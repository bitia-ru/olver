<?xml version="1.0" encoding="windows-1251"?>
<bugDB xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://unitesk.com/bugdb http://unitesk.com/bugdb/bugDB.xsd"
      xmlns="http://unitesk.com/bugdb"
      name="OLVER bug DB">

   <bug id="bug028(insque)">
    <pattern origin="util.search.insque_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && ( info.indexOf( "Connection closed" )!=-1 || info.endsWith( "Segmentation fault: Invalid memory address \'(nil)\'" )
            || info.endsWith( "Segmentation fault: Invalid permissions for memory at \'(nil)\'" ))
       && modelOperation.name
          == "insque_spec"
       && modelOperation.getParameterValue( "pred" )
          == "struct { 0, 0, 0 }"
       && getCoveredElementId( "C" ) == 1
      ]]>
    </pattern>
    <body>
        The insque(element, pred) function shall insert the element pointed to by
        element into a queue immediately after the element pointed to by pred.
		According to LSB, if the queue is to be used as a linear list, invoking
		insque(element, NULL), where element is the	initial element of the queue,
		shall initialize the forward and backward pointers of element to null pointers.
		But this function causes the segmentation fault if the second parameter is NULL.
		Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0028.
	</body>
  </bug>

   <bug id="bug207(basename)">
      <pattern origin="fs.name.basename_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("basename.01.01")
       && modelOperation.name
          == "basename_spec"
       && modelOperation.getParameterValue( "path" )
          == "err//"
       && modelOperation.returnValue == ""
       && getCoveredElementId( "C" ) == 4
      ]]>
      </pattern>
      <body>
		The basename() function shall take the pathname pointed to by path
		and return a pointer to the final component of the pathname,
		deleting any trailing '/' characters.
		But the input "err////" causes segmentation fault.
		Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0207.
	  </body>
   </bug>

   <bug id="bug342(slk_label)">
      <pattern origin="ncurses.slk.slk_label_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("slk_label.04;slk_label.05.01")
       && modelOperation.name
          == "slk_label_spec"
       && modelOperation.returnValue.matches("^\\s+.*|.*\\s+$")
      ]]>
      </pattern>
      <body>
		Upon successful completion, slk_label(labnum) function from ncurses library
		returns the requested label	with number labnum with leading and trailing
		blanks stripped.
		But on the target machine there are outputs with unstripped blanks.
		Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0342.
      </body>
   </bug>

   <bug id="bug357(keyname)">
      <pattern origin="ncurses.misc.keyname_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("keyname.05.01")
       && modelOperation.name
          == "keyname_spec"
       && modelOperation.returnValue.matches("^M\\-(\\^.|.)+$")
      ]]>
      </pattern>
      <body>
         The keyname() function generates a character string whose value describes the key
         specified as the argument of the functions.
         The meta-character notation in function keyname() from ncurses library, when running it
         with meta-character parameter, shall be used only if meta-characters are enabled
         (according to the LSB standard). But it is used irrespectively of enabling of
         meta-characters.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0357.
      </body>
   </bug>

  <bug id="bug313(mvcur)">
      <pattern origin="ncurses.move.mvcur_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("mvcur.04")
       && modelOperation.name
          == "mvcur_spec"
       && ( modelOperation.getParameterValue( "cursorPosNew" ) == "{ x=10000000, y=10000000 }"
         || modelOperation.getParameterValue( "cursorPosNew" ) == "{ x=-1000000, y=-1000000 }"
          )
      ]]>
      </pattern>
      <body>
         According to LSB, if screen position (newrow, newcol) is not a valid address for
         the terminal in use, mvcur(int xpos, int ypos) function call to this cursor position should fail
         (mvcur() is the function from Ncurses library that moves the cursor), but error doesn't occur on
         inputs (-1000000, -1000000), (10000000, 10000000).
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0313.
      </body>
   </bug>

  <bug id="bug329(chgat)">
      <pattern origin="ncurses.window.refresh_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("refresh.01;wrefresh.01")
       && modelOperation.name
          == "refresh_spec"
      ]]>
      </pattern>
      <body>
         Function chgat() is one from Ncurses library and it changes renditions (for example, color, bold,
         italic attributes etc.) of characters in a window.
         This function doesn't work if it is applied to the text that was output to the window and this
         window was refreshed. It still works if it is applied after the text was output to the window
         but before refresh() call. This behavior is unclear from standard.
         Additional information about this bug may be found at bug-ncurses@gnu.org, archive is
         http://www.nabble.com/chgat%28%29-function-does-not-work-correctly-after-refresh%28%29-tf3777004.html.
         This bug has been fixed since patch 20060715 for ncurses 5.5.
      </body>
   </bug>

  <bug id="bug319(ripoffline)">
      <pattern origin="ncurses.line.ripoffline_spec">
         <![CDATA[
          kind == SERIALIZATION_FAILED
       && interimFailures.size() == 1
       && modelOperationSeries.size() > 5
       && interimFailures.get(0).isRequirementFailed("ripoffline.09")
      ]]>
      </pattern>
      <property name="package">ncurses.line</property>
	  <property name="operationName">ripoffline_spec</property>
      <body>
         Function ripoffline() is one from Ncurses library and reserves one screen line for use by
         the application (for example, for menu). According to LSB,  up to five lines can be ripped off
         for use by the application and calls to ripoffline() above this limit have no effect but report
         success.
         But this function on sixth call returns error value -1. This contradicts the standard.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0319.
      </body>
   </bug>

  <bug id="bug443(strerror_r)">
      <pattern origin="locale.messages.strerror_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
          && modelOperation.name == "strerror_spec"
          && modelOperation.getParameterValue( "@strerrbuf" ) == "<NULL>"
          && isRequirementFailed("strerror_r.01")
      ]]>
      </pattern>
      <body>
         According to LSB, the strerror_r() function shall return a pointer to the string corresponding to errno
         and shall place the string with description of the error in the buffer, specified as argument of
         the strerror_r() function.
         But in this buffer no valid error description string was found.
         The problem is a consequence of a bug in LSB SDK,
         which is registered at http://bugs.linuxbase.org/show_bug.cgi?id=1256.
         It was fixed in LSB 3.2.
      </body>
   </bug>

  <bug id="bug177(getgrouplist)">
      <pattern origin="system.user.getgrouplist_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
          && modelOperation.name == "getgrouplist_spec"
          && modelOperation.returnValue == "1"
          && isRequirementFailed("getgrouplist.07.01")
      ]]>
      </pattern>
      <body>
          The getgrouplist() function shall fill in the supplied array with the supplementary groups for the
          specified user. According to LSB, if such user doesn't exist function shall return 0.
          But it returns 1 on the system under test.
          Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0177.
      </body>
   </bug>


  <bug id="bug525(getgrouplist)">
      <pattern origin="system.user.getgrouplist_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
          && modelOperation.name == "getgrouplist_spec"
          && (modelOperation.getParameterValue("ngroups") != modelOperation.getParameterValue("@ngroups"))
          && isRequirementFailed("getgrouplist.06.02")
      ]]>
      </pattern>
      <body>
         The getgrouplist() function shall fill in the supplied array with the supplementary groups
         for the specified user and update its parameter to contain the number of  groups copied.
         According to LSB, if there was not sufficient room to copy all the supplementary group
         identifiers, getgrouplist() shall return -1, and update the value referenced by this parameter
         to the number actually copied.
		 But on the target machine this parameter was set to the value, greater then array size.
		 Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0525.
      </body>
   </bug>


   <bug id="bug498_1(sigandset)">
    <pattern origin="signal.sigset.sigandset_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf( "Segmentation fault: Invalid memory address" ) != -1 || info.indexOf( "Connection closed" )!=-1 || info.indexOf("Segmentation fault: Invalid permissions for memory at")!=-1)
       && modelOperation.name
          == "sigandset_spec"
       && ( modelOperation.getParameterValue( "left" ) == "struct SigSetTPtr { system=0, process=0, address=0 }" ||  modelOperation.getParameterValue( "right" ) == "struct SigSetTPtr { system=0, process=0, address=0 }" || modelOperation.getParameterValue( "set" ) == "struct SigSetTPtr { system=0, process=0, address=0 }" )
      ]]>
    </pattern>
    <body>
       The sigandset() shall combine the two signal sets (specified as arguments) using a logical AND
       operation and shall place the result in the location supplied as the third argument.
       According to LSB, if one or more of the function arguments is NULL then it shall cause
       EINVAL error.
       But it causes crash on the target machine.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0498.
    </body>
  </bug>

   <bug id="bug498_2(sigorset)">
    <pattern origin="signal.sigset.sigorset_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf( "Segmentation fault: Invalid memory address" ) != -1 || info.indexOf( "Connection closed" )!=-1|| info.indexOf("Segmentation fault: Invalid permissions for memory at")!=-1)
       && modelOperation.name
          == "sigorset_spec"
       && ( modelOperation.getParameterValue( "left" ) == "struct SigSetTPtr { system=0, process=0, address=0 }" ||  modelOperation.getParameterValue( "right" ) == "struct SigSetTPtr { system=0, process=0, address=0 }" || modelOperation.getParameterValue( "set" ) == "struct SigSetTPtr { system=0, process=0, address=0 }" )
      ]]>
    </pattern>
    <body>
       The sigorset() shall combine the two signal sets (specified as arguments) using a logical OR
       operation and shall place the result in the location supplied as the third argument.
       According to LSB, if one or more of the function arguments is NULL then it shall cause
       EINVAL error.
       But it causes crash on the target machine.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0498.
    </body>
  </bug>

   <bug id="bug498_3(sigisemptyset)">
    <pattern origin="signal.sigset.sigisemptyset_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf( "Segmentation fault: Invalid memory address" ) != -1 || info.indexOf("Segmentation fault: Invalid permissions for memory at")!=-1)
       && modelOperation.name
          == "sigisemptyset_spec"
       && modelOperation.getParameterValue( "set" ) == "struct SigSetTPtr { system=0, process=0, address=0 }"
      ]]>
    </pattern>
    <body>
       The sigisemptyset() shall check its argument for empty signal set.
       According to LSB, if argument is NULL then it shall cause  EINVAL error.
       But it causes crash on the target machine.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0498.
    </body>
  </bug>

   <bug id="bug504(sched_setscheduler)">
    <pattern origin="process.scheduler.sched_setscheduler_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("sched_setscheduler.22.01")
       && modelOperation.name ==
          "sched_setscheduler_spec"
       && modelOperation.returnValue == "0"
       ]]>
    </pattern>
    <body>
       The sched_setscheduler() function shall set the scheduling policy and scheduling parameters of the
       specified process. According to LSB, upon successful completion, the function shall return the former
       scheduling policy of the specified process.
       But it always returns 0 on the target machine.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0504.
    </body>
   </bug>

   <bug id="bug522(mmap)">
    <pattern origin="memory.mman.mmap_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && modelOperation.name == "mmap_spec"
       && ( modelOperation.getParameterValue("len") == "0" )
       && isRequirementFailed("mmap.53.04;mmap64.mmap.53.04;mmap.10;mmap64.mmap.10")
      ]]>
    </pattern>
    <body>
       The mmap() function shall establish a mapping between a process' address space and a file,
       shared memory object, or typed memory object. The length of the mapping is set up by
       function parameter.
       According to LSB, if this parameter equals to zero then function shall cause EINVAL error.
       But it returns success on the target machine.
       The bug was fixed in libc 2.4.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0522.
    </body>
  </bug>

   <bug id="bug520_1(getdate)">
    <pattern origin="">
      <![CDATA[
          kind == SCENARIO_FUNCTION_FAILED
       && ( isRequirementFailed( "getdate.07.07" ) || isRequirementFailed( "getdate.07.08" ) || isRequirementFailed( "getdate.07.10" )
            || isRequirementFailed( "getdate.07.15" ) || isRequirementFailed( "getdate.07.17" ) || isRequirementFailed( "getdate.07.20" ) || isRequirementFailed( "getdate.07.26" )
            || isRequirementFailed( "getdate.07.27" ) || isRequirementFailed( "getdate.08" ) || isRequirementFailed( "getdate.15.03.02" ))
       && transitionName  == "util_format_getdate_scen"
      ]]>
    </pattern>
    <property name="package">util.format</property>
	<property name="operationName">getdate_spec</property>
    <body>
       The getdate() function shall convert a string representation of a date or time into a broken-down time
       according to conversion specification.
       But on the target machine it is detected incorrect processing of conversion patterns
       %S, %M, %p, %y, %Y, %d, %C.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0520_1.
    </body>
  </bug>

   <bug id="bug377(stime)">
    <pattern origin="time.time.stime_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "stime_spec"
           && ( modelOperation.getParameterValue("errno") != "EINVAL" )
           && getCoveredElementId( "C_T" ) == 0
           && isRequirementFailed("stime.03.02")
      ]]>
    </pattern>
    <body>
       The stime() function shall set the system's idea of the time and date to the time
       referenced by function argument. According to LSB, if this argument is NULL then
       stime() shall set error code to EINVAL.
       But it sets error code to EFAULT instead of EINVAL.
       The bug was fixed in libc 2.4.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0377.
    </body>
  </bug>

<!--
-->
   <bug id="bug488(errx)">
    <pattern origin="util.assert.err_processTerminated">
      <![CDATA[
          kind == SERIALIZATION_FAILED
          &&  interimFailures.get(0).kind == POSTCONDITION_FAILED
          &&  interimFailures.get(0).modelOperation.name == "err_processTerminated"
          &&  interimFailures.get(0).isRequirementFailed("errx.41")
      ]]>
    </pattern>
    <property name="package">util.assert</property>
    <property name="operationName">errx_spec</property>
    <body>
       The errx() function shall display a formatted error message on the standard error stream.
       According to LSB, the formatted error message, the last component of the program name, a colon
       character, a space and a newline character shall be output.
       But on the target machine colon character, and a space are not output after the formatted error
       message.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0488.
    </body>
  </bug>

   <bug id="bug558(timer_create)">
    <pattern origin="time.timer.timer_create_spec">
      <![CDATA[
          kind == SERIALIZATION_FAILED                                          &&
          interimFailures.get(0).kind == POSTCONDITION_FAILED                   &&
          ( interimFailures.get(0).isRequirementFailed("timer_create.08.02") ||
            interimFailures.get(0).isRequirementFailed("timer_create.09.03")
          )                                                                      &&
          interimFailures.get(0).modelOperation.name ==
              "timer_create_spec"
      ]]>
    </pattern>
    <property name="package">time.timer</property>
    <property name="operationName">timer_create_spec</property>
    <body>
       The timer_create() function shall create a per-process timer using the specified
       clock, clock_id, as the timing base.
       But call to timer_create with clock_id received from clock_getcpuclockid() cause
       an error EINVAL on the target machine.
       The bug was fixed in libc 2.4.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0558.
    </body>
  </bug>

   <bug id="bug489(verrx)">
    <pattern origin="util.assert.err_processTerminated">
      <![CDATA[
          kind == SERIALIZATION_FAILED
          &&  interimFailures.get(0).kind == POSTCONDITION_FAILED
          &&  interimFailures.get(0).isRequirementFailed("verrx.41")
          &&  interimFailures.get(0).modelOperation.name == "err_processTerminated"
      ]]>
    </pattern>
    <property name="package">util.assert</property>
    <property name="operationName">verrx_spec</property>
    <body>
       The verrx() function shall display a formatted error message on the standard error stream.
       According to LSB, the formatted error message, the last component of the program name, a colon
       character, a space and a newline character shall be output.
       But on the target machine colon character, and a space are not output after the formatted error
       message.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0488.
    </body>
  </bug>

   <bug id="bug486(warnx)">
    <pattern origin="util.assert.warnx_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "warnx_spec"
           && ( modelOperation.getParameterValue("fmt") != "" )
           && ( !modelOperation.getParameterValue("errput").endsWith(":\n"))
           && ( modelOperation.getParameterValue("errput").endsWith("\n"))
           && info.endsWith("Requirement failed: {} Check output")
      ]]>
    </pattern>
    <body>
       The warnx() function shall display a formatted error message on the standard error stream.
       According to LSB, the formatted error message, the last component of the program name, a colon
       character, a space and a newline character shall be output.
       But on the target machine colon character, and a space are not output after the formatted error
       message.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0488.
    </body>
  </bug>

   <bug id="bug83(setegid)">
    <pattern origin="process.meta.setegid_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "setegid_spec"
           && isRequirementFailed("setegid.05.02")
           && ( modelOperation.getParameterValue("errno") == "EPERM" )
           && ( modelOperation.returnValue == "-1" )
      ]]>
    </pattern>
    <body>
       The setegid() function sets the effective group ID of the calling process to the value,
       specified as its argument.
       According to LSB, if this argument equals to the real group ID or the saved set-group-ID,
       or if the process has appropriate privileges, setegid() shall set the effective group ID
       to this value.
       But on the target machine setegid() fails when trying to set effective group ID to the
       saved set-group-ID value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0102.
    </body>
  </bug>

   <bug id="bug82(seteuid)">
    <pattern origin="process.meta.seteuid_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "seteuid_spec"
           && isRequirementFailed("seteuid.05.02")
           && ( modelOperation.getParameterValue("errno") == "EPERM" )
           && ( modelOperation.returnValue == "-1" )
      ]]>
    </pattern>
    <body>
       The seteuid() function sets the effective user ID of the calling process to the value,
       specified as its argument.
       According to LSB, if this argument equals to the real user ID or the saved set-user-ID,
       or if the process has appropriate privileges, seteuid() shall set the effective user ID
       to this value.
       But on the target machine seteuid() fails when trying to set effective user ID to the
       saved set-user-ID value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0102.
    </body>
  </bug>

   <bug id="bug104(setgid)">
    <pattern origin="process.meta.setgid_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "setgid_spec"
           && isRequirementFailed("setgid.06.02")
           && ( modelOperation.getParameterValue("errno") == "EPERM" )
           && ( modelOperation.returnValue == "-1" )
      ]]>
    </pattern>
    <body>
       The setgid() function sets the real group ID, effective group ID, and the saved set-group-ID
       of the calling process to the value, specified as its argument.
       According to LSB, if this argument equals to the real group ID or the saved set-group-ID,
       setgid() shall set the effective group ID to this value.
       But on the target machine setgid() fails when trying to set the effective group ID to the
       saved set-group-ID value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0102.
    </body>
  </bug>

  <bug id="bug106(setregid)">
    <pattern origin="process.meta.setregid_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "setregid_spec"
           && isRequirementFailed("setregid.07.02")
           && ( modelOperation.getParameterValue("errno") == "EPERM" )
           && ( modelOperation.returnValue == "-1" )
      ]]>
    </pattern>
    <body>
       The setregid() function shall set the real and effective group IDs of the calling process
       to the value, specified as its argument.
       According to LSB, if this argument equals to the saved set-group-ID, setregid() shall always
       be successful to set the real group ID to this value.
       But on the target machine setregid() fails when trying to set the real group ID to the
       saved set-group-ID value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0102.
    </body>
  </bug>

  <bug id="bug103(setreuid)">
    <pattern origin="process.meta.setreuid_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "setreuid_spec"
           && isRequirementFailed("setreuid.06.02")
           && ( modelOperation.getParameterValue("errno") == "EPERM" )
           && ( modelOperation.returnValue == "-1" )
      ]]>
    </pattern>
    <body>
       The setreuid() function shall set the real and effective user IDs of the calling process
       to the value, specified as its argument.
       According to LSB, if this argument equals to the saved set-user-ID, setreuid() shall always
       be successful to set the real user ID to this value.
       But on the target machine setreuid() fails when trying to set the real user ID to the
       saved set-user-ID value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0102.
    </body>
  </bug>

  <bug id="bug102(setuid)">
    <pattern origin="process.meta.setuid_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "setuid_spec"
           && isRequirementFailed("setuid.05.02")
           && ( modelOperation.getParameterValue("errno") == "EPERM" )
           && ( modelOperation.returnValue == "-1" )
      ]]>
    </pattern>
    <body>
       The setuid() function sets the real user ID, effective user ID, and the saved set-user-ID
       of the calling process to the value, specified as its argument.
       According to LSB, if this argument equals to the real user ID or the saved set-user-ID,
       setuid() shall set the effective user ID to this value.
       But on the target machine setuid() fails when trying to set the effective user ID to the
       saved set-user-ID value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0102.
    </body>
  </bug>

  <bug id="bug380(asctime)">
    <pattern origin="time.conversion.asctime_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "asctime_spec"
           && isRequirementFailed("asctime.01")
           && ( modelOperation.returnValue.indexOf("???")!=-1 )
      ]]>
    </pattern>
    <body>
       The asctime() function converts date and time to a string and returns it.
       According to LSB, if the function is unsuccessful, it should return NULL,
       But on the target machine it returns a string with '?' symbols, for
       example "??? Oct  9 09:09:09 1909".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0379.
    </body>
  </bug>

  <bug id="bug379(asctime_r)">
    <pattern origin="time.conversion.asctime_r_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "asctime_r_spec"
           && isRequirementFailed("asctime_r.01")
           && ( modelOperation.returnValue.indexOf("???")!=-1 )
      ]]>
    </pattern>
    <body>
       The asctime_r() function converts date and time to a string and returns it.
       According to LSB, if the function is unsuccessful, it should return NULL,
       But on the target machine it returns a string with '?' symbols, for
       example "??? Oct  9 09:09:09 1909".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0379.
    </body>
  </bug>

  <bug id="bug167(ulimit)">
    <pattern origin="process.resources.ulimit_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name	== "ulimit_spec"
           && isRequirementFailed("ulimit.02")
           && modelOperation.returnValue == "0"
      ]]>
    </pattern>
    <body>
       The ulimit() function shall control process limits. The process limits that can be controlled
       by this function include the maximum size of a single file that can be written.
       According to LSB, the return value shall be the integer part of the soft file size
       limit divided by 512.
       But on the target machine the function always returns 0 upon successful completion.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0167.
    </body>
  </bug>

    <bug id="bug527(getdate)">
    <pattern origin="util.format.getdate_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf( "Segmentation fault: Invalid memory address" ) != -1)
       && modelOperation.name == "getdate_spec"
       && modelOperation.getParameterValue("@str") == "19"
      ]]>
    </pattern>
    <body>
      The getdate() function shall convert a string representation of a date or time into a broken-down time
      structure using template.
	  On the target machine if this template is '%C' then getdate() crashes.
      Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0520_1.
    </body>
  </bug>

  <bug id="bug523(clock_getres)">
    <pattern origin="time.clock.clock_getres_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && ( info.endsWith("Segmentation fault: Invalid memory address \'(nil)\'") || info.endsWith("Segmentation fault: Invalid permissions for memory at \'(nil)\'") )
       && modelOperation.name == "clock_getres_spec"
       && modelOperation.getParameterValue("@res") == "<NULL>"
      ]]>
    </pattern>
    <body>
       The clock_getres() function shall return the resolution of any clock and write this
       value to the second parameter.
       According to LSB, if this parameter is NULL then the clock resolution is not returned.
       But on the target machine clock_getres() crashes if second parameter is NULL.
       The bug was fixed in libc 2.4.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0523.
    </body>
  </bug>


  <bug id="bug524_1(scanw)">
    <pattern origin="ncurses.string.scanw_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "scanw_spec"
           && isRequirementFailed("scanw.03.02")
           && modelOperation.returnValue != "-1"
           && modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
       According to the standard, upon successful completion, scanw() function from Ncurses
       library shall return OK(0), otherwise, it shall return ERR(-1).
       But on the target machine, the function scanw() returned 1 when it is called  with first argument "  %i".
       Bug was added to linuxtesting.ru as bug number S0524.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0524.
    </body>
  </bug>

  <bug id="bug524_2(vw_scanw)">
    <pattern origin="ncurses.string.vw_scanw_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "vw_scanw_spec"
           && (isRequirementFailed("vw_scanw.03.02"))
           && modelOperation.returnValue != "-1"
           && modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
       According to the standard, upon successful completion, vw_scanw() function from Ncurses
       library shall return OK(0), otherwise, it shall return ERR(-1).
       But on the target machine, the function  vw_scanw() returned 1 when it is called with first argument "  %i".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0524.
    </body>
  </bug>

  <bug id="bug524_3(vwscanw)">
    <pattern origin="ncurses.string.vwscanw_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "vwscanw_spec"
           && ((isRequirementFailed("vwscanw.03.02")) || isRequirementFailed("vwscanw.mvscanw.03.02"))
           && modelOperation.returnValue != "-1"
           && modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
       According to the standard, upon successful completion, vwscanw() function from Ncurses
       library shall return OK(0), otherwise, it shall return ERR(-1).
       But on the target machine, the function vwscanw() returned 1 when it is called with first argument "  %i".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0524.
    </body>
  </bug>

  <bug id="bug524_4(mvwscanw)">
    <pattern origin="ncurses.string.scanw_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "scanw_spec"
           && isRequirementFailed("mvwscanw.03.02")
           && modelOperation.returnValue != "-1"
           && modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
       According to the standard, upon successful completion, mvwscanw() function from Ncurses
       library shall return OK(0), otherwise, it shall return ERR(-1).
       But on the target machine, the function mvwscanw() returned 1 when it is called  with fmt argument "  %i".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0524.
    </body>
  </bug>

  <bug id="bug524_5(mvscanw)">
    <pattern origin="ncurses.string.scanw_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "scanw_spec"
           && isRequirementFailed("mvscanw.03.02")
           && modelOperation.returnValue != "-1"
           && modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
       According to the standard, upon successful completion, mvscanw() function from Ncurses
       library shall return OK(0), otherwise, it shall return ERR(-1).
       But on the target machine, the function mvscanw() returned 1 when it is called  with fmt argument "  %i".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0524.
    </body>
  </bug>

  <bug id="bug524_6(wscanw)">
    <pattern origin="ncurses.string.scanw_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name
              == "scanw_spec"
           && isRequirementFailed("wscanw.03.02")
           && modelOperation.returnValue != "-1"
           && modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
       According to the standard, upon successful completion, wscanw() function from Ncurses
       library shall return OK(0), otherwise, it shall return ERR(-1).
       But on the target machine, the function wscanw() returned 1 when it is called  with fmt argument "  %i".
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0524.
    </body>
  </bug>

  <bug id="bug506(vswprintf)">
    <pattern origin="util.format.vswprintf_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name == "vswprintf_spec"
           && isRequirementFailed("vswprintf.05.02")
           && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       According to LSB,  on error vswprintf() function shall return -1 and set errno global variable.
       On the target machine,  vswprintf() function returns -1, but doesn't set error code in errno
       global variable. This contradicts LSB standard for this function.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0505.
    </body>
  </bug>

  <bug id="bug505(swprintf)">
    <pattern origin="util.format.swprintf_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
           && modelOperation.name == "swprintf_spec"
           && isRequirementFailed("swprintf.05.02")
           && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       According to LSB,  on error swprintf() function shall return -1 and set errno global variable.
       On the target machine,  swprintf() function returns -1, but doesn't set error code in errno
       global variable. This contradicts LSB standard for this function.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0505.
    </body>
  </bug>

  <bug id="bug561(wcsftime)">
    <pattern origin="">
      <![CDATA[
          kind == SCENARIO_FUNCTION_FAILED
       && isRequirementFailed( "wcsftime.strftime.11.35" )
       && transitionName == "util_format_wtime_scen"
      ]]>
    </pattern>
    <property name="package">util.format</property>
	<property name="operationName">wcsftime_spec</property>
    <body>
       %z Replaced by the offset from UTC in the ISO 8601:2000 standard format,
       or by no characters if no timezone is determinable; depending on the field tm_isdst in tm structure.
       But on the target machine it is detected incorrect processing of this conversion pattern
       when tm_isdst is set to a positive number - no daylight savings time offset is used.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0561.
    </body>
  </bug>

<!-- Bugs in mathematics -->
   <bug id="bug548(pow)">
    <pattern origin="math.exp.pow_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("pow.27.01.01;powf.27.01.01;powl.27.01.01" )
       && modelOperation.name == "pow_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
       && (getCoveredElementId( "C" ) == 4)
      ]]>
    </pattern>
    <body>
       The pow(x, y) family of functions shall compute the value of x raised to the power y.
       According to LSB, if x is +-0 and y is negative infinity +Inf shall be retuned
       an no error shall occur.
       But on the target machine pow() returns EDOM error in this case.
    </body>
  </bug>

   <bug id="bug549(pow)">
    <pattern origin="math.exp.pow_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("pow.26") || isRequirementFailed("powf.26") || isRequirementFailed("powl.26"))
       && modelOperation.name == "pow_spec"
       && modelOperation.getParameterValue( "errno" ) == "ERANGE"
      ]]>
    </pattern>
    <body>
       The pow(x, y) family of functions shall compute the value of x raised to the power y.
       According to LSB, if the correct value would cause underflow, and is representable,
       a range error may occur and the correct value shall be returned.
       But on the target machine this function returns 0 when the correct result underflows but
       is still representable.
       Bug was added to linuxtesting.ru as bug number S0549.
    </body>
  </bug>

   <bug id="bug550(ilogb)">
    <pattern origin="util.float.ilogb_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("ilogb.10.01.01;ilogbf.10.01.01;ilogbl.10.01.01")
       && modelOperation.name == "ilogb_spec"
       && modelOperation.getParameterValue("errno") == "ERANGE"
       && (getCoveredElementId( "C" ) == 2)
      ]]>
    </pattern>
    <body>
       The ilogb() family of functions shall return the exponent part of its argument.
       According to LSB, it shall set error code to EDOM when computing radix-independent
       exponent of +0 or -0.
       But on the target machine ilogb() sets error code ERANGE in this case.
     </body>
  </bug>

   <bug id="bug551(logb)">
    <pattern origin="util.float.logb_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("logb.08.01.01;logbf.08.01.01;logbl.08.01.01")
       && modelOperation.name == "logb_spec"
       && modelOperation.getParameterValue("errno") == "EDOM"
      ]]>
    </pattern>
    <body>
       The logb() family of functions shall compute the exponent of x, which is the integral part of log |x|, as a
       signed floating-point value.
       According to LSB, it shall set error code to ERANGE when computing exponent of +0 or -0.
       But on the target machine logb() sets error code EDOM in this case.
    </body>
  </bug>

   <bug id="bug424(nexttoward)">
    <pattern origin="util.float.nexttoward_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("nexttoward.04") )
       && modelOperation.name == "nexttoward_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The nexttoward(x, y) function shall compute the next representable floating-point value following
       x in the direction of y.
       The function gives incorrect result on the input (3fffffff ffffffff, 3fffffffffff ffffffff).
    </body>
  </bug>

   <bug id="bug513(j0)">
    <pattern origin="math.bessel.j0_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("j0.04") || isRequirementFailed("j0f.j0.04") || isRequirementFailed("j0l.j0.04"))
       && modelOperation.name == "j0_spec"
      ]]>
    </pattern>
    <body>
       The j0() function is Bessel function of the first kind.
       At the specified point the inaccuracy of the result is more then 20 bits from the
       end of the floating point number.
    </body>
  </bug>

   <bug id="bug513(j1)">
    <pattern origin="math.bessel.j1_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("j1.04") || isRequirementFailed("j1f.j1.04") || isRequirementFailed("j1l.j1.04"))
       && modelOperation.name == "j1_spec"
      ]]>
    </pattern>
    <body>
       The j1() function is Bessel function of the first kind.
       At the specified point the inaccuracy of the result is more then 20 bits from the
       end of the floating point number.
    </body>
  </bug>

   <bug id="bug513(jn)">
    <pattern origin="math.bessel.jn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("jn.04") || isRequirementFailed("jnf.jn.04") || isRequirementFailed("jnl.jn.04"))
       && modelOperation.name == "jn_spec"
      ]]>
    </pattern>
    <body>
       The jn() function is Bessel function of the first kind.
       At the specified point the inaccuracy of the result is more then 20 bits from the
       end of the floating point number.
    </body>
  </bug>

   <bug id="bug512(y0)">
    <pattern origin="math.bessel.y0_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("y0.10.02.01") || isRequirementFailed("y0f.y0.10.02.01") || isRequirementFailed("y0l.y0.10.02.01"))
       && modelOperation.name == "y0_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
      ]]>
    </pattern>
    <body>
       The y0() function is Bessel function of the second kind.
       According to LSB, if the value of the argument is zero then ERANGE
       error shall occur.
       But on the target machine the function sets error code EDOM
       instead of ERANGE on an input 0.
    </body>
  </bug>

   <bug id="bug513(y0)">
    <pattern origin="math.bessel.y0_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("y0.04") || isRequirementFailed("y0f.y0.04") || isRequirementFailed("y0l.y0.04"))
       && modelOperation.name  == "y0_spec"
      ]]>
    </pattern>
    <body>
       The y0() function is Bessel function of the second kind.
       At the specified point the inaccuracy of the result is more then 20 bits from the
       end of the floating point number.
     </body>
  </bug>

   <bug id="bug512_1(y1)">
    <pattern origin="math.bessel.y1_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("y1.10.02.01;y1f.y1.10.02.01;y1l.y1.10.02.01")
       && modelOperation.name  == "y1_spec"
      ]]>
    </pattern>
    <body>
       The y1() function is Bessel function of the second kind.
       According to LSB, if the value of the argument is zero then ERANGE
       error shall occur.
       But on the target machine the function sets error code EDOM
       instead of ERANGE on an input 0.
     </body>
  </bug>

   <bug id="bug513(y1)">
    <pattern origin="math.bessel.y1_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("y1.04") || isRequirementFailed("y1f.y1.04") || isRequirementFailed("y1l.y1.04"))
       && modelOperation.name  == "y1_spec"
      ]]>
    </pattern>
    <body>
       The y1() function is Bessel function of the second kind.
       At the specified point the inaccuracy of the result is more then 20 bits from the
       end of the floating point number.
    </body>
  </bug>

   <bug id="bug512_1(yn)">
    <pattern origin="math.bessel.yn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("yn.10.02.01;ynf.yn.10.02.01;ynl.yn.10.02.01")
       && modelOperation.name == "yn_spec"
      ]]>
    </pattern>
    <body>
       The yn() function is Bessel function of the second kind.
       According to LSB, if the value of the argument is zero then ERANGE
       error shall occur.
       But on the target machine the function sets error code EDOM
       instead of ERANGE on an input 0.
    </body>
  </bug>

   <bug id="bug513(yn)">
    <pattern origin="math.bessel.yn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("yn.04") || isRequirementFailed("ynf.yn.04") || isRequirementFailed("ynl.yn.04"))
       && modelOperation.name == "yn_spec"
      ]]>
    </pattern>
    <body>
       The yn() function is Bessel function of the second kind.
       At the specified point the inaccuracy of the result is more then 20 bits from the
       end of the floating point number.
    </body>
  </bug>

   <bug id="bug516(yn)">
    <pattern origin="math.bessel.yn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("yn.09") || isRequirementFailed("ynf.yn.09") || isRequirementFailed("ynl.yn.09"))
       && modelOperation.name == "yn_spec"
      ]]>
    </pattern>
    <body>
       The yn() function is Bessel function of the second kind.
       At the specified point, when overflow occured, function return NaN instead of 0 or -Infinity
       according to LSB.
    </body>
  </bug>

   <bug id="bug516_1(jn)">
    <pattern origin="math.bessel.jn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("jn.09.03") || isRequirementFailed("jn.09.02") || isRequirementFailed("jn.09.01"))
       && modelOperation.name == "jn_spec"
      ]]>
    </pattern>
    <body>
       The jn() function is Bessel function of the first kind.
       At the specified point function return -0 instead of 0
       according to LSB.
    </body>
  </bug>

     <bug id="bug516_2(jn)">
    <pattern origin="math.bessel.jn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("jn.11")
       && modelOperation.name == "jn_spec"
      ]]>
    </pattern>
    <body>
       The jn() function is Bessel function of the first kind.
       At the specified point function return value with the wrong sign.
    </body>
  </bug>

   <bug id="bug512(sin)">
    <pattern origin="math.trig.sin_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("sin.09.01.01;sinf.09.01.01;sinl.09.01.01" )
       && modelOperation.name == "sin_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The sin() family of functions shall compute the sine of their argument, measured in radians.
       According to LSB, if the x is +-Inf then the function shall fail with EDOM error.
       But on the target machine sin() sets error code EOK instead of EDOM on infinity.
    </body>
  </bug>

   <bug id="bug512(cos)">
    <pattern origin="math.trig.cos_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("cos.08.01.01;cosf.08.01.01;cosl.08.01.01" )
       && modelOperation.name == "cos_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The cos() family of functions shall compute the cosine of their argument, measured in radians.
       According to LSB, if the x is +-Inf then the function shall fail with EDOM error.
       But on the target machine cos() sets error code EOK instead of EDOM on infinity.
    </body>
  </bug>

   <bug id="bug512(tan)">
    <pattern origin="math.trig.tan_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("tan.12.01.01;tanf.12.01.01;tanl.12.01.01" )
       && modelOperation.name == "tan_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The tan() family of functions shall compute the tangent of their argument, measured in radians.
       According to LSB, if the x is +-Inf then the function shall fail with EDOM error.
       But on the target machine tan() sets error code EOK instead of EDOM on infinity.
    </body>
  </bug>

   <bug id="bug513(sin)">
    <pattern origin="math.trig.sin_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("sin.04" ) || isRequirementFailed("sinl.04" ) )
       && modelOperation.name == "sin_spec"
      ]]>
    </pattern>
    <body>
       At the specified point the inaccuracy of the result of sin()  family of functions  is more then
       20 bits from the end of the floating point number.
    </body>
  </bug>

   <bug id="bug513(tan)">
    <pattern origin="math.trig.tan_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("tan.04" ) || isRequirementFailed("tanl.04" ))
       && modelOperation.name == "tan_spec"
      ]]>
    </pattern>
    <body>
       At the specified point the inaccuracy of the result of tan() family of functions is more then
       20 bits from the end of the floating point number.
    </body>
  </bug>

   <bug id="bug513(atan)">
    <pattern origin="math.trig.atan_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("atan.04" ) || isRequirementFailed("atanl.04") || isRequirementFailed("atanf.04" ))
       && modelOperation.name == "atan_spec"
      ]]>
    </pattern>
    <body>
       At the specified point the inaccuracy of the result of atan() family of functions is more then
       20 bits from the end of the floating point number.
    </body>
  </bug>

   <bug id="bug513(cos)">
    <pattern origin="math.trig.cos_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("cos.04" ) || isRequirementFailed("cosl.04" ) || isRequirementFailed("cosf.04" ))
       && modelOperation.name == "cos_spec"
      ]]>
    </pattern>
    <body>
       At the specified point the inaccuracy of the result of cos() family of functions is more then
       20 bits from the end of the floating point number.
    </body>
  </bug>

   <bug id="bug513(sincos)">
    <pattern origin="math.trig.sincos_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && ( isRequirementFailed("sincos.01;sincos.02" ) || isRequirementFailed("sincosl.01;sincosl.02" ) )
       && modelOperation.name == "sincos_spec"
      ]]>
    </pattern>
    <body>
       The sincos() family of functions calculates sin and cos simultaneously.
       At the specified point the inaccuracy of the result of sincos() function is more then
       20 bits from the end of the floating point number.
    </body>
  </bug>

   <bug id="bug512(lgamma)">
    <pattern origin="math.gamma.lgamma_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "lgamma.13.01.01;lgammaf.13.01.01;lgammal.13.01.01;lgamma.13.02.01;lgammaf.13.02.01;lgammal.13.02.01" )
       && modelOperation.name == "lgamma_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
      ]]>
    </pattern>
    <body>
       According to LSB, lgamma(x) family of functions shall set error code to ERANGE if x argument is
       negative integer or zero.
       But on the target machine the functions sets error code EDOM instead of ERANGE on
       zero argument.
    </body>
  </bug>

   <bug id="bug512(lgamma_r)">
    <pattern origin="math.gamma.lgamma_r_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "lgamma_r.13.01.01;lgammaf_r.13.01.01;lgammal_r.13.01.01;lgamma_r.13.02.01;lgammaf_r.13.02.01;lgammal_r.13.02.01" )
       && modelOperation.name == "lgamma_r_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
      ]]>
    </pattern>
    <body>
      According to LSB, lgamma_r(x) family of functions shall set error code to ERANGE if x argument is
      negative integer or zero.
      But on the target machine the functions sets error code EDOM instead of ERANGE on
      zero argument.
    </body>
  </bug>

   <bug id="bug516(lgamma)">
    <pattern origin="math.gamma.lgamma_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && ( isRequirementFailed( "lgamma.08") || isRequirementFailed("lgammaf.08") || isRequirementFailed("lgammal.08" ))
       && modelOperation.name == "lgamma_spec"
      ]]>
    </pattern>
    <body>
       According to LSB, lgamma(x) family of functions shall return +HUGE_VAL if
       x is a non-positive integer.
       But on the target machine the functions don't return +HUGE_VAL if the argument
       is not positive.
    </body>
  </bug>

  <bug id="bug518_3(nextafter)">
    <pattern origin="util.float.nextafter_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("nextafter.10.01.01;nextafterf.10.01.01;nextafterl.10.01.01;nextafter.10.02.01;nextafterf.10.02.01;nextafterl.10.02.01")
       && modelOperation.name == "nextafter_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The nextafter(x, y) family of functions functions shall compute the next representable
       floating-point value following x in the direction of y.
       According to LSB, if the correct value is subnormal or underflows then ERANGE error code
       shall be set.
       But on the target machine the function sets error code EOK instead of ERANGE.
    </body>
  </bug>

   <bug id="bug518_4(nexttoward)">
    <pattern origin="util.float.nexttoward_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("nexttoward.09.01.01;nexttowardf.09.01.01;nexttowardl.09.01.01;nexttoward.09.02.01;nexttowardf.09.02.01;nexttowardl.09.02.01")
       && modelOperation.name == "nexttoward_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The nexttoward(x, y) family of functions functions shall compute the next representable
       floating-point value following x in the direction of y.
       According to LSB, if the correct value is subnormal or underflows then ERANGE error code
       shall be set.
       But on the target machine the function sets error code EOK instead of ERANGE.
    </body>
  </bug>

   <bug id="bug516(tgamma)">
    <pattern origin="math.gamma.tgamma_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && ( isRequirementFailed("tgamma.05" ) || isRequirementFailed("tgammaf.05" ) || isRequirementFailed("tgammal.05" ))
       && modelOperation.name == "tgamma_spec"
      ]]>
    </pattern>
    <body>
       The tgamma(x) family of functions shall compute the mathematical gamma() function of x.
       According to LSB, if x is a negative integer NaN shall be returned.
       But on the target machine, the functions don't return NaN if the argument is negative.
    </body>
  </bug>

   <bug id="bug512(tgamma)">
    <pattern origin="math.gamma.tgamma_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("tgamma.11.01.01;tgammaf.11.01.01;tgammal.11.01.01" )
       && modelOperation.name == "tgamma_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The tgamma(x) family of functions shall compute the mathematical gamma() function of x.
       According to LSB, if x is negative infinity then a domain error shall occur and error
       code shall be set to EDOM.
       But on the target machine, the functions set error code EOK instead of EDOM.
    </body>
  </bug>

   <bug id="bug553(tgamma)">
    <pattern origin="math.gamma.tgamma_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("tgamma.11.02.01;tgamma.11.03.01;tgammaf.11.02.01;tgammaf.11.03.01;tgammal.11.02.01;tgammal.11.03.01" )
       && modelOperation.name == "tgamma_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
      ]]>
    </pattern>
    <body>
       The tgamma(x) family of functions shall compute the mathematical gamma() function of x.
       According to LSB, if x is zero then pole error shall occur and error code shall
       be set to ERANGE.
       But on the target machine, the functions set error code EDOM instead of ERANGE.
    </body>
  </bug>

   <bug id="bug516(gamma)">
    <pattern origin="math.gamma.gamma_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("gamma.lgamma.11") || isRequirementFailed("gammaf.lgamma.11") || isRequirementFailed("gammal.lgamma.11" ))
       && modelOperation.name == "gamma_spec"
      ]]>
    </pattern>
    <body>
       According to LSB, gamma(x) family of functions shall return either HUGE_VAL or NaN if
       x is a non-positive integer.
       But on the target machine the functions don't return HUGE_VAL or NaN if the argument
       is not positive.
    </body>
  </bug>

   <bug id="bug516(lgamma_r)">
    <pattern origin="math.gamma.lgamma_r_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed( "lgamma_r.08") || isRequirementFailed( "lgammaf_r.08") || isRequirementFailed( "lgammal_r.08"))
       && modelOperation.name == "lgamma_r_spec"
      ]]>
    </pattern>
    <body>
       According to LSB, lgamma_r(x) family of functions shall return +HUGE_VAL if
       x is a non-positive integer.
       But on the target machine the functions don't return +HUGE_VAL if the argument
       is not positive.
    </body>
  </bug>

   <bug id="bug512(fdim)">
    <pattern origin="math.real.fdim_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("fdim.08.01.01;fdimf.08.01.01;fdiml.08.01.01" )
       && modelOperation.name == "fdim_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The fdim(x, y) family of functions shall determine the positive difference between their arguments.
       According to LSB, if the result overflows then fdim() shall fail and shall set ERANGE error code.
       But on the target machine, the functions set error code EOK instead of ERANGE when overflow occurs.
    </body>
  </bug>

   <bug id="bug664(fdim)">
    <pattern origin="math.real.fdim_spec">
      <![CDATA[
       kind == MEDIATOR_FAILED
       && (info.indexOf("Execution failed")!=-1 || info.indexOf("Connection closed")!=-1)
       && modelOperation.name == "fdim_spec"
      ]]>
    </pattern>
    <body>
       The fdim(x, y) family of functions shall determine the positive difference between their arguments.
       According to LSB, if the result overflows then fdim() shall fail and shall set ERANGE error code.
       But on the target machine, the functions crash when overflow occurs.
    </body>
  </bug>

   <bug id="bug512(llrint)">
    <pattern origin="math.real.llrint_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("llrint.10.01.01;llrintf.10.01.01;llrintl.10.01.01;llrint.05;llrintf.05;llrintl.05;llrint.06;llrintf.06;llrintl.06;llrint.07;llrintf.07;llrintl.07;llrint.08;llrintf.08;llrintl.08;llrint.09;llrintf.09;llrintl.09")
       && modelOperation.name == "llrint_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The llrint() family of  functions shall round their argument to the nearest integer value,
       rounding according to the current rounding direction.
       According to LSB, if argument is NaN, +Inf, -Inf, or the correct value is not representable as an
       integer then the functions shall set EDOM error code.
       But on the target machine, the functions set error code EOK instead of EDOM in these cases.
    </body>
  </bug>

   <bug id="bug512(llround)">
    <pattern origin="math.real.llround_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("llround.10.01.01;llroundf.10.01.01;llroundl.10.01.01;llround.05;llroundf.05;llroundl.05;llround.06;llroundf.06;llroundl.06;llround.07;llroundf.07;llroundl.07;llround.08;llroundf.08;llroundl.08;llround.09;llroundf.09;llroundl.09")
       && modelOperation.name == "llround_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The llround() family of  functions shall round their argument to the nearest integer value,
       rounding halfway cases away from zero, regardless of the current rounding direction.
       According to LSB, if argument is NaN, +Inf -Inf, or the correct value is not representable as an
       integer then the functions shall set EDOM error code.
       But on the target machine, the functions set error code EOK instead of EDOM in these cases.
    </body>
  </bug>

   <bug id="bug512(lrint)">
    <pattern origin="math.real.lrint_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("lrint.10.01.01;lrintf.10.01.01;lrintl.10.01.01" )
       && modelOperation.name == "lrint_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The lrint() family of  functions shall round their argument to the nearest integer value,
       rounding according to the current rounding direction.
       According to LSB, if argument is NaN, +Inf, -Inf, or the correct value is not representable as an
       integer then the functions shall set EDOM error code.
       But on the target machine, the functions set error code EOK instead of EDOM in these cases.
    </body>
  </bug>

   <bug id="bug512(lround)">
    <pattern origin="math.real.lround_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("lround.10.01.01;lroundf.10.01.01;lroundl.10.01.01;lround.05;lroundf.05;lroundl.05;lround.06;lroundf.06;lroundl.06;lround.07;lroundf.07;lroundl.07;lround.08;lroundf.08;lroundl.08;lround.09;lroundf.09;lroundl.09")
       && modelOperation.name == "lround_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The lround() family of  functions shall round their argument to the nearest integer value,
       rounding halfway cases away from zero, regardless of the current rounding direction.
       According to LSB, if argument is NaN, +Inf, -Inf, or the correct value is not representable as an
       integer then the functions shall set EDOM error code.
       But on the target machine, the functions set error code EOK instead of EDOM in these cases.
    </body>
  </bug>

   <bug id="bug512(fmod)">
    <pattern origin="math.real.fmod_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "fmod.12.01.01;fmodf.12.01.01;fmodl.12.01.01" )
       && modelOperation.name == "fmod_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The fmod(x, y) family of functions shall return the floating-point remainder of the division of x by y.
       According to LSB, if the x argument is infinite then the functions() shall set error code to EDOM.
	   But on the target machine, the functions set error code EOK instead of EDOM when x is infinity.
    </body>
  </bug>

   <bug id="bug512(drem)">
    <pattern origin="math.real.drem_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "dremf.remainderf.06.01.01;dreml.remainderl.06.01.01" )
       && modelOperation.name == "drem_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The drem(x, y) family of functions shall return the floating-point remainder r = x-ny when y is non-zero.
       According to LSB, if the x argument is +Inf or -Inf, and the other argument is non-NaN then error code shall
       be set to EDOM.
       But on the target machine, the functions set error code EOK instead of EDOM in this case.
    </body>
  </bug>

   <bug id="bug512(remainder)">
    <pattern origin="math.real.remainder_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("remainder.06.01.01;remainderf.06.01.01;remainderl.06.01.01" )
       && modelOperation.name == "remainder_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The remainder(x, y) family of functions shall return the floating-point remainder r = x-ny when y is non-zero.
       According to LSB, if the x argument is +Inf or -Inf, and the other argument is non-NaN then error code shall
       be set to EDOM.
       But on the target machine, the functions set error code EOK instead of EDOM in this case.
    </body>
  </bug>

   <bug id="bug512(remquo)">
    <pattern origin="math.real.remquo_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "remquo.07.01.01;remquof.07.01.01;remquol.07.01.01" )
       && modelOperation.name == "remquo_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The remquo(x, y, quo) family of functions shall return the floating-point remainder r = x-ny when y is non-zero
       und update quo variable.
       According to LSB, if the x argument is +Inf, -Inf, or the y argument is +0 or -0 and the other argument is non-NaN.
 	   then error code shall be set to EDOM.
       But on the target machine, the functions set error code EOK instead of EDOM in these cases.
    </body>
  </bug>

   <bug id="bug516_2(cexp)">
    <pattern origin="math.cexp.cexp_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("cexp.01;cexp.02" )
            || isRequirementFailed("cexpf.01;cexpf.02" )
            || isRequirementFailed("cexpl.01;cexpl.02" )
            )
       && modelOperation.name == "cexp_spec"
      ]]>
    </pattern>
    <body>
       The cexp() family of functions function shall compute the complex exponent of their
       argument.
       At the specified point the result of computing the exponent is very imprecise
       (inaccuracy is more then 20 bits from the end of the floating point number).
    </body>
  </bug>

   <bug id="bug516(cacosh)">
    <pattern origin="math.chyper.cacosh_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("cacosh.02") || isRequirementFailed("cacoshf.02") || isRequirementFailed("cacoshl.02" ))
       && modelOperation.name == "cacosh_spec"
      ]]>
    </pattern>
    <body>
       The cacosh() family of functions shall compute the complex arc hyperbolic cosine of
       their argument.
       According to LSB, the functions shall return result in the range of a half-strip of non-negative
       values along the real axis and in the interval [-i, +i] along the imaginary axis.
       But at the specified point the result doesn't lay in appropriate area of the complex
       plane.
    </body>
  </bug>

   <bug id="bug516(catanh)">
    <pattern origin="">
      <![CDATA[
          kind == SCENARIO_FUNCTION_FAILED
       && (isRequirementFailed("catanh.ext.04") || isRequirementFailed("catanhf.ext.04") || isRequirementFailed("catanhl.ext.04" ))
       && transitionName == "catanh_scen"
      ]]>
    </pattern>
    <property name="package">math.chyper</property>
	<property name="operationName">catanh_spec</property>
    <body>
       The catanh() family of functions shall compute the complex arc hyperbolic tangent of their
       argument.
       But at the specified point the result is very imprecise (inaccuracy is more then 20 bits from the end of the
       floating point number).
    </body>
  </bug>

   <bug id="bug516(ctanh)">
    <pattern origin="math.chyper.ctanh_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("ctanhf.02;ctanhf.01" )
       && modelOperation.name == "ctanh_spec"
      ]]>
    </pattern>
    <body>
       The ctanh() family of functions shall compute the complex hyperbolic tangent of their
       argument.
       But at the specified point the result is very imprecise (inaccuracy is more then 20 bits from the end of the
       floating point number).
    </body>
  </bug>

   <bug id="bug516(ctan)">
    <pattern origin="math.ctrig.ctan_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "ctanf.ext.03" )
       && modelOperation.name == "ctan_spec"
      ]]>
    </pattern>
    <body>
       The ctan() family of functions shall compute the complex tangent of their
       argument.
       At the specified point the functions don't satisfy to the property
       ctan(z) == -i * ctanh(iz).
    </body>
  </bug>

   <bug id="bug512(expm1)">
    <pattern origin="math.exp.expm1_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "expm1.11.01.01;expm1f.11.01.01;expm1l.11.01.01" )
       && modelOperation.name == "expm1_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The expm1(x) family of functions shall compute exp(x)-1.0.
       According to LSB, if the correct value would cause overflow, a range error shall occur
       and error code shall be set to ERANGE.
       But on the target machine the functions set error code EOK instead of
       ERANGE when overflow occurs.
    </body>
  </bug>

   <bug id="bug512_1(log1p)">
    <pattern origin="math.exp.log1p_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("log1p.10.01.01;log1pf.10.01.01;log1pl.10.01.01" )
       && modelOperation.name == "log1p_spec"
      ]]>
    </pattern>
    <body>
       The log1p(x) family of functions shall compute log(1.0 + x).
       According to LSB, the functions shall fail if argument is less than -1
       and set error code to EDOM.
       But on the target machine the functions set error code EOK instead of EDOM if
       the argument is less than -1.
    </body>
  </bug>

   <bug id="bug512_2(log1p)">
    <pattern origin="math.exp.log1p_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("log1p.10.02.01;log1pf.10.02.01;log1pl.10.02.01" )
       && modelOperation.name == "log1p_spec"
       && modelOperation.getParameterValue( "errno" ) == "EOK"
      ]]>
    </pattern>
    <body>
       The log1p(x) family of functions shall compute log(1.0 + x).
       According to LSB, the functions shall fail if argument equals to -1
       and set error code to ERANGE.
       But on the target machine the functions set error code EOK instead of ERANGE
       in this case.
    </body>
  </bug>

   <bug id="bug512(pow)">
    <pattern origin="math.exp.pow_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("pow.27.02.01;pow.27.03.01;powf.27.02.01;powf.27.03.01;powl.27.02.01;powl.27.03.01" )
       && modelOperation.name == "pow_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
       && (getCoveredElementId( "C" ) == 8 ||
       getCoveredElementId( "C" ) == 11 || getCoveredElementId( "C" ) == 14 || getCoveredElementId( "C" ) == 17)
      ]]>
    </pattern>
    <body>
       The pow(x, y) family of functions shall compute the value of x raised to the power y.
       According to LSB, if x is +-0 and y is negative the functions shall fail and set error code
       to ERANGE.
	   But on the target machine, the functions set error code EDOM instead of ERANGE in this
	   case.
    </body>
  </bug>

   <bug id="bug512(atanh)">
    <pattern origin="math.hyper.atanh_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "atanh.11.02.01;atanhf.11.02.01;atanhl.11.02.01" )
       && modelOperation.name == "atanh_spec"
       && modelOperation.getParameterValue( "errno" ) == "EDOM"
      ]]>
    </pattern>
    <body>
      The atanh(x) family of functions shall compute the inverse hyperbolic tangent of their argument x.
      According to LSB, if the x argument is +1 or -1 then the functions shall fail and
      set error code to ERANGE.
      But on the target machine, these functions set error code EDOM instead of ERANGE
      in this case.
    </body>
  </bug>

   <bug id="bug511_1(initstate)">
    <pattern origin="math.rand.initstate_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "initstate.11" )
       && modelOperation.name == "initstate_spec"
      ]]>
    </pattern>
    <body>
       The initstate() function handles restarting of random-number generator.
       One of the argument to initstate() function is size of the state array.
       The larger the state array, the more random the numbers.
       According to LSB, values for the amount of state information are 8, 32, 64, 128, and 256 bytes
       and if initstate() is called with size less than 8, it shall return NULL.
       But on the target machine the function doesn't return NULL when called with size less
       than 8.
    </body>
  </bug>

   <bug id="bug511_2(initstate)">
    <pattern origin="math.rand.initstate_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("initstate.07" )
       && modelOperation.name == "initstate_spec"
      ]]>
    </pattern>
    <body>
       The initstate() function handles restarting of random-number generator.
	   According to LSB, upon successful completion, initstate() shall return a pointer to the previous state
	   array; otherwise, a null pointer shall be returned.
       But on the target machine the function returns neither a pointer to the previous state,
       nor NULL pointer.
    </body>
  </bug>

<bug id="bug552(__signbit)">
    <pattern origin="util.float.__signbit_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("__signbit.signbit.01;__signbit.signbit.02" )
       && modelOperation.name == "__signbit_spec"
      ]]>
    </pattern>
    <body>
       The function __signbit() shall determine whether the sign of its argument value is negative.
       NaNs, zeros, and infinities have a sign bit. It returns a non-zero value if and only if the
       sign of its argument value is negative.
       But on the target machine, the function __signbit() returns 0 on -NaN while the correct
       result shall be non-zero.
    </body>
  </bug>

   <bug id="bug532(cacosh)">
      <pattern origin="math.chyper.cacosh_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("cacoshf.01") ||
			isRequirementFailed("cacosh.01") ||
			isRequirementFailed("cacoshl.01"))
       && modelOperation.name
          == "cacosh_spec"
       && getCoveredElementId( "C" ) == 2
      ]]>
      </pattern>
      <body>
         The cacosh() family of functions shall compute the complex arc hyperbolic cosine of
         their argument.
         The cacosh(-1) function shall return Pi * I according to definition of arc hyperbolic cosine.
         But on the target machine it returns Pi/2 * I.
      </body>
   </bug>

   <bug id="bug496(cacosh)">
    <pattern origin="">
      <![CDATA[
          kind == SCENARIO_FUNCTION_FAILED
       && transitionName == "cacosh_scen"
      ]]>
    </pattern>
    <property name="package">math.chyper</property>
	<property name="operationName">cacosh_spec</property>
    <body>
       The cacosh() family of functions shall compute the complex arc hyperbolic cosine of
       their argument.
       From mathematical definition of the complex arc hyperbolic cosine there is the
       requirement "cacos(conj(z)) = conj(cacos(z)), where conj(z) is the complex conjugate of z".
       But on the target machine cacosh(-1 + 0*I) = cacosh(-1 - 0*I) = Pi * I.
    </body>
  </bug>

  <bug id="bug533(pow)">
    <pattern origin="math.exp.pow_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("pow.08" )
       && modelOperation.name == "pow_spec"
      ]]>
    </pattern>
    <body>
       The pow(x, y) family of functions shall compute the value of x raised to the power y.
       According to LSB, if x is -Inf and y is Nan then the functions shall return NaN.
       But on the target machine it returns Inf instead of NaN on (-Inf, NaN).
       The bug was fixed in libc 2.6.
    </body>
  </bug>

   <bug id="bug535(logb)">
      <pattern origin="util.float.logb_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("logbf.04") ||
		    isRequirementFailed("logb.04") ||
			isRequirementFailed("logbl.04") )
       && modelOperation.name
          == "logb_spec"
       && getCoveredElementId( "C" ) == 3
      ]]>
      </pattern>
      <body>
         The logb() family of functions shall compute the exponent of x, which is the integral part
         of log |x|, as a signed floating-point value.
         If the number is denormalized then its part that is stored in exponential part is
         different from log(2)(x). Function logb(x) shall return log(2)(x).
         But on the target machine, the family of functions does not produce correct results
         on denormalized arguments, because it simply returns exponential part of the number
         which is not correct for this type of arguments.
         The bug was fixed in libc 2.6.
      </body>
   </bug>

   <bug id="bug536(scalbln)">
      <pattern origin="util.float.scalbln_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("scalblnf.10") ||
        isRequirementFailed("scalbln.10") ||
			isRequirementFailed("scalblnl.10")
		)
       && modelOperation.name
          == "scalbln_spec"
       && getCoveredElementId( "C" ) == 4
      ]]>
      </pattern>
      <body>
         The scalbln() family of functions shall compute x * FLT_RADIX at the power of n efficiently, not
         normally by computing FLT_RADIX at the power of n explicitly.
         On the target machine the functions return incorrect result on denormalized arguments - NaN or
         very big number.
         Bug was added to linuxtesting.ru as bug number S0536.
      </body>
   </bug>

   <bug id="bug537(powl)">
      <pattern origin="math.exp.pow_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("powl.05")
		)
       && modelOperation.name
          == "pow_spec"
       && (getCoveredElementId( "C" ) == 19 ||
       getCoveredElementId( "C" ) == 16)
      ]]>
      </pattern>
      <body>
         The powl(x, y) function shall compute the value of x raised to the power y.
         According to LSB, it shall return NaN on x less than 0 and finite non integer y.
         But it doesn't return NaN on such arguments on the target machine.
         Bug was added to linuxtesting.ru as bug number S0537.
      </body>
   </bug>

   <bug id="bug538(powl)">
      <pattern origin="math.exp.pow_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("powl.04")
		)
       && modelOperation.name
          == "pow_spec"
       && (getCoveredElementId( "C" ) == 19 ||
       getCoveredElementId( "C" ) == 16)
      ]]>
      </pattern>
      <body>
         The powl(x, y) function shall compute the value of x raised to the power y.
         But at the given point on the target machine it produces incorrect result after chain of
         calls of powl() on positive x and negative y.
      </body>
   </bug>

   <bug id="bug543(hypotl)">
      <pattern origin="math.exp.hypot_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("hypotl.08")
		)
       && modelOperation.name
          == "hypot_spec"
      ]]>
      </pattern>
      <body>
         The hypotl() function shall compute the value of the square root of x^2+ y^2 without
         undue overflow or underflow.
         According to LSB, if both arguments are subnormal and the correct result is subnormal,
         a range error may occur and the correct result is returned.
		 But on the target machine the function returns Inf instead of correct subnormal result on
		 both subnormal arguments.
      </body>
   </bug>

  <bug id="bug530(log1pl)">
    <pattern origin="math.exp.log1p_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("log1pl.06" )
       && modelOperation.name == "log1p_spec"
      ]]>
    </pattern>
    <body>
       The log1pl(x) function shall compute log(1.0 + x).
       According to LSB, for finite values of x that are less than -1, or if x is -Inf,
       a domain error shall occur, and NaN shall be returned.
       But on the target machine the function returns -Inf instead of NaN on -Inf.
       The bug was fixed in libc 2.6.
    </body>
  </bug>

  <bug id="bug503(csqrt)">
      <pattern origin="math.cexp.csqrt_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("csqrtf.02") ||
       		isRequirementFailed("csqrtf.ext.03") ||
       		isRequirementFailed("csqrt.02") ||
       		isRequirementFailed("csqrt.ext.03") ||
       		isRequirementFailed("csqrtl.02") ||
       		isRequirementFailed("csqrtl.ext.03"))
       && modelOperation.name
          == "csqrt_spec"
       && getCoveredElementId( "C" ) == 2
      ]]>
      </pattern>
      <body>
        The csqrt() family of functions shall compute the complex square root of z, with a
        branch cut along the negative real axis. Thus the functions shall return result from right
        half-plane.
        But csqrtf(0 - i) returns (-0.7071068 + 0.7071068*I) from left half-plane.
        It leads to the requirement "csqrt(conj(z)) = conj(csqrt(z)), where conj(z) is the
        complex conjugate of z" to be failed.
      </body>
   </bug>

   <bug id="bug518_5(scalb)">
    <pattern origin="util.float.scalb_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("scalb.14.01.01;scalbf.14.01.01;scalbl.14.01.01") || isRequirementFailed("scalb.14.02.01;scalbf.14.02.01;scalbl.14.02.01") )
       && modelOperation.name == "scalb_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
      The scalb() family of functions shall compute x*r^n, where r is the radix of the machine's
      floating-point arithmetic.
      According to LSB, the functions shall set EDOM error code when x is zero and n is +Inf, or x is Inf and n
      is -Inf and ERANGE when overflow occurs.
      But the functions sets error code EOK in these cases.
    </body>
  </bug>

   <bug id="bug518_6(scalbln)">
    <pattern origin="util.float.scalbln_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("scalbln.11.01.01;scalblnf.11.01.01;scalblnl.11.01.01") )
       && modelOperation.name == "scalbln_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The scalbln() family of functions shall compute x * FLT_RADIX^n efficiently, not normally by computing
       FLT_RADIX^n explicitly.
       According to LSB, the functions shall set ERANGE error code when overflow occurs.
       But on the target machine the function sets error code EOK instead of ERANGE in
       this case.
    </body>
  </bug>

   <bug id="bug518_7(scalbn)">
    <pattern origin="util.float.scalbn_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("scalbn.11.01.01;scalbnf.11.01.01;scalbnl.11.01.01") )
       && modelOperation.name == "scalbn_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The scalbn() family of functions shall compute x * FLT_RADIX^n efficiently, not normally by computing
       FLT_RADIX^n explicitly.
       According to LSB, the functions shall set ERANGE error code when overflow occurs.
       But on the target machine the function sets error code EOK instead of ERANGE in
       this case.
    </body>
  </bug>

   <bug id="bug516_1(cexp)">
    <pattern origin="math.cexp.cexp_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("cexp.ext.14") || isRequirementFailed("cexpf.ext.14") || isRequirementFailed("cexpl.ext.14" ))
       && modelOperation.name == "cexp_spec"
      ]]>
    </pattern>
    <body>
       The cexp() family of functions shall compute the complex exponent of z.
       But on the target machine the functions don't return NaN+i*Inf if the argument
       is NaN+i*Inf. This result is logical from definition of mathematical exponent
       function.
    </body>
  </bug>

  <bug id="bug516(cpow)">
    <pattern origin="math.cexp.cpow_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("cpow.01;cpow.02" )
            || isRequirementFailed("cpowf.01;cpowf.02" )
            || isRequirementFailed("cpowl.01;cpowl.02" )
            )
       && (
       (modelOperation.getParameterValue("x") == "(float) -Infinity + i *(float) 1.0000000000000000e+00 (0x00800000P0F)"
       && modelOperation.getParameterValue("y") == "(float) -2.0000000000000000e+00 (-0x00800000P1F) + i *(float) 0.0000000000000000e+00 (0x00000000P0F)")
       || (modelOperation.getParameterValue("x") == "(double) -Infinity + i *(double) 1.0000000000000000e+00 (0x00100000 00000000P0)"
       && modelOperation.getParameterValue("y") == "(double) -2.0000000000000000e+00 (-0x00100000 00000000P1) + i *(double) 0.0000000000000000e+00 (0x00000000 00000000P0)")
       || (modelOperation.getParameterValue("x") == "(long double) -Infinity + i *(long double) 1.00000000000000000000e+00 (0x80000000 00000000P0L)"
       && modelOperation.getParameterValue("y") == "(long double) -2.00000000000000000000e+00 (-0x80000000 00000000P1L) + i *(long double) 0.00000000000000000000e+00 (0x00000000 00000000P0L)")
       )
       && modelOperation.name == "cpow_spec"
      ]]>
    </pattern>
    <body>
       The cpow(x, y) family of  functions shall compute the complex power function x^y,
       with a branch cut for the first parameter along the negative real axis.
       If the argument is x = -Inf+i*1 and y = -2+i*0 then the functions return 0-i*0
       instead of 0+i*0. This result is logical from definition of mathematical complex
       power function.
    </body>
  </bug>

  <bug id="bug616(exp2l)">
    <pattern origin="math.exp.exp2_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && info.endsWith( "Function not found in any library: exp2l" )
       && modelOperation.name == "exp2_spec"
      ]]>
    </pattern>
    <body>
       The function exp2l() is not implemented in libraries on the system
       of the target machine.
    </body>
</bug>

   <bug id="bug618(hypotf)">
      <pattern origin="math.exp.hypot_spec">
         <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("hypotf.08")
		)
       && modelOperation.name
          == "hypot_spec"
      ]]>
      </pattern>
      <body>
         The hypotf() function shall compute the value of the square root of x^2+ y^2 without
         undue overflow or underflow.
         According to LSB, if both arguments are subnormal and the correct result is subnormal,
         a range error may occur and the correct result is returned.
		 But on the target machine the function returns 0 instead of correct subnormal result on
		 both subnormal arguments.
      </body>
   </bug>

   <bug id="bug619(llroundf)">
    <pattern origin="math.real.llround_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && (isRequirementFailed("llroundf.01;llroundf.04") )
       && modelOperation.name == "llround_spec"
       && (modelOperation.getParameterValue("x") == "(float) 1.9999998807907104e+00 (0x00FFFFFFP0F)"
       || modelOperation.getParameterValue("x") == "(float) -1.9999998807907104e+00 (-0x00FFFFFFP0F)")
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The llroundf() function shall round their argument to the nearest integer value,
       rounding halfway cases away from zero, regardless of the current rounding direction.
       But on the target machine, the function gives incorrect result on the inputs
       +-1.9999998807907104e+00 (i.e. nearest to +-2 float numbers).
    </body>
  </bug>


   <bug id="bug518_1(ilogb)">
    <pattern origin="util.float.ilogb_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("ilogb.10.01.01;ilogbf.10.01.01;ilogbl.10.01.01")
       && modelOperation.name == "ilogb_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The ilogb() function shall return the exponent part of its argument.
       According to LSB, if this argument is infinity, EDOM error shall be set in errno.
       But on the target machine this function sets error code EOK instead of EDOM.
    </body>
  </bug>

   <bug id="bug518_2(logb)">
    <pattern origin="util.float.logb_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("logb.08.01.01;logbf.08.01.01;logbl.08.01.01")
       && modelOperation.name == "logb_spec"
       && modelOperation.getParameterValue("errno") == "EOK"
      ]]>
    </pattern>
    <body>
       The logb() function shall compute the exponent of the integral part of logarithm
       of its argument as a signed floating-point value.
       According to LSB, if this argument is 0, ERANGE error shall be set in errno.
       But on the target machine this function sets error code EOK instead of ERANGE.
    </body>
  </bug>

  <bug id="bug552(__signbitf)">
    <pattern origin="util.float.__signbit_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed("__signbitf.signbit.01;__signbitf.signbit.02" )
       && modelOperation.name == "__signbit_spec"
      ]]>
    </pattern>
    <body>
       The __signbit() function shall determine whether the sign of its argument value is negative. NaNs, zeros,
       and infinities have a sign bit.
	   According to LSB, the __signbit() shall return a non-zero value if and only if the sign of its
	   argument value is negative.
	   But on the target machine it returns 0 on -NaN while the correct result shall be non-zero.
    </body>
  </bug>

<!-- Architecure specific bugs -->

<!-- Bugs that occure on SuSe 10 for ia64, s390x only -->
   <bug id="bug544_1(timer_getoverrun)">
      <pattern origin="time.timer.timer_getoverrun_spec">
         <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf("Segmentation fault: Invalid memory address ")!=-1)
       && modelOperation.name
          == "timer_getoverrun_spec"
      ]]>
      </pattern>
      <body>
         When a timer expiration signal is delivered to or accepted by a process, if the implementation
         supports the Realtime Signals Extension, the timer_getoverrun() function shall return the timer
         expiration overrun count for the specified timer.
         But on the target machine simple call to timer_getoverrun() crashes.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0544.
      </body>
   </bug>

   <bug id="bug544_2(timer_delete)">
      <pattern origin="time.timer.timer_delete_spec">
         <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf("Segmentation fault: Invalid memory address ")!=-1)
       && modelOperation.name
          == "timer_delete_spec"
      ]]>
      </pattern>
      <body>
         The timer_delete() function deletes the specified timer.
         But on the target machine simple call to timer_delete() function crashes.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0544.
      </body>
   </bug>

   <bug id="bug544_3(timer_gettime)">
      <pattern origin="time.timer.timer_gettime_spec">
         <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf("Segmentation fault: Invalid memory address ")!=-1)
       && modelOperation.name
          == "timer_gettime_spec"
      ]]>
      </pattern>
      <body>
      	 The timer_gettime() function shall store the amount of time until the specified timer,
      	 expires and the reload value of the timer into the space pointed to by the value argument.
 		 But on the target machine simple call to timer_gettime() crashes.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0544.
      </body>
   </bug>

   <bug id="bug501_1(pthread_mutexattr)">
    <pattern origin="">
      <![CDATA[
          kind == SCENARIO_FUNCTION_FAILED
       && isRequirementFailed( "pthread_mutexattr.01" )
       && transitionName  == "mutexattr_simple_scen"
      ]]>
    </pattern>
    <property name="package">pthread.mutex</property>
	<property name="operationName">pthread_mutex_trylock_spec</property>
    <body>
       Function pthread_mutex_trylock() tries to lock a mutex. It shall return EBUSY error code
       if the mutex could not be acquired because it was already locked.
       But it returns error code EDEADLK.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0501.
    </body>
  </bug>

   <bug id="bug501_2(pthread_mutex_trylock)">
    <pattern origin="pthread.mutex.pthread_mutex_trylock_spec">
      <![CDATA[
          kind == SERIALIZATION_FAILED
          &&  interimFailures.get(0).kind == POSTCONDITION_FAILED
          &&  interimFailures.get(0).isRequirementFailed("pthread_mutex_trylock.02.01;pthread_mutex_trylock.06.02")
          &&  interimFailures.get(0).modelOperation.name == "pthread_mutex_trylock_spec"
          &&  interimFailures.get(0).modelOperation.returnValue != "EBUSY"
       ]]>
    </pattern>
    <property name="package">pthread.mutex</property>
	<property name="operationName">pthread_mutex_trylock_spec</property>
    <body>
       Function pthread_mutex_trylock() tries to lock a mutex. It shall return EBUSY error code
       if the mutex could not be acquired because it was already locked.
       But it returns error code EDEADLK.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0501.
    </body>
  </bug>

<!-- Bug occures on SuSe 10 for ppc64, s390x  and Debian 4 for ppc only -->
   <bug id="bug602_1(clock_getres)">
    <pattern origin="time.clock.clock_getres_spec">
      <![CDATA[
          kind == SERIALIZATION_FAILED                                          &&
          interimFailures.get(0).kind == POSTCONDITION_FAILED                   &&
          ( interimFailures.get(0).isRequirementFailed("clock_getres.09.01") )  &&
          interimFailures.get(0).modelOperation.name == "clock_getres_spec"
      ]]>
    </pattern>
    <property name="package">time.clock</property>
    <property name="operationName">clock_getres_spec</property>
    <body>
       The clock_getres() function shall return the resolution of any clock.
       But on the target machine this function returns error when it is
       executed with correct clock (recieved as the result of clock_getcpuclockid()
       function) as the argument.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0601.
    </body>
  </bug>


   <bug id="bug602_2(clock_gettime)">
    <pattern origin="time.clock.clock_gettime_spec">
      <![CDATA[
          kind == SERIALIZATION_FAILED                                          &&
          interimFailures.get(0).kind == POSTCONDITION_FAILED                   &&
          ( interimFailures.get(0).isRequirementFailed("clock_gettime.09.01") )  &&
          interimFailures.get(0).modelOperation.name == "clock_gettime_spec"
      ]]>
    </pattern>
    <property name="package">time.clock</property>
    <property name="operationName">clock_gettime_spec</property>
    <body>
       The clock_gettime() function shall return the current value for the specified clock.
       But on the target machine this function returns error when it is
       executed with correct clock (recieved as the result of clock_getcpuclockid()
       function) as the argument.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0601.
    </body>
  </bug>

<!-- Bug occures on Debian 4 for ppc only -->
   <bug id="bug610(sockatmark)">
    <pattern origin="socket.socket.sockatmark_spec">
      <![CDATA[
          kind == SERIALIZATION_FAILED                                          &&
          interimFailures.get(0).kind == POSTCONDITION_FAILED                   &&
          ( interimFailures.get(0).info.endsWith("Requirement failed: Unexpected error code returned: [EFAULT] code 0xE") )  &&
          interimFailures.get(0).modelOperation.name == "sockatmark_spec"
      ]]>
    </pattern>
    <property name="package">socket.socket</property>
    <property name="operationName">sockatmark_spec</property>
    <body>
       The sockatmark() function shall determine whether the socket specified by the descriptor
       is at the out-of-band data mark.
       But on the target machine this function returns error EFAULT when it is
       executed with correct socket as the argument.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0610.
    </body>
  </bug>


   <bug id="bug611_1(setgid)">
    <pattern origin="process.meta.setgid_spec">
      <![CDATA[
         kind == POSTCONDITION_FAILED
         && ( isRequirementFailed("setgid.01"))
         && modelOperation.name  == "setgid_spec"
         && (modelOperation.getParameterValue("gid") == "4294967295" || modelOperation.getParameterValue("gid") == "4294967293" )
         && modelOperation.returnValue == "0"
      ]]>
    </pattern>
    <body>
       If the process has appropriate privileges, setgid() shall set the real group ID, effective group ID, and
       the saved set-group-ID of the calling process to gid.
       But on the target machine this function sets the real group ID to invalid value if it is
       executed with parameter less than zero.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0611.
    </body>
  </bug>

   <bug id="bug611_2(setuid)">
    <pattern origin="process.meta.setuid_spec">
      <![CDATA[
         kind == POSTCONDITION_FAILED
         && ( isRequirementFailed("setuid.01"))
         && modelOperation.name  == "setuid_spec"
         && (modelOperation.getParameterValue("uid") == "4294967295" || modelOperation.getParameterValue("uid") == "4294967293" )
         && modelOperation.returnValue == "0"
      ]]>
    </pattern>
    <body>
       If the process has appropriate privileges, setuid() shall set the real user ID, effective user ID, and
       the saved set-user-ID of the calling process to uid.
       But on the target machine this function sets the real user ID to invalid value if it is
       executed with parameter less than zero.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0611.
    </body>
  </bug>


<!-- Bug occures on SuSe 10 for s390x only -->
<bug id="bug617(readdir_spec)">
	<pattern origin="fs.dir.readdir_spec">
	  <![CDATA[
	     kind == POSTCONDITION_FAILED
	     && (info.indexOf("Requirements Failed: file found to have invalid Ino in model") != -1)
	     && modelOperation.name  == "readdir_spec"
	     && ( modelOperation.returnValue == ". [2]" || modelOperation.returnValue == ".. [2]")
	  ]]>
	</pattern>
	<body>
       The readdir() function shall return a pointer to a structure representing
       the directory entry at the current position in the directory.
       Each file in the filesystem should have unique file serial number. But on
       the target machine readdir() returns the same serial number for different
       file.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0617.
	</body>
</bug>


<!-- Bug occures on SuSe 10 for ia64 only -->
<bug id="bug545(fesetround_spec)">
  <pattern origin="process.fenv.fesetround_spec">
     <![CDATA[
      kind == POSTCONDITION_FAILED
   && isRequirementFailed("fesetround.02")
   && modelOperation.name
      == "fesetround_spec"
   && modelOperation.getParameterValue("round") == "-1"
   && modelOperation.returnValue == "0"
  ]]>
  </pattern>
  <body>
       The fesetround() function shall establish the rounding direction represented by its argument.
       According to LSB, the fesetround() function shall return a zero value if and only if the
       requested rounding direction was established. If the argument is not equal to the value of a
       rounding direction macro, the rounding direction is not changed.
       But on the target machine fesetround() function returns 0 on any invalid negative value.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0545.
  </body>
</bug>

<!-- Bug occures on Red Hat 4 for x86_64 and Debian 4.0 etch for PowerPC-->
  <bug id="bug526_1(pthread_attr_setstack)">
    <pattern origin="pthread.attr.pthread_attr_setstack_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && info.endsWith( "Function not found in any library: pthread_attr_setstack" )
       && modelOperation.name == "pthread_attr_setstack_spec"
      ]]>
    </pattern>
    <body>
       The function pthread_attr_setstack() is not implemented in libraries on the system
       of the target machine.
    </body>
  </bug>

    <bug id="bug526_2(pthread_attr_setstack)">
    <pattern origin="pthread.pthread.pthread_create_spec">
      <![CDATA[
          kind == MEDIATOR_FAILED
       && (info.indexOf( "Connection closed" )!=-1)
       && modelOperation.name == "pthread_create_spec"
      ]]>
    </pattern>
    <body>
       The function pthread_attr_setstack() is not implemented in libraries on the system
       of the target machine, thus pthread_create() was not successful.
    </body>
  </bug>

  <bug id="bug649">
    <pattern origin="io.multiplex.poll_spec">
      <![CDATA[
      kind == POSTCONDITION_FAILED && isRequirementFailed("poll.07.05.01") && modelOperation.name == "poll_spec"
      ]]>
    </pattern>
    <pattern origin="io.multiplex.select_spec">
      <![CDATA[
      kind == POSTCONDITION_FAILED && isRequirementFailed("select.05") && modelOperation.name == "select_spec"
      ]]>
    </pattern>
    <body>
       Write bit (file desc or POLLOUT | POLLWRBAND) was set to 1, but write() function returns -1.
       Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0649.
    </body>
  </bug>

   <bug id="bug684(psignal)">
    <pattern origin="signal.sigstr.psignal_spec">
      <![CDATA[
         kind == POSTCONDITION_FAILED                                                                         &&
         modelOperation.name == "psignal_spec"                                                                &&
         isRequirementFailed( "psignal.03" )                                                                  &&
         ( getCoveredElementId( "psignal_coverage" ) == 0 || getCoveredElementId( "psignal_coverage" ) == 1 )
      ]]>
    </pattern>
    <body>
      If string s is empty, psignal shall display only a message describing the signal number sig.

      SYNOPSIS
      ...
      void psignal(int sig, const char * s);
      ...
      DESCRIPTION
      ...
      If s is not the null pointer, and does not point to an empty string (e.g. "\0"),
      the message shall consist of the string s, a colon, a space, and a string
      describing the signal number sig; otherwise psignal() shall display only a message
      describing the signal number sig.
      ...

      But in real, psignal output a colon, a space, and a string describing the signal number sig.

      Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0684.
    </body>
  </bug>

   <bug id="bug685(strsignal)">
    <pattern origin="signal.sigstr.strsignal_spec">
      <![CDATA[
         kind == POSTCONDITION_FAILED                     &&
         modelOperation.name == "strsignal_spec"          &&
         isRequirementFailed( "strsignal.08" )            &&
         getCoveredElementId( "strsignal_coverage" ) == 1
      ]]>
    </pattern>
    <body>
      If sig is not a valid signal number, strsignal shall return either a pointer
      either a pointer to the string "unknown signal", or a null pointer.

      SYNOPSIS
      ...
      char * strsignal(int sig);
      ...
      RETURN VALUE
      If sig is a valid signal number, strsignal() shall return a pointer
      to the appropriate description string. Otherwise, strsignal() shall return
      either a pointer to the string "unknown signal", or a null pointer.
      ...

      But in real, strsignal return "Unknown signal", a space, and a number sig.

      Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0685.
    </body>
  </bug>

  <bug id="bug686(tgetnum)">
    <pattern origin="ncurses.terminal.tgetnum_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED           &&
          modelOperation.name == "tgetnum_spec"  &&
          isRequirementFailed( "tgetnum.05.02" ) &&
          modelOperation.returnValue != "-1"     &&
          modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
      According to the standard, upon successful completion, tgetnum() function from Ncurses
      library shall return OK(0), otherwise, it shall return ERR(-1).

      RETURN VALUE
      ...
      Upon successful completion, functions that return an integer return OK.
      Otherwise, they return ERR.

      But the real implementation does not match LSB standard.
      Manual pages for GNU extension, that is used in real Linux systems, say:
      The tgetnum routine gets the numeric entry for id, or -1 if it is not available.

      Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0686.
    </body>
  </bug>

  <bug id="bug687(tgetflag)">
    <pattern origin="ncurses.terminal.tgetflag_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED            &&
          modelOperation.name == "tgetflag_spec"  &&
          isRequirementFailed( "tgetflag.05.02" ) &&
          modelOperation.returnValue != "-1"      &&
          modelOperation.returnValue != "0"
      ]]>
    </pattern>
    <body>
      According to the standard, upon successful completion, tgetflag() function from Ncurses
      library shall return OK(0), otherwise, it shall return ERR(-1).

      RETURN VALUE
      ...
      Upon successful completion, functions that return an integer return OK.
      Otherwise, they return ERR.

      But the real implementation does not match LSB standard.
      Manual pages for GNU extension, that is used in real Linux systems, say:
      The tgetflag routine gets the boolean entry for id, or zero if it is not available.

      Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0687.
    </body>
  </bug>

   <!-- <bug id="bug688(setcontext)">
    <pattern origin="process.context.setcontext_spec">
      <![CDATA[
        kind == MEDIATOR_FAILED                                            &&
        info.indexOf( "Segmentation fault: Invalid memory address" ) != -1 &&
        modelOperation.name == "setcontext_spec"
      ]]>
    </pattern>
    <body>
        Error in pair getcontext and setcontext on ppc64.
        Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0688.
    </body>
  </bug>

   <bug id="bug688(swapcontext)">
    <pattern origin="process.context.swapcontext_spec">
      <![CDATA[
        kind == MEDIATOR_FAILED                                            &&
        info.indexOf( "Segmentation fault: Invalid memory address" ) != -1 &&
        modelOperation.name == "swapcontext_spec"
      ]]>
    </pattern>
    <body>
        Error in pair getcontext and swapcontext on ppc64.
        Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0688.
    </body>
  </bug> -->

   <bug id="bug709_1(__strtod_internal)">
      <pattern origin="util.conversion.__strtod_internal_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED                                      &&
             modelOperation.name == "__strtod_internal_spec"                   &&
             isRequirementFailed( "__strtod_internal.strtod.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a string to a double-precision number make shift in a string with error.
         Functions __strtof_internal, __strtod_internal, __strtold_internal, strtof, strtod, strtold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt;(const char *restrict nptr, char **restrict endptr);
         After return * endptr must point to final string of one or more unrecognized characters,
         including the terminating null byte of the input string. If input string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0709.
      </body>
   </bug>
   <!--
              &&
             modelOperation.getParameterValue("endptr").endsWith( "ptr to )" ) &&
             modelOperation.returnValue.endsWith( "NaN" )
   -->

   <bug id="bug709_2(__strtof_internal)">
      <pattern origin="util.conversion.__strtod_internal_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED                         &&
             modelOperation.name == "__strtod_internal_spec"      &&
             isRequirementFailed( "__strtof_internal.strtof.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a string to a double-precision number make shift in a string with error.
         Functions __strtof_internal, __strtod_internal, __strtold_internal, strtof, strtod, strtold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt;(const char *restrict nptr, char **restrict endptr);
         After return * endptr must point to final string of one or more unrecognized characters,
         including the terminating null byte of the input string. If input string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0709.
      </body>
   </bug>

   <bug id="bug709_3(__strtold_internal)">
      <pattern origin="util.conversion.__strtod_internal_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED                           &&
             modelOperation.name == "__strtod_internal_spec"        &&
             isRequirementFailed( "__strtold_internal.strtold.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a string to a double-precision number make shift in a string with error.
         Functions __strtof_internal, __strtod_internal, __strtold_internal, strtof, strtod, strtold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt;(const char *restrict nptr, char **restrict endptr);
         After return * endptr must point to final string of one or more unrecognized characters,
         including the terminating null byte of the input string. If input string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0709.
      </body>
   </bug>

   <bug id="bug709_4(strtod)">
      <pattern origin="util.conversion.strtod_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED         &&
             modelOperation.name == "strtod_spec" &&
             isRequirementFailed( "strtod.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a string to a double-precision number make shift in a string with error.
         Functions __strtof_internal, __strtod_internal, __strtold_internal, strtof, strtod, strtold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt;(const char *restrict nptr, char **restrict endptr);
         After return * endptr must point to final string of one or more unrecognized characters,
         including the terminating null byte of the input string. If input string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0709.
      </body>
   </bug>

   <bug id="bug709_5(strtof)">
      <pattern origin="util.conversion.strtod_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED         &&
             modelOperation.name == "strtod_spec" &&
             isRequirementFailed( "strtof.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a string to a double-precision number make shift in a string with error.
         Functions __strtof_internal, __strtod_internal, __strtold_internal, strtof, strtod, strtold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt;(const char *restrict nptr, char **restrict endptr);
         After return * endptr must point to final string of one or more unrecognized characters,
         including the terminating null byte of the input string. If input string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0709.
      </body>
   </bug>

   <bug id="bug709_6(strtold)">
      <pattern origin="util.conversion.strtod_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED         &&
             modelOperation.name == "strtod_spec" &&
             isRequirementFailed( "strtold.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a string to a double-precision number make shift in a string with error.
         Functions __strtof_internal, __strtod_internal, __strtold_internal, strtof, strtod, strtold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt;(const char *restrict nptr, char **restrict endptr);
         After return * endptr must point to final string of one or more unrecognized characters,
         including the terminating null byte of the input string. If input string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0709.
      </body>
   </bug>

   <bug id="bug710_1(__wcstod_internal)">
      <pattern origin="util.conversion.__wcstod_internal_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED                                      &&
             modelOperation.name == "__wcstod_internal_spec"                   &&
             isRequirementFailed( "__wcstod_internal.wcstod.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a wide string to a double-precision number make shift in a string with error.
         Functions __wcstof_internal, __wcstod_internal, __wcstold_internal, wcstof, wcstod, wcstold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt; (const wchar_t *restrict nptr, wchar_t **restrict endptr);
         After return * endptr must point to final wide string of one or more unrecognized wide characters, including
         the terminating null byte of the input wide string. If input wide string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0710.
      </body>
   </bug>
   <!--
              &&
             modelOperation.getParameterValue("endptr").endsWith( "ptr to )" ) &&
             modelOperation.returnValue.endsWith( "NaN" )
   -->

   <bug id="bug710_2(__wcstof_internal)">
      <pattern origin="util.conversion.__wcstod_internal_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED                         &&
             modelOperation.name == "__wcstod_internal_spec"      &&
             isRequirementFailed( "__wcstof_internal.wcstof.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a wide string to a double-precision number make shift in a string with error.
         Functions __wcstof_internal, __wcstod_internal, __wcstold_internal, wcstof, wcstod, wcstold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt; (const wchar_t *restrict nptr, wchar_t **restrict endptr);
         After return * endptr must point to final wide string of one or more unrecognized wide characters, including
         the terminating null byte of the input wide string. If input wide string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0710.
      </body>
   </bug>

   <bug id="bug710_3(__wcstold_internal)">
      <pattern origin="util.conversion.__wcstod_internal_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED                           &&
             modelOperation.name == "__wcstod_internal_spec"        &&
             isRequirementFailed( "__wcstold_internal.wcstold.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a wide string to a double-precision number make shift in a string with error.
         Functions __wcstof_internal, __wcstod_internal, __wcstold_internal, wcstof, wcstod, wcstold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt; (const wchar_t *restrict nptr, wchar_t **restrict endptr);
         After return * endptr must point to final wide string of one or more unrecognized wide characters, including
         the terminating null byte of the input wide string. If input wide string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0710.
      </body>
   </bug>

   <bug id="bug710_4(wcstod)">
      <pattern origin="util.conversion.wcstod_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED         &&
             modelOperation.name == "wcstod_spec" &&
             isRequirementFailed( "wcstod.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a wide string to a double-precision number make shift in a string with error.
         Functions __wcstof_internal, __wcstod_internal, __wcstold_internal, wcstof, wcstod, wcstold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt; (const wchar_t *restrict nptr, wchar_t **restrict endptr);
         After return * endptr must point to final wide string of one or more unrecognized wide characters, including
         the terminating null byte of the input wide string. If input wide string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0710.
      </body>
   </bug>

   <bug id="bug710_5(wcstof)">
      <pattern origin="util.conversion.wcstod_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED         &&
             modelOperation.name == "wcstod_spec" &&
             isRequirementFailed( "wcstof.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a wide string to a double-precision number make shift in a string with error.
         Functions __wcstof_internal, __wcstod_internal, __wcstold_internal, wcstof, wcstod, wcstold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt; (const wchar_t *restrict nptr, wchar_t **restrict endptr);
         After return * endptr must point to final wide string of one or more unrecognized wide characters, including
         the terminating null byte of the input wide string. If input wide string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0710.
      </body>
   </bug>

   <bug id="bug710_6(wcstold)">
      <pattern origin="util.conversion.wcstod_spec">
         <![CDATA[
             kind == POSTCONDITION_FAILED         &&
             modelOperation.name == "wcstod_spec" &&
             isRequirementFailed( "wcstold.11" )
         ]]>
      </pattern>
      <body>
         Functions for convert a wide string to a double-precision number make shift in a string with error.
         Functions __wcstof_internal, __wcstod_internal, __wcstold_internal, wcstof, wcstod, wcstold.
         All thise functions have signature like
         &lt;return value type&gt; &lt;function name&gt; (const wchar_t *restrict nptr, wchar_t **restrict endptr);
         After return * endptr must point to final wide string of one or more unrecognized wide characters, including
         the terminating null byte of the input wide string. If input wide string looks like NAN(n-char-sequenceopt)
         * endptr must point to symbol after closing bracket. But * endptr point to closing bracket.
         Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0710.
      </body>
   </bug>

   <bug id="bug790(hsearch)">
    <pattern origin="util.search.hsearch_spec">
      <![CDATA[
        kind == MEDIATOR_FAILED
        && modelOperation.name == "hsearch_spec"
        && ( info.indexOf("Connection closed")!=-1 || info.indexOf("Segmentation fault:")!=-1 || info.indexOf("Execution failed")!=-1 )
      ]]>
    </pattern>
    <body>
        The hsearch(item, action) function shall return a pointer into a hash table created by hcreate(nel) function
        indicating the location at which an item can be found.
        The modifications of hsearch in glibc-2.9 leads to segmentation fault in some circumstances as a consequence 
        of internal invariant violation or in the case size of the table created is less than 3.
        Additional information about these bugs may be found at http://linuxtesting.org/results/report?num=S0791 and
        http://linuxtesting.org/results/report?num=S0790.
    </body>
  </bug>
  
   <bug id="bug792(hsearch)">
    <pattern origin="util.search.hsearch_spec">
      <![CDATA[
        kind == POSTCONDITION_FAILED
        && modelOperation.name == "hsearch_spec"
        && modelOperation.getParameterValue("action") == 0
        && getCoveredElementId( "C_keylen" ) == 0
        && info.indexOf("Search shall return not NULL")!=-1
      ]]>
    </pattern>
    <body>
        The hsearch(item, action) function shall return a pointer into a hash table indicating the location at which an item can be found.
        According to LSB, the ENTER value of the action argument indicates that the item should be inserted in the table at an appropriate point.
        But the implementation of hsearch in glibc-2.9 doesn't insert item in the case it's key value is zero
        and hence returns NULL pointer while trying to obtain the value desired.
    </body>
  </bug>

   <bug id="bug793(hsearch)">
    <pattern origin="util.search.hsearch_spec">
      <![CDATA[
        kind == POSTCONDITION_FAILED
        && modelOperation.name == "hsearch_spec"
        && modelOperation.getParameterValue("action") == 1
        && modelOperation.getParameterValue("errno") == "ENOMEM"
      ]]>
    </pattern>
    <body>
        The hsearch(item, action) function shall return a pointer into a hash table created by hcreate(nel) function
        indicating the location at which an item can be found.
        The ENTER value of action parameter indicates that the item should be inserted in the table at an appropriate point.
        The function may fail with ENOMEM error code if insufficient storage space is available.
        But the implementation of hsearch in glibc-2.9 sets error code ENOMEM in some circumstances due to internal invariant violation.
    </body>
  </bug>

   <bug id="bug794(ulimit)">
    <pattern origin="process.resources.ulimit_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED
       && isRequirementFailed( "ulimit.02")
       && modelOperation.name == "ulimit_spec"
       && getCoveredElementId( "C" ) == 0
      ]]>
    </pattern>
    <body>
    	It is a test suite deficiency that will be fixed soon.
    </body>
  </bug>

<!--  fair pattern
       && ( isRequirementFailed("unistd.01") || isRequirementFailed("unistd.02") || isRequirementFailed("unistd.03") 
       || isRequirementFailed("unistd.05") || isRequirementFailed("unistd.07") || isRequirementFailed("unistd.08") 
       || isRequirementFailed("unistd.10") || isRequirementFailed("unistd.11") || isRequirementFailed("unistd.12") 
       || isRequirementFailed("unistd.13") || isRequirementFailed("unistd.14") || isRequirementFailed("unistd.17") 
       || isRequirementFailed("unistd.18") || isRequirementFailed("unistd.19") || isRequirementFailed("unistd.20") 
       || isRequirementFailed("unistd.21") || isRequirementFailed("unistd.24") || isRequirementFailed("unistd.25") 
       || isRequirementFailed("unistd.27") || isRequirementFailed("unistd.28") || isRequirementFailed("unistd.30") 
       || isRequirementFailed("unistd.31") || isRequirementFailed("unistd.32") || isRequirementFailed("unistd.34") 
       || isRequirementFailed("unistd.35") || isRequirementFailed("unistd.36") || isRequirementFailed("unistd.37") 
       || isRequirementFailed("unistd.38") || isRequirementFailed("unistd.40") || isRequirementFailed("unistd.41") 
       || isRequirementFailed("unistd.42") || isRequirementFailed("unistd.49") || isRequirementFailed("unistd.50") 
       || isRequirementFailed("unistd.51") || isRequirementFailed("unistd.54") || isRequirementFailed("unistd.61") 
       || isRequirementFailed("unistd.83") || isRequirementFailed("unistd.84") )

    apply after CTesK is fixed
        kind == SERIALIZATION_FAILED
        && interimFailures.get(0).kind == POSTCONDITION_FAILED
        && interimFailures.get(0).modelOperation.name == "sysconf_spec"
        && interimFailures.get(0).modelOperation.returnValue == "200809"
-->


   <bug id="bug807(sysconf)">
    <pattern origin="system.sysconf.sysconf_spec">
      <![CDATA[
          kind == POSTCONDITION_FAILED 
       && modelOperation.name == "sysconf_spec" 
       && modelOperation.returnValue == "200809"
      ]]>
    </pattern>
    <pattern>
      <![CDATA[
          kind == SERIALIZATION_FAILED 
       && transitionName  == "initialize" 
       && scenarioName == "pthread_tls_tls_scenario"
      ]]>
    </pattern>
    <pattern>
      <![CDATA[
          kind == SCENARIO_INITIALIZATION_FAILED 
       && transitionName  == "initialize" 
       && ( scenarioName == "pthread_tls_tls_scenario" 
       || scenarioName == "pthread_scheduler_scenario" 
       || scenarioName == "pthread_tls_errors_scenario" 
       || scenarioName == "pthread_tls_setget_scenario" )
      ]]>
    </pattern>
    <body>
        According to LSB if any of symbols _POSIX2_C_BIND, _POSIX2_C_DEV, _POSIX2_CHAR_TERM, _POSIX2_LOCALEDEF, _POSIX2_SW_DEV, 
        _POSIX2_VERSION, _POSIX_ADVISORY_INFO, _POSIX_ASYNCHRONOUS_IO, _POSIX_BARRIERS, _POSIX_CLOCK_SELECTION, _POSIX_FSYNC, 
        _POSIX_IPV6, _POSIX_MAPPED_FILES, _POSIX_MEMLOCK, _POSIX_MEMLOCK_RANGE, _POSIX_MEMORY_PROTECTION, _POSIX_MESSAGE_PASSING, 
        _POSIX_PRIORITIZED_IO, _POSIX_PRIORITY_SCHEDULING, _POSIX_RAW_SOCKETS, _POSIX_READER_WRITER_LOCKS, _POSIX_REALTIME_SIGNALS, 
        _POSIX_SEMAPHORES, _POSIX_SHARED_MEMORY_OBJECTS, _POSIX_SPAWN, _POSIX_SPIN_LOCKS, _POSIX_SYNCHRONIZED_IO, 
        _POSIX_THREAD_ATTR_STACKADDR, _POSIX_THREAD_ATTR_STACKSIZE, _POSIX_THREAD_PRIO_INHERIT, _POSIX_THREAD_PRIO_PROTECT, 
        _POSIX_THREAD_PRIORITY_SCHEDULING, _POSIX_THREAD_PROCESS_SHARED, _POSIX_THREADS, _POSIX_THREAD_SAFE_FUNCTIONS, 
        _POSIX_TIMEOUTS, _POSIX_TIMERS, _POSIX_VERSION is defined in &lt;unistd.h&gt;, it shall be defined to be -1, 
        0, or 200112L. The value of such symbol reported by sysconf() shall either be -1 or 200112L. But glibc since 
        version 2.10 corresponds to POSIX-2008 claiming that the value returned by sysconf() shall either be -1 or 200809L.
        Additional information about this bug may be found at http://linuxtesting.org/results/report?num=S0807.
    </body>
  </bug>

</bugDB>
