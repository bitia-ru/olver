/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



#include "common/wchararray.seh"

#include <utils/boolean.h>
#include <utils/assertion.h>

#include <string.h>

// Temporary here
#include "ts/version.hh"


static void _init_wchar_array( struct _wchar_array* ba, WCharT* ptr, unsigned int len)
{
    ba->length = len;
    if (ba->length == 0)
    {
        ba->data = NULL;
        return;
    }
    assertion(ptr != NULL, FORMAT("NULL pointer for WCharArray initialization, length %u"),
              len
        );
    ba->data = malloc(len*sizeof(WCharT));
    assertion(ba->data != NULL, FORMAT("Failed to allocate memory, length %u"),
              len*sizeof(WCharT)
        );
    memcpy(ba->data, ptr, len*sizeof(WCharT));
}

static void init_WCharArray( struct _wchar_array *ba, va_list *arg_list )
{
    WCharT * ptr = va_arg( *arg_list, void *);
    unsigned int len = va_arg( *arg_list, unsigned int);
    
    _init_wchar_array(ba, ptr, len);
}

static void copy_WCharArray( struct _wchar_array *src, struct _wchar_array *dst )
{
    _init_wchar_array(dst, src->data, src->length);
}

static int compare_WCharArray( struct _wchar_array *left, struct _wchar_array *right )
{
    unsigned int cmp_len = (left->length < right->length)?left->length : right->length;
    int cmp_result = 0;
    
    if (cmp_len == 0)
    {
        if (right->length > 0) return -1;
        else if (left->length > 0) return 1;
        else return 0;
    }

    cmp_result = memcmp(left->data, right->data, cmp_len*sizeof(WCharT));
    if (cmp_result != 0) return cmp_result;
    
    if (left->length < right->length) return -1;
    else if (left->length > right->length) return 1;
    else return 0;
}

static String *to_string_WCharArray( struct _wchar_array *ba )
{
    char buf[250];

    sprintf( buf, "<%p, %u>", ba->data, ba->length );

    return create_String( buf );
}

static void destroy_WCharArray( struct _wchar_array *ba )
{
    if (ba->length != 0) free(ba->data);
}

#if CTESK_VERSION >= 25247
static String* to_xml_WCharArray( struct _wchar_array* ba )
{
 return to_XML_spec( "WCharArray", to_string_WCharArray( ba ) );
} 

specification invariant typedef struct _wchar_array WCharArray = {
    .init      = (Init)init_WCharArray,
    .copy      = (Copy)copy_WCharArray,
    .compare   = (Compare)compare_WCharArray,
    .to_string = (ToString)to_string_WCharArray,
    .to_XML    = (ToXML)to_xml_WCharArray,
    .destroy   = (Destroy)destroy_WCharArray
};

invariant(WCharArray* self)
{
  return (self->data == NULL)? (self->length == 0) : 1;
}

#else // Old CTesK

static bool check_invariant_WCharArray(struct _wchar_array * ba)
{
    return (ba->data == NULL)? ba->length == 0 : 1;
}

const Type type_WCharArray
    = { "WCharArray"
      , sizeof(struct _wchar_array)
      , &type_Object
      , (Init)init_WCharArray
      , (Copy)copy_WCharArray
      , (Compare)compare_WCharArray
      , (ToString)to_string_WCharArray
      , (CheckInvariant)check_invariant_WCharArray
      , (Enumerate)enumerate_Default
      , (Destroy)destroy_WCharArray
      };
#endif


/*
 * Constructs a newly allocated WCharArray object
 * that represents a wide characters array.
 *
 * ptr can be NULL if and only if len is zero
 */
WCharArray* create_WCharArray( WCharT* ptr, unsigned int len )
{
    return create(&type_WCharArray, ptr, len);
}

/*
 * Returns the value of this WCharArray as a WCharT *.
 */
WCharT* wcharArray_WCharArray( WCharArray* self )
{
    return self->data;
}

/*
 * Returns the length of this VoidAst.
 */
unsigned int size_WCharArray( WCharArray* self )
{
    return self->length;
}

/*
 * Returns the wide character at the specified offset from the beginning of this
 * WCharArray.
 */
WCharT wcharAt_WCharArray( WCharArray* self, unsigned int offset )
{
    assertion(offset < self->length, FORMAT("Index beyond array boundary, %u (boundary %u)"),
              offset, self->length);
    return ((WCharT*)(self->data))[offset];
}

/*
 * Sets the value of the byte at the specified offset from the beginning of
 * this WByteArray.
 */
void setWCharAt_WCharArray(WCharArray* self, unsigned int offset, WCharT value)
{
    assertion(offset < self->length, FORMAT("Index beyond array boundary, %u (boundary %u)"),
              offset, self->length);
    ((WCharT*)(self->data))[offset] = value;
}

/*
 * Concatenates the specified array to the end of this array.
 */
WCharArray* concat_WCharArray( WCharArray *self, WCharArray *array )
{
WCharArray* res;
  
    assertion( self != NULL, FORMAT("self is NULL") );
    assertion( array != NULL, FORMAT("array is NULL") );

    if (self->length == 0)
      return clone(array);
    res = clone(self);
    res->data = realloc( res->data, (self->length + array->length)*sizeof(WCharT) );
    assertion( res->data != NULL, FORMAT("not enough memory") );
    memcpy( res->data + self->length, array->data, array->length*sizeof(WCharT) );
    res->length = self->length + array->length;
    return res;
}
