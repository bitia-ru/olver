/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common/tsstream.seh"
#include "common/ts_socket.h"
#include "common/verbose.h"

/********************************************************************/
/**                   Model To TSStream Encoding                   **/
/********************************************************************/
#ifdef _MSC_VER
  #define I64FORMAT  "%I64d"
  #define UI64FORMAT "%I64u"
#else
  #define I64FORMAT  "%lld"
  #define UI64FORMAT "%llu"
#endif

static char buff[64];


void writeEmptyByteArray_TSStream( TSStream* stream )
{
  writeTypeHeaderTSStream( stream, "ba" );
  writeInt32TSStream( stream, 0 );
}

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(ByteT) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
void writeCByteArray_TSStream( TSStream* stream, CByteArray* array )
{
  if (array == NULL)
   {writeEmptyByteArray_TSStream(stream);
    return;
   }
  writeTypeHeaderTSStream( stream, "ba" );
  writeInt32TSStream( stream, array->length );
  writeTSStream( stream, (char*)array->data, array->length );
}

void writeWCharArray_TSStream( TSStream* stream, WCharArray* array )
{
unsigned int i;

  writeTypeHeaderTSStream( stream, "wchararray" );
  writeInt32TSStream( stream, array->length );
  for( i = 0; i < array->length; i++ )
   {
    sprintf(buff,I64FORMAT,(int64_t)array->data[i]);
    writeStringTSStream(stream,buff);
    writeCharTSStream(stream,'\0');
   }
}

void writeIntList_TSStream( TSStream* stream, List* /*<int>*/ list )
{
    int i, num;

    num = list ? size_List(list) : -1;

    writeInt_TSStream(stream, num);
    
    if(num < 1) return;

    for(i = 0; i < num; i++)
        writeInt_TSStream(stream, *((IntTObj*)get_List(list, i)));
}

void writeStringLiteral_TSStream( TSStream* stream, const char* string )
{
  if (string == NULL)
   {writeTypeHeaderTSStream( stream, "null" );
    return;
   }
  writeTypeHeaderTSStream( stream, "str" );
  writeStringTSStream( stream, string );
  writeCharTSStream( stream, '\0' );
}

void writeString_TSStream( TSStream* stream, String* str )
{
  if (str == NULL)
   {writeTypeHeaderTSStream( stream, "null" );
    return;
   }
  writeTypeHeaderTSStream( stream, "str" );
  writeStringTSStream( stream, toCharArray_String(str) );
  writeCharTSStream( stream, '\0' );
}

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(char) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
void writeCString_TSStream( TSStream* stream, CString* str )
{
  if (str == NULL)
   {writeTypeHeaderTSStream( stream, "null" );
    return;
   }
  writeTypeHeaderTSStream( stream, "str" );
  writeStringTSStream( stream, toCharArray_CString(str) );
  writeCharTSStream( stream, '\0' );
}

void writeWString_TSStream(TSStream* stream, WString* wstr)
{
    if (wstr == NULL)
    {
        writeTypeHeaderTSStream(stream, "null");
        return;
    }
    writeTypeHeaderTSStream(stream, "wstr");
    //alignment checking is delegated to the target interface wrapper
    //alignTSStream( stream );
    writeTSStream(stream, (const char*)toWCharArray_WString(wstr), (length_WString(wstr) + 1) * sizeof(WCharT));
    if ( 0 ) {
        int i;
        verbose( "writeWString_TSStream : stream->cursor        is [%i]\n", stream->cursor        );
        verbose( "writeWString_TSStream : stream->buffer.length is [%i]\n", stream->buffer.length );
        verbose( "writeWString_TSStream : stream->buffer.data   is\n" );
        for ( i = 0; i < stream->buffer.length; i++ ) {
            unsigned char c = stream->buffer.data[ i ];
            verbose( "[%3hhu|%c]", c, c < 32 || 127 < c ? '?' : c );
            if ( ( i + 1 ) % 10 == 0 ) { verbose( "\n" ); }
        }
        if ( stream->buffer.length % 10 != 0 ) { verbose( "\n" ); }
    }
}

/* Standard Integer Types */

/* Assertion: sizeof(char) == sizeof(CharT) */
void writeChar_TSStream( TSStream* stream, CharT value )
{
  writeTypeHeaderTSStream(stream,"char");
  writeCharTSStream(stream,(char)value);
}

void writeSChar_TSStream( TSStream* stream, SCharT value )
{
  writeTypeHeaderTSStream(stream,"schar");
  writeCharTSStream(stream,(char)value);
}

void writeUChar_TSStream( TSStream* stream, UCharT value )
{
  writeTypeHeaderTSStream(stream,"uchar");
  writeCharTSStream(stream,(char)value);
}

void writeShort_TSStream( TSStream* stream, ShortT value )
{
  writeTypeHeaderTSStream(stream,"short");
  sprintf(buff,"%d",(int)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeUShort_TSStream( TSStream* stream, UShortT value )
{
  writeTypeHeaderTSStream(stream,"ushort");
  sprintf(buff,"%u",(unsigned)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeInt_TSStream( TSStream* stream, IntT value )
{
  writeTypeHeaderTSStream(stream,"int");
  sprintf(buff,"%ld",(long)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeUInt16_TSStream( TSStream* stream, UInt16T value )
{
  writeTypeHeaderTSStream(stream,"uint16");
  sprintf(buff,"%lu",(unsigned long)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeUInt_TSStream( TSStream* stream, UIntT value )
{
  writeTypeHeaderTSStream(stream,"uint");
  sprintf(buff,"%lu",(unsigned long)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeUInt32_TSStream( TSStream* stream, UInt32T value )
{
  writeTypeHeaderTSStream(stream,"uint32");
  sprintf(buff,"%lu",(unsigned long)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeLong_TSStream( TSStream* stream, LongT value )
{
  writeTypeHeaderTSStream(stream,"long");
  sprintf(buff,I64FORMAT,(int64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeLongReal_TSStream( TSStream* stream, LongT value )
{
  writeTypeHeaderTSStream(stream,"long");
  sprintf(buff,"%ld",(sut_long)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeULong_TSStream( TSStream* stream, ULongT value )
{
  writeTypeHeaderTSStream(stream,"ulong");
  sprintf(buff,UI64FORMAT,(uint64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeLLong_TSStream( TSStream* stream, LLongT value )
{
  writeTypeHeaderTSStream(stream,"llong");
  sprintf(buff,I64FORMAT,(int64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeULLong_TSStream( TSStream* stream, ULLongT value )
{
  writeTypeHeaderTSStream(stream,"ullong");
  sprintf(buff,UI64FORMAT,(uint64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeWChar_TSStream( TSStream* stream, WCharT value )
{
  writeTypeHeaderTSStream(stream,"wchar");
  sprintf(buff,I64FORMAT,(int64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeSize_TSStream( TSStream* stream, SizeT value )
{
  writeTypeHeaderTSStream(stream,"size");
  sprintf(buff,UI64FORMAT,(uint64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeSSize_TSStream( TSStream* stream, SSizeT value )
{
  writeTypeHeaderTSStream(stream,"ssize");
  sprintf(buff,I64FORMAT,(int64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeIntMaxT_TSStream( TSStream* stream, IntMaxT value )
{
  writeTypeHeaderTSStream(stream,"intmax");
  sprintf(buff,I64FORMAT,(int64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeIntPtrT_TSStream(TSStream* stream, IntPtrT value)
{
    writeTypeHeaderTSStream(stream, "intptr");
    sprintf(buff, I64FORMAT, (int64_t)value);
    writeStringTSStream(stream, buff);
    writeCharTSStream(stream, '\0');
}

/* Real Floating Types */
// Replaced with Unifloat
/*
void writeFloat_TSStream( TSStream* stream, FloatT value )
{
    writeTypeHeaderTSStream(stream, "float");
    sprintf(buff, "%f", value); // !!!!!!!!!!!!!!!!
    writeStringTSStream(stream, buff);
    writeCharTSStream(stream, '\0');
}

void writeDouble_TSStream( TSStream* stream, DoubleT value )
{
    writeTypeHeaderTSStream(stream, "double");
    sprintf(buff, "%lf", value); // !!!!!!!!!!!!!!!!
    writeStringTSStream(stream, buff);
    writeCharTSStream(stream, '\0');
}

void writeLongDouble_TSStream( TSStream* stream, LongDoubleT value );
*/

/* Pointers */
void writePointer_TSStream( TSStream* stream, VoidTPtr value )
{
  writeTypeHeaderTSStream(stream,"ptr");
  sprintf(buff,UI64FORMAT,(uint64_t)value.address);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

/* Additional Types */
void writeTimeUnit_TSStream( TSStream* stream, TimeUnit value )
{
  writeTypeHeaderTSStream(stream,"timeunit");
  sprintf(buff,I64FORMAT,(int64_t)value);
  writeStringTSStream(stream,buff);
  writeCharTSStream(stream,'\0');
}

void writeFlags_TSStream( TSStream* stream, List* value )
{
int i,size;

  writeTypeHeaderTSStream(stream,"flags");
  size = size_List(value);
  for( i = 0; i < size; i++ )
   {
    String* flag = get_List( value, i );
    writeString_TSStream( stream, flag );
   }
  writeTypeHeaderTSStream(stream,"endflags");
}


/********************************************************************/
/**                   TSStream To Model Decoding                   **/
/********************************************************************/

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(ByteT) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
CByteArray* readCByteArray_TSStream(TSStream* stream)
{
CByteArray* res;
TSInt32 length;

  verifyType_TSStream(stream,"ba");
  length = readTSInt32_TSStream(stream);
  verifyLength_TSStream(stream,length);
  res = create_CByteArray((ByteT*)pointer_TSStream(stream),length);
  shift_TSInputStream(stream,length);
  return res;
}

WCharArray* readWCharArray_TSStream(TSStream* stream)
{
WCharArray* res;
TSInt32 length;
WCharT* data;
uint64_t res2;
int i;

  verifyType_TSStream(stream,"wchararray");
  length = readTSInt32_TSStream(stream);
  data = malloc(length*sizeof(WCharT));
  assertion( data != NULL, "readWCharArray_TSStream: not enought memory" );
  for( i = 0; i < length; i++ )
   {
    sscanf(pointer_TSStream(stream),UI64FORMAT,&res2);
    shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
    data[i] = (WCharT)res2;
   }
  res = create_WCharArray(data,length);
  free(data);
  return res;
}

List* /*<int>*/ readIntList_TSStream(TSStream* stream)
{
    int i, num;
    List* list = create_List(NULL);

    num = readInt_TSStream(stream);

    assertion(num >= -1, "readIntArray_TSStream: num < -1");
    
    if(num < 0) return NULL;

    if(num > 0) for(i = 0; i < num; i++)
        append_List(list, create_IntTObj(readInt_TSStream(stream)));

    return list;
}

char* readStringAsCharArray_TSStream(TSStream* stream)
{
char* res;

  if (startsWith_TSStream(stream,"null:"))
   {verifyType_TSStream(stream,"null");
    return NULL;
   }
  verifyType_TSStream(stream,"str");
  res = pointer_TSStream(stream);
  shift_TSInputStream(stream,strlen(res)+1);
  return res;
}

String* readString_TSStream(TSStream* stream)
{
String* res;

  if (startsWith_TSStream(stream,"null:"))
   {verifyType_TSStream(stream,"null");
    return NULL;
   }
  verifyType_TSStream(stream,"str");
  res = create_String(pointer_TSStream(stream));
  shift_TSInputStream(stream,length_String(res)+1);
  return res;
}

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(char) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
CString* readCString_TSStream(TSStream* stream)
{
CString* res;

  if (startsWith_TSStream(stream,"null:"))
   {verifyType_TSStream(stream,"null");
    return NULL;
   }
  verifyType_TSStream(stream,"str");
  res = create_CString(pointer_TSStream(stream));
  shift_TSInputStream(stream,length_CString(res)+1);
  return res;
}

WString* readWString_TSStream(TSStream* stream)
{
WString* res;
TSInt32 length;
WCharT* data;
uint64_t res2;
int i;

  if (startsWith_TSStream(stream,"null:"))
   {verifyType_TSStream(stream,"null");
    return NULL;
   }
  verifyType_TSStream(stream,"wstr");
  length = readTSInt32_TSStream(stream);
  data = malloc( (length+1)*sizeof(WCharT) );
  assertion( data != NULL, "readWString_TSStream: not enought memory" );
  for( i = 0; i < length; i++ )
   {
    sscanf(pointer_TSStream(stream),UI64FORMAT,&res2);
    shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
    data[i] = (WCharT)res2;
   }
  data[i] = (WCharT)0;
  res = create_WString(data);
  free(data);
  return res;
}

/* Standard Integer Types */
CharT readChar_TSStream(TSStream* stream)
{
CharT res;

  verifyType_TSStream(stream,"char");
  res = *pointer_TSStream(stream);
  shift_TSInputStream(stream,1);
  return res;
}

SCharT readSChar_TSStream(TSStream* stream)
{
SCharT res;

  verifyType_TSStream(stream,"schar");
  res = *pointer_TSStream(stream);
  shift_TSInputStream(stream,1);
  return res;
}

UCharT readUChar_TSStream(TSStream* stream)
{
UCharT res;

  verifyType_TSStream(stream,"uchar");
  res = *pointer_TSStream(stream);
  shift_TSInputStream(stream,1);
  return res;
}

ShortT readShort_TSStream(TSStream* stream)
{
ShortT res;

  verifyType_TSStream(stream,"short");
  sscanf(pointer_TSStream(stream),"%hd",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

UShortT readUShort_TSStream(TSStream* stream)
{
UShortT res;

  verifyType_TSStream(stream,"ushort");
  sscanf(pointer_TSStream(stream),"%hu",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

IntT readInt_TSStream(TSStream* stream)
{
IntT res;

  verifyType_TSStream(stream,"int");
  sscanf(pointer_TSStream(stream),"%d",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

UInt16T readUInt16_TSStream(TSStream* stream)
{
UInt16T res;

  verifyType_TSStream(stream,"uint16");
  sscanf(pointer_TSStream(stream),"%hu",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

UIntT readUInt_TSStream(TSStream* stream)
{
UIntT res;

  verifyType_TSStream(stream,"uint");
  sscanf(pointer_TSStream(stream),"%u",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

UInt32T readUInt32_TSStream(TSStream* stream)
{
UInt32T res;

  verifyType_TSStream(stream,"uint32");
  sscanf(pointer_TSStream(stream),"%u",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

LongT readLong_TSStream(TSStream* stream)
{
  int64_t res;

  verifyType_TSStream(stream,"long");
  sscanf(pointer_TSStream(stream),I64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (LongT)res;
}

LongT readLongReal_TSStream(TSStream* stream)
{
  LongT res;

  verifyType_TSStream(stream,"long");
  sscanf(pointer_TSStream(stream),"%ld",&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (LongT)res;
}

ULongT readULong_TSStream(TSStream* stream)
{
uint64_t res;

  verifyType_TSStream(stream,"ulong");
  sscanf(pointer_TSStream(stream),UI64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (ULongT)res;
}

LLongT readLLong_TSStream(TSStream* stream)
{
int64_t res;

  verifyType_TSStream(stream,"llong");
  sscanf(pointer_TSStream(stream),I64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (LLongT)res;
}

ULLongT readULLong_TSStream(TSStream* stream)
{
uint64_t res;

  verifyType_TSStream(stream,"ullong");
  sscanf(pointer_TSStream(stream),UI64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (ULLongT)res;
}

WCharT readWChar_TSStream(TSStream* stream)
{
uint64_t res;

  verifyType_TSStream(stream,"wchar");
  sscanf(pointer_TSStream(stream),UI64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (WCharT)res;
}

SizeT readSize_TSStream(TSStream* stream)
{
uint64_t res;

  verifyType_TSStream(stream,"size");
  sscanf(pointer_TSStream(stream),UI64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (SizeT)res;
}

SSizeT readSSize_TSStream(TSStream* stream)
{
int64_t res;

  verifyType_TSStream(stream,"ssize");
  sscanf(pointer_TSStream(stream),I64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return (SSizeT)res;
}

IntMaxT readIntMaxT_TSStream(TSStream* stream)
{
int64_t res;
    
  verifyType_TSStream(stream,"intmax");
  sscanf(pointer_TSStream(stream),I64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

/* Real Floating Types */
FloatT readFloat_TSStream(TSStream* stream)
{
    float res;

    verifyType_TSStream(stream,"float");
    sscanf(pointer_TSStream(stream),"%f",&res);
    shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
    return res;
}

DoubleT readDouble_TSStream(TSStream* stream)
{
    double res;

    verifyType_TSStream(stream,"double");
    sscanf(pointer_TSStream(stream),"%lf",&res);
    shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
    return res;
}

LongDoubleT readLongDouble_TSStream(TSStream* stream);


/* Pointers */
VoidTPtr readPointer_TSStream(ThreadId threadid,TSStream* stream)
{
uint64_t addr;
VoidTPtr res;

  verifyType_TSStream(stream,"ptr");
  res.system = threadid.system;
  res.process = threadid.process;
  sscanf(pointer_TSStream(stream),UI64FORMAT,&addr);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  res.address = addr;
  return res;
}

/* Additional Types */
TimeUnit readTimeUnit_TSStream(TSStream* stream)
{
TimeUnit res;

  verifyType_TSStream(stream,"timeunit");
  sscanf(pointer_TSStream(stream),I64FORMAT,&res);
  shift_TSInputStream(stream,strlen(pointer_TSStream(stream))+1);
  return res;
}

List* readFlags_TSStream(TSStream* stream)
{
List* res;
 
  res = create_List(NULL);
  verifyType_TSStream(stream,"flags");
  for(;!startsWith_TSStream(stream,"endflags:");)
   {
    append_List( res, readString_TSStream(stream) );
   }
  verifyType_TSStream(stream,"endflags");
  return res;
}

void readCancelStatus_TSStream(TSStream* stream,CancelStatus status)
{
IntT res2;
  
  res2 = readInt_TSStream(stream);
  if (res2)
    *status = true;
  else
    *status = false;
}

