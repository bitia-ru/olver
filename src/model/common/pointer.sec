/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "common/pointer.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"


/********************************************************************/
/**                Model Representation of Pointer                 **/
/********************************************************************/

/*
 * Returns a result of subtraction of the arguments.
 */
PtrDiffT diff_VoidTPtr( VoidTPtr ptr1, VoidTPtr ptr2 )
{
  assertion( ptr1.system == ptr2.system,   "diff_VoidTPtr: different systems" );
  assertion( ptr1.process == ptr2.process, "diff_VoidTPtr: different processes" );
  return (PtrDiffT)(ptr1.address - ptr2.address);
}

/*
 * Returns a result of addition of the arguments.
 */
VoidTPtr add_VoidTPtr( VoidTPtr ptr, LongT index )
{
VoidTPtr res;

  res.system = ptr.system;
  res.process = ptr.process;
  res.address = ptr.address + index;
  return  res;
}

/*
 * Returns a result of subtraction of the arguments.
 */
VoidTPtr subtract_VoidTPtr( VoidTPtr ptr, LongT index )
{
VoidTPtr res;

  res.system = ptr.system;
  res.process = ptr.process;
  res.address = ptr.address - index;
  return  res;
}


/********************************************************************/
/**                         Memory Readers                         **/
/********************************************************************/
CharT readChar_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
CharT res = 0;

  format_TSCommand( &command, "read_char:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readChar_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

SCharT readSChar_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
CharT res = 0;

  format_TSCommand( &command, "read_char:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readChar_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

UCharT readUChar_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
CharT res = 0;

  format_TSCommand( &command, "read_char:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readChar_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

ShortT readShort_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
ShortT res = 0;

  format_TSCommand( &command, "read_short:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readShort_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

UShortT readUShort_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
UShortT res = 0;

  format_TSCommand( &command, "read_short:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = (UShortT)readShort_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

IntT readInt_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
IntT res = 0;

  format_TSCommand( &command, "read_int:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readInt_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

UIntT readUInt_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
UIntT res = 0;

  format_TSCommand( &command, "read_int:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = (UIntT)readInt_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

LongT readLong_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
LongT res = 0;

  format_TSCommand( &command, "read_long:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readLong_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

ULongT readULong_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
ULongT res = 0;

  format_TSCommand( &command, "read_ulong:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readULong_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

LLongT readLLong_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
LLongT res = 0;

  format_TSCommand( &command, "read_llong:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readLLong_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

ULLongT readULLong_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
ULLongT res = 0;

  format_TSCommand( &command, "read_ullong:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readULLong_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

WCharT readWChar_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
WCharT res = 0;

  format_TSCommand( &command, "read_wchar:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readWChar_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(char) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
CByteArray* readCByteArray_VoidTPtr( VoidTPtr ptr, SizeT size )
{
TSCommand command = create_TSCommand();
bool verdict;
CByteArray* res = NULL;

  if (size == 0)
   {
    return create_CByteArray( NULL, 0 );
   }
  format_TSCommand( &command, "read_byte_array:$(ptr)$(size)", create_VoidTPtrObj(ptr), create_SizeTObj(size) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readCByteArray_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

WCharArray* readWCharArray_VoidTPtr( VoidTPtr ptr, SizeT size )
{
TSCommand command = create_TSCommand();
bool verdict;
WCharArray* res = NULL;

  if (size == 0)
   {
    return create_WCharArray( NULL, 0 );
   }
  format_TSCommand( &command, "read_wchar_array:$(ptr)$(size)", create_VoidTPtrObj(ptr), create_SizeTObj(size) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readWCharArray_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

String* readString_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
String* res = NULL;

  format_TSCommand( &command, "read_string:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readString_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

String* readLimitedString_VoidTPtr( VoidTPtr ptr, SizeT size )
{
TSCommand command = create_TSCommand();
bool verdict;
String* res = NULL;

  if (size == 0)
   {
    return create_String( "" );
   }
  format_TSCommand( &command, "read_limited_string:$(ptr)$(size)", create_VoidTPtrObj(ptr), create_SizeTObj(size) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readString_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}


CString* readCString_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
CString* res = NULL;

  format_TSCommand( &command, "read_string:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readCString_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

CString* readLimitedCString_VoidTPtr( VoidTPtr ptr, SizeT size )
{
TSCommand command = create_TSCommand();
bool verdict;
CString* res = NULL;

  format_TSCommand( &command, "read_limited_string:$(ptr)$(size)", create_VoidTPtrObj(ptr), create_SizeTObj(size) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readCString_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}


WString* readWString_VoidTPtr( VoidTPtr ptr )
{
TSCommand command = create_TSCommand();
bool verdict;
WString* res = NULL;

  format_TSCommand( &command, "read_wstring:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readWString_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}

WString* readLimitedWString_VoidTPtr( VoidTPtr ptr, SizeT size )
{
TSCommand command = create_TSCommand();
bool verdict;
WString* res = NULL;

  format_TSCommand( &command, "read_limited_wstring:$(ptr)$(size)", create_VoidTPtrObj(ptr), create_SizeTObj(size) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    res = readWString_TSStream(&command.response);
   }

  destroy_TSCommand(&command);

  return res;
}


VoidTPtr readPointer_VoidTPtr(CallContext context, VoidTPtr ptr)
{
TSCommand command = create_TSCommand();
bool verdict;
VoidTPtr res;

  format_TSCommand( &command, "read_pointer:$(ptr)", create_VoidTPtrObj(ptr) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
     res = readPointer_TSStream(context, &command.response);
   }

  destroy_TSCommand(&command);

  return res;
}
/********************************************************************/
/**                           Memory Writers                       **/
/********************************************************************/
bool writeChar_VoidTPtr( VoidTPtr ptr, CharT value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_char:$(ptr)$(char)", create_VoidTPtrObj(ptr), create_CharTObj(value) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

bool writeInt_VoidTPtr( VoidTPtr ptr, IntT value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_int:$(ptr)$(int)", create_VoidTPtrObj(ptr), create_IntTObj(value) );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

bool writeLong_VoidTPtr(VoidTPtr ptr, LongT value)
{
    TSCommand command = create_TSCommand();
    bool verdict;

    format_TSCommand(&command, "write_long:$(ptr)$(long)", create_VoidTPtrObj(ptr), create_LongTObj(value));
    verdict = executeCommandInContext(getSystemContext(ptr.system,ptr.process), &command);
    if (verdict)
    {
        String* code = readString_TSStream(&command.response);
        verdict = equals(code, create_String("Ok"));
        if (!verdict)
            traceUserInfo(toCharArray_String(code));
    }

    destroy_TSCommand(&command);

    return verdict;
}

bool writeWChar_VoidTPtr( VoidTPtr ptr, WCharT value ) {
    assertion( sizeof( WCharT ) == sizeof( IntT ), "writeWChar_VoidTPtr : sizeof( WCharT ) != sizeof( IntT )\n" );
    return writeInt_VoidTPtr( ptr, value );
}

bool writeSChar_VoidTPtr( VoidTPtr ptr, SCharT value );
bool writeUChar_VoidTPtr( VoidTPtr ptr, UCharT value );
bool writeShort_VoidTPtr( VoidTPtr ptr, ShortT value );
bool writeUShort_VoidTPtr( VoidTPtr ptr, UShortT value );
bool writeUInt_VoidTPtr( VoidTPtr ptr, UIntT value );
bool writeULong_VoidTPtr( VoidTPtr ptr, ULongT value );
bool writeLLong_VoidTPtr( VoidTPtr ptr, LLongT value );
bool writeULLong_VoidTPtr( VoidTPtr ptr, ULLongT value );

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(char) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
bool writeCByteArray_VoidTPtr( VoidTPtr ptr, CByteArray* value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_byte_array:$(ptr)$(ba)", create_VoidTPtrObj(ptr), value );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

bool writeWCharArray_VoidTPtr( VoidTPtr ptr, WCharArray* value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_wchar_array:$(ptr)$(wchararray)", create_VoidTPtrObj(ptr), value );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

bool writeString_VoidTPtr( VoidTPtr ptr, String* value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_byte_array:$(ptr)$(ba)",
                                  create_VoidTPtrObj(ptr),
                                  create_CByteArray( (ByteT*)toCharArray_String(value), length_String(value) + 1 )
                  );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

/*
 * Linux Standard Base Specific Assertion
 *
 * Assertion: sizeof(char) == 1
 *   Always true within
 *     Linux Standard Base Core Specification 3.1
 *     Copyright (c) 2004, 2005 Free Standards Group
 *
 *     See section 'Data Definitions for libc'.
 */
bool writeCString_VoidTPtr( VoidTPtr ptr, CString* value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_byte_array:$(ptr)$(ba)",
                                  create_VoidTPtrObj(ptr),
                                  create_CByteArray( (ByteT*)toCharArray_CString(value),
                                                    (length_CString(value) + 1)*sizeof(CharT)
                                                  )
                  );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

bool writeWString_VoidTPtr( VoidTPtr ptr, WString* value )
{
TSCommand command = create_TSCommand();
bool verdict;

  format_TSCommand( &command, "write_wchar_array:$(ptr)$(wchararray)",
                                  create_VoidTPtrObj(ptr),
                                  create_WCharArray( (WCharT*)toWCharArray_WString(value), length_WString(value) + 1 )
                  );
  verdict = executeCommandInContext( getSystemContext(ptr.system,ptr.process), &command );
  if (verdict)
   {
    String* code = readString_TSStream(&command.response);
    verdict = equals( code, create_String("Ok") );
    if (!verdict)
      traceUserInfo( toCharArray_String(code) );
   }

  destroy_TSCommand(&command);

  return verdict;
}

bool writePointer_VoidTPtr(CallContext context, VoidTPtr ptr, VoidTPtr value)
{
    TSCommand command = create_TSCommand();
    bool verdict;

    format_TSCommand(&command, "write_pointer:$(ptr)$(ptr)",
                                create_VoidTPtrObj(ptr),
                                create_VoidTPtrObj(value)
                    );
    verdict = executeCommandInContext(context, &command);

    destroy_TSCommand(&command);

    return verdict;
}
