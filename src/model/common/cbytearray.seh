/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef COMMON_CBYTE_ARRAY_SEH
#define COMMON_CBYTE_ARRAY_SEH

#include <atl/object.h>
#include "data/embed_model.seh"


/********************************************************************/
/**                               ByteT                            **/
/********************************************************************/

typedef UCharT    ByteT;

typedef UCharTObj ByteTObj;

#define create_ByteTObj create_UCharTObj
#define type_ByteTObj type_UCharTObj


/********************************************************************/
/**                             CByteArray                         **/
/********************************************************************/
struct _cbyte_array
{
    ByteT*       data;
    unsigned int length;
};

#ifdef __SEC__
  #pragma SEC file
  specification invariant typedef struct _cbyte_array CByteArray;
#else
  typedef struct _cbyte_array CByteArray;
  extern const Type type_CByteArray;
#endif


/*
 * Constructs a newly allocated CByteArray object
 * that represents a wide characters array.
 *
 * ptr can be NULL if and only if len is zero
 */
CByteArray* create_CByteArray( ByteT* ptr, unsigned int len );

/*
 * Returns the value of this CByteArray as a ByteT*.
 */
ByteT* byteArray_CByteArray( CByteArray* self );

/*
 * Returns the size of this CByteArray.
 */
unsigned int size_CByteArray( CByteArray* self );

/*
 * Returns the byte at the specified offset from the beginning of this
 * CByteArray.
 */
ByteT byteAt_CByteArray( CByteArray* self, unsigned int offset );

/*
 * Sets the value of the byte at the specified offset from the beginning of
 * this CByteArray.
 */
void setByteAt_CByteArray( CByteArray* self, unsigned int offset, ByteT value );

/*
 * Creates a new array containing concatination of the specified arrays.
 */
CByteArray* concat_CByteArray( CByteArray* self, CByteArray* array );

/*
 * Creates a new array that is a specified left part of the original array
 */
CByteArray* left_CByteArray(CByteArray* data, SSizeT sz);

/*
 * Creates a new array that is a specified right part of the original array
 */
CByteArray* right_CByteArray(CByteArray* data, SSizeT pos);

/*
 * Compares parts of the arrays no longer than nbytes
 */
bool compare_CByteArrays(CByteArray* ar1, CByteArray* ar2, SSizeT nbytes);

#endif
