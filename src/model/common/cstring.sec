/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <common/cstring.seh>

#include <utils/boolean.h>
#include <utils/assertion.h>
#include <ctype.h>

// Temporary here
#include "ts/version.hh"


static void _init_string( struct _string* str, CharT* ptr )
{
int i,size;

  for( i = 0; ptr[i]!=0; i++ );
  str->length = i;
  size = (str->length + 1)*sizeof(CharT);
  str->data = malloc( size );
  assertion( str->data != NULL, FORMAT("Failed to allocate memory") );
  memcpy(str->data, ptr, size );
}

static void init_CString( struct _string* str, va_list* arg_list )
{
    CharT* ptr = va_arg( *arg_list, void* );
    
    _init_string( str, ptr );
}

static void copy_CString( struct _string *src, struct _string *dst )
{
  _init_string(dst, src->data);
}

static int compare_CString( struct _string *left, struct _string *right )
{
int cmp_len = (left->length < right->length)?left->length : right->length;
int i,cmp_result = 0;
   
  for( i = 0; i < cmp_len; i++ )
   {
    cmp_result = left->data[i] - right->data[i];
    if (cmp_result != 0)
      return cmp_result;
   }
  if (left->length < right->length) 
    return -1;
  else if (left->length > right->length) 
    return 1;
  return 0;
}

static String* to_string_CString( struct _string* str )
{
int i;
char* conv;
String* res;

  conv = malloc( str->length+1 );
  assertion( conv != NULL, FORMAT("Failed to allocate memory, length %u"),
             str->length+1
           );

  for( i = 0; i < str->length; i++ )
   {
    conv[i] = (char)str->data[i];
   }
  conv[i] = 0;
  
  res = create_String( conv );
  
  free(conv);

  return res;
}

static void destroy_CString( struct _string* str )
{
  free(str->data);
}

#if CTESK_VERSION >= 25247
static String* to_xml_CString( struct _string* str )
{
 return to_XML_spec( "CString", to_string_CString( str ) );
} 

specification typedef struct _string CString = {
    .init      = (Init)init_CString,
    .copy      = (Copy)copy_CString,
    .compare   = (Compare)compare_CString,
    .to_string = (ToString)to_string_CString,
    .to_XML    = (ToXML)to_xml_CString,
    .destroy   = (Destroy)destroy_CString
};

#else // Old CTesK

const Type type_CString
    = { "CString"
      , sizeof(struct _string)
      , &type_Object
      , (Init)init_CString
      , (Copy)copy_CString
      , (Compare)compare_CString
      , (ToString)to_string_CString
      , (CheckInvariant)check_invariant_Default
      , (Enumerate)enumerate_Default
      , (Destroy)destroy_CString
      };
#endif


/*
 * Constructs a newly allocated CString object
 * that represents a null terminated string.
 */
CString* create_CString( CharT* str )
{
  return create( &type_CString, str );
}

/*
 * Returns the value of this CString as a CharT*.
 */
CharT* toCharArray_CString( CString* self )
{
    if (!self)
    {
        return 0;
    }
    else
    {
        return self->data;
    }
}

/*
 * Returns the length of this CString.
 */
int length_CString( CString* self )
{
  return self->length;
}

/*
 * Returns the character at the specified offset from the beginning of this
 * CString.
 */
CharT charAt_CString( CString* self, int offset )
{
  assertion( 0 <= offset, FORMAT("Index is less than zero") );
  assertion( offset < self->length, FORMAT("Index beyond string boundary, %d (boundary %d)"),
              offset, self->length);
  return ((CharT*)(self->data))[offset];
}

/*
 * Sets the character at the specified offset from the beginning of this
 * CString.
 */
void setCharAt_CString( CString* self, int offset, CharT val )
{
  assertion( 0 <= offset, FORMAT("Index is less than zero") );
  assertion( offset < self->length, FORMAT("Index beyond string boundary, %d (boundary %d)"),
              offset, self->length);
  ((CharT*)(self->data))[offset] = val;
}


/*
 * Concatenates the specified string to the end of this string.
 */
CString* concat_CString( CString* self, CString *str )
{
CString* res;
  
  assertion( self != NULL, FORMAT("self is NULL") );
  assertion( str != NULL, FORMAT("str is NULL") );

  if (self->length == 0)
    return clone(str);
  if (str->length == 0)
    return clone(self);
  res = clone(self);
  res->data = realloc( res->data, (self->length + str->length + 1)*sizeof(CharT) );
  assertion( res->data != NULL, FORMAT("Failed to allocate memory") );
  memcpy( res->data + self->length, str->data, (str->length + 1)*sizeof(CharT) );
  res->length = self->length + str->length;
  return res;
}


/*
 * Returns the index within this string of the first occurrence 
 * of the specified character.
 */
int indexOfChar_CString( CString *self, CharT ch )
{
  return indexOfCharFrom_CString( self, ch, 0 );
}

/*
 * Returns the index within this string of the first occurrence
 * of the specified character, starting the search at the specified index.
 */
int indexOfCharFrom_CString( CString *self, CharT ch, int fromIndex )
{
int res = - 1;

  CHECK_TYPE_COMPATIBLE( indexOfCharFrom_CString, &type_CString, self );

  if( fromIndex < 0 ) fromIndex = 0;

  if( ch != 0 && fromIndex < length_CString( self ) )
   {
    const CharT* self_cstr = toCharArray_CString( self );
    int i;
    
    for( i = fromIndex; self_cstr[i] != 0; i++ )
     {
      if (self_cstr[i] == ch)
       {
        res = i;
        break;
       }
     }
   }

  return res;
}


/*
 * Returns a new string that is a substring of this string.
 */
CString *substringFrom_CString( CString *self, int beginIndex )
{
  CHECK_TYPE_COMPATIBLE( substringFrom_CString, &type_CString, self );

  assertion( 0 <= beginIndex && beginIndex <= length_CString( self )
           , FORMAT( "substringFrom_CString: beginIndex %d is out of bounds [0,%d]" )
           , beginIndex
           , length_CString( self )
           );

  return create_CString( toCharArray_CString( self ) + beginIndex );
}

/*
 * Returns a new string that is a substring of this string.
 */
CString *substring_CString( CString *self, int beginIndex, int endIndex )
{
CString* res;
int i;
CharT* res_cstr;
CharT* self_cstr;

  CHECK_TYPE_COMPATIBLE( substring_CString, &type_CString, self );

  assertion(    0 <= beginIndex 
             && beginIndex <= endIndex 
             && endIndex <= length_CString( self )
           , FORMAT( "substring_CString: beginIndex %d or endIndex %d are out of bounds [0,%d]"
                     " or endIndex < beginIndex" 
                   )
           , beginIndex
           , endIndex
           , length_CString( self )
           );

  res_cstr = calloc( endIndex - beginIndex + 1, sizeof(CharT) );
  assertion( res_cstr != NULL, "substring_CString: Not enought memory" );

  self_cstr = toCharArray_CString( self );

  for( i = 0; i < endIndex - beginIndex; i++ )
   {
    res_cstr[i] = self_cstr[beginIndex+i];
   }
  res_cstr[i] = 0;

  res = create_CString(res_cstr);
  free(res_cstr);

  return res;
}

/*
 * Removes white space from both ends of this string.
 */
CString* trim_CString( CString *self )
{
int len;
int beginIndex;
int endIndex;

  CHECK_TYPE_COMPATIBLE( trim_CString, &type_CString, self );

  len = length_CString( self );

  for( beginIndex = 0; beginIndex < len; beginIndex++ )
   {
    if( !isspace( charAt_CString( self, beginIndex ) ) ) break;
   }

  if( beginIndex == len )
   {
    return create_CString( "" );
   }

  for( endIndex = len - 1; beginIndex < endIndex; endIndex-- )
   {
    if( !isspace( charAt_CString( self, endIndex ) ) ) break;
   }

  return substring_CString( self, beginIndex, endIndex + 1 );
}

/*
 * Returns a new string resulting from replacing all occurrences
 * of old substring in this string with new string.
 */
CString* replace_CString( CString *self, CString* old, CString* new )
{
CString* res;
CString* tail;
CharT* res_cstr;
CharT* old_cstr;
int old_len;
int new_len;
int len;
int beginIndex;

  CHECK_TYPE_COMPATIBLE( replace_CString, &type_CString, self );
  CHECK_TYPE_COMPATIBLE( replace_CString, &type_CString, old );
  CHECK_TYPE_COMPATIBLE( replace_CString, &type_CString, new );
  
  old_cstr = toCharArray_CString( old );
  old_len = length_CString( old );
  new_len = length_CString( new );

  res = clone( self );
  res_cstr = toCharArray_CString( res );
  len = length_CString( res );
  
  for( beginIndex = 0; beginIndex <= len - old_len; beginIndex++ )
   {
      if (memcmp(&(res_cstr[beginIndex]), old_cstr, old_len) == 0)
       {
       	  tail = substringFrom_CString( res, beginIndex + old_len );
       	  res = concat_CString( substring_CString( res, 0, beginIndex ), new );
       	  res = concat_CString( res, tail );

       	  res_cstr = toCharArray_CString( res );
       	  len = len + new_len - old_len;
       	  beginIndex = beginIndex + new_len - 1;
       }
   }

  return res;
}

CString *createChar_CString(CharT ch)
{
    CharT cstr[2];
    cstr[0] = ch;
    cstr[1] = 0;
    return create_CString(cstr);
}

CString *concatChar_CString(CString *self, CharT ch)
{
    return concat_CString(self, createChar_CString(ch));
}

CString *concatPChar_CString(CString *self, CharT *str)
{
    return concat_CString(self, create_CString(str));
}

bool isEmpty_CString(CString* self)
{
    return compare(self, _CS("")) == 0;
}

int safeCompare_CString(CString* str1, CString* str2)
{
    if(str1 == NULL || str2 == NULL) return str1 == str2 ? 0 : 1;
    
    return compare(str1, str2);
}
