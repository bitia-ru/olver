/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "math/complex/complex_model.seh"
#include "math/math/math_data.seh"

#pragma SEC subsystem complex "math.complex"



/* 
   The group of functions 'math.complex' consists of: 
       cabs [2]
       cabsf [2]
       cabsl [2]
       carg [2]
       cargf [2]
       cargl [2]
       cimag [2]
       cimagf [2]
       cimagl [2]
       conj [2]
       conjf [2]
       conjl [2]
       cproj [2]
       cprojf [2]
       cprojl [2]
       creal [2]
       crealf [2]
       creall [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

cabs, cabsf, cabsl - return a complex absolute value 

SYNOPSIS

#include <complex.h>

double cabs(double complex z);

float cabsf(float complex z);

long double cabsl(long double complex z);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO 
C standard. Any conflict between the requirements described here and the ISO C 
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
ISO C standard. These functions shall compute the complex absolute value (also 
called norm, modulus, or magnitude) of z.

RETURN VALUE

These functions shall return the complex absolute value.

ERRORS

No errors are defined.
*/

//This specification refers to: cabsf, cabs, cabsl
specification
Unifloat* cabs_spec( CallContext context, UnifloatComplex* x )
{
    char type[3][10] = {"cabsf", "cabs", "cabsl"};
    
    FILTER(type[(x->Re)->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
        /*[Implicit precondition]*/
        REQ("", "RE and IM part of x shall not be NULL", 
            (x->Re != NULL) && (x->Im != NULL));
        /*[Type coincidence]*/
        REQ("", "RE and IM part of x has equal type", 
            (x->Re)->type == (x->Im)->type);
    }

    coverage C
    {
        if(isNormal_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NORMAL_IM_NORMAL, "RE is normal and IM is normal" };

        if(isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NORMAL_IM_INF, "RE is normal and IM is infinity" };

        if(isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NORMAL_IM_NAN, "RE is normal and IM is nan" };

        if(isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_INF_IM_NORMAL, "RE is infinity and IM is normal" };

        if(isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_INF_IM_INF, "RE is infinity and IM is infinity" };

        if(isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_INF_IM_NAN, "RE is infinity and IM is nan" };

        if(isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NAN_IM_NORMAL, "RE is nan and IM is normal" };

        if(isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NAN_IM_INF, "RE is nan and IM is infinity" };

        if(isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NAN_IM_NAN, "RE is nan and IM is nan" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = cabs_model(x);

        round_Unifloat(model_res, mant[(x->Re)->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(cabs_spec, mant[(x->Re)->type]);

        /*
         * These functions shall compute the complex absolute value 
         * (also called norm, modulus, or magnitude) of z.
         */
        /*
         * These functions shall return the complex absolute value.
         */
        REQ("cabs.02;cabsf.02;cabsl.02;cabs.01;cabsf.01;cabsl.01", 
            "Functions shall return the complex absolute value", 
            !compare_Unifloat(model_res, cabs_spec));
        
        return true;
    }

    FILTER_CLEAN;
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

carg, cargf, cargl - complex argument functions 

SYNOPSIS

#include <complex.h>

double carg(double complex z);

float cargf(float complex z);

long double cargl(long double complex z);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO 
C standard. Any conflict between the requirements described here and the ISO C 
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
ISO C standard. These functions shall compute the argument (also called phase 
angle) of z, with a branch cut along the negative real axis.

RETURN VALUE

These functions shall return the value of the argument in the interval [-, +].

ERRORS

No errors are defined.
*/

//This specification refers to: cargf, carg, cargl
specification
Unifloat* carg_spec( CallContext context, UnifloatComplex* x )
{
    char type[3][10] = {"cargf", "carg", "cargl"};
    
    FILTER(type[(x->Re)->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
        /*[Implicit precondition]*/
        REQ("", "RE and IM part of x shall not be NULL", 
            (x->Re != NULL) && (x->Im != NULL));
        /*[Type coincidence]*/
        REQ("", "RE and IM part of x has equal type", 
            (x->Re)->type == (x->Im)->type);
    }

    coverage C
    {
        if(isNormal_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NORMAL_IM_NORMAL, "RE is normal and IM is normal" };

        if(isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NORMAL_IM_INF, "RE is normal and IM is infinity" };

        if(isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NORMAL_IM_NAN, "RE is normal and IM is nan" };

        if(isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_INF_IM_NORMAL, "RE is infinity and IM is normal" };

        if(isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_INF_IM_INF, "RE is infinity and IM is infinity" };

        if(isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_INF_IM_NAN, "RE is infinity and IM is nan" };

        if(isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NAN_IM_NORMAL, "RE is nan and IM is normal" };

        if(isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NAN_IM_INF, "RE is nan and IM is infinity" };

        if(isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NAN_IM_NAN, "RE is nan and IM is nan" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = carg_model(x);

        round_Unifloat(model_res, mant[(x->Re)->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(carg_spec, mant[(x->Re)->type]);
        
        /*
         * These functions shall compute the argument (also called phase angle) 
         * of z, with a branch cut along the negative real axis.
         */
        /*
         * These functions shall return the value of the argument in the 
         * interval [-pi, +pi].
         */
        REQ("carg.02;cargf.02;cargl.02;carg.01;cargf.01;cargl.01", 
            "functions shall return the value of the argument in the interval "
            "[-pi, +pi]", 
            !compare_Unifloat(model_res, carg_spec));
        
        return true;
    }

    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

cimag, cimagf, cimagl - complex imaginary functions 

SYNOPSIS

#include <complex.h>

double cimag(double complex z);

float cimagf(float complex z);

long double cimagl(long double complex z);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO 
C standard. Any conflict between the requirements described here and the ISO C 
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
ISO C standard. These functions shall compute the imaginary part of z.

RETURN VALUE

These functions shall return the imaginary part value (as a real).

ERRORS

No errors are defined.
*/

//This specification refers to: cimagf, cimag, cimagl
specification
Unifloat* cimag_spec( CallContext context, UnifloatComplex* x )
{
    char type[3][10] = {"cimagf", "cimag", "cimagl"};
    
    FILTER(type[(x->Re)->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
        /*[Implicit precondition]*/
        REQ("", "RE and IM part of x shall not be NULL", 
            (x->Re != NULL) && (x->Im != NULL));
        /*[Type coincidence]*/
        REQ("", "RE and IM part of x has equal type", 
            (x->Re)->type == (x->Im)->type);
    }

    coverage C
    {
        if(isNormal_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NORMAL_IM_NORMAL, "RE is normal and IM is normal" };

        if(isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NORMAL_IM_INF, "RE is normal and IM is infinity" };

        if(isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NORMAL_IM_NAN, "RE is normal and IM is nan" };

        if(isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_INF_IM_NORMAL, "RE is infinity and IM is normal" };

        if(isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_INF_IM_INF, "RE is infinity and IM is infinity" };

        if(isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_INF_IM_NAN, "RE is infinity and IM is nan" };

        if(isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NAN_IM_NORMAL, "RE is nan and IM is normal" };

        if(isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NAN_IM_INF, "RE is nan and IM is infinity" };

        if(isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NAN_IM_NAN, "RE is nan and IM is nan" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = cimag_model(x);
        
        round_Unifloat(model_res, mant[(x->Re)->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(cimag_spec, mant[(x->Re)->type]);

        /*
         * These functions shall compute the imaginary part of z.
         */
        /*
         * These functions shall return the imaginary part value (as a real).
         */
        REQ("cimag.02;cimagf.02;cimagl.02;cimag.01;cimagf.01;cimagl.01", 
            "functions shall return the imaginary part value (as a real)", 
            !compare_Unifloat(model_res, cimag_spec));
        
        return true;
    }

    FILTER_CLEAN;
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

conj, conjf, conjl - complex conjugate functions 

SYNOPSIS

#include <complex.h>

double complex conj(double complex z);

float complex conjf(float complex z);

long double complex conjl(long double complex z);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO 
C standard. Any conflict between the requirements described here and the ISO C 
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
ISO C standard. These functions shall compute the complex conjugate of z, by 
reversing the sign of its imaginary part.

RETURN VALUE

These functions return the complex conjugate value.

ERRORS

No errors are defined.
*/

//This specification refers to: cimagf, cimag, cimagl
specification
UnifloatComplex* conj_spec( CallContext context, UnifloatComplex* x )
{
    char type[3][10] = {"conjf", "conj", "conjl"};
    
    FILTER(type[(x->Re)->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
        /*[Implicit precondition]*/
        REQ("", "RE and IM part of x shall not be NULL", 
            (x->Re != NULL) && (x->Im != NULL));
        /*[Type coincidence]*/
        REQ("", "RE and IM part of x has equal type", 
            (x->Re)->type == (x->Im)->type);
    }

    coverage C
    {
        if(isNormal_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NORMAL_IM_NORMAL, "RE is normal and IM is normal" };

        if(isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NORMAL_IM_INF, "RE is normal and IM is infinity" };

        if(isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NORMAL_IM_NAN, "RE is normal and IM is nan" };

        if(isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_INF_IM_NORMAL, "RE is infinity and IM is normal" };

        if(isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_INF_IM_INF, "RE is infinity and IM is infinity" };

        if(isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_INF_IM_NAN, "RE is infinity and IM is nan" };

        if(isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NAN_IM_NORMAL, "RE is nan and IM is normal" };

        if(isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NAN_IM_INF, "RE is nan and IM is infinity" };

        if(isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NAN_IM_NAN, "RE is nan and IM is nan" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        UnifloatComplex* model_res = conj_model(x);
        
        round_Unifloat(model_res->Re, mant[(x->Re)->type]);
        round_Unifloat(model_res->Im, mant[(x->Re)->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(conj_spec->Re, mant[(x->Re)->type]);
        round_Unifloat(conj_spec->Im, mant[(x->Re)->type]);

        /*
         * These functions shall compute the complex conjugate of z, 
         * by reversing the sign of its imaginary part.
         */
        /*
         * These functions return the complex conjugate value.
         */
        REQ("conj.02;conjf.02;conjl.02;conj.01;conjf.01;conjl.01", 
            "functions return the complex conjugate value", 
            !compare_UnifloatComplex(model_res, conj_spec));
        
        return true;
    }

    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

cproj, cprojf, cprojl - complex projection functions 

SYNOPSIS

#include <complex.h>

double complex cproj(double complex z);

float complex cprojf(float complex z);

long double complex cprojl(long double complex z);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO 
C standard. Any conflict between the requirements described here and the ISO C 
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
ISO C standard. These functions shall compute a projection of z onto the 
Riemann sphere: z projects to z, except that all complex infinities (even those 
with one infinite part and one NaN part) project to positive infinity on the 
real axis. If z has an infinite part, then cproj( z) shall be equivalent to: 
INFINITY + I * copysign(0.0, cimag(z)) 

RETURN VALUE

These functions shall return the value of the projection onto the Riemann 
sphere.

ERRORS

No errors are defined.
*/

//This specification refers to: cprojf, cproj, cprojl
specification
UnifloatComplex* cproj_spec( CallContext context, UnifloatComplex* x )
{
    char type[3][10] = {"cprojf", "cproj", "cprojl"};
    
    FILTER(type[(x->Re)->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
        /*[Implicit precondition]*/
        REQ("", "RE and IM part of x shall not be NULL", 
            (x->Re != NULL) && (x->Im != NULL));
        /*[Type coincidence]*/
        REQ("", "RE and IM part of x has equal type", 
            (x->Re)->type == (x->Im)->type);
    }

    coverage C
    {
        if(isNormal_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NORMAL_IM_NORMAL, "RE is normal and IM is normal" };

        if(isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NORMAL_IM_INF, "RE is normal and IM is infinity" };

        if(isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NORMAL_IM_NAN, "RE is normal and IM is nan" };

        if(isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_INF_IM_NORMAL, "RE is infinity and IM is normal" };

        if(isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_INF_IM_INF, "RE is infinity and IM is infinity" };

        if(isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_INF_IM_NAN, "RE is infinity and IM is nan" };

        if(isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NAN_IM_NORMAL, "RE is nan and IM is normal" };

        if(isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NAN_IM_INF, "RE is nan and IM is infinity" };

        if(isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NAN_IM_NAN, "RE is nan and IM is nan" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        UnifloatComplex* model_res = cproj_model(x);
        
        round_Unifloat(model_res->Re, mant[(x->Re)->type]);
        round_Unifloat(model_res->Im, mant[(x->Re)->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(cproj_spec->Re, mant[(x->Re)->type]);
        round_Unifloat(cproj_spec->Im, mant[(x->Re)->type]);

        if(!isInfinity_Unifloat(x->Re) && !isInfinity_Unifloat(x->Im))
        /*
         * These functions shall compute a projection of z onto the Riemann 
         * sphere: z projects to z, except that all complex infinities 
         * (even those with one infinite part and one NaN part) project to 
         * positive infinity on the real axis.
         */
        REQ("cproj.01;cprojf.01;cprojl.01", 
            "z projects to z, except that all complex infinities "
            "(even those with one infinite part and one NaN part) project to "
            "positive infinity on the real axis.", 
            !compare_UnifloatComplex(cproj_spec, model_res));

        if(isInfinity_Unifloat(x->Re) || isInfinity_Unifloat(x->Im))
        /*
         * If z has an infinite part, then cproj( z) shall be equivalent to: 
         * INFINITY + I * copysign(0.0, cimag(z))
         */
        REQ("cproj.02;cprojf.02;cprojl.02", 
        "If z has an infinite part, then cproj( z) shall be equivalent to: "
        "INFINITY + I * copysign(0.0, cimag(z))", 
        isInfinity_Unifloat(cproj_spec->Re) && 
        ((cproj_spec->Re)->sign == 1) && 
        ((cproj_spec->Im)->sign == (x->Im)->sign) && 
        isZero_Unifloat(cproj_spec->Im));

  
        return true;
    }

    FILTER_CLEAN;
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

creal, crealf, creall - complex real functions 

SYNOPSIS

#include <complex.h>

double creal(double complex z);

float crealf(float complex z);

long double creall(long double complex z);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO 
C standard. Any conflict between the requirements described here and the ISO C 
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
ISO C standard. These functions shall compute the real part of z.

RETURN VALUE

These functions shall return the real part value.

ERRORS

No errors are defined.
*/

//This specification refers to: crealf, creal, creal
specification
Unifloat* creal_spec( CallContext context, UnifloatComplex* x )
{
    char type[3][10] = {"crealf", "creal", "creall"};
    
    FILTER(type[(x->Re)->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
        /*[Implicit precondition]*/
        REQ("", "RE and IM part of x shall not be NULL", 
            (x->Re != NULL) && (x->Im != NULL));
        /*[Type coincidence]*/
        REQ("", "RE and IM part of x has equal type", 
            (x->Re)->type == (x->Im)->type);
    }
    
    coverage C
    {
        if(isNormal_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NORMAL_IM_NORMAL, "RE is normal and IM is normal" };

        if(isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NORMAL_IM_INF, "RE is normal and IM is infinity" };

        if(isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NORMAL_IM_NAN, "RE is normal and IM is nan" };

        if(isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_INF_IM_NORMAL, "RE is infinity and IM is normal" };

        if(isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_INF_IM_INF, "RE is infinity and IM is infinity" };

        if(isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_INF_IM_NAN, "RE is infinity and IM is nan" };

        if(isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            return { RE_NAN_IM_NORMAL, "RE is nan and IM is normal" };

        if(isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            return { RE_NAN_IM_INF, "RE is nan and IM is infinity" };

        if(isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            return { RE_NAN_IM_NAN, "RE is nan and IM is nan" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = creal_model(x);
        
        round_Unifloat(model_res, mant[(x->Re)->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(creal_spec, mant[(x->Re)->type]);

        /*
         * These functions shall compute the real part of z.
         */
        /*
         * These functions shall return the real part value.
         */
        REQ("creal.02;crealf.02;creall.02;creal.01;crealf.01;creall.01", 
            "functions shall return the real part value", 
            !compare_Unifloat(model_res, creal_spec));
        
        return true;
    }

    FILTER_CLEAN;
}

/********************************************************************/
/**                      Unifloat Complex Functions                **/
/********************************************************************/
