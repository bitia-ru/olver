/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "math/bessel/bessel_model.seh"
#pragma SEC subsystem bessel "math.bessel"



/* 
   The group of functions 'math.bessel' consists of: 
       j0 [2]
       j0f [1]
       j0l [1]
       j1 [2]
       j1f [1]
       j1l [1]
       jn [2]
       jnf [1]
       jnl [1]
       y0 [2]
       y0f [1]
       y0l [1]
       y1 [2]
       y1f [1]
       y1l [1]
       yn [2]
       ynf [1]
       ynl [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    j0, j1, jn - Bessel functions of the first kind 

SYNOPSIS

    [XSI] #include <math.h>

    double j0(double x);

    double j1(double x);

    double jn(int n, double x); 

DESCRIPTION

    The j0(), j1(), and jn() functions shall compute Bessel functions of x of 
    the first kind of orders 0, 1, and n, respectively.

    An application wishing to check for error situations should set errno to 
    zero and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. 
    On return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO | 
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the relevant 
    Bessel value of x of the first kind.

    If the x argument is too large in magnitude, or the correct result would 
    cause underflow, 0 shall be returned and a range error may occur.

    If x is NaN, a NaN shall be returned.

ERRORS

    These functions may fail if:

    Range Error The value of x was too large in magnitude, or an underflow 
    occurred.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling 
    & amp; MATH_ERREXCEPT) is non-zero, then the underflow floating-point 
    exception shall be raised.

    No other errors shall occur.
*/

/** j0_spec **/
//This specification refers to: j0f, j0, j0l
specification
Unifloat* j0_spec( CallContext context, Unifloat* x, ErrorCode *errno)
{
    char type[3][10] = {"j0f", "j0", "j0l"};

    FILTER(type[x->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
    }
    coverage C
    {
        if(isNormal_Unifloat(x))return {NORMAL_ARGUMENT, "x is normal" };
        if(isNan_Unifloat(x))return {NAN_ARGUMENT, "x is nan" };
    }
    post
    {   
        IntT mant = digMant_Unifloat(x->type);

        Unifloat* model_res = j0_model(x);

        round_Unifloat(model_res, mant);
        round_Unifloat(j0_spec, mant);

        model_res = checkRange_Unifloat(model_res);

        if(isUnderflow_Unifloat(model_res))
        {
            /*
             * If the x argument is too large in magnitude, or the correct 
             * result would cause underflow, 0 shall be returned and a range 
             * error may occur.
             */
            REQ("j0.05;j0f.j0.05;j0l.j0.05", 
                "If the x argument is too large 0 shall be returned", 
                isZero_Unifloat(j0_spec));
        }

        /*
         * These functions may fail if:
         *
         * Range Error The value of x was too large in magnitude, or an 
         * underflow occurred.
         */
        ERROR_BEGIN(POSIX_J0, 
                    "j0.07.01.01;j0f.j0.07.01.01;j0l.j0.07.01.01", 
                    *errno, *errno)

            /*
             * These functions may fail if:
             *
             * Range Error The value of x was too large in magnitude, or an 
             * underflow occurred.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is 
             * non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_MAY(POSIX_J0, ERANGE, 
                      "j0.07.01.01;j0f.j0.07.01.01;j0l.j0.07.01.01", 
                      isUnderflow_Unifloat(model_res))

            /*
             * These functions may fail if:
             *
             * Range Error The value of x was too large in magnitude, or an 
             * underflow occurred.
             *
             * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
             * is non-zero, then the underflow floating-point exception shall 
             * be raised.
             */
        ERROR_END()

        if(isNormal_Unifloat(x) && !isUnderflow_Unifloat(model_res))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * relevant Bessel value of x of the first kind.
             */
            REQ("j0.04;j0f.j0.04;j0l.j0.04", 
                "Function shall return Bessel value of x of the first kind", 
                 compareWithPrecision_Unifloat(model_res, j0_spec, mant) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        {
            /*
             * If x is NaN, a NaN shall be returned.
             */
            REQ("j0.06;j0f.j0.06;j0l.j0.06", 
                "If x is NaN, a NaN shall be returned", 
                 isNan_Unifloat(j0_spec));
        }
#endif


        return true;
    }
    
    FILTER_CLEAN;
}

//////////////////////////////////////////////////////////////////////
//                          j0_model                                //
//////////////////////////////////////////////////////////////////////
Unifloat* j0_model(Unifloat* x)
{
    Unifloat* One, * BoundFirst, * BoundSecond;
    Unifloat* res = createZero_Unifloat(x->type);
    
    if(isNan_Unifloat(x))
    {
        res->kind = NaN;
        return res;
    }
    
    if(isInfinity_Unifloat(x))
    {
        return res;
    }

    if(isZero_Unifloat(x))
    {
        return createOne_Unifloat(x->type);
    }

    One = createOne_Unifloat(x->type);
    BoundFirst = clone(One);
    BoundFirst->exp += 3;
    BoundSecond = clone(One);
    BoundSecond->exp += 6;

    if(compare_Unifloat(abs_Unifloat(x), BoundFirst) != 1)
    {
        return jnPowerSeries_Unifloat(0, x);
    }
    else if(compare_Unifloat(abs_Unifloat(x), BoundSecond) != 1)
    {
        return jnSteed_Unifloat(0, x);
    }
    else
    {
        return jnHankel_Unifloat(0, x);
    }
}

/** j1_spec **/
//This specification refers to: j1f, j1, j1l
specification
Unifloat* j1_spec( CallContext context, Unifloat* x, ErrorCode *errno)
{
    char type[3][10] = {"j1f", "j1", "j1l"};
    FILTER(type[x->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
    }
    coverage C
    {
        if(isNormal_Unifloat(x))return {NORMAL_ARGUMENT, "x is normal" };
        if(isNan_Unifloat(x))return {NAN_ARGUMENT, "x is nan" };
    }
    post
    {
        IntT mant = digMant_Unifloat(x->type);

        Unifloat* model_res = j1_model(x);

        round_Unifloat(model_res, mant);
        round_Unifloat(j1_spec, mant);

        model_res = checkRange_Unifloat(model_res);

        if(isUnderflow_Unifloat(model_res))
        {
            /*
             * If the x argument is too large in magnitude, or the correct 
             * result would cause underflow, 0 shall be returned and a range 
             * error may occur.
             */
            REQ("j1.05;j1f.j1.05;j1l.j1.05", 
                "If the result would cause underflow, 0 shall be returned", 
                 isZero_Unifloat(j1_spec));
        }

        /*
         * These functions may fail if:
         *
         * Range Error The value of x was too large in magnitude, or an 
         * underflow occurred.
         */
        ERROR_BEGIN(POSIX_J1, 
            "j1.07.01.01;j1f.j1.07.01.01;j1l.j1.07.01.01", 
            *errno, *errno)

            /*
             * These functions may fail if:
             *
             * Range Error The value of x was too large in magnitude, or an 
             * underflow occurred.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is 
             * non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_MAY(POSIX_J1, ERANGE, 
                      "j1.07.01.01;j1f.j1.07.01.01;j1l.j1.07.01.01", 
                       isUnderflow_Unifloat(model_res))

            /*
             * These functions may fail if:
             *
             * Range Error The value of x was too large in magnitude, or an 
             * underflow occurred.
             *
             * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
             * is non-zero, then the underflow floating-point exception shall 
             * be raised.
             */
        ERROR_END()

        if(isNormal_Unifloat(x) && !isUnderflow_Unifloat(model_res))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * relevant Bessel value of x of the first kind.
             */
            REQ("j1.04;j1f.j1.04;j1l.j1.04", 
                "Function shall return the relevant Bessel value of x of the "
                "first kind", 
                 compareWithPrecision_Unifloat(model_res, j1_spec, mant) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        {
            /*
             * If x is NaN, a NaN shall be returned.
             */
            REQ("j1.06;j1f.j1.06;j1l.j1.06", 
                "If x is NaN, a NaN shall be returned", 
                 isNan_Unifloat(j1_spec));
        }
#endif


        return true;
    }
    
    FILTER_CLEAN;
}

//////////////////////////////////////////////////////////////////////
//                          j1_model                                //
//////////////////////////////////////////////////////////////////////
Unifloat* j1_model(Unifloat* x)
{
    Unifloat* One, * BoundFirst, * BoundSecond;
    Unifloat* res = createZero_Unifloat(x->type);

    if(isNan_Unifloat(x))
    {
        res->kind = NaN;
        return res;
    }
    
    if(isInfinity_Unifloat(x))
    {
        return res;
    }

    if(isZero_Unifloat(x))
    {
        res->sign = x->sign;
        return res;
    }
    
    One = createOne_Unifloat(x->type);
    BoundFirst = clone(One);
    BoundFirst->exp += 3;
    BoundSecond = clone(One);
    BoundSecond->exp += 6;

    if(compare_Unifloat(abs_Unifloat(x), BoundFirst) != 1)
    {
        return jnPowerSeries_Unifloat(1, x);
    }
    else if(compare_Unifloat(abs_Unifloat(x), BoundSecond) != 1)
    {
        return jnSteed_Unifloat(1, x);
    }
    else
    {
        return jnHankel_Unifloat(1, x);
    }
}

/** jn_spec **/
//This specification refers to: jnf, jn, jnl
specification
Unifloat* jn_spec( CallContext context, IntT n, Unifloat* x, 
                   IntT round, IntT* ulp, ErrorCode *errno)
{
    char type[3][10] = {"jnf", "jn", "jnl"};
    FILTER(type[x->type]);
    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
    }
    coverage C
    {
        if(isNormal_Unifloat(x))return {NORMAL_ARGUMENT, "x is normal" };
        if(isNan_Unifloat(x))return {NAN_ARGUMENT, "x is nan" };
    }
    post
    {
        FILE* file;
        IntT mant = digMant_Unifloat(x->type);
        Unifloat* model_res;
        Unifloat* error;
        model_res = jn_model(n, x);
        round_Unifloat(model_res, mant);
        round_Unifloat(jn_spec, mant);
        model_res = checkRange_Unifloat(model_res);
        
        if(RESEARCH == 1)
        {
            if(compare_Unifloat(model_res, jn_spec)!=0)
            {
                error = sub_Unifloat(model_res, jn_spec);
                error = abs_Unifloat(error);
                error->exp = error->exp + 52 - (model_res->exp - 1);
                *ulp = error->exp;
            }
            else
            {
                *ulp = 0;
            }
        }

        if(isUnderflow_Unifloat(model_res))
        {
            /*
             * If the x argument is too large in magnitude, or the correct 
             * result would cause underflow, 0 shall be returned and a range 
             * error may occur.
             */
            REQ("jn.05;jnf.jn.05;jnl.jn.05", 
                "If the result would cause underflow, 0 shall be returned", 
                 isZero_Unifloat(jn_spec));
        }

        if((CHECK_EXTENDED_REQ == 1) && (x->type == UniDoubleT))
        {
            if(isNormal_Unifloat(model_res))
            {
                REQ("j0.11;j1.11;jn.11;j0f.j0.11;j1f.j1.11;jnf.jn.11;j0l.j0.11;j1l.j1.11;jnl.jn.11", 
                    "Function shall return value with the correct sign", 
                     jn_spec->sign == model_res->sign);
            }
            if(isZero_Unifloat(x))
            {
                REQ("j0.09.01;j1.09.01;jn.09.01;j0f.j0.09.01;j1f.j1.09.01;jnf.jn.09.01;j0l.j0.09.01;j1l.j1.09.01;jnl.jn.09.01;"
                    "j0.09.02;j1.09.02;jn.09.02;j0f.j0.09.02;j1f.j1.09.02;jnf.jn.09.02;j0l.j0.09.02;j1l.j1.09.02;jnl.jn.09.02;"
                    "j0.09.03;j1.09.03;jn.09.03;j0f.j0.09.03;j1f.j1.09.03;jnf.jn.09.03;j0l.j0.09.03;j1l.j1.09.03;jnl.jn.09.03", 
                    "If x is zero functions shall return correct values", 
                     compare_Unifloat(jn_spec, model_res));
            }
            if(isInfinity_Unifloat(x))
            {
                REQ("j0.08;j1.08;jn.08;j0f.j0.08;j1f.j1.08;jnf.jn.08;j0l.j0.08;j1l.j1.08;jnl.jn.08", 
                    "If x is infinity functions shall return correct values", 
                     compare_Unifloat(jn_spec, model_res));
            }
        }
        
        ERROR_BEGIN(POSIX_JN, 
            "jn.07.01.01;jnf.jn.07.01.01;jnl.jn.07.01.01", 
            *errno, *errno)

            /*
             * These functions may fail if:
             *
             * Range Error The value of x was too large in magnitude, or an 
             * underflow occurred.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is 
             * non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_MAY(POSIX_JN, ERANGE, 
                      "jn.07.01.01;jnf.jn.07.01.01;jnl.jn.07.01.01", 
                      isUnderflow_Unifloat(model_res))

            /*
             * These functions may fail if:
             *
             * Range Error The value of x was too large in magnitude, or an 
             * underflow occurred.
             *
             * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
             * is non-zero, then the underflow floating-point exception shall 
             * be raised.
             */
        ERROR_END()

        if(isNormal_Unifloat(x) && !isUnderflow_Unifloat(model_res))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * relevant Bessel value of x of the first kind.
             */
            REQ("jn.04;jnf.jn.04;jnl.jn.04", 
                "Function shall return the relevant Bessel value of x of the "
                "first kind", 
                 compareWithPrecision_Unifloat(model_res, jn_spec, mant) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        {
            /*
             * If x is NaN, a NaN shall be returned.
             */
            REQ("jn.06;jnf.jn.06;jnl.jn.06", 
                "If x is NaN, a NaN shall be returned", 
                 isNan_Unifloat(jn_spec));
        }
#endif

        return true;
    }
    
    FILTER_CLEAN;
}

//////////////////////////////////////////////////////////////////////
//                          jn_model                                //
//////////////////////////////////////////////////////////////////////
Unifloat* jn_model(IntT n, Unifloat* x)
{
    IntT sign = 1, n_sign = 1;
    Unifloat* res = createZero_Unifloat(x->type);

    if(n == 0)
        return j0_model(x);
    if(n == 1)
    {
        return j1_model(x);
    }
    if(n == -1)
    {
        res = j1_model(x);
        res->sign = (-1)*(res->sign);
        return res;
    }

    if(isNan_Unifloat(x))
    {
        res->kind = NaN;
        return res;
    }
    
    if(isInfinity_Unifloat(x))
    {
        return res;
    }

    if(isZero_Unifloat(x))
    {
        if(((x->sign == 1) && (n > 0)) || ((x->sign == -1) && (n < 0)))
        {
            res->sign = 1;
            return res;
        }
        
        if(((x->sign == -1) && (n > 0)) || ((x->sign == 1) && (n < 0)))
        {
            if(n%2 == 0)
                res->sign = 1;
            else
                res->sign = -1;
            return res;
        }
    }
    //////J[-n]=(-1)^n*J[n]//////
    if(n < 0)
    {
        n_sign = -1;
        if(n % 2 != 0)
            sign = -1;
    }

    if(x->sign == -1)
    {
        if(n % 2 != 0)
            sign = (-1) * sign;
    }
    
    //////compute function//////
    switch(getMethod_Unifloat(n_sign * n, abs_Unifloat(x)))
    {
    case 1: res = jnPowerSeries_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    case 2: res = jnHankel_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    case 3: res = jnMeisselFirst_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    case 4: res = jnMeisselSecond_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    case 5: res = jnSteed_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    case 6: res = jnRecurrent_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    }
    
    res->sign = sign * res->sign;
    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    y0, y1, yn - Bessel functions of the second kind 

SYNOPSIS

    [XSI] #include <math.h>

    double y0(double x);

    double y1(double x);

    double yn(int n, double x); 

DESCRIPTION

    The y0(), y1(), and yn() functions shall compute Bessel functions of x of 
    the second kind of orders 0, 1, and n, respectively.

    An application wishing to check for error situations should set errno to 
    zero and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. 
    On return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO | 
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the relevant 
    Bessel value of x of the second kind.

    If x is NaN, NaN shall be returned.

    If the x argument to these functions is negative, -HUGE_VAL or NaN shall be 
    returned, and a domain error may occur.

    If x is 0.0, -HUGE_VAL shall be returned and a pole error may occur.

    If the correct result would cause underflow, 0.0 shall be returned and a 
    range error may occur.

    If the correct result would cause overflow, -HUGE_VAL or 0.0 shall be 
    returned and a range error may occur.

ERRORS

    These functions may fail if:

    Domain Error The value of x is negative. 

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [EDOM]. If the integer expression (math_errhandling & 
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception 
    shall be raised.

    Pole Error The value of x is zero. 

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling 
    & amp; MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point 
    exception shall be raised.

    Range Error The correct result would cause overflow. 

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling 
    & amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point 
    exception shall be raised.

    Range Error The value of x is too large in magnitude, or the correct result 
    would cause underflow. 

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling 
    & amp; MATH_ERREXCEPT) is non-zero, then the underflow floating-point 
    exception shall be raised.
*/

/** y0_spec **/
//This specification refers to: y0f, y0, y0l
specification
Unifloat* y0_spec( CallContext context, Unifloat* x, ErrorCode *errno )
{
    char type[3][10] = {"y0f", "y0", "y0l"};

    FILTER(type[x->type]);

    pre
    {
        /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
    }
    coverage C
    {
        if((x->sign == 1) && isNormal_Unifloat(x) && !isZero_Unifloat(x))
            return {POSITIVE_ARGUMENT, "x is positive" };

        if(isZero_Unifloat(x))
            return {ZERO_ARGUMENT, "x is zero" };

        if((x->sign == -1) && isNormal_Unifloat(x))
            return {NEGATIVE_ARGUMENT, "x is negative" };

        if(isNan_Unifloat(x))
            return {NAN_ARGUMENT, "x is nan" };
    }
    post
    {
        IntT mant = digMant_Unifloat(x->type);

        Unifloat* model_res = y0_model(x);

        round_Unifloat(model_res, mant);
        round_Unifloat(y0_spec, mant);

        model_res = checkRange_Unifloat(model_res);

        if((x->sign == -1) && isNormal_Unifloat(x))
        {
            /*
             * If the x argument to these functions is negative, -HUGE_VAL or 
             * NaN shall be returned, and a domain error may occur.
             */
            REQ("y0.06;y0f.y0.06;y0l.y0.06", 
                "If the x argument to these functions is negative, -HUGE_VAL "
                "or NaN shall be returned", 
                 isNan_Unifloat(y0_spec) || 
                 (isInfinity_Unifloat(y0_spec) && (y0_spec->sign == -1)));
        }

        if(isZero_Unifloat(x))
        {
            /*
             * If x is 0.0, -HUGE_VAL shall be returned and a pole error may 
             * occur.
             */
            REQ("y0.07;y0f.y0.07;y0l.y0.07", 
                "If x is 0.0, -HUGE_VAL shall be returned", 
                 isInfinity_Unifloat(y0_spec) && (y0_spec->sign == -1));
        }

        if(isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct result would cause underflow, 0.0 shall be 
             * returned and a range error may occur.
             */
            REQ("y0.08;y0f.y0.08;y0l.y0.08", 
                "If the correct result would cause underflow, 0.0 shall be "
                "returned", 
                 isZero_Unifloat(y0_spec));
        }

        if(isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct result would cause overflow, -HUGE_VAL or 0.0 
             * shall be returned and a range error may occur.
             */
            REQ("y0.09;y0f.y0.09;y0l.y0.09", 
                "If the correct result would cause overflow, -HUGE_VAL or 0.0 "
                "shall be returned", 
                 isZero_Unifloat(y0_spec) || 
                 (isInfinity_Unifloat(y0_spec) && (y0_spec->sign == -1)));
        }

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * Pole Error The value of x is zero.
         *
         * Range Error The correct result would cause overflow.
         *
         * Range Error The value of x is too large in magnitude, or the correct 
         * result would cause underflow.
         */
        ERROR_BEGIN(POSIX_Y0, 
                    "y0.10.01.01;y0f.y0.10.01.01;y0l.y0.10.01.01;"
                    "y0.10.02.01;y0f.y0.10.02.01;y0l.y0.10.02.01;"
                    "y0.10.03.01;y0f.y0.10.03.01;y0l.y0.10.03.01;"
                    "y0.10.04.01;y0f.y0.10.04.01;y0l.y0.10.04.01", 
                     *errno, *errno)

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) 
         * is non-zero, then errno shall be set to [EDOM].
         */
        ERROR_MAY(POSIX_Y0, EDOM, 
                  "y0.10.01.01;y0f.y0.10.01.01;y0l.y0.10.01.01;", 
                   (x->sign == -1) && isNormal_Unifloat(x))

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the invalid floating-point exception shall be 
         * raised.
         */
         
        /*
         * These functions may fail if:
         *
         * Pole Error The value of x is zero.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) 
         * is non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_Y0, ERANGE, 
                  "y0.10.02.01;y0f.y0.10.02.01;y0l.y0.10.02.01;", 
                   isZero_Unifloat(x))

        /*
         * These functions may fail if:
         *
         * Pole Error The value of x is zero.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the divide-by-zero floating-point exception 
         * shall be raised.
         */

        /*
         * These functions may fail if:
         *
         * Range Error The correct result would cause overflow.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) is 
         * non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_Y0, ERANGE, 
                  "y0.10.03.01;y0f.y0.10.03.01;y0l.y0.10.03.01;", 
                   isOverflow_Unifloat(model_res))

        /*
         * These functions may fail if:
         *
         * Range Error The correct result would cause overflow.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the overflow floating-point exception shall be 
         * raised.
         */

        /*
         * These functions may fail if:
         *
         * Range Error The value of x is too large in magnitude, or the correct 
         * result would cause underflow.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) is 
         * non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_Y0, ERANGE, 
                  "y0.10.04.01;y0f.y0.10.04.01;y0l.y0.10.04.01", 
                   isUnderflow_Unifloat(model_res))

        /*
         * These functions may fail if:
         *
         * Range Error The value of x is too large in magnitude, or the correct
         * result would cause underflow.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the underflow floating-point exception shall be 
         * raised.
         */
        ERROR_END()

        if((x->sign == 1) && isNormal_Unifloat(x) && !isZero_Unifloat(x) && 
           !isUnderflow_Unifloat(model_res) && !isOverflow_Unifloat(model_res))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * relevant Bessel value of x of the second kind.
             */
            REQ("y0.04;y0f.y0.04;y0l.y0.04", 
                "functions shall return the relevant Bessel value of x of the "
                "second kind", 
                 compareWithPrecision_Unifloat(y0_spec, model_res, mant) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        {
            /*
             * If x is NaN, NaN shall be returned.
             */
            REQ("y0.05;y0f.y0.05;y0l.y0.05", 
                "If x is NaN, NaN shall be returned", 
                 isNan_Unifloat(y0_spec));
        }
#endif


        return true;
    }

    FILTER_CLEAN;
}

//////////////////////////////////////////////////////////////////////
//                          y0_model                                //
//////////////////////////////////////////////////////////////////////
Unifloat* y0_model(Unifloat* x)
{
    Unifloat* One, * BoundFirst, * BoundSecond;
    Unifloat* res = createZero_Unifloat(x->type);

    if(isNan_Unifloat(x))
    {
        res->kind = NaN;
        return res;
    }
    
    if(isInfinity_Unifloat(x) && x->sign == 1)
    {
        return res;
    }

    if(isZero_Unifloat(x) || 
       ((isNormal_Unifloat(x) || isInfinity_Unifloat(x)) && x->sign == -1))
    {
       res->kind = Infinity;
       res->sign = -1;
       return res;
    }

    One = createOne_Unifloat(x->type);
    BoundFirst = clone(One);
    BoundFirst->exp += 3;
    BoundSecond = clone(One);
    BoundSecond->exp += 6;

    if(compare_Unifloat(abs_Unifloat(x), BoundFirst) != 1)
    {
        return ynPowerSeries_Unifloat(0, x);
    }
    else if(compare_Unifloat(abs_Unifloat(x), BoundSecond) != 1)
    {
        return ynSteed_Unifloat(0, x);
    }
    else
    {
        return ynHankel_Unifloat(0, x);
    }
}

/** y1_spec **/
//This specification refers to: y1f, y1, y1l
specification
Unifloat* y1_spec( CallContext context, Unifloat* x, ErrorCode *errno )
{
    char type[3][10] = {"y1f", "y1", "y1l"};

    FILTER(type[x->type]);

    pre
    {
         /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
    }
    coverage C
    {
        if((x->sign == 1) && isNormal_Unifloat(x) && !isZero_Unifloat(x))
            return {POSITIVE_ARGUMENT, "x is positive" };

        if(isZero_Unifloat(x))
            return {ZERO_ARGUMENT, "x is zero" };

        if((x->sign == -1) && isNormal_Unifloat(x))
            return {NEGATIVE_ARGUMENT, "x is negative" };

        if(isNan_Unifloat(x))
            return {NAN_ARGUMENT, "x is nan" };
    }
    post
    {
        IntT mant = digMant_Unifloat(x->type);

        Unifloat* model_res = y1_model(x);

        round_Unifloat(model_res, mant);
        round_Unifloat(y1_spec, mant);

        model_res = checkRange_Unifloat(model_res);

        if((x->sign == -1) && isNormal_Unifloat(x))
        {
            /*
             * If the x argument to these functions is negative, -HUGE_VAL or 
             * NaN shall be returned, and a domain error may occur.
             */
            REQ("y1.06;y1f.y1.06;y1l.y1.06", 
                "If the x argument to these functions is negative, -HUGE_VAL "
                "or NaN shall be returned", 
                 isNan_Unifloat(y1_spec) || 
                 (isInfinity_Unifloat(y1_spec) && (y1_spec->sign == -1)));
        }

        if(isZero_Unifloat(x))
        {
            /*
             * If x is 0.0, -HUGE_VAL shall be returned and a pole error may occur.
             */
            REQ("y1.07;y1f.y1.07;y1l.y1.07", 
                "If x is 0.0, -HUGE_VAL shall be returned", 
                 isInfinity_Unifloat(y1_spec) && (y1_spec->sign == -1));
        }

        if(isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct result would cause underflow, 0.0 shall be returned 
             * and a range error may occur.
             */
            REQ("y1.08;y1f.y1.08;y1l.y1.08", 
                "If the correct result would cause underflow, 0.0 shall be "
                "returned", 
                 isZero_Unifloat(y1_spec));
        }

        if(isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct result would cause overflow, -HUGE_VAL or 0.0 
             * shall be returned and a range error may occur.
             */
            REQ("y1.09;y1f.y1.09;y1l.y1.09", 
                "If the correct result would cause overflow, -HUGE_VAL or 0.0 "
                "shall be returned", 
                 isZero_Unifloat(y1_spec) || 
                 (isInfinity_Unifloat(y1_spec) && (y1_spec->sign == -1)));
        }

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * Pole Error The value of x is zero.
         *
         * Range Error The correct result would cause overflow.
         *
         * Range Error The value of x is too large in magnitude, or the correct 
         * result would cause underflow.
         */
        ERROR_BEGIN(POSIX_Y1, 
                    "y1.10.01.01;y1f.y1.10.01.01;y1l.y1.10.01.01;"
                    "y1.10.02.01;y1f.y1.10.02.01;y1l.y1.10.02.01;"
                    "y1.10.03.01;y1f.y1.10.03.01;y1l.y1.10.03.01;"
                    "y1.10.04.01;y1f.y1.10.04.01;y1l.y1.10.04.01", 
                     *errno, *errno)

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) 
         * is non-zero, then errno shall be set to [EDOM].
         */
        ERROR_MAY(POSIX_Y1, EDOM, 
                  "y1.10.01.01;y1f.y1.10.01.01;y1l.y1.10.01.01;", 
                   (x->sign == -1) && isNormal_Unifloat(x))

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the invalid floating-point exception shall be 
         * raised.
         */
         
        /*
         * These functions may fail if:
         *
         * Pole Error The value of x is zero.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) 
         * is non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_Y1, ERANGE, 
                  "y1.10.02.01;y1f.y1.10.02.01;y1l.y1.10.02.01;", 
                   isZero_Unifloat(x))

        /*
         * These functions may fail if:
         *
         * Pole Error The value of x is zero.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the divide-by-zero floating-point exception 
         * shall be raised.
         */

        /*
         * These functions may fail if:
         *
         * Range Error The correct result would cause overflow.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) is 
         * non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_Y1, ERANGE, 
                  "y1.10.03.01;y1f.y1.10.03.01;y1l.y1.10.03.01;", 
                   isOverflow_Unifloat(model_res))

        /*
         * These functions may fail if:
         *
         * Range Error The correct result would cause overflow.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the overflow floating-point exception shall be 
         * raised.
         */

        /*
         * These functions may fail if:
         *
         * Range Error The value of x is too large in magnitude, or the correct 
         * result would cause underflow.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) is 
         * non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_Y1, ERANGE, 
                  "y1.10.04.01;y1f.y1.10.04.01;y1l.y1.10.04.01", 
                   isUnderflow_Unifloat(model_res))

        /*
         * These functions may fail if:
         *
         * Range Error The value of x is too large in magnitude, or the correct
         * result would cause underflow.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the underflow floating-point exception shall be 
         * raised.
         */
        ERROR_END()

        if((x->sign == 1) && isNormal_Unifloat(x) && 
           !isUnderflow_Unifloat(model_res) && !isOverflow_Unifloat(model_res))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * relevant Bessel value of x of the second kind.
             */
            REQ("y1.04;y1f.y1.04;y1l.y1.04", 
                "functions shall return the relevant Bessel value of x of the "
                "second kind", 
                 compareWithPrecision_Unifloat(y1_spec, model_res, mant) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        {
            /*
             * If x is NaN, NaN shall be returned.
             */
            REQ("y1.05;y1f.y1.05;y1l.y1.05", 
                "If x is NaN, NaN shall be returned", 
                 isNan_Unifloat(y1_spec));
        }
#endif


        return true;
    }

    FILTER_CLEAN;
}

//////////////////////////////////////////////////////////////////////
//                          y1_model                                //
//////////////////////////////////////////////////////////////////////
Unifloat* y1_model(Unifloat* x)
{
    Unifloat* One, * BoundFirst, * BoundSecond;
    Unifloat* res = createZero_Unifloat(x->type);

    if(isNan_Unifloat(x))
    {
        res->kind = NaN;
        return res;
    }
    
    if(isInfinity_Unifloat(x) && x->sign == 1)
    {
        return res;
    }

    if(isZero_Unifloat(x) || 
       ((isNormal_Unifloat(x) || isInfinity_Unifloat(x)) && x->sign == -1))
    {
       res->kind = Infinity;
       res->sign = -1;
       return res;
    }
    
    One = createOne_Unifloat(x->type);
    BoundFirst = clone(One);
    BoundFirst->exp += 3;
    BoundSecond = clone(One);
    BoundSecond->exp += 6;

    if(compare_Unifloat(abs_Unifloat(x), BoundFirst) != 1)
    {
        return ynPowerSeries_Unifloat(1, x);
    }
    else if(compare_Unifloat(abs_Unifloat(x), BoundSecond) != 1)
    {
        return ynSteed_Unifloat(1, x);
    }
    else
    {
        return ynHankel_Unifloat(1, x);
    }
}

/** yn_spec **/
//This specification refers to: ynf, yn, ynl
specification
Unifloat* yn_spec( CallContext context, IntT n, Unifloat* x, 
                   IntT round, IntT* ulp, ErrorCode *errno)
{
    char type[3][10] = {"ynf", "yn", "ynl"};

    FILTER(type[x->type]);

    pre
    {
         /*[Implicit precondition]*/
        REQ("", "x shall not be NULL", x != NULL);
    }
    coverage C
    {
        if((x->sign == 1) && isNormal_Unifloat(x) && !isZero_Unifloat(x))
            return {POSITIVE_ARGUMENT, "x is positive" };

        if(isZero_Unifloat(x))
            return {ZERO_ARGUMENT, "x is zero" };

        if((x->sign == -1) && isNormal_Unifloat(x))
            return {NEGATIVE_ARGUMENT, "x is negative" };

        if(isNan_Unifloat(x))
            return {NAN_ARGUMENT, "x is nan" };
    }
    post
    {
        IntT mant = digMant_Unifloat(x->type);
        Unifloat* model_res;
        Unifloat* error;
        model_res = yn_model(n, x);
        round_Unifloat(model_res, mant);
        round_Unifloat(yn_spec, mant);
        model_res = checkRange_Unifloat(model_res);
        
        if(RESEARCH == 1)
        {
            if(compare_Unifloat(model_res, yn_spec)!=0)
            {
                error = sub_Unifloat(model_res, yn_spec);
                error = abs_Unifloat(error);
                error->exp = error->exp + 52 - (model_res->exp - 1);
                *ulp = error->exp;
            }
            else
            {
                *ulp = 0;
            }
        }
        
        if((x->sign == -1) && isNormal_Unifloat(x))
        {
            /*
             * If the x argument to these functions is negative, -HUGE_VAL or 
             * NaN shall be returned, and a domain error may occur.
             */
            REQ("yn.06;ynf.yn.06;ynl.yn.06", 
                "If the x argument to these functions is negative, -HUGE_VAL "
                "or NaN shall be returned", 
                 isNan_Unifloat(yn_spec) || 
                 (isInfinity_Unifloat(yn_spec) && (yn_spec->sign == -1)));
        }

        if(isZero_Unifloat(x))
        {
            /*
             * If x is 0.0, -HUGE_VAL shall be returned and a pole error may 
             * occur.
             */
            REQ("yn.07;ynf.yn.07;ynl.yn.07", 
                "If x is 0.0, -HUGE_VAL shall be returned", 
                 isInfinity_Unifloat(yn_spec) && (yn_spec->sign == -1));
        }

        if(isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct result would cause underflow, 0.0 shall be 
             * returned and a range error may occur.
             */
            REQ("yn.08;ynf.yn.08;ynl.yn.08", 
                "If the correct result would cause underflow, 0.0 shall be "
                "returned", 
                 isZero_Unifloat(yn_spec));
        }
        
        if(isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct result would cause overflow, -HUGE_VAL or 0.0 
             * shall be returned and a range error may occur.
             */
            REQ("yn.09;ynf.yn.09;ynl.yn.09", 
                "If the correct result would cause overflow, -HUGE_VAL or 0.0 "
                "shall be returned", 
                 isZero_Unifloat(yn_spec) || 
                 (isInfinity_Unifloat(yn_spec) && (yn_spec->sign == -1)));
        }

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * Pole Error The value of x is zero.
         *
         * Range Error The correct result would cause overflow.
         *
         * Range Error The value of x is too large in magnitude, or the correct 
         * result would cause underflow.
         */
        ERROR_BEGIN(POSIX_YN, 
                    "yn.10.01.01;ynf.yn.10.01.01;ynl.yn.10.01.01;"
                    "yn.10.02.01;ynf.yn.10.02.01;ynl.yn.10.02.01;"
                    "yn.10.03.01;ynf.yn.10.03.01;ynl.yn.10.03.01;"
                    "yn.10.04.01;ynf.yn.10.04.01;ynl.yn.10.04.01", 
                    *errno, *errno)

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) 
         * is non-zero, then errno shall be set to [EDOM].
         */
        ERROR_MAY(POSIX_YN, EDOM, 
                  "yn.10.01.01;ynf.yn.10.01.01;ynl.yn.10.01.01;", 
                   (x->sign == -1) && isNormal_Unifloat(x))

        /*
         * These functions may fail if:
         *
         * Domain Error The value of x is negative.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the invalid floating-point exception shall be 
         * raised.
         */
         
        /*
         * These functions may fail if:
         *
         * Pole Error The value of x is zero.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) 
         * is non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_YN, ERANGE, 
                  "yn.10.02.01;ynf.yn.10.02.01;ynl.yn.10.02.01;", 
                   isZero_Unifloat(x))

        /*
         * These functions may fail if:
         *
         * Pole Error The value of x is zero.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the divide-by-zero floating-point exception 
         * shall be raised.
         */

        /*
         * These functions may fail if:
         *
         * Range Error The correct result would cause overflow.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) is 
         * non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_YN, ERANGE, 
                  "yn.10.03.01;ynf.yn.10.03.01;ynl.yn.10.03.01;", 
                   isOverflow_Unifloat(model_res))

        /*
         * These functions may fail if:
         *
         * Range Error The correct result would cause overflow.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the overflow floating-point exception shall be 
         * raised.
         */

        /*
         * These functions may fail if:
         *
         * Range Error The value of x is too large in magnitude, or the correct 
         * result would cause underflow.
         *
         * If the integer expression (math_errhandling & MATH_ERRNO) is 
         * non-zero, then errno shall be set to [ERANGE].
         */
        ERROR_MAY(POSIX_YN, ERANGE, 
                  "yn.10.04.01;ynf.yn.10.04.01;ynl.yn.10.04.01", 
                   isUnderflow_Unifloat(model_res))

        /*
         * These functions may fail if:
         *
         * Range Error The value of x is too large in magnitude, or the correct
         * result would cause underflow.
         *
         * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
         * is non-zero, then the underflow floating-point exception shall be 
         * raised.
         */
        ERROR_END()

        if((x->sign == 1) && isNormal_Unifloat(x) && 
           !isUnderflow_Unifloat(model_res) && !isOverflow_Unifloat(model_res))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * relevant Bessel value of x of the second kind.
             */
            REQ("yn.04;ynf.yn.04;ynl.yn.04", 
                "functions shall return the relevant Bessel value of x of the "
                "second kind", 
                 compareWithPrecision_Unifloat(yn_spec, model_res, mant) == 0);
            }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        { 
            /*
             * If x is NaN, NaN shall be returned.
             */
            REQ("yn.05;ynf.yn.05;ynl.yn.05", 
                "If x is NaN, NaN shall be returned", 
                 isNan_Unifloat(yn_spec));
        }
#endif


        return true;
    }

    FILTER_CLEAN;
}

//////////////////////////////////////////////////////////////////////
//                          yn_model                                //
//////////////////////////////////////////////////////////////////////
Unifloat* yn_model(IntT n, Unifloat* x)
{
    IntT sign = 1, n_sign = 1;
    Unifloat* res = createZero_Unifloat(x->type);

    if(n == 0)
        return y0_model(x);
    if((n == 1) || (n == -1))
        return y1_model(x);

    if(isNan_Unifloat(x))
    {
        res->kind = NaN;
        return res;
    }
    
    if(isInfinity_Unifloat(x) && x->sign == 1)
    {
        return res;
    }

    if(isZero_Unifloat(x) || 
       ((isNormal_Unifloat(x) || isInfinity_Unifloat(x)) && x->sign == -1))
    {
       res->kind = Infinity;
       res->sign = -1;
       return res;
    }
    
    //////Y[-n]=(-1)^n*Y[n]//////
    if(n < 0)
    {
        n_sign = -1;
        if(n % 2 != 0)
            sign = -1;
    }

    //////compute function//////
    switch(getMethod_Unifloat(n_sign * n, abs_Unifloat(x)))
    {
    case 1: res = ynPowerSeries_Unifloat(n_sign * n, x);
            break;
    case 2: res = ynHankel_Unifloat(n_sign * n, x);
            break;
    case 3: res = ynMeisselFirst_Unifloat(n_sign * n, x);
            break;
    case 4: res = ynMeisselSecond_Unifloat(n_sign * n, x);
            break;
    case 5: res = ynSteed_Unifloat(n_sign * n, x);
            break;
    case 6: res = ynRecurrent_Unifloat(n_sign * n, abs_Unifloat(x));
            break;
    }

    res->sign = sign * res->sign;
    return res;
}

/********************************************************************/
/**                      Reference Functions                       **/
/********************************************************************/

//////////////////////////////////////////////////////////////////////
//                    jnPowerSeries_Unifloat                        //
//////////////////////////////////////////////////////////////////////
Unifloat* jnPowerSeries_Unifloat(IntT n, Unifloat* x)
{

    ////// calculate through representation function in power sum //////
    IntT num, type = x->type;
    Unifloat* current, * z, * One;
    //Unifloat* * aux, * pi, * e, * Two, * INDEX;
    Unifloat* x_pow_n = createOne_Unifloat(x->type);
    Unifloat* n_fact = createOne_Unifloat(x->type);
    Unifloat* tmp;

    One = createOne_Unifloat(x->type);
    //Two = createOne_Unifloat(x->type);
    //Two->exp++;
    //INDEX = convertInteger_Unifloat(n, type);
    //pi = convertBinaryString_Unifloat(create_CString(PI), type);
    //e = convertString_Unifloat(create_CString(E), type);
    z = mul_Unifloat(x, x);
    current = createOne_Unifloat(x->type);

//    if(compare_Unifloat(x,sqrt_Unifloat(convertInteger_Unifloat(n, type))) != 1)
//        for(num = 20; num > 0; num--)
//        {
//            //current=sub_Unifloat(One, div_Unifloat(mul_Unifloat(current, z), mul_Unifloat(convertInteger_Unifloat(4*num, type), add_Unifloat(convertInteger_Unifloat(num, type), INDEX))));
//            tmp = mul_Unifloat(current, z);
//            tmp = div_Unifloat(tmp, convertInteger_Unifloat(num * (n + num), type));
//            tmp->exp -= 2;
//            current=sub_Unifloat(One, tmp);
//        }
//    else
        for(num = 45; num > 0; num--)
        {
            tmp = mul_Unifloat(current, z);
            tmp = div_Unifloat(tmp, convertInteger_Unifloat(num * (n + num), type));
            tmp->exp -= 2;
            current=sub_Unifloat(One, tmp);
        }

    /*/
    if(n > 100)
    {
        aux = mul_Unifloat(INDEX, log_Unifloat(div_Unifloat(mul_Unifloat(x, e), mul_Unifloat(Two, INDEX))));
        aux = sub_Unifloat(aux, div_Unifloat(log_Unifloat(mul_Unifloat(mul_Unifloat(Two, pi), INDEX)), Two));
        aux = exp_Unifloat(sub_Unifloat(aux, factorialSeries_Unifloat(n, type)));
        current = mul_Unifloat(current, aux);
    }
    /**/

    /**/
    if((n != 0) && (n <= 100))
    {
        for(num = 1; num < n + 1; num++)
        {
            x_pow_n = mul_Unifloat(x_pow_n, x);
            n_fact = mul_Unifloat(n_fact, convertInteger_Unifloat(num, type));
        }
        current = mul_Unifloat(current, x_pow_n);
        current = div_Unifloat(current, n_fact);
        current->exp -= n;
    }
    /**/

    return current;
}

//////////////////////////////////////////////////////////////////////
//                    ynPowerSeries_Unifloat                        //
//////////////////////////////////////////////////////////////////////
Unifloat* ynPowerSeries_Unifloat(IntT n, Unifloat* x)
{
    IntT num, type = x->type;
     Unifloat* currentsumA, * aux, * z;
    Unifloat* currentsumB = createZero_Unifloat(type);
    Unifloat* work = createZero_Unifloat(type);
    Unifloat* currentA, * currentB;
    Unifloat* pi, * gamma;
    Unifloat* M = createOne_Unifloat(type);
    //Unifloat* e;


    //e = convertString_Unifloat(create_CString(E), type);
    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    gamma = convertString_Unifloat(create_CString(GAMMA), type);
    z = mul_Unifloat(x, x);
    
    ///////////////////////////////////////////////////////////////////////////
    //first part of representation
    ///////////////////////////////////////////////////////////////////////////
    aux = clone(x);
    aux->exp--;
    currentsumA = add_Unifloat(log_Unifloat(aux), gamma);
    currentsumA = mul_Unifloat(jnPowerSeries_Unifloat(n, x), currentsumA);
    currentsumA->exp++;
        
    ///////////////////////////////////////////////////////////////////////////
    //second part of representation
    ///////////////////////////////////////////////////////////////////////////
    if(n != 0)
    {
        currentB = createOne_Unifloat(type);
        currentsumB = createOne_Unifloat(type);
        for(num = 1; num < n; num++)
        {
            currentB = mul_Unifloat(currentB, z);
            currentB = div_Unifloat(currentB, convertInteger_Unifloat(num*(n - num), type));
            currentB->exp -= 2;
            currentsumB = add_Unifloat(currentsumB, currentB);
        }
        
        aux = createOne_Unifloat(type);
        for(num = 1; num < n; num++)
        {
            M = mul_Unifloat(M, convertInteger_Unifloat(num, type));
            aux = mul_Unifloat(aux, x);
        }
        aux = mul_Unifloat(aux, x);
        M = div_Unifloat(M, aux);
        currentsumB = mul_Unifloat(currentsumB, M);
        currentsumB->exp += n;

        currentsumA = sub_Unifloat(currentsumA, currentsumB);
    }

    ///////////////////////////////////////////////////////////////////////////
    //third part of representation
    ///////////////////////////////////////////////////////////////////////////
    currentsumB = createZero_Unifloat(type);
    currentB = createOne_Unifloat(type);
    currentA = createOne_Unifloat(type);
    for(num = 1; num < n + 1; num++)
    {
        work = add_Unifloat(work, div_Unifloat(createOne_Unifloat(type), convertInteger_Unifloat(num, type)));
    }
    currentsumB = add_Unifloat(currentsumB, work);
    num = 1;
    while(currentB->exp > -PRECISION - 1)
    {
        work = add_Unifloat(work, div_Unifloat(createOne_Unifloat(type), convertInteger_Unifloat(num, type)));
        work = add_Unifloat(work, div_Unifloat(createOne_Unifloat(type), convertInteger_Unifloat(n + num, type)));
        currentA = mul_Unifloat(currentA, z);
        currentA = div_Unifloat(currentA, convertInteger_Unifloat(num * (n + num), type));
        currentA->exp -= 2;
            
        currentA->sign = (-1)*currentA->sign;
        currentB = mul_Unifloat(currentA, work);
        currentsumB = add_Unifloat(currentsumB, currentB);
        num++;
    }

    if(n != 0)
    {
        M = mul_Unifloat(M, convertInteger_Unifloat(n, type));
        currentsumB->exp -= n;
        currentsumB = div_Unifloat(currentsumB, M);
    }

    currentsumA = sub_Unifloat(currentsumA, currentsumB);
    currentsumA = div_Unifloat(currentsumA, pi);
    //////
    return currentsumA;
}

//////////////////////////////////////////////////////////////////////
//                        jnHankel_Unifloat                         //
//////////////////////////////////////////////////////////////////////
Unifloat* jnHankel_Unifloat(IntT n, Unifloat* x)
{
    ////// asimptotic representation //////
    IntT num = 1, exp1 = 1, exp2 = 0;
    IntT type = x->type;    

    Unifloat* Four, * INDEX, * z, * aux2;
    Unifloat* aux1 = createZero_Unifloat(type);
    Unifloat* currentsumA = createZero_Unifloat(type);
    Unifloat* currentsumB = createZero_Unifloat(type);
    Unifloat* currentA, * currentB, * pi, * arg, * pi_4;
    Unifloat* One, * Two;

    One = createOne_Unifloat(type);
    Two = createOne_Unifloat(type);
    Two->exp++;
    Four = createOne_Unifloat(type);
    Four->exp += 2;
    INDEX = convertInteger_Unifloat(n, type);
    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    pi_4 = clone(pi);
    pi_4->exp -= 2;
    z = mul_Unifloat(x, x);
    z->exp += 6;
    //////calculating argument of sin() and cos()//////
    arg = mul_Unifloat(pi, INDEX);
    arg->exp--;
    arg = sub_Unifloat(x, arg);
    arg = sub_Unifloat(arg, pi_4);

    //////calculating all//////
    
    currentA = createOne_Unifloat(type);
    aux2 = mul_Unifloat(INDEX,INDEX);
    currentB = clone(aux2);
    aux2->exp += 2;
    currentB->exp += 2;
    currentB = sub_Unifloat(currentB, One);
    currentB = div_Unifloat(currentB, x);
    currentB->exp -= 3;
    
    while((exp2 <= exp1) && (exp2 > -PRECISION - 1))
    {
        if(currentB->exp < 0)
        {
            exp1 = currentB->exp;
        }
        
        currentsumA = add_Unifloat(currentsumA, currentA);
        currentsumB = add_Unifloat(currentsumB, currentB);

        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, convertInteger_Unifloat((4*num-3)*(4*num-3), type));
        currentA = mul_Unifloat(currentA, aux1);
        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, convertInteger_Unifloat((4*num-1)*(4*num-1), type));
        currentA = mul_Unifloat(currentA, aux1);
        aux1 = convertInteger_Unifloat(2*num*(2*num-1), type);
        aux1 = mul_Unifloat(aux1, z);
        currentA = div_Unifloat(currentA, aux1);

        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, convertInteger_Unifloat((4*num-1)*(4*num-1), type));
        currentB = mul_Unifloat(currentB, aux1);
        
        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, convertInteger_Unifloat((4*num+1)*(4*num+1), type));
        currentB = mul_Unifloat(currentB, aux1);
        
        aux1 = convertInteger_Unifloat(2*num*(2*num+1), type);
        aux1 = mul_Unifloat(aux1, z);
        currentB = div_Unifloat(currentB, aux1);

        currentA->sign=(-1)*currentA->sign;
        currentB->sign=(-1)*currentB->sign;
        
        if(currentB->exp < 0)
        {
            exp2 = currentB->exp;
        }
        num++;
    }
    ////////////
    currentsumA = mul_Unifloat(currentsumA, cos_Unifloat(arg));
    currentsumB = mul_Unifloat(currentsumB, sin_Unifloat(arg));
    currentsumA = sub_Unifloat(currentsumA, currentsumB);
    currentsumA = mul_Unifloat(currentsumA, sqrt_Unifloat(div_Unifloat(Two, mul_Unifloat(pi, x))));
    ////////////
    return currentsumA;
}

//////////////////////////////////////////////////////////////////////
//                        ynHankel_Unifloat                         //
//////////////////////////////////////////////////////////////////////
Unifloat* ynHankel_Unifloat(IntT n, Unifloat* x)
{
    ////// asimptotic representation //////
    IntT num = 1, exp1 = 1, exp2 = 0;
    UnifloatType type = x->type;    

    Unifloat* Four, * INDEX, * z, * aux2;
    Unifloat* aux1 = createZero_Unifloat(type);
    Unifloat* currentsumA = createZero_Unifloat(type);
    Unifloat* currentsumB = createZero_Unifloat(type);
    Unifloat* currentA, * currentB, * pi, * arg;

    Four = convertInteger_Unifloat(4, type);
    INDEX = convertInteger_Unifloat(n, type);
    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    z = mul_Unifloat(x, mul_Unifloat(x, convertInteger_Unifloat(64, type)));
    //////calculating argument of sin() and cos()//////
    arg = sub_Unifloat(x, mul_Unifloat(div_Unifloat(pi, convertInteger_Unifloat(2, type)), INDEX));
    arg = sub_Unifloat(arg, div_Unifloat(pi, Four));
    aux2 = mul_Unifloat(INDEX,INDEX);
    aux2 = mul_Unifloat(aux2,Four);

    //////calculating all//////
    currentA = convertInteger_Unifloat(1, type);
    currentB = mul_Unifloat(INDEX, INDEX);
    currentB = mul_Unifloat(currentB, Four);
    currentB = sub_Unifloat(currentB, convertInteger_Unifloat(1, type));
    currentB = div_Unifloat(currentB, x);
    currentB = div_Unifloat(currentB, convertInteger_Unifloat(8, type));
    while((exp2 <= exp1)&&(exp2>-PRECISION-1))
    {
        if(currentB->exp<0)
            exp1 = currentB->exp;
        currentsumA = add_Unifloat(currentsumA, currentA);
        currentsumB = add_Unifloat(currentsumB, currentB);

        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, mul_Unifloat(convertInteger_Unifloat(4*num-3, type),convertInteger_Unifloat(4*num-3, type)));
        currentA = mul_Unifloat(currentA, aux1);
        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, mul_Unifloat(convertInteger_Unifloat(4*num-1, type),convertInteger_Unifloat(4*num-1, type)));
        currentA = mul_Unifloat(currentA, aux1);
        aux1 = mul_Unifloat(convertInteger_Unifloat(2*num, type), convertInteger_Unifloat(2*num-1, type));
        aux1 = mul_Unifloat(aux1, z);
        currentA = div_Unifloat(currentA, aux1);

        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, mul_Unifloat(convertInteger_Unifloat(4*num-1, type),convertInteger_Unifloat(4*num-1, type)));
        currentB = mul_Unifloat(currentB, aux1);
        aux1 = clone(aux2);
        aux1 = sub_Unifloat(aux1, mul_Unifloat(convertInteger_Unifloat(4*num+1, type),convertInteger_Unifloat(4*num+1, type)));
        currentB = mul_Unifloat(currentB, aux1);
        aux1 = mul_Unifloat(convertInteger_Unifloat(2*num, type), convertInteger_Unifloat(2*num+1, type));
        aux1 = mul_Unifloat(aux1, z);
        currentB = div_Unifloat(currentB, aux1);

        currentA->sign=(-1)*currentA->sign;
        currentB->sign=(-1)*currentB->sign;
        if(currentB->exp<0)
            exp2 = currentB->exp;
        num++;
    }
    ////////////
    currentsumA = mul_Unifloat(currentsumA, sin_Unifloat(arg));
    currentsumB = mul_Unifloat(currentsumB, cos_Unifloat(arg));
    currentsumA = add_Unifloat(currentsumA, currentsumB);
    currentsumA = mul_Unifloat(currentsumA, sqrt_Unifloat(div_Unifloat(convertInteger_Unifloat(2, type), mul_Unifloat(pi, x))));
    ////////////
    return currentsumA;
}

//////////////////////////////////////////////////////////////////////
//                        jnMeisselFirst_Unifloat                   //
//////////////////////////////////////////////////////////////////////
Unifloat* jnMeisselFirst_Unifloat(IntT n, Unifloat* x)
{
    //int num;
    IntT type = x->type;
    Unifloat* result, * currentV, * current1;
    Unifloat* current2 = createZero_Unifloat(type);
    Unifloat* sumV = createZero_Unifloat(type);
    Unifloat* arg, * aux1, * aux2, * pi, * e;

    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    e = convertString_Unifloat(create_CString(E), type);

    arg = div_Unifloat(x, convertInteger_Unifloat(n, type));
    aux1 = sqrt_Unifloat(sub_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(arg, arg)));
    aux2 = sub_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(arg, arg));
    //////computation Vsum
    /**/    //////V1
    currentV = convertInteger_Unifloat(2, type);
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(3, type), power_Unifloat(2, arg)));
    currentV = div_Unifloat(currentV, aux1);
    currentV = div_Unifloat(currentV, aux2);
    currentV = sub_Unifloat(currentV, convertInteger_Unifloat(2, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(24, type), convertInteger_Unifloat(n, type)));
    sumV = add_Unifloat(sumV, currentV);
    /**/    
    /**/    //////V2
    currentV = mul_Unifloat(convertInteger_Unifloat(4, type), power_Unifloat(2, arg));
    currentV = add_Unifloat(currentV, power_Unifloat(4, arg));
    currentV = div_Unifloat(currentV, power_Unifloat(2, convertInteger_Unifloat(n, type)));
    currentV = div_Unifloat(currentV, convertInteger_Unifloat(16, type));
    currentV = div_Unifloat(currentV, power_Unifloat(3, aux2));
    sumV = sub_Unifloat(sumV, currentV);
    /**/    
    /**/    //////V3
    currentV = convertInteger_Unifloat(16, type);
    currentV = sub_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1512, type), power_Unifloat(2, arg)));
    currentV = sub_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(3654, type), power_Unifloat(4, arg)));
    currentV = sub_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(375, type), power_Unifloat(6, arg)));
    currentV = div_Unifloat(currentV, power_Unifloat(4, aux2));
    currentV = div_Unifloat(currentV, aux1);
    currentV = sub_Unifloat(currentV, convertInteger_Unifloat(16, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(5760, type), power_Unifloat(3, convertInteger_Unifloat(n, type))));
    sumV = sub_Unifloat(sumV, currentV);

    /**/
    /**/
    //////V4
    currentV = mul_Unifloat(convertInteger_Unifloat(32, type), power_Unifloat(2, arg));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(288, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(232, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(13, type), power_Unifloat(8, arg)));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(128, type), power_Unifloat(4, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(6, aux2));
    sumV = sub_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V5
    currentV = mul_Unifloat(convertInteger_Unifloat(67599, type), power_Unifloat(10, arg));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1914210, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(4744640, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1891200, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(78720, type), power_Unifloat(2, arg)));
    currentV = add_Unifloat(currentV, convertInteger_Unifloat(256, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(322560, type), power_Unifloat(5, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(7, aux2));
    currentV = div_Unifloat(currentV, aux1);
    currentV = sub_Unifloat(currentV, div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(1260, type), power_Unifloat(5, convertInteger_Unifloat(n, type)))));
    sumV = add_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V6
    currentV = convertInteger_Unifloat(48, type);
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(2580, type), power_Unifloat(2, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(14884, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(17493, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(4242, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(103, type), power_Unifloat(10, arg)));
    currentV = mul_Unifloat(currentV, power_Unifloat(2, arg));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(192, type), power_Unifloat(6, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(9, aux2));
    sumV = sub_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V7
    currentV = mul_Unifloat(convertInteger_Unifloat(881664, type), power_Unifloat(2, arg));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(99783936, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1135145088, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(2000000000, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(884531440, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1965889800, type), power_Unifloat(10, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(318291750, type), power_Unifloat(12, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(5635995, type), power_Unifloat(14, arg)));
    currentV = sub_Unifloat(currentV, convertInteger_Unifloat(2048, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(3440640, type), power_Unifloat(7, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(10, aux2));
    currentV = div_Unifloat(currentV, aux1);
    currentV = add_Unifloat(currentV, div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(1680, type), power_Unifloat(7, convertInteger_Unifloat(n, type)))));
    sumV = add_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V8
    currentV = convertInteger_Unifloat(1024, type);
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(248320, type), power_Unifloat(2, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(5095936, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(24059968, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(34280896, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(15252048, type), power_Unifloat(10, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1765936, type), power_Unifloat(12, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(23797, type), power_Unifloat(14, arg)));
    currentV = mul_Unifloat(currentV, power_Unifloat(2, arg));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(4096, type), power_Unifloat(8, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(12, aux2));
    sumV = sub_Unifloat(sumV, currentV);

    /**/
    //////computation result
    
    result = div_Unifloat(convertInteger_Unifloat(1, type), sqrt_Unifloat(aux1));

    current1 = log_Unifloat(div_Unifloat(arg, add_Unifloat(convertInteger_Unifloat(1, type), aux1)));
    current1 = add_Unifloat(current1, aux1);
    current1 = mul_Unifloat(current1, convertInteger_Unifloat(n, type));

     current2 = add_Unifloat(current2, sumV);
    current2 = add_Unifloat(current2, factorialSeries_Unifloat(n, type));

    result = mul_Unifloat(result, exp_Unifloat(sub_Unifloat(current1, current2)));
    result = div_Unifloat(result, sqrt_Unifloat(mul_Unifloat(mul_Unifloat(convertInteger_Unifloat(2, type), convertInteger_Unifloat(n, type)), pi)));
    return result;
}

//////////////////////////////////////////////////////////////////////
//                        ynMeisselFirst_Unifloat                   //
//////////////////////////////////////////////////////////////////////
Unifloat* ynMeisselFirst_Unifloat(IntT n, Unifloat* x)
{
    //int num;
    IntT type = x->type;
    Unifloat* result, * currentV, * current1;
    Unifloat* current2 = createZero_Unifloat(type);
    Unifloat* sumV = createZero_Unifloat(type);
    Unifloat* arg, * aux1, * aux2, * pi, * e;

    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    e = convertString_Unifloat(create_CString(E), type);

    arg = div_Unifloat(x, convertInteger_Unifloat(n, type));
    aux1 = sqrt_Unifloat(sub_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(arg, arg)));
    aux2 = sub_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(arg, arg));
    //////computation Vsum
    /**/    //////V1
    currentV = convertInteger_Unifloat(2, type);
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(3, type), power_Unifloat(2, arg)));
    currentV = div_Unifloat(currentV, aux1);
    currentV = div_Unifloat(currentV, aux2);
    currentV = sub_Unifloat(currentV, convertInteger_Unifloat(2, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(24, type), convertInteger_Unifloat(n, type)));
    sumV = add_Unifloat(sumV, currentV);
    /**/    
    /**/    //////V2
    currentV = mul_Unifloat(convertInteger_Unifloat(4, type), power_Unifloat(2, arg));
    currentV = add_Unifloat(currentV, power_Unifloat(4, arg));
    currentV = div_Unifloat(currentV, power_Unifloat(2, convertInteger_Unifloat(n, type)));
    currentV = div_Unifloat(currentV, convertInteger_Unifloat(16, type));
    currentV = div_Unifloat(currentV, power_Unifloat(3, aux2));
    sumV = add_Unifloat(sumV, currentV);
    /**/    
    /**/    //////V3
    currentV = convertInteger_Unifloat(16, type);
    currentV = sub_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1512, type), power_Unifloat(2, arg)));
    currentV = sub_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(3654, type), power_Unifloat(4, arg)));
    currentV = sub_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(375, type), power_Unifloat(6, arg)));
    currentV = div_Unifloat(currentV, power_Unifloat(4, aux2));
    currentV = div_Unifloat(currentV, aux1);
    currentV = sub_Unifloat(currentV, convertInteger_Unifloat(16, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(5760, type), power_Unifloat(3, convertInteger_Unifloat(n, type))));
    sumV = sub_Unifloat(sumV, currentV);

    /**/
    /**/
    //////V4
    currentV = mul_Unifloat(convertInteger_Unifloat(32, type), power_Unifloat(2, arg));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(288, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(232, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(13, type), power_Unifloat(8, arg)));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(128, type), power_Unifloat(4, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(6, aux2));
    sumV = add_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V5
    currentV = mul_Unifloat(convertInteger_Unifloat(67599, type), power_Unifloat(10, arg));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1914210, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(4744640, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1891200, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(78720, type), power_Unifloat(2, arg)));
    currentV = add_Unifloat(currentV, convertInteger_Unifloat(256, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(322560, type), power_Unifloat(5, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(7, aux2));
    currentV = div_Unifloat(currentV, aux1);
    currentV = sub_Unifloat(currentV, div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(1260, type), power_Unifloat(5, convertInteger_Unifloat(n, type)))));
    sumV = add_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V6
    currentV = convertInteger_Unifloat(48, type);
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(2580, type), power_Unifloat(2, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(14884, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(17493, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(4242, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(103, type), power_Unifloat(10, arg)));
    currentV = mul_Unifloat(currentV, power_Unifloat(2, arg));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(192, type), power_Unifloat(6, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(9, aux2));
    sumV = add_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V7
    currentV = mul_Unifloat(convertInteger_Unifloat(881664, type), power_Unifloat(2, arg));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(99783936, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1135145088, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(2000000000, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(884531440, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1965889800, type), power_Unifloat(10, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(318291750, type), power_Unifloat(12, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(5635995, type), power_Unifloat(14, arg)));
    currentV = sub_Unifloat(currentV, convertInteger_Unifloat(2048, type));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(3440640, type), power_Unifloat(7, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(10, aux2));
    currentV = div_Unifloat(currentV, aux1);
    currentV = add_Unifloat(currentV, div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(1680, type), power_Unifloat(7, convertInteger_Unifloat(n, type)))));
    sumV = add_Unifloat(sumV, currentV);
    /**/

    /**/
    //////V8
    currentV = convertInteger_Unifloat(1024, type);
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(248320, type), power_Unifloat(2, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(5095936, type), power_Unifloat(4, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(24059968, type), power_Unifloat(6, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(34280896, type), power_Unifloat(8, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(15252048, type), power_Unifloat(10, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(1765936, type), power_Unifloat(12, arg)));
    currentV = add_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(23797, type), power_Unifloat(14, arg)));
    currentV = mul_Unifloat(currentV, power_Unifloat(2, arg));
    currentV = div_Unifloat(currentV, mul_Unifloat(convertInteger_Unifloat(4096, type), power_Unifloat(8, convertInteger_Unifloat(n, type))));
    currentV = div_Unifloat(currentV, power_Unifloat(12, aux2));
    sumV = add_Unifloat(sumV, currentV);

    /**/
    //////computation result
    result = div_Unifloat(convertInteger_Unifloat(1, type), sqrt_Unifloat(aux1));
    current1 = log_Unifloat(div_Unifloat(arg, add_Unifloat(convertInteger_Unifloat(1, type), aux1)));
    current1 = add_Unifloat(current1, aux1);
    current1 = mul_Unifloat(current1, convertInteger_Unifloat(n, type));

    current2 = add_Unifloat(current2, sumV);
    current2 = add_Unifloat(current2, factorialSeries_Unifloat(n, type));

    result = mul_Unifloat(result, exp_Unifloat(sub_Unifloat(current2, current1)));
    result = div_Unifloat(result, sqrt_Unifloat(pi));
    result = mul_Unifloat(result, sqrt_Unifloat(convertInteger_Unifloat(2, type)));
    result = div_Unifloat(result, sqrt_Unifloat(convertInteger_Unifloat(n, type)));
    result->sign = -1;
    return result;
}

//////////////////////////////////////////////////////////////////////
//                        jnMeisselSecond_Unifloat                  //
//////////////////////////////////////////////////////////////////////
Unifloat* jnMeisselSecond_Unifloat(IntT n, Unifloat* x)
{
    IntT type = x->type;
    Unifloat* result, * current;
    Unifloat* P = createZero_Unifloat(type);
    Unifloat* Q = createZero_Unifloat(type);
    Unifloat* arg, * cot, * sec;
    Unifloat* pi, * e;

    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    e = convertString_Unifloat(create_CString(E), type);

    arg = acos_Unifloat(div_Unifloat(convertInteger_Unifloat(n, type), x));
    cot = div_Unifloat(convertInteger_Unifloat(1, type), tan_Unifloat(arg));
    sec = div_Unifloat(x, convertInteger_Unifloat(n, type));

    //////P1
    current = mul_Unifloat(convertInteger_Unifloat(4, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, power_Unifloat(4, sec));
    current = mul_Unifloat(current, power_Unifloat(6, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(16, type), power_Unifloat(2, convertInteger_Unifloat(n, type))));
    P = add_Unifloat(P, current);

    /**/
    //////P2
    current = mul_Unifloat(convertInteger_Unifloat(32, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(288, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(232, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(13, type), power_Unifloat(8, sec)));
    current = mul_Unifloat(current, power_Unifloat(12, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(128, type), power_Unifloat(4, convertInteger_Unifloat(n, type))));
    P = sub_Unifloat(P, current);
    /**/
    /**/
    //////P3
    current = mul_Unifloat(convertInteger_Unifloat(48, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(2580, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(14884, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(17493, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(4242, type), power_Unifloat(10, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(103, type), power_Unifloat(12, sec)));
    current = mul_Unifloat(current, power_Unifloat(18, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(192, type), power_Unifloat(6, convertInteger_Unifloat(n, type))));
    P = add_Unifloat(P, current);
    /**/
    /**/
    //////P4
    current = convertInteger_Unifloat(1024, type);
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(248320, type), power_Unifloat(2, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(5095936, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(24059968, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(34280896, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(15252048, type), power_Unifloat(10, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1765936, type), power_Unifloat(12, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(23797, type), power_Unifloat(14, sec)));
    current = mul_Unifloat(current, power_Unifloat(24, cot));
    current = mul_Unifloat(current, power_Unifloat(2, sec));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(4096, type), power_Unifloat(8, convertInteger_Unifloat(n, type))));
    P = sub_Unifloat(P, current);
    /**/
    //////Q1
    current = add_Unifloat(convertInteger_Unifloat(2, type), mul_Unifloat(convertInteger_Unifloat(3, type), power_Unifloat(2, sec)));
    current = mul_Unifloat(current, power_Unifloat(3, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(24, type), convertInteger_Unifloat(n, type)));
    current->sign = (-1)*current->sign;
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(n, type), sub_Unifloat(tan_Unifloat(arg), arg)));
    Q = add_Unifloat(Q, current);
    //////Q2
    current = convertInteger_Unifloat(16, type);
    current = sub_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1512, type), power_Unifloat(2, sec)));
    current = sub_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(3654, type), power_Unifloat(4, sec)));
    current = sub_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(375, type), power_Unifloat(6, sec)));
    current = mul_Unifloat(current, power_Unifloat(9, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(5760, type), power_Unifloat(3, convertInteger_Unifloat(n, type))));
    Q = sub_Unifloat(Q, current);
    //////Q3
    current = convertInteger_Unifloat(256, type);
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(78720, type), power_Unifloat(2, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1891200, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(4744640, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1914210, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(67599, type), power_Unifloat(10, sec)));
    current = mul_Unifloat(current, power_Unifloat(15, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(322560, type), power_Unifloat(5, convertInteger_Unifloat(n, type))));
    Q = sub_Unifloat(Q, current);
    //////Q4
    current = mul_Unifloat(convertInteger_Unifloat(881664, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(99783936, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1135145088, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(2000000000, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(884531440, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1965889800, type), power_Unifloat(10, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(318291750, type), power_Unifloat(12, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(5635995, type), power_Unifloat(14, sec)));
    current = sub_Unifloat(current, convertInteger_Unifloat(2048, type));
    current = mul_Unifloat(current, power_Unifloat(21, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(3440640, type), power_Unifloat(7, convertInteger_Unifloat(n, type))));
    Q = add_Unifloat(Q, current);

    //////result//////
    result = sqrt_Unifloat(div_Unifloat(mul_Unifloat(convertInteger_Unifloat(2, type), cot), mul_Unifloat(convertInteger_Unifloat(n, type), pi)));
    result = div_Unifloat(result, exp_Unifloat(P));
    
    result = mul_Unifloat(result, cos_Unifloat(sub_Unifloat(Q, div_Unifloat(pi, convertInteger_Unifloat(4, type)))));

    return result;
}

//////////////////////////////////////////////////////////////////////
//                        ynMeisselSecond_Unifloat                  //
//////////////////////////////////////////////////////////////////////
Unifloat* ynMeisselSecond_Unifloat(IntT n, Unifloat* x)
{
    IntT type = x->type;
    Unifloat* result, * current;
    Unifloat* P = createZero_Unifloat(type);
    Unifloat* Q = createZero_Unifloat(type);
    Unifloat* arg, * cot, * sec;
    Unifloat* pi, * e;

    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    e = convertString_Unifloat(create_CString(E), type);

    arg = acos_Unifloat(div_Unifloat(convertInteger_Unifloat(n, type), x));
    cot = div_Unifloat(convertInteger_Unifloat(1, type), tan_Unifloat(arg));
    sec = div_Unifloat(x, convertInteger_Unifloat(n, type));

    //////P1
    current = mul_Unifloat(convertInteger_Unifloat(4, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, power_Unifloat(4, sec));
    current = mul_Unifloat(current, power_Unifloat(6, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(16, type), power_Unifloat(2, convertInteger_Unifloat(n, type))));
    P = add_Unifloat(P, current);
    /**///////P2
    current = mul_Unifloat(convertInteger_Unifloat(32, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(288, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(232, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(13, type), power_Unifloat(8, sec)));
    current = mul_Unifloat(current, power_Unifloat(12, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(128, type), power_Unifloat(4, convertInteger_Unifloat(n, type))));
    P = sub_Unifloat(P, current);
    /**/
    /**/    //////P3
    current = mul_Unifloat(convertInteger_Unifloat(48, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(2580, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(14884, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(17493, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(4242, type), power_Unifloat(10, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(103, type), power_Unifloat(12, sec)));
    current = mul_Unifloat(current, power_Unifloat(18, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(192, type), power_Unifloat(6, convertInteger_Unifloat(n, type))));
    P = add_Unifloat(P, current);
    /**/
    /**/    //////P4
    current = convertInteger_Unifloat(1024, type);
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(248320, type), power_Unifloat(2, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(5095936, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(24059968, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(34280896, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(15252048, type), power_Unifloat(10, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1765936, type), power_Unifloat(12, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(23797, type), power_Unifloat(14, sec)));
    current = mul_Unifloat(current, power_Unifloat(24, cot));
    current = mul_Unifloat(current, power_Unifloat(2, sec));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(4096, type), power_Unifloat(8, convertInteger_Unifloat(n, type))));
    P = sub_Unifloat(P, current);
    /**/
    //////Q1
    current = add_Unifloat(convertInteger_Unifloat(2, type), mul_Unifloat(convertInteger_Unifloat(3, type), power_Unifloat(2, sec)));
    current = mul_Unifloat(current, power_Unifloat(3, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(24, type), convertInteger_Unifloat(n, type)));
    current->sign = (-1)*current->sign;
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(n, type), sub_Unifloat(tan_Unifloat(arg), arg)));
    Q = add_Unifloat(Q, current);
    /**/    //////Q2
    current = convertInteger_Unifloat(16, type);
    current = sub_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1512, type), power_Unifloat(2, sec)));
    current = sub_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(3654, type), power_Unifloat(4, sec)));
    current = sub_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(375, type), power_Unifloat(6, sec)));
    current = mul_Unifloat(current, power_Unifloat(9, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(5760, type), power_Unifloat(3, convertInteger_Unifloat(n, type))));
    Q = sub_Unifloat(Q, current);
    /**/
    /**/    //////Q3
    current = convertInteger_Unifloat(256, type);
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(78720, type), power_Unifloat(2, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1891200, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(4744640, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1914210, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(67599, type), power_Unifloat(10, sec)));
    current = mul_Unifloat(current, power_Unifloat(15, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(322560, type), power_Unifloat(5, convertInteger_Unifloat(n, type))));
    Q = sub_Unifloat(Q, current);

    /**/
    //////Q4
    /**/
    current = mul_Unifloat(convertInteger_Unifloat(881664, type), power_Unifloat(2, sec));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(99783936, type), power_Unifloat(4, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1135145088, type), power_Unifloat(6, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(2000000000, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(884531440, type), power_Unifloat(8, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(1965889800, type), power_Unifloat(10, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(318291750, type), power_Unifloat(12, sec)));
    current = add_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(5635995, type), power_Unifloat(14, sec)));
    current = sub_Unifloat(current, convertInteger_Unifloat(2048, type));
    current = mul_Unifloat(current, power_Unifloat(21, cot));
    current = div_Unifloat(current, mul_Unifloat(convertInteger_Unifloat(3440640, type), power_Unifloat(7, convertInteger_Unifloat(n, type))));
    Q = add_Unifloat(Q, current);
    /**/
    //////result//////
    result = sqrt_Unifloat(div_Unifloat(mul_Unifloat(convertInteger_Unifloat(2, type), cot), mul_Unifloat(convertInteger_Unifloat(n, type), pi)));
    result = div_Unifloat(result, exp_Unifloat(P));
    result = mul_Unifloat(result, sin_Unifloat(sub_Unifloat(Q, div_Unifloat(pi, convertInteger_Unifloat(4, type)))));
    return result;
}

//////////////////////////////////////////////////////////////////////
//                          jnSteed_Unifloat                        //
//////////////////////////////////////////////////////////////////////
Unifloat* jnSteed_Unifloat(IntT n, Unifloat* x)
{
    IntT num, N1 = 1, N2 = 300, sign, type = x->type;
    Unifloat* Wronskian, * J, * gamma, * pi, * CF1, * A1, * A2, * B1, * B2, * AA;
    Unifloat* One, * Two, * Four, * INDEX, * Zero;
    Unifloat* temp, * tmp, * Q0, * Q1;
    UnifloatComplex* CF2, * aux;

    Zero = createZero_Unifloat(type);
    One = createOne_Unifloat(type);
    Two = createOne_Unifloat(type);
    Two->exp++;
    Four = createOne_Unifloat(type);
    Four->exp += 2;
    INDEX = convertInteger_Unifloat(n, type);
    pi = convertBinaryString_Unifloat(create_CString(PI), type);
    
    CF2 = create_UnifloatComplex(clone(Zero), clone(Zero));
    aux = create_UnifloatComplex(clone(Zero), clone(Zero));
    
    //////determine N1///////
    B1 = div_Unifloat(createOne_Unifloat(type), x);
    B1->exp++;
    A1 = mul_Unifloat(INDEX, B1);
    Q0 = clone(A1);
    Q1 = mul_Unifloat(Q0, add_Unifloat(A1, B1));
    Q1 = sub_Unifloat(Q1, One);
    temp = add_Unifloat(A1, B1);
    while(Q1->exp < 50)
    {
        N1 += 1;
        temp = add_Unifloat(temp, B1);
        tmp = mul_Unifloat(temp, Q1);
        tmp = sub_Unifloat(tmp, Q0);
        Q0 = clone(Q1);
        Q1 = clone(tmp);
    }
    //////computation CF1//////
    A1 = clone(One);
    A2 = clone(Zero);
    
    B1 = clone(Zero);
    B2 = clone(One);

    for(num = 1; num < N1; num++)
    {
        AA = clone(A2);
        A2 = sub_Unifloat(div_Unifloat(mul_Unifloat(mul_Unifloat(Two, A2), 
           add_Unifloat(INDEX, convertInteger_Unifloat(num, type))), x), A1);
        A1 = clone(AA);
        AA = clone(B2);
        B2 = sub_Unifloat(div_Unifloat(mul_Unifloat(mul_Unifloat(Two, B2), 
           add_Unifloat(INDEX, convertInteger_Unifloat(num, type))), x), B1);
        B1 = clone(AA);
    }
    
    CF1=div_Unifloat(A2, B2);
    CF1 = add_Unifloat(div_Unifloat(INDEX, x), CF1);
    sign = B2->sign;

    CF2->Re = clone(x);
    CF2->Re->exp++;
    CF2->Im = convertInteger_Unifloat(N2 + 1, type);
    CF2->Im->exp++;
    for(num = N2; num > 0; num--)
    {
        aux->Re = mul_Unifloat(convertInteger_Unifloat(2*num+1, type), convertInteger_Unifloat(2*num+1, type));
        aux->Re->exp -= 2;
        aux->Re = sub_Unifloat(aux->Re, mul_Unifloat(INDEX, INDEX));
        aux->Im = createZero_Unifloat(type);
        CF2 = div_UnifloatComplex(aux, CF2);
        aux->Re = clone(x);
        aux->Re->exp++;
        aux->Im = convertInteger_Unifloat(num, type);
        aux->Im->exp++;
        CF2 = add_UnifloatComplex(aux, CF2);
    }
    aux->Im = clone(One);
    aux->Im->exp -= 2;
    aux->Im = sub_Unifloat(aux->Im, mul_Unifloat(INDEX, INDEX));
    aux->Im = div_Unifloat(aux->Im, x);
    aux->Re = createZero_Unifloat(type);

    CF2 = div_UnifloatComplex(aux, CF2);
    CF2->Im = add_Unifloat(CF2->Im, One);
    CF2->Re = sub_Unifloat(CF2->Re, div_Unifloat(One, mul_Unifloat(Two, x)));
    
    //////computation J//////
    Wronskian = div_Unifloat(Two, mul_Unifloat(pi, x));

    gamma = div_Unifloat(sub_Unifloat(CF2->Re, CF1), CF2->Im);
    J = div_Unifloat(Wronskian, add_Unifloat(CF2->Im, mul_Unifloat(gamma, sub_Unifloat(CF2->Re, CF1))));
    J = sqrt_Unifloat(J);
    J->sign=sign;
    return J;
}

//////////////////////////////////////////////////////////////////////
//                          ynSteed_Unifloat                        //
//////////////////////////////////////////////////////////////////////
Unifloat* ynSteed_Unifloat(IntT n, Unifloat* x)
{
    IntT num, N1 = 1, N2 = 300, sign, type = x->type;
    Unifloat* Wronskian, * Y, * gamma, * pi, * CF1, * A1, * A2, * B1, * B2, * AA;
    Unifloat* One, * Two, * Four, * INDEX, * Zero;
    Unifloat* temp, * tmp, * Q0, * Q1;
    UnifloatComplex* CF2, * aux;

    Zero = createZero_Unifloat(type);
    One = convertInteger_Unifloat(1, type);
    Two = convertInteger_Unifloat(2, type);
    Four = convertInteger_Unifloat(4, type);
    INDEX = convertInteger_Unifloat(n, type);
    pi = convertBinaryString_Unifloat(create_CString(PI), type);

    CF2 = create_UnifloatComplex(clone(Zero), clone(Zero));
    aux = create_UnifloatComplex(clone(Zero), clone(Zero));

    //////determine N1///////
    B1 = div_Unifloat(createOne_Unifloat(type), x);
    B1->exp++;
    A1 = mul_Unifloat(INDEX, B1);
    Q0 = clone(A1);
    Q1 = mul_Unifloat(Q0, add_Unifloat(A1, B1));
    Q1 = sub_Unifloat(Q1, One);
    temp = add_Unifloat(A1, B1);
    while(Q1->exp < 50)
    {
        N1 += 1;
        temp = add_Unifloat(temp, B1);
        tmp = mul_Unifloat(temp, Q1);
        tmp = sub_Unifloat(tmp, Q0);
        Q0 = clone(Q1);
        Q1 = clone(tmp);
    }

    //////computation CF1//////
    A1 = clone(One);
    A2 = clone(Zero);
    
    B1 = clone(Zero);
    B2 = clone(One);

    for(num = 1; num < N1; num++)
    {
        AA = clone(A2);
        A2 = sub_Unifloat(div_Unifloat(mul_Unifloat(mul_Unifloat(Two, A2), 
           add_Unifloat(INDEX, convertInteger_Unifloat(num, type))), x), A1);
        A1 = clone(AA);
        AA = clone(B2);
        B2 = sub_Unifloat(div_Unifloat(mul_Unifloat(mul_Unifloat(Two, B2), 
           add_Unifloat(INDEX, convertInteger_Unifloat(num, type))), x), B1);
        B1 = clone(AA);
    }
    
    CF1=div_Unifloat(A2, B2);
    CF1 = add_Unifloat(div_Unifloat(INDEX, x), CF1);
    sign = B2->sign;

    CF2->Re = mul_Unifloat(Two, x);
    CF2->Im = mul_Unifloat(Two, convertInteger_Unifloat(N2 + 1, type));

    for(num = N2; num > 0; num--)
    {
        aux->Re = div_Unifloat(mul_Unifloat(convertInteger_Unifloat(2*num+1, type), 
                               convertInteger_Unifloat(2*num+1, type)), Four);
        aux->Re = sub_Unifloat(aux->Re, mul_Unifloat(INDEX, INDEX));
        aux->Im = convertInteger_Unifloat(0, type);
        CF2 = div_UnifloatComplex(aux, CF2);
        aux->Re = mul_Unifloat(Two, x);
        aux->Im = mul_Unifloat(Two, convertInteger_Unifloat(num, type));
        CF2 = add_UnifloatComplex(aux, CF2);
    }
    aux->Im = div_Unifloat(One, Four);
    aux->Im = sub_Unifloat(aux->Im, mul_Unifloat(INDEX, INDEX));
    aux->Im = div_Unifloat(aux->Im, x);
    aux->Re = convertInteger_Unifloat(0, type);

    CF2 = div_UnifloatComplex(aux, CF2);
    CF2->Im = add_Unifloat(CF2->Im, One);
    CF2->Re = sub_Unifloat(CF2->Re, div_Unifloat(One, mul_Unifloat(Two, x)));
    
    //////computation Y//////
    Wronskian = div_Unifloat(convertInteger_Unifloat(2, type), mul_Unifloat(pi, x));

    gamma = div_Unifloat(sub_Unifloat(CF2->Re, CF1), CF2->Im);
    Y = div_Unifloat(Wronskian, add_Unifloat(CF2->Im, mul_Unifloat(gamma, sub_Unifloat(CF2->Re, CF1))));
    Y = sqrt_Unifloat(Y);
    Y->sign=sign;
    Y = mul_Unifloat(Y, gamma);
    return Y;
}

//////////////////////////////////////////////////////////////////////
//                        factorialSeries_Unifloat                  //
//////////////////////////////////////////////////////////////////////
Unifloat* factorialSeries_Unifloat(IntT n, UnifloatType type)
{
    Unifloat* result = createZero_Unifloat(type);
    Unifloat* current = createZero_Unifloat(type);
    Unifloat* index = convertInteger_Unifloat(n, type);
    Unifloat* square_index = mul_Unifloat(index, index);

    current = div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(12, type), index));
    result = add_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(360, type), index));
    result = sub_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(1260, type), index));
    result = add_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(1, type), mul_Unifloat(convertInteger_Unifloat(1680, type), index));
    result = sub_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(5, type), mul_Unifloat(convertInteger_Unifloat(5940, type), index));
    result = add_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(691, type), mul_Unifloat(convertInteger_Unifloat(360360, type), index));
    result = sub_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(7, type), mul_Unifloat(convertInteger_Unifloat(1092, type), index));
    result = add_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(3617, type), mul_Unifloat(convertInteger_Unifloat(122400, type), index));
    result = sub_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(43867, type), mul_Unifloat(convertInteger_Unifloat(244188, type), index));
    result = add_Unifloat(result, current);

    index = mul_Unifloat(index, square_index);

    current = div_Unifloat(convertInteger_Unifloat(174611, type), mul_Unifloat(convertInteger_Unifloat(125400, type), index));
    result = sub_Unifloat(result, current);

    return result;
}

//////////////////////////////////////////////////////////////////////
//                          power_Unifloat                          //
//////////////////////////////////////////////////////////////////////
Unifloat* power_Unifloat(IntT n, Unifloat* x)
{
    IntT num;
    Unifloat* res = createZero_Unifloat(x->type);
    res = convertInteger_Unifloat(1, x->type);
    for(num=1;num<n+1;num++)
    {
        res = mul_Unifloat(res, x);
    }
    return res;
}

//////////////////////////////////////////////////////////////////////
//                          getMethod_Unifloat                      //
//////////////////////////////////////////////////////////////////////
IntT getMethod_Unifloat(IntT n, Unifloat* x)
{
    IntT type = x->type;
    Unifloat* tmp, * INDEX = convertInteger_Unifloat(n, type);
    Unifloat* Ten = convertInteger_Unifloat(10, type);
    Unifloat* One, * BoundFirst, * BoundSecond;
    
    One = createOne_Unifloat(x->type);
    BoundFirst = clone(One);
    BoundFirst->exp += 3;
    BoundSecond = clone(One);
    BoundSecond->exp += 6;

    tmp = createOne_Unifloat(x->type);
    tmp->exp+=4;
    BoundFirst = add_Unifloat(BoundFirst, tmp);

    if(n <= 10)
    {
        if(compare_Unifloat(abs_Unifloat(x), BoundFirst) != 1)
        {
            return 1;
        }
        else if(compare_Unifloat(abs_Unifloat(x), BoundSecond) != 1)
        {
            return 5;
        }
        else
        {
            return 2;
        }
    }
    else if(n <= 100000)
    {
        return 6;//Recurence, forward and backward
    }
    else
    {
        tmp = mul_Unifloat(INDEX, INDEX);
        if(compare_Unifloat(x, tmp) != -1)
            return 2;//Hankel's

        tmp = mul_Unifloat(convertString_Unifloat(create_CString("0.98"), type), INDEX);
        if(compare_Unifloat(x, tmp) != 1)
            return 3;//Meissel's First
        
        tmp = mul_Unifloat(convertString_Unifloat(create_CString("1.03"), type), INDEX);
        if(compare_Unifloat(x, tmp) != -1)
            return 4;//Meissel's Second
        
        if((compare_Unifloat(x, add_Unifloat(INDEX, Ten)) != 1)  
            && (compare_Unifloat(x, sub_Unifloat(INDEX, Ten)) != -1))
            return 5;//Steed's
    }
    return 0;
}

Unifloat* jnRecurrent_Unifloat(IntT n, Unifloat* x)
{
    IntT i, NUM = 1;
    UnifloatType type = x->type;
    Unifloat* INDEX = convertInteger_Unifloat(n, type);
    Unifloat* aux, * tmp, * A1, * B1, * A2, * B2, * CF, * J0, * Q0, * Q1;
    Unifloat* One, * Two, * Zero;
    Zero = createZero_Unifloat(type);
    One = createOne_Unifloat(type);
    Two = clone(One);
    Two->exp++;

    J0 = j0_model(x);
    A1 = clone(J0);
    B1 = j1_model(x);
    if(compare_Unifloat(abs_Unifloat(x), abs_Unifloat(INDEX)) != -1)
    {
        for(i = 1; i < n; i++)
        {
            aux = clone(B1);
            B1 = mul_Unifloat(B1, convertInteger_Unifloat(i, type));
            B1 = div_Unifloat(B1, x);
            B1->exp++;
            B1 = sub_Unifloat(B1, A1);
            A1 = clone(aux);
        }
        return B1;
    }
    else
    {
        //////determine NUM///////
        B1 = div_Unifloat(createOne_Unifloat(type), x);
        B1->exp++;
        A1 = mul_Unifloat(INDEX, B1);
        Q0 = clone(A1);
        Q1 = mul_Unifloat(Q0, add_Unifloat(A1, B1));
        Q1 = sub_Unifloat(Q1, One);
        aux = add_Unifloat(A1, B1);
        while(Q1->exp < 50)
        {
            NUM += 1;
            aux = add_Unifloat(aux, B1);
            tmp = mul_Unifloat(aux, Q1);
            tmp = sub_Unifloat(tmp, Q0);
            Q0 = clone(Q1);
            Q1 = clone(tmp);
        }

        //////compute CF//////
        A1 = clone(One);
        A2 = clone(Zero);
        
        B1 = clone(Zero);
        B2 = clone(One);

        for(i = 0; i < NUM; i++)
        {
            aux = clone(A2);
            A2 = sub_Unifloat(div_Unifloat(mul_Unifloat(mul_Unifloat(Two, A2), 
               add_Unifloat(INDEX, convertInteger_Unifloat(i, type))), x), A1);
            A1 = clone(aux);
            aux = clone(B2);
            B2 = sub_Unifloat(div_Unifloat(mul_Unifloat(mul_Unifloat(Two, B2), 
               add_Unifloat(INDEX, convertInteger_Unifloat(i, type))), x), B1);
            B1 = clone(aux);
        }
        
        CF = div_Unifloat(A2, B2);
        CF->sign = (-1) * CF->sign;

        //////backward recurrence//////
        A1 = clone(CF);
        B1 = createOne_Unifloat(type);
        for(i = n - 1; i > 0; i--)
        {
            aux = clone(B1);
            B1 = mul_Unifloat(B1, convertInteger_Unifloat(i, type));
            B1 = div_Unifloat(B1, x);
            B1->exp++;
            B1 = sub_Unifloat(B1, A1);
            A1 = clone(aux);
        }
        B1 = div_Unifloat(mul_Unifloat(CF, J0), B1);
        return B1;
    }
}

Unifloat* ynRecurrent_Unifloat(IntT n, Unifloat* x)
{
    IntT i;
    UnifloatType type = x->type;
    Unifloat* aux, * A1, * B1;

    A1 = y0_model(x);
    B1 = y1_model(x);
    for(i = 1; i < n; i++)
    {
        aux = clone(B1);
        B1 = mul_Unifloat(B1, convertInteger_Unifloat(i, type));
        B1 = div_Unifloat(B1, x);
        B1->exp++;
        B1 = sub_Unifloat(B1, A1);
        A1 = clone(aux);
    }
    return B1;
}

