 /*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "math/bessel/tests/bessel_scenario.seh"
#include "math/bessel/bessel_media.seh"
#include "math/bessel/bessel_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "math/math/math_data.seh"
#include "math/math/math_config.h"
#include <stdio.h>

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context;
static VoidTPtr ptr;
/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_math_bessel_scenario(int argc, char** argv)
{
    // Init test scenario data
    context = getContext();

    initReqFilters();

    ptr = allocateMemoryBlock(context, 1024);

    setFinishMode(UNTIL_END);

    return true;
}
static void finish_math_bessel_scenario(void)
{
    deallocateMemoryBlock(context, ptr);
    TEST_SCENARIO_VERDICT_VERBOSE(bessel_scenario);
}
/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/
void ReadFromFileBessel(CharT* file_name, List* x)
{
    FILE* f;
    char st[100];
    CString* str;
    Unifloat* tmp, *tmp_exp;
    IntT error;

    f = fopen(getTestDataFile(file_name), "r+");
    while (!feof(f))
    {
        fscanf(f, "%s\n", &st);
        str = create_CString(st);
        tmp = convertBinaryString_Unifloat(substring_CString(str, 0, indexOfChar_CString(str, 'e')), UniDoubleT);
        tmp_exp = convertString_Unifloat(substring_CString(str, indexOfChar_CString(str, 'e')+1, length_CString(str)), UniDoubleT);
        tmp->exp = convertUnifloat_Integer(tmp_exp, &error) + 1;
        append_List(x, tmp);
    }
    fclose(f);
}

int two_power(int n)
{
    int i, res = 1;
    for(i = 0; i < n; i++)
        res *= 2;
    return res;
}

int checkSymmetryByX(Unifloat* pos_res, Unifloat* x, IntT n, IntT round_mode)
{
    IntT ulp = 0;
    IntT hits = 0;
    Unifloat* neg_res;
    IntT mant = digMant_Unifloat(x->type);
    x->sign = -1 * x->sign;
    neg_res = jn_spec(context,
                         n,
                         x,
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
    if(CHECK_EXTENDED_REQ==1)
    {
    if(n%2 != 0)
    {
        pos_res->sign = -1 * pos_res->sign;
    }
    REQ_SCEN("j0.10.01;j1.10.01;jn.10.01;j0f.j0.10.01;j1f.j1.10.01;jnf.jn.10.01;j0l.j0.10.01;j1l.j1.10.01;jnl.jn.10.01;"
             "j0.10.02;j1.10.02;jn.10.02;j0f.j0.10.02;j1f.j1.10.02;jnf.jn.10.02;j0l.j0.10.02;j1l.j1.10.02;jnl.jn.10.02;"
             "j0.10.03;j1.10.03;jn.10.03;j0f.j0.10.03;j1f.j1.10.03;jnf.jn.10.03;j0l.j0.10.03;j1l.j1.10.03;jnl.jn.10.03",
             "Symmetry by the argument x",
                  compare_Unifloat(pos_res, neg_res) == 0);
    if(compare_Unifloat(pos_res, neg_res) != 0)
    {
        hits += 1;
    }
    if(n%2 != 0)
    {
        pos_res->sign = -1 * pos_res->sign;
    }
    }

    x->sign = -1 * x->sign;
    return hits;
}

int checkSymmetryByN(Unifloat* pos_res, Unifloat* x, IntT n, IntT round_mode)
{
    IntT ulp = 0;
    IntT hits = 0;
    Unifloat* neg_res;
    IntT mant = digMant_Unifloat(x->type);
    //FILE* file;
    IntT neg_n = -1 * n;
    neg_res = jn_spec(context,
                         neg_n,
                         x,
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
    if(CHECK_EXTENDED_REQ==1)
    {
    if(n%2 != 0)
    {
        pos_res->sign = -1 * pos_res->sign;
    }
    //printExp_Unifloat(x, 53);
    //printExp_Unifloat(pos_res, 53);
    //printExp_Unifloat(neg_res, 53);
    REQ_SCEN("j0.10.04;j1.10.04;jn.10.04;j0f.j0.10.04;j1f.j1.10.04;jnf.jn.10.04;j0l.j0.10.04;j1l.j1.10.04;jnl.jn.10.04",
             "Symmetry by the index n",
                  compare_Unifloat(pos_res, neg_res) == 0);
    if(compare_Unifloat(pos_res, neg_res) != 0)
    {
        hits += 1;
    }
    //file = fopen("src/model/math/bessel/tests/Results/out.txt", "a");
    //fprintf(file, "%d\n", n);
    //fprintf(file, "%d\n", compare_Unifloat(pos_res, neg_res));
    //fclose(file);
    if(n%2 != 0)
    {
        pos_res->sign = -1 * pos_res->sign;
    }
    }
    return hits;
}

int checkRecurrence(Unifloat* res, Unifloat* x, IntT n, IntT round_mode)
{
    IntT ulp = 0;
    IntT hits = 0;
    Unifloat* ResM1, * ResP1;
    Unifloat* Expression1, * Expression2;
    IntT mant = digMant_Unifloat(x->type);
    Unifloat* Two = createOne_Unifloat(x->type);
    //FILE* file;
    Two->exp++;
    if(isZero_Unifloat(x))
    {
        return 0;
    }
    ResM1 = jn_spec(context,
                         n - 1,
                         x,
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
    ResP1 = jn_spec(context,
                         n + 1,
                         x,
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
    if(CHECK_EXTENDED_REQ==1)
    {
    Expression1 = add_Unifloat(ResM1, ResP1);
    round_Unifloat(Expression1, mant);
    Expression2 = mul_Unifloat(Two, convertInteger_Unifloat(n, x->type));
    Expression2 = div_Unifloat(Expression2, x);
    Expression2 = mul_Unifloat(Expression2, res);
    round_Unifloat(Expression2, mant);
    REQ_SCEN("j0.10.05;j1.10.05;jn.10.05;j0f.j0.10.05;j1f.j1.10.05;jnf.jn.10.05;j0l.j0.10.05;j1l.j1.10.05;jnl.jn.10.05",
             "Recurrence",
                  compareWithPrecision_Unifloat(Expression1, Expression2, mant + COMPARE_PRECISION - 2) == 0);
    if(compareWithPrecision_Unifloat(Expression1, Expression2, mant + COMPARE_PRECISION - 2) != 0)
    {
        hits += 1;
    }
    //file = fopen("src/model/math/bessel/tests/Results/out.txt", "a");
    //fprintf(file, "%d\n", compareWithPrecision_Unifloat(Expression1, Expression2, mant + COMPARE_PRECISION - 2));
    //fclose(file);
    }
    return hits;
}

scenario bool besselJ_scen()
{
    FILE* Report = fopen("src/model/math/bessel/tests/Results/Report.txt", "w+");
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                                createOne_Unifloat(UniDoubleT),
                                createOne_Unifloat(UniLongDoubleT)};
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;

    //AUXILIARY VARIABLES
    List* JA, * JB, * JC;
    Unifloat* x;
    Unifloat* y1, * y2, * y3;
    IntT i, j, k, n;
    IntT ulp = 0, round_mode = 1;
    IntT MaxInd = 5;
    IntT mant;

    //DATA CONTAINERS FOR ERRORS
    IntT HitsN = 0;
    IntT HitsX = 0;
    IntT HitsR = 0;
    IntT Hit = 0;
    IntT errorJAN[93][54];
    IntT errorJAN_ALL[54];
    IntT errorJAM[54];
    IntT errorJAS[54];
    IntT errorJBM_ALL[54];
    IntT errorJBN_ALL[54];
    IntT errorJCN_ALL[10][54];
    IntT errorJCM_ALL[10][54];
    DoubleT errorJBM_GRAPH[48];
    DoubleT errorJBM_REST[1001];
    DoubleT errorJBN_GRAPH[3][48];
    DoubleT errorJCN_GRAPH[3][10][48];
    DoubleT errorJCM_GRAPH[10][48];
    DoubleT errorJCN_DEPEND[3][14];
    DoubleT errorJCM_DEPEND[14];
    DoubleT errorJCCOMPL_DEPEND[14];
    double AvrUlp, sum;

    //PATHS TO FILES WITH POINTS
    CharT* pathJAN[11] = {(CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN0.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN1.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN2.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN3.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAN/JAN10.txt"};

    CharT* pathJAM[11] = {(CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM0.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM1.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM2.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM3.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAM/JAM10.txt"};

    CharT* pathJAS[11] = {(CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS0.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS1.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS2.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS3.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/A/JA/JAS/JAS10.txt"};

    CharT* pathJBM[11] = {(CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM0.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM1.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM2.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM3.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBM/JBM10.txt"};

    CharT* pathJBN[11] = {(CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN0.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN1.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN2.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN3.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/B/JB/JBN/JBN10.txt"};

    CharT* pathJCN[10] = {(CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN10.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN11.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN12.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCN/JCN13.txt"};

    CharT* pathJCM[10] = {(CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM4.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM5.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM6.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM7.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM8.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM9.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM10.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM11.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM12.txt",
                          (CharT *)"src/testdata/math.bessel/Points/C/JC/JCM/JCM13.txt"};

    //INITIALIZING OF ERRORS
    for(i = 0; i < 93; i++)
    {
        for(k= 0; k < 54; k++)
        {
            errorJAN[i][k] = 0;
            errorJAN_ALL[k] = 0;
            errorJAM[k] = 0;
            errorJAS[k] = 0;
            errorJBM_ALL[k] = 0;
            errorJBN_ALL[k] = 0;
        }
    }
    for(i = 0; i < 3; i++)
    {
        for(k= 0; k < 48; k++)
        {
            errorJBN_GRAPH[i][k] = 0;
            errorJBM_GRAPH[k] = 0;
        }
    }
    for(i = 0; i < 3; i++)
        for(j= 0; j < 10; j++)
            for(k= 0; k < 48; k++)
            {
                errorJCN_GRAPH[i][j][k] = 0;
                errorJCM_GRAPH[j][k] = 0;
            }

    for(i = 0; i < 10; i++)
        for(j= 0; j < 54; j++)
        {
            errorJCN_ALL[i][j] = 0;
            errorJCM_ALL[i][j] = 0;
        }

    for(i = 0; i < 3; i++)
        for(j= 0; j < 14; j++)
        {
            errorJCN_DEPEND[i][j] = 0;
            errorJCM_DEPEND[j] = 0;
            errorJCCOMPL_DEPEND[j] = 0;
        }


    ///////////////////////////////////////////////////////////////////////////
    //FIRST AREA (A)
    ///////////////////////////////////////////////////////////////////////////
    fprintf(Report, "FUNCTION jn(n,x)\n");
    fprintf(Report, "FIRST AREA A={(n,x)}=[0,10]*[0,20]\n\n");

    ///////////////////////////////////////////////////////////////////////////
    //J:A:N
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: AN\n");
    fprintf(Report, "(Beside nulls)\n");
    for(n = 0; n < MaxInd; n++)
    {
        JA = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJAN[n], JA);
        for (j = 0; j < size_List(JA); j++)
        {
            x = (Unifloat*)get_List(JA, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context,
                         n,
                         round_Unifloat(x, leng_num[1]),
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJAN[j%93][ulp]++;
            errorJAN_ALL[ulp]++;
            checkSymmetryByX(y1, x, n, round_mode);
            checkSymmetryByN(y1, x, n, round_mode);
            checkRecurrence(y1, x, n, round_mode);
        }
    }

    ///////DEPENDENCE OF ERROR FROM POSITION BESIDE NULL
    fprintf(Report, "\nDEPENDENCE OF ERROR FROM POSITION BESIDE NULL:\n");
    fprintf(Report, "\n(Average by the index from 0 to 10, and by the all nulls)\n");
    for(i = 0; i < 93; i++)
    {
        AvrUlp = 0;
        for(j = 0; j < 54; j++)
        {
            AvrUlp += j*errorJAN[i][j];
        }
        AvrUlp /= 43;
        fprintf(Report, "%e\n", AvrUlp);
    }
    /**/

    if(RESEARCH == 1)
    {
    ///////////////////////////////////////////////////////////////////////////
    //J:A:M
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: AM\n");
    fprintf(Report, "(Between nulls)\n");
    for(n = 0; n < 11; n++)
    {
        JA = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJAM[n], JA);
        for (j = 0; j < size_List(JA); j++)
        {
            x = (Unifloat*)get_List(JA, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context,
                         n,
                         round_Unifloat(x, leng_num[1]),
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJAM[ulp]++;
            Hit = checkSymmetryByX(y1, x, n, round_mode);
            if(Hit == 1)
            {
                HitsX += 1;
            }
            Hit = checkSymmetryByN(y1, x, n, round_mode);
            if(Hit == 1)
            {
                HitsN += 1;
            }
            Hit = checkRecurrence(y1, x, n, round_mode);
            if(Hit == 1)
            {
                HitsR += 1;
            }
        }
    }
    fprintf(Report, "\nSYMMETRY_X:\n");
    fprintf(Report, "%d\n", HitsX);
    fprintf(Report, "\nSYMMETRY_N:\n");
    fprintf(Report, "%d\n", HitsN);
    fprintf(Report, "\nRECURRENCE:\n");
    fprintf(Report, "%d\n", HitsR);

    ///////AVERAGE ERROR
    fprintf(Report, "\nAVERAGE ERROR:\n");
    AvrUlp = 0;
    for(i = 0; i < 54; i++)
    {
        AvrUlp += i*errorJAM[i];
    }
    fprintf(Report, "%e\n\n", AvrUlp/5472);

    ///////HISTOGRAM
    fprintf(Report, "\nHISTOGRAM:\n");
    for(i = 0; i < 54; i++)
    {
        fprintf(Report, "%d\n", errorJAM[i]);
    }
    /**/

    ///////////////////////////////////////////////////////////////////////////
    //J:A:S
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: AS\n");
    fprintf(Report, "(Between zero and first null of functions)\n");
    for(n = 0; n < 11; n++)
    {
        JA = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJAS[n], JA);
        for (j = 0; j < size_List(JA); j++)
        {
            x = (Unifloat*)get_List(JA, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context,
                         n,
                         round_Unifloat(x, leng_num[1]),
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJAS[ulp]++;
        }
    }

    ///////AVERAGE ERROR
    fprintf(Report, "\nAVERAGE ERROR:\n");
    AvrUlp = 0;
    for(i = 0; i < 54; i++)
    {
        AvrUlp += i*errorJAS[i];
    }
    fprintf(Report, "AvrUlp=%e\n\n", AvrUlp/2805);

    ///////HISTOGRAM
    fprintf(Report, "\nHISTOGRAM:\n");
    for(i = 0; i < 54; i++)
    {
        fprintf(Report, "%d\n", errorJAS[i]);
    }
    /**/

    /*/
    fprintf(Report, "SUB AREA: AS\n");
    fprintf(Report, "(Special points)\n");
    JA = create_List(&type_Unifloat);
    ReadFromFileBessel("src/testdata/math.bessel/Points/A/JA/JAS/SpecialPoints.txt", JA);
    for (j = 0; j < size_List(JA); j++)
    {
        x = (Unifloat*)get_List(JA, j);
        x->type=UniDoubleT;
        y1 = jn_spec(context,
                     j + 1,
                     round_Unifloat(x, leng_num[1]),
                     round_mode,
                     &ulp,
                     requestErrorCode()
                     );
    }
    /**/

    ///////////////////////////////////////////////////////////////////////////
    //J:B
    ///////////////////////////////////////////////////////////////////////////
    fprintf(Report, "FUNCTION jn(n,x)\n");
    fprintf(Report, "SECOND AREA B={(n,x)}=[0,10]*[20,+INF]\n\n");

    ///////////////////////////////////////////////////////////////////////////
    //J:B:M
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: BM\n");
    fprintf(Report, "(Between nulls)\n");
    for(n = 0; n < 11; n++)
    {
        JB = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJBM[n], JB);
        for (j = 0; j < size_List(JB); j++)
        {
            x = (Unifloat*)get_List(JB, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context,
                         n,
                         round_Unifloat(x, leng_num[1]),
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJBM_ALL[ulp]++;
            errorJBM_GRAPH[(int)(j/15)] += (DoubleT)ulp;
        }
    }

    ///////AVERAGE ERROR
    fprintf(Report, "\nAVERAGE ERROR:\n");
    AvrUlp = 0;
    for(i = 0; i < 54; i++)
    {
        AvrUlp += i*errorJBM_ALL[i];
    }
    fprintf(Report, "%e\n\n", AvrUlp/7425);

    ///////HISTOGRAM
    fprintf(Report, "\nHISTOGRAM:\n");
    for(i = 0; i < 54; i++)
    {
        fprintf(Report, "%d\n", errorJBM_ALL[i]);
    }

    ///////DEPENDENCE OF ERROR FROM NUMBER OF NULL
    fprintf(Report, "\nDEPENDENCE OF ERROR FROM NUMBER OF NULL:\n");
    fprintf(Report, "\n(Average by the index from 0 to 10)\n");
    for(i = 0; i < 48; i++)
    {
            fprintf(Report, "%e\n", errorJBM_GRAPH[i]/165.0);
    }
    /**/

    ///////////////////////////////////////////////////////////////////////////
    //J:B:N
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: BN\n");
    fprintf(Report, "(Beside nulls)\n");
    for(n = 0; n < 11; n++)
    {
        JB = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJBN[n], JB);
        for (j = 0; j < size_List(JB); j++)
        {
            x = (Unifloat*)get_List(JB, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context,
                         n,
                         round_Unifloat(x, leng_num[1]),
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJBN_ALL[ulp]++;
            errorJBN_GRAPH[j%3][(int)(j/3)] += ulp;
        }
    }

    ///////AVERAGE ERROR
    fprintf(Report, "\nAVERAGE ERROR:\n");
    AvrUlp = 0;
    for(i = 0; i < 54; i++)
    {
        AvrUlp += i*errorJBN_ALL[i];
    }
    fprintf(Report, "AvrUlp=%e\n\n", AvrUlp/1485);

    ///////HISTOGRAM
    fprintf(Report, "\nHISTOGRAM:\n");
    for(i = 0; i < 54; i++)
    {
        fprintf(Report, "%d\n", errorJBN_ALL[i]);
    }

    ///////DEPENDENCE OF ERROR FROM NUMBER OF NULL
    fprintf(Report, "\nDEPENDENCE OF ERROR FROM NUMBER OF NULL:\n");
    fprintf(Report, "\n(Average by the index from 0 to 10)\n");
    fprintf(Report, "(THE NEAREST LEFT POINT):\n");
    for(k = 0; k < 48; k++)
    {
        fprintf(Report, "%e\n", errorJBN_GRAPH[0][k]/11.0);
    }
    fprintf(Report, "(NULL):\n");
    for(k = 0; k < 48; k++)
    {
        fprintf(Report, "%e\n", errorJBN_GRAPH[1][k]/11.0);
    }
    fprintf(Report, "(THE NEAREST RIGHT POINT):\n");
    for(k = 0; k < 48; k++)
    {
        fprintf(Report, "%e\n", errorJBN_GRAPH[2][k]/11.0);
    }
    /**/

    ///////////////////////////////////////////////////////////////////////////
    //THIRD AREA (C)
    ///////////////////////////////////////////////////////////////////////////
    fprintf(Report, "FUNCTION jn(n,x)\n");
    fprintf(Report, "THIRD AREA C={(n,x)}=[11,2147483647]*[0,+INF]\n\n");

    ///////////////////////////////////////////////////////////////////////////
    //J:C:N
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: CN\n");
    fprintf(Report, "(Beside nulls)\n");
    for(n = 0; n < 10; n++)
    {
        JC = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJCN[n], JC);
        for (j = 0; j < size_List(JC); j++)
        {
            x = (Unifloat*)get_List(JC, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context, 
                         two_power(n + 4), 
                         round_Unifloat(x, leng_num[1]), 
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJCN_ALL[n][ulp]++;
            errorJCN_GRAPH[j%3][n][(int)(j/3)] += ulp;
        }
    }

    ///////AVERAGE ERROR
    fprintf(Report, "\nAVERAGE ERROR:\n");
    for(j = 0; j < 10; j ++)
    {
        AvrUlp = 0;
        for(i = 0; i < 54; i++)
        {
            AvrUlp += i*errorJCN_ALL[j][i];
        }
        fprintf(Report, "%e\n", AvrUlp/144);
    }
    ///////HISTOGRAM
    fprintf(Report, "\nHISTOGRAM:\n");
    for(j = 0; j < 10; j ++)
    {
        fprintf(Report, "INDEX=2^(%d)\n", j + 4);
        for(i = 0; i < 54; i++)
        {
                fprintf(Report, "%d\n", errorJCN_ALL[j][i]);
        }
    }
    ///////ALL HISTOGRAM
    fprintf(Report, "\nALL HISTOGRAM:\n");
    for(i = 0; i < 54; i++)
    {
        sum = 0.0;
        for(j = 0; j < 10; j ++)
        {
            sum += errorJCN_ALL[j][i];
        }
        fprintf(Report, "%e\n", sum);
    }

    ///////DEPENDENCE OF ERROR FROM NUMBER OF NULL
    fprintf(Report, "\nDEPENDENCE OF ERROR FROM NUMBER OF NULL:\n");
    for(j = 0; j < 10; j++)
    {
        fprintf(Report, "index = %d\n", j + 4);
        fprintf(Report, "(THE NEAREST LEFT POINT):\n");
        for(k = 0; k < 48; k++)
        {
            fprintf(Report, "%e\n", errorJCN_GRAPH[0][j][k]);
        }
        fprintf(Report, "(NULL POINT):\n");
        for(k = 0; k < 48; k++)
        {
            fprintf(Report, "%e\n", errorJCN_GRAPH[1][j][k]);
        }
        fprintf(Report, "(THE NEAREST RIGHT POINT):\n");
        for(k = 0; k < 48; k++)
        {
            fprintf(Report, "%e\n", errorJCN_GRAPH[2][j][k]);
        }
    }

    ///////AVERAGE DEPENDENCE OF ERROR FROM NUMBER OF NULL
    fprintf(Report, "\nAVERAGE DEPENDENCE OF ERROR FROM NUMBER OF NULL:\n");
    fprintf(Report, "(THE NEAREST LEFT POINT):\n");
    for(k = 0; k < 48; k++)
    {
        sum = 0.0;
        for(j = 0; j < 10; j ++)
        {
            sum += errorJCN_GRAPH[0][j][k];
        }
        fprintf(Report, "%e\n", sum/10.0);
    }
    fprintf(Report, "(NULL POINT):\n");
    for(k = 0; k < 48; k++)
    {
        sum = 0.0;
        for(j = 0; j < 10; j ++)
        {
            sum += errorJCN_GRAPH[1][j][k];
        }
        fprintf(Report, "%e\n", sum/10.0);
    }
    fprintf(Report, "(THE NEAREST RIGHT POINT):\n");
    for(k = 0; k < 48; k++)
    {
        sum = 0.0;
        for(j = 0; j < 10; j ++)
        {
            sum += errorJCN_GRAPH[2][j][k];
        }
        fprintf(Report, "%e\n", sum/10.0);
    }
    /**/
    
    ///////////////////////////////////////////////////////////////////////////
    //J:C:M
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: CM\n");
    fprintf(Report, "(Between nulls)\n");
    for(n = 0; n < 10; n++)
    {
        JC = create_List(&type_Unifloat);
        ReadFromFileBessel(pathJCM[n], JC);
        for (j = 0; j < size_List(JC); j++)
        {
            x = (Unifloat*)get_List(JC, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context, 
                         two_power(n + 4), 
                         round_Unifloat(x, leng_num[1]), 
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJCM_ALL[n][ulp]++;
            errorJCM_GRAPH[n][(int)(j/3)] += ulp;
        }
    }

    ///////AVERAGE ERROR
    fprintf(Report, "\nAVERAGE ERROR:\n");
    for(j = 0; j < 10; j ++)
    {
        AvrUlp = 0;
        for(i = 0; i < 54; i++)
        {
            AvrUlp += i*errorJCN_ALL[j][i];
        }
        fprintf(Report, "%e\n", AvrUlp/144);
    }
    ///////HISTOGRAM
    fprintf(Report, "\nHISTOGRAM:\n");
    for(j = 0; j < 10; j ++)
    {
        fprintf(Report, "INDEX=2^(%d)\n", j + 4);
        for(i = 0; i < 54; i++)
        {
                fprintf(Report, "%d\n", errorJCM_ALL[j][i]);
        }
    }
    ///////AVERAGE HISTOGRAM
    fprintf(Report, "\nAVERAGE HISTOGRAM:\n");
    for(i = 0; i < 54; i++)
    {
        sum = 0.0;
        for(j = 0; j < 10; j ++)
        {
            sum += errorJCM_ALL[j][i];
        }
        fprintf(Report, "%e\n", sum);
    }

    ///////DEPENDENCE OF ERROR FROM NUMBER OF NULL
    fprintf(Report, "\nDEPENDENCE OF ERROR FROM NUMBER OF NULL:\n");
    for(j = 0; j < 10; j++)
    {
        fprintf(Report, "index = %d\n", j + 4);
        for(k = 0; k < 48; k++)
        {
            fprintf(Report, "%e\n", errorJCM_GRAPH[j][k]/3);
        }
    }

    ///////AVERAGE DEPENDENCE OF ERROR FROM NUMBER OF NULL
    fprintf(Report, "\nAVERAGE DEPENDENCE OF ERROR FROM NUMBER OF NULL:\n");
    for(k = 0; k < 48; k++)
    {
        sum = 0.0;
        for(j = 0; j < 10; j ++)
        {
            sum += errorJCM_GRAPH[j][k];
        }
        fprintf(Report, "%e\n", sum/30.0);
    }
    /**/
    
    ///////////////////////////////////////////////////////////////////////////
    //J:C:M:DEPEND
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: CM\n");
    fprintf(Report, "(Between 1st and 2nd nulls for different index)\n");
    JC = create_List(&type_Unifloat);
    ReadFromFileBessel("src/testdata/math.bessel/Points/C/JC/JCDEPEND/JCDEPENDM.txt", JC);
    for (j = 0; j < size_List(JC); j++)
    {
        x = (Unifloat*)get_List(JC, j);
        x->type=UniDoubleT;
        y1 = jn_spec(context, 
                     two_power((int)(j/15)), 
                     round_Unifloat(x, leng_num[1]), 
                     round_mode,
                     &ulp,
                     requestErrorCode()
                     );
        errorJCM_DEPEND[(int)(j/15)] += ulp;
    }

    ///////AVERAGE DEPENDENCE OF ERROR FROM INDEX
    fprintf(Report, "\nAVERAGE DEPENDENCE OF AVERAGE ERROR FROM INDEX:\n");
    for(j = 0; j < 14; j++)
    {
        fprintf(Report, "%e\n", errorJCM_DEPEND[j]/15);
    }
    /**/

    ///////////////////////////////////////////////////////////////////////////
    //J:C:N:DEPEND
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: CN\n");
    fprintf(Report, "(beside 1st null for different index)\n");
    JC = create_List(&type_Unifloat);
    ReadFromFileBessel("src/testdata/math.bessel/Points/C/JC/JCDEPEND/JCDEPENDN.txt", JC);
    for (j = 0; j < size_List(JC); j++)
    {
        x = (Unifloat*)get_List(JC, j);
        x->type=UniDoubleT;
        y1 = jn_spec(context, 
                     two_power((int)(j/3)), 
                     round_Unifloat(x, leng_num[1]), 
                     round_mode,
                     &ulp,
                     requestErrorCode()
                     );
        errorJCN_DEPEND[j%3][(int)(j/3)] += ulp;
    }

    ///////AVERAGE DEPENDENCE OF ERROR FROM INDEX
    fprintf(Report, "\nAVERAGE DEPENDENCE OF AVERAGE ERROR FROM INDEX:\n");

    fprintf(Report, "LEFT POINT\n");
    for(j = 0; j < 14; j++)
    {
        fprintf(Report, "%e\n", errorJCN_DEPEND[0][j]);
    }
    fprintf(Report, "NULL POINT\n");
    for(j = 0; j < 14; j++)
    {
        fprintf(Report, "%e\n", errorJCN_DEPEND[1][j]);
    }
    fprintf(Report, "RIGHT POINT\n");
    for(j = 0; j < 14; j++)
    {
        fprintf(Report, "%e\n", errorJCN_DEPEND[2][j]);
    }
    /**/
    
    ///////////////////////////////////////////////////////////////////////////
    //J:C:COMPL
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: JC\n");
    fprintf(Report, "(Beside first extremum)\n");
    JC = create_List(&type_Unifloat);
    ReadFromFileBessel("src/testdata/math.bessel/Points/C/JC/JCCOMPL/JCCOMPL.txt", JC);
    for (j = 0; j < size_List(JC); j++)
    {
        x = (Unifloat*)get_List(JC, j);
        x->type=UniDoubleT;
        y1 = jn_spec(context, 
                     two_power((int)(j/1023)), 
                     round_Unifloat(x, leng_num[1]), 
                     round_mode,
                     &ulp,
                     requestErrorCode()
                     );
        if(j%1023 == 0)fprintf(Report, "INDEX=2^(%d)\n", (int)(j/1023));
        fprintf(Report, "%d\n", ulp);
        errorJCCOMPL_DEPEND[(int)(j/1023)] += ulp;
    }

    ///////AVERAGE DEPENDENCE OF ERROR FROM INDEX
    fprintf(Report, "\nAVERAGE DEPENDENCE OF AVERAGE ERROR FROM INDEX:\n");
    for(j = 0; j < 14; j++)
    {
        fprintf(Report, "%e\n", errorJCCOMPL_DEPEND[j]/1023);
    }
    /**/

    ///////////////////////////////////////////////////////////////////////////
    //J:B:REST
    ///////////////////////////////////////////////////////////////////////////
    /*/
    fprintf(Report, "SUB AREA: BR\n");
    for(n = 0; n < 1; n++)
    {
        JB = create_List(&type_Unifloat);
        ReadFromFileBessel("src/testdata/math.bessel/Points/B/JB/JBREST/JBREST.txt", JB);
        for (j = 0; j < size_List(JB); j++)
        {
            x = (Unifloat*)get_List(JB, j);
            x->type=UniDoubleT;
            y1 = jn_spec(context, 
                         n, 
                         round_Unifloat(x, leng_num[1]), 
                         round_mode,
                         &ulp,
                         requestErrorCode()
                         );
            errorJBM_REST[j] = (DoubleT)ulp;
        }
    }

    ///////DEPENDENCE OF ERROR FROM LOG[2](x)
    fprintf(Report, "\nDEPENDENCE OF ERROR FROM LOG[2](x):\n");
    fprintf(Report, "\n(average by the index from 0 to 10)\n");
    for(i = 0; i < 1001; i++)
    {
            fprintf(Report, "%e\n", errorJBM_REST[i]);
    }
    /**/
    }
    fclose(Report);
    return true;
}

scenario bool besselY_scen()
{
    return true;    
}


scenario bool j0_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[7] = { 
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("100000000"), type),
            clone(Nan[type]),
            clone(Almost_Zero[type])
            };
        x[1]->sign = -1;
        for(i = 0; i < 7; i++)
                j0_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                        requestErrorCode());
    }
    return true;    
}

scenario bool j1_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[7] = { 
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("100000000"), type),
            clone(Nan[type]),
            clone(Almost_Zero[type])
            };
        x[1]->sign = -1;
        for(i = 0; i < 7; i++)
                j1_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                        requestErrorCode());
    }
    return true;    
}

scenario bool jn_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i;
    IntT ulp = 0;
    IntT round_mode = 1;
    
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[14] = {
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("10000000"), type),
            convertString_Unifloat(create_CString("10000000"), type),
            convertString_Unifloat(create_CString("-10000001"), type),
            convertString_Unifloat(create_CString("-10000001"), type),
            convertString_Unifloat(create_CString("100"), type),
            clone(Nan[type]),
            clone(Almost_Zero[type])
            };
        IntT n[14] = {
            (IntT)3,
            (IntT)3,
            (IntT)2,
            (IntT)2,
            (IntT)0,
            (IntT)1,
            (IntT)-1,
            (IntT)1000,
            (IntT)-1000,
            (IntT)1000,
            (IntT)-1000,
            (IntT)1000,
            (IntT)100,
            (IntT)10
            };
        x[1]->sign = -1;
        x[3]->sign = -1;
        for(i = 0; i < 14; i++)
                jn_spec(context, n[i], 
                        round_Unifloat(x[i], leng_num[type]),
                        round_mode,
                        &ulp,
                        requestErrorCode());
    }

    return true;    
}

scenario bool y0_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    UnifloatType type;
    int i;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[7] = { 
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("100000000"), type),
            clone(Nan[type]),
            clone(Almost_Zero[type])
            };
        x[2]->sign = -1;
        for(i = 0; i < 7; i++)
                y0_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                        requestErrorCode());
    }
    return true;    
}

scenario bool y1_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    UnifloatType type;
    int i;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[7] = { 
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("10"), type),
            convertString_Unifloat(create_CString("100000000"), type),
            clone(Nan[type]),
            clone(Almost_Zero[type])
            };
        x[2]->sign = -1;
        for(i = 0; i < 7; i++)
                y1_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                        requestErrorCode());
    }
    return true;    
}

scenario bool yn_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    UnifloatType type;
    IntT ulp = 0;
    IntT round_mode = 1;
    int i;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[6] = { 
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("1"), type),
            convertString_Unifloat(create_CString("10000000"), type),
            convertString_Unifloat(create_CString("100"), type),
            clone(Nan[type]),
            clone(Almost_Zero[type])
            };
        IntT n[6] = {
            (IntT)100,
            (IntT)100,
            (IntT)1000,
            (IntT)1000,
            (IntT)100,
            (IntT)10
            };
        x[1]->sign = -1;
        for(i = 0; i < 6; i++)
                yn_spec(context, n[i], 
                        round_Unifloat(x[i], leng_num[type]),
                        round_mode,
                        &ulp,
                        requestErrorCode());
    }
    return true;    
}
/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm math_bessel_scenario =
{
    .init = init_math_bessel_scenario,
    .finish = finish_math_bessel_scenario,
    .actions = { 
//                    besselJ_scen,
//                    besselY_scen,
                    j0_scen,
                    j1_scen,
                    jn_scen,
                    y0_scen,
                    y1_scen,
                    yn_scen,
                    NULL 
                }
};

bool main_math_bessel(int argc, char** argv)
{
    math_bessel_scenario(argc,argv);
    return true;
}

#include "math/bessel/tests/bessel_scenario.seh"
#include "math/math/math_data.seh"

#ifdef MATH_BESSEL_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "math/bessel/bessel_media.seh"
#include "math/bessel/bessel_model.seh"
#include "math/math/math_data.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();
    initMath();

    initMathBesselSubsystem();
}

#ifdef WIN32

int main(int argc, char** argv)
{
    clock_t start, finish;
    double duration;

    initTestSystem();
    
    loadSUT();
    
    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");

    start = clock();

    main_math_bessel(argc,argv);
    

    finish = clock();
    duration = (double) (finish - start) / CLOCKS_PER_SEC;

    verbose( "%2.3f seconds\n", duration );
    
    
    
    //  unloadSUT();
    return 0;
}

#else

int main(int argc, char** argv)
{
    initTestSystem();
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");
    main_math_bessel(argc,argv);

    //  unloadSUT();
    return 0;
}

#endif

#endif
