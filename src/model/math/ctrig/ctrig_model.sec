/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "math/ctrig/ctrig_model.seh"
#include "math/math/math_data.seh"
#include "math/math/math_config.h"


#pragma SEC subsystem ctrig "math.ctrig"



/* 
   The group of functions 'math.ctrig' consists of: 
       cacos [2]
       cacosf [2]
       cacosl [2]
       casin [2]
       casinf [2]
       casinl [2]
       catan [2]
       catanf [2]
       catanl [2]
       ccos [2]
       ccosf [2]
       ccosl [2]
       csin [2]
       csinf [2]
       csinl [2]
       ctan [2]
       ctanf [2]
       ctanl [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    cacos, cacosf, cacosl - complex arc cosine functions

SYNOPSIS

    #include <complex.h>

    double complex cacos(double complex z);

    float complex cacosf(float complex z);

    long double complex cacosl(long double complex z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the complex arc cosine of z, with
    branch cuts outside the interval [-1, +1] along the real axis.

RETURN VALUE

    These functions shall return the complex arc cosine value, in the range of a
    strip mathematically unbounded along the imaginary axis and in the interval [0,
    ] along the real axis.

ERRORS

    No errors are defined.
*/

//This specification refers to: cacosf, cacos, cacosl
specification
UnifloatComplex* cacos_spec(CallContext context, UnifloatComplex* x)
{
    char type[3][10] = {"cacosf", "cacos", "cacosl"};
    
    FILTER(type[x->Im->type]);

    pre
    {
        /*[Input argument should be not NULL]*/
        REQ("", "Argument isn't Null", x != NULL);

        /*[Real and Imag part of input arguments should be not NULL]*/
        REQ("", "Argument isn't Null", (x->Im != NULL) && (x->Re != NULL));

        /*[Image and Real parts of input argument should have the same type]*/
        REQ("", "Im and Re has the same type", x->Im->type == x->Re->type);

        return true;
    }
    coverage C
    {
        if ((x->Im->kind == NaN) || (x->Re->kind == NaN))
            return {NaN_ARG, "Some part of argument is NaN"};
        else
            if ((x->Im->kind == Infinity) || (x->Re->kind == Infinity))
                return {INF_ARG, "some part of argument is infinity"};
            else
                return {NORMAL_ARG, "all parts of argument are normal"};
    }
    post
    {
        int type = x->Im->type;
        int mant = digMant_Unifloat(type);
        UnifloatComplex* model_res = cacos_model(x);
        Unifloat* PiFour = div_Unifloat(Pi[type], convertInteger_Unifloat(4, type));
        Unifloat* ThreePiFour = mul_Unifloat(PiFour, convertInteger_Unifloat(3, type));
        Unifloat* PiTwo = div_Unifloat(Pi[type], convertInteger_Unifloat(2, type));

        round_Unifloat(model_res->Re, mant);
        round_Unifloat(model_res->Im, mant);

        if (CHECK_EXTENDED_REQ)
            if (x->Im->sign == 1)
        {
            if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
            {
                /*
                 * cacos(±0 + i * 0) returns Pi/2 - i * 0.
                 */
                REQ("cacos.ext.04;cacosf.ext.04;cacosl.ext.04", 
                    "cacos(±0 + i * 0) returns Pi/2 - i * 0",
                    (compareWithPrecision_Unifloat(cacos_spec->Re, PiTwo, mant) == 0) &&
                    isZero_Unifloat(cacos_spec->Im) && (cacos_spec->Im->sign == -1));
            }

            if (isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            {
                /*
                 * cacos(±0 + i * NaN ) returns Pi/2 + i * NaN.
                 */
                REQ("cacos.ext.05;cacosf.ext.05;cacosl.ext.05", 
                    "cacos(±0 + i * NaN ) returns Pi/2 + i * NaN",
                    (compareWithPrecision_Unifloat(cacos_spec->Re, PiTwo, mant) == 0) &&
                    isNan_Unifloat(cacos_spec->Im));
            }

            if (isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            {
                /*
                 * cacos(x + i * Inf) returns Pi/2 - i * Inf, for finite x.
                 */
                REQ("cacos.ext.06;cacosf.ext.06;cacosl.ext.06", 
                    "cacos(x + i * Inf) returns Pi/2 - i * Inf, for finite x",
                    (compareWithPrecision_Unifloat(cacos_spec->Re, PiTwo, mant) == 0) &&
                    isInfinity_Unifloat(cacos_spec->Im) && (cacos_spec->Im->sign == -1));
            }

            if (isNormal_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            {
                /*
                 * cacos(x + i * NaN) returns NaN + i * NaN and optionally raises the "invalid"
                 * floating-point exception, for nonzero finite x.
                 */
                REQ("cacos.ext.07;cacosf.ext.07;cacosl.ext.07",
                    "cacos(x + i * NaN) returns NaN + i * NaN",
                    isNan_Unifloat(cacos_spec->Re) && isNan_Unifloat(cacos_spec->Im));
            }

            if (isInfinity_Unifloat(x->Re) && (x->Re->sign == -1) && isNormal_Unifloat(x->Im) & (x->Im->sign = 1))
            {
                /*
                 * cacos(-Inf + i * y) returns Pi - i * Inf, for positive-signed finite y.
                 */
                REQ("cacos.ext.08;cacosf.ext.08;cacosl.ext.08", 
                    "cacos(-Inf + i * y) returns Pi - i * Inf, for positive-signed finite y",
                    (compareWithPrecision_Unifloat(cacos_spec->Re, Pi[type], mant) == 0) &&
                    isInfinity_Unifloat(cacos_spec->Im) && (cacos_spec->Im->sign == -1));
            }

            if (isInfinity_Unifloat(x->Re) && (x->Re->sign == 1) && isNormal_Unifloat(x->Im) && (x->Im->sign == 1))
            {
                /*
                 * cacos(+Inf + i * y) returns +0 - i * Inf, for positive-signed finite y.
                 */
                REQ("cacos.ext.09;cacosf.ext.09;cacosl.ext.09", 
                    "cacos(+Inf + i * y) returns +0 - i * Inf, for positive-signed finite y",
                    isZero_Unifloat(cacos_spec->Re) && (cacos_spec->Re->sign == 1) &&
                    isInfinity_Unifloat(cacos_spec->Im) && (cacos_spec->Im->sign == -1));
            }

            if (isInfinity_Unifloat(x->Re) && (x->Re->sign == -1) && isInfinity_Unifloat(x->Im))
            {
                /*
                 * cacos(-Inf + i * Inf) returns 3*Pi/4 - i * Inf.
                 */
                REQ("cacos.ext.10;cacosf.ext.10;cacosl.ext.10", 
                    "cacos(-Inf + i * Inf) returns 3*Pi/4 - i * Inf",
                    (compareWithPrecision_Unifloat(cacos_spec->Re, ThreePiFour, mant) == 0) &&
                    isInfinity_Unifloat(cacos_spec->Im) && (cacos_spec->Im->sign == -1));
            }

            if (isInfinity_Unifloat(x->Re) && (x->Re->sign == 1) && isInfinity_Unifloat(x->Im))
            {
                /*
                 * cacos(+Inf + i * Inf) returns Pi/4 - i * Inf.
                 */
                REQ("cacos.ext.11;cacosf.ext.11;cacosl.ext.11", 
                    "cacos(+Inf + i * Inf) returns Pi/4 - i * Inf",
                    (compareWithPrecision_Unifloat(cacos_spec->Re, PiFour, mant) == 0) && 
                    isInfinity_Unifloat(cacos_spec->Im) && (cacos_spec->Im->sign == -1));
            }

            if (isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            {
                /*
                 * cacos(±Inf + i * NaN) returns NaN ± i * Inf (where the sign of the imaginary
                 * part of the result is unspecified).
                 */
                REQ("cacos.ext.12;cacosf.ext.12;cacosl.ext.12", 
                    "cacos(±Inf + i * NaN) returns NaN ± i * Inf",
                    isNan_Unifloat(cacos_spec->Re) && isInfinity_Unifloat(cacos_spec->Im));
            }

            if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
            {
                /*
                 * cacos(NaN + i * y) returns NaN + i * NaN and optionally raises the "invalid"
                 * floating-point exception, for finite y.
                 */
                REQ("cacos.ext.13;cacosf.ext.13;cacosl.ext.13",
                    "cacos(NaN + i * y) returns NaN + i * NaN",
                    isNan_Unifloat(cacos_spec->Re) && isNan_Unifloat(cacos_spec->Im));
            }

            if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
            {
                /*
                 * cacos(NaN + i * Inf) returns NaN - i * Inf.
                 */
                REQ("cacos.ext.14;cacosf.ext.14;cacosl.ext.14", 
                    "cacos(NaN + i * Inf) returns NaN - i * Inf",
                    isNan_Unifloat(cacos_spec->Re) && isInfinity_Unifloat(cacos_spec->Im) &&
                    (cacos_spec->Im->sign == -1));
            }

            if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
            {
                /*
                 * cacos(NaN + i * NaN) returns NaN + i * NaN.
                 */
                REQ("cacos.ext.15;cacosf.ext.15;cacosl.ext.15", 
                    "cacos(NaN + i * NaN) returns NaN + i * NaN",
                    isNan_Unifloat(cacos_spec->Re) && isNan_Unifloat(cacos_spec->Im));
            }
        }

        /*
         * These functions shall return the complex arc cosine value, in 
         * the range of a strip mathematically unbounded along the imaginary
         * axis and in the interval [0, Pi] along the real axis.
         */
        REQ("cacos.02;cacosf.02;cacosl.02", 
            "Result should be in defined interval",
            (compare_Unifloat(cacos_spec->Re, createZero_Unifloat(type)) != -1)
            && (compareWithPrecision_Unifloat(cacos_spec->Re, Pi[type], mant) != 1));        

        /*
         * These functions shall compute the complex arc cosine of z, with 
         * branch cuts outside the interval [-1, +1] along the real axis.
         */
        REQ("cacos.01;cacosf.01;cacosl.01", 
            "It should compute the complex arc cosine", 
            compareWithPrecision_UnifloatComplex(model_res, cacos_spec, mant) == 0);

        return true;
    }
    FILTER_CLEAN;
}

UnifloatComplex* cacos_model(UnifloatComplex* x)
{
    UnifloatComplex* tmp1, *tmp2;
    UnifloatComplex* res = clone(x);
    UnifloatType type = x->Re->type;
    UnifloatComplex* I = create_UnifloatComplex(createZero_Unifloat(type), createOne_Unifloat(type));
    Unifloat* PiFour = div_Unifloat(Pi[type], convertInteger_Unifloat(4, type));
    Unifloat* ThreePiFour = mul_Unifloat(PiFour, convertInteger_Unifloat(3, type));
    Unifloat* PiTwo = div_Unifloat(Pi[type], convertInteger_Unifloat(2, type));

    if (x->Im->sign == -1)
    {
        x->Im->sign = 1;
        res = cacos_model(x);
        x->Im->sign = -1;
        res->Im->sign = (-1)* res->Im->sign;
        return res;
    }

    if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(PiTwo), createZero_Unifloat(type));
        res->Im->sign = -1;
        return res;
    }

    if (isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(PiTwo), clone(nan_Unifloat(type)));
        return res;
    }

    if (isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(PiTwo), clone(infinity_Unifloat(type)));
        res->Im->sign = -1;
        return res;
    }

    if (isNormal_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(nan_Unifloat(type)), clone(nan_Unifloat(type)));
        return res;
    }

    if (isInfinity_Unifloat(x->Re) && (x->Re->sign == -1) && isNormal_Unifloat(x->Im) && (x->Im->sign == 1))
    {
        res = create_UnifloatComplex(clone(Pi[type]), clone(infinity_Unifloat(type)));
        res->Im->sign = -1;
        return res;
    }

    if (isInfinity_Unifloat(x->Re) && (x->Re->sign == 1) && isNormal_Unifloat(x->Im) && (x->Im->sign == 1))
    {
        res = create_UnifloatComplex(createZero_Unifloat(type), clone(infinity_Unifloat(type)));
        res->Im->sign = -1;
        return res;
    }

    if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im) && (x->Re->sign == -1))
    {
        res = create_UnifloatComplex(clone(ThreePiFour), clone(infinity_Unifloat(type)));
        res->Im->sign = -1;
        return res;
    }

    if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im) && (x->Re->sign == 1))
    {
        res = create_UnifloatComplex(clone(PiFour), clone(infinity_Unifloat(type)));
        res->Im->sign = -1;
        return res;
    }

    if (isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(nan_Unifloat(type)), clone(infinity_Unifloat(type)));
        res->Im->sign = (-1) * x->Im->sign;
        return res;
    }

    if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(nan_Unifloat(type)), clone(nan_Unifloat(type)));
        return res;
    }

    if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(nan_Unifloat(type)), clone(infinity_Unifloat(type)));
        res->Im->sign = -1;
        return res;
    }

    if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
    {
        res = create_UnifloatComplex(clone(nan_Unifloat(type)), clone(nan_Unifloat(type)));
        return res;
    }

    tmp1 = mul_UnifloatComplex(x, x);
    tmp1->Re = sub_Unifloat(tmp1->Re, createOne_Unifloat(type));

    tmp2 = add_UnifloatComplex(csqrt_Unifloat(tmp1), x);

    res = mul_UnifloatComplex(I, clog_Unifloat(tmp2));
    if (res->Re->sign < 0)
    {
        res->Re->sign = (-1)*res->Re->sign;
        res->Im->sign = (-1)*res->Im->sign;
    }

    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    casin, casinf, casinl - complex arc sine functions

SYNOPSIS

    #include <complex.h>

    double complex casin(double complex z);

    float complex casinf(float complex z);

    long double complex casinl(long double complex z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the complex arc sine of z, with
    branch cuts outside the interval [-1, +1] along the real axis.

RETURN VALUE

    These functions shall return the complex arc sine value, in the range of a
    strip mathematically unbounded along the imaginary axis and in the interval [-/
    2, +/2] along the real axis.

ERRORS

    No errors are defined.
*/

//This specification refers to: casinf, casin, casinl
specification
UnifloatComplex* casin_spec(CallContext context, UnifloatComplex* x)
{
    char type[3][10] = {"casinf", "casin", "casinl"};
    
    FILTER(type[x->Im->type]);

    pre
    {
        /*[Input argument should be not NULL]*/
        REQ("", "Argument isn't Null", x != NULL);

        /*[Real and Imag part of input arguments should be not NULL]*/
        REQ("", "Argument isn't Null", (x->Im != NULL) && (x->Re != NULL));

        /*[Image and Real parts of input argument should have the same type]*/
        REQ("", "Im and Re has the same type", x->Im->type == x->Re->type);

        return true;
    }
    coverage C
    {
        if ((x->Im->kind == NaN) || (x->Re->kind == NaN))
            return {NaN_ARG, "Some part of argument is NaN"};
        else
            if ((x->Im->kind == Infinity) || (x->Re->kind == Infinity))
                return {INF_ARG, "some part of argument is infinity"};
            else
                return {NORMAL_ARG, "all parts of argument are normal"};
    }
    post
    {
        int type = x->Im->type;
        int mant = digMant_Unifloat(type);
        Unifloat* PiFour = div_Unifloat(Pi[type], convertInteger_Unifloat(4, type));
        Unifloat* PiTwo = div_Unifloat(Pi[type], convertInteger_Unifloat(2, type));
        Unifloat* Neg_PiTwo = clone(PiTwo);
        UnifloatComplex* model_res = casin_model(x);
        Neg_PiTwo->sign = -1;

        round_Unifloat(model_res->Re, mant);
        round_Unifloat(model_res->Im, mant);

        if (CHECK_EXTENDED_REQ)
        {
            if ((x->Re->sign == 1) && (x->Im->sign == 1))
            {
                if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * casin(+0 + i * 0) returns +0 + i * 0.
                     */
                    REQ("casin.ext.06;casinf.ext.06;casinl.ext.06",
                        "casin(+0 + i * 0) returns 0 + i * 0", 
                        isZero_Unifloat(casin_spec->Re) && isZero_Unifloat(casin_spec->Im) &&
                        (casin_spec->Re->sign == 1));
                }

                if (isZero_Unifloat(x->Re) && (isNan_Unifloat(x->Im)))
                {
                    /*
                     * casin(0 + i * NaN) returns +0 + i * NaN.
                     */
                    REQ("casin.ext.07;casinf.ext.07;casinl.ext.07",
                        "casin(0 + i * NaN) returns 0 + i * NaN", 
                        isZero_Unifloat(casin_spec->Re) && isNan_Unifloat(casin_spec->Im) &&
                        (casin_spec->Re->sign == 1));
                }

                if (isZero_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * casin(x + i * Inf) returns +0 + i * Inf for positive-signed finite x.
                     */
                    REQ("casin.ext.08;casinf.ext.08;casinl.ext.08", 
                        "casin(x + i * Inf) returns +0 + i * Inf",
                        isZero_Unifloat(casin_spec->Re) && (casin_spec->Re->sign == 1) &&
                        isInfinity_Unifloat(casin_spec->Im));
                }

                if (isNormal_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * casin(x + i * NaN) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for finite nonzero x.
                     */
                    REQ("casin.ext.09;casinf.ext.09;casinl.ext.09",
                        "casin(x + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(casin_spec->Re) && isNan_Unifloat(casin_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
                {
                    /*
                     * casin(+Inf + i * y) returns Pi/2 + i * Inf for positive-signed finite y.
                     */
                    REQ("casin.ext.10;casinf.ext.10;casinl.ext.10", 
                        "casin(+Inf + i * y) returns Pi/2 + i * Inf",
                        (compareWithPrecision_Unifloat(casin_spec->Re, PiTwo, mant) == 0) &&
                        isInfinity_Unifloat(casin_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * casin(+Inf + i * Inf) returns Pi/4 + i * Inf.
                     */
                    REQ("casin.ext.11;casinf.ext.11;casinl.ext.11", 
                        "casin(+Inf + i * Inf) returns Pi/4 + i * Inf.",
                        (compareWithPrecision_Unifloat(casin_spec->Re, PiFour, mant) == 0) &&
                        isInfinity_Unifloat(casin_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * casin(+Inf + i * NaN) returns NaN ± i * Inf (where the sign of the imaginary
                     * part of the result is unspecified).
                     */
                    REQ("casin.ext.12;casinf.ext.12;casinl.ext.12", 
                        "casin(+Inf + i * NaN) returns NaN ± i * Inf",
                        isNan_Unifloat(casin_spec->Re) && isInfinity_Unifloat(casin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
                {
                    /*
                     * casin(NaN + i * y) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for finite y.
                     */
                    REQ("casin.ext.13;casinf.ext.13;casinl.ext.13", 
                        "casin(NaN + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(casin_spec->Re) && isNan_Unifloat(casin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * casin(NaN + i * Inf) returns NaN + i * Inf.
                     */
                    REQ("casin.ext.14;casinf.ext.14;casinl.ext.14",
                        "casin(NaN + i * Inf) returns NaN + i * Inf",
                        isNan_Unifloat(casin_spec->Re) && isInfinity_Unifloat(casin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * casin(NaN + i * NaN) returns NaN + i * NaN.
                     */
                    REQ("casin.ext.15;casinf.ext.15;casinl.ext.15", 
                        "casin(NaN + i * NaN) returns NaN + i * NaN", 
                        isNan_Unifloat(casin_spec->Re) && isNan_Unifloat(casin_spec->Im));
                }
            }
            /*
             * casin(z) = -i * casinh(iz).
             */
            REQ("casin.ext.03;casinf.ext.03;casinl.ext.03", 
                "casin(z) = -i * casinh(iz)", 
                compareWithPrecision_UnifloatComplex(model_res, casin_spec, mant) == 0);
        }


        /*
         * These functions shall return the complex arc sine value, in the 
         * range of a strip mathematically unbounded along the imaginary axis 
         * and in the interval [-Pi/2, +Pi/2] along the real axis.
         */
        REQ("casin.02;casinf.02;casinl.02", 
            "Result should be in defined interval",
            (compareWithPrecision_Unifloat(casin_spec->Re, Neg_PiTwo, mant) != -1) &&
            (compareWithPrecision_Unifloat(casin_spec->Re, PiTwo, mant) != 1));

        /*
         * These functions shall compute the complex arc sine of z, with 
         * branch cuts outside the interval [-1, +1] along the real axis.
         */
        REQ("casin.01;casinf.01;casinl.01", 
            "It should compute the complex arc sine",
            compareWithPrecision_UnifloatComplex(model_res, casin_spec, mant) == 0);
       
        return true;
    }
    FILTER_CLEAN;
}

UnifloatComplex* casin_model(UnifloatComplex* x)
{
    UnifloatComplex* tmp1;
    UnifloatComplex* res;
    UnifloatComplex* arg;
    UnifloatType type = x->Re->type;

    arg = create_UnifloatComplex(x->Im, x->Re);
    tmp1 = casinh_model(arg);
    res = create_UnifloatComplex(tmp1->Im, tmp1->Re);

    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    catan, catanf, catanl - complex arc tangent functions

SYNOPSIS

    #include <complex.h>

    double complex catan(double complex z);

    float complex catanf(float complex z);

    long double complex catanl(long double complex z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the complex arc tangent of z,
    with branch cuts outside the interval [-i, +i] along the imaginary axis.

RETURN VALUE

    These functions shall return the complex arc tangent value, in the range of a
    strip mathematically unbounded along the imaginary axis and in the interval [-/
    2, +/2] along the real axis.

ERRORS

    No errors are defined.
*/

//This specification refers to: catanf, catan, catanl
specification
UnifloatComplex* catan_spec(CallContext context, UnifloatComplex* x)
{
    char type[3][10] = {"catanf", "catan", "catanl"};
    
    FILTER(type[x->Im->type]);

    pre
    {
        /*[Input argument should be not NULL]*/
        REQ("", "Argument isn't Null", x != NULL);

        /*[Real and Imag part of input arguments should be not NULL]*/
        REQ("", "Argument isn't Null", (x->Im != NULL) && (x->Re != NULL));

        /*[Image and Real parts of input argument should have the same type]*/
        REQ("", "Im and Re has the same type", x->Im->type == x->Re->type);

        return true;
    }
    coverage C
    {
        if ((x->Im->kind == NaN) || (x->Re->kind == NaN))
            return {NaN_ARG, "Some part of argument is NaN"};
        else
            if ((x->Im->kind == Infinity) || (x->Re->kind == Infinity))
                return {INF_ARG, "some part of argument is infinity"};
            else
                return {NORMAL_ARG, "all parts of argument are normal"};
    }
    post
    {
        int type = x->Im->type;
        int mant = digMant_Unifloat(type);
        Unifloat* PiTwo = div_Unifloat(Pi[type], convertInteger_Unifloat(2, type));
        Unifloat* Neg_PiTwo = clone(PiTwo);
        UnifloatComplex* model_res = catan_model(x);
        Unifloat* One = createOne_Unifloat(type);
        Neg_PiTwo->sign = -1;

        round_Unifloat(model_res->Re, mant);
        round_Unifloat(model_res->Im, mant);
     
        if (CHECK_EXTENDED_REQ)
        {
            if ((x->Re->sign == 1) && (x->Im->sign == 1))
            {
                if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * catan(+0 + i * 0) returns +0 + i * 0.
                     */
                    REQ("catan.ext.06;catanf.ext.06;catanl.ext.06",
                        "catan(+0 + i * 0) returns +0 + i * 0",
                        isZero_Unifloat(catan_spec->Re) && (catan_spec->Re->sign == 1) &&
                        isZero_Unifloat(catan_spec->Im));
                }

                if (isZero_Unifloat(x->Re) && (compare_Unifloat(x->Im, One) == 0))
                {
                    /*
                     * catan(+0 + i * 1) returns +0 + i * Inf and raises the "divide-by-zero" floating-
                     * point exception.
                     */
                    REQ("catan.ext.07;catanf.ext.07;catanl.ext.07",
                        "catan(+0 + i * 1) returns +0 + i * Inf",
                        isZero_Unifloat(catan_spec->Re) && (catan_spec->Re->sign == 1)
                        && isInfinity_Unifloat(catan_spec->Im));
                }

                if (isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * catan(x + i * Inf) returns Pi/2 + i * 0, for finite positive-signed x.
                     */
                    REQ("catan.ext.08;catanf.ext.08;catanl.ext.08", 
                        "catan(x + i * Inf) returns Pi/2 + i * 0",
                        (compareWithPrecision_Unifloat(catan_spec->Re, PiTwo, mant) == 0) &&
                        isZero_Unifloat(catan_spec->Im));
                }

                if (isNormal_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * catan(x + i * NaN) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for finite x.
                     */
                    REQ("catan.ext.09;catanf.ext.09;catanl.ext.09",
                        "catan(x + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(catan_spec->Re) && isNan_Unifloat(catan_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
                {
                    /*
                     * catan(+Inf + i * y) returns Pi/2 + i * 0, for finite positive-signed y.
                     */
                    REQ("catan.ext.10;catanf.ext.10;catanl.ext.10", 
                        "catan(+Inf + i * y) returns Pi/2 + i * 0",
                        (compareWithPrecision_Unifloat(catan_spec->Re, PiTwo, mant) == 0) &&
                        isZero_Unifloat(catan_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * catan(+Inf + i * Inf) returns Pi/2 + i * 0.
                     */
                    REQ("catan.ext.11;catanf.ext.11;catanl.ext.11",
                        "catan(+Inf + i * Inf) returns Pi/2 + i * 0",
                        (compareWithPrecision_Unifloat(catan_spec->Re, PiTwo, mant) == 0) &&
                        isZero_Unifloat(catan_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * catan(+Inf + i * NaN) returns Pi/2 ± i * 0 (where the sign of the imaginary part
                     * of the result is unspecified).
                     */
                    REQ("catan.ext.12;catanf.ext.12;catanl.ext.12", 
                        "catan(+Inf + i * NaN) returns Pi/2 ± i * 0",
                        (compareWithPrecision_Unifloat(catan_spec->Re, PiTwo, mant) == 0) &&
                        isZero_Unifloat(catan_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * catan(NaN + i * 0) returns NaN + i * 0.
                     */
                    REQ("catan.ext.13;catanf.ext.13;catanl.ext.13",
                        "catan(NaN + i * 0) returns NaN + i * 0",
                        isNan_Unifloat(catan_spec->Re) && isZero_Unifloat(catan_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im) && !isZero_Unifloat(x->Im))
                {
                    /*
                     * catan(NaN + i * y) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for nonzero finite y.
                     */
                    REQ("catan.ext.14;catanf.ext.14;catanl.ext.14",
                        "catan(NaN + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(catan_spec->Re) && isNan_Unifloat(catan_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * catan(NaN + i * Inf) returns NaN + i * 0.
                     */
                    REQ("catan.ext.15;catanf.ext.15;catanl.ext.15",
                        "catan(NaN + i * Inf) returns NaN + i * 0",
                        isNan_Unifloat(catan_spec->Re) && isZero_Unifloat(catan_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * catan(NaN + i * NaN) returns NaN + i * NaN.
                     */
                    REQ("catan.ext.16;catanf.ext.16;catanl.ext.16", 
                        "catan(NaN + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(catan_spec->Re) && isNan_Unifloat(catan_spec->Im));
                }
            }
            /*
             * catan(z) = -i * catanh(iz).
             */
            REQ("catan.ext.03;catanf.ext.03;catanl.ext.03",
                "catan(z) = -i * catanh(iz)",
                compareWithPrecision_UnifloatComplex(model_res, catan_spec, mant) == 0);
        }

        /*
         * These functions shall return the complex arc tangent value, in
         * the range of a strip mathematically unbounded along the imaginary 
         * axis and in the interval [-Pi/2, +Pi/2] along the real axis.
         */
        REQ("catan.02;catanf.02;catanl.02", 
            "Result should be in defined range",
            (compareWithPrecision_Unifloat(catan_spec->Re, Neg_PiTwo, mant) != -1) &&
            (compareWithPrecision_Unifloat(catan_spec->Re, PiTwo, mant) != 1));

        /*
         * These functions shall compute the complex arc tangent of z, with
         * branch cuts outside the interval [-i, +i] along the imaginary axis.
         */
        REQ("catan.01;catanf.01;catanl.01", 
            "It shall compute the complex arc tangent",
            compareWithPrecision_UnifloatComplex(model_res, catan_spec, mant) == 0);

        return true;
    }
    FILTER_CLEAN;
}

UnifloatComplex* catan_model(UnifloatComplex* x)
{
    UnifloatComplex* tmp1;
    UnifloatComplex* res;
    UnifloatComplex* arg;
    UnifloatType type = x->Re->type;

    arg = create_UnifloatComplex(x->Im, x->Re);
    tmp1 = catanh_model(arg);
    res = create_UnifloatComplex(tmp1->Im, tmp1->Re);
    
    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    ccos, ccosf, ccosl - complex cosine functions

SYNOPSIS

    #include <complex.h>

    double complex ccos(double complex z);

    float complex ccosf(float complex z);

    long double complex ccosl(long double complex z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the complex cosine of z.

RETURN VALUE

    These functions shall return the complex cosine value.

ERRORS

    No errors are defined.
*/

//This specification refers to: ccosf, ccos, ccosl
specification
UnifloatComplex* ccos_spec(CallContext context, UnifloatComplex* x)
{
    char type[3][10] = {"ccosf", "ccos", "ccosl"};
    
    FILTER(type[x->Im->type]);

    pre
    {
        /*[Input argument should be not NULL]*/
        REQ("", "Argument isn't Null", x != NULL);

        /*[Real and Imag part of input arguments should be not NULL]*/
        REQ("", "Argument isn't Null", (x->Im != NULL) && (x->Re != NULL));

        /*[Image and Real parts of input argument should have the same type]*/
        REQ("", "Im and Re has the same type", x->Im->type == x->Re->type);

        return true;
    }
    coverage C
    {
        if ((x->Im->kind == NaN) || (x->Re->kind == NaN))
            return {NaN_ARG, "Some part of argument is NaN"};
        else
            if ((x->Im->kind == Infinity) || (x->Re->kind == Infinity))
                return {INF_ARG, "some part of argument is infinity"};
            else
                return {NORMAL_ARG, "all parts of argument are normal"};
    }
    post
    {
        int type = x->Im->type;
        int mant = digMant_Unifloat(type);
        UnifloatComplex* model_res = ccos_model(x);
        UnifloatComplex* cis;
        Unifloat* One = createOne_Unifloat(type);

        round_Unifloat(model_res->Re, mant);
        round_Unifloat(model_res->Im, mant);

        if (CHECK_EXTENDED_REQ)
        {
            if ((x->Re->sign == 1) && (x->Im->sign == 1))
            {
                if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * ccosh(+0 + i * 0) returns 1 - i * 0.
                     */
                    REQ("ccos.ext.06;ccosf.ext.06;ccosl.ext.06",
                        "ccosh(+0 + i * 0) returns 1 - i * 0", 
                        (compare_Unifloat(ccos_spec->Re, One) == 0) && isZero_Unifloat(ccos_spec->Im) &&
                        (ccos_spec->Im->sign == -1));
                }

                if (isZero_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * ccosh(+0 + i * Inf) returns +Inf - i * 0.
                     */
                    REQ("ccos.ext.07;ccosf.ext.07;ccosl.ext.07", 
                        "ccosh(+0 + i * Inf) returns +Inf - i * 0",
                        isInfinity_Unifloat(ccos_spec->Re) && (ccos_spec->Re->sign == 1) &&
                        isZero_Unifloat(ccos_spec->Im) && (ccos_spec->Im->sign == -1));
                }

                if (isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * ccosh(+0 + i * NaN) returns NaN ± i * 0 (where the sign of the imaginary part of
                     * the resul is unspecified).
                     */
                    REQ("ccos.ext.08;ccosf.ext.08;ccosl.ext.08", 
                        "ccosh(+0 + i * NaN) returns NaN ± i * 0",
                        isNan_Unifloat(ccos_spec->Re) && isZero_Unifloat(ccos_spec->Im));
                }

                if (isNormal_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    cis = create_UnifloatComplex(mul_Unifloat(infinity_Unifloat(type), cos_Unifloat(x->Re)), 
                                                 mul_Unifloat(infinity_Unifloat(type), sin_Unifloat(x->Re)));
                    cis->Im->sign = -1;
                    /*
                     * ccosh(x + i * Inf) returns +Inf * conj( cis(x) ), for finite nonzero x (where conj(
                     * cis(x) ) = cos(x) - i * sin(x)).
                     */
                    REQ("ccos.ext.09;ccosf.ext.09;ccosl.ext.09", 
                        "ccosh(x + i * Inf) returns +Inf * conj( cis(y) )",
                        (compareWithPrecision_Unifloat(ccos_spec->Re, cis->Re, mant) == 0) &&
                        (compareWithPrecision_Unifloat(ccos_spec->Im, cis->Im, mant) == 0));
                }

                if (!isNan_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * ccosh(x + i * NaN) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for all nonzero numbers x.
                     */
                    REQ("ccos.ext.10;ccosf.ext.10;ccosl.ext.10",
                        "ccosh(x + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(ccos_spec->Re) && isNan_Unifloat(ccos_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * ccosh(Inf + i * 0) returns NaN ± i * 0 (where the sign of the imaginary part of
                     * the result is unspecified) and raises the "invalid" floating-point exception.
                     */
                    REQ("ccos.ext.11;ccosf.ext.11;ccosl.ext.11", 
                        "ccosh(Inf + i * 0) returns NaN ± i * 0",
                        isNan_Unifloat(ccos_spec->Re) && isZero_Unifloat(ccos_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im) && !isZero_Unifloat(x->Im))
                {
                    /*
                     * ccosh(Inf + i * y) returns NaN + i * NaN and raises the "invalid" floating-
                     * point exception, for finite nonzero y.
                     */
                    REQ("ccos.ext.12;ccosf.ext.12;ccosl.ext.12", 
                        "ccosh(Inf + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(ccos_spec->Re) && isNan_Unifloat(ccos_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * ccosh(+Inf + i * Inf) returns ±Inf + i * NaN (where the sign of real part of
                     * the result is unspecified) and raises the "invalid" floating-point exception.
                     */
                    REQ("ccos.ext.13;ccosf.ext.13;ccosl.ext.13", 
                        "ccosh(+Inf + i * Inf) returns ±Inf + i * NaN",
                        isInfinity_Unifloat(ccos_spec->Re) && isNan_Unifloat(ccos_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * ccosh(NaN + i * 0) returns NaN ± i * 0 (where the sign of the imaginary part of
                     * the result is unspecified).
                     */
                    REQ("ccos.ext.14;ccosf.ext.14;ccosl.ext.14", 
                        "ccosh(NaN + i * 0) returns NaN ± i * 0",
                        isNan_Unifloat(ccos_spec->Re) && isZero_Unifloat(ccos_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im) && !isZero_Unifloat(x->Im))
                {
                    /*
                     * ccosh(NaN + i * y) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for finite nonzero y.
                     */
                    REQ("ccos.ext.15;ccosf.ext.15;ccosl.ext.15",
                        "ccosh(NaN + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(ccos_spec->Re) && isNan_Unifloat(ccos_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * ccosh(NaN + i * Inf) returns +Inf + i * NaN.
                     */
                    REQ("ccos.ext.16;ccosf.ext.16;ccosl.ext.16", 
                        "ccosh(NaN + i * Inf) returns +Inf + i * NaN",
                        isInfinity_Unifloat(ccos_spec->Re) && isNan_Unifloat(ccos_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * ccosh(NaN + i * NaN) returns NaN + i * NaN.
                     */
                    REQ("ccos.ext.17;ccosf.ext.17;ccosl.ext.17", 
                        "ccosh(NaN + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(ccos_spec->Re) && isNan_Unifloat(ccos_spec->Im));
                }
            }
            /*
             * ccos(z) = ccosh(iz).
             */
            REQ("ccos.ext.03;ccosf.ext.03;ccosl.ext.03", 
                "ccos(z) = ccosh(iz)",
                compareWithPrecision_UnifloatComplex(model_res, ccos_spec, mant) == 0);
        }
        /*
         * These functions shall compute the complex cosine of z.
         */
        /*
         * These functions shall return the complex cosine value.
         */
        REQ("ccos.01;ccosf.01;ccosl.01;"
            "ccos.02;ccosf.02;ccosl.02", 
            "It shall return the complex cosine", 
            compareWithPrecision_UnifloatComplex(model_res, ccos_spec, mant) == 0);

        return true;
    }
    FILTER_CLEAN;
}

UnifloatComplex* ccos_model(UnifloatComplex* x)
{
    UnifloatComplex* res;
    UnifloatComplex* tmp1;
    UnifloatComplex* arg;
    UnifloatType type = x->Re->type;
    IntT sign;

    arg = create_UnifloatComplex(x->Im, x->Re);
    tmp1 = ccosh_model(arg);
    res = create_UnifloatComplex(tmp1->Re, tmp1->Im);
    res->Im->sign = -res->Im->sign;

    if (isOverflow_Unifloat(res->Re))
    {
        sign = res->Re->sign;
        res->Re = clone(infinity_Unifloat(type));
        res->Re->sign = sign;
    }
    
    if (isOverflow_Unifloat(res->Im))
    {
        sign = res->Im->sign;
        res->Im = clone(infinity_Unifloat(type));
        res->Im->sign = sign;
    }

    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    csin, csinf, csinl - complex sine functions

SYNOPSIS

    #include <complex.h>

    double complex csin(double complex z);

    float complex csinf(float complex z);

    long double complex csinl(long double complex z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the complex sine of z.

RETURN VALUE

    These functions shall return the complex sine value.

ERRORS

    No errors are defined.
*/

//This specification refers to: csinf, csin, csinl
specification
UnifloatComplex* csin_spec(CallContext context, UnifloatComplex* x)
{
    char type[3][10] = {"csinf", "csin", "csinl"};
    
    FILTER(type[x->Im->type]);

    pre
    {
        /*[Input argument should be not NULL]*/
        REQ("", "Argument isn't Null", x != NULL);

        /*[Real and Imag part of input arguments should be not NULL]*/
        REQ("", "Argument isn't Null", (x->Im != NULL) && (x->Re != NULL));

        /*[Image and Real parts of input argument should have the same type]*/
        REQ("", "Im and Re has the same type", x->Im->type == x->Re->type);

        return true;
    }
    coverage C
    {
        if ((x->Im->kind == NaN) || (x->Re->kind == NaN))
            return {NaN_ARG, "Some part of argument is NaN"};
        else
            if ((x->Im->kind == Infinity) || (x->Re->kind == Infinity))
                return {INF_ARG, "some part of argument is infinity"};
            else
                return {NORMAL_ARG, "all parts of argument are normal"};
    }
    post
    {
        int type = x->Im->type;
        int mant = digMant_Unifloat(type);
        UnifloatComplex* model_res = csin_model(x);
        UnifloatComplex* sic;

        round_Unifloat(model_res->Re, mant);
        round_Unifloat(model_res->Im, mant);

        if (CHECK_EXTENDED_REQ)
        {
            if ((x->Re->sign == 1) && (x->Im->sign == 1))
            {
                if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * csin(+0 + i * 0) returns +0 + i * 0.
                     */
                    REQ("csin.ext.06;csinf.ext.06;csinl.ext.06", 
                        "csin(+0 + i * 0) returns +0 + i * 0",
                        isZero_Unifloat(csin_spec->Re) && (csin_spec->Re->sign == 1)
                        && isZero_Unifloat(csin_spec->Im));
                }

                if (isZero_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * csin(+0 + i * Inf) returns +0 + i * Inf.
                     */
                    REQ("csin.ext.07;csinf.ext.07;csinl.ext.07", 
                        "csin(+0 + i * Inf) returns +0 + i * Inf",
                        isZero_Unifloat(csin_spec->Re) && (csin_spec->Re->sign == 1) 
                        && isInfinity_Unifloat(csin_spec->Im)&& (csin_spec->Im->sign == 1));
                }

                if (isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * csin(+0 + i * NaN) returns +0 + i * NaN.
                     */
                    REQ("csin.ext.08;csinf.ext.08;csinl.ext.08", 
                        "csin(+0 + i * NaN) returns +0 + i * NaN",
                        isZero_Unifloat(csin_spec->Re) && (csin_spec->Re->sign == 1) &&
                        isNan_Unifloat(csin_spec->Im));
                }

                if (isNormal_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    sic = create_UnifloatComplex(mul_Unifloat(infinity_Unifloat(type), sin_Unifloat(x->Re)), 
                                                 mul_Unifloat(infinity_Unifloat(type), cos_Unifloat(x->Re)));
                    /*
                     * csin(x + i * Inf) returns +Inf * sic(x), for positive finite x 
                     * (where sic(x) = sin(x) - i * cos(x)).
                     */
                    REQ("csin.ext.09;csinf.ext.09;csinl.ext.09", 
                        "csin(x + i * Inf) returns +Inf * sic(x), for positive finite x", 
                        (compareWithPrecision_Unifloat(csin_spec->Re, sic->Re, mant) == 0) &&
                        (compareWithPrecision_Unifloat(csin_spec->Im, sic->Im, mant) == 0));
                }

                if (isNormal_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * csin(x + i * NaN) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for all nonzero numbers x.
                     */
                    REQ("csin.ext.10;csinf.ext.10;csinl.ext.10",
                        "csin(x + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(csin_spec->Re) && isNan_Unifloat(csin_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * csin(+Inf + i * 0) returns NaN ± i * 0 (where the sign of the imaginary part of
                     * the result is unspecified) and raises the "invalid" floating-point exception.
                     */
                    REQ("csin.ext.11;csinf.ext.11;csinl.ext.11",
                        "csin(+Inf + i * 0) returns NaN ± i * 0",
                        isNan_Unifloat(csin_spec->Re) && isZero_Unifloat(csin_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im) && !isZero_Unifloat(x->Im))
                {
                    /*
                     * csin(+Inf + i * y) returns NaN + i * NaN and raises the "invalid" floating-
                     * point exception, for positive finite y.
                     */
                    REQ("csin.ext.12;csinf.ext.12;csinl.ext.12",
                        "csin(+Inf + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(csin_spec->Re) && isNan_Unifloat(csin_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * csin(+Inf + i * Inf) returns NaN ± i * Inf (where the sign of the imaginary
                     * part of the result is unspecified) and raises the "invalid" floating-point
                     * exception.
                     */
                    REQ("csin.ext.13;csinf.ext.13;csinl.ext.13", 
                        "csin(+Inf + i * Inf) returns NaN ± i * Inf",
                        isNan_Unifloat(csin_spec->Re) && isInfinity_Unifloat(csin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                    /*
                     * csin(NaN + i * 0) returns NaN ± i * 0 (where the sign of the imaginary part of
                     * the result is unspecified).
                     */
                    REQ("csin.ext.14;csinf.ext.14;csinl.ext.14", 
                        "csin(NaN + i * 0) returns NaN ± i * 0",
                        isNan_Unifloat(csin_spec->Re) && isZero_Unifloat(csin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im) && !isZero_Unifloat(x->Im))
                {
                    /*
                     * csin(NaN + i * y) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for finite nonzero y.
                     */
                    REQ("csin.ext.15;csinf.ext.15;csinl.ext.15",
                        "csin(NaN + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(csin_spec->Re) && isNan_Unifloat(csin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * csin(NaN + i * Inf) returns NaN ± i * Inf (where the sign of the imaginary part
                     * of the result is unspecified).
                     */
                    REQ("csin.ext.16;csinf.ext.16;csinl.ext.16", 
                        "csin(NaN + i * Inf) returns NaN ± i * Inf",
                        isNan_Unifloat(csin_spec->Re) && isInfinity_Unifloat(csin_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * csin(NaN + i * NaN) returns NaN + i * NaN.
                     */
                    REQ("csin.ext.17;csinf.ext.17;csinl.ext.17", 
                        "csin(NaN + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(csin_spec->Re) && isNan_Unifloat(csin_spec->Im));
                }
            }
            /*
             * csin(z) = -i * csinh(iz).
             */
            REQ("csin.ext.03;csinf.ext.03;csinl.ext.03", 
                "csin(z) = -i * csinh(iz)",
                compareWithPrecision_UnifloatComplex(model_res, csin_spec, mant) == 0);
        }

        /*
         * These functions shall compute the complex sine of z.
         */
        /*
         * These functions shall return the complex sine value.
         */
        REQ("csin.01;csinf.01;csinl.01;"
            "csin.02;csinf.02;csinl.02", 
            "It shall compute the complex sine", 
            compareWithPrecision_UnifloatComplex(model_res, csin_spec, mant) == 0);

        return true;
    }
    FILTER_CLEAN;
}

UnifloatComplex* csin_model(UnifloatComplex* x)
{
    UnifloatComplex* tmp1;
    UnifloatComplex* res;
    UnifloatComplex* arg;
    UnifloatType type = x->Re->type;
    IntT sign;

    arg = create_UnifloatComplex(x->Im, x->Re);
    tmp1 = csinh_model(arg);
    res = create_UnifloatComplex(tmp1->Im, tmp1->Re);

    if (isOverflow_Unifloat(res->Re))
    {
        sign = res->Re->sign;
        res->Re = clone(infinity_Unifloat(type));
        res->Re->sign = sign;
    }
    
    if (isOverflow_Unifloat(res->Im))
    {
        sign = res->Im->sign;
        res->Im = clone(infinity_Unifloat(type));
        res->Im->sign = sign;
    }
    
    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    ctan, ctanf, ctanl - complex tangent functions

SYNOPSIS

    #include <complex.h>

    double complex ctan(double complex z);

    float complex ctanf(float complex z);

    long double complex ctanl(long double complex z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the complex tangent of z.

RETURN VALUE

    These functions shall return the complex tangent value.

ERRORS

    No errors are defined.
*/

//This specification refers to: ctanf, ctan, ctanl
specification
UnifloatComplex* ctan_spec(CallContext context, UnifloatComplex* x)
{
    char type[3][10] = {"ctanf", "ctan", "ctanl"};
    
    FILTER(type[x->Im->type]);

    pre
    {
        /*[Input argument should be not NULL]*/
        REQ("", "Argument isn't Null", x != NULL);

        /*[Real and Imag part of input arguments should be not NULL]*/
        REQ("", "Argument isn't Null", (x->Im != NULL) && (x->Re != NULL));

        /*[Image and Real parts of input argument should have the same type]*/
        REQ("", "Im and Re has the same type", x->Im->type == x->Re->type);

        return true;
    }
    coverage C
    {
        if ((x->Im->kind == NaN) || (x->Re->kind == NaN))
            return {NaN_ARG, "Some part of argument is NaN"};
        else
            if ((x->Im->kind == Infinity) || (x->Re->kind == Infinity))
                return {INF_ARG, "some part of argument is infinity"};
            else
                return {NORMAL_ARG, "all parts of argument are normal"};
    }
    post
    {
        int type = x->Im->type;
        int mant = digMant_Unifloat(type);
        UnifloatComplex* model_res = ctan_model(x);
        Unifloat* One = createOne_Unifloat(type);
        Unifloat* Zero = createZero_Unifloat(type);
        Unifloat* Two = convertInteger_Unifloat(2, type);

        round_Unifloat(model_res->Re, mant);
        round_Unifloat(model_res->Im, mant);

        if (CHECK_EXTENDED_REQ)
        {
            if ((x->Re->sign == 1) && (x->Im->sign == 1))
            {
                if (isZero_Unifloat(x->Re) && isZero_Unifloat(x->Im))
                {
                   /*
                     * ctan(+0 + i * 0) returns +0 + i * 0.
                     */
                    REQ("ctan.ext.06;ctanf.ext.06;ctanl.ext.06", 
                        "ctan(+0 + i * 0) returns +0 + i * 0",
                        isZero_Unifloat(ctan_spec->Re) && (ctan_spec->Re->sign == 1) &&
                        isZero_Unifloat(ctan_spec->Im));
                }

                if (isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * ctan(+0 + i * NaN) returns +0 + i * NaN.
                     */
                    REQ("ctan.ext.07;ctanf.ext.07;ctanl.ext.07",
                        "ctan(+0 + i * NaN) returns +0 + i * NaN",
                        isZero_Unifloat(ctan_spec->Re) && isNan_Unifloat(ctan_spec->Im));
                }

                if (isNormal_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * ctan(x + i * Inf) returns +0 * sin(2x) + i, for positive-signed finite x.
                     */
                    REQ("ctan.ext.08;ctanf.ext.08;ctanl.ext.08", 
                        "ctan(x + i * Inf) returns +0 * sin(2x) + i",
                        (compareWithPrecision_Unifloat(ctan_spec->Re, 
                                                        mul_Unifloat(Zero, 
                                                                sin_Unifloat(
                                                                    mul_Unifloat(Two, x->Re))), mant) == 0) &&
                        (compare_Unifloat(ctan_spec->Im, One) == 0));
                }

                if (!isNan_Unifloat(x->Re) && !isZero_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * ctan(x + i * NaN) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for all nonzero numbers x.
                     */
                    REQ("ctan.ext.09;ctanf.ext.09;ctanl.ext.09", 
                        "ctan(x + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(ctan_spec->Re) && isNan_Unifloat(ctan_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
                {
                    /*
                     * ctan(+Inf + i * y) returns NaN + i * NaN and raises the "invalid" floating-
                     * point exception, for finite y.
                     */
                    REQ("ctan.ext.10;ctanf.ext.10;ctanl.ext.10",
                        "ctan(+Inf + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(ctan_spec->Re) && isNan_Unifloat(ctan_spec->Im));
                }

                if (isInfinity_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * ctan(+Inf + i * Inf) returns ±0 + i (where the sign of the real part of the
                     * result is unspecified).
                     */
                    REQ("ctan.ext.11;ctanf.ext.11;ctanl.ext.11", 
                        "ctan(+Inf + i * Inf) returns ±0 + i", 
                        isZero_Unifloat(ctan_spec->Re) && (compare_Unifloat(ctan_spec->Im, One) == 0));
                }

                if (isNan_Unifloat(x->Re) && isNormal_Unifloat(x->Im))
                {
                    /*
                     * ctan(NaN + i * y) returns NaN + i * NaN and optionally raises the "invalid"
                     * floating-point exception, for finite y.
                     */
                    REQ("ctan.ext.12;ctanf.ext.12;ctanl.ext.12",
                        "ctan(NaN + i * y) returns NaN + i * NaN",
                        isNan_Unifloat(ctan_spec->Re) && isNan_Unifloat(ctan_spec->Im));
                }

                if (isNan_Unifloat(x->Re) && isInfinity_Unifloat(x->Im))
                {
                    /*
                     * ctan(NaN + i * Inf) returns ±0 + i (where the sign of the real part of the
                     * result is unspecified).
                     */
                    REQ("ctan.ext.13;ctanf.ext.13;ctanl.ext.13",
                        "ctan(NaN + i * Inf) returns ±0 + i",
                        isZero_Unifloat(ctan_spec->Re) && (compare_Unifloat(ctan_spec->Im, One) == 0));
                }

                if (isNan_Unifloat(x->Re) && isNan_Unifloat(x->Im))
                {
                    /*
                     * ctan(NaN + i * NaN) returns NaN + i * NaN.
                     */
                    REQ("ctan.ext.14;ctanf.ext.14;ctanl.ext.14", 
                        "ctan(NaN + i * NaN) returns NaN + i * NaN",
                        isNan_Unifloat(ctan_spec->Re) && isNan_Unifloat(ctan_spec->Im));
                }
            }
            /*
             * ctan(z) = -i * ctanh(iz).
             */
            REQ("ctan.ext.03;ctanf.ext.03;ctanl.ext.03", 
                "ctan(z) = -i * ctanh(iz)",
                compareWithPrecision_UnifloatComplex(model_res, ctan_spec, mant) == 0);
        }
        /*
         * These functions shall compute the complex tangent of z.
         */
        /*
         * These functions shall return the complex tangent value.
         */
        REQ("ctan.01;ctanf.01;ctanl.01;"
            "ctan.02;ctanf.02;ctanl.02", 
            "It shall compute the complex tagent", 
            compareWithPrecision_UnifloatComplex(model_res, ctan_spec, mant) == 0);

        return true;
    }
    FILTER_CLEAN;
}

UnifloatComplex* ctan_model(UnifloatComplex* x)
{
    UnifloatComplex* tmp1;
    UnifloatComplex* res;
    UnifloatComplex* arg;
    UnifloatType type = x->Re->type;
    IntT sign;

    arg = create_UnifloatComplex(x->Im, x->Re);
    tmp1 = ctanh_model(arg);
    res = create_UnifloatComplex(tmp1->Im, tmp1->Re);

    if (isOverflow_Unifloat(res->Re))
    {
        sign = res->Re->sign;
        res->Re = clone(infinity_Unifloat(type));
        res->Re->sign = sign;
    }
    
    if (isOverflow_Unifloat(res->Im))
    {
        sign = res->Im->sign;
        res->Im = clone(infinity_Unifloat(type));
        res->Im->sign = sign;
    }
    
    return res;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
