/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ
#include "math/rand/rand_model.seh"
#include "system/sysconf/sysconf_model.seh"
#pragma SEC subsystem rand "math.rand"

/* 
   The group of functions 'math.rand' consists of: 
       drand48 [1]
       erand48 [1]
       initstate [1]
       jrand48 [1]
       lcong48 [1]
       lrand48 [1]
       mrand48 [1]
       nrand48 [1]
       rand [1]
       rand_r [1]
       random [1]
       seed48 [1]
       setstate [1]
       srand [1]
       srand48 [1]
       srandom [1]
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------
NAME

    drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, 
    srand48 - generate uniformly distributed pseudo-random numbers 

SYNOPSIS

    [XSI] #include <stdlib.h>
    double drand48(void);
    double erand48(unsigned short xsubi[3]);
    long jrand48(unsigned short xsubi[3]);
    void lcong48(unsigned short param[7]);
    long lrand48(void);
    long mrand48(void);
    long nrand48(unsigned short xsubi[3]);
    unsigned short *seed48(unsigned short seed16v[3]);
    void srand48(long seedval); 

DESCRIPTION

    This family of functions shall generate pseudo-random numbers using a 
    linear congruential algorithm and 48-bit integer arithmetic.
    The drand48() and erand48() functions shall return non-negative, double- 
    precision, floating-point values, uniformly distributed over the interval 
    [0.0,1.0).

    The lrand48() and nrand48() functions shall return non-negative, long 
    integers, uniformly distributed over the interval [0,231).

    The mrand48() and jrand48() functions shall return signed long integers 
    uniformly distributed over the interval [-231,231).

    The srand48(), seed48(), and lcong48() functions are initialization entry 
    points, one of which should be invoked before either drand48(), lrand48(), 
    or mrand48() is called. (Although it is not recommended practice, constant 
    default initializer values shall be supplied automatically if drand48(), 
    lrand48(), or mrand48() is called without a prior call to an initialization 
    entry point.) The erand48(), nrand48(), and jrand48() functions do not 
    require an initialization entry point to be called first.

    All the routines work by generating a sequence of 48-bit integer values, 
    Xi , according to the linear congruential formula: 
    Xn+1 = (aXn + c)mod m n>= 0 
    The parameter m = 248; hence 48-bit integer arithmetic is performed. Unless 
    lcong48() is invoked, the multiplier value a and the addend value c are 
    given by: a = 5DEECE66D16 = 2736731631558 c = B16 = 138 

    The value returned by any of the drand48(), erand48(), jrand48(), 
    lrand48(), mrand48(), or nrand48() functions is computed by first 
    generating the next 48-bit Xi in the sequence. Then the appropriate number 
    of bits, according to the type of data item to be returned, are copied from 
    the high-order (leftmost) bits of Xi and transformed into the returned 
    value.

    The drand48(), lrand48(), and mrand48() functions store the last 48-bit Xi 
    generated in an internal buffer; that is why the application shall ensure 
    that these are initialized prior to being invoked. The erand48(), 
    nrand48(), and jrand48() functions require the calling program to provide 
    storage for the successive Xi values in the array specified as an argument 
    when the functions are invoked. That is why these routines do not have to 
    be initialized; the calling program merely has to place the desired initial 
    value of Xi into the array and pass it as an argument. By using different 
    arguments, erand48(), nrand48(), and jrand48() allow separate modules of a 
    large program to generate several independent streams of pseudo-random 
    numbers; that is, the sequence of numbers in each stream shall not depend 
    upon how many times the routines are called to generate numbers for the 
    other streams.

    The initializer function srand48() sets the high-order 32 bits of Xi to the 
    low-order 32 bits contained in its argument. The low-order 16 bits of Xi 
    are set to the arbitrary value 330E16.

    The initializer function seed48() sets the value of Xi to the 48-bit value 
    specified in the argument array. The low-order 16 bits of Xi are set to the 
    low- order 16 bits of seed16v[0]. The mid-order 16 bits of Xi are set to 
    the low-order 16 bits of seed16v[1]. The high-order 16 bits of Xi are set 
    to the low-order 16 bits of seed16v[2]. In addition, the previous value of 
    Xi is copied into a 48-bit internal buffer, used only by seed48(), and a 
    pointer to this buffer is the value returned by seed48(). This returned 
    pointer, which can just be ignored if not needed, is useful if a program is 
    to be restarted from a given point at some future time-use the pointer to 
    get at and store the last Xi value, and then use this value to reinitialize 
    via seed48() when the program is restarted.

    The initializer function lcong48() allows the user to specify the initial 
    Xi, the multiplier value a, and the addend value c. Argument array elements 
    param[0-2] specify Xi , param[3-5] specify the multiplier a, and param[6] 
    specifies the 16-bit addend c. After lcong48() is called, a subsequent call 
    to either srand48() or seed48() shall restore the standard multiplier and 
    addend values, a and c, specified above.

    The drand48(), lrand48(), and mrand48() functions need not be reentrant. A 
    function that is not required to be reentrant is not required to be 
    thread-safe.

RETURN VALUE

    As described in the DESCRIPTION above.

ERRORS

    No errors are defined.
*/
specification
Unifloat* drand48_spec(CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        Unifloat* model_res;
        model_res = drand48_model();

        printExp_Unifloat(model_res, PRECISION);
        printExp_Unifloat(drand48_spec, PRECISION);
        verbose("\n");

        /*
         * The drand48(), lrand48(), and mrand48() functions need not be reentrant.
         */
        REQ("drand48.09", "", TODO_REQ());

        /*
         * This family of functions shall generate pseudo-random numbers using a linear 
         * congruential algorithm and 48-bit integer arithmetic.
         */
        REQ("drand48.01", "shall generate random numbers", 
             compare_Unifloat(drand48_spec, model_res) == 0);

        return true;
    }
}

Unifloat* drand48_model()
{
    Unifloat* res;

    /*
     * All the routines work by generating a sequence of 48-bit integer values, Xi , 
     * according to the linear congruential formula: Xn+1 = (aXn + c)mod m n>= 0
     */
    IMPLEMENT_REQ("drand48.04");

    /*
     * The parameter m = 248;
     */
    IMPLEMENT_REQ("drand48.05");

    /*
     * The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), 
     * mrand48(), or nrand48() functions is computed by first generating the next 48- 
     * bit Xi in the sequence.
     */
    IMPLEMENT_REQ("drand48.06");

    /*
     * Then the appropriate number of bits, according to the type of data item to be 
     * returned, are copied from the high-order (leftmost) bits of Xi and transformed 
     * into the returned value.
     */
    IMPLEMENT_REQ("drand48.07");

    res = clone(Rand48State->seed_model);
    res->exp -= 48;
    return res;
}

specification
Unifloat* erand48_spec(CallContext context, UShortT* xsubi)
{
    pre
    {
        return true;
    }
    coverage C
    {

       return { COMMON_CASE, "COMMON_CASE" };

    }
    post
    {
        Unifloat* model_res;
        model_res = erand48_model(xsubi);

        /*
         * The drand48() and erand48() functions shall return non-negative, double- 
         * precision, floating-point values, uniformly distributed over the interval [0. 
         * 0,1.0).
         */
        REQ("erand48.02", "shall return pseudo-random numbers", TODO_REQ());

        /*
         * This family of functions shall generate pseudo-random numbers using a linear 
         * congruential algorithm and 48-bit integer arithmetic.
         */
        REQ("erand48.01", "shall generate random numbers", 
             compare_Unifloat(erand48_spec, model_res) == 0);

        return true;
    }
}

Unifloat* erand48_model(UShortT* xsubi)
{
    IntT i;
    Unifloat* res, * m, * int_part, * seed, * tmp;
    /*
     * All the routines work by generating a sequence of 48-bit integer values, Xi , 
     * according to the linear congruential formula: Xn+1 = (aXn + c)mod m n>= 0
     */
    IMPLEMENT_REQ("erand48.04");

    /*
     * The parameter m = 248;
     */
    IMPLEMENT_REQ("erand48.05");

    /*
     * The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), 
     * mrand48(), or nrand48() functions is computed by first generating the next 48- 
     * bit Xi in the sequence.
     */
    IMPLEMENT_REQ("erand48.06");

    /*
     * Then the appropriate number of bits, according to the type of data item to be 
     * returned, are copied from the high-order (leftmost) bits of Xi and transformed 
     * into the returned value.
     */
    IMPLEMENT_REQ("erand48.07");

    /*
     * The erand48(), nrand48(), and jrand48() functions require the calling program 
     * to provide storage for the successive Xi values in the array specified as an 
     * argument when the functions are invoked.
     */
    IMPLEMENT_REQ("erand48.08");

    /*
     * the calling program merely has to place the desired initial value of Xi into 
     * the array and pass it as an argument.
     */
    IMPLEMENT_REQ("erand48.09");

    seed = convertInteger_Unifloat(xsubi[0], 1);
    tmp = convertInteger_Unifloat(xsubi[1], 1);
    tmp->exp += 16;
    seed = add_Unifloat(seed, tmp);
    tmp = convertInteger_Unifloat(xsubi[2], 1);
    tmp->exp += 32;
    seed = add_Unifloat(seed, tmp);

    m = convertString_Unifloat(create_CString("281474976710656"), 1);
    res = mul_Unifloat(Rand48State->a_model, seed);
    res = add_Unifloat(res, Rand48State->c_model);
    int_part = div_Unifloat(res, m);
    if(int_part->exp>0)
    for(i = int_part->exp + 1; i < PRECISION + 1; i++)
    setMant_Unifloat(int_part, i, 0);
    else int_part = createZero_Unifloat(1);
    res = sub_Unifloat(res, mul_Unifloat(int_part, m));
    res->exp -= 48;
    return res;
}

specification
Unifloat* jrand48_spec( CallContext context, UShortT* xsubi)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        Unifloat* model_res;
        model_res = jrand48_model(xsubi);

        /*
         * The mrand48() and jrand48() functions shall return signed long integers 
         * uniformly distributed over the interval [-231,231).
         */
        REQ("jrand48.02", "shall generate pseudo-random numbers", TODO_REQ());

        /*
         * This family of functions shall generate pseudo-random numbers using a linear 
         * congruential algorithm and 48-bit integer arithmetic.
         */
        REQ("jrand48.01", "shall generate random numbers", 
             compare_Unifloat(jrand48_spec, model_res) == 0);

        return true;
    }
}

Unifloat* jrand48_model(UShortT* xsubi)
{
    IntT i, sp;
    Unifloat* res, * m, * int_part, * seed, * tmp;
    
    /*
     * All the routines work by generating a sequence of 48-bit integer values, Xi , 
     * according to the linear congruential formula: Xn+1 = (aXn + c)mod m n>= 0
     */
    IMPLEMENT_REQ("jrand48.04");

    /*
     * The parameter m = 248;
     */
    IMPLEMENT_REQ("jrand48.05");

    /*
     * The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), 
     * mrand48(), or nrand48() functions is computed by first generating the next 48- 
     * bit Xi in the sequence.
     */
    IMPLEMENT_REQ("jrand48.06");

    /*
     * Then the appropriate number of bits, according to the type of data item to be 
     * returned, are copied from the high-order (leftmost) bits of Xi and transformed 
     * into the returned value.
     */
    IMPLEMENT_REQ("jrand48.07");

    /*
     * The erand48(), nrand48(), and jrand48() functions require the calling program 
     * to provide storage for the successive Xi values in the array specified as an 
     * argument when the functions are invoked.
     */
    IMPLEMENT_REQ("jrand48.08");

    /*
     * the calling program merely has to place the desired initial value of Xi into 
     * the array and pass it as an argument.
     */
    IMPLEMENT_REQ("jrand48.09");
    
    seed = convertInteger_Unifloat(xsubi[0], 1);
    tmp = convertInteger_Unifloat(xsubi[1], 1);
    tmp->exp += 16;
    seed = add_Unifloat(seed, tmp);
    tmp = convertInteger_Unifloat(xsubi[2], 1);
    tmp->exp += 32;
    seed = add_Unifloat(seed, tmp);

    m = convertString_Unifloat(create_CString("281474976710656"), 1);
    res = mul_Unifloat(Rand48State->a_model, seed);
    res = add_Unifloat(res, Rand48State->c_model);
    int_part = div_Unifloat(res, m);
    if(int_part->exp>0)
    for(i = int_part->exp + 1; i < PRECISION + 1; i++)
    setMant_Unifloat(int_part, i, 0);
    else int_part = createZero_Unifloat(1);
    res = sub_Unifloat(res, mul_Unifloat(int_part, m));
    
    //get hight 32 bits
    for(i = res->exp; (i > res->exp - 16) && (i > 0); i--)
    {
        setMant_Unifloat(res, i, 0);
    }
    res->exp -= 16;

    //when res is negative (sign is 32'nd bit)
    if(res->exp == 32)
    {
        res->sign = -1;
    }
    else
    {
        res->sign = 1;
    }
    if(res->sign == -1)
    {
        //represent res in negative form: add one and inversion (1->0, 0->1)
        res = add_Unifloat(res, createOne_Unifloat(1));

        for(i = 1; i < res->exp + 1; i++)
        {
            if(getMant_Unifloat(res, i) == 0)
            {
                setMant_Unifloat(res, i, 1);
            }
            else
            {
                setMant_Unifloat(res, i, 0);
            }
        }
        
        //normalization after inversion
        sp = 0;
        for(i = 1; i < res->exp + 1; i++)
        {
            if(getMant_Unifloat(res, i) == 0)
            {
                sp++;
            }
            else
            {
                break;
            }
        }
        for(i = sp + 1; i < res->exp + 1; i++)
        {
            setMant_Unifloat(res, i - sp, getMant_Unifloat(res, i));
        }
        for(i = res->exp + 1 - sp; i < res->exp + 1; i++)
        {
            setMant_Unifloat(res, i, 0);
        }
        res->exp -= sp;
    }

    //case when value of res is less then one
    if(res->exp <= 0)
    {
        res = createZero_Unifloat(1);
    }
    return res;
}

specification
void lcong48_spec(CallContext context, UShortT *param)
{
    pre
    {
        return true;
    }

    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    
    post
    {
        /*
         * The initializer function lcong48() allows the user to specify the initial Xi , 
         * the multiplier value a, and the addend value c. Argument array elements param[0- 
         * 2] specify Xi , param[3-5] specify the multiplier a, and param[6] specifies the 
         * 16-bit addend c.
         */

        IMPLEMENT_REQ("lcong48.03");

        return true;
    }
}

specification
Unifloat* lrand48_spec(CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        Unifloat* model_res;
        model_res = lrand48_model();

        /*
         * The drand48(), lrand48(), and mrand48() functions need not be reentrant.
         */
        REQ("lrand48.09", "", TODO_REQ());

        /*
         * This family of functions shall generate pseudo-random numbers using a linear 
         * congruential algorithm and 48-bit integer arithmetic.
         */
        REQ("lrand48.01", "shall generate random numbers", 
             compare_Unifloat(lrand48_spec, model_res) == 0);

        return true;
    }
}

Unifloat* lrand48_model()
{
    IntT i;
    Unifloat* res;

    /*
     * All the routines work by generating a sequence of 48-bit integer values, Xi , 
     * according to the linear congruential formula: Xn+1 = (aXn + c)mod m n>= 0
     */
    IMPLEMENT_REQ("lrand48.04");

    /*
     * The parameter m = 248;
     */
    IMPLEMENT_REQ("lrand48.05");

    /*
     * The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), 
     * mrand48(), or nrand48() functions is computed by first generating the next 48- 
     * bit Xi in the sequence.
     */
    IMPLEMENT_REQ("lrand48.06");

    /*
     * Then the appropriate number of bits, according to the type of data item to be 
     * returned, are copied from the high-order (leftmost) bits of Xi and transformed 
     * into the returned value.
     */
    IMPLEMENT_REQ("lrand48.07");

    res = clone(Rand48State->seed_model);
    for(i = res->exp; (i > res->exp - 17) && (i > 0); i--)
    {
        setMant_Unifloat(res, i, 0);
    }
    res->exp -= 17;
    if(res->exp <= 0)
    {
        res = createZero_Unifloat(1);
    }
    return res;
}

specification
Unifloat* mrand48_spec(CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };

    }
    post
    {
        Unifloat* model_res;
        model_res = mrand48_model();

        /*
         * The drand48(), lrand48(), and mrand48() functions need not be reentrant.
         */
        REQ("mrand48.09", "", TODO_REQ());

        /*
         * This family of functions shall generate pseudo-random numbers using a linear 
         * congruential algorithm and 48-bit integer arithmetic.
         */
        REQ("mrand48.01", "shall generate random numbers", 
             compare_Unifloat(mrand48_spec, model_res) == 0);
        
        return true;
    }
}

Unifloat* mrand48_model()
{
    Unifloat* res;
    IntT i, sp = 0;

    /*
     * All the routines work by generating a sequence of 48-bit integer values, Xi , 
     * according to the linear congruential formula: Xn+1 = (aXn + c)mod m n>= 0
     */
    IMPLEMENT_REQ("mrand48.04");

    /*
     * The parameter m = 248;
     */
    IMPLEMENT_REQ("mrand48.05");

    /*
     * The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), 
     * mrand48(), or nrand48() functions is computed by first generating the next 48- 
     * bit Xi in the sequence.
     */
    IMPLEMENT_REQ("mrand48.06");

    /*
     * Then the appropriate number of bits, according to the type of data item to be 
     * returned, are copied from the high-order (leftmost) bits of Xi and transformed 
     * into the returned value.
     */
    IMPLEMENT_REQ("mrand48.07");

    res = clone(Rand48State->seed_model);
    //get hight 32 bits
    for(i = res->exp; (i > res->exp - 16) && (i > 0); i--)
    {
        setMant_Unifloat(res, i, 0);
    }
    res->exp -= 16;

    //when res is negative (sign is 32'nd bit)
    if(res->exp == 32)
    {
        res->sign = -1;
    }
    else
    {
        res->sign = 1;
    }
    if(res->sign == -1)
    {
        //represent res in negative form: add one and inversion (1->0, 0->1)
        res = add_Unifloat(res, createOne_Unifloat(1));

        for(i = 1; i < res->exp + 1; i++)
        {
            if(getMant_Unifloat(res, i) == 0)
            {
                setMant_Unifloat(res, i, 1);
            }
            else
            {
                setMant_Unifloat(res, i, 0);
            }
        }
        
        //normalization after inversion
        sp = 0;
        for(i = 1; i < res->exp + 1; i++)
        {
            if(getMant_Unifloat(res, i) == 0)
            {
                sp++;
            }
            else
            {
                break;
            }
        }
        for(i = sp + 1; i < res->exp + 1; i++)
        {
            setMant_Unifloat(res, i - sp, getMant_Unifloat(res, i));
        }
        for(i = res->exp + 1 - sp; i < res->exp + 1; i++)
        {
            setMant_Unifloat(res, i, 0);
        }
        res->exp -= sp;
    }

    //case when value of res is less then one
    if(res->exp <= 0)
    {
        res = createZero_Unifloat(1);
    }
    return res;
}

specification
Unifloat* nrand48_spec( CallContext context, UShortT* xsubi)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        Unifloat* model_res;
        model_res = nrand48_model(xsubi);

        /*
         * The lrand48() and nrand48() functions shall return non-negative, long integers, 
         * uniformly distributed over the interval [0,231).
         */
        REQ("nrand48.02", "shall generate pseudo-random numbers", 
             TODO_REQ());

        /*
         * This family of functions shall generate pseudo-random numbers using a linear 
         * congruential algorithm and 48-bit integer arithmetic.
         */
        REQ("nrand48.01", "shall generate random numbers", 
             compare_Unifloat(nrand48_spec, model_res) == 0);
        
        return true;
    }
}

Unifloat* nrand48_model(UShortT* xsubi)
{
    IntT i;
    Unifloat* res, * m, * int_part, * seed, * tmp;

    /*
     * All the routines work by generating a sequence of 48-bit integer values, Xi , 
     * according to the linear congruential formula: Xn+1 = (aXn + c)mod m n>= 0
     */
    IMPLEMENT_REQ("nrand48.04");

    /*
     * The parameter m = 248;
     */
    IMPLEMENT_REQ("nrand48.05");

    /*
     * The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), 
     * mrand48(), or nrand48() functions is computed by first generating the next 48- 
     * bit Xi in the sequence.
     */
    IMPLEMENT_REQ("nrand48.06");

    /*
     * Then the appropriate number of bits, according to the type of data item to be 
     * returned, are copied from the high-order (leftmost) bits of Xi and transformed 
     * into the returned value.
     */
    IMPLEMENT_REQ("nrand48.07");

    /*
     * The erand48(), nrand48(), and jrand48() functions require the calling program 
     * to provide storage for the successive Xi values in the array specified as an 
     * argument when the functions are invoked.
     */
    IMPLEMENT_REQ("nrand48.08");

    /*
     * the calling program merely has to place the desired initial value of Xi into 
     * the array and pass it as an argument.
     */
    IMPLEMENT_REQ("nrand48.09");

    seed = convertInteger_Unifloat(xsubi[0], 1);
    tmp = convertInteger_Unifloat(xsubi[1], 1);
    tmp->exp += 16;
    seed = add_Unifloat(seed, tmp);
    tmp = convertInteger_Unifloat(xsubi[2], 1);
    tmp->exp += 32;
    seed = add_Unifloat(seed, tmp);

    m = convertString_Unifloat(create_CString("281474976710656"), 1);
    res = mul_Unifloat(Rand48State->a_model, seed);
    res = add_Unifloat(res, Rand48State->c_model);
    int_part = div_Unifloat(res, m);
    if(int_part->exp>0)
    for(i = int_part->exp + 1; i < PRECISION + 1; i++)
    setMant_Unifloat(int_part, i, 0);
    else int_part = createZero_Unifloat(1);
    res = sub_Unifloat(res, mul_Unifloat(int_part, m));

    for(i = res->exp; (i > res->exp - 17) && (i > 0); i--)
    {
        setMant_Unifloat(res, i, 0);
    }
    res->exp -= 17;
    if(res->exp <= 0)
    {
        res = createZero_Unifloat(1);
    }
    return res;
}

/////////////////////////////////////////////////////////////
specification typedef struct Seed48ReturnType Seed48ReturnType = {};

Seed48ReturnType * create_Seed48ReturnType(UShortT res[3])
{
    return create(&type_Seed48ReturnType, res);
}

specification
Seed48ReturnType* seed48_spec( CallContext context, UShortT* seed16v3)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        /*
         * The initializer function seed48() sets the value of Xi to the 48-bit value 
         * specified in the argument array. The low-order 16 bits of Xi are set to the low- 
         * order 16 bits of seed16v[0]. The mid-order 16 bits of Xi are set to the low- 
         * order 16 bits of seed16v[1]. The high-order 16 bits of Xi are set to the low- 
         * order 16 bits of seed16v[2].
         */

        IMPLEMENT_REQ("seed48.02");

        /*
         * In addition, the previous value of Xi is copied into a 48-bit internal buffer, 
         * used only by seed48(), and a pointer to this buffer is the value returned by 
         * seed48().
         */

        REQ("seed48.03", "", TODO_REQ());

        /*
         * After lcong48() is called, a subsequent call to either srand48() or seed48() 
         * shall restore the standard multiplier and addend values, a and c, specified 
         * above.
         */

        IMPLEMENT_REQ("seed48.04");
        
        return true;
    }
}

specification
void srand48_spec( CallContext context, LongT seedval)
{
    pre
    {
        return true;
    }
    
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }

    post
    {
        /*
         * The initializer function srand48() sets the high-order 32 bits of Xi to the low- 
         * order 32 bits contained in its argument. The low-order 16 bits of Xi are set to 
         * the arbitrary value 330E16.
         */

        IMPLEMENT_REQ("srand48.02");

        /*
         * After lcong48() is called, a subsequent call to either srand48() or seed48() 
         * shall restore the standard multiplier and addend values, a and c, specified 
         * above.
         */

        IMPLEMENT_REQ("srand48.03");

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    rand, rand_r, srand - pseudo-random number generator 

SYNOPSIS

    #include <stdlib.h>

    int rand(void);

    [TSF] int rand_r(unsigned *seed); 

    void srand(unsigned seed);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the 
    ISO C standard. Any conflict between the requirements described here and 
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 
    defers to the ISO C standard. The rand() function shall compute a sequence 
    of pseudo-random integers in the range [0, {RAND_MAX}] [XSI] with a period 
    of at least 232. 

    [CX] The rand() function need not be reentrant. A function that is not 
    required to be reentrant is not required to be thread-safe. 

    [TSF] The rand_r() function shall compute a sequence of pseudo-random 
    integers in the range [0, {RAND_MAX}]. (The value of the {RAND_MAX} macro 
    shall be at least 32767.)

    If rand_r() is called with the same initial value for the object pointed to 
    by seed and that object is not modified between successive returns and 
    calls to rand_r(), the same sequence shall be generated. 

    The srand() function uses the argument as a seed for a new sequence of 
    pseudo-random numbers to be returned by subsequent calls to rand(). If 
    srand() is then called with the same seed value, the sequence of 
    pseudo-random numbers shall be repeated. If rand() is called before any 
    calls to srand() are made, the same sequence shall be generated as when 
    srand() is first called with a seed value of 1.

    The implementation shall behave as if no function defined in this volume of 
    IEEE Std 1003.1-2001 calls rand() or srand().

RETURN VALUE

    The rand() function shall return the next pseudo-random number in the 
    sequence.

    [TSF] The rand_r() function shall return a pseudo-random integer. 

    The srand() function shall not return a value.

ERRORS

    No errors are defined.
*/

specification
Unifloat* rand_spec(CallContext context)
{
    LongT MAX = getSystemConfigurationValue(context, SUT_SC_RAND_MAX);
    Unifloat* Zero = createZero_Unifloat(1);
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        /*
         * The rand() function shall compute a sequence of pseudo-random integers in the 
         * range [0, {RAND_MAX}] [XSI] with a period of at least 2^32.
         */
       
        REQ("rand.01", "shall compute pseudo-random integers", 
                       (compare_Unifloat(rand_spec, Zero) != -1) && 
                       (compare_Unifloat(rand_spec, convertInteger_Unifloat(MAX, 1)) != 1));

        /*
         * [CX] The rand() function need not be reentrant.
         */
        REQ("rand.02", "", TODO_REQ());

        /*
         * (The value of the {RAND_MAX} macro shall be at least 32767.)
         */
        REQ("rand.03", "RAND_MAX macro shall be at least 32767", 
             compare_Unifloat(convertInteger_Unifloat(MAX, 1), convertInteger_Unifloat(32767, 1)) != -1);

        /*
         * The rand() function shall return the next pseudo-random number in the sequence.
         */
        REQ("rand.04", "", TODO_REQ());
        
        return true;
    }
}

specification
Unifloat* rand_r_spec(CallContext context, UIntT seed)
{
    LongT MAX = getSystemConfigurationValue(context, SUT_SC_RAND_MAX);
    Unifloat* Zero = createZero_Unifloat(1);
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {
        /*
         * [TSF] The rand_r() function shall compute a sequence of pseudo-random integers 
         * in the range [0, {RAND_MAX}].
         */
        REQ("rand_r.01", "shall compute pseudo-random integers", 
                         (compare_Unifloat(rand_r_spec, Zero) != -1) && 
                         (compare_Unifloat(rand_r_spec, convertInteger_Unifloat(MAX, 1)) != 1));

        /*
         * (The value of the {RAND_MAX} macro shall be at least 32767.)
         */
        REQ("rand_r.02", "RAND_MAX macro shall be at least 32767", 
             compare_Unifloat(convertInteger_Unifloat(MAX, 1), convertInteger_Unifloat(32767, 1)) != -1);

        /*
         * [TSF] The rand_r() function shall return a pseudo-random integer.
         */
        REQ("rand_r.04", "", TODO_REQ());
        
        return true;
    }
}

specification
void srand_spec(CallContext context, UIntT seed)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE" };
    }
    post
    {

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    initstate, random, setstate, srandom - pseudo-random number functions 

SYNOPSIS

    [XSI] #include <stdlib.h>

    char *initstate(unsigned seed, char *state, size_t size);

    long random(void);

    char *setstate(const char *state);

    void srandom(unsigned seed); 

DESCRIPTION

    The random() function shall use a non-linear additive feedback 
    random-number generator employing a default state array size of 31 long 
    integers to return successive pseudo-random numbers in the range from 0 to 
    231-1.The period of this random-number generator is approximately 
    16 x (231-1). The size of the state array determines the period of the 
    random-number generator. Increasing the state array size shall increase the 
    period.

    With 256 bytes of state information, the period of the random-number 
    generator shall be greater than 269.

    Like rand(), random() shall produce by default a sequence of numbers that 
    can be duplicated by calling srandom() with 1 as the seed.

    The srandom() function shall initialize the current state array using the 
    value of seed.

    The initstate() and setstate() functions handle restarting and changing 
    random-number generators. The initstate() function allows a state array, 
    pointed to by the state argument, to be initialized for future use. The 
    size argument, which specifies the size in bytes of the state array, shall 
    be used by initstate() to decide what type of random-number generator to 
    use; the larger the state array, the more random the numbers. Values for 
    the amount of state information are 8, 32, 64, 128, and 256 bytes. Other 
    values greater than 8 bytes are rounded down to the nearest one of these 
    values. If initstate() is called with 8<=size<32, then random() shall use a 
    simple linear congruential random number generator. The seed argument 
    specifies a starting point for the random-number sequence and provides for 
    restarting at the same point. The initstate() functioen shall return a 
    pointer to the previous state information array.

    If initstate() has not been called, then random() shall behave as though 
    initstate() had been called with seed=1 and size=128.

    Once a state has been initialized, setstate() allows switching between 
    state arrays. The array defined by the state argument shall be used for 
    further random-number generation until initstate() is called or setstate() 
    is called again. The setstate() function shall return a pointer to the 
    previous state array.

RETURN VALUE

    If initstate() is called with size less than 8, it shall return NULL.

    The random() function shall return the generated pseudo-random number.

    The srandom() function shall not return a value.

    Upon successful completion, initstate() and setstate() shall return a 
    pointer to the previous state array; otherwise, a null pointer shall be 
    returned.

ERRORS

    No errors are defined.
*/

/////////////////////////////////////////////////////////////

specification typedef struct InitstateReturnType InitstateReturnType = {};

InitstateReturnType * create_InitstateReturnType(VoidTPtr res, VoidTPtr CurStatePointer)
{
    return create(&type_InitstateReturnType, res, CurStatePointer);
}

specification
InitstateReturnType* initstate_spec( CallContext context, UIntT seed, IntT size)
{
    pre
    {
        return true;
    }
    coverage C
    {
        if(size < 8)
            return { unsuccessful_case, 
                    "size < 8: unsuccessful case" };

        if((size >= 8) && (size < 32))
            return { size_8_linear, 
                    "8 <= size < 32: simple linear congruential random number "
                    "generator" };
        
        if((size >= 32) && (size < 64))
            return { size_32_non_linear, 
                    "32 <= size < 64: size 32 non-linear additive feedback "
                    "random number generator" };

        if((size >= 64) && (size < 128))
            return { size_64_non_linear, 
                    "64 <= size < 128: size 64 non-linear additive feedback "
                    "random number generator" };

        if((size >= 128) && (size < 256))
            return { size_128_non_linear, 
                    "128 <= size < 256: size 128 non-linear additive feedback "
                    "random number generator" };

        if(size >= 256)
            return { size_256_non_linear, 
                    "size >= 256: size 256 non-linear additive feedback "
                    "random number generator" };
    }
    post
    {
        /*
         * The initstate() function allows a state array, pointed to by the state 
         * argument, to be initialized for future use.
         */
        REQ("initstate.02", "", TODO_REQ());

        /*
         * The size argument, which specifies the size in bytes of the state array, shall 
         * be used by initstate() to decide what type of random-number generator to use;
         */
        REQ("initstate.03", "", TODO_REQ());

        /*
         * Values for the amount of state information are 8, 32, 64, 128, and 256 bytes. 
         * Other values greater than 8 bytes are rounded down to the nearest one of these 
         * values.
         */
        REQ("initstate.04", "", TODO_REQ());

        /*
         * If initstate() is called with 8<=size<32, then random() shall use a 
         * simple linear congruential random number generator.
         */
        REQ("initstate.05", "", TODO_REQ());

        if(size < 8)
        {
            /*
             * If initstate() is called with size less than 8, it shall return NULL.
             */
            REQ("initstate.11", "if size<8 shall return NULL", initstate_spec->res.address == 0);
        }

        if(@RandState->CurrentStatePointer.address != 0)
        {
            /*
             * The initstate() function shall return a pointer to the previous state 
             * information array.
             */
            REQ("initstate.07", "shall return pointer to the previous state", 
                 initstate_spec->res.address == @RandState->CurrentStatePointer.address);
        }

        if(@RandState->CurrentStatePointer.address != 0)
        {
            /*
             * Upon successful completion, initstate() and setstate() shall return a pointer 
             * to the previous state array; otherwise, a null pointer shall be returned.
             */
            REQ("initstate.12", "shall return pointer to the previous state", 
                 initstate_spec->res.address == @RandState->CurrentStatePointer.address);
        }

     
        
        return true;
    }
}

specification
Unifloat* random_spec(CallContext context)
{
    LongT MAXRAND = 2147483647;
    Unifloat* Zero = createZero_Unifloat(1);
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE"};
    }
    post
    {
        /*
         * The random() function shall use a non-linear additive feedback random-number 
         * generator employing a default state array size of 31 long integers to return 
         * successive pseudo-random numbers in the range from 0 to 2^31-1.
         */
        REQ("random.01", "shall compute pseudo-random integers", 
                         (compare_Unifloat(random_spec, Zero) != -1) && 
                         (compare_Unifloat(random_spec, convertInteger_Unifloat(MAXRAND, 1)) != 1));

        /*
         * The period of this random-number generator is approximately 16 x (231-1).
         */
        REQ("random.02", "", TODO_REQ());

        /*
         * The size of the state array determines the period of the random-number 
         * generator.
         */
        REQ("random.03", "", TODO_REQ());

        /*
         * Increasing the state array size shall increase the period.
         */
        REQ("random.04", "", TODO_REQ());

        /*
         * With 256 bytes of state information, the period of the random-number generator 
         * shall be greater than 2^69.
         */
        REQ("random.05", "", TODO_REQ());

        /*
         * Like rand(), random() shall produce by default a sequence of numbers that can 
         * be duplicated by calling srandom() with 1 as the seed.
         */
        REQ("random.06", "", TODO_REQ());

        /*
         * the larger the state array, the more random the numbers.
         */
        REQ("random.07", "", TODO_REQ());

      

        return true;
    }
}

specification
VoidTPtr setstate_spec(CallContext context, VoidTPtr StatePointer)
{
    Integer* res;
    pre
    {
        return true;
    }
    coverage C
    {
            return { COMMON_CASE, "COMMON_CASE"};
    }
    post
    {

        /*
         * Once a state has been initialized, setstate() allows switching between state 
         * arrays.
         */
        /*
         * The setstate() function shall return a pointer to the previous state array.
         */
        REQ("setstate.02;setstate.04", "shall return pointer to the previous state array", 
                  setstate_spec.address == @RandState->CurrentStatePointer.address);
        
        if(setstate_spec.address != 0)
        {
            /*
             * Upon successful completion, initstate() and setstate() shall return a pointer 
             * to the previous state array; otherwise, a null pointer shall be returned.
             */
            REQ("setstate.05", "shall return pointer to the previous state array", 
                      setstate_spec.address == @RandState->CurrentStatePointer.address);
        }



        return true;
    }
}

specification
void srandom_spec(CallContext context, UIntT seed)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { COMMON_CASE, "COMMON_CASE"};
    }
    post
    {
        /*
         * The srandom() function shall initialize the current state array using the value 
         * of seed.
         */
        REQ("srandom.01", "", TODO_REQ());

        /*
         * The srandom() function shall not return a value.
         */
        REQ("srandom.04", "", TODO_REQ());

        return true;
    }
}

/********************************************************************/
/**                            State                               **/
/********************************************************************/

//for drand48, erand48, lrand48, jrand48, mrand48, nrand48 functions
specification typedef struct Random48State Random48State = {};

Random48State* create_Random48State(Unifloat* seed_model, Unifloat* a_model, Unifloat* c_model)
{   
    return create(&type_Random48State, seed_model, a_model, c_model);
}

//for initstate, setstate, random, srandom functions
specification typedef struct RandomState RandomState = {};

VoidTPtr NullState = {0,0,0};

RandomState* create_RandomState()
{   
    return create(&type_RandomState, create_List(&type_VoidTPtrObj), NullState);
}

/********************************************************************/
/**                     Unifloat Random Functions                  **/
/********************************************************************/

BoolT Kolmogorov_drand48(Map* RandomSample)
{
    IntT k;
    IntT size = size_Map(RandomSample);
    Unifloat* delta1, * delta2, * tmp, * x, * Statistics, * Bound;
    Map* Delta = create_Map(&type_Integer, &type_Unifloat);
    Map* CosmicDelta;
    Map* CosmicRandomSample = bubblesort(RandomSample);
    
    tmp = div_Unifloat(createOne_Unifloat(1), convertInteger_Unifloat(size, 1));
    for(k = 1; k <= size; k++)
    {
        x = get_Map(CosmicRandomSample, create_Integer(k));
        delta1 = mul_Unifloat(convertInteger_Unifloat(k - 1, 1), tmp);
        delta1 = sub_Unifloat(delta1, x);
        delta1 = abs_Unifloat(delta1);
        delta2 = mul_Unifloat(convertInteger_Unifloat(k, 1), tmp);
        delta2 = sub_Unifloat(delta2, x);
        delta2 = abs_Unifloat(delta2);
        if(compare_Unifloat(delta2, delta1) == 1)
            put_Map(Delta, create_Integer(k), delta2);
        else
            put_Map(Delta, create_Integer(k), delta1);
    }
    CosmicDelta = bubblesort(Delta);
    Statistics = get_Map(CosmicDelta, create_Integer(size));
    Statistics = mul_Unifloat(Statistics, sqrt_Unifloat(convertInteger_Unifloat(size, 1)));

    //significance level epsilon = 0.001
    Bound = convertBinaryString_Unifloat(create_CString(
                                                       "1.1111001100010000110"
                                                       "001001000001001101111"
                                                       "000100010101111010101"
                                                       "010000001100101010101"
                                                       "10100011011010110"
                                                       ),1);

    if(compare_Unifloat(Statistics, Bound) == 1)
    {
        return false;
    }
    else
    {
        return true;
    }
}

BoolT Kolmogorov_lrand48(Map* RandomSample)
{
    IntT k;
    IntT size = size_Map(RandomSample);
    Unifloat* delta1, * delta2, * tmp, * x, * Statistics, * Bound, * Max;
    Map* Delta = create_Map(&type_Integer, &type_Unifloat);
    Map* CosmicDelta;
    Map* CosmicRandomSample = bubblesort(RandomSample);
    Max = convertString_Unifloat(create_CString("2147483648"), 1);
    
    tmp = div_Unifloat(createOne_Unifloat(1), convertInteger_Unifloat(size, 1));
    for(k = 1; k <= size; k++)
    {
        x = get_Map(CosmicRandomSample, create_Integer(k));
        x = div_Unifloat(x, Max);
        delta1 = mul_Unifloat(convertInteger_Unifloat(k - 1, 1), tmp);
        delta1 = sub_Unifloat(delta1, x);
        delta1 = abs_Unifloat(delta1);
        delta2 = mul_Unifloat(convertInteger_Unifloat(k, 1), tmp);
        delta2 = sub_Unifloat(delta2, x);
        delta2 = abs_Unifloat(delta2);
        if(compare_Unifloat(delta2, delta1) == 1)
            put_Map(Delta, create_Integer(k), delta2);
        else
            put_Map(Delta, create_Integer(k), delta1);
    }
    CosmicDelta = bubblesort(Delta);
    Statistics = get_Map(CosmicDelta, create_Integer(size));
    Statistics = mul_Unifloat(Statistics, sqrt_Unifloat(convertInteger_Unifloat(size, 1)));

    //significance level epsilon = 0.001
    Bound = convertBinaryString_Unifloat(create_CString(
                                                       "1.1111001100010000110"
                                                       "001001000001001101111"
                                                       "000100010101111010101"
                                                       "010000001100101010101"
                                                       "10100011011010110"
                                                       ),1);

    if(compare_Unifloat(Statistics, Bound) == 1)
    {
        return false;
    }
    else
    {
        return true;
    }
}

BoolT Kolmogorov_mrand48(Map* RandomSample)
{
    IntT k;
    IntT size = size_Map(RandomSample);
    Unifloat* delta1, * delta2, * tmp, * x, * Statistics, * Bound, * Max;
    Map* Delta = create_Map(&type_Integer, &type_Unifloat);
    Map* CosmicDelta;
    Map* CosmicRandomSample = bubblesort(RandomSample);
    Max = convertString_Unifloat(create_CString("2147483648"), 1);
    
    tmp = div_Unifloat(createOne_Unifloat(1), convertInteger_Unifloat(size, 1));
    for(k = 1; k <= size; k++)
    {
        x = get_Map(CosmicRandomSample, create_Integer(k));
        x = add_Unifloat(x, Max);
        x = div_Unifloat(x, Max);
        x->exp--;
        delta1 = mul_Unifloat(convertInteger_Unifloat(k - 1, 1), tmp);
        delta1 = sub_Unifloat(delta1, x);
        delta1 = abs_Unifloat(delta1);
        delta2 = mul_Unifloat(convertInteger_Unifloat(k, 1), tmp);
        delta2 = sub_Unifloat(delta2, x);
        delta2 = abs_Unifloat(delta2);
        if(compare_Unifloat(delta2, delta1) == 1)
            put_Map(Delta, create_Integer(k), delta2);
        else
            put_Map(Delta, create_Integer(k), delta1);
    }
    CosmicDelta = bubblesort(Delta);
    Statistics = get_Map(CosmicDelta, create_Integer(size));
    Statistics = mul_Unifloat(Statistics, sqrt_Unifloat(convertInteger_Unifloat(size, 1)));

    //significance level epsilon = 0.001
    Bound = convertBinaryString_Unifloat(create_CString(
                                                       "1.1111001100010000110"
                                                       "001001000001001101111"
                                                       "000100010101111010101"
                                                       "010000001100101010101"
                                                       "10100011011010110"
                                                       ),1);

    if(compare_Unifloat(Statistics, Bound) == 1)
    {
        return false;
    }
    else
    {
        return true;
    }
}

/********************************************************************/
/**                      Helper Functions                          **/
/********************************************************************/

Map* bubblesort(Map* RandomSample)
{
    IntT i,j;
    Unifloat* elem1, * elem2, * tmp;
    Map* CosmicRandomSample = clone(RandomSample);
    for(i = size_Map(CosmicRandomSample); i > 0 ; i--)
    {
       for(j = 1 ; j < i ; j++)
       {
           elem1 = get_Map(CosmicRandomSample, create_Integer(j));
           elem2 = get_Map(CosmicRandomSample, create_Integer(j + 1));
           if(compare_Unifloat(elem1, elem2) == 1)
           {
                put_Map(CosmicRandomSample, create_Integer(j), clone(elem2));
                put_Map(CosmicRandomSample, create_Integer(j + 1), clone(elem1));
           }
       }
    }
    return CosmicRandomSample;
}
