/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "math/gamma/tests/gamma_scenario.seh"
#include "math/gamma/gamma_media.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "math/math/math_data.seh"
#include <stdio.h>

static CallContext context;
static VoidTPtr ptr;


/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_math_gamma_scenario(int argc, char** argv)
{
    // Init test scenario data
    context = getContext();  

    initReqFilters();

    ptr = allocateMemoryBlock(context, 1024);

    setFinishMode(UNTIL_END); 
    
    return true;
}
static void finish_math_gamma_scenario(void)
{
    deallocateMemoryBlock(context, ptr);
    TEST_SCENARIO_VERDICT_VERBOSE(gamma_scenario);
}
/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/
scenario bool gamma_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    IntT i, signgam = 0;
    UnifloatType type;
    Unifloat* max_val[3] = {max_FloatT, max_DoubleT, max_LongDoubleT};

    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[7] = { 
            convertString_Unifloat(create_CString("11.1323"), type),
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("-0.5"), type),
            clone(Nan[type]),
            convertInteger_Unifloat(1, type),
            convertInteger_Unifloat(2, type),
            clone(max_val[type])
            };

        for(i = 0; i<7; i++)
                gamma_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                   &signgam,
                                   requestErrorCode());
    }
    return true;    
}

scenario bool lgamma_lgamma_r_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    IntT i, signgam = 0;
    UnifloatType type;
    Unifloat* max_val[3] = {max_FloatT, max_DoubleT, max_LongDoubleT};

    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[9] = { 
            convertString_Unifloat(create_CString("11.1323"), type),
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("-0.5"), type),
            clone(Nan[type]),
            clone(Inf[type]),
            clone(Inf[type]),
            convertInteger_Unifloat(1, type),
            convertInteger_Unifloat(2, type),
            clone(max_val[type])
            };
        x[4]->sign = 1;
        x[5]->sign = -1;

        for(i = 0; i<9; i++)
        {
                lgamma_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                   &signgam,
                                   requestErrorCode());
                lgamma_r_spec(context, round_Unifloat(x[i], leng_num[type]), 
                                   &signgam,
                                   requestErrorCode());
        }
    }
    return true;    
}

scenario bool tgamma_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(min_FloatT), clone(min_DoubleT), clone(min_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    IntT i, signgam = 0;
    UnifloatType type;
    Unifloat* big_val[3] = {createOne_Unifloat(UniFloatT), 
                            createOne_Unifloat(UniDoubleT), 
                            createOne_Unifloat(UniLongDoubleT)};
    
    big_val[0]->exp = 12;
    big_val[1]->exp = 12;
    big_val[2]->exp = 12;

    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    for(type = 0; type < 3; type++)
    {
        Unifloat* x[7] = { 
            convertString_Unifloat(create_CString("10.1"), type),
            createZero_Unifloat(type),
            convertString_Unifloat(create_CString("-0.5"), type),
            clone(Nan[type]),
            clone(Inf[type]),
            clone(Inf[type]),
            clone(big_val[type])
            };
        x[4]->sign = 1;
        x[5]->sign = -1;

        for(i = 0; i<7; i++)
                tgamma_spec(context, round_Unifloat(x[i], leng_num[type]),
                                   requestErrorCode());
    }
    return true;    
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm math_gamma_scenario =
{
    .init = init_math_gamma_scenario,
    .finish = finish_math_gamma_scenario,
    .actions = {         
                    lgamma_lgamma_r_scen,
                    tgamma_scen,
                    gamma_scen,
                    NULL 
               }
};

bool main_math_gamma(int argc, char** argv)
{
    math_gamma_scenario(argc,argv);
    return true;
}

#include "math/gamma/tests/gamma_scenario.seh"
#include "math/math/math_data.seh"

#ifdef MATH_GAMMA_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "math/gamma/gamma_media.seh"
#include "math/math/math_data.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initMath();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initMathGammaSubsystem();
}

#ifdef WIN32

int main(int argc, char** argv)
{
    clock_t start, finish;
    double duration;
    
    initTestSystem();
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");

    
    start = clock();

    main_math_gamma(argc,argv);


    finish = clock();
    duration = (double) (finish - start) / CLOCKS_PER_SEC;

    verbose( "%2.3f seconds\n", duration );        
    
    
    
    //  unloadSUT();
    return 0;
}

#else

int main(int argc, char** argv)
{
    initTestSystem();
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");
    main_math_gamma(argc,argv);

    //  unloadSUT();
    return 0;
}

#endif

#endif

