 /*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "math/chyper/tests/chyper_scenario.seh"
#include "math/chyper/chyper_media.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "math/math/math_data.seh"
#include "math/math/math_config.h"
#include <stdio.h>

static CallContext context;
static VoidTPtr ptr;


/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_math_chyper_scenario(int argc, char** argv)
{
    // Init test scenario data
    context = getContext();  

    initReqFilters();

    ptr = allocateMemoryBlock(context, 1024);

    setFinishMode(UNTIL_END); 
    
    return true;
}
static void finish_math_chyper_scenario(void)
{
    deallocateMemoryBlock(context, ptr);
    TEST_SCENARIO_VERDICT_VERBOSE(chyper_scenario);
}
/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario 
bool cacosh_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    int type, i;
    int i1, i2, sign;
    UnifloatComplex* x, *res1, *res2;
    char st[3][10] = {"cacoshf", "cacosh", "cacoshl"};

    INIT_REQ_SCEN;
    for(type = 0; type < 3; type++)
    {
        Unifloat* par[4] = {
            clone(Nan[type]),
            clone(Inf[type]),
            createZero_Unifloat(type),
            createOne_Unifloat(type)
        };
        Unifloat* finite_par[4] = 
        {
            convertString_Unifloat(create_CString("0,5"), type),
            convertInteger_Unifloat(10, type),
            convertInteger_Unifloat(123, type),
            createOne_Unifloat(type)
        };
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
                for (sign = 1; sign > -2; sign-=2)
                {
                    x = create_UnifloatComplex(clone(par[i1]), clone(par[i2]));
                    x->Re->sign = sign * x->Re->sign;
                    res1 = clone(cacosh_spec(context, x));
                    x->Im->sign = (-1) * x->Im->sign;
                    res2 = clone(cacosh_spec(context, x));
                    if(CHECK_EXTENDED_REQ)
                    {
                        FILTER(st[type]);
                        /*
                         * cacosh(conj(z)) = conj(cacosh(z)), where conj(z) is the complex conjugate of z.
                         */
                        REQ_SCEN("cacosh.ext.03;cacoshf.ext.03;cacoshl.ext.03", 
                            "cacos(conj(z)) = conj(cacos(z)), where conj(z) is the complex conjugate of z",
                            compare_UnifloatComplex(res2, conj_model(res1)) == 0);
                        FILTER_CLEAN;
                    }
                }
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
                for (sign = 1; sign > -2; sign-=2)
                {
                    x = create_UnifloatComplex(clone(finite_par[i1]), clone(finite_par[i2]));
                    x->Re->sign = sign * x->Re->sign;
                    res1 = clone(cacosh_spec(context, x));
                    x->Im->sign = (-1) * x->Im->sign;
                    res2 = clone(cacosh_spec(context, x));
                    if(CHECK_EXTENDED_REQ)
                    {
                        FILTER(st[type]);
                        /*
                         * cacosh(conj(z)) = conj(cacosh(z)), where conj(z) is the complex conjugate of z.
                         */
                        REQ_SCEN("cacosh.ext.03;cacoshf.ext.03;cacoshl.ext.03", 
                            "cacos(conj(z)) = conj(cacos(z)), where conj(z) is the complex conjugate of z",
                            compare_UnifloatComplex(res2, conj_model(res1)) == 0);
                        FILTER_CLEAN;
                    }
                }
    }
    VERDICT_REQ_SCEN;
    return true;
}

scenario 
bool casinh_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    int type, i;
    int i1, i2, sign;
    UnifloatComplex* x, *res1, *res2, *res3, *res4;
    char st[3][10] = {"casinhf", "casinh", "casinhl"};

    INIT_REQ_SCEN;
    for(type = 0; type < 3; type++)
    {
        int mant = digMant_Unifloat(type);
        Unifloat* par[4] = {
            clone(Nan[type]),
            clone(Inf[type]),
            createZero_Unifloat(type),
            createOne_Unifloat(type)
        };
        Unifloat* finite_par[4] = 
        {
            convertString_Unifloat(create_CString("0,5"), type),
            convertInteger_Unifloat(10, type),
            convertInteger_Unifloat(123, type),
            createOne_Unifloat(type)
        };
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(clone(par[i1]), clone(par[i2]));
                res1 = casinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = casinh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = casinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = casinh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * casinh(conj(z)) = conj(casinh(z)), where conj(z) is the complex conjugate of z.
                     */
                    REQ_SCEN("casinh.ext.03;casinhf.ext.03;casinhl.ext.03", 
                        "casinh(conj(z)) = conj(casinh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));

                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    /*
                     * and casinh is odd
                     */
                    REQ_SCEN("casinh.ext.04;casinhf.ext.04;casinhl.ext.04", 
                        "casinh is odd",
                        (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    FILTER_CLEAN;
                }
            }

        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(clone(finite_par[i1]), clone(finite_par[i2]));
                res1 = casinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = casinh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = casinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = casinh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * casinh(conj(z)) = conj(casinh(z)), where conj(z) is the complex conjugate of z.
                     */
                    REQ_SCEN("casinh.ext.03;casinhf.ext.03;casinhl.ext.03", 
                        "casinh(conj(z)) = conj(casinh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));

                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    /*
                     * and casinh is odd
                     */
                    REQ_SCEN("casinh.ext.04;casinhf.ext.04;casinhl.ext.04", 
                        "casinh is odd",
                        (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    FILTER_CLEAN;
                }
            }
    }
    VERDICT_REQ_SCEN;
    return true;
}
scenario 
bool catanh_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    int type, i;
    int i1, i2, sign;
    UnifloatComplex* x, *res1, *res2, *res3, *res4;
    char st[3][10] = {"catanhf", "catanh", "catanhl"};
    UnifloatComplex* argument;

    INIT_REQ_SCEN;        
    for(type = 0; type < 3; type++)
    {
        int mant = digMant_Unifloat(type);
        Unifloat* par[4] = {
            clone(Nan[type]),
            clone(Inf[type]),
            createZero_Unifloat(type),
            createOne_Unifloat(type)
        };
        Unifloat* finite_par[4] = 
        {
            convertString_Unifloat(create_CString("0,5"), type),
            convertInteger_Unifloat(10, type),
            convertInteger_Unifloat(123, type),
            createOne_Unifloat(type)
        };
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(clone(par[i1]), clone(par[i2]));
                res1 = catanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = catanh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = catanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = catanh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * catanh(conj(z)) = conj(catanh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("catanh.ext.03;catanhf.ext.03;catanhl.ext.03", 
                        "catanh(conj(z)) = conj(catanh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    /*
                     * and catanh is odd.
                     */
                    REQ_SCEN("catanh.ext.04;catanhf.ext.04;catanhl.ext.04", 
                        "catanh is odd",
                        (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    FILTER_CLEAN;
                }
            }

        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(finite_par[i1], finite_par[i2]);
                res1 = catanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = catanh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = catanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = catanh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * catanh(conj(z)) = conj(catanh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("catanh.ext.03;catanhf.ext.03;catanhl.ext.03", 
                        "catanh(conj(z)) = conj(catanh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    /*
                     * and catanh is odd.
                     */
                    REQ_SCEN("catanh.ext.04;catanhf.ext.04;catanhl.ext.04", 
                        "catanh is odd",
                        (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    FILTER_CLEAN;
                }
            }
    }

    VERDICT_REQ_SCEN;
}

scenario 
bool ccosh_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    int type, i;
    int i1, i2, sign;
    UnifloatComplex* x, *res1, *res2, *res3, *res4;
    char st[3][10] = {"ccoshf", "ccosh", "ccoshl"};

    INIT_REQ_SCEN;
    for(type = 0; type < 3; type++)
    {
        int mant = digMant_Unifloat(type);
        Unifloat* par[4] = {
            clone(Nan[type]),
            clone(Inf[type]),
            createZero_Unifloat(type),
            createOne_Unifloat(type)
        };
        Unifloat* finite_par[4] = 
        {
            convertString_Unifloat(create_CString("0,5"), type),
            convertInteger_Unifloat(10, type),
            convertInteger_Unifloat(123, type),
            createOne_Unifloat(type)
        };
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(par[i1], par[i2]);
                res1 = ccosh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = ccosh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = ccosh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = ccosh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * ccosh(conj(z)) = conj(ccosh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("ccosh.ext.03;ccoshf.ext.03;ccoshl.ext.03", 
                        "ccosh(conj(z)) = conj(ccosh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    /*
                     * and ccosh is even.
                     */
                    REQ_SCEN("ccosh.ext.04;ccoshf.ext.04;ccoshl.ext.04", 
                        "ccosh is even",
                        (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    FILTER_CLEAN;
                }
            }

        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(finite_par[i1], finite_par[i2]);
                res1 = ccosh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = ccosh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = ccosh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = ccosh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * ccosh(conj(z)) = conj(ccosh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("ccosh.ext.03;ccoshf.ext.03;ccoshl.ext.03", 
                        "ccosh(conj(z)) = conj(ccosh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    /*
                     * and ccosh is even.
                     */
                    REQ_SCEN("ccosh.ext.04;ccoshf.ext.04;ccoshl.ext.04", 
                        "ccosh is even",
                        (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    FILTER_CLEAN;
                }
            }
    }
    VERDICT_REQ_SCEN;
    return true;
}

scenario 
bool csinh_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    int type, i;
    int i1, i2, sign;
    UnifloatComplex* x, *res1, *res2, *res3, *res4;
    char st[3][10] = {"csinhf", "csinh", "csinhl"};

    INIT_REQ_SCEN;
    for(type = 0; type < 3; type++)
    {
        int mant = digMant_Unifloat(type);
        Unifloat* par[4] = {
            clone(Nan[type]),
            clone(Inf[type]),
            createZero_Unifloat(type),
            createOne_Unifloat(type)
        };
        Unifloat* finite_par[4] = 
        {
            convertString_Unifloat(create_CString("0,5"), type),
            convertInteger_Unifloat(10, type),
            convertInteger_Unifloat(123, type),
            createOne_Unifloat(type)
        };
        
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(clone(par[i1]), clone(par[i2]));
                res1 = csinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = csinh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = csinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = csinh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * csinh(conj(z)) = conj(csinh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("csinh.ext.03;csinhf.ext.03;csinhl.ext.03", 
                        "csinh(conj(z)) = conj(csinh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    if (!(isInfinity_Unifloat(res1->Re) && isNan_Unifloat(res1->Im)))
                    {
                        /*
                         * and csinh is odd.
                         */
                        REQ_SCEN("csinh.ext.04;csinhf.ext.04;csinhl.ext.04", 
                            "csinh is odd",
                            (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                            (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    }
                    FILTER_CLEAN;
                }
            }

        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(finite_par[i1], finite_par[i2]);
                res1 = csinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = csinh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = csinh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = csinh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * csinh(conj(z)) = conj(csinh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("csinh.ext.03;csinhf.ext.03;csinhl.ext.03", 
                        "csinh(conj(z)) = conj(csinh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    if (!(isInfinity_Unifloat(res1->Re) && isNan_Unifloat(res1->Im)))
                    {
                        /*
                         * and csinh is odd.
                         */
                        REQ_SCEN("csinh.ext.04;csinhf.ext.04;csinhl.ext.04", 
                            "csinh is odd",
                            (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                            (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    }
                    FILTER_CLEAN;
                }
            }
    }
    VERDICT_REQ_SCEN;
    return true;
}

scenario 
bool ctanh_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    int type, i;
    int i1, i2, sign;
    UnifloatComplex* x, *res1, *res2, *res3, *res4;
    char st[3][10] = {"ctanhf", "ctanh", "ctanhl"};

    INIT_REQ_SCEN;
    for(type = 0; type < 3; type++)
    {
        int mant = digMant_Unifloat(type);
        Unifloat* par[4] = {
            clone(Nan[type]),
            clone(Inf[type]),
            createZero_Unifloat(type),
            createOne_Unifloat(type)
        };
        Unifloat* finite_par[4] = 
        {
            convertString_Unifloat(create_CString("0,5"), type),
            convertInteger_Unifloat(10, type),
            convertInteger_Unifloat(123, type),
            createOne_Unifloat(type)
        };
        
        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(clone(par[i1]), clone(par[i2]));
                res1 = ctanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = ctanh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = ctanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = ctanh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * ctanh(conj(z)) = conj(ctanh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("ctanh.ext.03;ctanhf.ext.03;ctanhl.ext.03", 
                        "ctanh(conj(z)) = conj(ctanh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    if (!(isInfinity_Unifloat(res1->Re) && isNan_Unifloat(res1->Im)))
                    {
                        /*
                         * and ctanh is odd.
                         */
                        REQ_SCEN("ctanh.ext.04;ctanhf.ext.04;ctanhl.ext.04", 
                            "ctanh is odd",
                            (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                            (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    }
                    FILTER_CLEAN;
                }
            }

        for (i1 = 0; i1 < 4; i1++)
            for (i2 = 0; i2 < 4; i2++)
            {
                x = create_UnifloatComplex(finite_par[i1], finite_par[i2]);
                res1 = ctanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res2 = ctanh_spec(context, x);
                x->Re->sign = (-1) * x->Re->sign;
                res3 = ctanh_spec(context, x);
                x->Im->sign = (-1) * x->Im->sign;
                res4 = ctanh_spec(context, x);
                if(CHECK_EXTENDED_REQ)
                {
                    FILTER(st[type]);
                    /*
                     * ctanh(conj(z)) = conj(ctanh(z)), where conj(z) is the complex conjugate of z
                     */
                    REQ_SCEN("ctanh.ext.03;ctanhf.ext.03;ctanhl.ext.03", 
                        "ctanh(conj(z)) = conj(ctanh(z)), where conj(z) is the complex conjugate of z",
                        (compareWithPrecision_UnifloatComplex(res2, conj_model(res1), mant) == 0) &&
                        (compareWithPrecision_UnifloatComplex(res4, conj_model(res3), mant) == 0));
                    res1->Re->sign = (-1) * res1->Re->sign;
                    res1->Im->sign = (-1) * res1->Im->sign;
                    res2->Re->sign = (-1) * res2->Re->sign;
                    res2->Im->sign = (-1) * res2->Im->sign;
                    if (!(isInfinity_Unifloat(res1->Re) && isNan_Unifloat(res1->Im)))
                    {
                        /*
                         * and ctanh is odd.
                         */
                        REQ_SCEN("ctanh.ext.04;ctanhf.ext.04;ctanhl.ext.04", 
                            "ctanh is odd",
                            (compareWithPrecision_UnifloatComplex(res3, res1, mant) == 0) &&
                            (compareWithPrecision_UnifloatComplex(res4, res2, mant) == 0));
                    }
                    FILTER_CLEAN;
                }
            }
    }
    VERDICT_REQ_SCEN;
    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm math_chyper_scenario =
{
    .init = init_math_chyper_scenario,
    .finish = finish_math_chyper_scenario,
    .actions = {                
                    cacosh_scen,
                    casinh_scen,
                    catanh_scen,
                    ccosh_scen,
                    csinh_scen,
                    ctanh_scen,
                    NULL 
                }
};

bool main_math_chyper(int argc, char** argv)
{
    math_chyper_scenario(argc,argv);
    return true;
}

#include "math/chyper/tests/chyper_scenario.seh"
#include "math/math/math_data.seh"

#ifdef MATH_CHYPER_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "math/chyper/chyper_media.seh"
#include "math/math/math_data.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initMath();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initMathChyperSubsystem();
}

#ifdef WIN32

int main(int argc, char** argv)
{
    clock_t start, finish;
    double duration;
    
    initTestSystem();
    
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");

    start = clock();
    
    main_math_chyper(argc,argv);

    finish = clock();
    duration = (double) (finish - start) / CLOCKS_PER_SEC;

    verbose( "%2.3f seconds\n", duration );        
    
    
    
    //  unloadSUT();
    return 0;
}

#else

int main(int argc, char** argv)
{
    initTestSystem();
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");
    main_math_chyper(argc,argv);

    //  unloadSUT();
    return 0;
}

#endif

#endif

