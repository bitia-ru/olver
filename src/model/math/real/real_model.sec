/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "math/real/real_model.seh"
#include "math/real/real_config.h"

#pragma SEC subsystem real "math.real"



/*
   The group of functions 'math.real' consists of:
       ceil [2]
       ceilf [2]
       ceill [2]
       copysign [2]
       copysignf [2]
       copysignl [2]
       dremf [1]
       dreml [1]
       fabs [2]
       fabsf [2]
       fabsl [2]
       fdim [2]
       fdimf [2]
       fdiml [2]
       floor [2]
       floorf [2]
       floorl [2]
       fma [2]
       fmaf [2]
       fmal [2]
       fmax [2]
       fmaxf [2]
       fmaxl [2]
       fmin [2]
       fminf [2]
       fminl [2]
       fmod [2]
       fmodf [2]
       fmodl [2]
       llrint [2]
       llrintf [2]
       llrintl [2]
       llround [2]
       llroundf [2]
       llroundl [2]
       lrint [2]
       lrintf [2]
       lrintl [2]
       lround [2]
       lroundf [2]
       lroundl [2]
       modf [2]
       modff [2]
       modfl [2]
       nan [2]
       nanf [2]
       nanl [2]
       nearbyint [2]
       nearbyintf [2]
       nearbyintl [2]
       remainder [2]
       remainderf [2]
       remainderl [2]
       remquo [2]
       remquof [2]
       remquol [2]
       rint [2]
       rintf [2]
       rintl [2]
       round [2]
       roundf [2]
       roundl [2]
       trunc [2]
       truncf [2]
       truncl [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    ceil, ceilf, ceill - ceiling value function

SYNOPSIS

    #include <math.h>

    double ceil(double x);

    float ceilf(float x);

    long double ceill(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the smallest integral value not
    less than x.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, ceil(), ceilf(), and ceill() shall return the
    smallest integral value not less than x, expressed as a type double, float, or
    long double, respectively.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0 or ±Inf, x shall be returned.

    [XSI] If the correct value would cause overflow, a range error shall occur and
    ceil(), ceilf(), and ceill() shall return the value of the macro HUGE_VAL,
    HUGE_VALF, and HUGE_VALL, respectively.

ERRORS

    These functions shall fail if:

        Range Error [XSI] The result overflows.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling &
    amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception
    shall be raised.
*/

//This specification refers to: ceilf, ceil, ceill
specification
Unifloat* ceil_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"ceilf", "ceil", "ceill"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input argument must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if(x->kind == 2)
            return {ISNORMAL_ARGUMENT, "The argument is finite value" };
        if(x->kind == 1)
            return {ISNAN_ARGUMENT, "The argument is NaN" };
        if(x->kind == 0)
            return {ISINFINITY_ARGUMENT, "The argument is infinity" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = ceil_model(x);

        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(ceil_spec, mant[x->type]);

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct value would cause overflow, a range error
             * shall occur and ceil(), ceilf(), and ceill() shall return
             * the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL,
             * respectively.
             */
            REQ("ceil.07;ceilf.07;ceill.07",
                "If the correct value would cause overflow, "
                "HUGE_VAL should be returned", isInfinity_Unifloat(ceil_spec));
        }

        /*
         * These functions shall fail if:
         *
         * Range Error [XSI] The result overflows.
         */
        ERROR_BEGIN(POSIX_CEIL,
                    "ceil.08.01.01;ceilf.08.01.01;ceill.08.01.01",
                    *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Range Error [XSI] The result overflows.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
             * errno shall be set to [ERANGE].
             */
            ERROR_SHALL(POSIX_CEIL, ERANGE,
                        "ceil.08.01.01;ceilf.08.01.01;ceill.08.01.01",
                        isOverflow_Unifloat(model_res))

        ERROR_END()

        /*
         * Upon successful completion, ceil(), ceilf(), and ceill() shall
         * return the smallest integral value not less than x, expressed
         * as a type double, float, or long double, respectively.
         */
        REQ("ceil.04;ceilf.04;ceill.04",
            "It shall return the smallest integral value not less than x",
            compare_Unifloat(model_res, ceil_spec) == 0);

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x))
        {
            /*
             * [MX] If x is NaN, a NaN shall be returned.
             */
            REQ("ceil.05;ceilf.05;ceill.05",
                "If x is NaN, a NaN shall be returned",
                isNan_Unifloat(ceil_spec));
        }
#endif

        if (isZero_Unifloat(x) || isInfinity_Unifloat(x))
        {
            /*
             * If x is ±0 or ±Inf, x shall be returned.
             */
            REQ("ceil.06;ceilf.06;ceill.06",
                "If x is ±0 or ±Inf, x shall be returned",
                compare_Unifloat(x, ceil_spec) == 0);
        }



        return true;
    }
    FILTER_CLEAN;
}

Unifloat* ceil_model(Unifloat* x)
{
    IntT i, type = x->type;
    Unifloat* res = clone(x);

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || isZero_Unifloat(x))
        return res;

    if (x->exp<=0)
        if (x->sign == 1)
            return createOne_Unifloat(x->type);
        else
            return createZero_Unifloat(x->type);

    for(i = x->exp + 1; i < PRECISION + 1; i++)
        setMant_Unifloat(res, i, 0);

    if((x->sign == 1) && (compare_Unifloat(x, res) != 0))
        res = add_Unifloat(res, convertInteger_Unifloat(1, type));

    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    copysign, copysignf, copysignl - number manipulation function

SYNOPSIS

    #include <math.h>

    double copysign(double x, double y);

    float copysignf(float x, float y);

    long double copysignl(long double x, long double y);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall produce a value with the magnitude of x
    and the sign of y. On implementations that represent a signed zero but do not
    treat negative zero consistently in arithmetic operations, these functions
    regard the sign of zero as positive.

RETURN VALUE

    Upon successful completion, these functions shall return a value with the
    magnitude of x and the sign of y.

ERRORS

    No errors are defined.
*/

//This specification refers to: copysignf, copysingn, copysignl
specification
Unifloat* copysign_spec(CallContext context, Unifloat* x, Unifloat* y)
{
    char type[3][10] = {"copysignf", "copysign", "copysignl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input argument must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (y->sign == 1)
        {
            if (isNan_Unifloat(x))
                return {Pos_NaN_arg, "Sign of y is positive, x is NaN"};
            if (isInfinity_Unifloat(x))
                return {Pos_Inf_arg, "Sign of y is positive, x is infinity"};
            if (isNormal_Unifloat(x))
                return {Pos_Norm_arg,
                                "Sign of y is positive, x is finite value"};
        }
        else
        {
            if (isNan_Unifloat(x))
                return {Neg_NaN_arg, "Sign of y is negative, x is NaN"};
            if (isInfinity_Unifloat(x))
                return {Neg_Inf_arg, "Sign of y is negative, x is infinity"};
            if (isNormal_Unifloat(x))
                return {Neg_Norm_arg,
                                "Sign of y is negative, x is finite value"};
        }
    }
    post
    {
//        if ((ARITHMATIC_WITHOUT_NEGATIVE_ZERO) && (isZero_Unifloat(y)))
//            y->sign = 1;

        normalize_Unifloat(copysign_spec);

        /*
         * Upon successful completion, these functions shall return a
         * value with the magnitude of x and the sign of y.
         */

        REQ("copysign.03;copysignf.03;copysignl.03",
           "It shall return a value with the magnitude of x and the sign of y",
          (compare_Unifloat(abs_Unifloat(copysign_spec), abs_Unifloat(x)) == 0)
          && ( copysign_spec->sign == y->sign) );


        return true;
    }
    FILTER_CLEAN;
}

/*
NAME

    dreml -- remainder function

SYNOPSIS

    float dreml(float arg);

DESCRIPTION

    dreml() has the same specification as remainderl() in ISO POSIX (2003).

    dreml() is not in the source standard; it is only in the binary standard.
*/

//This specification refers to: dremf, drem, dreml
specification
Unifloat* drem_spec(CallContext context, Unifloat* x, Unifloat* y, ErrorCode* errno)
{
    char type[3][10] = {"dremf","drem", "dreml"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        return true;
    }
    coverage C
    {
        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
            return { NORMAL_CASE_Y_NOT_ZERO,
            "x and y are normal, y is not null" };

        if(isNan_Unifloat(x))
            return { X_IS_NAN, "x is NaN"};

        if(isNan_Unifloat(y))
            return { Y_IS_NAN, "y is NaN"};

        if((isInfinity_Unifloat(x) && !isNan_Unifloat(y)))
            return { X_INF_Y_NOT_NAN,
            "x is infinite and y is non-NaN"};
        if(isZero_Unifloat(y) && !isNan_Unifloat(x))
            return { Y_NULL_X_NOT_NAN,
            "y is 0 and x is non-NaN"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = remainder_model(x, y);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
         * decreased to mantissa in appropriate type]*/
        round_Unifloat(drem_spec, mant[x->type]);

#if NAN_SUPPORT == 1
        if((isInfinity_Unifloat(x) && !isNan_Unifloat(y)) ||
            (isZero_Unifloat(y) && !isNan_Unifloat(x)))
        {
            /*
             * If x is infinite or y is 0 and the other is non-NaN,
             * a domain error shall occur, and either a NaN (if supported),
             * or an implementation-defined value shall be returned.
             */
            REQ("dremf.remainderf.05;dreml.remainderl.05",
            "If x is infinite or y is 0 and the other is non-NaN a NaN "
            "shall be returned",
            isNan_Unifloat(drem_spec));
        }
#endif
        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is ±Inf, or the y argument
         * is ±0 and the other argument is non-NaN.
         */
        ERROR_BEGIN(POSIX_REMAINDER,
            "dremf.remainderf.06.01.01;dreml.remainderl.06.01.01",
            *errno, *errno)
            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is ±Inf, or the y argument
             * is ±0 and the other argument is non-NaN.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO)
             * is non-zero, then errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_REMAINDER, EDOM,
            "dremf.remainderf.06.01.01;dreml.remainderl.06.01.01",
            (isInfinity_Unifloat(x) && !isNan_Unifloat(y)) ||
            (isZero_Unifloat(y) && !isNan_Unifloat(x)))

        ERROR_END()

        /*
         * The behavior of remainder() shall be independent
         * of the rounding mode.
         */
        REQ("dremf.remainderf.02;dreml.remainderl.02", "", TODO_REQ());

        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
        {
            /*
             * Upon successful completion, these functions shall return the
             * floating-point remainder r= x- ny when y is non-zero.
             */
            REQ("remainder.03;dremf.remainderf.03;dreml.remainderl.03",
            "functions shall return the floating-point remainder r= x- ny "
            "when y is non-zero",
            compare_Unifloat(drem_spec, model_res) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x) || isNan_Unifloat(y))
        {
            /*
             * [MX] If x or y is NaN, a NaN shall be returned.
             */
            REQ("dremf.remainderf.04;dreml.remainderl.04",
            "If x or y is NaN, a NaN shall be returned",
            isNan_Unifloat(drem_spec));
        }
#endif


        return true;
    }
    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    fabs, fabsf, fabsl - absolute value function

SYNOPSIS

    #include <math.h>

    double fabs(double x);

    float fabsf(float x);

    long double fabsl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the absolute value of their
    argument x,| x|.

RETURN VALUE

    Upon successful completion, these functions shall return the absolute value of
    x.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0, +0 shall be returned.

    If x is ±Inf, +Inf shall be returned.

ERRORS

    No errors are defined.
*/

//This specification refers to: fabsf, fabs, fabsl
specification
Unifloat* fabs_spec(CallContext context, Unifloat* x)
{
    char type[3][10] = {"fabsf", "fabs", "fabsl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input argument must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {arg_Nan, "The argument is Nan"};
        else
            if (isInfinity_Unifloat(x))
                return {arg_Inf, "The argument is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {arg_zero, "The argument is zero"};
                else
                    return {arg_norm, "The argument is finite non-zero value"};

    }
    post
    {
        normalize_Unifloat(fabs_spec);

        if (isNormal_Unifloat(x) && !isZero_Unifloat(x))
        {
            /*
             * Upon successful completion, these functions shall return the
             * absolute value of x.
             */
            REQ("fabs.02;fabsf.02;fabsl.02",
                "It shall return the absolute value of x",
                compare_Unifloat(abs_Unifloat(x), fabs_spec) == 0);
        }

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x))
        {
            /*
             * If x is NaN, a NaN shall be returned.
             */
            REQ("fabs.03;fabsf.03;fabsl.03",
                "If x is NaN, a NaN shall be returned",
                isNan_Unifloat(fabs_spec));
        }
#endif

        if (isZero_Unifloat(x))
        {
            /*
             * If x is ±0, +0 shall be returned.
             */
            REQ("fabs.04;fabsf.04;fabsl.04",
                "If x is ±0, +0 shall be returned",
                isZero_Unifloat(fabs_spec) && (fabs_spec->sign == 1));
        }

        if (isInfinity_Unifloat(x))
        {
            /*
             * If x is ±Inf, +Inf shall be returned.
             */
            REQ("fabs.05;fabsf.05;fabsl.05",
                "If x is ±Inf, +Inf shall be returned",
                isInfinity_Unifloat(fabs_spec) && (fabs_spec->sign == 1));
        }



        return true;
    }
    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    fdim, fdimf, fdiml - compute positive difference between two floating-point
    numbers

SYNOPSIS

    #include <math.h>

    double fdim(double x, double y);

    float fdimf(float x, float y);

    long double fdiml(long double x, long double y);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall determine the positive difference between
    their arguments. If x is greater than y, x- y is returned. If x is less than or
    equal to y, +0 is returned.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the positive
    difference value.

    If x- y is positive and overflows, a range error shall occur and fdim(),
    fdimf(), and fdiml() shall return the value of the macro HUGE_VAL, HUGE_VALF,
    and HUGE_VALL, respectively.

    If x- y is positive and underflows, a range error may occur, and either ( x- y)
    (if representable), [XSI] or 0.0 (if supported), or an implementation-defined
    value shall be returned.

    [MX] If x or y is NaN, a NaN shall be returned.

ERRORS

    The fdim() function shall fail if:

        Range Error The result overflows.

    ">If the integer expression (math_errhandling & MATH_ERRNO) is non-zero,
    then errno shall be set to [ERANGE]. If the integer expression
    (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-
    point exception shall be raised.

    The fdim() function may fail if:

        Range Error The result underflows.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling &
    amp; MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
    shall be raised.
*/

//This specification refers to: fdimf, fdim, fdiml
specification
Unifloat* fdim_spec(CallContext context, Unifloat* x, Unifloat* y,
                    ErrorCode* errno)
{
    char type[3][10] = {"fdimf", "fdim", "fdiml"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x) || isNan_Unifloat(y))
            return {Nan_Nan, "x or y is NaN"};
        else
            if (isInfinity_Unifloat(x))
            {
                if (isInfinity_Unifloat(y))
                    return {Inf_Inf, "x and y are infinity"};
                else
                    return {Inf_Norm, "x is infinity, y - finite value"};
            }
            else
                if (isInfinity_Unifloat(y))
                    return {Norm_Inf, "x - finite value, y - infinity"};
                else
                    return {Norm_Norm, "x and y - finite values"};

    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        Unifloat* model_res = fdim_model(x, y);

        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(fdim_spec, mant[x->type]);
        normalize_Unifloat(fdim_spec);

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If x- y is positive and overflows, a range error shall occur and
             * fdim(), fdimf(), and fdiml() shall return the value of the macro
             * HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
             */
            REQ("fdim.05;fdimf.05;fdiml.05",
                "If x- y is positive and overflows, HUGE_VAL should be returned",
                isInfinity_Unifloat(fdim_spec) && (fdim_spec->sign == 1));
        }

        if (isUnderflow_Unifloat(model_res))
        {
            /*
             * If x- y is positive and underflows, a range error may occur,
             * and either ( x- y) (if representable), [XSI] or 0.0
             * (if supported), or an implementation-defined value
             * shall be returned.
             */
            REQ("fdim.06;fdimf.06;fdiml.06",
                "If x- y is positive and underflows, "
                "either (x- y) or 0.0 shall be returned",
                isZero_Unifloat(fdim_spec) ||
                (compare_Unifloat(fdim_spec, sub_Unifloat(x, y)) == 0));
        }

        /*
         * The fdim() function shall fail if:
         *
         * Range Error The result overflows.
         *
         * The fdim() function may fail if:
         *
         * Range Error The result underflows.
         */
        ERROR_BEGIN( POSIX_FDIM, "fdim.08.01.01;fdimf.08.01.01;fdiml.08.01.01;fdim.09.01.01;fdimf.09.01.01;fdiml.09.01.01",
                     *errno, *errno
                   )
            /*
             * The fdim() function shall fail if:
             *
             * Range Error The result overflows.
             *
             * ">If the integer expression (math_errhandling & MATH_ERRNO)
             * is non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_SHALL
                ( POSIX_FDIM, ERANGE, "fdim.08.01.01;fdimf.08.01.01;fdiml.08.01.01", isOverflow_Unifloat( model_res ) )

            /*
             * The fdim() function may fail if:
             *
             * Range Error The result underflows.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO)
             * is non-zero, then errno shall be set to [ERANGE].
             */
            traceUserInfo( isOverflow_Unifloat( model_res ) ? "fdim_model( x, y ) is overflow"
                                                            : "fdim_model( x, y ) is not overflow"
                         );
            if ( ! isOverflow_Unifloat( model_res ) ) {
                ERROR_MAY
                    ( POSIX_FDIM, ERANGE, "fdim.09.01.01;fdimf.09.01.01;fdiml.09.01.01", isUnderflow_Unifloat( model_res ) )
            }
        ERROR_END()

        /*
         * Upon successful completion, these functions shall return the positive
         * difference value.
         */
        REQ("fdim.04;fdimf.04;fdiml.04",
            "It shall return the positive difference value",
            compare_Unifloat(model_res, fdim_spec) == 0);

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x) || isNan_Unifloat(y))
        {
            /*
             * If x or y is NaN, a NaN shall be returned.
             */
            REQ("fdim.07;fdimf.07;fdiml.07",
                "If x or y is NaN, a NaN shall be returned",
                isNan_Unifloat(fdim_spec));
        }
#endif

        return true;
    }
    FILTER_CLEAN;
}

Unifloat* fdim_model(Unifloat* x, Unifloat* y)
{
    Unifloat* res;
    if (isNan_Unifloat(x) || isNan_Unifloat(y))
    {
        res =createOne_Unifloat( x->type);
        res->kind = NaN;
        return res;
    }
    if (compare_Unifloat(x, y) == 1)
        return sub_Unifloat(x, y);
    else
        return createZero_Unifloat( x->type);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    floor, floorf, floorl - floor function

SYNOPSIS

    #include <math.h>

    double floor(double x);

    float floorf(float x);

    long double floorl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall compute the largest integral value not
    greater than x.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the largest integral
    value not greater than x, expressed as a double, float, or long double, as
    appropriate for the return type of the function.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0 or ±Inf, x shall be returned.

    [XSI] If the correct value would cause overflow, a range error shall occur and
    floor(), floorf(), and floorl() shall return the value of the macro -HUGE_VAL, -
    HUGE_VALF, and -HUGE_VALL, respectively.

ERRORS

    These functions shall fail if:

        Range Error [XSI] The result would cause an overflow.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling &
    amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception
    shall be raised.
*/

//This specification refers to: floorf, floor, floorl
specification
Unifloat* floor_spec( CallContext context, Unifloat* value, ErrorCode* errno)
{
    char type[3][10] = {"floorf", "floor", "floorl"};

    FILTER(type[value->type]);

    pre
    {
        /* [Input argument must be not Null] */
        REQ("", "value isn't Null", value != NULL);

        return true;
    }
    coverage C
    {
        if(value->kind == 2)return {ISNORMAL_ARGUMENT, "ISNORMAL ARGUMENT" };
        if(value->kind == 1)return {ISNAN_ARGUMENT, "ISNAN ARGUMENT" };
        if(value->kind == 0)return {ISINFINITY_ARGUMENT, "ISINFINITY ARGUMENT" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        Unifloat* model_res = floor_Unifloat(value);

        round_Unifloat(model_res, mant[value->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(floor_spec, mant[value->type]);
             
        if(isOverflow_Unifloat(model_res)&&(!isInfinity_Unifloat(value)))
        {
            /*
            * [XSI] If the correct value would cause overflow, a range error 
            * shall occur and floor(), floorf(), and floorl() shall 
            * return the value of the macro -  HUGE_VAL,
            * -HUGE_VALF, and -HUGE_VALL, respectively.
            */
            REQ("floor.07;floorf.07;floorl.07", 
                "If the correct value would cause overflow, "
                "HUGE_VAL should be returned",
                isInfinity_Unifloat(floor_spec));
        }

        /*
         * These functions shall fail if:
         *
         * Range Error 
         * [XSI] The result would cause an overflow.
         */
        ERROR_BEGIN( POSIX_FLOOR, "floor.08.01.01;floorf.08.01.01;"
            "floorl.08.01.01", *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Range Error 
             * [XSI] The result would cause an overflow.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then  errno shall be set to [ERANGE].
             */
            ERROR_SHALL(POSIX_FLOOR, ERANGE, 
                        "floor.08.01.01;floorf.08.01.01;floorl.08.01.01",
                        isOverflow_Unifloat(floor_spec) &&
                        (!isInfinity_Unifloat(value)))

        ERROR_END()
        
        /*
        * Upon successful completion, these functions shall return the largest 
        * integral  value not greater than x, expressed as a double, float,
        * or long double, as  appropriate for the return type of the function.
        */
        REQ("floor.04;floorf.04;floorl.04",
            "It compare results of model and target functions", 
            compare_Unifloat(floor_spec, model_res) == 0);

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(value))
        {
            /*
            * [MX] If x is NaN, a NaN shall be returned.
            */
            REQ("floor.05;floorf.05;floorl.05",
                "If x is NaN, a NaN shall be returned", 
                isNan_Unifloat(floor_spec));
        }
#endif

        if(isZero_Unifloat(value) || isInfinity_Unifloat(value))
        {
            /*
            * If x is 0 or Inf, x shall be returned.
            */
            REQ("floor.06;floorf.06;floorl.06",
                "If x is 0 or Inf, x shall be returned", 
                compare_Unifloat(value, floor_spec) == 0);
        }
             
 
        
        return true;
    }
    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    fma, fmaf, fmal - floating-point multiply-add 

SYNOPSIS

    #include <math.h>

    double fma(double x, double y, double z);

    float fmaf(float x, float y, float z);

    long double fmal(long double x, long double y, long double z);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. These functions shall compute (x * y) + z, rounded as one 
    ternary operation: they shall compute the value (as if) to infinite precision 
    and round once to the result format, according to the rounding mode 
    characterized by the value of FLT_ROUNDS.

    An application wishing to check for error situations should set errno to zero 
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On 
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO | 
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return (x * y) + z, rounded 
    as one ternary operation.

    [MX] If x or y are NaN, a NaN shall be returned.

    If x multiplied by y is an exact infinity and z is also an infinity but with 
    the opposite sign, a domain error shall occur, and either a NaN (if supported), 
    or an implementation-defined value shall be returned.

    If one of x and y is infinite, the other is zero, and z is not a NaN, a domain 
    error shall occur, and either a NaN (if supported), or an implementation- 
    defined value shall be returned.

    If one of x and y is infinite, the other is zero, and z is a NaN, a NaN shall 
    be returned and a domain error may occur.

    If x* y is not 0*Inf nor Inf*0 and z is a NaN, a NaN shall be returned. 

ERRORS

    These functions shall fail if:

        Domain Error [MX] The value of x* y+ z is invalid, or the value x* y is invalid 
        and z is not a NaN. 

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [EDOM]. If the integer expression (math_errhandling & 
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be 
    raised. 

        Range Error [MX] The result overflows. 

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling & 
    amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception 
    shall be raised. 

    These functions may fail if:

        Domain Error [MX] The value x* y is invalid and z is a NaN.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [EDOM]. If the integer expression (math_errhandling & 
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be 
    raised. 

        Range Error [MX] The result underflows.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling & 
    amp; MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception 
    shall be raised.
*/

//This specification refers to: fmaf, fma, fmal
specification
Unifloat* fma_spec( CallContext context, Unifloat* x, Unifloat* y, Unifloat* z, ErrorCode* errno)
{
    char type[3][10] = {"fmaf", "fma", "fmal"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x, y and z aren't Null", (x != NULL) && (y != NULL) && (z != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x, y and z have the same type", (x->type == y->type) && (x->type == z->type));

        return true;
    }
    coverage C
    {
        if(isNormal_Unifloat(x) && isNormal_Unifloat(y) &&
           isNormal_Unifloat(z))
            return {case_1, "normal case" };

        if(isNan_Unifloat(x)||isNan_Unifloat(y))
            return {case_2, "x or y are NaN" };

        if(isInfinity_Unifloat(mul_Unifloat(x, y)) && 
            isInfinity_Unifloat(z) && 
            (z->sign == -1*(x->sign)*(y->sign)))
            return {case_3, "x*y is infinity and z is infinity"
                            "with the opposite sign" };

        if(((isInfinity_Unifloat(x) && 
            isZero_Unifloat(y)) || (isInfinity_Unifloat(y) && 
            isZero_Unifloat(x))) && !isNan_Unifloat(z))
            return {case_4, "If one of x and y is infinite, the other is zero,"
                            "and z is not a NaN" };

        if(((isInfinity_Unifloat(x) && isZero_Unifloat(y)) || 
            (isInfinity_Unifloat(y) && isZero_Unifloat(y))) && 
            isNan_Unifloat(z))
            return {case_5, "If one of x and y is infinite, the other is zero,"
                            "and z is a NaN" };

        if((!(isInfinity_Unifloat(x) && isZero_Unifloat(y)) && 
            !(isInfinity_Unifloat(y) && isZero_Unifloat(y))) && 
            isNan_Unifloat(z))
            return {case_6, "If x* y is not 0*Inf nor Inf*0 and z is a NaN" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = fma_model(x, y, z);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
        * decreased to mantissa in appropriate type]*/
        round_Unifloat(fma_spec, mant[x->type]);

#if NAN_SUPPORT == 1
        if(isInfinity_Unifloat(mul_Unifloat(x, y)) && 
            isInfinity_Unifloat(z) && (z->sign == -1*x->sign*y->sign))
        {
            /*
             * If x multiplied by y is an exact infinity and z is also an 
             * infinity but with the opposite sign, a domain error shall occur, 
             * and either a NaN (if supported), or an implementation-defined 
             * value shall be returned.
             */
            REQ("fma.06;fmaf.06;fmal.06", 
            "If x multiplied by y is an exact infinity and z is an "
            " infinity but with the opposite sign, domain error shall occur", 
             isNan_Unifloat(fma_spec) != 0);
        }

        if(((isInfinity_Unifloat(x) && isZero_Unifloat(y)) || 
            (isInfinity_Unifloat(y) && 
            isZero_Unifloat(x))) && !isNan_Unifloat(z))
        {
            /*
             * If one of x and y is infinite, the other is zero, and z is 
             * not a NaN, a domain 
             * error shall occur, and either a NaN (if supported), or an 
             * implementation-defined value shall be returned.
             */
            REQ("fma.07;fmaf.07;fmal.07", 
                "If one of x and y is infinite, the other is zero, and z is "
                " not a NaN, a domain error shall occur",
                isNan_Unifloat(fma_spec));
        }

        if(((isInfinity_Unifloat(x) && isZero_Unifloat(y)) || 
            (isInfinity_Unifloat(y) && 
            isZero_Unifloat(y))) && isNan_Unifloat(z))
        {
            /*
             * If one of x and y is infinite, the other is zero, and z is a NaN, 
             * a NaN shall be returned and a domain error may occur.
             */
            REQ("fma.08;fmaf.08;fmal.08", 
            "If one of x and y is infinite, the other is zero, and z is a NaN,"
            "a NaN shall be returned", isNan_Unifloat(fma_spec));
        }

#endif

        /*
         * These functions shall fail if:
         *
         *
         * Range Error [MX] The result overflows.
         */
        ERROR_BEGIN(POSIX_FMA, "fma.10.01.01;fmaf.10.01.01;fmal.10.01.01",
                    *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The value of x* y+ z is invalid, 
             * or the value x* y is invalid 
             * and z is not a NaN.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then 
             * errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_FMA, EDOM, 
                        "fma.10.01.01;fmaf.10.01.01;fmal.10.01.01", 
                        TODO_ERR(EDOM) )

            /*
             * These functions shall fail if:
             *
             * Range Error [MX] The result overflows.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then 
             * errno shall be set to [ERANGE].
             */
            ERROR_SHALL(POSIX_FMA, ERANGE, 
                        "fma.10.02.01;fmaf.10.02.01;fmal.10.02.01", 
                        isOverflow_Unifloat(fma_spec))

            /*
             * These functions may fail if:
             *
             * Domain Error [MX] The value x* y is invalid and z is a NaN.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then 
             * errno shall be set to [EDOM].
             */
            ERROR_MAY(POSIX_FMA, EDOM, 
                      "fma.11.01.01;fmaf.11.01.01;fmal.11.01.01", 
                      TODO_ERR(EDOM))

            /*
             * These functions may fail if:
             *
             * Domain Error [MX] The value x* y is invalid and z is a NaN.
             *
             * If the integer expression (math_errhandling & MATH_ERREXCEPT) 
             * is non-zero, 
             * then the invalid floating-point exception shall be raised.
             */
            /*
             * These functions may fail if:
             *
             * Range Error [MX] The result underflows.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then 
             * errno shall be set to [ERANGE].
             */
            ERROR_MAY(POSIX_FMA, ERANGE, 
                      "fma.11.02.01;fmaf.11.02.01;fmal.11.02.01",
                      isUnderflow_Unifloat(fma_spec))
        ERROR_END()

        if(isNormal_Unifloat(x) && isNormal_Unifloat(y) &&
           isNormal_Unifloat(z))
        {
            /*
             * Upon successful completion, these functions shall return 
             * (x * y) + z, rounded as one ternary operation.
             */
            REQ("fma.04;fmaf.04;fmal.04", 
                "It shal return (x * y) + z", 
                compare_Unifloat(fma_spec, model_res) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x) || isNan_Unifloat(y))
        {
            /*
             * [MX] If x or y are NaN, a NaN shall be returned.
             */
            REQ("fma.05;fmaf.05;fmal.05", 
                "If x or y are NaN, a NaN shall be returned",
                isNan_Unifloat(fma_spec));
        }  
    
        if((!(isInfinity_Unifloat(x) && isZero_Unifloat(y))
            && !(isInfinity_Unifloat(y) && 
            isZero_Unifloat(y))) && isNan_Unifloat(z))
        {
            /*
             * If x* y is not 0*Inf nor Inf*0 and z is a NaN, 
             * a NaN shall be returned.
             */
            REQ("fma.09;fmaf.09;fmal.09", 
            "If x* y is not 0*Inf nor Inf*0 and z is a NaN," 
            "a NaN shall be returned.", isNan_Unifloat(fma_spec));
        }
#endif

   

        return true;
    }
    FILTER_CLEAN;
}

Unifloat* fma_model(Unifloat* x, Unifloat* y, Unifloat* z)
{
    return add_Unifloat(mul_Unifloat(x, y), z);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    fmax, fmaxf, fmaxl - determine maximum numeric value of two floating-point 
    numbers 

SYNOPSIS

    #include <math.h>

    double fmax(double x, double y);

    float fmaxf(float x, float y);

    long double fmaxl(long double x, long double y);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. These functions shall determine the maximum numeric value of 
    their arguments. NaN arguments shall be treated as missing data: if one 
    argument is a NaN and the other numeric, then these functions shall choose the 
    numeric value.

RETURN VALUE

    Upon successful completion, these functions shall return the maximum numeric 
    value of their arguments.

    If just one argument is a NaN, the other argument shall be returned.

    [MX] If x and y are NaN, a NaN shall be returned. 

ERRORS

    No errors are defined.

*/

//This specification refers to: fmaxf, fmax, fmaxl
specification
Unifloat* fmax_spec( CallContext context, Unifloat* x, Unifloat* y)
{
    
    char type[3][10] = {"fmaxf", "fmax", "fmaxl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        return true;
    }
    
    coverage C
    {
        if(!isNan_Unifloat(x) && !isNan_Unifloat(y))
            return { NORMAL_CASE, "x is not nan and y is not nan" };

        if(!isNan_Unifloat(x) && isNan_Unifloat(y))
            return { x_IS_NORMAL_y_IS_NAN, "x is not nan and y is nan" };

        if(!isNan_Unifloat(y) && isNan_Unifloat(x))
            return { x_IS_NAN_y_IS_NORMAL, "x is nan and y is not nan" };
        
        if(isNan_Unifloat(y) && isNan_Unifloat(x))
            return { x_IS_NAN_y_IS_NAN, "x is nan and y is nan" };
    }
    
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = fmax_model(x, y);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
        * decreased to mantissa in appropriate type]*/
        round_Unifloat(fmax_spec, mant[x->type]);

#if NAN_SUPPORT == 1
        if((!isNan_Unifloat(x) && isNan_Unifloat(y)) || 
            (isNan_Unifloat(x) && !isNan_Unifloat(y)))
        {
            /*
             * NaN arguments shall be treated as missing data: 
             * if one argument is a NaN and the other numeric, 
             * then these functions shall choose the numeric value.
             */
            REQ("fmax.02;fmaxf.02;fmaxl.02", 
            "If one argument is a NaN and the other numeric, functions"
            " shall choose the numeric value", 
            ((!isNan_Unifloat(x) && isNan_Unifloat(y) && 
            !compare_Unifloat(x, fmax_spec)) || (isNan_Unifloat(x) && 
            !isNan_Unifloat(y) && !compare_Unifloat(y, fmax_spec))) );
        }
#endif

        if(!isNan_Unifloat(x) && !isNan_Unifloat(y))
        {
            /*
             * Upon successful completion, these functions shall 
             * return the maximum numeric value of their arguments.
             */
            REQ("fmax.03;fmaxf.03;fmaxl.03", 
                "functions shall return the maximum numeric"
                " value of their arguments", 
                !compare_Unifloat(fmax_spec, model_res));
        }

#if NAN_SUPPORT == 1
        if((!isNan_Unifloat(x) && isNan_Unifloat(y)) || 
            (isNan_Unifloat(x) && !isNan_Unifloat(y)))
        {
            /*
             * If just one argument is a NaN, the other argument shall be returned.
             */
            REQ("fmax.04;fmaxf.04;fmaxl.04", 
            "If just one argument is a NaN, the other argument shall be returned", 
            ((!isNan_Unifloat(x) && isNan_Unifloat(y) && 
            !compare_Unifloat(x, fmax_spec)) || (isNan_Unifloat(x) && 
            !isNan_Unifloat(y) && !compare_Unifloat(y, fmax_spec))));
        }

        if(isNan_Unifloat(x) && isNan_Unifloat(y))
        {
            /*
             * [MX] If x and y are NaN, a NaN shall be returned.
             */
            REQ("fmax.05;fmaxf.05;fmaxl.05", 
            "If x and y are NaN, a NaN shall be returned", 
            isNan_Unifloat(fmax_spec));
        }
#endif

     
        return true;
    }
    FILTER_CLEAN;
}

Unifloat* fmax_model(Unifloat* x, Unifloat* y)
{
    if(compare_Unifloat(x, y) != -1)
        return clone(x);
    else return clone(y);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    fmin, fminf, fminl - determine minimum numeric value of two floating-point
    numbers

SYNOPSIS

    #include <math.h>

    double fmin(double x, double y);

    float fminf(float x, float y);

    long double fminl(long double x, long double y);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall determine the minimum numeric value of
    their arguments. NaN arguments shall be treated as missing data: if one
    argument is a NaN and the other numeric, then these functions shall choose the
    numeric value.

RETURN VALUE

    Upon successful completion, these functions shall return the minimum numeric
    value of their arguments.

    If just one argument is a NaN, the other argument shall be returned.

    [MX] If x and y are NaN, a NaN shall be returned.

ERRORS

    No errors are defined.
*/

//This specification refers to: fminf, fmin, fminl
specification
Unifloat* fmin_spec(CallContext context, Unifloat* x, Unifloat* y)
{
    
    char type[3][10] = {"fminf", "fmin", "fminl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        return true;
    }
    
    coverage C
    {
        if(!isNan_Unifloat(x) && !isNan_Unifloat(y))
            return { X_AND_Y_IS_NOT_NAN, "x is not nan and y is not nan" };

        if(!isNan_Unifloat(x) && isNan_Unifloat(y))
            return { x_IS_NOT_NAN_y_IS_NAN, "x is not nan and y is nan" };

        if(!isNan_Unifloat(y) && isNan_Unifloat(x))
            return { x_IS_NAN_y_IS_NOT_NAN, "x is nan and y is not nan" };

        if(isNan_Unifloat(y) && isNan_Unifloat(x))
            return { x_IS_NAN_y_IS_NAN, "x is nan and y is nan" };
    }
    
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = fmin_model(x, y);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
        * decreased to mantissa in appropriate type]*/
        round_Unifloat(fmin_spec, mant[x->type]);

#if NAN_SUPPORT == 1
        if((!isNan_Unifloat(x) && isNan_Unifloat(y)) || 
            (isNan_Unifloat(x) && !isNan_Unifloat(y)))
        {
            /*
             * NaN arguments shall be treated as missing data: 
             * if one argument is a NaN and the other numeric, 
             * then these functions shall choose the numeric value.
             */
            REQ("fmin.02;fminf.02;fminl.02", 
            "If one argument is a NaN and the other numeric, functions"
            " shall choose the numeric value", 
            ((!isNan_Unifloat(x) && isNan_Unifloat(y) && 
            !compare_Unifloat(x, fmin_spec)) || (isNan_Unifloat(x) && 
            !isNan_Unifloat(y) && !compare_Unifloat(y, fmin_spec))) );
        }
#endif

        if(!isNan_Unifloat(x) && !isNan_Unifloat(y))
        {
            /*
             * Upon successful completion, these functions shall 
             * return the minimum numeric value of their arguments.
             */
            REQ("fmin.03;fminf.03;fminl.03", 
                "functions shall return the minimum numeric"
                " value of their arguments", 
                !compare_Unifloat(fmin_spec, model_res));
        }

#if NAN_SUPPORT == 1
        if((!isNan_Unifloat(x) && isNan_Unifloat(y)) || 
            (isNan_Unifloat(x) && !isNan_Unifloat(y)))
        {
            /*
             * If just one argument is a NaN, the other argument shall be returned.
             */
            REQ("fmin.04;fminf.04;fminl.04", 
            "If just one argument is a NaN, the other argument shall be returned", 
            ((!isNan_Unifloat(x) && isNan_Unifloat(y) && 
            !compare_Unifloat(x, fmin_spec)) || (isNan_Unifloat(x) && 
            !isNan_Unifloat(y) && !compare_Unifloat(y, fmin_spec))));
        }

        if(isNan_Unifloat(x) && isNan_Unifloat(y))
        {
            /*
             * [MX] If x and y are NaN, a NaN shall be returned.
             */
            REQ("fmin.05;fminf.05;fminl.05", 
            "If x and y are NaN, a NaN shall be returned", 
            isNan_Unifloat(fmin_spec));
        }
#endif


        return true;
    }

    FILTER_CLEAN;
}

Unifloat* fmin_model(Unifloat* x, Unifloat* y)
{
    if(compare_Unifloat(x, y) != 1)
        return clone(x);
    else return clone(y);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    fmod, fmodf, fmodl - floating-point remainder value function 

SYNOPSIS

    #include <math.h>

    double fmod(double x, double y);

    float fmodf(float x, float y);

    long double fmodl(long double x, long double y);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. These functions shall return the floating-point remainder of 
    the division of x by y.

    An application wishing to check for error situations should set errno to zero 
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On 
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO | 
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    These functions shall return the value x- i* y, for some integer i such that, 
    if y is non-zero, the result has the same sign as x and magnitude less than the 
    magnitude of y.

    If the correct value would cause underflow, and is not representable, a range 
    error may occur, and [MX] either 0.0 (if supported), or an implementation- 
    defined value shall be returned.

    [MX] If x or y is NaN, a NaN shall be returned.

    If y is zero, a domain error shall occur, and either a NaN (if supported), or 
    an implementation-defined value shall be returned.

    If x is infinite, a domain error shall occur, and either a NaN (if supported), 
    or an implementation-defined value shall be returned.

    If x is ±0 and y is not zero, ±0 shall be returned.

    If x is not infinite and y is ±Inf, x shall be returned.

    If the correct value would cause underflow, and is representable, a range error 
    may occur and the correct value shall be returned. 

ERRORS

    These functions shall fail if:

        Domain Error [MX] The x argument is infinite or y is zero.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [EDOM]. If the integer expression (math_errhandling & 
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be 
    raised. 

    These functions may fail if:

        Range Error The result underflows.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling & 
    amp; MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception 
    shall be raised.
*/

//This specification refers to: fmodf, fmod, fmodl
specification
Unifloat* fmod_spec( CallContext context, Unifloat* x, 
                      Unifloat* y, ErrorCode *errno)
{
    char type[3][10] = {"fmodf", "fmod", "fmodl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        return true;
    }
    coverage C
    {
        if(isNormal_Unifloat(x) && isNormal_Unifloat(y) && 
            !isZero_Unifloat(x) && !isZero_Unifloat(y))
            return { NORMAL_CASE, 
            "x is normal not null and y is normal not null" };

        if(isNan_Unifloat(x) && !isNan_Unifloat(y))
            return { X_IS_NAN_Y_IS_NOT_NAN, "x is Nan and y is not Nan" };

        if(!isNan_Unifloat(x) && isNan_Unifloat(y))
            return { X_IS_NOT_NAN_Y_IS_NAN, "x is not Nan and y is Nan" };

        if(isZero_Unifloat(y))
            return { Y_IS_NULL, "y is null" };

        if(isInfinity_Unifloat(x))
            return { X_IS_INFINITY, "x is infinity" };

        if(isZero_Unifloat(x) && !isZero_Unifloat(y))
            return { X_IS_NULL_AND_Y_IS_NOT_NULL, 
                    "x is null and y is not null" };

        if(!isInfinity_Unifloat(x) && isInfinity_Unifloat(y))
            return { X_IS_NOT_INFINITY_AND_Y_IS_INFINITY, 
                    "x is not infinity and y is infinity" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = fmod_model(x, y);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
         * decreased to mantissa in appropriate type]*/
        round_Unifloat(fmod_spec, mant[x->type]);

#if ZERO_SUPPORTED == 1
        if(isUnderflow_Unifloat(model_res) && (isRepresentable_Unifloat(model_res) == false))
        {
            /*
             * If the correct value would cause underflow, and is not 
             * representable, a range error may occur, and [MX] either 
             * 0.0 (if supported), or an implementation-defined value 
             * shall be returned.
             */
            REQ("fmod.05;fmodf.05;fmodl.05", "If the correct value would cause "
            "underflow 0.0 shall be returned.", 
            isZero_Unifloat(fmod_spec));
        }
#endif

#if NAN_SUPPORT == 1
        if(isZero_Unifloat(y))
        {
            /*
             * If y is zero, a domain error shall occur, and either a 
             * NaN (if supported), or an implementation-defined value 
             * shall be returned.
             */
            REQ("fmod.07;fmodf.07;fmodl.07", 
            "If y is zero NaN shall be returned", 
            isNan_Unifloat(fmod_spec));
        }

        if(isInfinity_Unifloat(x))
        {
            /*
             * If x is infinite, a domain error shall occur, and either a 
             * NaN (if supported), or an implementation-defined value 
             * shall be returned.
             */
            REQ("fmod.08;fmodf.08;fmodl.08", 
            "If x is infinite a NaN shall be returned", 
            isNan_Unifloat(fmod_spec));
        }
#endif

        if(isUnderflow_Unifloat(fmod_spec) && (isRepresentable_Unifloat(model_res) == true))
        {
            /*
             * If the correct value would cause underflow, and is representable, 
             * a range error may occur and the correct value shall be returned.
             */
            REQ("fmod.11;fmodf.11;fmodl.11", 
            "If the correct value would cause underflow, and is representable, "
            "the correct value shall be returned", 
            !compare_Unifloat(fmod_spec, model_res));
        }

        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is infinite or y is zero.
         */
        ERROR_BEGIN(POSIX_FMOD, "fmod.12.01.01;fmodf.12.01.01;fmodl.12.01.01",
                    *errno, *errno)
            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is infinite or y is zero.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_FMOD, EDOM, 
            "fmod.12.01.01;fmodf.12.01.01;fmodl.12.01.01", 
            isInfinity_Unifloat(x)||isZero_Unifloat(y))

            /*
             * These functions may fail if:
             *
             * Range Error The result underflows.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_MAY(POSIX_FMOD, ERANGE, 
                      "fmod.13.01.01;fmodf.13.01.01;fmodl.13.01.01", 
                      isUnderflow_Unifloat(fmod_spec))
        ERROR_END()

        if(isNormal_Unifloat(x) && isNormal_Unifloat(y) && 
            !isZero_Unifloat(x) && !isZero_Unifloat(y))
        {
            /*
             * These functions shall return the value x- i* y, for some 
             * integer i such that, if y is non-zero, the result has the same sign 
             * as x and magnitude less than the magnitude of y.
             */
            REQ("fmod.04;fmodf.04;fmodl.04", 
            "It shall return the floating-point remainder "
            "of the division of x by y", 
            compare_Unifloat(fmod_spec, model_res) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x) || isNan_Unifloat(y))
        {
            /*
             * [MX] If x or y is NaN, a NaN shall be returned.
             */
            REQ("fmod.06;fmodf.06;fmodl.06", 
            "If x or y is NaN, a NaN shall be returned", 
            isNan_Unifloat(fmod_spec));
        }
#endif

        if(isZero_Unifloat(x) && !isZero_Unifloat(y))
        {
            /*
             * If x is ±0 and y is not zero, ±0 shall be returned.
             */
            REQ("fmod.09;fmodf.09;fmodl.09", 
            "If x is ±0 and y is not zero, ±0 shall be returned", 
            isZero_Unifloat(fmod_spec) && (fmod_spec->sign == x->sign));
        }

        if(!isInfinity_Unifloat(x) && isInfinity_Unifloat(y))
        {
            /*
             * If x is not infinite and y is ±Inf, x shall be returned.
             */
            REQ("fmod.10;fmodf.10;fmodl.10", 
            "If x is not infinite and y is ±Inf, x shall be returned", 
            compare_Unifloat(x, fmod_spec) == 0);
        }



        return true;        
    }
    FILTER_CLEAN;
}

Unifloat* fmod_model(Unifloat* x, Unifloat* y)
{
    Unifloat* int_part;
    IntT i;
    int_part = div_Unifloat(x, y);
    
    if(int_part->exp>0)
        for(i = int_part->exp + 1; i < PRECISION + 1; i++)
            setMant_Unifloat(int_part, i, 0);
    else return clone(x);
    
    return sub_Unifloat(x, mul_Unifloat(int_part, y));
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    llrint, llrintf, llrintl - round to the nearest integer value using current
    rounding direction

SYNOPSIS

    #include <math.h>

    long long llrint(double x);

    long long llrintf(float x);

    long long llrintl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to the nearest
    integer value, rounding according to the current rounding direction.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the rounded integer
    value.

    [MX] If x is NaN, a domain error shall occur, and an unspecified value is
    returned.

    If x is +Inf, a domain error shall occur and an unspecified value is returned.

    If x is -Inf, a domain error shall occur and an unspecified value is returned.

    If the correct value is positive and too large to represent as a long long, a
    domain error shall occur and an unspecified value is returned.

    If the correct value is negative and too large to represent as a long long, a
    domain error shall occur and an unspecified value is returned.

ERRORS

    These functions shall fail if:

        Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
        representable as an integer.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [EDOM]. If the integer expression (math_errhandling &
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
    raised.
*/

//This specification refers to: llrintf, llrint, llrintl
specification
LLongT llrint_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"llrintf", "llrint", "llrintl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        IntT model_error;
        LLongT model_res = llrint_model(x, &model_error);

        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
         * representable as an integer.
         */
        ERROR_BEGIN(POSIX_LLRINT, 
                        "llrint.10.01.01;llrintf.10.01.01;llrintl.10.01.01",
                        *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
             * representable as an integer.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
             * errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_LLRINT, EDOM, 
                        "llrint.10.01.01;llrintf.10.01.01;llrintl.10.01.01;"
                        "llrint.05;llrintf.05;llrintl.05;"
                        "llrint.06;llrintf.06;llrintl.06;"
                        "llrint.07;llrintf.07;llrintl.07;"
                        "llrint.08;llrintf.08;llrintl.08;"
                        "llrint.09;llrintf.09;llrintl.09", 
                         model_error)
        ERROR_END()
        
        if (!model_error)
        {
        	traceExtraFormattedProperty("expected value", "%lld", model_res);
           /*
             * These functions shall round their argument to the nearest integer 
             * value, rounding according to the current rounding direction.
             *
             * Upon successful completion, these functions shall return the 
             * rounded integer value.
             */
            REQ("llrint.01;llrintf.01;llrintl.01;"
                "llrint.04;llrintf.04;llrintl.04", 
                "It return the  rounded integer value",
                model_res == llrint_spec);
        }

        return true;
    }
    FILTER_CLEAN;
}

LLongT llrint_model(Unifloat* x, IntT* error)
{
    IntT i;
    Unifloat* res = clone(x);
    IntT flag;
    *error = 0;

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || 
        (compare_Unifloat(abs_Unifloat(x), maxLongLongT) == 1) )
    {
        *error = 1;
        return 0;
    }

    if ((res->exp >= PRECISION) && (res->exp > 0) )
        return convertUnifloat_LongLong(res, error);

    if (res->exp < 0) 
        return (LLongT)0;

    if (getMant_Unifloat(res, res->exp + 1) == 1)
    {
        flag = 0;
        for (i = res->exp + 2; i <= PRECISION; i++)
        {
            if (getMant_Unifloat(res, i) == 1) flag = 1;
        }

        if (!flag) 
        {
            setMant_Unifloat(res, res->exp + 1, 0);
            return convertUnifloat_LongLong(res, error);
        }
    }

    if (res->exp > 0 )
        round_Unifloat(res, res->exp);
    else
        round_Unifloat(res, 1);
    round_Unifloat(res, PRECISION);
    return convertUnifloat_LongLong(res, error);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    llround, llroundf, llroundl - round to nearest integer value

SYNOPSIS

    #include <math.h>

    long long llround(double x);

    long long llroundf(float x);

    long long llroundl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to the nearest
    integer value, rounding halfway cases away from zero, regardless of the current
    rounding direction.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the rounded integer
    value.

    [MX] If x is NaN, a domain error shall occur, and an unspecified value is
    returned.

    If x is +Inf, a domain error shall occur and an unspecified value is returned.

    If x is -Inf, a domain error shall occur and an unspecified value is returned.

    If the correct value is positive and too large to represent as a long long, a
    domain error shall occur and an unspecified value is returned.

    If the correct value is negative and too large to represent as a long long, a
    domain error shall occur and an unspecified value is returned.

ERRORS

    These functions shall fail if:

        Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
        representable as an integer.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [EDOM]. If the integer expression (math_errhandling &
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
    raised.
*/

//This specification refers to: llroundf, llround, llroundl
specification
LLongT llround_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"llroundf", "llround", "llroundl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        IntT model_error;
        LLongT model_res = llround_model(x, &model_error);

        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is NaN or ±Inf, or the correct 
         * value is not representable as an integer.
         */
        ERROR_BEGIN(POSIX_LLROUND, 
                        "llround.10.01.01;llroundf.10.01.01;llroundl.10.01.01",
                        *errno, *errno)
            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is NaN or ±Inf, or the correct 
             * value is not representable as an integer.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO)
             * is non-zero, then errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_LLROUND, EDOM, 
                        "llround.10.01.01;llroundf.10.01.01;llroundl.10.01.01;"
                        "llround.05;llroundf.05;llroundl.05;"
                        "llround.06;llroundf.06;llroundl.06;"
                        "llround.07;llroundf.07;llroundl.07;"
                        "llround.08;llroundf.08;llroundl.08;"
                        "llround.09;llroundf.09;llroundl.09", 
                         model_error)
        ERROR_END()

        traceExtraFormattedProperty("expected value", "%lld", model_res);
       /*
         * These functions shall round their argument to the nearest integer 
         * value, rounding halfway cases away from zero, regardless of the
         * current rounding direction.
         *
         * Upon successful completion, these functions shall return
         * the rounded integer value.
         */
        REQ("llround.01;llroundf.01;llroundl.01;"
            "llround.04;llroundf.04;llroundl.04", 
            "It shall return the rounded integer value",
            model_res == llround_spec);

        return true;
    }
    FILTER_CLEAN;
}

LLongT llround_model(Unifloat* x, IntT* error)
{
    IntT i;
    Unifloat* res = clone(x);

    *error = 0;

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || 
        (compare_Unifloat(abs_Unifloat(x), maxLongLongT) == 1) )
    {
        *error = 1;
        return 0;
    }

    if ((res->exp >= PRECISION) && (res->exp > 0) )
        return convertUnifloat_LongLong(res, error);

    if (res->exp < 0) 
        return (LLongT)0;

    for (i = PRECISION; i>res->exp+1 && i>0; i--)
        setMant_Unifloat(res, i, 0);

    if (res->exp>=0)
        if (getMant_Unifloat(res, res->exp+1) == 1) 
        {
            setMant_Unifloat(res, res->exp+1, 0);
            if (res->sign == 1) 
                res = add_Unifloat(res, convertInteger_Unifloat(1, res->type));
            else
                res = sub_Unifloat(res, convertInteger_Unifloat(1, res->type));
        }
        else
            setMant_Unifloat(res, res->exp+1, 0);

    return convertUnifloat_LongLong(res, error);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    lrint, lrintf, lrintl - round to nearest integer value using current rounding
    direction

SYNOPSIS

    #include <math.h>

    long lrint(double x);

    long lrintf(float x);

    long lrintl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to the nearest
    integer value, rounding according to the current rounding direction.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the rounded integer
    value.

    [MX] If x is NaN, a domain error shall occur and an unspecified value is
    returned.

    If x is +Inf, a domain error shall occur and an unspecified value is returned.

    If x is -Inf, a domain error shall occur and an unspecified value is returned.

    If the correct value is positive and too large to represent as a long, a domain
    error shall occur and an unspecified value is returned.

    If the correct value is negative and too large to represent as a long, a domain
    error shall occur and an unspecified value is returned.

ERRORS

    These functions shall fail if:

    Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
    representable as an integer.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [EDOM]. If the integer expression (math_errhandling &
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
    raised.
*/

//This specification refers to: lrintf, lrint, lrintl
specification
LongT lrint_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"lrintf", "lrint", "lrintl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        IntT model_error;
        LLongT model_res = lrint_model(x, &model_error);

        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
         * representable as an integer.
         */
        ERROR_BEGIN(POSIX_LRINT, 
                        "lrint.10.01.01;lrintf.10.01.01;lrintl.10.01.01;"
                        "lrint.05;lrintf.05;lrintl.05;"
                        "lrint.06;lrintf.06;lrintl.06;"
                        "lrint.07;lrintf.07;lrintl.07;"
                        "lrint.08;lrintf.08;lrintl.08;"
                        "lrint.09;lrintf.09;lrintl.09", 
                        *errno, *errno)
            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
             * representable as an integer.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
             * errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_LRINT, EDOM, 
                        "lrint.10.01.01;lrintf.10.01.01;lrintl.10.01.01",
                         model_error)
        ERROR_END()
        
        if (!model_error)
        {
        	traceExtraFormattedProperty("expected value", "%lld", model_res);
            /*
             * These functions shall round their argument to the nearest integer 
             * value, rounding according to the current rounding direction.
             *
             * Upon successful completion, these functions shall return the 
             * rounded integer value.
             */
            REQ("lrint.01;lrintf.01;lrintl.01;"
                "lrint.04;lrintf.04;lrintl.04", 
                "It return the  rounded integer value",
                model_res == lrint_spec);
        }

        return true;
    }
    FILTER_CLEAN;
}

LongT lrint_model(Unifloat* x, IntT* error)
{
    IntT i;
    Unifloat* res = clone(x);
    IntT flag;
    *error = 0;

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || 
        (compare_Unifloat(abs_Unifloat(x), maxLongT) == 1) )
    {
        *error = 1;
        return 0;
    }

    if ((res->exp >= PRECISION) && (res->exp > 0) )
        return (LongT)convertUnifloat_LongLong(res, error);

    if (res->exp < 0) 
        return (LongT)0;

    if (getMant_Unifloat(res, res->exp + 1) == 1)
    {
        flag = 0;
        for (i = res->exp + 2; i <= PRECISION; i++)
            if (getMant_Unifloat(res, i) == 1) flag = 1;
        if (!flag) 
        {
            setMant_Unifloat(res, res->exp + 1, 0);
            return (LongT)convertUnifloat_LongLong(res, error);
        }
    }

    if (res->exp > 0 )
        round_Unifloat(res, res->exp);
    else
        round_Unifloat(res, 1);
    round_Unifloat(res, PRECISION);

    return (LongT)convertUnifloat_LongLong(res, error);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    lround, lroundf, lroundl - round to nearest integer value

SYNOPSIS

    #include <math.h>

    long lround(double x);

    long lroundf(float x);

    long lroundl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to the nearest
    integer value, rounding halfway cases away from zero, regardless of the current
    rounding direction.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the rounded integer
    value.

    [MX] If x is NaN, a domain error shall occur and an unspecified value is
    returned.

    If x is +Inf, a domain error shall occur and an unspecified value is returned.

    If x is -Inf, a domain error shall occur and an unspecified value is returned.

    If the correct value is positive and too large to represent as a long, a domain
    error shall occur and an unspecified value is returned.

    If the correct value is negative and too large to represent as a long, a domain
    error shall occur and an unspecified value is returned.

ERRORS

    These functions shall fail if:

        Domain Error [MX] The x argument is NaN or ±Inf, or the correct value is not
        representable as an integer.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [EDOM]. If the integer expression (math_errhandling &
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
    raised.
*/

//This specification refers to: lroundf, lround, lroundl
specification
LongT lround_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"lroundf", "lround", "lroundl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        IntT model_error;
        LLongT model_res = lround_model(x, &model_error);

        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is NaN or ±Inf, or the correct 
         * value is not representable as an integer.
         */
        ERROR_BEGIN(POSIX_LROUND, 
                        "lround.10.01.01;lroundf.10.01.01;lroundl.10.01.01",
                        *errno, *errno)
            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is NaN or ±Inf, or the correct 
             * value is not representable as an integer.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO)
             * is non-zero, then errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_LROUND, EDOM, 
                        "lround.10.01.01;lroundf.10.01.01;lroundl.10.01.01;"
                        "lround.05;lroundf.05;lroundl.05;"
                        "lround.06;lroundf.06;lroundl.06;"
                        "lround.07;lroundf.07;lroundl.07;"
                        "lround.08;lroundf.08;lroundl.08;"
                        "lround.09;lroundf.09;lroundl.09", 
                         model_error)

        ERROR_END()

        traceExtraFormattedProperty("expected value", "%lld", model_res);
        /*
         * These functions shall round their argument to the nearest integer 
         * value, rounding halfway cases away from zero, regardless of the
         * current rounding direction.
         *
         * Upon successful completion, these functions shall return
         * the rounded integer value.
         */
        REQ("lround.01;lroundf.01;lroundl.01;"
            "lround.04;lroundf.04;lroundl.04", 
            "It shall return the rounded integer value",
            model_res == lround_spec);

        return true;
    }
    FILTER_CLEAN;
}

LongT lround_model(Unifloat* x, IntT* error)
{
    IntT i;
    Unifloat* res = clone(x);

    *error = 0;

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || 
        (compare_Unifloat(abs_Unifloat(x), maxLongT) == 1) )
    {
        *error = 1;
        return (LongT)0;
    }

    if (((unsigned int)res->exp >= PRECISION) && (res->exp > 0) )
        return (LongT)convertUnifloat_LongLong(res, error);

    if (res->exp < 0) 
        return (LongT)0;

    for (i = PRECISION; i>res->exp+1 && i>0; i--)
        setMant_Unifloat(res, i, 0);
    if (res->exp>=0)
        if (getMant_Unifloat(res, res->exp+1) == 1) 
        {
            setMant_Unifloat(res, res->exp+1, 0);
            if (res->sign == 1) 
                res = add_Unifloat(res, convertInteger_Unifloat(1, res->type));
            else
                res = sub_Unifloat(res, convertInteger_Unifloat(1, res->type));
        }
        else
            setMant_Unifloat(res, res->exp+1, 0);

    return (LongT)convertUnifloat_LongLong(res, error);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    modf, modff, modfl - decompose a floating-point number 

SYNOPSIS

    #include <math.h>

    double modf(double x, double *iptr);

    float modff(float value, float *iptr);

    long double modfl(long double value, long double *iptr);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. These functions shall break the argument x into integral and 
    fractional parts, each of which has the same sign as the argument. It stores 
    the integral part as a double (for the modf() function), a float (for the 
    modff() function), or a long double (for the modfl() function), in the object 
    pointed to by iptr.

RETURN VALUE

    Upon successful completion, these functions shall return the signed fractional 
    part of x.

    [MX] If x is NaN, a NaN shall be returned, and *iptr shall be set to a NaN.

    If x is ±Inf, ±0 shall be returned, and *iptr shall be set to ±Inf. 

ERRORS

    No errors are defined.
*/

//This specification refers to: modff, modf, modfl
specification
Unifloat* modf_spec( CallContext context, Unifloat* x, Unifloat** iptr)
{
    char type[3][10] = {"modff", "modf", "modfl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }

    coverage C
    {
        if(isNormal_Unifloat(x))
            return { NORMAL_CASE, "x is normal" };

        if(isNan_Unifloat(x))
            return { NAN_CASE, "x is nan" };

        if(isInfinity_Unifloat(x))
            return { INFINITY_CASE, "x is infinity" };
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* Zero = createZero_Unifloat(x->type);
        Unifloat** model_iptr = (Unifloat**)&Zero;
        Unifloat* model_res = modf_model(x, model_iptr);

        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected fractional value", model_res);
        round_Unifloat(*model_iptr, mant[x->type]);
        traceExtraProperty("expected integer value", *model_iptr);
        round_Unifloat(modf_spec, mant[x->type]);

#if NAN_SUPPORT == 1
        if(!isNan_Unifloat(x) && !isInfinity_Unifloat(x))
        {
            /*
             * It stores the integral part as a double (for the modf() function), a float (for 
             * the modff() function), or a long double (for the modfl() function), in the 
             * object pointed to by iptr.
             */
            REQ("modf.02;modff.02;modfl.02", 
                "It stores the integral part in the object pointed to by iptr", 
                compare_Unifloat(*model_iptr, *iptr) == 0);
        }
#endif
        if(!isNan_Unifloat(x) && !isInfinity_Unifloat(x))
        {
            /*
             * Upon successful completion, these functions shall return the signed fractional 
             * part of x.
             */
            REQ("modf.03;modff.03;modfl.03", 
                "functions shall return the signed fractional part of x", 
                !compare_Unifloat(modf_spec, model_res));
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x))
        {
            /*
             * [MX] If x is NaN, a NaN shall be returned, and *iptr shall be set to a NaN.
             */
            REQ("modf.04;modff.04;modfl.04", 
            "If x is NaN, a NaN shall be returned, "
            "and *iptr shall be set to a NaN", 
            isNan_Unifloat(modf_spec) && isNan_Unifloat(*iptr));
        }
#endif

        if(isInfinity_Unifloat(x))
        {
            /*
             * If x is ±Inf, ±0 shall be returned, and *iptr shall be set to ±Inf.
             */
            REQ("modf.05;modff.05;modfl.05", 
                "If x is ±Inf, ±0 shall be returned, "
                "and *iptr shall be set to ±Inf", 
                isZero_Unifloat(modf_spec) && isInfinity_Unifloat(*iptr) && 
                (modf_spec->sign == x->sign) && ((*iptr)->sign == x->sign));
        }


        
        return true;
    }
    FILTER_CLEAN;
}

Unifloat* modf_model(Unifloat* x, Unifloat** model_iptr)
{
    Unifloat* int_part = clone(x);
    IntT i;
    
    if(int_part->exp>0)
        for(i = int_part->exp + 1; i < PRECISION + 1; i++)
            setMant_Unifloat(int_part, i, 0);
    else int_part = createZero_Unifloat( x->type);
    
    *model_iptr = int_part;
    return sub_Unifloat(x, int_part);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    nan, nanf, nanl - return quiet NaN 

SYNOPSIS

    #include <math.h>

    double nan(const char *tagp);

    float nanf(const char *tagp);

    long double nanl(const char *tagp);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. The function call nan("n-char-sequence") shall be 
    equivalent to: 



    strtod("NAN(n-char-sequence)", (char **) NULL); 
    The function call 
    nan("") shall be equivalent to: 



    strtod("NAN()", (char **) NULL) 
    If tagp does not point to an n- 
    char sequence or an empty string, the function call shall be equivalent to: 



    strtod("NAN", (char **) NULL) 
    Function calls to nanf() and nanl() 
    are equivalent to the corresponding function calls to strtof() and strtold(). 

RETURN VALUE

    These functions shall return a quiet NaN, if available, with content indicated 
    through tagp.

    If the implementation does not support quiet NaNs, these functions shall return 
    zero.

ERRORS

    No errors are defined.
*/

//This specification refers to: nanf, nan, nanl
specification
Unifloat* nan_spec( CallContext context, CString* tagp, IntT type_f)
{
    char type[3][10] = {"nanf", "nan", "nanl"};

    FILTER(type[type_f]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "tagp isn't Null", tagp != NULL);

        return true;
    }
    coverage C
    {
      return { COMMON_CASE, "input value is NAN, NAN() or NAN(...)" };
    }
    post
    {

#if NAN_SUPPORT == 1
        /*
         * The function call nan("n-char-sequence") shall be equivalent to: 
         * strtod("NAN(n-char-sequence)", (char **) NULL); 
         */
        REQ("nan.01;nanf.01;nanl.01", 
            "nan(str) shall return NaN", isNan_Unifloat(nan_spec));

        /*
         * The function call nan("") shall be equivalent to: 
         * strtod("NAN()", (char **) NULL) 
         */
        REQ("nan.02;nanf.02;nanl.02", 
            "nan("") shall return NaN", isNan_Unifloat(nan_spec));

        /*
         * If tagp does not point to an n- char sequence or an empty string, 
         * the function call shall be equivalent to: 
         * strtod("NAN", (char **) NULL) 
         */
        REQ("nan.03;nanf.03;nanl.03", 
            "nan() shall return NaN", isNan_Unifloat(nan_spec));

        /*
         * Function calls to nanf() and nanl() are equivalent to the 
         * corresponding function calls to strtof() and strtold().
         */
        REQ("nan.04;nanf.04;nanl.04", "nan", isNan_Unifloat(nan_spec));

        /*
         * These functions shall return a quiet NaN, if available, with 
         * content indicated through tagp.
         */
        REQ("nan.05;nanf.05;nanl.05", 
            "functions shall return a quiet NaN, if available, "
            "with content indicated through tagp", 
            isNan_Unifloat(nan_spec));
#endif
#if NAN_SUPPORT == 0
        /*
         * If the implementation does not support quiet NaNs, these 
         * functions shall return zero.
         */
        REQ("nan.06;nanf.06;nanl.06", 
            "If the implementation does not support quiet NaNs, these" 
            " functions shall return zero", 
            isZero_Unifloat(nan_spec));
#endif

        return true;
    }
    FILTER_CLEAN;
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    nearbyint, nearbyintf, nearbyintl - floating-point rounding functions

SYNOPSIS

    #include <math.h>

    double nearbyint(double x);

    float nearbyintf(float x);

    long double nearbyintl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to an integer value
    in floating-point format, using the current rounding direction and without
    raising the inexact floating-point exception.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the rounded integer
    value.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0, ±0 shall be returned.

    If x is ±Inf, x shall be returned.

    [XSI] If the correct value would cause overflow, a range error shall occur and
    nearbyint(), nearbyintf(), and nearbyintl() shall return the value of the macro
    ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (with the same sign as x), respectively.

ERRORS

    These functions shall fail if:

        Range Error [XSI] The result would cause an overflow.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling &
    amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception
    shall be raised.
*/

//This specification refers to: nearbyintf, nearbyint, nearbyintl
specification
Unifloat* nearbyint_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][15] = {"nearbyintf", "nearbyint", "nearbyintl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        Unifloat* model_res = nearbyint_model(x);

        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(nearbyint_spec, mant[x->type]);

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * [XSI] If the correct value would cause overflow, a range 
             * error shall occur and nearbyint(), nearbyintf(), and 
             * nearbyintl() shall return the value of the macro ±HUGE_VAL,
             * ±HUGE_VALF, and ±HUGE_VALL (with the same sign as x),
             * respectively.
             */
            REQ("nearbyint.08;nearbyintf.08;nearbyintl.08", 
                "If the correct value would cause overflow, "
                "HUGE_VAL should be returned",
                isInfinity_Unifloat(nearbyint_spec));
        }

        /*
         * These functions shall fail if:
         *
         * Range Error [XSI] The result would cause an overflow.
         */
        ERROR_BEGIN(POSIX_NEARBYINT, 
                  "nearbyint.09;nearbyintf.09;nearbyintl.09",
                    *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Range Error [XSI] The result would cause an overflow.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_SHALL(POSIX_NEARBYINT, ERANGE, 
                  "nearbyint.09.01.01;nearbyintf.09.01.01;nearbyintl.09.01.01",
                  isOverflow_Unifloat(model_res))

        ERROR_END()        

        /*
         * Upon successful completion, these functions shall return
         * the rounded integer value.
         */
        REQ("nearbyint.04;nearbyintf.04;nearbyintl.04", 
            "It shall return the rounded integer value", 
            compare_Unifloat(model_res, nearbyint_spec) == 0);

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x))
        {
            /*
             * [MX] If x is NaN, a NaN shall be returned.
             */
            REQ("nearbyint.05;nearbyintf.05;nearbyintl.05", 
                "If x is NaN, a NaN shall be returned",
                isNan_Unifloat(nearbyint_spec));
        }
#endif

        if (isZero_Unifloat(x))
        {
            /*
             * If x is ±0, ±0 shall be returned.
             */
            REQ("nearbyint.06;nearbyintf.06;nearbyintl.06", 
                "If x is ±0, ±0 shall be returned",
                isZero_Unifloat(nearbyint_spec));
        }

        if (isInfinity_Unifloat(x))
        {
            /*
             * If x is ±Inf, x shall be returned.
             */
            REQ("nearbyint.07;nearbyintf.07;nearbyintl.07", 
                "If x is ±Inf, x shall be returned",
                compare_Unifloat(x, nearbyint_spec) == 0);
        }



        return true;
    }
    FILTER_CLEAN;
}

Unifloat* nearbyint_model(Unifloat* x)
{
    IntT i;
    Unifloat* res = clone(x);
    IntT flag;

    if ((res->exp >= PRECISION) && (res->exp > 0) )
        return res;

    if (res->exp < 0) 
        return createZero_Unifloat( x->type);

    if (getMant_Unifloat(res, res->exp + 1) == 1)
    {
        flag = 0;
        for (i = res->exp + 2; i <= PRECISION; i++)
            if (getMant_Unifloat(res, i) == 1) flag = 1;
        if (!flag) 
        {
            setMant_Unifloat(res, res->exp + 1, 0);
            return res;
        }
    }

    if (res->exp > 0 )
        round_Unifloat(res, res->exp);
    else
        round_Unifloat(res, 1);
    round_Unifloat(res, PRECISION);
    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    remainder, remainderf, remainderl - remainder function 

SYNOPSIS

    #include <math.h>

    double remainder(double x, double y);

    float remainderf(float x, float y);

    long double remainderl(long double x, long double y);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. These functions shall return the floating-point remainder r= x- 
    ny when y is non-zero. The value n is the integral value nearest the exact 
    value x/ y. When |n-x/y|=?, the value n is chosen to be even.

    The behavior of remainder() shall be independent of the rounding mode.

RETURN VALUE

    Upon successful completion, these functions shall return the floating-point 
    remainder r= x- ny when y is non-zero.

    [MX] If x or y is NaN, a NaN shall be returned.

    If x is infinite or y is 0 and the other is non-NaN, a domain error shall 
    occur, and either a NaN (if supported), or an implementation-defined value 
    shall be returned. 

ERRORS

    These functions shall fail if:

        Domain Error [MX] The x argument is ±Inf, or the y argument is ±0 and the other 
        argument is non-NaN.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [EDOM]. If the integer expression (math_errhandling & 
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be 
    raised.
*/

//This specification refers to: remainderf, remainder, remainderl
specification
Unifloat* remainder_spec( CallContext context, Unifloat* x, 
                         Unifloat* y, ErrorCode *errno)
{
    char type[3][15] = {"remainderf", "remainder", "remainderl"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        return true;
    }
    coverage C
    {
        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
            return { NORMAL_CASE_Y_NOT_ZERO, 
            "x and y are normal, y is not null" };

        if(isNan_Unifloat(x))
            return { X_IS_NAN, "x is NaN"};

        if(isNan_Unifloat(y))
            return { Y_IS_NAN, "y is NaN"};
        
        if((isInfinity_Unifloat(x) && !isNan_Unifloat(y)))
            return { X_INF_Y_NOT_NAN, 
            "x is infinite and y is non-NaN"};
        if(isZero_Unifloat(y) && !isNan_Unifloat(x))
            return { Y_NULL_X_NOT_NAN, 
            "y is 0 and x is non-NaN"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = remainder_model(x, y);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
         * decreased to mantissa in appropriate type]*/
        round_Unifloat(remainder_spec, mant[x->type]);

#if NAN_SUPPORT == 1
        if((isInfinity_Unifloat(x) && !isNan_Unifloat(y)) || 
            (isZero_Unifloat(y) && !isNan_Unifloat(x)))
        {
            /*
             * If x is infinite or y is 0 and the other is non-NaN, 
             * a domain error shall occur, and either a NaN (if supported), 
             * or an implementation-defined value shall be returned.
             */
            REQ("remainder.05;remainderf.05;remainderl.05", 
            "If x is infinite or y is 0 and the other is non-NaN a NaN "
            "shall be returned", 
            isNan_Unifloat(remainder_spec));
        }
#endif
        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is ±Inf, or the y argument 
         * is ±0 and the other argument is non-NaN.
         */
        ERROR_BEGIN(POSIX_REMAINDER, 
            "remainder.06.01.01;remainderf.06.01.01;remainderl.06.01.01", 
            *errno, *errno)
            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is ±Inf, or the y argument 
             * is ±0 and the other argument is non-NaN.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_REMAINDER, EDOM, 
            "remainder.06.01.01;remainderf.06.01.01;remainderl.06.01.01", 
            (isInfinity_Unifloat(x) && !isNan_Unifloat(y)) || 
            (isZero_Unifloat(y) && !isNan_Unifloat(x)))

        ERROR_END()

        /*
         * The behavior of remainder() shall be independent 
         * of the rounding mode.
         */
        REQ("remainder.02;remainderf.02;remainderl.02", "", TODO_REQ());

        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
        {
            /*
             * Upon successful completion, these functions shall return the 
             * floating-point remainder r= x- ny when y is non-zero.
             */
            REQ("remainder.03;remainderf.03;remainderl.03", 
            "functions shall return the floating-point remainder r= x- ny "
            "when y is non-zero", 
            compare_Unifloat(remainder_spec, model_res) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x) || isNan_Unifloat(y))
        {
            /*
             * [MX] If x or y is NaN, a NaN shall be returned.
             */
            REQ("remainder.04;remainderf.04;remainderl.04", 
            "If x or y is NaN, a NaN shall be returned", 
            isNan_Unifloat(remainder_spec));
        }
#endif


        return true;
    }
    FILTER_CLEAN;
}

Unifloat* remainder_model(Unifloat* x, Unifloat* y)
{
    Unifloat* tmp, * frac_part, * int_part;
    Unifloat* One =createOne_Unifloat( x->type);
    Unifloat* Two = convertInteger_Unifloat(2, x->type);
    Unifloat* Half;
    IntT i, sign;
    Half = clone(Two);
    Half->exp-=2;
    tmp = div_Unifloat(x, y);
    sign = tmp->sign;
    tmp->sign = 1;
    int_part = clone(tmp);

    if(int_part->exp>0)
        for(i = int_part->exp + 1; i < PRECISION + 1; i++)
            setMant_Unifloat(int_part, i, 0);
    else int_part = createZero_Unifloat( x->type);

    frac_part = sub_Unifloat(tmp, int_part);

    if(compare_Unifloat(frac_part, Half) == 1)
        tmp = add_Unifloat(int_part,One);
    else if(compare_Unifloat(frac_part, Half) == -1)
        tmp = int_part;
    else
    {
        if(isZero_Unifloat(fmod_model(int_part, Two)))
            tmp = int_part; 
        if(isZero_Unifloat(fmod_model(add_Unifloat(int_part,One), Two)))
            tmp = add_Unifloat(int_part,One);
    }
    
    tmp->sign = sign;
    return sub_Unifloat(x, mul_Unifloat(tmp, y));
        
    
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6 
IEEE Std 1003.1, 2004 Edition 
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    remquo, remquof, remquol - remainder functions 

SYNOPSIS

    #include <math.h>

    double remquo(double x, double y, int *quo);

    float remquof(float x, float y, int *quo);

    long double remquol(long double x, long double y, int *quo);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the ISO C 
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the 
    ISO C standard. The remquo(), remquof(), and remquol() functions shall compute 
    the same remainder as the remainder(), remainderf(), and remainderl() 
    functions, respectively. In the object pointed to by quo, they store a value 
    whose sign is the sign of x/ y and whose magnitude is congruent modulo 2n to 
    the magnitude of the integral quotient of x/ y, where n is an implementation- 
    defined integer greater than or equal to 3.

    An application wishing to check for error situations should set errno to zero 
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On 
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO | 
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    These functions shall return x REM y.

    [MX] If x or y is NaN, a NaN shall be returned.

    If x is ±Inf or y is zero and the other argument is non-NaN, a domain error 
    shall occur, and either a NaN (if supported), or an implementation-defined 
    value shall be returned. 

ERRORS

    These functions shall fail if:

        Domain Error [MX] The x argument is ±Inf, or the y argument is ±0 and the other 
        argument is non-NaN.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then 
    errno shall be set to [EDOM]. If the integer expression (math_errhandling & 
    MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be 
    raised.
*/

//This specification refers to: remquof, remquo, remquol
specification
Unifloat* remquo_spec( CallContext context, Unifloat* x, 
                       Unifloat* y, Unifloat** quo, ErrorCode *errno)
{
    char type[3][10] = {"remquof", "remquo", "remquol"};

    FILTER(type[x->type]);

    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x and y aren't Null", (x != NULL) && (y != NULL));

        /* [Input arguments should have the same type] */
        REQ("", "x and y have the same type", x->type == y->type);

        return true;
    }
    coverage C
    {
        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
            return { NORMAL_CASE_Y_NOT_ZERO, 
            "x and y are normal, y is not null" };

        if(isNan_Unifloat(x))
            return { X_IS_NAN, "x is NaN"};

        if(isNan_Unifloat(y))
            return { Y_IS_NAN, "y is NaN"};
        
        if((isInfinity_Unifloat(x) && !isNan_Unifloat(y)))
            return { X_INF_Y_NOT_NAN, 
            "x is infinite and y is non-NaN"};
        if(isZero_Unifloat(y) && !isNan_Unifloat(x))
            return { Y_NULL_X_NOT_NAN, 
            "y is 0 and x is non-NaN"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        /*[Calculate model function]*/
        Unifloat* model_res = remquo_model(x, y);
        /*[update Unifloat-number in float-point-representable number]*/
        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        /* [nextafter_spec has PRECISION numbers in mantissa. It should be
         * decreased to mantissa in appropriate type]*/
        round_Unifloat(remquo_spec, mant[x->type]);
        
#if NAN_SUPPORT == 1
        if((isInfinity_Unifloat(x) && !isNan_Unifloat(y)) || 
            (isZero_Unifloat(y) && !isNan_Unifloat(x)))
        {
            /*
             * If x is ±Inf or y is zero and the other argument is non-NaN, 
             * a domain error shall occur, and either a NaN (if supported), 
             * or an implementation-defined value shall be returned.
             */
            REQ("remquo.06;remquof.06;remquol.06", 
            "If x is infinite or y is 0 and the other is non-NaN a NaN "
            "shall be returned", 
            isNan_Unifloat(remquo_spec));
        }
#endif

        /*
         * These functions shall fail if:
         *
         * Domain Error [MX] The x argument is ±Inf, or the y argument 
         * is ±0 and the other argument is non-NaN.
         */
        ERROR_BEGIN(POSIX_REMQUO, 
            "remquo.07.01.01;remquof.07.01.01;remquol.07.01.01", 
            *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Domain Error [MX] The x argument is ±Inf, or the y argument 
             * is ±0 and the other argument is non-NaN.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then errno shall be set to [EDOM].
             */
            ERROR_SHALL(POSIX_REMQUO, EDOM, 
            "remquo.07.01.01;remquof.07.01.01;remquol.07.01.01", 
            (isInfinity_Unifloat(x) && !isNan_Unifloat(y)) || 
            (isZero_Unifloat(y) && !isNan_Unifloat(x)))

        ERROR_END()

        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
        {
            /*
             * The remquo(), remquof(), and remquol() functions shall compute 
             * the same remainder as the remainder(), remainderf(), and 
             * remainderl() functions, respectively. In the object pointed to by 
             * quo, they store a value whose sign is the sign of x/ y and whose 
             * magnitude is congruent modulo 2n to the magnitude of the integral 
             * quotient of x/ y, where n is an implementation-defined integer 
             * greater than or equal to 3.
             */
            REQ("remquo.01;remquof.01;remquol.01", 
                "Functions shall return x REM y. In the object pointed to by quo", 
                (compare_Unifloat(model_res, remquo_spec) == 0 ) && 
                check_quo_remquo(x, y, *quo));
        }

        if(!isZero_Unifloat(y) && isNormal_Unifloat(x) && isNormal_Unifloat(y))
        {
            /*
             * These functions shall return x REM y.
             */
            REQ("remquo.04;remquof.04;remquol.04", 
            "functions shall return x REM y", 
            compare_Unifloat(model_res, remquo_spec) == 0);
        }

#if NAN_SUPPORT == 1
        if(isNan_Unifloat(x) || isNan_Unifloat(y))
            /*
             * [MX] If x or y is NaN, a NaN shall be returned.
             */
            REQ("remquo.05;remquof.05;remquol.05", 
                "If x or y is NaN, a NaN shall be returned", 
                isNan_Unifloat(remquo_spec));
#endif

        return true;
    }
    FILTER_CLEAN;
}

Unifloat* remquo_model(Unifloat* x, Unifloat* y)
{
    return remainder_model(x, y);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    rint, rintf, rintl - round-to-nearest integral value

SYNOPSIS

    #include <math.h>

    double rint(double x);

    float rintf(float x);

    long double rintl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall return the integral value (represented as
    a double) nearest x in the direction of the current rounding mode. The current
    rounding mode is implementation-defined.

    If the current rounding mode rounds toward negative infinity, then rint() shall
    be equivalent to floor(). If the current rounding mode rounds toward positive
    infinity, then rint() shall be equivalent to ceil().

    These functions differ from the nearbyint(), nearbyintf(), and nearbyintl()
    functions only in that they may raise the inexact floating-point exception if
    the result differs in value from the argument.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the integer
    (represented as a double precision number) nearest x in the direction of the
    current rounding mode.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0 or ±Inf, x shall be returned.

    [XSI] If the correct value would cause overflow, a range error shall occur and
    rint(), rintf(), and rintl() shall return the value of the macro ±HUGE_VAL, ±
    HUGE_VALF, and ±HUGE_VALL (with the same sign as x), respectively.

ERRORS

    These functions shall fail if:

        Range Error [XSI] The result would cause an overflow.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling &
    amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception
    shall be raised.
*/

//This specification refers to: rintf, rint, rintl
specification
Unifloat* rint_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"rintf", "rint", "rintl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        Unifloat* model_res;

        if (ROUND == NEGATIVE_INFINITY)
            model_res = floor_Unifloat(x);

        if (ROUND == POSITIVE_INFINITY)
            model_res = ceil_model(x);

        if ((ROUND == TO_NEAREST) || (ROUND == TOWARD_ZERO))
            model_res = nearbyint_model(x);

        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(rint_spec, mant[x->type]);

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * [XSI] If the correct value would cause overflow, a range error 
             * shall occur and rint(), rintf(), and rintl() shall return 
             * the value of the macro ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL 
             * (with the same sign as x), respectively.
             */
            REQ("rint.10;rintf.10;rintl.10", 
                "If the correct value would cause overflow, HUGE_VAL should be returned",
                isInfinity_Unifloat(rint_spec));      
        }
        /*
         * These functions shall fail if:
         *
         * Range Error [XSI] The result would cause an overflow.
         */
        ERROR_BEGIN(POSIX_RINT, 
                    "rint.11.01.01;rintf.11.01.01;rintl.11.01.01",
                    *errno, *errno)

            /*
             * These functions shall fail if:
             *
             * Range Error [XSI] The result would cause an overflow.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
             * errno shall be set to [ERANGE].
             */
            ERROR_SHALL(POSIX_RINT, ERANGE, 
                        "rint.11.01.01;rintf.11.01.01;rintl.11.01.01",
                        isOverflow_Unifloat(model_res))

        ERROR_END()

        /*
         * If the current rounding mode rounds toward negative infinity,
         * then rint() shall be equivalent to floor().
         */
        /*
         * If the current rounding mode rounds toward positive infinity, 
         * then rint() shall be equivalent to ceil().
         */
        /*
         * Upon successful completion, these functions shall return the integer
         * (represented as a double precision number) nearest x in the direction of the
         * current rounding mode.
         */
        REQ("rint.02;rintf.02;rintl.02;"
            "rint.03;rintf.03;rintl.03;"
            "rint.07;rintf.07;rintl.07", 
            "It shall return the integer nearest x ",
            compare_Unifloat(model_res, rint_spec) == 0);

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x))
        {
            /*
             * [MX] If x is NaN, a NaN shall be returned.
             */
            REQ("rint.08;rintf.08;rintl.08", 
                "If x is NaN, a NaN shall be returned",
                isNan_Unifloat(rint_spec));
        }
#endif

        if (isZero_Unifloat(x) || isInfinity_Unifloat(x))
        {
            /*
             * If x is ±0 or ±Inf, x shall be returned.
             */
            REQ("rint.09;rintf.09;rintl.09", 
                "If x is ±0 or ±Inf, x shall be returned",
                compare_Unifloat(x, rint_spec) == 0);
        }
        


        return true;
    }
    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    round, roundf, roundl - round to the nearest integer value in a floating-point
    format

SYNOPSIS

    #include <math.h>

    double round(double x);

    float roundf(float x);

    long double roundl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to the nearest
    integer value in floating-point format, rounding halfway cases away from zero,
    regardless of the current rounding direction.

    An application wishing to check for error situations should set errno to zero
    and call feclearexcept(FE_ALL_EXCEPT) before calling these functions. On
    return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO |
    FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

RETURN VALUE

    Upon successful completion, these functions shall return the rounded integer
    value.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0 or ±Inf, x shall be returned.

    [XSI] If the correct value would cause overflow, a range error shall occur and
    round(), roundf(), and roundl() shall return the value of the macro ±HUGE_VAL, ±
    HUGE_VALF, and ±HUGE_VALL (with the same sign as x), respectively.

ERRORS

    These functions may fail if:

        Range Error [XSI] The result overflows.

    If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then
    errno shall be set to [ERANGE]. If the integer expression (math_errhandling &
    amp; MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception
    shall be raised.
*/

//This specification refers to: roundf, round, roundl
specification
Unifloat* round_spec(CallContext context, Unifloat* x, ErrorCode* errno)
{
    char type[3][10] = {"roundf", "round", "roundl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        Unifloat* model_res = round_model(x);

        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(round_spec, mant[x->type]);

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * [XSI] If the correct value would cause overflow, a range error
             * shall occur and round(), roundf(), and roundl() shall return 
             * the value of the macro ±HUGE_VAL, ± HUGE_VALF, and ±HUGE_VALL 
             * (with the same sign as x), respectively.
             */
            REQ("round.07;roundf.07;roundl.07",
                "If the correct value would cause overflow, "
                "HUGE_VAL should be returned", 
                isInfinity_Unifloat(round_spec));  
        }

        /*
         * These functions may fail if:
         *
         * Range Error [XSI] The result overflows.
         */
        ERROR_BEGIN(POSIX_ROUND, 
                    "round.08.01.01;roundf.08.01.01;roundl.08.01.01",
                    *errno,  *errno)

            /*
             * These functions may fail if:
             *
             * Range Error [XSI] The result overflows.
             *
             * If the integer expression (math_errhandling & MATH_ERRNO) 
             * is non-zero, then errno shall be set to [ERANGE].
             */
            ERROR_MAY(POSIX_ROUND, ERANGE, 
                      "round.08.01.01;roundf.08.01.01;roundl.08.01.01",
                      isOverflow_Unifloat(model_res))
        ERROR_END()

        /*
         * Upon successful completion, these functions shall return the rounded integer
         * value.
         */
        REQ("round.04;roundf.04;roundl.04", 
            "It shall return the rounded integer value", 
            compare_Unifloat(model_res, round_spec) == 0);

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x))
        {
            /*
             * [MX] If x is NaN, a NaN shall be returned.
             */
            REQ("round.05;roundf.05;roundl.05", 
                "If x is NaN, a NaN shall be returned",
                isNan_Unifloat(round_spec));
        }
#endif

        if (isZero_Unifloat(x) || isInfinity_Unifloat(x))
        {
            /*
             * If x is ±0 or ±Inf, x shall be returned.
             */
            REQ("round.06;roundf.06;roundl.06", 
                "If x is ±0 or ±Inf, x shall be returned",
                compare_Unifloat(x, round_spec) == 0);
        }

     

        return true;
    }
    FILTER_CLEAN;
}

Unifloat* round_model(Unifloat* x)
{
    IntT i;
    Unifloat* res = clone(x);

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || isZero_Unifloat(x))
        return res;

    if ((res->exp >= PRECISION) && (res->exp > 0) )
        return res;

    if (res->exp < 0) 
        return createZero_Unifloat( x->type);

    for (i = PRECISION; i>res->exp+1 && i>0; i--)
        setMant_Unifloat(res, i, 0);
    if (res->exp>=0)
        if (getMant_Unifloat(res, res->exp+1) == 1) 
        {
            setMant_Unifloat(res, res->exp+1, 0);
            if (res->sign == 1) 
                res = add_Unifloat(res, convertInteger_Unifloat(1, res->type));
            else
                res = sub_Unifloat(res, convertInteger_Unifloat(1, res->type));
        }
        else
            setMant_Unifloat(res, res->exp+1, 0);

    return res;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    trunc, truncf, truncl - round to truncated integer value

SYNOPSIS

    #include <math.h>

    double trunc(double x);

    float truncf(float x);

    long double truncl(long double x);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall round their argument to the integer
    value, in floating format, nearest to but no larger in magnitude than the
    argument.

RETURN VALUE

    Upon successful completion, these functions shall return the truncated integer
    value.

    [MX] If x is NaN, a NaN shall be returned.

    If x is ±0 or ±Inf, x shall be returned.

ERRORS

    No errors are defined.
*/

/** trunc_spec **/
//This specification refers to: truncf, trunc, truncl
specification
Unifloat* trunc_spec(CallContext context, Unifloat* x)
{
    char type[3][10] = {"truncf", "trunc", "truncl"};
    
    FILTER(type[x->type]);
    pre
    {
        /* [Input arguments must be not Null] */
        REQ("", "x isn't Null", x != NULL);

        return true;
    }
    coverage C
    {
        if (isNan_Unifloat(x))
            return {naN_arg, "x is NaN"};
        else
            if (isInfinity_Unifloat(x))
                return {Inf_arg, "x is infinity"};
            else
                if (isZero_Unifloat(x))
                    return {Zero_arg, "x is zero"};
                else
                    return {Norm_arg, "x is finite non-zero value"};
    }
    post
    {
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        Unifloat* model_res = trunc_model(x);

        round_Unifloat(model_res, mant[x->type]);
        traceExtraProperty("expected value", model_res);
        round_Unifloat(trunc_spec, mant[x->type]);

        /*
         * Upon successful completion, these functions shall return the 
         * truncated integer value.
         */
        REQ("trunc.02;truncf.02;truncl.02", 
            "It shall return the truncated integer value", 
            compare_Unifloat(model_res, trunc_spec) == 0);

#if NAN_SUPPORT == 1
        if (isNan_Unifloat(x))
        {
            /*
             * [MX] If x is NaN, a NaN shall be returned.
             */
            REQ("trunc.03;truncf.03;truncl.03", 
                "If x is NaN, a NaN shall be returned",
                isNan_Unifloat(trunc_spec));
        }
#endif
 
        if (isZero_Unifloat(x) || isInfinity_Unifloat(x))
        {
            /*
             * If x is ±0 or ±Inf, x shall be returned.
             */
            REQ("trunc.04;truncf.04;truncl.04", 
                "If x is ±0 or ±Inf, x shall be returned",
                compare_Unifloat(x, trunc_spec) == 0); 
        }



        return true;
    }
    FILTER_CLEAN;
}

Unifloat* trunc_model(Unifloat* x)
{
    IntT i;
    Unifloat* res = clone(x);

    if (isNan_Unifloat(x) || isInfinity_Unifloat(x) || isZero_Unifloat(x))
        return res;

    if ((res->exp >= PRECISION) && (res->exp > 0) )
        return res;

    if (res->exp < 0) 
        return createZero_Unifloat( x->type);

    for (i = PRECISION; i>res->exp && i > 0; i--)
        setMant_Unifloat(res, i, 0);
    return res;
}

/********************************************************************/
/**                       UNIFLOAT REAL FUNCTIONS                  **/
/********************************************************************/

Unifloat* floor_Unifloat(Unifloat* x)
{
    IntT i, type = x->type;
    Unifloat* res = clone(x);
    
    if(isNan_Unifloat(x)||isInfinity_Unifloat(x) || isZero_Unifloat(x))
        return res;

    if (x->exp <= 0)
    {
        res = createZero_Unifloat( x->type);
        if (x->sign == -1) 
            res = sub_Unifloat(res, convertInteger_Unifloat(1, type));
        return res;
    }

    for(i = x->exp + 1; i < PRECISION + 1; i++)
        setMant_Unifloat(res, i, 0);

    if((x->sign == -1) && (compare_Unifloat(x, res) != 0))
        res = sub_Unifloat(res, convertInteger_Unifloat(1, type));
    
    return res;
}

IntT check_quo_remquo(Unifloat* x, Unifloat* y, Unifloat* quo)
{
    Unifloat* int_quotient, * tmp1, * tmp2, * tmp3;
    Unifloat* One =createOne_Unifloat( x->type);
    Unifloat* Two = convertInteger_Unifloat(2, x->type);
    IntT i;
    int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    IntT type = x->type;

    int_quotient = div_Unifloat(sub_Unifloat(x, remainder_model(x, y)), y);
    if(quo->sign != int_quotient->sign)
        return 0;
    
    int_quotient = nearbyint_model(int_quotient);
    tmp2 = convertInteger_Unifloat(8, x->type);
    tmp3 = sub_Unifloat(quo, int_quotient);
    while(1)
    {
        tmp1 = div_Unifloat(tmp3, tmp2);
        if(isInteger_Unifloat(tmp1))
            return 1;
        else
            return 0;
        /*tmp2 = mul_Unifloat(tmp2, Two);*/
    }
}
