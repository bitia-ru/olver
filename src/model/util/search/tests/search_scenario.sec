/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "util/search/tests/search_scenario.seh"
#include "util/search/search_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include <atl/list.h>

typedef List CByteArrayListList;

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

// Element types
typedef unsigned char elem0[1];
typedef unsigned char elem1[1];
typedef unsigned char elem2[2];
typedef unsigned char elem3[3];
typedef unsigned char elem4[4]; 

/*** Data for bsearch ***/

#define MAX_NUM (5)

static int elem_sizes[MAX_NUM] = {
    sizeof(elem0),
    sizeof(elem1),
    sizeof(elem2),
    sizeof(elem3),
    sizeof(elem4)
};

// Base tables
static elem0 table0[] = {
    {1}
};

static elem1 table1[] = {
    {1}, {5}, {5}, {68}, {127}, {255}
};

static elem2 table2[] = {
    {1, 0}, {1, 1}, {2, 2}, {10, 6}, {10, 127}, {85, 255}, {255, 85}
};

static elem3 table3[] = {
    {1, 2, 3}, {4, 5, 6}, {4, 6, 0}, {4, 6, 0}, {4, 6, 0}, {4, 129, 122}, {10, 0, 0}, {10, 0, 16}, {10, 16, 0}, {254, 52, 61}
};

static elem4 table4[] = {
    {0, 0, 0, 0}, {4, 5, 8, 6}, {4, 213, 120, 3}, {10, 0, 0, 0}, {10, 0, 16, 0}, {10, 16, 0, 0}, {254, 52, 61, 8}
};

static void* tables[MAX_NUM] = {
    (void*)table0,
    (void*)table1,
    (void*)table2,
    (void*)table3,
    (void*)table4
};

static int tsizes[MAX_NUM] = {
    0,
    sizeof(table1) / sizeof(elem1),
    sizeof(table2) / sizeof(elem2),
    sizeof(table3) / sizeof(elem3),
    sizeof(table4) / sizeof(elem4)
};

// Search values
static elem0 search_vals0[] = {{1}, {0}};
static elem1 search_vals1[] = {{1}, {0}, {255}, {5}};
static elem2 search_vals2[] = {{1, 0}, {255, 85}, {1, 2}, {10, 2}, {2, 6}};
static elem3 search_vals3[] = {{1, 2, 4}, {1, 2, 3}, {4, 6, 0}, {10, 0, 122}, {254, 52, 61}};
static elem4 search_vals4[] = {{0, 0, 0, 0}, {254, 52, 61, 8}, {10, 0, 0, 16}, {1, 2, 3, 4}};

static void* search_vals[MAX_NUM] = {
    (void*)search_vals0,
    (void*)search_vals1,
    (void*)search_vals2,
    (void*)search_vals3,
    (void*)search_vals4
};

static int search_sizes[MAX_NUM] = {
    sizeof(search_vals0) / sizeof(elem0),
    sizeof(search_vals1) / sizeof(elem1),
    sizeof(search_vals2) / sizeof(elem2),
    sizeof(search_vals3) / sizeof(elem3),
    sizeof(search_vals4) / sizeof(elem4)
};


/*** Data for qsort ***/

#define MAX_NUM2 (10)

static int qs_elem_sizes[MAX_NUM2] = {
    sizeof(elem0),
    sizeof(elem0),
    sizeof(elem1),
    sizeof(elem1),
    sizeof(elem2),
    sizeof(elem2),
    sizeof(elem3),
    sizeof(elem3),
    sizeof(elem4),
    sizeof(elem4)
};

// Base tables
static elem0 qs_table00[] = {
    {1}
};

static elem0 qs_table01[] = {
    {8}, {1}
};

static elem1 qs_table10[] = {
    {1}, {5}, {6}, {68}, {127}, {255}
};

static elem1 qs_table11[] = {
    {68}, {145}, {5}, {1}, {127}, {5}
};

static elem2 qs_table20[] = {
    {10, 127}, {1, 0}, {2, 2}, {85, 255}, {10, 6}, {1, 1}, {255, 85}
};

static elem2 qs_table21[] = {
    {10, 6}, {10, 6}, {10, 6}, {10, 6}, {255, 85}, {85, 255}, {10, 127}, {10, 6}, {0, 0}
};

static elem3 qs_table30[] = {
    {4, 5, 6}, {4, 129, 122}, {1, 2, 3}, {4, 6, 0}, {10, 0, 16}, {10, 0, 0}, {4, 6, 0}, {10, 16, 0}, {4, 6, 0}, {254, 52, 61}
};

static elem3 qs_table31[] = {
    {1, 2, 3}, {4, 5, 6}, {4, 6, 0}, {4, 6, 0}, {4, 6, 0}, {4, 129, 122}, {10, 0, 16}, {10, 16, 0}, {10, 0, 0}
};

static elem4 qs_table40[] = {
    {0, 0, 0, 0}, {4, 5, 8, 6}, {4, 213, 120, 3}, {10, 0, 0, 0}, {10, 0, 16, 0}, {10, 16, 0, 0}, {254, 52, 61, 8}
};

static elem4 qs_table41[] = {
    {254, 52, 61, 8}, {10, 16, 0, 0}, {10, 0, 16, 0}, {10, 0, 0, 0}, {4, 213, 120, 3}, {4, 5, 8, 6}, {0, 0, 0, 0}
};

static void* qs_tables[MAX_NUM2] = {
    (void*)qs_table00,
    (void*)qs_table01,
    (void*)qs_table10,
    (void*)qs_table11,
    (void*)qs_table20,
    (void*)qs_table21,
    (void*)qs_table30,
    (void*)qs_table31,
    (void*)qs_table40,
    (void*)qs_table41
};

static int qs_tsizes[MAX_NUM2] = {
    0,
    0,
    sizeof(qs_table10) / sizeof(elem1),
    sizeof(qs_table11) / sizeof(elem1),
    sizeof(qs_table20) / sizeof(elem2),
    sizeof(qs_table21) / sizeof(elem2),
    sizeof(qs_table30) / sizeof(elem3),
    sizeof(qs_table31) / sizeof(elem3),
    sizeof(qs_table40) / sizeof(elem4),
    sizeof(qs_table41) / sizeof(elem4)
};


/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context;
static CByteArrayListList* bases;
static CByteArrayListList* qs_bases;
static CByteArrayListList* keys;


/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_search_scenario(int argc, char** argv)
{
    int i, j;
    CByteArrayList* l_tmp;
    CByteArray* ba_tmp;

    // Init test scenario data
    context = getContext();

    bases = create_List(&type_List);
    for (i = 0; i < MAX_NUM; i++)
    {
        l_tmp = create_CByteArrayList();
        for (j=0; j<tsizes[i]; j++)
        {
            ba_tmp = create_CByteArray(((ByteT*)(tables[i])) + j * elem_sizes[i], elem_sizes[i]);
            append_List(l_tmp, ba_tmp);
        }
        append_List(bases, l_tmp);
    }

    qs_bases = create_List(&type_List);
    for (i = 0; i < MAX_NUM2; i++)
    {
        l_tmp = create_CByteArrayList();
        for (j=0; j<qs_tsizes[i]; j++)
        {
            ba_tmp = create_CByteArray(((ByteT*)(qs_tables[i])) + j * qs_elem_sizes[i], qs_elem_sizes[i]);
            append_List(l_tmp, ba_tmp);
        }
        append_List(qs_bases, l_tmp);
    }

    keys = create_List(&type_List);
    for (i = 0; i < MAX_NUM; i++)
    {
        l_tmp = create_CByteArrayList();
        for (j=0; j<search_sizes[i]; j++)
        {
            ba_tmp = create_CByteArray(((ByteT*)(search_vals[i])) + j * elem_sizes[i], elem_sizes[i]);
            append_List(l_tmp, ba_tmp);
        }
        append_List(keys, l_tmp);
    }

    return true;
}

static void finish_search_scenario(void)
{
    TEST_SCENARIO_VERDICT_VERBOSE(search_scenario);
}


/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/


/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario
bool bsearch_scen()
{
    iterate (int base_index = 0; base_index < MAX_NUM; base_index++;)
    {
        iterate (int s_index = 0; s_index < search_sizes[base_index]; s_index++;)
        {
            iterate (int nel = 0; nel <= tsizes[base_index]; nel++;)
            {
                bsearch_spec(context,
                    get_List(get_List(keys, base_index), s_index),  // key
                    get_List(bases, base_index),                    // base
                    nel,                                            // nel
                    elem_sizes[base_index]);                        // width
            }
        }
    }
    return true;
}

scenario
bool lfind_scen()
{
    SizeT index;
    iterate (int base_index = 0; base_index < MAX_NUM; base_index++;)
    {
        iterate (int s_index = 0; s_index < search_sizes[base_index]; s_index++;)
        {
            iterate (SizeT nel = 0; nel <= tsizes[base_index]; nel++;)
            {
                lfind_spec(context,
                    get_List(get_List(keys, base_index), s_index),  // key
                    get_List(bases, base_index),                    // base
                    &nel,                                           // nel
                    elem_sizes[base_index],                         // width
                    &index                                          // index     
                    );                        
            }
        }
    }
    return true;
}

scenario
bool lsearch_scen()
{
    SizeT index;
    iterate (int base_index = 0; base_index < MAX_NUM; base_index++;)
    {
        iterate (int s_index = 0; s_index < search_sizes[base_index]; s_index++;)
        {
            iterate (SizeT nel = 0; nel <= tsizes[base_index]; nel++;)
            {
                lsearch_spec(context,
                    get_List(get_List(keys, base_index), s_index),  // key
                    clone(get_List(bases, base_index)),             // base
                    &nel,                                           // nel
                    elem_sizes[base_index],                         // width
                    &index                                          // index     
                    );                        
            }
        }
    }
    return true;
}

scenario
bool qsort_scen()
{
    iterate (int base_index = 0; base_index < MAX_NUM2; base_index++;)
    {
        iterate (int nel = 0; nel <= qs_tsizes[base_index]; nel++;)
        {
            qsort_spec(context,
                get_List(qs_bases, base_index),                 // base
                nel,                                            // nel
                qs_elem_sizes[base_index]);                     // width
        }
    }
    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm search_scenario =
{
    .init = init_search_scenario,
    .finish = finish_search_scenario,
    .actions = {
        bsearch_scen,
        lfind_scen,
        lsearch_scen,
        qsort_scen,
        NULL
    }
};

#ifdef UTIL_SEARCH_SEARCH_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "util/search/search_media.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initUtilSearchSearchSubsystem();
}


bool main_util_search_search(int argc, char** argv)
{
    search_scenario(argc,argv);
    return true;
}


int main(int argc, char** argv)
{
    //
    initTestSystem();
    loadSUT();

    // Set up tracer
    //setTraceEncoding("windows-1251");

    // Run test scenario
    main_util_search_search(argc,argv);

    //  unloadSUT();
    return 0;
}

#endif
