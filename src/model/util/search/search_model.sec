/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "config/interpretation.seh"
#include "util/search/search_config.h"
#include "util/search/search_model.seh"


#pragma SEC subsystem search "util.search"


/* 
   The group of functions 'util.search.search' consists of: 
       bsearch [1]
       lfind [1]
       lsearch [1]
       qsort [1]
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    bsearch - binary search a sorted table

SYNOPSIS

    #include <stdlib.h>

    void *bsearch(const void *key, const void *base, size_t nel,
           size_t width, int (*compar)(const void *, const void *));

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The bsearch() function shall search an array of nel objects, the initial
    element of which is pointed to by base, for an element that matches the
    object pointed to by key. The size of each element in the array is
    specified by width. If the nel argument has the value zero, the comparison
    function pointed to by compar shall not be called and no match shall be
    found.

    The comparison function pointed to by compar shall be called with two
    arguments that point to the key object and to an array element, in that
    order.

    The application shall ensure that the comparison function pointed to by
    compar does not alter the contents of the array. The implementation may
    reorder elements of the array between calls to the comparison function, but
    shall not alter the contents of any individual element.

    The implementation shall ensure that the first argument is always a pointer
    to the key.

    When the same objects (consisting of width bytes, irrespective of their
    current positions in the array) are passed more than once to the comparison
    function, the results shall be consistent with one another. That is, the
    same object shall always compare the same way with the key.

    The application shall ensure that the function returns an integer less
    than, equal to, or greater than 0 if the key object is considered,
    respectively, to be less than, to match, or to be greater than the array
    element. The application shall ensure that the array consists of all the
    elements that compare less than, all the elements that compare equal to,
    and all the elements that compare greater than the key object, in that
    order.

RETURN VALUE

    The bsearch() function shall return a pointer to a matching member of the
    array, or a null pointer if no match is found. If two or more members
    compare equal, which member is returned is unspecified.

ERRORS

    No errors are defined.

*/

/*
 * The specification function returns 1-based number of the array item found,
 * or zero if bsearch() function returns NULL.
 */

specification
SizeT bsearch_spec(CallContext context, CByteArray* key, CByteArrayList* base,
                   SizeT nel, SizeT width)
    reads base, key
{
    SizeT numEquals;
    pre
    {
        /* [Consistency of test suite] */
        REQ("", "key is not NULL", key != NULL);

        /* [Consistency of test suite] */
        REQ("", "base is not NULL", base != NULL);

        /* [base contains not less than nel elements.] */
        REQ("", "base contains not less than nel elements", nel <= size_List(base));

        /* [width is not zero.] */
        REQ("", "width is not zero", width > 0);

        /* [key has size equal to width.] */
        REQ("", "key has size equal to width", size_CByteArray(key) == width);

        if (nel > 0)
        {
            /*
             * The size of each element in the array is specified by width.
             * [Sizes of all elements are equal to each other because of the
             *  invariant condition, we need to check only one of them.]
             */
            REQ("", "each element has size equal to width", size_CByteArray(get_List(base, 0)) == width);
        }

        /*
         * The application shall ensure that the comparison function pointed to by compar 
         * does not alter the contents of the array.
         */
        REQ("app.bsearch.04", "", TODO_REQ());

        /*
         * When the same objects (consisting of width bytes, irrespective of their current 
         * positions in the array) are passed more than once to the comparison function, 
         * the results shall be consistent with one another. That is, the same object 
         * shall always compare the same way with the key.
         */
        REQ("app.bsearch.06", "", TODO_REQ());

        /*
         * The application shall ensure that the function returns an integer less than, 
         * equal to, or greater than 0 if the key object is considered, respectively, to 
         * be less than, to match, or to be greater than the array element.
         */
        REQ("app.bsearch.07", "", TODO_REQ());

        /*
         * The application shall ensure that the array consists of all the elements that 
         * compare less than, all the elements that compare equal to, and all the 
         * elements that compare greater than the key object, in that order.
         */
        /*
         * [In addition, check_PartSort() function calculates the number of the elements
         *  equal to the searched one.]
         */
        REQ("app.bsearch.08", "array should be partially sorted", check_PartSort(key, base, nel, &numEquals));

        return true;
    }
    coverage C
    {
        if (size_List(base) == 0)
            return {EmptyBase, "The array is empty"};
        else if (nel == 0)
            return {ZeroElems, "0 elements in the array"};
        else if (numEquals == 0)
            return {ZeroPresent, "There is no searched element"};
        else if (numEquals == 1)
            return {OnePresent, "There is the only searched element"};
        else if (numEquals > 1)
            return {MorePresent, "There are several searched elements"};
    }
    C_EVENNESS(nel)

    post
    {
        /*
         * The bsearch() function shall search an array of nel objects, the initial 
         * element of which is pointed to by base, for an element that matches the 
         * object pointed to by key. The size of each element in the array is specified by 
         * width.
         */
        REQ("bsearch.01", "", TODO_REQ());

        /*
         * If the nel argument has the value zero,
         * 
         * the comparison function pointed to by compar shall not be called
         */
        REQ("bsearch.02.01", "", TODO_REQ());

        /*
         * If the nel argument has the value zero,
         * 
         * no match shall be found.
         */
        REQ("bsearch.02.02", "", TODO_REQ());

        /*
         * The comparison function pointed to by compar shall be called with two arguments 
         * that point to the key object and to an array element, in that order.
         * 
         * The implementation shall ensure that the first argument is always a pointer to 
         * the key.
         */
        REQ("bsearch.03.01", "", TODO_REQ());

        /*
         * The implementation may reorder elements of the array between calls to the 
         * comparison function, but shall not alter the contents of any individual 
         * element.
         */
        REQ("bsearch.05", "", TODO_REQ());

        if (numEquals != 0)
        {
            /*
             * The bsearch() function shall return a pointer to a matching member of the array,
             */
            REQ("bsearch.09", "result should point to a matching member of the array",
                T(bsearch_spec != 0)
                &&
                T(equals(key, get_List(base, bsearch_spec - 1)))
               );
        }
        else
        {
            /*
             * or a null pointer if no match is found.
             */
            REQ("bsearch.10", "result should be NULL, if nothing was found", bsearch_spec == 0);
        }

        /*
         * If two or more members compare equal, which member is returned is unspecified.
         */
        REQ("bsearch.11", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    lsearch, lfind - linear search and update

SYNOPSIS

    #include <search.h>

    void *lsearch(const void *key, void *base, size_t *nelp, size_t width,
           int (*compar)(const void *, const void *));
    
    void *lfind(const void *key, const void *base, size_t *nelp,
           size_t width, int (*compar)(const void *, const void *)); 

DESCRIPTION

    The lsearch() function shall linearly search the table and return a pointer
    into the table for the matching entry. If the entry does not occur, it 
    shall be added at the end of the table. The key argument points to the 
    entry to be sought in the table. The base argument points to the first 
    element in the table. The width argument is the size of an element in 
    bytes. The nelp argument points to an integer containing the current number
    of elements in the table. The integer to which nelp points shall be 
    incremented if the entry is added to the table. The compar argument points 
    to a comparison function which the application shall supply (for example, 
    strcmp()). It is called with two arguments that point to the elements being
    compared. The application shall ensure that the function returns 0 if the 
    elements are equal, and non-zero otherwise.

    The lfind() function shall be equivalent to lsearch(), except that if the 
    entry is not found, it is not added to the table. Instead, a null pointer 
    is returned.

RETURN VALUE

    If the searched for entry is found, both lsearch() and lfind() shall return
    a pointer to it. Otherwise, lfind() shall return a null pointer and 
    lsearch() shall return a pointer to the newly added element.

    Both functions shall return a null pointer in case of error.

ERRORS

    No errors are defined.
*/

/*
    Return value of this function is a pair lfind_spec (bool) and index 
    (SizeT*). The first determines whether searched element is in an array or 
    is not. The second represents the index of this element if it is included 
    in the array.
*/

specification
bool lfind_spec(CallContext context, CByteArray* key, CByteArrayList* base,
                SizeT *nelp, SizeT width, SizeT * index)
    reads base, key, *nelp
{
    int m_elem_num;
    pre
    {
        /* [Implicit precondition] */
        REQ("", "key is not NULL", key != NULL);
        REQ("", "base is not NULL", base != NULL);
        REQ("", "nelp is not NULL", nelp != NULL);

        /* [Consistency of test suite] */
        REQ("", "index is not NULL", index != NULL);

        /* [tested part of the array should be less or equal than the array] */
        REQ("", "The nelp argument points to an integer containing the current number of elements in the table",
            *nelp <= size_List(base));

        /* [width is not zero.] */
        REQ("", "width is not zero", width > 0);

        /* [key has size equal to width.] */
        REQ("", "key has size equal to width", size_CByteArray(key) == width);

        if (*nelp > 0)
        {
            /*
             * [Each element has size equal to width.
             *  Sizes of all elements are equal to each other because of the
             *  invariant condition, we need to check only one of them.]
             */
            REQ("", "each element has size equal to width", size_CByteArray(get_List(base, 0)) == width);
        }

        /* [Count number of key elements in the array] */
        m_elem_num = count_CByteArrayList(key, base, nelp);

        /*
         * The application shall ensure that the function returns 0 if the elements are 
         * equal, and non-zero otherwise.
         */
        REQ("app.lfind.04", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        switch (m_elem_num)
        {
        case 0:
            return {ArrayNotIncluded, "The array does not include the element"};
        case 1:
            return {ArrayIncludeOneElem, "The array includes one element"};
        default:
            return {ArrayIncludeManyElem, "The array includes more than one element"};
        }
    }
    C_EVENNESS(*nelp)

    post
    {
        /* [The number of elements in the table has not changed] */
        REQ("", "*nelp should not change", *nelp == @*nelp);

        if (m_elem_num != 0)
        {
            /*
             * The lsearch() function shall linearly search the table and return a pointer 
             * into the table for the matching entry.
             * 
             * The key argument points to the entry to be sought in the table. The base 
             * argument points to the first element in the table. The width argument is the 
             * size of an element in bytes. The nelp argument points to an integer containing 
             * the current number of elements in the table.
             * 
             * If the searched for entry is found, both lsearch() and lfind() shall return a 
             * pointer to it.
             */
            REQ("lfind.01.01.01", "result shall point to a matching member of the array",
                T(lfind_spec)
                &&
                T(equals(key, get_List(base, *index)))
               );

            if(UTIL_SEARCH_LFIND_RETURNS_FIRST_SUITABLE_ELEMENT)
            {
                /* [The lfind() function result shall point to a FIRST matching member of the array] */
                REQ("lfind.01.01.01", "result shall point to a FIRST matching member of the array",
                    is_IndexOfFirstElem(key, base, nelp, *index)
                   );
            }

        }
        else
        {
            /*
             * The lfind() function shall be equivalent to lsearch(), except that if the entry 
             * is not found, it is not added to the table. Instead, a null pointer is 
             * returned.
             * 
             * Otherwise,
             * 
             * lfind() shall return a null pointer
             */
            REQ("lfind.02.01.01", "result shall be NULL", !lfind_spec);
        }

        /*
         * The compar argument points to a comparison function which the application 
         * shall supply (for example, strcmp()). It is called with two arguments that 
         * point to the elements being compared.
         */
        REQ("lfind.03", "", TODO_REQ());

        /*
         * Both functions shall return a null pointer in case of error.
         */
        REQ("lfind.05", "", TODO_REQ());

        return true;
    }
}

/*
    Return value of this function is a pair lfind_spec (bool) and index 
    (SizeT*). The first determines whether searched element is in an array or 
    is not. The second represents the index of this element if it is included 
    in the array.
*/

specification
bool lsearch_spec(CallContext context, CByteArray* key, CByteArrayList* base,
                  SizeT *nelp, SizeT width, SizeT * index)
    reads key
    updates base, *nelp
{
    bool m_elem_num;
    CByteArrayList* m_base;
    SizeT m_nelp;
    pre
    {
        /* [Implicit precondition] */
        REQ("", "key is not NULL", key != NULL);
        REQ("", "base is not NULL", base != NULL);
        REQ("", "nelp is not NULL", nelp != NULL);

        /* [Consistency of test suite] */
        REQ("", "index is not NULL", index != NULL);

        /* [tested part of the array should be less or equal than the array] */
        REQ("", "The nelp argument points to an integer containing the current number of elements in the table",
            *nelp <= size_List(base));

        /* [width is not zero.] */
        REQ("", "width is not zero", width > 0);

        /* [key has size equal to width.] */
        REQ("", "key has size equal to width", size_CByteArray(key) == width);

        if (*nelp > 0)
        {
            /*
             * [Each element has size equal to width.
             *  Sizes of all elements are equal to each other because of the
             *  invariant condition, we need to check only one of them.]
             */
            REQ("", "each element has size equal to width", size_CByteArray(get_List(base, 0)) == width);
        }

        /* [Save pre-state] */
        m_base = clone(base);
        m_nelp = *nelp;

        /* [Count number of key elements in the array] */
        m_elem_num = count_CByteArrayList(key, m_base, nelp);

        /*
         * The application shall ensure that the function returns 0 if the elements are 
         * equal, and non-zero otherwise.
         */
        REQ("app.lsearch.04", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        switch (m_elem_num)
        {
        case 0:
            return {ArrayNotInclude, "The array does not include the element"};
        case 1:
            return {ArrayIncludeOneElem, "The array includes one element"};
        default:
            return {ArrayIncludeManyElem, "The array includes more than one element"};
        }
    }
    C_EVENNESS(*nelp)

    post
    {
        if (m_elem_num != 0)
        {
            /*
             * The lsearch() function shall linearly search the table and return a pointer 
             * into the table for the matching entry.
             * 
             * The key argument points to the entry to be sought in the table. The base 
             * argument points to the first element in the table. The width argument is the 
             * size of an element in bytes. The nelp argument points to an integer containing 
             * the current number of elements in the table.
             * 
             * If the searched for entry is found, both lsearch() and lfind() shall return a 
             * pointer to it.
             */
            REQ("lsearch.01.01.01", "result shall point to a matching member of the array",
                equals(key, get_List(base, *index))
               );

            if(UTIL_SEARCH_LFIND_RETURNS_FIRST_SUITABLE_ELEMENT)
            {
                /* [The lsearch() function result shall point to a FIRST matching member of the array] */
                REQ("", "result shall point to a FIRST matching member of the array",
                    is_IndexOfFirstElem(key, base, nelp, *index)
                   );
            }

            /* [The number of elements in the table has not changed] */
            REQ("", "*nelp should not change", *nelp == m_nelp);

            /* [Checks the consistency of the model state and the target state] */
            REQ("", "the table should not change", 
                equals(subList_List(m_base, 0, m_nelp), subList_List(base, 0, *nelp))
               );
        }
        else
        {
            add_List(m_base, m_nelp, clone(key));
            ++m_nelp;

            /*
             * If the entry does not occur, it shall be added at the end of the table.
             */
            REQ("lsearch.02.01", "the searched item should be added at the end",
                equals(subList_List(m_base, 0, m_nelp), subList_List(base, 0, *nelp))
               );

            /*
             * The integer to which nelp points shall be incremented if the entry is added to 
             * the table.
             */
            REQ("lsearch.02.02", "*nelp should be incremented", *nelp == m_nelp);

            /*
             * Otherwise,
             * 
             * lsearch() shall return a pointer to the newly added element.
             */
            REQ("lsearch.02.03.01", "result shall point to a matching member of the array",
                equals(key, get_List(base, *index))
               );
        }

        /*
         * The compar argument points to a comparison function which the application 
         * shall supply (for example, strcmp()). It is called with two arguments that 
         * point to the elements being compared.
         */
        REQ("lsearch.03", "", TODO_REQ());

        /*
         * Both functions shall return a null pointer in case of error.
         */
        REQ("lsearch.05", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    qsort - sort a table of data

SYNOPSIS

    #include <stdlib.h>

    void qsort(void *base, size_t nel, size_t width,
           int (*compar)(const void *, const void *));

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The qsort() function shall sort an array of nel objects, the initial
    element of which is pointed to by base. The size of each object, in bytes,
    is specified by the width argument. If the nel argument has the value zero,
    the comparison function pointed to by compar shall not be called and no
    rearrangement shall take place.

    The application shall ensure that the comparison function pointed to by
    compar does not alter the contents of the array. The implementation may
    reorder elements of the array between calls to the comparison function, but
    shall not alter the contents of any individual element.

    When the same objects (consisting of width bytes, irrespective of their
    current positions in the array) are passed more than once to the comparison
    function, the results shall be consistent with one another. That is, they
    shall define a total ordering on the array.

    The contents of the array shall be sorted in ascending order according to a
    comparison function. The compar argument is a pointer to the comparison
    function, which is called with two arguments that point to the elements
    being compared. The application shall ensure that the function returns an
    integer less than, equal to, or greater than 0, if the first argument is
    considered respectively less than, equal to, or greater than the second. If
    two members compare as equal, their order in the sorted array is
    unspecified.

RETURN VALUE

    The qsort() function shall not return a value.

ERRORS

    No errors are defined.

*/

specification
void qsort_spec(CallContext context, CByteArrayList* base, SizeT nel, SizeT width)
    updates base
{
    int num_uniques;
    CByteArrayList* m_base;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "base is not NULL", base != NULL);

        /* [base contains not less than nel elements.] */
        REQ("", "base contains not less than nel elements", nel <= size_List(base));

        /* [width is not zero.] */
        REQ("", "width is not zero", width > 0);

        if (nel > 0)
        {
            /*
             * The size of each object, in bytes, is specified by the width argument.
             * [Sizes of all elements are equal to each other because of the
             *  invariant condition, we need to check only one of them.]
             */
            REQ("", "each element has size equal to width", size_CByteArray(get_List(base, 0)) == width);
        }

        /*
         * The application shall ensure that the comparison function pointed to by compar 
         * does not alter the contents of the array.
         */
        REQ("app.qsort.03", "", TODO_REQ());

        /*
         * When the same objects (consisting of width bytes, irrespective of their current 
         * positions in the array) are passed more than once to the comparison function, 
         * the results shall be consistent with one another. That is, they shall define a 
         * total ordering on the array.
         */
        REQ("app.qsort.05", "", TODO_REQ());

        /*
         * The application shall ensure that the function returns an integer less than, 
         * equal to, or greater than 0, if the first argument is considered respectively 
         * less than, equal to, or greater than the second.
         */
        REQ("app.qsort.07", "", TODO_REQ());

        num_uniques = number_Uniques(base, nel);
        m_base = clone(base);

        return true;
    }
    coverage C
    {
        if (nel == 0)
            return {ZeroElems, "Zero elements in array"};
        else if (nel == 1)
            return {OneElem, "One element in array"};
        else if (num_uniques == nel)
            return {UsualArray, "Array without duplicate elements"};
        else if (num_uniques == 1)
            return {AllEqual, "Array with all elements equal"};
        else
            return {SeveralEqual, "Array with several elements equal"};
    }
    C_EVENNESS(nel)

    post
    {
        /*
         * The qsort() function shall sort an array of nel objects, the initial element of 
         * which is pointed to by base. The size of each object, in bytes, is 
         * specified by the width argument.
         * 
         * The contents of the array shall be sorted in ascending order according to a 
         * comparison function.
         */
        REQ("qsort.01.01", "array should be sorted", check_Sort(base, nel));

        /*
         * If the nel argument has the value zero,
         * 
         * the comparison function pointed to by compar shall not be called
         */
        REQ("qsort.02.01", "", TODO_REQ());

        if (nel == 0)
        {
            /*
             * If the nel argument has the value zero,
             * 
             * no rearrangement shall take place.
             */
            REQ("qsort.02.02", "array should not change", equals(base, m_base));
        }

        /*
         * The implementation may reorder elements of the array between calls to the 
         * comparison function, but shall not alter the contents of any individual 
         * element.
         */
        REQ("qsort.04", "array elements shall not be altered",
            equals(toMultiSet_List(base), toMultiSet_List(@base))
           );

        /*
         * The compar argument is a pointer to the comparison function, which is called 
         * with two arguments that point to the elements being compared.
         */
        REQ("qsort.06", "", TODO_REQ());

        /*
         * If two members compare as equal, their order in the sorted array is 
         * unspecified.
         */
        REQ("qsort.08", "", TODO_REQ());

        return true;
    }
}


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

invariant (CByteArrayList* list)
{
    return check_Sizes(list);
}

MultiSet* toMultiSet_List(List* list)
{
    int i;
    MultiSet* ms = create_MultiSet(elemType_List(list));

    for (i=0; i<size_List(list); i++)
        add_MultiSet(ms, get_List(list, i));

    return ms;
}

bool check_PartSort(CByteArray* key, CByteArrayList* base, SizeT nel, SizeT* equals)
{
    int i, tmp, res = -1;

    *equals = 0;
    for (i=0; i<nel; i++)
    {
        tmp = compare(get_List(base, i), key);

        if (tmp < 0)
            tmp = -1;
        else if (tmp > 0)
            tmp = 1;

        if (tmp < res)
            return false;
        res = tmp;

        if (tmp == 0)
            (*equals)++;
    }

    return true;
}

bool check_Sort(CByteArrayList* base, SizeT nel)
{
    int i, res = -1;

    if (nel > 1)
        for (i=0; i<nel-1; i++)
        {
            if (compare(get_List(base, i), get_List(base, i + 1)) > 0)
                return false;
        }

    return true;
}

int number_Uniques(CByteArrayList* base, SizeT nel)
{
    if (nel <= 1)
        return nel;

    return size_Set(toSet_List(subList_List(base, 0, nel)));
}

bool check_Sizes(CByteArrayList* base)
{
    int i;
    SizeT sz = size_List(base);
    SizeT width;

    if (sz < 2)
        return true;

    width = size_CByteArray(get_List(base, 0));
    for (i=1; i<sz; i++)
        if (size_CByteArray(get_List(base, i)) != width)
            return false;

    return true;
}

unsigned int count_CByteArrayList(CByteArray* key, CByteArrayList* base, SizeT *nelp)
{
    int i;
    SizeT res=0;
    for(i=0;i<*nelp;i++)
    {
        if(equals(get_List(base, i), key)) res++;
    }
    return res;
}

bool is_IndexOfFirstElem(CByteArray* key, CByteArrayList* base, SizeT *nelp, SizeT index)
{
    bool res=false; unsigned int i;
    for(i=0;i<*nelp;i++)
    {
        if(equals(get_List(base, i), key))
        {
            if(index==i) return true;
            else return false;
        }
    }
    return false;
}

CByteArrayList* create_CByteArrayList(void)
{
    return create(&type_CByteArrayList, &type_CByteArray);
}
