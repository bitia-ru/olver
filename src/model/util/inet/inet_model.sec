/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "util/inet/inet_config.h"
#include "common/common_model.seh"
#include "util/inet/inet_model.seh"
#include "data/errno_model.seh" 

#include "data/netinet/in_model.seh"
#pragma SEC subsystem inet "util.inet"


/* 
   The group of functions 'util.inet' consists of: 
       inet_addr [1]
       inet_ntoa [1]
       inet_ntop [1]
       inet_pton [1]
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    inet_addr - IPv4 address manipulation
  
SYNOPSIS

    #include <arpa/inet.h>

    in_addr_t inet_addr(const char *cp);

DESCRIPTION

    The inet_addr() function shall convert the string pointed to by cp, in the
    standard IPv4 dotted decimal notation, to an integer value suitable for use
    as an Internet address.

    All Internet addresses shall be returned in network order (bytes ordered
    from left to right).

    Values specified using IPv4 dotted decimal notation take one of the
    following forms:

        a.b.c.d

        When four parts are specified, each shall be interpreted as a byte of
        data and assigned, from left to right, to the four bytes of an Internet
        address.

  
        a.b.c

        When a three-part address is specified, the last part shall be
        interpreted as a 16-bit quantity and placed in the rightmost two bytes
        of the network address. This makes the three-part address format
        convenient for specifying Class B network addresses as "128.net.host".


        a.b

        When a two-part address is supplied, the last part shall be interpreted
        as a 24-bit quantity and placed in the rightmost three bytes of the
        network address. This makes the two-part address format convenient for
        specifying Class A network addresses as "net.host".


        a

        When only one part is given, the value shall be stored directly in the
        network address without any byte rearrangement.


    All numbers supplied as parts in IPv4 dotted decimal notation may be
    decimal, octal, or hexadecimal, as specified in the ISO C standard (that
    is, a leading 0x or 0X implies hexadecimal; otherwise, a leading '0'
    implies octal; otherwise, the number is interpreted as decimal).

RETURN VALUE

    Upon successful completion, inet_addr() shall return the Internet address.
    Otherwise, it shall return ( in_addr_t)(-1).

ERRORS

    No errors are defined.
*/

specification
InAddrT* inet_addr_spec( CallContext context, CString* address)
{
    InAddrT* tmp;
    pre
    {        
        return address!=NULL;  
    }
    coverage C
    {        
        int parts=inet_addr_how_many_parts(address);        
        
        switch(parts)
        {
            case 4:  return {Four,  "Address contains four parts"};  break;
            case 3:  return {Three, "Address contains three parts"}; break;
            case 2:  return {Two,   "Address contains two parts"};   break;
            case 1:  return {One,   "Address contains one part"};    break;
            default: return {Invalid, "Invalid address"};
        }        
    }
    post
    {        
        InAddrT* expected_inet_addr;
        
        REQ("", "Address didn't change", equals(address, @address));        
        
        /*
         *   [All this requirements are completed in inet_addr_model function
         *   or in it's subfunctions]
         */

        /*
         *  Values specified using IPv4 dotted decimal notation take one of the
         *  following forms:
         *
         *      a.b.c.d
         *
         *      When four parts are specified, each shall be interpreted as a
         *      byte of data and assigned, from left to right, to the four
         *      bytes of an Internet address.
         *
         *
         *      a.b.c
         *
         *      When a three-part address is specified, the last part shall be
         *      interpreted as a 16-bit quantity and placed in the rightmost
         *      two bytes of the network address. This makes the three-part
         *      address format convenient for specifying Class B network
         *      addresses as "128.net.host".
         *
         *
         *      a.b
         *
         *      When a two-part address is supplied, the last part shall be
         *      interpreted as a 24-bit quantity and placed in the rightmost
         *      three bytes of the network  address. This makes the two-part
         *      address format convenient for specifying Class A network
         *      addresses as "net.host".
         *
         *
         *      a
         *
         *      When only one part is given, the value shall be stored directly
         *      in the network address without any byte rearrangement.
         */
        /*
         *  All numbers supplied as parts in IPv4 dotted decimal notation may
         *  be decimal, octal, or hexadecimal, as specified in the ISO C
         *  standard (that is, a leading 0x or 0X implies hexadecimal;
         *  otherwise, a leading '0' implies octal; otherwise, the number is
         *  interpreted as decimal).
         */
        /*        
         *  Upon successful completion, inet_addr() shall return the Internet
         *  address.
         */
        /*        
         *   Otherwise, it shall return ( in_addr_t)(-1).
         */
        

        expected_inet_addr=inet_addr_model(address);        

        tmp=expected_inet_addr;
        
        VERBOSE("\n%s", *address);
        VERBOSE("\n%d %d %d %d", (unsigned char)tmp->arr[0],
                                (unsigned char)tmp->arr[1],
                                (unsigned char)tmp->arr[2],
                                (unsigned char)tmp->arr[3]);
        tmp=inet_addr_spec;
        VERBOSE("\n%d %d %d %d", (unsigned char)tmp->arr[0],
                                (unsigned char)tmp->arr[1],
                                (unsigned char)tmp->arr[2],
                                (unsigned char)tmp->arr[3]);        
        
        /*
         * The inet_addr() function shall convert the string pointed to by cp,
         * in the standard IPv4 dotted decimal notation, to an integer value
         * suitable for use as an Internet address.
         */
        REQ("inet_addr.01",
            "Returning value must be equal to expected value",
            equals(expected_inet_addr, inet_addr_spec)
            );
        
        IMPLEMENT_REQ("inet_addr.02;inet_addr.03;inet_addr.04;inet_addr.05");

        return true;
    }
}

//Modelling inet_addr function
InAddrT* inet_addr_model(CString* address)
{
    int i=inet_addr_how_many_parts(address);
    InAddrT* MinusOne;
    if(i>0)
    {        
        return inet_addr_get_input_parts(address, i);
    }
    else
    {
        MinusOne=create_InAddrT((CharT)255,(CharT)255,
                                                (CharT)255,(CharT)255);            
        return MinusOne;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    inet_addr, inet_ntoa - IPv4 address manipulation

SYNOPSIS

    #include <arpa/inet.h>

    char *inet_ntoa(struct in_addr in);

DESCRIPTION

    The inet_ntoa() function shall convert the Internet host address specified
    by in to a string in the Internet standard dot notation.

    The inet_ntoa() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

    All Internet addresses shall be returned in network order (bytes ordered
    from left to right).

    Values specified using IPv4 dotted decimal notation take one of the
    following forms:

        a.b.c.d

        When four parts are specified, each shall be interpreted as a byte of
        data and assigned, from left to right, to the four bytes of an Internet
        address.

        a.b.c
        
        When a three-part address is specified, the last part shall be
        interpreted as a 16-bit quantity and placed in the rightmost two bytes
        of the network address. This makes the three-part address format
        convenient for specifying Class B network addresses as "128.net.host".

        a.b

        When a two-part address is supplied, the last part shall be interpreted
        as a 24-bit quantity and placed in the rightmost three bytes of the
        network address. This makes the two-part address format convenient for
        specifying Class A network addresses as "net.host".

        a

        When only one part is given, the value shall be stored directly in the
        network address without any byte rearrangement.

    
RETURN VALUE

    The inet_ntoa() function shall return a pointer to the network address in
    Internet standard dot notation.

ERRORS

    No errors are defined.
*/

specification
CString* inet_ntoa_spec( CallContext context, InAddrT* address)
{
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        CString* a=inet_ntoa_spec;
        CString* b=inet_ntoa_model(address);

        if(a!=NULL)
            traceFormattedUserInfo("inet_ntoa_spec==%s\n", *a);
        if(b!=NULL)
            traceFormattedUserInfo("inet_ntoa_model(address)==%s\n", *b);

        /*
         * The inet_ntoa() function shall return a pointer to the network
         * address in Internet standard dot notation.
         */        
        REQ("inet_ntoa.03", "The inet_ntoa() function shall return a pointer\
            to the network address in Internet standard dot notation.",
            equals(inet_ntoa_spec, inet_ntoa_model(address)));

        /*
         * The inet_ntoa() function shall convert the Internet host address
         * specified by in to a string in the Internet standard dot notation.
         */
        /*
         * All Internet addresses shall be returned in network order (bytes
         * ordered from left to right).
         */
        IMPLEMENT_REQ("inet_ntoa.01;inet_ntoa.02");        

        return true;
    }
}

//Modelling inet_ntoa function
CString* inet_ntoa_model(InAddrT* address)
{
    CString* ret=create_CString("");
    CString* dot=create_CString(".");
    CString* part;
    int i;
    if(__BYTE_ORDER == __LITTLE_ENDIAN)
    {
        for(i=0;i<3;i++)
        {
            part=inet_ntop_int2CString((unsigned char)address->arr[i], 10);
            part=concat_CString(dot, part);
            ret=concat_CString(part, ret);
        }
        part=inet_ntop_int2CString((unsigned char)address->arr[i], 10);
        ret=concat_CString(part, ret);
    }
    else
    {
        for(i=0;i<3;i++)
        {
            part=inet_ntop_int2CString((unsigned char)address->arr[i], 10);
            part=concat_CString(part, dot);
            ret=concat_CString(ret, part);
        }
        part=inet_ntop_int2CString((unsigned char)address->arr[i], 10);
        ret=concat_CString(ret, part);
    } 
    return ret;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    inet_ntop - convert IPv4 and IPv6 addresses between binary and text form

SYNOPSIS

    #include <arpa/inet.h>

    const char *inet_ntop(int af, const void *restrict src,
                                char *restrict dst, socklen_t size);

DESCRIPTION

    The inet_ntop() function shall convert a numeric address into a text
    string suitable for presentation.

    The af argument shall specify the family of the address.
    This can be SUT_AF_INET or SUT_AF_INET6.

    The src argument points to a buffer holding an IPv4 address if the af
    argument is SUT_AF_INET, or an IPv6 address if the af argument is SUT_AF_INET6;
    the address must be in network byte order.

    The dst argument points to a buffer where the function stores the
    resulting text string; it shall not be NULL.

    The size argument specifies the size of this buffer, which shall be
    large enough to hold the text string (INET_ADDRSTRLEN characters for IPv4,
    INET6_ADDRSTRLEN characters for IPv6). 


RETURN VALUE

    The inet_ntop() function shall return a pointer to the buffer
    containing the text string if the conversion succeeds, and NULL otherwise,
    and set errno to indicate the error.

ERRORS

    The inet_ntop() function shall fail if:


    [EAFNOSUPPORT]

    The af argument is invalid.


    [ENOSPC]

    The size of the inet_ntop() result buffer is inadequate.

*/

specification
VoidTPtr inet_ntop_spec( CallContext context, IntT af, VoidTPtr src,
                               VoidTPtr dst,  IntT size, ErrorCode* errno)
{
    pre
    {
        /*
         * The dst argument points to a buffer where the function stores
         * the resulting text string;
         * 
         * it shall not be NULL.
         */
        REQ("app.inet_ntop.04.05", "dst!=NULL", !isNULL_VoidTPtr(dst));

        /*
         * The size argument specifies the size of this buffer, which
         * shall be large enough to hold the text string (INET_ADDRSTRLEN
         * characters for IPv4, [IP6] INET6_ADDRSTRLEN characters for IPv6). 
         */
        IMPLEMENT_REQ("app.inet_ntop.05");
        
        return !isNULL_VoidTPtr(dst);
    }
    coverage C
    {        
        if(af==SUT_AF_INET)
        {
            if(size>=SUT_INET_ADDRSTRLEN)
            {
                VERBOSE("SUT_AF_INET_size_enough\n");
                return {ipv4_size_ok, "af == SUT_AF_INET, size is enough"};
            }
            else
            {
                VERBOSE("SUT_AF_INET_size_!enough\n");
                return {ipv4_len_bad, "af == SUT_AF_INET, size isn't enough"};
            }
        }
        else
        if(af==SUT_AF_INET6 && IS_IPV6)
        {
            if(size>=SUT_INET6_ADDRSTRLEN)
            {            
                VERBOSE("SUT_AF_INET6, size is enough\n");
                return {ipv6_size_ok,
                    "SUT_AF_INET6 is defined, af == SUT_AF_INET6, size is enough"};
            }
            else
            {
                VERBOSE("SUT_AF_INET6, size isn't enough\n");
                return {ipv6_size_bad,
                    "SUT_AF_INET6 is defined, af == SUT_AF_INET6, size isn't enough"};
            }
        }
        else
        {
            VERBOSE("error: af==%d\n, SUT_AF_INET6==%d, SUT_AF_INET==%d,"
                " IS_IPV6==%d", af, SUT_AF_INET6, SUT_AF_INET, IS_IPV6);
            return { Invalid, "Invalid value for af" };
        }
    }
    post
    {        
        CString* ret, *expected_ret, *expected_ret2;

        ERROR_BEGIN(POSIX_INET_NTOP, "inet_ntop.08.01", isNULL_VoidTPtr(inet_ntop_spec),
                 *errno )
        /*
         * The inet_ntop() and inet_pton() functions shall fail if:
         * 
         * [EAFNOSUPPORT] 
         * 
         * The af argument is invalid. 
         */
            ERROR_SHALL(POSIX_INET_NTOP, EAFNOSUPPORT, "inet_ntop.08.01",
                (   @af!=SUT_AF_INET && @af!=SUT_AF_INET6
                ||  @af==SUT_AF_INET6 && !IS_IPV6
                ))

        /*
         * The inet_ntop() and inet_pton() functions shall fail if:
         * 
         * [ENOSPC] 
         * 
         * The size of the inet_ntop() result buffer is inadequate. 
         */
            ERROR_SHALL(POSIX_INET_NTOP, ENOSPC, "inet_ntop.08.02",
                (  @size<SUT_INET_ADDRSTRLEN  && @af==SUT_AF_INET
                || @size<SUT_INET6_ADDRSTRLEN && @af==SUT_AF_INET6 && IS_IPV6
                ))

        ERROR_END()
       
        /*
         *  The inet_ntop() function shall return a pointer to the buffer
         *  containing the text string if the conversion succeeds, and NULL
         *  otherwise, and set errno to indicate the error.
         */
        REQ("inet_ntop.06",
        "Inet_ntop returned not-NULL value, checking for correct error code",
            *errno!=SUT_EAFNOSUPPORT || *errno!=SUT_ENOSPC);        


        ret=readCString_VoidTPtr(inet_ntop_spec);        
        VERBOSE("ret==%s\n", *ret);

        //Getting first form of the expected model state
        expected_ret=inet_ntop_model(af, src);
        VERBOSE("expected_ret==%s\n", *expected_ret);

        //Bringing ret value to more convenient form for easy checking
        ret=inet_ntop_tolower(ret);
        ret=inet_ntop_ipv6_make_full_zeroes(ret);
        VERBOSE("after convert ret==%s\n", *ret);        

        //Getting second form of the expected model state
        expected_ret2=inet_ntop_convert_last_4bytes(expected_ret);
        VERBOSE("expected_ret2==%s\n",
                *expected_ret2);        

        /*
         *  The inet_ntop() function shall convert a numeric address into
         *  a text string suitable for presentation.
         */
        REQ("inet_ntop.01", "Checking correctness of the return value",
                equals(ret, expected_ret)
            ||  equals(ret, expected_ret2));


        /*
         * The af argument shall specify the family of the address.
         * This can be AF_INET [IP6]  or AF_INET6. 
         */
        /*
         * The src argument points to a buffer holding an IPv4 address if the
         * af argument is AF_INET, [IP6]  or an IPv6 address if the af
         * argument is AF_INET6; the address must be in network byte order.
         */
        /*
         * The dst argument points to a buffer where the function stores
         * the resulting text string;
         */
        IMPLEMENT_REQ("inet_ntop.02;inet_ntop.03;inet_ntop.04");       
        
        return true;
    }
}

//Modelling inet_ntop function
CString* inet_ntop_model(int af, VoidTPtr src)
{
    if(af==SUT_AF_INET)
        return inet_ntop_model_ipv4(src);    
    else
        return inet_ntop_model_ipv6(src);

    return 0;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    inet_pton - convert IPv4 and IPv6 addresses between binary and text form

SYNOPSIS

    #include <arpa/inet.h>

    int inet_pton(int af, const char *restrict src, void *restrict dst);

DESCRIPTION


    The inet_pton() function shall convert an address in its standard text
    presentation form into its numeric binary form.The af argument shall
    specify the family of the address. The SUT_AF_INET [IP6]   and SUT_AF_INET6
    address families shall be supported. The src argument points to the
    string being passed in. The dst argument points to a buffer into which
    the function stores the numeric address; this shall be large enough to
    hold the numeric address (32 bits for SUT_AF_INET, 128 bits for SUT_AF_INET6). 

    
    If the af argument of inet_pton() is SUT_AF_INET, the src string shall be in
    the standard IPv4 dotted-decimal form:

    ddd.ddd.ddd.ddd

    where "ddd" is a one to three digit decimal number between 0 and 255
    (see inet_addr()). The inet_pton() function does not accept other formats
    (such as the octal numbers, hexadecimal numbers, and fewer than four
    numbers that inet_addr() accepts).

    [IP6]  If the af argument of inet_pton() is SUT_AF_INET6, the src string shall
    be in one of the following standard IPv6 text forms:

    The preferred form is "x:x:x:x:x:x:x:x", where the 'x' s are the
    hexadecimal values of the eight 16-bit pieces of the address. Leading zeros
    in individual fields can be omitted, but there shall be at least one
    numeral in every field.

    A string of contiguous zero fields in the preferred form can be shown as
    "::". The "::" can only appear once in an address. Unspecified addresses
    ( "0:0:0:0:0:0:0:0" ) may be represented simply as "::".

    A third form that is sometimes more convenient when dealing with a mixed
    environment of IPv4 and IPv6 nodes is "x:x:x:x:x:x:d.d.d.d", where the 'x'
    s are the hexadecimal values of the six high-order 16-bit pieces of the
    address, and the 'd' s are the decimal values of the four low-order 8-bit
    pieces of the address (standard IPv4 representation).    

RETURN VALUE

    The inet_pton() function shall return 1 if the conversion succeeds, with
    the address pointed to by dst in network byte order. It shall return 0 if
    the input is not a valid IPv4 dotted-decimal string [IP6]  or a valid IPv6
    address string,  or -1 with errno set to [EAFNOSUPPORT] if the af argument
    is unknown.

ERRORS

    The inet_pton() function shall fail if:


    [EAFNOSUPPORT]

    The af argument is invalid.
*/
specification
int inet_pton_spec( CallContext context, IntT af, VoidTPtr src,
                               VoidTPtr dst, ErrorCode* errno)
{
    CByteArray* bin_val, *ret;
    int size=(af==SUT_AF_INET? 4: (af==SUT_AF_INET6? 16:0)), af_pre=af;
    CString* src_pre, *tmp;
    
    pre
    {
        /*
         * The dst argument points to a buffer into which the function stores
         * the numeric address; this shall be large enough to hold the numeric
         * address (32 bits for AF_INET, [IP6]  128 bits for AF_INET6). 
         */
        REQ("inet_pton.04", "dst!=NULL", !isNULL_VoidTPtr(dst));

        /*
         * The src argument points to the string being passed in. 
         */
        REQ("inet_pton.03", "src!=NULL", !isNULL_VoidTPtr(src));
        
        src_pre=readCString_VoidTPtr(src);
        
        VERBOSE("src_pre before if==%s\n", *src_pre);
        if(af==SUT_AF_INET6)
        {
            tmp=inet_ntop_ipv6_make_full_zeroes(src_pre);
            if(tmp!=NULL)
                src_pre=tmp;
        }

        VERBOSE("src_pre==%s\n", *src_pre);

        if(size)
        {
            bin_val=readCByteArray_VoidTPtr(dst, size);
            return bin_val!=NULL;
        }
        else
            return true;
    }
    coverage C
    {
        if(af==SUT_AF_INET)
        {
            return {ipv4, "Af indicates that we do with ipv4 format"};
        }
        else
        if(af==SUT_AF_INET6)
        {
            return {ipv6, "Af indicates that we do with ipv6 format"};
        }
        else
            return {Invalid, "Invalid value for af"};
    }
    post
    {
        IntT i;

        ERROR_BEGIN(POSIX_INET_PTON, "inet_pton.08", inet_pton_spec == -1,
                *errno)
        /*
         * The inet_ntop() and inet_pton() functions shall fail if:
         * 
         * [EAFNOSUPPORT] 
         * 
         * The af argument is invalid. 
         */
        /*
         * The inet_pton() function shall return
         * 
         * -1 with errno set to [EAFNOSUPPORT] if the af argument is unknown.
         */
            ERROR_SHALL(POSIX_INET_PTON, EAFNOSUPPORT,
                "inet_pton.07.03;inet_pton.08.01",
                (   @af!=SUT_AF_INET && @af!=SUT_AF_INET6
                ||  @af==SUT_AF_INET6 && !IS_IPV6
                ))

        /*
         * The inet_ntop() and inet_pton() functions shall fail if:
         * 
         * [ENOSPC] 
         * 
         * The size of the inet_ntop() result buffer is inadequate. 
         */
            ERROR_UNCHECKABLE(POSIX_INET_PTON, ENOSPC, "inet_pton.08.02",
                "What does it mean: inadequate?")

        ERROR_END()
        
        if(inet_pton_spec==0)   
        {
            /*
             * The inet_pton() function shall return
             * 
             * 0 if the input is not a valid IPv4 dotted-decimal string [IP6]
             * or a valid IPv6 address string
             */
            REQ("inet_pton.07.02",
            "inet_pton_spec returned 0, checking src for incorrectness",
             !inet_pton_correct_src(src_pre, af_pre));

            return true;
        }
        
        REQ("",
        "inet_pton_spec returned not 0, checking src for correctness",
         inet_pton_correct_src(src_pre, af_pre));

        /*
         * The inet_pton() function shall convert an address in its standard text 
         * presentation form into its numeric binary form.
         */
        IMPLEMENT_REQ("inet_pton.01");

        /*
         * The af argument shall specify the family of the address.
         * The AF_INET [IP6] and AF_INET6 address families shall be supported.
         */
        IMPLEMENT_REQ("inet_pton.02");

        /*
         *  [Implicit postcondition: function must return -1, 0, 1
         *  and nothing else]
         */
        if(inet_pton_spec==1)
        {
            inet_pton_model(af_pre, src_pre, bin_val);
            ret=readCByteArray_VoidTPtr(dst, size);
            if(ret!=NULL  && bin_val!=NULL)
            {
                if(af==SUT_AF_INET)
                {                
                    for(i=0;i<4;i++)
                        VERBOSE("%d ", byteAt_CByteArray(ret, i));
                    VERBOSE("\n");
                    for(i=0;i<4;i++)
                        VERBOSE("%d ", byteAt_CByteArray(bin_val, i));
                    VERBOSE("\n");
                }
                else
                {
                    for(i=0;i<16;i++)
                        VERBOSE("%d ", byteAt_CByteArray(ret, i));
                    VERBOSE("\n");
                    for(i=0;i<16;i++)
                        VERBOSE("%d ", byteAt_CByteArray(bin_val, i));
                    VERBOSE("\n");
                }

                /*
                 * The inet_pton() function shall return
                 * 
                 * 1 if the conversion succeeds, with the address pointed
                 * to by dst in network byte order
                 */
                REQ("inet_pton.07.01",
                    "Checking model result with target function result",
                    equals(ret, bin_val));

                return true;
            }    
        }       

        return false;
    }
}

//Modelling  inet_pton function
//This function is similar to inet_pton_correct_src with the only difference
//that in writes dst parameter, which is similar to inet_pton's dst
//parameter
bool inet_pton_model(int af_pre, CString* src_pre, CByteArray* dst)
{
    int i, size=length_CString(src_pre), num_dot, num_colon, j, tmp, k=-1;
    CString* part;
    CString* src=substring_CString(src_pre, 0, size);    

    /*
     * If the af argument of inet_pton() is AF_INET6, the src string shall
     * be in one of the following standard IPv6 text forms:
     * 
     * The preferred form is "x:x:x:x:x:x:x:x", where the 'x' s are the 
     * hexadecimal values of the eight 16-bit pieces of the address.
     * Leading zeros in individual fields can be omitted, but there shall
     * be at least one numeral in every field.
     */
    IMPLEMENT_REQ("inet_pton.06.01");

    /*
     * If the af argument of inet_pton() is AF_INET6, the src string
     * shall be in one of the following standard IPv6 text forms:
     * 
     * A string of contiguous zero fields in the preferred form can be
     * shown as "::". The "::" can only appear once in an address.
     * Unspecified addresses ( "0:0:0:0:0:0:0:0" ) may be represented
     * simply as "::".
     */
    IMPLEMENT_REQ("inet_pton.06.02");

    /*
     * If the af argument of inet_pton() is AF_INET6, the src string
     * shall be in one of the following standard IPv6 text forms:
     * 
     * A third form that is sometimes more convenient when dealing with
     * a mixed environment of IPv4 and IPv6 nodes is "x:x:x:x:x:x:d.d.d.d", 
     * where the 'x' s are the hexadecimal values of the six high-order
     * 16-bit pieces of the address, and the 'd' s are the decimal values
     * of the four low-order 8-bit pieces of the address (standard
     * IPv4 representation).
     */
    IMPLEMENT_REQ("inet_pton.06.03");

    //Checking src_pre format, depending on af_pre parameter value
    if(af_pre==SUT_AF_INET)
    {
        //If src_pre is in IPV4 format
        num_dot=0;
        j=i=0;

        while(num_dot<4)
        {
            //Finding part of the address
            while(i<size && charAt_CString(src, i)!='.')
                i++;

            part=substring_CString(src, j, i);

            j=++i;

            //Checking part for correctness
            tmp=inet_pton_correct_part_dec(part);
            
            if(tmp==-1)
                return false;

            //If part is correct, writing it into dst
            setByteAt_CByteArray(dst, ++k, (unsigned char)tmp);

            //Adding number of dots, if needed
            if(i-1<size)            
                ++num_dot;
            else
            //If we reach end of string, then number of dots must be equal to 3
                return num_dot==3;            
        }        

        //If number of dots in the address is more than 3, src_pre couldn't be
        //passed to inet_pton function
        return false;
    }
    else    
    {
        //If src_pre is in IPV6 format
        num_dot=num_colon=0;
        j=i=0;
        
        while(num_colon<8)
        {
            //Finding part of the address
            while(i<size && charAt_CString(src, i)!=':'
                         && charAt_CString(src, i)!='.')
                i++;            

            part=substring_CString(src, j, i);

            j=++i;            

            if(i-1<size)
            {
                //Checking part for correctness, depending on kind of part:
                if(charAt_CString(src, i-1)=='.' || num_dot>0)
                {
                    //if part is from last 4 components of IPV6 address in
                    //third form, then it must be correct as IPV4 part
                    tmp=inet_pton_correct_part_dec(part);

                    if(tmp==-1)
                        return false;

                    //If part is correct, writing it into dst
                    setByteAt_CByteArray(dst, ++k, (unsigned char)tmp);
                }
                else
                {
                    //else part must be correct as IPV6 part
                    tmp=inet_pton_correct_part_hex(part);

                    if(tmp==-1)
                        return false;

                    //If part is correct, writing it into dst
                    setByteAt_CByteArray(dst, ++k,
                                (unsigned char)(((unsigned long)tmp>>8)&255));
                    setByteAt_CByteArray(dst, ++k,
                                (unsigned char)(((unsigned long)tmp)&255));
                }

                //Adding number of colons if we needed.
                if(charAt_CString(src, i-1)==':')
                {
                    if(num_dot==0)
                        ++num_colon;
                    else
                    //If we found colon after finding dot, then address is
                    //incorrect
                        return false;
                }
                else
                //Adding number of dots if we needed.
                {
                    ++num_dot;
                    //If we found three dots, then they are equal to one colon
                    if(num_dot==3)
                        ++num_colon;
                    //If number of dots is more than three, then address is
                    //incorrect
                    if(num_dot>3)
                        return false;
                }                
            }
            else
            {
                //Checking part for correctness, depending on kind of part:
                if(num_dot>0)
                {
                    //if part is from last 4 components of IPV6 address in
                    //third form, then it must be correct as IPV4 part
                    tmp=inet_pton_correct_part_dec(part);

                    if(tmp==-1)
                        return false;

                    //If part is correct, writing it into dst
                    setByteAt_CByteArray(dst, ++k, (unsigned char)tmp);
                }
                else
                {
                    //else part must be correct as IPV6 part
                    tmp=inet_pton_correct_part_hex(part);

                    if(tmp==-1)
                        return false;

                    //If part is correct, writing it into dst
                    setByteAt_CByteArray(dst, ++k,
                                (unsigned char)(((unsigned long)tmp>>8)&255));
                    setByteAt_CByteArray(dst, ++k,
                                (unsigned char)(((unsigned long)tmp)&255));
                }                

                //if we reach end of string, then number of colons must be
                //equal to 7
                return num_colon==7;
            }
        }
         //If number of colons in the address is more than 7, src_pre couldn't
        //be passed to inet_pton function
        return false;
    }
  
}

/********************************************************************/
/**                       Specifitation Types                      **/
/********************************************************************/

specification typedef struct InAddrT InAddrT={};

//Creating InAddrT object
InAddrT* create_InAddrT(CharT arr0, CharT arr1, CharT arr2, CharT arr3)
{
    CharT ret[4];
    ret[0] = arr0;
    ret[1] = arr1;
    ret[2] = arr2;
    ret[3] = arr3;
    
    return create(&type_InAddrT, ret);;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

//Geting number of part of address.
//Returning 0 if format is incorrect for inet_addr function
int inet_addr_how_many_parts(CString* address)
{
    int i;
    for(i=4;i>0;i--)
        if(inet_addr_num_input_parts(address, i))
            return i;

    return 0;
}

//Checking if our address has "num" parts
bool inet_addr_num_input_parts(CString* address, int num)
{
    int i=-1, j;
    CString* tmp=address;
    CString* tmp2;    
    unsigned long maxes[4]={4294967295, 16777215, 65535, 255 };

    for(j=0;j<num-1;j++)
    {
        tmp=substring_CString(tmp, i+1, length_CString(tmp));   

        i=indexOfChar_CString(tmp, '.');    

        if(i==-1)
           return false;        
        
        tmp2=substring_CString(tmp, 0, i);          

        VERBOSE("bef: j==%d;tmp2==%s\n", j, *tmp2);
        VERBOSE("hex==%d,  oct==%d,  dec==%d\n", 
            inet_addr_part_is_hex(tmp2, 255), inet_addr_part_is_oct(tmp2, 255),
            inet_addr_part_is_dec(tmp2, 255));
        
        if(    !inet_addr_part_is_hex(tmp2, 255)
            && !inet_addr_part_is_oct(tmp2, 255)
            && !inet_addr_part_is_dec(tmp2, 255))
            return false;        
        VERBOSE("aft: j==%d;tmp2==%s\n\n", j, *tmp2);
    }

    tmp=substring_CString(tmp, i+1, length_CString(tmp));   
    
    if(    !inet_addr_part_is_hex(tmp, maxes[num-1])
        && !inet_addr_part_is_oct(tmp, maxes[num-1])
        && !inet_addr_part_is_dec(tmp, maxes[num-1]))
        return false;

    return true;
}

//Getting parts of the address.
//We must know that address contains exactly "num" parts
InAddrT* inet_addr_get_input_parts(CString* address, int num)
{
    CharT arr[4]={(CharT)0,(CharT)0,(CharT)0,(CharT)0};
    unsigned long maxes[4]={4294967295, 16777215, 65535, 255 };
    InAddrT* ret;
    int i=-1, j;
    CString* tmp=address;
    CString* tmp2;

    unsigned long res;

    //Getting parts
    for(j=0;j<num-1;j++)
    {
        tmp=substring_CString(tmp, i+1, length_CString(tmp));   

        i=indexOfChar_CString(tmp, '.');    

        tmp2=substring_CString(tmp, 0, i);          

        if(inet_addr_part_is_hex(tmp2, 255))
        {
            arr[j]=(CharT)inet_addr_part_get_hex(tmp2);
        }
        else
        if(inet_addr_part_is_oct(tmp2, 255))
        {
            arr[j]=(CharT)inet_addr_part_get_oct(tmp2);
        }
        else
        {
            arr[j]=(CharT)inet_addr_part_get_dec(tmp2);
        }   
    }

    tmp=substring_CString(tmp, i+1, length_CString(tmp));   
    
    if(inet_addr_part_is_hex(tmp, maxes[num-1]))
    {
        res=inet_addr_part_get_hex(tmp);        
    }
    else
    if(inet_addr_part_is_oct(tmp, maxes[num-1]))
    {
        res=inet_addr_part_get_oct(tmp);
    }
    else
    {
        res=inet_addr_part_get_dec(tmp);
    }   

    for(i=0;i<(5-num);i++)
    {
        arr[3-i]=(CharT)(res & 255);
        res>>=8;
    }   
    
    //returning result
    ret=create_InAddrT(arr[0],arr[1],arr[2],arr[3]);
    
    return ret;
}

//Checking if address part entered is in hexadecimal form
bool inet_addr_part_is_hex(CString* comp, unsigned long max)
{   
    CharT* arr=toCharArray_CString(comp);
    int size=length_CString(comp), i;
    unsigned long res=0;

    //Making uppercase string and checking part for illegal symbols:
    //"comp" must contain only digits, A-F letters, and "0X" prefix
    for(i=0;i<size;i++)
    {
        if(arr[i]>='a' && arr[i]<='f' || arr[i]=='x')
            arr[i]=(CharT)toupper(arr[i]);

        if(!(  arr[i]>='A' && arr[i]<='F'
            || arr[i]>='0' && arr[i]<='9'
            || i==1 && arr[i]=='X'
            )
          )
            return false;
    }

    //If "0X" prefix exists
    if(size>2)
    {
        if(arr[0]=='0' && arr[1]=='X')
        {
            //Getting decimal value of hexadecimal notation.
            //If value is bigger than max then it can't be a part of the
            //address
            for(i=2;i<size;i++)
            {
                if(arr[i]>='A' && arr[i]<='F')
                {
                    if(     res<=res*16+(arr[i]-'A'+10)
                        &&  res*16+(arr[i]-'A'+10)<=max)
                        res=res*16+(arr[i]-'A'+10);
                    else
                        return false;
                }
                else                
                {
                    if(res<=res*16+(arr[i]-'0') && res*16+(arr[i]-'0')<=max)
                        res=res*16+(arr[i]-'0');
                    else
                        return false;
                }
            }       
            return true;
        }
        else
            return false;
    }
    else
        return false;   
}

//Checking if address part entered is in octal form
bool inet_addr_part_is_oct(CString* comp, unsigned long max)
{   
    CharT* arr=toCharArray_CString(comp);
    int size=length_CString(comp), i;
    unsigned long res=0;

    //Checking part for illegal symbols:
    //"comp" must contain only digits from 0 to 7 inclusive
    for(i=0;i<size;i++)
        if(!(arr[i]>='0' && arr[i]<='7'))
            return false;

    //If "0" prefix exists
    if(size>1)
    {
        if(arr[0]=='0')
        {
            //Getting decimal value of octal notation.
            //If value is bigger than max then it can't be a part of the
            //address
            for(i=1;i<size;i++)
            {
                if(res<=res*8+(arr[i]-'0') && res*8+(arr[i]-'0')<=max)
                    res=res*8+(arr[i]-'0');
                else
                    return false;
            }       
            return true;
        }
        else
            return false;
    }
    else
        return false;   
}

//Checking if address part entered is in decimal form
bool inet_addr_part_is_dec(CString* comp, unsigned long max)
{   
    CharT* arr=toCharArray_CString(comp);
    int size=length_CString(comp), i, f=0;
    unsigned long res=0;

    //Checking part for illegal symbols: "comp" must contain only digits
    for(i=0;i<size;i++)
        if(!(arr[i]>='0' && arr[i]<='9'))
            return false;
    
    //If "comp" isn't empty
    if(size>0)
    {   

        //If "comp" begins from "0", then it must be equal to 0
        //Otherwise it is octal number, and we shall return false
        if(arr[0]=='0')
            f=1;
        
        //Getting decimal value of decimal notation.
        //If value is bigger than 255 or smaller than 0,
        //then it can't be a part of the address
        for(i=0;i<size;i++)
        {
            if(res<=res*10+(arr[i]-'0') && res*10+(arr[i]-'0')<=max)
                res=res*10+(arr[i]-'0');
            else
                return false;
        }       

        //Otherwise it is octal number, and we shall return false
        if(res!=0 && f)
            return false;

        return true;
    }
    else
        return false;
}

//Getting decimal value from hexadecimal notation.
//We must know that value is in the hexadecimal notation.
//Otherwise function may bring to crash.
//Check the "comp" with inet_addr_part_is_hex before using this function.
unsigned long inet_addr_part_get_hex(CString* comp)
{   
    CharT* arr=toCharArray_CString(comp);
    int size=length_CString(comp), i;
    unsigned long res=0;

    //Making uppercase string
    for(i=0;i<size;i++)
       if(arr[i]>='a' && arr[i]<='f')
            arr[i]=(CharT)toupper(arr[i]);    

    //Getting decimal value of hexadecimal notation.
    for(i=2;i<size;i++)
    {
        if(arr[i]>='A' && arr[i]<='F')
            res=res*16+(arr[i]-'A'+10);
        else
            res=res*16+(arr[i]-'0');
    }
    return res;
}

//Getting decimal value from octal notation.
//We must know that value is in the octal notation.
//Otherwise function may bring to crash.
//Check the "comp" with "inet_addr_part_is_oct" before using this function.
unsigned long inet_addr_part_get_oct(CString* comp)
{   
    CharT* arr=toCharArray_CString(comp);
    int size=length_CString(comp), i;
    unsigned long res=0;

    //Getting decimal value of octal notation.
    for(i=1;i<size;i++)
        res=res*8+(arr[i]-'0');

    return res; 
}

//Getting decimal value from decimal notation.
//We must know that value is in the decimal notation.
//Otherwise function may bring to crash.
//Check the "comp" with "inet_addr_part_is_dec" before using this function.
unsigned long inet_addr_part_get_dec(CString* comp)
{   
    CharT* arr=toCharArray_CString(comp);
    int size=length_CString(comp), i;
    unsigned long res=0;

    //Getting decimal value of decimal notation.
    for(i=0;i<size;i++)
        res=res*10+(arr[i]-'0');
        
    return res;
}

//Getting string presentation of the unsigned int a, in base "base"
CString* inet_ntop_int2CString(unsigned int a, int base)
{    
    int size=35;
    char* arr=calloc(size, sizeof(char));
    CString* ret;
    int i;    
    for(i=0;i<size-1 && a!=0;++i)
    {
        arr[size-2-i]=inet_ntop_num2char(a%base);
        a/=base;
    }

    //if a is equal to 0 we shall return "0"
    if(i==0)
    {
        arr[size-2]='0';
        ++i;
    }
    arr[size-1]='\0';

    ret=create_CString(arr+size-1-i);

    free(arr);

    return ret;
}

//Modelling return value for function inet_ntop,
//if "src" parameter is in IPV4 form
CString* inet_ntop_model_ipv4(VoidTPtr src)
{
    CByteArray* arr=readCByteArray_VoidTPtr(src, 4);    
    CString* ret=create_CString("");
    CString* dot=create_CString(".");
    CString* part;
    int i;
    
    for(i=0;i<3;i++)
    {        
        part=inet_ntop_int2CString(byteAt_CByteArray(arr, i), 10);
        part=concat_CString(part, dot);
        ret=concat_CString(ret, part);
    }

    part=inet_ntop_int2CString(byteAt_CByteArray(arr, i), 10);    
    ret=concat_CString(ret, part);

    return ret;
}

//Modelling return value for function inet_ntop,
//if "src" parameter is in IPV6 form
CString* inet_ntop_model_ipv6(VoidTPtr src)
{
    CByteArray* arr=readCByteArray_VoidTPtr(src, 16);    
    CString* ret=create_CString("");
    CString* colon=create_CString(":");
    CString* part;
    int param, i;
    
    for(i=0;i<7;i++)
    {
        param=byteAt_CByteArray(arr, 2*i)*256+byteAt_CByteArray(arr, 2*i+1);
        part=inet_ntop_int2CString(param, 16);
        part=concat_CString(part, colon);
        ret=concat_CString(ret, part);
    }

    param=byteAt_CByteArray(arr, 2*i)*256+byteAt_CByteArray(arr, 2*i+1);
    part=inet_ntop_int2CString(param, 16);
    ret=concat_CString(ret, part);     

    return ret;
}

//Converting incomplete addresses in IPV6 form into complete form,
//i.e. removing "::" part of the address and adding "0"-es as necessary
CString* inet_ntop_ipv6_make_full_zeroes(CString* addr)
{
    int i, size=length_CString(addr), j, num_colon=7, num_dots=0;
    CString* ret;
    CString* zero=create_CString("0:");
    CString* tail;
    
    for(i=0;i<size;i++)
    {
        //Counting number of colons, which indicates number of parts,
        //that are actually present in address
        if(charAt_CString(addr, i)==':')
            --num_colon;

        //Address may contain four byte components instead of last two 16-bit
        //part. In this case three dots counts as one colon
        if(charAt_CString(addr, i)=='.')
            ++num_dots;
    }
    
    if(num_dots==3)
        --num_colon;
    else
    if(num_dots!=0)
        return NULL;

    //Finding consecutive colons.
    //If exists adding parts to make address complete and removing them    
    for(i=0;i<size-1;i++)
        if(charAt_CString(addr, i)==':' && charAt_CString(addr, i+1)==':')
        {
            ret=substring_CString(addr, 0, i+1);

            for(j=0;j<num_colon;j++)
            {
                ret=concat_CString(ret, zero);
            }

            zero=create_CString("0");
            ret=concat_CString(ret, zero);

            tail=substring_CString(addr, i+1, size);
            ret=concat_CString(ret, tail);

            zero=create_CString("0");
            if(charAt_CString(ret, 0)==':')
            {
                ret=concat_CString(zero, ret);
            }
            if(charAt_CString(ret, length_CString(ret)-1)==':')
            {
                ret=concat_CString(ret, zero);
            }

            return ret;
        }

    return addr;
}

//Returning tolower(addr)
CString* inet_ntop_tolower(CString* addr)
{
    int i, size=length_CString(addr);
    CharT* arr=calloc(size+1, sizeof(CharT));
    CString* ret;
    CharT curr;
    for(i=0;i<size;i++)
    {
        curr=charAt_CString(addr, i);                
        arr[i]=tolower(curr);
    }
    arr[size]='\0';
    ret=create_CString(arr);
    free(arr);
    return ret;
}

//Addr is in IPV6 first form
//Function returns addr in IPV6 third form

//Note: A more extensive description of the standard representations of IPv6
//addresses can be found in RFC 2373.
CString* inet_ntop_convert_last_4bytes(CString* addr)
{
    int i, size=length_CString(addr), num_colon=2, num_assigned, f=1;
    unsigned long byte4=0;    
    unsigned char bit4;
    
    CString* ret;
    CString* dot=create_CString(".");   

    //if addr isn't in IPV6 first form we return addr unchanged 
    for(i=0;i<size && f==1;i++)
        if(charAt_CString(addr, i)==':')
            f=0;    
    if(f)
        return addr;    
    
    //Else we convert addr's copy to IPV6 third form and return it
    i=size;
    while(num_colon)
    {
        --i;
        if(charAt_CString(addr, i)==':')
            --num_colon;        
    }
    
    //Getting part from addr, which will remain the same
    ret=substring_CString(addr, 0, i+1);

    VERBOSE("in_convert: ret==%s\n", *ret);

    //Getting last 2 16-bit parts of the addr into unsigned long int "byte4"
    i=size-1;
    num_colon=2;
    num_assigned=0;
    while(num_colon!=0)
    {
        bit4=charAt_CString(addr, i);
        if(bit4!=':')
        {
            byte4+=(inet_ntop_char2num(bit4)<<(4*num_assigned));
            ++num_assigned;
        }
        else
        {
            --num_colon;
            num_assigned=4;
        }
        --i;
    }

    VERBOSE("byte4==%lu\n", byte4);
    //Decoding "byte4" into IPV4 notation and adding it to addr's first part
    for(i=0;i<4;i++)
    {        
        bit4=(unsigned char)((byte4>>(8*(3-i)))&255);
        VERBOSE("bit4==%d\n", bit4);
        ret=concat_CString(ret, inet_ntop_int2CString(bit4, 10));
        ret=concat_CString(ret, dot);
    }
    ret=substring_CString(ret, 0, length_CString(ret)-1);
    
    return ret;
}

//Converting character into its integer value. Character must be digit or
//letter between 'a' to 'f' inclusive in uppercase or lowercase
unsigned long inet_ntop_char2num(char x)
{
    x=tolower(x);
    return (x>='0' && x<='9'? x-'0': x-'a'+10);
}

//Converts integer into its char value. Integer must be between
//0 and 15 inclusive.
char inet_ntop_num2char(int x)
{       
    return (x>9?x-10+'a':x+'0');
}

//Checking src_pre string for correctness.
//Correctness depends on af_pre parameter
bool inet_pton_correct_src(CString* src_pre, int af_pre)
{
    int i, size=length_CString(src_pre), num_dot, num_colon, j, tmp;
    CString* part;
    CString* src=substring_CString(src_pre, 0, size);    

    //Checking src_pre format, depending on af_pre parameter value
    if(af_pre==SUT_AF_INET)
    {
        //If src_pre is in IPV4 format
        VERBOSE("af_pre==SUT_AF_INET\n");
        num_dot=0;
        j=i=0;

        while(num_dot<4)
        {
            //Finding part of the address
            while(i<size && charAt_CString(src, i)!='.')
                i++;

            part=substring_CString(src, j, i);

            j=++i;

            //Checking part for correctness
            tmp=inet_pton_correct_part_dec(part);
            
            if(tmp==-1)
                return false;

            //Adding number of dots, if needed
            if(i-1<size)
                ++num_dot;
            else
            //If we reach end of string, then number of dots must be equal to 3
                return num_dot==3;            
        }
        
        //If number of dots in the address is more than 3, src_pre couldn't be
        //passed to inet_pton function
        return false;
    }
    else    
    {
        //If src_pre is in IPV6 format
        VERBOSE("af_pre==SUT_AF_INET6\n");

        num_dot=num_colon=0;
        j=i=0;

        while(num_colon<8)
        {
            //Finding part of the address
            while(i<size && charAt_CString(src, i)!=':'
                         && charAt_CString(src, i)!='.')
                i++;            

            part=substring_CString(src, j, i);

            j=++i;            

            if(i-1<size)
            {
                //Checking part for correctness, depending on kind of part:
                if(charAt_CString(src, i-1)=='.' || num_dot>0)
                {
                    //if part is from last 4 components of IPV6 address in
                    //third form, then it must be correct as IPV4 part
                    tmp=inet_pton_correct_part_dec(part);
                }
                else
                    //else part must be correct as IPV6 part
                    tmp=inet_pton_correct_part_hex(part);

                if(tmp==-1)
                    return false;

                //Adding number of colons if we needed.
                if(charAt_CString(src, i-1)==':')
                {                    
                    if(num_dot==0)
                        ++num_colon;
                    else
                    //If we found colon after finding dot, then address is
                    //incorrect
                        return false;
                }
                else
                //Adding number of dots if we needed.                
                {
                    ++num_dot;
                    //If we found three dots, then they are equal to one colon
                    if(num_dot==3)
                        ++num_colon;
                    //If number of dots is more than three, then address is
                    //incorrect
                    if(num_dot>3)
                        return false;
                }
            }
            else
            {
                //Checking part for correctness, depending on kind of part:
                if(num_dot!=0)
                {
                    //if part is from last 2 components of IPV6 address in
                    //third form, then it must be correct as IPV4 part
                    tmp=inet_pton_correct_part_dec(part);
                }
                else
                    //else part must be correct as IPV6 part
                    tmp=inet_pton_correct_part_hex(part);
                
                if(tmp==-1)
                    return false;

                //if we reach end of string, then number of colons must be
                //equal to 7
                return num_colon==7;
            }
        }
        //If number of colons in the address is more than 7, src_pre couldn't
        //be passed to inet_pton function
        return false;
    }
}
//Checking part for correctness:
// 1) part must be in decimal notation, 
// 2) value must be between 0 and 255 inclusive
int inet_pton_correct_part_dec(CString* part)
{    
    int i, size, res=0, curr;

    if(part==NULL)
        return -1;

    size=length_CString(part);

    if(size==0)
        return -1;
    
    //Getting value of the part
    for(i=0;i<size;i++)
    {
        curr=inet_ntop_char2num(charAt_CString(part, i));
        if(curr>=0 && curr<=9)
        {
            res=res*10+curr;
            //Checking value for belonging to [0, 255] interval
            if(res>255)
                return -1;
        }
        else
            return -1;
    }
    return res;
}
//Checking part for correctness:
// 1) part must be in hexadecimal notation, 
// 2) value must be between 0 and 65535 inclusive
int inet_pton_correct_part_hex(CString* part)
{
    int i, size, res=0, curr;

    if(part==NULL)
        return -1;

    size=length_CString(part);

    if(size==0)
        return -1;

    //Getting value of the part
    for(i=0;i<size;i++)
    {
        curr=inet_ntop_char2num(charAt_CString(part, i));
        if(curr>=0 && curr<=15)
        {
            res=res*16+curr;
            //Checking value for belonging to [0, 65535] interval
            if(res>65535)
                return -1;
        }
        else
            return -1;
    }
    return res;
}
