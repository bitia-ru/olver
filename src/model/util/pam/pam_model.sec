/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "process/process/process_model.seh"
#include "util/pam/pam_model.seh"
#include "util/pam/pam_config.h"

#pragma SEC subsystem pam "util.pam"

/*
   The group of functions 'util.pam' consists of:
       pam_acct_mgmt [1]
       pam_authenticate [1]
       pam_chauthtok [1]
       pam_close_session [1]
       pam_end [1]
       pam_fail_delay [1]
       pam_get_item [1]
       pam_getenvlist [1]
       pam_open_session [1]
       pam_set_item [1]
       pam_setcred [1]
       pam_start [1]
       pam_strerror [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_acct_mgmt

NAME

    pam_acct_mgmt -- establish the status of a user's account

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_acct_mgmt(pam_handle_t * pamh, int flags);

DESCRIPTION

    pam_acct_mgmt() establishes the account's usability and the user's
    accessibility to the system. It is typically called after the user has been
    authenticated.

    flags may be specified as any valid flag (namely, one of those applicable
    to the flags argument of pam_authenticate()). Additionally, the value of
    flags may be logically or'd with PAM_SILENT.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_NEW_AUTHTOK_REQD

        User is valid, but user's authentication token has expired. The correct
        response to this return-value is to require that the user satisfy the
        pam_chauthtok() function before obtaining service. It may not be
        possible for an application to do this. In such a case, the user should
        be denied access until the account password is updated.

    PAM_ACCT_EXPIRED

        User is no longer permitted access to the system.

    PAM_AUTH_ERR

        Authentication error.

    PAM_PERM_DENIED

        User is not permitted to gain access at this time.

    PAM_USER_UNKNOWN

        User is not known to a module's account management component.

    Note: Errors may be translated to text with pam_strerror().
*/
specification
IntT pam_acct_mgmt_spec( CallContext context, PamHandleT pamh, IntT flags ) {
    pre {
        /*
         * It is typically called after the user has been authenticated.
         */
        REQ("app.pam_acct_mgmt.02", "", TODO_REQ());

        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_acct_mgmt_spec != SUT_PAM_SUCCESS ) {
            if ( pam_acct_mgmt_spec == SUT_PAM_NEW_AUTHTOK_REQD ) {
                /*
                 * Return Value
                 *
                 * PAM_NEW_AUTHTOK_REQD
                 *
                 * User is valid, but user's authentication token has expired.
                 * The correct response to this return-value is to require
                 * that the user satisfy the pam_chauthtok() function before
                 * obtaining service. It may not be possible for an application
                 * to do this. In such a case, the user should be denied
                 * access until the account password is updated.
                 */
                REQ("pam_acct_mgmt.05.02", "", TODO_REQ());
            } else if( pam_acct_mgmt_spec == SUT_PAM_ACCT_EXPIRED ) {
                /*
                 * Return Value
                 *
                 * PAM_ACCT_EXPIRED
                 *
                 * User is no longer permitted access to the system.
                 */
                REQ("pam_acct_mgmt.05.03", "", TODO_REQ());
            } else if( pam_acct_mgmt_spec == SUT_PAM_AUTH_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_AUTH_ERR
                 *
                 * Authentication error.
                 */
                REQ("pam_acct_mgmt.05.04", "", TODO_REQ());
            } else if( pam_acct_mgmt_spec == SUT_PAM_PERM_DENIED ) {
                /*
                 * Return Value
                 *
                 * PAM_PERM_DENIED
                 *
                 * User is not permitted to gain access at this time.
                 */
                REQ("pam_acct_mgmt.05.05", "", TODO_REQ());
            } else if( pam_acct_mgmt_spec == SUT_PAM_USER_UNKNOWN ) {
                /*
                 * Return Value
                 *
                 * PAM_USER_UNKNOWN
                 *
                 * User is not known to a module's account management component.
                 */
                REQ("pam_acct_mgmt.05.06", "", TODO_REQ());
            }
        } else {
            /*
             * pam_acct_mgmt() establishes the account's usability and the user's
             * accessibility to the system.
             */
            REQ("pam_acct_mgmt.01", "", TODO_REQ());

            /*
             * flags may be specified as any valid flag (namely, one of those
             * applicable to the flags argument of pam_authenticate()).
             */
            REQ("pam_acct_mgmt.03", "", TODO_REQ());

            if ( flags & SUT_PAM_SILENT != 0 ) {
                /*
                 * Additionally, the value of flags may be logically or'd
                 * with PAM_SILENT.
                 */
                REQ( "pam_acct_mgmt.04", "the value of flags may be logically or'd with PAM_SILENT", TODO_REQ() );
            }

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_acct_mgmt.05.01", "Return Value is PAM_SUCCESS", pam_acct_mgmt_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

pam_authenticate

NAME

    pam_authenticate -- authenticate the user

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_authenticate(pam_handle_t * pamh, int flags);

DESCRIPTION

    pam_authenticate() serves as an interface to the authentication mechanisms
    of the loaded modules.

    flags is an optional parameter that may be specified by the following
    value:

    PAM_DISALLOW_NULL_AUTHTOK

        Instruct the authentication modules to return PAM_AUTH_ERR if the user
        does not have a registered authorization token.

    Additionally, the value of flags may be logically or'd with PAM_SILENT.

    The process may need to be privileged in order to successfully call this
    function.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_AUTH_ERR

        User was not authenticated or process did not have sufficient
        privileges to perform authentication.

    PAM_CRED_INSUFFICIENT

        Application does not have sufficient credentials to authenticate the
        user.

    PAM_AUTHINFO_UNAVAIL

        Modules were not able to access the authentication information. This
        might be due to a network or hardware failure, etc.

    PAM_USER_UNKNOWN

        Supplied username is not known to the authentication service.

    PAM_MAXTRIES

        One or more authentication modules has reached its limit of tries
        authenticating the user. Do not try again.

    PAM_ABORT

        One or more authentication modules failed to load.

    Note: Errors may be translated to text with pam_strerror().
*/

specification
IntT pam_authenticate_spec( CallContext context, PamHandleT pamh, IntT flags ) {
    pre {
        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_authenticate_spec != SUT_PAM_SUCCESS ) {
            if ( pam_authenticate_spec == SUT_PAM_AUTH_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_AUTH_ERR
                 *
                 * User was not authenticated or process did not
                 * have sufficient privileges to perform authentication.
                 */
                REQ("pam_authenticate.05.02", "", TODO_REQ());
            } else if ( pam_authenticate_spec == SUT_PAM_CRED_INSUFFICIENT ) {
                /*
                 * Return Value
                 *
                 * PAM_CRED_INSUFFICIENT
                 *
                 * Application does not have sufficient credentials to
                 * authenticate the user.
                 */
                REQ("pam_authenticate.05.03", "", TODO_REQ());
            } else if ( pam_authenticate_spec == SUT_PAM_AUTHINFO_UNAVAIL ) {
                /*
                 * Return Value
                 *
                 * PAM_AUTHINFO_UNAVAIL
                 *
                 * Modules were not able to access the authentication
                 * information. This might be due to a network or
                 * hardware failure, etc.
                 */
                REQ("pam_authenticate.05.04", "", TODO_REQ());
            } else if ( pam_authenticate_spec == SUT_PAM_USER_UNKNOWN ) {
                /*
                 * Return Value
                 *
                 * PAM_USER_UNKNOWN
                 *
                 * Supplied username is not known to the authentication
                 * service.
                 */
                REQ("pam_authenticate.05.05", "", TODO_REQ());
            } else if ( pam_authenticate_spec == SUT_PAM_MAXTRIES ) {
                /*
                 * Return Value
                 *
                 * PAM_MAXTRIES
                 *
                 * One or more authentication modules has reached its
                 * limit of tries authenticating the user. Do not try again.
                 */
                REQ("pam_authenticate.05.06", "", TODO_REQ());
            } else if ( pam_authenticate_spec == SUT_PAM_ABORT ) {
                /*
                 * Return Value
                 *
                 * PAM_ABORT
                 *
                 * One or more authentication modules failed to load.
                 */
                REQ("pam_authenticate.05.07", "", TODO_REQ());
            }
        } else {
            /*
             * pam_authenticate() serves as an interface to the authentication
             * mechanisms of the loaded modules.
             */
            REQ( "pam_authenticate.01", "pam_authenticate() serves as an interface to the authentication mechanisms",
                                        authenticated_PamData( pamData )
               );

            /*
             * flags is an optional parameter that may be specified by the
             * following value:
             *
             * PAM_DISALLOW_NULL_AUTHTOK
             *
             * Instruct the authentication modules to return
             * PAM_AUTH_ERR if the user does not have a registered
             * authorization token.
             */
            REQ("pam_authenticate.02.01", "", TODO_REQ());

            if ( flags & SUT_PAM_SILENT != 0 ) {
                /*
                 * Additionally, the value of flags may be logically or'd
                 * with PAM_SILENT.
                 */
                REQ( "pam_authenticate.03", "the value of flags may be logically or'd with PAM_SILENT", TODO_REQ() );
            }

            /*
             * The process may need to be privileged in order to
             * successfully call this function.
             */
            REQ("pam_authenticate.04", "", TODO_REQ());

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_authenticate.05.01", "Return Value is PAM_SUCCESS", pam_authenticate_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_chauthtok

NAME

    pam_chauthtok -- change the authentication token for a given user

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_chauthtok(pam_handle_t * pamh, const int flags);

DESCRIPTION

    pam_chauthtok() is used to change the authentication token for a given user
    as indicated by the state associated with the handle pamh.

    flags is an optional parameter that may be specified by the following value:

    PAM_CHANGE_EXPIRED_AUTHTOK

        User's authentication token should only be changed if it has expired.

    Additionally, the value of flags may be logically or'd with PAM_SILENT.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_AUTHTOK_ERR

        A module was unable to obtain the new authentication token.

    PAM_AUTHTOK_RECOVER_ERR

        A module was unable to obtain the old authentication token.

    PAM_AUTHTOK_LOCK_BUSY

        One or more modules were unable to change the authentication token
        since it is currently locked.

    PAM_AUTHTOK_DISABLE_AGING

        Authentication token aging has been disabled for at least one of the
        modules.

    PAM_PERM_DENIED

        Permission denied.

    PAM_TRY_AGAIN

        Not all modules were in a position to update the authentication
        token(s). In such a case, none of the user's authentication tokens are
        updated.

    PAM_USER_UNKNOWN

        User is not known to the authentication token changing service.

    Note: Errors may be translated to text with pam_strerror().
*/
specification
IntT pam_chauthtok_spec( CallContext context, PamHandleT pamh, IntT flags ) {
    pre {
        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_chauthtok_spec != SUT_PAM_SUCCESS ) {
            if ( pam_chauthtok_spec == SUT_PAM_AUTHTOK_ERR ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_AUTHTOK_ERR
                 *
                 * A module was unable to obtain the new authentication token.
                 */
                REQ("pam_chauthtok.04.02", "", TODO_REQ());
            } else if ( pam_chauthtok_spec == SUT_PAM_AUTHTOK_RECOVER_ERR ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_AUTHTOK_RECOVER_ERR
                 *
                 * A module was unable to obtain the old authentication
                 * token.
                 */
                REQ("pam_chauthtok.04.03", "", TODO_REQ());
            } else if ( pam_chauthtok_spec == SUT_PAM_AUTHTOK_LOCK_BUSY ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_AUTHTOK_LOCK_BUSY
                 *
                 * One or more modules were unable to change the
                 * authentication token since it is currently locked.
                 */
                REQ("pam_chauthtok.04.04", "", TODO_REQ());
            } else if ( pam_chauthtok_spec == SUT_PAM_AUTHTOK_DISABLE_AGING ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_AUTHTOK_DISABLE_AGING
                 *
                 * Authentication token aging has been disabled for at
                 * least one of the modules.
                 */
                REQ("pam_chauthtok.04.05", "", TODO_REQ());
            } else if ( pam_chauthtok_spec == SUT_PAM_PERM_DENIED ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_PERM_DENIED
                 *
                 * Permission denied.
                 */
                REQ("pam_chauthtok.04.06", "", TODO_REQ());
            } else if ( pam_chauthtok_spec == SUT_PAM_TRY_AGAIN ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_TRY_AGAIN
                 *
                 * Not all modules were in a position to update the
                 * authentication token(s). In such a case, none of
                 * the user's authentication tokens are updated.
                 */
                REQ("pam_chauthtok.04.07", "", TODO_REQ());
            } else if ( pam_chauthtok_spec == SUT_PAM_USER_UNKNOWN ) {
                /*
                 * RETURN VALUE
                 *
                 * PAM_USER_UNKNOWN
                 *
                 * User is not known to the authentication token
                 * changing service.
                 */
                REQ("pam_chauthtok.04.08", "", TODO_REQ());
            }
        } else {
            /*
             * pam_chauthtok() is used to change the authentication token
             * for a given user as indicated by the state associated with
             * the handle pamh.
             */
            REQ("pam_chauthtok.01", "", TODO_REQ());

            /*
             * flags is an optional parameter that may be specified by
             * the following value:
             *
             * PAM_CHANGE_EXPIRED_AUTHTOK
             *
             * User's authentication token should only be changed if
             * it has expired.
             */
            REQ("pam_chauthtok.02.01", "", TODO_REQ());

            if ( flags & SUT_PAM_SILENT != 0 ) {
                /*
                 * Additionally, the value of flags may be logically or'd
                 * with PAM_SILENT.
                 */
                REQ( "pam_chauthtok.03", "the value of flags may be logically or'd with PAM_SILENT", TODO_REQ() );
            }

            /*
            * RETURN VALUE
            *
            * PAM_SUCCESS
            *
            * Success.
            */
            REQ( "pam_chauthtok.04.01", "If success, Return Value is PAM_SUCCESS", pam_chauthtok_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_close_session

NAME

    pam_close_session -- indicate that an authenticated session has ended

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_close_session(pam_handle_t * pamh, int flags);

DESCRIPTION

    pam_close_session() is used to indicate that an authenticated session has
    ended. It is used to inform the module that the user is exiting a session.
    It should be possible for the PAM library to open a session and close the
    same session from different applications.

    flags may have the value PAM_SILENT to indicate that no output should be
    generated as a result of this function call.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_SESSION_ERR

        One of the required loaded modules was unable to close a session for
        the user.

    Note: Errors may be translated to text with pam_strerror().
*/
specification
IntT pam_close_session_spec( CallContext context, PamHandleT pamh, IntT flags ) {
    pre {
        /*
         * It is used to inform the module that the user is exiting a session.
         */
        REQ("app.pam_close_session.02", "", TODO_REQ());

        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_close_session_spec != SUT_PAM_SUCCESS ) {
            if ( pam_close_session_spec == SUT_PAM_SESSION_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_SESSION_ERR
                 *
                 * One of the required loaded modules was unable to close a
                 * session for the user.
                 */
                REQ("pam_close_session.05.02", "", TODO_REQ());
            }
        } else {
            /*
             * pam_close_session() is used to indicate that an authenticated
             * session has ended.
             */
            REQ( "pam_close_session.01", "authenticated session has ended", ! sessionOpened_PamData( pamData ) );

            /*
             * It should be possible for the PAM library to open a session
             * and close the same session from different applications.
             */
            REQ("pam_close_session.03", "", TODO_REQ());

            if ( flags & SUT_PAM_SILENT != 0 ) {
                /*
                 * Additionally, the value of flags may be logically or'd
                 * with PAM_SILENT.
                 */
                REQ( "pam_close_session.04", "the value of flags may be logically or'd with PAM_SILENT", TODO_REQ() );
            }

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_close_session.05.01", "Return Value is PAM_SUCCESS", pam_close_session_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_end

NAME

    pam_end -- terminate the use of the PAM library

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_end(pam_handle_t * pamh, int pam_status);

DESCRIPTION

    pam_end() terminates use of the PAM library. On success, the contents of
    *pamh are no longer valid, and all memory associated with it is invalid.

    Normally, pam_status is passed the value PAM_SUCCESS, but in the event of
    an unsuccessful service application, the appropriate PAM error return value
    should be used.

RETURN VALUE

    PAM_SUCCESS

        Success.

    Note: Errors may be translated to text with pam_strerror().
*/
specification
IntT pam_end_spec( CallContext context, PamHandleT pamh, IntT pam_status ) {
    pre {
        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        /*
         * pam_end() terminates use of the PAM library.
         */
        REQ("pam_end.01", "", TODO_REQ());

        if ( pam_end_spec != SUT_PAM_SUCCESS ) {
            /*
             * Normally, pam_status is passed the value PAM_SUCCESS, but
             * in the event of an unsuccessful service application, the
             * appropriate PAM error return value should be used.
             */
            REQ("pam_end.03", "", TODO_REQ());
        } else {
            /*
             * On success, the contents of *pamh are no longer valid,
             * and all memory associated with it is invalid.
             */
            REQ( "pam_end.02", "the contents of *pamh are no longer valid", pamData == NULL );

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_end.04.01", "If success, Return Value is PAM_SUCCESS", pam_end_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_fail_delay

NAME

    pam_fail_delay -- specify delay time to use on authentication error

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_fail_delay(pam_handle_t * pamh, unsigned int micro_sec);

DESCRIPTION

    pam_fail_delay() specifies the minimum delay for the PAM library to use
    when an authentication error occurs. The actual delay can vary by as much
    at 25%. If this function is called multiple times, the longest time
    specified by any of the call will be used.

    The delay is invoked if an authentication error occurs during the
    pam_authenticate() or pam_chauthtok() function calls.

    Independent of the success of pam_authenticate() or pam_chauthtok(), the
    delay time is reset to its default value of 0 when the PAM library returns
    control to the application from these two functions.

RETURN VALUE

    PAM_SUCCESS

        Success.

    Note: Errors may be translated to text with pam_strerror().
*/

specification
IntT pam_fail_delay_spec( CallContext context, PamHandleT pamh, UIntT micro_sec ) {
    pre {
        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        /*
         * pam_fail_delay() specifies the minimum delay for the PAM
         * library to use when an authentication error occurs.
         */
        REQ("pam_fail_delay.01", "", TODO_REQ());

        /*
         * The actual delay can vary by as much at 25%.
         */
        REQ("pam_fail_delay.02", "", TODO_REQ());

        /*
         * If this function is called multiple times, the longest
         * time specified by any of the call will be used.
         */
        REQ("pam_fail_delay.03", "", TODO_REQ());

        /*
         * The delay is invoked if an authentication error occurs
         * during the pam_authenticate() or pam_chauthtok()
         * function calls.
         */
        REQ("pam_fail_delay.04", "", TODO_REQ());

        /*
         * Independent of the success of pam_authenticate() or
         * pam_chauthtok(), the delay time is reset to its default
         * value of 0 when the PAM library returns control to the
         * application from these two functions.
         */
        REQ("pam_fail_delay.05", "", TODO_REQ());

        /*
         * Return Value
         *
         * PAM_SUCCESS
         *
         * Success.
         */
        REQ( "pam_fail_delay.06.01", "If success, Return Value is PAM_SUCCESS", pam_fail_delay_spec == SUT_PAM_SUCCESS );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_get_item

NAME

    pam_get_item -- obtain the value of the indicated item.

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_get_item(const pam_handle_t * pamh, int item_type, const
        void * * item);

DESCRIPTION

    pam_get_item() obtains the value of the indicated item_type. The
    possible values of item_type are the same as listed for
    pam_set_item().

    On success, item contains a pointer to the value of the corresponding item.
    Note that this is a pointer to the actual data and should not be free()'d
    or over-written.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_PERM_DENIED

        Application passed a NULL pointer for item.

    PAM_BAD_ITEM

        Application attempted to get an undefined item.

    Note: Errors may be translated to text with pam_strerror().
*/
specification
IntT pam_get_item_spec( CallContext context, PamHandleT pamh, IntT item_type, VoidTPtr * item ) {
    pre {
        /*
         * Note that this is a pointer to the actual data and should
         * not be free()'d or over-written.
         */
        REQ("app.pam_get_item.04", "", TODO_REQ());

        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_get_item_spec != SUT_PAM_SUCCESS ) {
            if ( pam_get_item_spec == SUT_PAM_PERM_DENIED ) {
                /*
                 * Return Value
                 *
                 * PAM_PERM_DENIED
                 *
                 * Application passed a NULL pointer for item.
                 */
                REQ( "pam_get_item.05.02", "Application passed a NULL pointer for item", ! isNULL_VoidTPtr( * item ) );
            } else if ( pam_get_item_spec == SUT_PAM_BAD_ITEM ) {
                /*
                 * Return Value
                 *
                 * PAM_BAD_ITEM
                 *
                 * Application attempted to get an undefined item.
                 */
                REQ( "pam_get_item.05.03", "attempted to get an undefined item", ! correctItemType_PamData( item_type ) );
            }
        } else {
            bool checkResult;
            if ( item_type == SUT_PAM_CONV ) {
                Object * storedItemValue = getItem( pamData, item_type );
                // to do
                Object * pointedItemValue = NULL;
				checkResult = equals( storedItemValue, pointedItemValue );
            } else {
                CString * storedItemValue = getItem( pamData, item_type );
                CString * pointedItemValue = readCString_VoidTPtr( * item );
				checkResult = equals( storedItemValue, pointedItemValue );
            }

            /*
             * pam_get_item() obtains the value of the indicated item_type.
             *
             * On success, item contains a pointer to the value of the
             * corresponding item.
             */
            REQ( "pam_get_item.01", "pam_get_item() obtains the value of the indicated item_type", checkResult );

            /*
             * The possible values of item_type are the same as listed for
             * pam_set_item().
             */
            REQ( "pam_get_item.02", "possible values of item_type are the same as listed for pam_set_item()",
                                    correctItemType_PamData( item_type )
               );

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_get_item.05.01", "If success, Return Value is PAM_SUCCESS", pam_get_item_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_getenvlist

NAME

    pam_getenvlist -- returns a pointer to the complete PAM environment.

SYNOPSIS

    #include <security/pam_appl.h>

    char * const * pam_getenvlist(pam_handle_t * pamh);

DESCRIPTION

    pam_getenvlist() returns a pointer to the complete PAM environment. This
    pointer points to an array of pointers to NUL-terminated strings and must
    be terminated by a NULL pointer. Each string has the form "name=value".

    The PAM library module allocates memory for the returned value and the
    associated strings. The calling application is responsible for freeing this
    memory.

RETURN VALUE

    pam_getenvlist() returns an array of string pointers containing the PAM
    environment. On error, NULL is returned.
*/
specification
List /* CString */ * pam_getenvlist_spec( CallContext context, PamHandleT pamh ) {
    pre {
        /*
         * The calling application is responsible for freeing this memory.
         */
        REQ("app.pam_getenvlist.05", "", TODO_REQ());

        return true;
    }
    post {
        if ( pam_getenvlist_spec == NULL ) {
            /*
             * On error, NULL is returned.
             */
            REQ( "pam_getenvlist.07", "NULL is returned", pam_getenvlist_spec == NULL );
        } else {
            /*
             * pam_getenvlist() returns a pointer to the complete
             * PAM environment.
             */
            REQ("pam_getenvlist.01", "", TODO_REQ());

            /*
             * This pointer points to an array of pointers to
             * NUL-terminated strings and must
             * be terminated by a NULL pointer.
             */
            REQ("pam_getenvlist.02", "", TODO_REQ());

            /*
             * Each string has the form "name=value".
             */
            REQ("pam_getenvlist.03", "", TODO_REQ());

            /*
             * The PAM library module allocates memory for the returned
             * value and the associated strings.
             */
            REQ("pam_getenvlist.04", "", TODO_REQ());

            /*
             * pam_getenvlist() returns an array of string pointers
             * containing the PAM environment.
             */
            REQ("pam_getenvlist.06", "", TODO_REQ());
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_open_session

NAME

    pam_open_session -- indicate session has started

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_open_session(pam_handle_t * pamh, int flags);

DESCRIPTION

    The pam_open_session() function is used to indicate that an authenticated
    session has begun, after the user has been identified (see
    pam_authenticate()) and, if necessary, granted credentials
    (see pam_setcred()). It is used to inform the module that the user is
    currently in a session. It should be possible for the PAM library to open
    a session and close the same session from different applications.

    flags may have the value PAM_SILENT to indicate that no output be generated
    as a result of this function call.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_SESSION_ERR

        One of the loaded modules was unable to open a session for the user.

    Note: Errors may be translated to text with pam_strerror().
*/

specification
IntT pam_open_session_spec( CallContext context, PamHandleT pamh, IntT flags ) {
    pre {
        /*
         * It is used to inform the module that the user is currently
         * in a session.
         */
        REQ("app.pam_open_session.02", "", TODO_REQ());

        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_open_session_spec != SUT_PAM_SUCCESS ) {
            if ( pam_open_session_spec == SUT_PAM_SESSION_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_SESSION_ERR
                 *
                 * One of the loaded modules was unable to open a session
                 * for the user.
                 */
                REQ("pam_open_session.05.02", "", TODO_REQ());
            }
        } else {
            /*
             * The pam_open_session() function is used to indicate that an
             * authenticated session has begun, after the user has been
             * identified (see pam_authenticate()) and, if necessary, granted
             * credentials (see pam_setcred()).
             */
            REQ( "pam_open_session.01", "authenticated session has begun", sessionOpened_PamData( pamData ) );

            /*
             * It should be possible for the PAM library to open a session
             * and close the same session from different applications.
             */
            REQ("pam_open_session.03", "", TODO_REQ());

            if ( flags & SUT_PAM_SILENT != 0 ) {
                /*
                 * flags may have the value PAM_SILENT to indicate that no
                 * output be generated as a result of this function call.
                 */
                REQ( "pam_open_session.04", "flags may have the value PAM_SILENT", TODO_REQ() );
            }

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_open_session.05.01", "Return Value is PAM_SUCCESS", pam_open_session_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_set_item

NAME

    pam_set_item -- (re)set the value of an item.

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_set_item(pam_handle_t * pamh, int item_type, const void *
        item);

DESCRIPTION

    pam_set_item() (re)sets the value of one of the following item_types:

    PAM_SERVICE

        service name

    PAM_USER

        user name

    PAM_TTY

        terminal name

        The value for a device file should include the /dev/ prefix. The value
        for graphical, X-based, applications should be the $DISPLAY variable.

    PAM_RHOST

        remote host name

    PAM_CONV

        conversation structure

    PAM_RUSER

        remote user name

    PAM_USER_PROMPT

        string to be used when prompting for a user's name

        The default value for this string is Please enter username: .

    For all item_types other than PAM_CONV, item is a pointer to a NULL-
    terminated character string. In the case of PAM_CONV, item points to an
    initialized pam_conv structure.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_PERM_DENIED

        An attempt was made to replace the conversation structure with a NULL
        value.

    PAM_BUF_ERR

        Function ran out of memory making a copy of the item.

    PAM_BAD_ITEM

        Application attempted to set an undefined item.

    Note: Errors may be translated to text with pam_strerror().
*/
specification
IntT pam_set_item_spec( CallContext context, PamHandleT pamh, IntT item_type, VoidTPtr item ) {
    pre {
        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_set_item_spec != SUT_PAM_SUCCESS ) {
            if ( pam_set_item_spec == SUT_PAM_PERM_DENIED ) {
                /*
                 * Return Value
                 *
                 * PAM_PERM_DENIED
                 *
                 * An attempt was made to replace the conversation
                 * structure with a NULL value.
                 */
                REQ("pam_set_item.04.02", "", TODO_REQ());
            } else if ( pam_set_item_spec == SUT_PAM_BUF_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_BUF_ERR
                 *
                 * Function ran out of memory making a copy of the item.
                 */
                REQ("pam_set_item.04.03", "", TODO_REQ());
            } else if ( pam_set_item_spec == SUT_PAM_BAD_ITEM ) {
                /*
                 * Return Value
                 *
                 * PAM_BAD_ITEM
                 *
                 * Application attempted to set an undefined item.
                 */
                REQ( "pam_set_item.04.04", "attempted to set an undefined item", ! correctItemType_PamData( item_type ) );
            }
        } else {
            if ( item_type == SUT_PAM_CONV ) {
                /*
                 * In the case of PAM_CONV, item points to an initialized pam_conv
                 * structure.
                 */
                REQ( "pam_set_item.03", "item points to an initialized pam_conv structure", TODO_REQ() );

                /*
                 * pam_set_item() (re)sets the value of one of the following item_types:
                 *
                 * PAM_CONV
                 *
                 * conversation structure
                 */
                REQ("pam_set_item.01.05", "", TODO_REQ());
            } else {
                CString * storedItemValue = getItem( pamData, item_type );
                CString * pointedItemValue = readCString_VoidTPtr( item );
                bool checkResult = equals( storedItemValue, pointedItemValue );

                /*
                 * For all item_types other than PAM_CONV, item is a pointer to a NULL-
                 * terminated character string.
                 */
                REQ( "pam_set_item.02", "item is a pointer to a NULL-terminated character string", true );

                if ( item_type == SUT_PAM_SERVICE ) {
                    /*
                     * pam_set_item() (re)sets the value of one of the following item_types:
                     *
                     * PAM_SERVICE
                     *
                     * service name
                     */
                    REQ( "pam_set_item.01.01", "service name", checkResult );
                } else if ( item_type == SUT_PAM_USER ) {
                    /*
                     * pam_set_item() (re)sets the value of one of the following item_types:
                     *
                     * PAM_USER
                     *
                     * user name
                     */
                    REQ( "pam_set_item.01.02", "user name", checkResult );
                } else if ( item_type == SUT_PAM_TTY ) {
                    /*
                     * pam_set_item() (re)sets the value of one of the following item_types:
                     *
                     * PAM_TTY
                     *
                     * terminal name
                     *
                     * The value for a device file should include the /dev/
                     * prefix. The value for graphical, X-based, applications should be
                     * the $DISPLAY variable.
                     */
                    REQ( "pam_set_item.01.03", "terminal name", checkResult );
                } else if ( item_type == SUT_PAM_RHOST ) {
                    /*
                     * pam_set_item() (re)sets the value of one of the following item_types:
                     *
                     * PAM_RHOST
                     *
                     * remote host name
                     */
                    REQ( "pam_set_item.01.04", "remote host name", checkResult );
                } else if ( item_type == SUT_PAM_RUSER ) {
                    /*
                     * pam_set_item() (re)sets the value of one of the following item_types:
                     *
                     * PAM_RUSER
                     *
                     * remote user name
                     */
                    REQ( "pam_set_item.01.06", "remote user name", checkResult );
                } else if ( item_type == SUT_PAM_USER_PROMPT ) {
                    /*
                     * pam_set_item() (re)sets the value of one of the following item_types:
                     *
                     * PAM_USER_PROMPT
                     *
                     * string to be used when prompting for a user's nameThe default
                     * value for this string is Please enter username: .
                     */
                    REQ( "pam_set_item.01.07", "string to be used when prompting for a user's name", checkResult );
                } else {
                    assertion( false, "pam_set_item_spec : unknown item type %d\n", item_type );
                }
            }

            /*
             * Return Value
             *
             * PAM_SUCCESS
             *
             * Success.
             */
            REQ( "pam_set_item.04.01", "If success, Return Value is PAM_SUCCESS", pam_set_item_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_setcred

NAME

    pam_setcred -- set the module-specific credentials of the user

SYNOPSIS

    #include <security/pam_appl.h>

    extern int pam_setcred(pam_handle_t * pamh, int flags);

DESCRIPTION

    pam_setcred() sets the module-specific credentials of the user. It is
    usually called after the user has been authenticated, after the account
    management function has been called and after a session has been opened for
    the user.

    flags maybe specified from among the following values:

    PAM_ESTABLISH_CRED

        set credentials for the authentication service

    PAM_DELETE_CRED

        delete credentials associated with the authentication service

    PAM_REINITIALIZE_CRED

        reinitialize the user credentials

    PAM_REFRESH_CRED

        extend lifetime of the user credentials

    Additionally, the value of flags may be logically or'd with PAM_SILENT.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_CRED_UNAVAIL

        Module cannot retrieve the user's credentials.

    PAM_CRED_EXPIRED

        User's credentials have expired.

    PAM_USER_UNKNOWN

        User is not known to an authentication module.

    PAM_CRED_ERR

        Module was unable to set the credentials of the user.

    Note: Errors may be translated to text with pam_strerror().
*/

specification
IntT pam_setcred_spec( CallContext context, PamHandleT pamh, IntT flags ) {
    pre {
        /*
         * It is usually called after the user has been authenticated,
         * after the account management function has been called and
         * after a session has been opened for the user.
         */
        REQ( "app.pam_setcred.02", "session has been opened for the user", TODO_REQ() );

        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, pamh );

        if ( pam_setcred_spec != SUT_PAM_SUCCESS ) {
            if ( pam_setcred_spec == SUT_PAM_CRED_UNAVAIL ) {
                /*
                 * Return Value
                 *
                 * PAM_CRED_UNAVAIL
                 *
                 * Module cannot retrieve the user's credentials.
                 */
                REQ("pam_setcred.05.02", "", TODO_REQ());
            } else if ( pam_setcred_spec == SUT_PAM_CRED_EXPIRED ) {
                /*
                 * Return Value
                 *
                 * PAM_CRED_EXPIRED
                 *
                 * User's credentials have expired.
                 */
                REQ("pam_setcred.05.03", "", TODO_REQ());
            } else if ( pam_setcred_spec == SUT_PAM_USER_UNKNOWN ) {
                /*
                 * Return Value
                 *
                 * PAM_USER_UNKNOWN
                 *
                 * User is not known to an authentication module.
                 */
                REQ("pam_setcred.05.04", "", TODO_REQ());
            } else if ( pam_setcred_spec == SUT_PAM_CRED_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_CRED_ERR
                 *
                 * Module was unable to set the credentials of the user.
                 */
                REQ("pam_setcred.05.05", "", TODO_REQ());
            }
        } else {
            /*
             * pam_setcred() sets the module-specific credentials of the user.
             */
            REQ("pam_setcred.01", "", TODO_REQ());

            /*
             * flags maybe specified from among the following values:
             *
             * PAM_ESTABLISH_CRED
             *
             * set credentials for the authentication service
             */
            REQ("pam_setcred.03.01", "", TODO_REQ());

            /*
             * flags maybe specified from among the following values:
             *
             * PAM_DELETE_CRED
             *
             * delete credentials associated with the authentication service
             */
            REQ("pam_setcred.03.02", "", TODO_REQ());

            /*
             * flags maybe specified from among the following values:
             *
             * PAM_REINITIALIZE_CRED
             *
             * reinitialize the user credentials
             */
            REQ("pam_setcred.03.03", "", TODO_REQ());

            /*
             * flags maybe specified from among the following values:
             *
             * PAM_REFRESH_CRED
             *
             * extend lifetime of the user credentials
             */
            REQ("pam_setcred.03.04", "", TODO_REQ());

            if ( flags & SUT_PAM_SILENT != 0 ) {
                /*
                 * Additionally, the value of flags may be logically or'd
                 * with PAM_SILENT.
                 */
                REQ( "pam_setcred.04", "the value of flags may be logically or'd with PAM_SILENT", TODO_REQ() );
            }

            /*
            * RETURN VALUE
            *
            * PAM_SUCCESS
            *
            * Success.
            */
            REQ( "pam_setcred.05.01", "If success, Return Value is PAM_SUCCESS", pam_setcred_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_start

NAME

    pam_start -- initialize the PAM library

SYNOPSIS

    #include <security/pam_appl.h>

    int pam_start(const char * service_name, const char * user, const
        struct pam_conv * pam_conversation, pam_handle_t * * pamh);

DESCRIPTION

    pam_start() is used to initialize the PAM library. It must be called prior
    to any other usage of the PAM library. On success, *pamh becomes a handle
    that provides continuity for successive calls to the PAM library.
    pam_start() expects arguments as follows: the service_name of the program,
    the username of the individual to be authenticated, a pointer to an
    application-supplied pam_conv structure, and a pointer to a pam_handle_t
    pointer.

    An application must provide the conversation function used for direct
    communication between a loaded module and the application. The application
    also typically provides a means for the module to prompt the user for a
    password, etc.

    The structure, pam_conv, is defined to be,

    struct pam_conv {
            int (*conv) (   int num_msg,
                            const struct pam_message * *msg,
                            struct pam_response * *resp,
                            void *appdata_ptr);
            void *appdata_ptr; };

    It is initialized by the application before it is passed to the library.
    The contents of this structure are attached to the *pamh handle. The point
    of this argument is to provide a mechanism for any loaded module to
    interact directly with the application program; this is why it is called a
    conversation structure.

    When a module calls the referenced conv() function, appdata_ptr is set to
    the second element of this structure.

    The other arguments of a call to conv() concern the information exchanged
    by module and application. num_msg holds the length of the array of
    pointers passed via msg. On success, the pointer resp points to an array
    of num_msg pam_response structures, holding the application-supplied text.
    Note that resp is a struct pam_response array and not an array of pointers.

RETURN VALUE

    PAM_SUCCESS

        Success.

    PAM_BUF_ERR

        Memory allocation error.

    PAM_ABORT

        Internal failure.

    ERRORS

        May be translated to text with pam_strerror().
*/

specification
IntT pam_start_spec
         ( CallContext context, CString * service_name, CString * username, IntT pam_conversation, PamHandleT * pamh ) {
    pre {
        /*
         * It must be called prior to any other usage of the PAM library.
         */
        IMPLEMENT_REQ("app.pam_start.02");

        /*
         * pam_start() expects arguments as follows:
         *
         * the service_name of the program
         */
        REQ("app.pam_start.04.01", "", TODO_REQ());

        /*
         * pam_start() expects arguments as follows:
         *
         * the username of the individual to be authenticated
         */
        REQ("app.pam_start.04.02", "", TODO_REQ());

        /*
         * pam_start() expects arguments as follows:
         *
         * a pointer to an application-supplied pam_conv structure
         */
        REQ("app.pam_start.04.03", "", TODO_REQ());

        /*
         * pam_start() expects arguments as follows:
         *
         * a pointer to a pam_handle_t pointer
         */
        REQ("app.pam_start.04.04", "", TODO_REQ());

        /*
         *     The structure, pam_conv, is defined to be,
         *
         *     struct pam_conv {
         *              int (*conv) (   int num_msg,
         *                              const struct pam_message * *msg,
         *                              struct pam_response * *resp,
         *                              void *appdata_ptr);
         *              void *appdata_ptr; };
         */
        REQ("app.pam_start.07.01", "", TODO_REQ());

        /*
         * It is initialized by the application before it is passed to
         * the library.
         */
        REQ("app.pam_start.08", "", TODO_REQ());

        /*
         * Note that resp is a struct pam_response array and not an array of
         * pointers.
         */
        REQ("app.pam_start.14", "", TODO_REQ());


        return true;
    }
    post {
        ProcessState * processState = getProcessState_CallContext( context );
        PamData * pamData = find_PamDatas( processState->pamDatas, * pamh );

        /*
         * pam_start() is used to initialize the PAM library.
         */
        IMPLEMENT_REQ( "pam_start.01" );

        if ( pam_start_spec != SUT_PAM_SUCCESS ) {
            if ( pam_start_spec == SUT_PAM_BUF_ERR ) {
                /*
                 * Return Value
                 *
                 * PAM_BUF_ERR
                 *
                 * Memory allocation error.
                 */
                REQ( "pam_start.15.02", "Memory allocation error", pamData == NULL );
            } else if ( pam_start_spec == SUT_PAM_ABORT ) {
                /*
                 * Return Value
                 *
                 * PAM_ABORT
                 *
                 * Internal failure.
                 */
                REQ( "pam_start.15.03", "Internal failure", pamData == NULL );
            }
        } else {
            /*
             * On success, *pamh becomes a handle that provides continuity
             * for successive calls to the PAM library.
             */
            REQ( "pam_start.03", "*pamh becomes a handle for successive calls to the PAM library", pamData != NULL );

            /*
             * An application must provide the conversation function used
             * for direct communication between a loaded module and the
             * application.
             */
            REQ("pam_start.05", "", TODO_REQ());

            /*
             * The application also typically provides a means for the
             * module to prompt the user for a password, etc.
             */
            REQ("pam_start.06", "", TODO_REQ());

            /*
             * The contents of this structure are attached to the *pamh handle.
             */
            REQ("pam_start.09", "", TODO_REQ());

            /*
             * The point of this argument is to provide a mechanism for any
             * loaded module to interact directly with the application program;
             * this is why it is called a conversation structure.
             */
            REQ("pam_start.10", "", TODO_REQ());

            /*
             * When a module calls the referenced conv() function,
             * appdata_ptr is set to the second element of this structure.
             */
            REQ("pam_start.11", "", TODO_REQ());

            /*
             * The other arguments of a call to conv() concern the information
             * exchanged by module and application.
             *
             * num_msg holds the length of the array of pointers passed via msg.
             */
            REQ("pam_start.12.01", "", TODO_REQ());

            /*
             * On success, the pointer resp points to an array of num_msg
             * pam_response structures, holding the application-supplied text.
             */
            REQ("pam_start.13", "", TODO_REQ());

            /*
             * Return Value
             *
             * PAM_SUCCESS Success.
             */
            REQ( "pam_start.15.01", "If success, Return Value is PAM_SUCCESS", pam_start_spec == SUT_PAM_SUCCESS );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    pam_strerror

NAME

    pam_strerror -- returns a string describing the PAM error

SYNOPSYS

    #include <security/pam_appl.h>

    const char * pam_strerror(pam_handle_t * pamh, int errnum);

DESCRIPTION

    pam_strerror() returns a string describing the PAM error associated with
    errnum.

RETURN VALUE

    On success, this function returns a description of the indicated error. The
    application should not free or modify this string. Otherwise, a string
    indicating that the error is unknown shall be returned. It is unspecified
    whether or not the string returned is translated according to the setting
    of LC_MESSAGES.
*/
specification
CString * pam_strerror_spec( CallContext context, PamHandleT pamh, IntT errnum ) {
    pre {
        /*
         * The application should not free or modify this string.
         */
        REQ("app.pam_strerror.03", "", TODO_REQ());

        return true;
    }
    post {
        if ( SUT_PAM_SUCCESS <= errnum && errnum <= SUT_PAM_BAD_ITEM ) {
            /*
             * pam_strerror() returns a string describing the PAM error associated with errnum.
             *
             * On success, this function returns a description of the indicated error.
             */
            REQ( "pam_strerror.01.01", "On success, this function returns a description of the indicated error",
                                       length_CString( pam_strerror_spec ) > 0
               );
        } else {
            /*
             * pam_strerror() returns a string describing the PAM error associated with errnum.
             *
             * Otherwise, a string indicating that the error is unknown shall be returned
             */
            REQ( "pam_strerror.01.02", "Otherwise, a string indicating that the error is unknown shall be returned",
                                       length_CString( pam_strerror_spec ) > 0
               );
        }

        /*
         * It is unspecified whether or not the string returned is
         * translated according to the setting of LC_MESSAGES.
         */
        REQ_UNCHECKABLE(
            "pam_strerror.02",
            "It is unspecified whether or not the string returned is translated according to the setting of LC_MESSAGES"
        );

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

static CString * strPamResult(IntT res)
{
    switch(res)
    {
        case SUT_PAM_SUCCESS:
            return create_CString("SUT_PAM_SUCCESS");
        case SUT_PAM_OPEN_ERR:
            return create_CString("SUT_PAM_OPEN_ERR");
        case SUT_PAM_USER_UNKNOWN:
            return create_CString("SUT_PAM_USER_UNKNOWN");
        case SUT_PAM_MAXTRIES:
            return create_CString("SUT_PAM_MAXTRIES");
        case SUT_PAM_NEW_AUTHTOK_REQD:
            return create_CString("SUT_PAM_NEW_AUTHTOK_REQD");
        case SUT_PAM_ACCT_EXPIRED:
            return create_CString("SUT_PAM_ACCT_EXPIRED");
        case SUT_PAM_SESSION_ERR:
            return create_CString("SUT_PAM_SESSION_ERR");
        case SUT_PAM_CRED_UNAVAIL:
            return create_CString("SUT_PAM_CRED_UNAVAIL");
        case SUT_PAM_CRED_EXPIRED:
            return create_CString("SUT_PAM_CRED_EXPIRED");
        case SUT_PAM_CRED_ERR:
            return create_CString("SUT_PAM_CRED_ERR");
        case SUT_PAM_CONV_ERR:
            return create_CString("SUT_PAM_CONV_ERR");
        case SUT_PAM_SYMBOL_ERR:
            return create_CString("SUT_PAM_SYMBOL_ERR");
        case SUT_PAM_AUTHTOK_ERR:
            return create_CString("SUT_PAM_AUTHTOK_ERR");
        case SUT_PAM_AUTHTOK_RECOVER_ERR:
            return create_CString("SUT_PAM_AUTHTOK_RECOVER_ERR");
        case SUT_PAM_AUTHTOK_LOCK_BUSY:
            return create_CString("SUT_PAM_AUTHTOK_LOCK_BUSY");
        case SUT_PAM_AUTHTOK_DISABLE_AGING:
            return create_CString("SUT_PAM_AUTHTOK_DISABLE_AGING");
        case SUT_PAM_TRY_AGAIN:
            return create_CString("SUT_PAM_TRY_AGAIN");
        case SUT_PAM_ABORT:
            return create_CString("SUT_PAM_ABORT");
        case SUT_PAM_AUTHTOK_EXPIRED:
            return create_CString("SUT_PAM_AUTHTOK_EXPIRED");
        case SUT_PAM_BAD_ITEM:
            return create_CString("SUT_PAM_BAD_ITEM");
        case SUT_PAM_SERVICE_ERR:
            return create_CString("SUT_PAM_SERVICE_ERR");
        case SUT_PAM_SYSTEM_ERR:
            return create_CString("SUT_PAM_SYSTEM_ERR");
        case SUT_PAM_BUF_ERR:
            return create_CString("SUT_PAM_BUF_ERR");
        case SUT_PAM_PERM_DENIED:
            return create_CString("SUT_PAM_PERM_DENIED");
        case SUT_PAM_AUTH_ERR:
            return create_CString("SUT_PAM_AUTH_ERR");
        case SUT_PAM_CRED_INSUFFICIENT:
            return create_CString("SUT_PAM_CRED_INSUFFICIENT");
        case SUT_PAM_AUTHINFO_UNAVAIL:
            return create_CString("SUT_PAM_AUTHINFO_UNAVAIL");
    }
    return format_CString("%d", (int)res);
}
