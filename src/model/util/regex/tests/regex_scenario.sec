/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "process/process/process_model.seh"
#include "system/system/system_model.seh"
#include "util/regex/regex_model.seh"
#include "util/regex/tests/regex_scenario.seh"

/********************************************************************/
/**                  Test Static Data                              **/
/********************************************************************/

static CallContext context;

static List /* FnmatchSheaf */ * fnmatchSheafs;

static List /* FnmatchSheaf */ * createFnmatchSheafs( void ) {
    List /* FnmatchSheaf */ * result = create_List( & type_FnmatchSheaf );
    append_List( result, create_FnmatchSheaf( "abcd", "abcd", SUT_FNM_PATHNAME,                  0              , "fnmatch.03.01",                  "fnmatch.03.03",                                      "fnmatch.03.06", "fnmatch.04.01",                  NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcd", 0,                                 0              ,                  "fnmatch.03.02", "fnmatch.03.03",                                      "fnmatch.03.06", "fnmatch.04.01",                  NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcd", SUT_FNM_NOESCAPE,                  0              ,                  "fnmatch.03.02",                  "fnmatch.03.04",                     "fnmatch.03.06", "fnmatch.04.01",                  NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcd", SUT_FNM_PERIOD | SUT_FNM_PATHNAME, 0              , "fnmatch.03.01",                  "fnmatch.03.03",                  "fnmatch.03.05.01",                  "fnmatch.04.01",                  NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcd", SUT_FNM_PERIOD                   , 0              ,                  "fnmatch.03.02", "fnmatch.03.03",                  "fnmatch.03.05.02",                  "fnmatch.04.01",                  NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcf", SUT_FNM_PATHNAME,                  SUT_FNM_NOMATCH, "fnmatch.03.01",                  "fnmatch.03.03",                                      "fnmatch.03.06",                  "fnmatch.04.02", NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcf", 0,                                 SUT_FNM_NOMATCH,                  "fnmatch.03.02", "fnmatch.03.03",                                      "fnmatch.03.06",                  "fnmatch.04.02", NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcf", SUT_FNM_NOESCAPE,                  SUT_FNM_NOMATCH,                  "fnmatch.03.02",                  "fnmatch.03.04",                     "fnmatch.03.06",                  "fnmatch.04.02", NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcf", SUT_FNM_PERIOD | SUT_FNM_PATHNAME, SUT_FNM_NOMATCH, "fnmatch.03.01",                  "fnmatch.03.03",                  "fnmatch.03.05.01",                                   "fnmatch.04.02", NULL ) );
    append_List( result, create_FnmatchSheaf( "abcd", "abcf", SUT_FNM_PERIOD                   , SUT_FNM_NOMATCH,                  "fnmatch.03.02", "fnmatch.03.03",                  "fnmatch.03.05.02",                                   "fnmatch.04.02", NULL ) );
    return result;
}

static List /* RegexpSheaf */ * regexpSheafs;

static List /* RegexpSheaf */ * createRegexpSheafs( void ) {
    List /* RegexpSheaf */ * result = create_List( & type_RegexpSheaf );
    append_List( result, create_RegexpSheaf( "ab\ncd", 0               , 0, "ab\ncd", 0,              0, 0, -1, "regcomp.01",                  "regcomp.04",               "regexec.02",                  "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", 0               , 0, "ab\ncd", 0, SUT_REG_NOTBOL, 0, -1, "regcomp.01",                  "regcomp.04",               "regexec.02", "regexec.04.01", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", 0               , 0, "ab\ncd", 0, SUT_REG_NOTEOL, 0, -1, "regcomp.01",                  "regcomp.04",               "regexec.02", "regexec.04.02", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_EXTENDED, 0, "ab\ncd", 0,              0, 0, -1, "regcomp.01", "regcomp.03.01",               "regcomp.05", "regexec.02",                  "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_EXTENDED, 0, "ab\ncd", 0, SUT_REG_NOTBOL, 0, -1, "regcomp.01", "regcomp.03.01",               "regcomp.05", "regexec.02", "regexec.04.01", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_EXTENDED, 0, "ab\ncd", 0, SUT_REG_NOTEOL, 0, -1, "regcomp.01", "regcomp.03.01",               "regcomp.05", "regexec.02", "regexec.04.02", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_ICASE   , 0, "ab\ncd", 0,              0, 0, -1, "regcomp.01", "regcomp.03.02", "regcomp.04",               "regexec.02",                  "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_ICASE   , 0, "ab\ncd", 0, SUT_REG_NOTBOL, 0, -1, "regcomp.01", "regcomp.03.02", "regcomp.04",               "regexec.02", "regexec.04.01", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_ICASE   , 0, "ab\ncd", 0, SUT_REG_NOTEOL, 0, -1, "regcomp.01", "regcomp.03.02", "regcomp.04",               "regexec.02", "regexec.04.02", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_NOSUB   , 0, "ab\ncd", 0,              0, 0, -1, "regcomp.01", "regcomp.03.03", "regcomp.04",               "regexec.02",                  "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_NOSUB   , 0, "ab\ncd", 0, SUT_REG_NOTBOL, 0, -1, "regcomp.01", "regcomp.03.03", "regcomp.04",               "regexec.02", "regexec.04.01", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_NOSUB   , 0, "ab\ncd", 0, SUT_REG_NOTEOL, 0, -1, "regcomp.01", "regcomp.03.03", "regcomp.04",               "regexec.02", "regexec.04.02", "regexec.05", "regexec.14",                                                    NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_NEWLINE , 0, "ab\ncd", 0,              0, 0, -1, "regcomp.01", "regcomp.03.04", "regcomp.04",               "regexec.02",                  "regexec.05",               "regexec.15.01", "regexec.15.02", "regexec.15.03", NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_NEWLINE , 0, "ab\ncd", 0, SUT_REG_NOTBOL, 0, -1, "regcomp.01", "regcomp.03.04", "regcomp.04",               "regexec.02", "regexec.04.01", "regexec.05",               "regexec.15.01", "regexec.15.02", "regexec.15.03", NULL ) );
    append_List( result, create_RegexpSheaf( "ab\ncd", SUT_REG_NEWLINE , 0, "ab\ncd", 0, SUT_REG_NOTEOL, 0, -1, "regcomp.01", "regcomp.03.04", "regcomp.04",               "regexec.02", "regexec.04.02", "regexec.05",               "regexec.15.01", "regexec.15.02", "regexec.15.03", NULL ) );
    return result;
}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_util_regex_scenario( int argc,char** argv ) {
    context = getContext();
    initCompiledRegularExpressionsAsObject_ProcessState
        ( getProcessState_CallContext( context ), create_CompiledRegularExpressions() );
    fnmatchSheafs = createFnmatchSheafs();
    currentFnmatchSheaf = NULL;
    regexpSheafs = createRegexpSheafs();
    currentSheaf = NULL;
    return true;
}

static void finish_util_regex_scenario( void ) {
    TEST_SCENARIO_VERDICT_VERBOSE( util_regex_scenario );
}

/********************************************************************/
/**                  Test Actions                                  **/
/********************************************************************/

scenario
bool util_regex_fnmatch_scen() {
    iterate ( int fnmatchSheafI = 0; fnmatchSheafI < size_List( fnmatchSheafs ); fnmatchSheafI++; ) {
        FnmatchSheaf * fnmatchSheaf = get_List( fnmatchSheafs, fnmatchSheafI );
        currentFnmatchSheaf = fnmatchSheaf;
        fnmatch_spec( context, fnmatchSheaf->pattern, fnmatchSheaf->whereFind, fnmatchSheaf->flags );
        currentFnmatchSheaf = NULL;
    }
}

scenario
bool util_regex_regcomp_regex_regfree_scen() {
    iterate ( int regexpSheafI = 0; regexpSheafI < size_List( regexpSheafs ); regexpSheafI++; ) {
        RegexpSheaf * regexpSheaf = get_List( regexpSheafs, regexpSheafI );
        RegcompReturnType * regcompReturn;
        currentSheaf = regexpSheaf;
        regcompReturn = regcomp_spec( context, regexpSheaf->pattern, regexpSheaf->cflags );
        if ( regcompReturn->funcRes == 0 ) {
            regexec_spec( context, regcompReturn->preg, regexpSheaf->whereFind, regexpSheaf->nmatch, regexpSheaf->eflags );
            regfree_spec( context, regcompReturn->preg );
        }
        currentSheaf = NULL;
    }
}

scenario
bool util_regex_regerror_scen() {
    iterate ( IntT errcode = SUT_REG_ENOSYS; errcode <= SUT_REG_ERPAREN; errcode++; ) {
        if ( knownErrcode( errcode ) ) {
            RegerrorReturnType * regerrorReturn = regerror_spec( context, errcode, NULL_VoidTPtr, 0 );
            regerror_spec( context, errcode, NULL_VoidTPtr, regerrorReturn->funcRes / 2 );
            regerror_spec( context, errcode, NULL_VoidTPtr, regerrorReturn->funcRes     );
            regerror_spec( context, errcode, NULL_VoidTPtr, regerrorReturn->funcRes * 2 );
        }
    }
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm util_regex_scenario = {
    .init    = init_util_regex_scenario  ,
    .finish  = finish_util_regex_scenario,
    .actions = { util_regex_fnmatch_scen              ,
                 util_regex_regcomp_regex_regfree_scen,
                 util_regex_regerror_scen             ,
                 NULL
               }
};

#ifdef REGEX_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "process/process/process_media.seh"
#include "system/sysconf/sysconf_media.seh"

/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/

void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initPathSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initSystemSysconfSubsystem();

    initUtilRegexSubsystem();
}

int main(int argc, char** argv)
{
    //
    initTestSystem();
    loadSUT();

    // Set up tracer
    //setTraceEncoding("windows-1251");

    addTraceToFile("trace.xml");

    trace_all_requirements = true;
    // Run test scenario
    util_regex_scenario(argc,argv);

    //  unloadSUT();
    return 0;
}

#endif


