/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "common/coverages.seh"
#include "process/process/process_model.seh"
#include "util/regex/regex_model.seh"

#pragma SEC subsystem regex "util.regex"

/*
   The group of functions 'util.regex' consists of:
       fnmatch [1]
       regcomp [1]
       regerror [1]
       regexec [1]
       regfree [1]
 */

coverage CoverageForIntTAsPeriodNoescapePathname( IntT i ) {
    switch ( i ) {
        case 0                                                   : return { f0, "Zero                  " };
        case                                     SUT_FNM_PATHNAME: return { f1, "              Pathname" };
        case                  SUT_FNM_NOESCAPE                   : return { f2, "      Noescape        " };
        case                  SUT_FNM_NOESCAPE | SUT_FNM_PATHNAME: return { f3, "      NoescapePathname" };
        case SUT_FNM_PERIOD                                      : return { f4, "Period                " };
        case SUT_FNM_PERIOD |                    SUT_FNM_PATHNAME: return { f5, "Period        Pathname" };
        case SUT_FNM_PERIOD | SUT_FNM_NOESCAPE                   : return { f6, "PeriodNoescape        " };
        case SUT_FNM_PERIOD | SUT_FNM_NOESCAPE | SUT_FNM_PATHNAME: return { f7, "PeriodNoescapePathname" };
        default                                                  : return { fX, "Unknown               " };
    }
}

bool knownErrcode( IntT e ) {
   return e == SUT_REG_NOMATCH || e == SUT_REG_BADPAT  || e == SUT_REG_ECOLLATE || e == SUT_REG_ECTYPE ||
          e == SUT_REG_EESCAPE || e == SUT_REG_ESUBREG || e == SUT_REG_EBRACK   || e == SUT_REG_EPAREN ||
          e == SUT_REG_EBRACE  || e == SUT_REG_BADBR   || e == SUT_REG_ERANGE   || e == SUT_REG_ESPACE ||
          e == SUT_REG_BADRPT  || e == SUT_REG_ENOSYS;
}

coverage CoverageForIntTAsNosubNewlineIcaseExtended( IntT i ) {
    switch ( i ) {
        case 0                                                                 : return { cf0, "Zero                   " };
        case                                                   SUT_REG_EXTENDED: return { cf1, "                 Extend" };
        case                                   SUT_REG_ICASE                   : return { cf2, "            Icase      " };
        case                                   SUT_REG_ICASE | SUT_REG_EXTENDED: return { cf3, "            IcaseExtend" };
        case                 SUT_REG_NEWLINE                                   : return { cf4, "     Newline           " };
        case                 SUT_REG_NEWLINE |                 SUT_REG_EXTENDED: return { cf5, "     Newline     Extend" };
        case                 SUT_REG_NEWLINE | SUT_REG_ICASE                   : return { cf6, "     NewlineIcase      " };
        case                 SUT_REG_NEWLINE | SUT_REG_ICASE | SUT_REG_EXTENDED: return { cf7, "     NewlineIcaseExtend" };
        case SUT_REG_NOSUB                                                     : return { cf8, "Nosub                  " };
        case SUT_REG_NOSUB |                                   SUT_REG_EXTENDED: return { cf9, "Nosub            Extend" };
        case SUT_REG_NOSUB |                   SUT_REG_ICASE                   : return { cfA, "Nosub       Icase      " };
        case SUT_REG_NOSUB |                   SUT_REG_ICASE | SUT_REG_EXTENDED: return { cfB, "Nosub       IcaseExtend" };
        case SUT_REG_NOSUB | SUT_REG_NEWLINE                                   : return { cfC, "NosubNewline           " };
        case SUT_REG_NOSUB | SUT_REG_NEWLINE |                 SUT_REG_EXTENDED: return { cfD, "NosubNewline     Extend" };
        case SUT_REG_NOSUB | SUT_REG_NEWLINE | SUT_REG_ICASE                   : return { cfE, "NosubNewlineIcase      " };
        case SUT_REG_NOSUB | SUT_REG_NEWLINE | SUT_REG_ICASE | SUT_REG_EXTENDED: return { cfF, "NosubNewlineIcaseExtend" };
        default                                                                : return { cfX, "Unknown                " };
    }
}

coverage CoverageForIntTAsNoteolNotbol( IntT i ) {
    switch ( i ) {
        case 0                              : return { ef0, "Zero        " };
        case                  SUT_REG_NOTBOL: return { ef1, "      Notbol" };
        case SUT_REG_NOTEOL                 : return { ef2, "Noteol      " };
        case SUT_REG_NOTEOL | SUT_REG_NOTBOL: return { ef3, "NoteolNotbol" };
        default                             : return { efX, "Unknown     " };
    }
}

coverage CoverageForIntTAsErrcode( IntT i ) {
    assertion( knownErrcode( i ), "CoverageForIntTAsErrcode : bad errcode %d\n", i );
    switch ( i ) {
        case SUT_REG_NOMATCH : return { ErrcodeRegNomatch , "regexec() failed to match"                                 };
        case SUT_REG_BADPAT  : return { ErrcodeRegBadpat  , "Invalid regular expression"                                };
        case SUT_REG_ECOLLATE: return { ErrcodeRegEcollate, "Invalid collating element referenced"                      };
        case SUT_REG_ECTYPE  : return { ErrcodeRegEctype  , "Invalid character class type referenced"                   };
        case SUT_REG_EESCAPE : return { ErrcodeRegEescape , "Trailing '\\' in pattern"                                  };
        case SUT_REG_ESUBREG : return { ErrcodeRegEsubreg , "Number in \\digit invalid or in error"                     };
        case SUT_REG_EBRACK  : return { ErrcodeRegEbrack  , "\"[]\" imbalance"                                          };
        case SUT_REG_EPAREN  : return { ErrcodeRegEparen  , "\"\\(\\)\" or \"()\" imbalance"                            };
        case SUT_REG_EBRACE  : return { ErrcodeRegEbrace  , "\"\\{\\}\" imbalance"                                      };
        case SUT_REG_BADBR   : return { ErrcodeRegBadbr   , "Content of \"\\{\\}\" invalid"                             };
        case SUT_REG_ERANGE  : return { ErrcodeRegErange  , "Invalid endpoint in range expression"                      };
        case SUT_REG_ESPACE  : return { ErrcodeRegEspace  , "Out of memory"                                             };
        case SUT_REG_BADRPT  : return { ErrcodeRegBadrpt  , "'?', '*', or '+' not preceded by valid regular expression" };
        case SUT_REG_ENOSYS  : return { ErrcodeRegEnosys  , "Reserved"                                                  };
     // default              : return { ErrcodeUnknown    , "Unknown errcode"                                           };
    }
}

/********************************************************************/
/**                          RegExp Data                           **/
/********************************************************************/

// struct CompiledRegularExpression

specification typedef struct CompiledRegularExpression CompiledRegularExpression = {};

/* quasi constructor */
CompiledRegularExpression * create_CompiledRegularExpression( RegexTPtr preg, CString * pattern, IntT cflags ) {
    return create( & type_CompiledRegularExpression,
                   preg, pattern,
                   cflags & SUT_REG_EXTENDED, cflags & SUT_REG_ICASE, cflags & SUT_REG_NOSUB, cflags & SUT_REG_NEWLINE
                 );
}

// bool CompiledRegularExpression::correspondTo( RegexTPtr preg ) const
bool correspondTo_CompiledRegularExpression
         ( /* const */ CompiledRegularExpression * thisCompiledRegularExpression, RegexTPtr preg ) {
    assertion( thisCompiledRegularExpression != NULL, "CompiledRegularExpression::correspondTo : this is NULL\n" );
    return equals_VoidTPtr( thisCompiledRegularExpression->preg, preg );
}

// struct CompiledRegularExpressions

specification typedef struct CompiledRegularExpressions CompiledRegularExpressions = {};

/* quasi constructor */
CompiledRegularExpressions * create_CompiledRegularExpressions( void ) {
    return create( & type_CompiledRegularExpressions, create_Set( & type_CompiledRegularExpression ) );
}

// static CompiledRegularExpressions * CompiledRegularExpressions::fromObject
//                                         ( Object * compiledRegularExpressionsAsObject )
CompiledRegularExpressions * fromObject_CompiledRegularExpressions( Object * compiledRegularExpressionsAsObject ) {
    CompiledRegularExpressions * result;
    assertion( compiledRegularExpressionsAsObject != NULL,
               "CompiledRegularExpressions::fromObject : compiledRegularExpressionsAsObject is NULL\n"
             );
    assertion( type( compiledRegularExpressionsAsObject ) == & type_CompiledRegularExpressions,
               "CompiledRegularExpressions::fromObject : bad type of compiledRegularExpressionsAsObject\n"
             );
    result = compiledRegularExpressionsAsObject;
    return result;
}

// static CompiledRegularExpressions * CompiledRegularExpressions::fromCallContext( CallContext context )
CompiledRegularExpressions * fromCallContext_CompiledRegularExpressions( CallContext context ) {
    return fromObject_CompiledRegularExpressions
               ( getCompiledRegularExpressionsAsObject_ProcessState( getProcessState_CallContext( context ) ) );
}

// CompiledRegularExpression * CompiledRegularExpressions::find( RegexTPtr preg )
CompiledRegularExpression * find_CompiledRegularExpressions
                                ( CompiledRegularExpressions * thisCompiledRegularExpressions, RegexTPtr preg ) {
    int i;
    assertion( thisCompiledRegularExpressions != NULL, "CompiledRegularExpressions::find : this is NULL\n" );
    for ( i = 0; i < size_Set( thisCompiledRegularExpressions->compiledRegularExpressions ); i++ ) {
        CompiledRegularExpression * compiledRegularExpression =
                                    get_Set( thisCompiledRegularExpressions->compiledRegularExpressions, i );
        if ( correspondTo_CompiledRegularExpression( compiledRegularExpression, preg ) ) {
            return compiledRegularExpression;
        }
    }
    return NULL;
}

// void CompiledRegularExpressions::add( const CompiledRegularExpression * compiledRegularExpression )
void add_CompiledRegularExpressions( CompiledRegularExpressions * thisCompiledRegularExpressions,
                                     /* const */ CompiledRegularExpression * compiledRegularExpression
                                   ) {
    assertion( thisCompiledRegularExpressions != NULL, "CompiledRegularExpressions::add : this is NULL\n" );
    add_Set( thisCompiledRegularExpressions->compiledRegularExpressions, compiledRegularExpression );
}

// void CompiledRegularExpressions::remove( RegexTPtr preg )
void remove_CompiledRegularExpressions( CompiledRegularExpressions * thisCompiledRegularExpressions, RegexTPtr preg ) {
    CompiledRegularExpression * compiledRegularExpression;
    assertion( thisCompiledRegularExpressions != NULL, "CompiledRegularExpressions::remove : this is NULL\n" );
    compiledRegularExpression = find_CompiledRegularExpressions( thisCompiledRegularExpressions, preg );
    remove_Set( thisCompiledRegularExpressions->compiledRegularExpressions, compiledRegularExpression );
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fnmatch - match a filename or a pathname

SYNOPSIS

    #include <fnmatch.h>
    int fnmatch(const char *pattern, const char *string, int flags);

DESCRIPTION

    The fnmatch() function shall match patterns as described in the Shell and
    Utilities volume of IEEE Std 1003.1-2001, Section 2.13.1, Patterns Matching
    a Single Character, and Section 2.13.2, Patterns Matching Multiple
    Characters. It checks the string specified by the string argument to see if
    it matches the pattern specified by the pattern argument.

    The flags argument shall modify the interpretation of pattern and string.
    It is the bitwise-inclusive OR of zero or more of the flags defined in
    <fnmatch.h>. If the FNM_PATHNAME flag is set in flags, then a slash
    character ( '/' ) in string shall be explicitly matched by a slash in
    pattern; it shall not be matched by either the asterisk or question-mark
    special characters, nor by a bracket expression. If the FNM_PATHNAME flag
    is not set, the slash character shall be treated as an ordinary character.

    If FNM_NOESCAPE is not set in flags, a backslash character ( '\' ) in
    pattern followed by any other character shall match that second character
    in string. In particular, "\\" shall match a backslash in string. If
    FNM_NOESCAPE is set, a backslash character shall be treated as an ordinary
    character.

    If FNM_PERIOD is set in flags, then a leading period ( '.' ) in string
    shall match a period in pattern; as described by rule 2 in the Shell and
    Utilities volume of IEEE Std 1003.1-2001, Section 2.13.3, Patterns Used for
    Filename Expansion where the location of "leading" is indicated by the
    value of FNM_PATHNAME:

    If FNM_PATHNAME is set, a period is "leading" if it is the first character
    in string or if it immediately follows a slash.

    If FNM_PATHNAME is not set, a period is "leading" only if it is the first
    character of string.

    If FNM_PERIOD is not set, then no special restrictions are placed on
    matching a period.

RETURN VALUE

    If string matches the pattern specified by pattern, then fnmatch() shall
    return 0. If there is no match, fnmatch() shall return FNM_NOMATCH, which
    is defined in <fnmatch.h>.If an error occurs, fnmatch() shall return
    another non-zero value.

ERRORS

    No errors are defined.
*/

specification
IntT fnmatch_spec( CallContext context, CString * pattern, CString * str, IntT flags ) {
    pre {
        return true;
    }
    coverage fnmatch_coverage = CoverageForNotNullCString( pattern ) * CoverageForNotNullCString( str ) *
                                CoverageForIntTAsPeriodNoescapePathname( flags );
    post {
        /*
         * The fnmatch() function shall match patterns
         */
        REQ("fnmatch.01", "", GENERAL_REQ("fnmatch.*"));

        /*
         * If an error occurs, fnmatch() shall return another non-zero value.
         */
        REQ("fnmatch.04.03", "", TODO_REQ());

        /* [Check result] */
        REQ( "", "Check result", checkFnmatchResult( pattern, str, flags, fnmatch_spec ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    regexec -- regular expression matching

DESCRIPTION

    The regexec() function shall behave as specified in ISO POSIX (2003), except
    with differences as listed below.

    Differences

    Certain aspects of regular expression matching are optional; see
    Internationalization and Regular Expressions.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    regcomp, regerror, regexec, regfree - regular expression matching

SYNOPSIS

    #include <regex.h>

    int regcomp(regex_t *restrict preg, const char *restrict pattern,
           int cflags);
    size_t regerror(int errcode, const regex_t *restrict preg,
           char *restrict errbuf, size_t errbuf_size);
    int regexec(const regex_t *restrict preg, const char *restrict string,
           size_t nmatch, regmatch_t pmatch[restrict], int eflags);
    void regfree(regex_t *preg);

DESCRIPTION

    These functions interpret basic and extended regular expressions as
    described in the Base Definitions volume of IEEE Std 1003.1-2001, Chapter
    9, Regular Expressions.

    The regex_t structure is defined in <regex.h> and contains at least the
    following member:

    Member Type   Member Name     Description

    size_t        re_nsub         Number of parenthesized subexpressions.

    The regmatch_t structure is defined in <regex.h> and contains at least the
    following members:

    Member Type     Member Name     Description

    regoff_t        rm_so           Byte offset from start of string to start
                                    of substring.

    regoff_t        rm_eo           Byte offset from start of string of the
                                    first character after the end of substring.

    The regcomp() function shall compile the regular expression contained in
    the string pointed to by the pattern argument and place the results in the
    structure pointed to by preg. The cflags argument is the bitwise-inclusive
    OR of zero or more of the following flags, which are defined in the
    <regex.h> header:

        REG_EXTENDED
        Use Extended Regular Expressions.

        REG_ICASE
        Ignore case in match. (See the Base Definitions volume of IEEE Std
        1003.1-2001, Chapter 9, Regular Expressions.)

        REG_NOSUB
        Report only success/fail in regexec().

        REG_NEWLINE
        Change the handling of <newline>s, as described in the text.

    The default regular expression type for pattern is a Basic Regular
    Expression. The application can specify Extended Regular Expressions using
    the REG_EXTENDED cflags flag.

    If the REG_NOSUB flag was not set in cflags, then regcomp() shall set
    re_nsub to the number of parenthesized subexpressions (delimited by "\(\)"
    in basic regular expressions or "()" in extended regular expressions) found
    in pattern.

    The regexec() function compares the null-terminated string specified by
    string with the compiled regular expression preg initialized by a previous
    call to regcomp(). If it finds a match, regexec() shall return 0;otherwise,
    it shall return non-zero indicating either no match or an error. The eflags
    argument is the bitwise-inclusive OR of zero or more of the following
    flags, which are defined in the <regex.h> header:

        REG_NOTBOL
        The first character of the string pointed to by string is not the
        beginning of the line. Therefore, the circumflex character ( '^' ),
        when taken as a special character, shall not match the beginning of
        string.

        REG_NOTEOL
        The last character of the string pointed to by string is not the end of
        the line. Therefore, the dollar sign ( '$' ), when taken as a special
        character, shall not match the end of string.

    If nmatch is 0 or REG_NOSUB was set in the cflags argument to regcomp(),
    then regexec() shall ignore the pmatch argument. Otherwise, the application
    shall ensure that the pmatch argument points to an array with at least
    nmatch elements, and regexec() shall fill in the elements of that array
    with offsets of the substrings of string that correspond to the
    parenthesized subexpressions of pattern: pmatch[ i]. rm_so shall be the
    byte offset of the beginning and pmatch[ i]. rm_eo shall be one greater
    than the byte offset of the end of substring i. (Subexpression i begins at
    the ith matched open parenthesis, counting from 1.) Offsets in pmatch[0]
    identify the substring that corresponds to the entire regular expression.
    Unused elements of pmatch up to pmatch[ nmatch-1] shall be filled with -1.
    If there are more than nmatch subexpressions in pattern ( pattern itself
    counts as a subexpression), then regexec() shall still do the match, but
    shall record only the first nmatch substrings.

    When matching a basic or extended regular expression, any given
    parenthesized subexpression of pattern might participate in the match of
    several different substrings of string, or it might not match any substring
    even though the pattern as a whole did match. The following rules shall be
    used to determine which substrings to report in pmatch when matching
    regular expressions:

        If subexpression i in a regular expression is not contained within
        another subexpression, and it participated in the match several times,
        then the byte offsets in pmatch[ i] shall delimit the last such match.

        If subexpression i is not contained within another subexpression, and
        it did not participate in an otherwise successful match, the byte
        offsets in pmatch[ i] shall be -1. A subexpression does not participate
        in the match when:

            '*' or "\{\}" appears immediately after the subexpression in a
            basic regular expression, or '*', '?', or "{}" appears immediately
            after the subexpression in an extended regular expression, and the
            subexpression did not match (matched 0 times)

            or:

            '|' is used in an extended regular expression to select this
            subexpression or another, and the other subexpression matched.

        If subexpression i is contained within another subexpression j, and i
        is not contained within any other subexpression that is contained
        within j, and a match of subexpression j is reported in pmatch[ j],
        then the match or non-match of subexpression i reported in pmatch[ i]
        shall be as described in 1. and 2. above, but within the substring
        reported in pmatch[ j] rather than the whole string. The offsets in
        pmatch[ i] are still relative to the start of string.

        If subexpression i is contained in subexpression j, and the byte
        offsets in pmatch[ j] are -1, then the pointers in pmatch[ i] shall
        also be -1.

        If subexpression i matched a zero-length string, then both byte offsets
        in pmatch[ i] shall be the byte offset of the character or null
        terminator immediately following the zero-length string.

    If, when regexec() is called, the locale is different from when the regular
    expression was compiled, the result is undefined.

    If REG_NEWLINE is not set in cflags, then a <newline> in pattern or string
    shall be treated as an ordinary character. If REG_NEWLINE is set, then
    <newline> shall be treated as an ordinary character except as follows:

        A <newline> in string shall not be matched by a period outside a
        bracket expression or by any form of a non-matching list (see the Base
        Definitions volume of IEEE Std 1003.1-2001, Chapter 9, Regular
        Expressions).

        A circumflex ( '^' ) in pattern, when used to specify expression
        anchoring (see the Base Definitions volume of IEEE Std 1003.1-2001,
        Section 9.3.8, BRE Expression Anchoring), shall match the zero-length
        string immediately after a <newline> in string, regardless of the
        setting of REG_NOTBOL.

        A dollar sign ( '$' ) in pattern, when used to specify expression
        anchoring, shall match the zero-length string immediately before a
        <newline> in string, regardless of the setting of REG_NOTEOL.

    The regfree() function frees any memory allocated by regcomp() associated
    with preg.

    The following constants are defined as error return values:

        REG_NOMATCH
        regexec() failed to match.

        REG_BADPAT
        Invalid regular expression.

        REG_ECOLLATE
        Invalid collating element referenced.

        REG_ECTYPE
        Invalid character class type referenced.

        REG_EESCAPE
        Trailing '\' in pattern.

        REG_ESUBREG
        Number in "\digit" invalid or in error.

        REG_EBRACK
        "[]" imbalance.

        REG_EPAREN
        "\(\)" or "()" imbalance.

        REG_EBRACE
        "\{\}" imbalance.

        REG_BADBR
        Content of "\{\}" invalid: not a number, number too large, more than
        two numbers, first larger than second.

        REG_ERANGE
        Invalid endpoint in range expression.

        REG_ESPACE
        Out of memory.

        REG_BADRPT
        '?', '*', or '+' not preceded by valid regular expression.

    The regerror() function provides a mapping from error codes returned by
    regcomp() and regexec() to unspecified printable strings. It generates a
    string corresponding to the value of the errcode argument, which the
    application shall ensure is the last non-zero value returned by regcomp()
    or regexec() with the given value of preg. If errcode is not such a value,
    the content of the generated string is unspecified.

    If preg is a null pointer, but errcode is a value returned by a previous
    call to regexec() or regcomp(), the regerror() still generates an error
    string corresponding to the value of errcode, but it might not be as
    detailed under some implementations.

    If the errbuf_size argument is not 0, regerror() shall place the generated
    string into the buffer of size errbuf_size bytes pointed to by errbuf.If
    the string (including the terminating null) cannot fit in the buffer,
    regerror() shall truncate the string and null-terminate the result.

    If errbuf_size is 0, regerror() shall ignore the errbuf argument, and
    return the size of the buffer needed to hold the generated string.

    If the preg argument to regexec() or regfree() is not a compiled regular
    expression returned by regcomp(), the result is undefined. A preg is no
    longer treated as a compiled regular expression after it is given to
    regfree().

RETURN VALUE

    Upon successful completion, the regcomp() function shall return 0.
    Otherwise, it shall return an integer value indicating an error as
    described in <regex.h>, and the content of preg is undefined. If a code is
    returned, the interpretation shall be as given in <regex.h>.

    If regcomp() detects an invalid RE, it may return REG_BADPAT, or it may
    return one of the error codes that more precisely describes the error.

    Upon successful completion, the regexec() function shall return 0.
    Otherwise, it shall return REG_NOMATCH to indicate no match.

    Upon successful completion, the regerror() function shall return the number
    of bytes needed to hold the entire generated string, including the null
    termination. If the return value is greater than errbuf_size, the string
    returned in the buffer pointed to by errbuf has been truncated.

    The regfree() function shall not return a value.

ERRORS

    No errors are defined.
*/
specification typedef struct RegcompReturnType RegcompReturnType = {};

specification
RegcompReturnType * regcomp_spec( CallContext context, CString * pattern, IntT cflags ) {
    pre {
        return true;
    }
    coverage regcomp_coverage =
                 CoverageForNotNullCString( pattern ) * CoverageForIntTAsNosubNewlineIcaseExtended( cflags );
    post {
        /*
         * The regcomp() function shall compile the regular expression contained in the
         * string pointed to by the pattern argument and place the results in the
         * structure pointed to by preg.
         */
        REQ("regcomp.02", "", TODO_REQ());

        /*
         * If the REG_NOSUB flag was not set in cflags, then regcomp() shall set re_nsub
         * to the number of parenthesized subexpressions (delimited by "\(\)" in basic
         * regular expressions or "()" in extended regular expressions) found in pattern.
         */
        REQ("regcomp.06", "", TODO_REQ());

        if ( regcomp_spec->funcRes == 0 ) {
            /*
             * Upon successful completion, the regcomp() function shall return 0.
             */
            REQ( "regcomp.26.01", "Upon successful completion, the regcomp() shall return 0", regcomp_spec->funcRes == 0 );
        } else {
            /*
             * Otherwise, it shall return an integer value indicating an error as described in
             * <regex.h>, and the content of preg is undefined. If a code is returned,
             * the interpretation shall be as given in <regex.h>.
             */
            REQ( "regcomp.26.02", "return an integer value indicating an error", regcomp_spec->funcRes != 0 );

            if ( regcomp_spec->funcRes == SUT_REG_BADPAT ) {
                /*
                 * If regcomp() detects an invalid RE, it may return REG_BADPAT, or it may return
                 * one of the error codes that more precisely describes the error.
                 */
                REQ( "regcomp.27", "If regcomp() detects an invalid RE, it may return REG_BADPAT",
                                   regcomp_spec->funcRes == SUT_REG_BADPAT
                   );

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADPAT Invalid regular expression.
                 */
                REQ("regcomp.16.02", "", TODO_REQ());
            } else {
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_NOMATCH regexec() failed to match.
                 */
                REQ("regcomp.16.01", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ECOLLATE Invalid collating element referenced.
                 */
                REQ("regcomp.16.03", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ECTYPE Invalid character class type referenced.
                 */
                REQ("regcomp.16.04", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EESCAPE Trailing '\' in pattern.
                 */
                REQ("regcomp.16.05", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ESUBREG Number in "\digit" invalid or in error.
                 */
                REQ("regcomp.16.06", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EBRACK "[]" imbalance.
                 */
                REQ("regcomp.16.07", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EPAREN "\(\)" or "()" imbalance.
                 */
                REQ("regcomp.16.08", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EBRACE "\{\}" imbalance.
                 */
                REQ("regcomp.16.09", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADBR Content of "\{\}" invalid: not a number, number too large, more than
                 * two numbers, first larger than second.
                 */
                REQ("regcomp.16.10", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ERANGE Invalid endpoint in range expression.
                 */
                REQ("regcomp.16.11", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ESPACE Out of memory.
                 */
                REQ("regcomp.16.12", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADRPT '?', '*', or '+' not preceded by valid regular expression.
                 */
                REQ("regcomp.16.13", "", TODO_REQ());
            }
        }

        /* [Check result] */
        REQ( "", "Check result", checkRegcompResult( pattern, cflags, regcomp_spec->funcRes ) );

        return true;
    }
}

specification typedef struct RegerrorReturnType RegerrorReturnType = {};

specification
RegerrorReturnType * regerror_spec( CallContext context, IntT errcode, RegexTPtr preg, SizeT errbuf_size ) {
    pre {
        /*
         * If errcode is not such a value, the content of the generated string is
         * unspecified.
         */
        REQ( "app.regerror.19", "the content of the generated string is unspecified", knownErrcode( errcode ) );

        return true;
    }
    coverage regerror_coverage = CoverageForIntTAsErrcode( errcode )                 *
                                 CoverageForPointer( preg )                          *
                                 CoverageForInteger_Min( (int)errbuf_size, 0, 5000 );
    post {
        switch ( regerror_coverage[ 0 ] ) {
            case CoverageForIntTAsErrcode.ErrcodeRegNomatch:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_NOMATCH regexec() failed to match.
                 */
                REQ( "regerror.16.01", "regexec() failed to match", errcode == SUT_REG_NOMATCH );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegBadpat:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADPAT Invalid regular expression.
                 */
                REQ( "regerror.16.02", "Invalid regular expression", errcode == SUT_REG_BADPAT );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEcollate:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ECOLLATE Invalid collating element referenced.
                 */
                REQ( "regerror.16.03", "Invalid collating element referenced", errcode == SUT_REG_ECOLLATE );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEctype:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ECTYPE Invalid character class type referenced.
                 */
                REQ( "regerror.16.04", "Invalid character class type referenced", errcode == SUT_REG_ECTYPE );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEescape:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EESCAPE Trailing '\' in pattern.
                 */
                REQ( "regerror.16.05", "Trailing '\' in pattern", errcode == SUT_REG_EESCAPE );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEsubreg:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ESUBREG Number in "\digit" invalid or in error.
                 */
                REQ( "regerror.16.06", "Number in \"\\digit\" invalid or in error", errcode == SUT_REG_ESUBREG );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEbrack:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EBRACK "[]" imbalance.
                 */
                REQ( "regerror.16.07", "\"[]\" imbalance", errcode == SUT_REG_EBRACK );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEparen:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EPAREN "\(\)" or "()" imbalance.
                 */
                REQ( "regerror.16.08", "\"\\(\\)\" or \"()\" imbalance", errcode == SUT_REG_EPAREN );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEbrace:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EBRACE "\{\}" imbalance.
                 */
                REQ( "regerror.16.09", "\"\\{\\}\" imbalance", errcode == SUT_REG_EBRACE );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegBadbr:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADBR Content of "\{\}" invalid: not a number, number too large, more than
                 * two numbers, first larger than second.
                 */
                REQ( "regerror.16.10", "Content of \"\\{\\}\" invalid", errcode == SUT_REG_BADBR );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegErange:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ERANGE Invalid endpoint in range expression.
                 */
                REQ( "regerror.16.11", "Invalid endpoint in range expression", errcode == SUT_REG_ERANGE );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEspace:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ESPACE Out of memory.
                 */
                REQ( "regerror.16.12", "Out of memory", errcode == SUT_REG_ESPACE );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegBadrpt:
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADRPT '?', '*', or '+' not preceded by valid regular expression.
                 */
                REQ( "regerror.16.13", "'?', '*', or '+' not preceded by valid regular expression",
                                       errcode == SUT_REG_BADRPT
                   );
                break;
            case CoverageForIntTAsErrcode.ErrcodeRegEnosys:
                break;
        } // switch errcode

        /*
         * The regerror() function provides a mapping from error codes returned by
         * regcomp() and regexec() to unspecified printable strings.
         */
        REQ( "regerror.17", "mapping from error codes to unspecified printable strings", true );

        /*
         * It generates a string corresponding to the value of the errcode argument, which
         * the application shall ensure is the last non-zero value returned by regcomp()
         * or regexec() with the given value of preg.
         */
        REQ( "regerror.18", "string corresponding to the value of the errcode", true );

        if ( isNULL_VoidTPtr( preg ) ) {
            /*
             * If preg is a null pointer, but errcode is a value returned by a previous call
             * to regexec() or regcomp(), the regerror() still generates an error string
             * corresponding to the value of errcode, but it might not be as detailed under
             * some implementations.
             */
            REQ( "regerror.20", "If preg is a null pointer, the regerror() still generates an error string", true );
        }

        if ( errbuf_size == 0 ) {
            /*
             * If errbuf_size is 0, regerror() shall ignore the errbuf argument, and return
             * the size of the buffer needed to hold the generated string.
             */
            REQ( "regerror.23", "", regerror_spec->funcRes > 0 );
        } else {
            bool checkResult = length_CString( regerror_spec->errbuf ) + 1 <= errbuf_size; // 1 for final 0
            /*
             * If the errbuf_size argument is not 0, regerror() shall place the generated
             * string into the buffer of size errbuf_size bytes pointed to by errbuf.
             */
            REQ( "regerror.21", "regerror() place string into the buffer of size errbuf_size bytes", checkResult );

            /*
             * Upon successful completion, the regerror() function shall return the number of
             * bytes needed to hold the entire generated string, including the null
             * termination.
             */
            REQ( "regerror.26", "the regerror() return the number of bytes needed to hold the entire generated string",
                                length_CString( regerror_spec->errbuf ) + 1 <= regerror_spec->funcRes
               );

            if ( regerror_spec->funcRes > errbuf_size ) {
                /*
                 * If the string (including the terminating null) cannot fit in the buffer,
                 * regerror() shall truncate the string and null-terminate the result.
                 */
                REQ( "regerror.22", "regerror() truncate the string in the buffer", checkResult );

                /*
                 * If the return value is greater than errbuf_size, the string returned in the
                 * buffer pointed to by errbuf has been truncated.
                 */
                REQ( "regerror.27", "the string returned in the buffer has been truncated", checkResult );
            }
        }

        return true;
    }
}

specification typedef struct RegmatchT RegmatchT = {};

specification typedef struct RegexecReturnType RegexecReturnType = {};

specification
RegexecReturnType * regexec_spec( CallContext context, RegexTPtr preg, CString * str, SizeT nmatch, IntT eflags ) {
    pre {
        /*
         * Otherwise, the application shall ensure that the pmatch argument points to an
         * array with at least nmatch elements,
         */
        REQ("app.regexec.06.01", "", TODO_REQ());

        /*
         * If, when regexec() is called, the locale is different from when the regular
         * expression was compiled, the result is undefined.
         */
        REQ("app.regexec.13", "", TODO_REQ());

        /*
         * If the preg argument to regexec() or regfree() is not a compiled regular
         * expression returned by regcomp(), the result is undefined.
         */
        REQ( "app.regexec.24",
             "preg argument is not a compiled regular expression returned by regcomp",
             find_CompiledRegularExpressions( fromCallContext_CompiledRegularExpressions( context ), preg ) != NULL
           );

        return true;
    }
    coverage regexec_coverage = CoverageForNotNullCString( str ) * CoverageForIntTAsNoteolNotbol( eflags );
    post {
        CompiledRegularExpression * compiledRegularExpression = find_CompiledRegularExpressions(
                                                                    fromCallContext_CompiledRegularExpressions( context ),
                                                                    preg
                                                                );
        if ( regexec_spec->funcRes == 0 ) {
            /*
             * If it finds a match, regexec() shall return 0;
             */
            REQ( "regexec.03.01", "If it finds a match, regexec() shall return 0", regexec_spec->funcRes == 0 );

            /*
             * Upon successful completion, the regexec() function shall return 0.
             */
            REQ("regexec.26.01", "Upon successful completion, the regexec() shall return 0", regexec_spec->funcRes == 0 );

            if ( nmatch != 0 && ! compiledRegularExpression->reportOnlySuccessFail ) {
                /*
                 * and regexec() shall fill in the elements of that array with offsets of the
                 * substrings of string that correspond to the parenthesized subexpressions of
                 * pattern:
                 *
                 * pmatch[ i]. rm_so shall be the byte offset of the beginning
                 */
                REQ("regexec.06.02.01", "", TODO_REQ());

                /*
                 * and regexec() shall fill in the elements of that array with offsets of the
                 * substrings of string that correspond to the parenthesized subexpressions of
                 * pattern:
                 *
                 * and pmatch[ i]. rm_eo shall be one greater than the byte offset of the end of
                 * substring i.
                 */
                REQ("regexec.06.02.02", "", TODO_REQ());

                /*
                 * Subexpression i begins at the ith matched open parenthesis, counting from 1.
                 */
                REQ("regexec.07", "", TODO_REQ());

                /*
                 * Offsets in pmatch[0] identify the substring that corresponds to the entire
                 * regular expression.
                 */
                REQ("regexec.08", "", TODO_REQ());

                /*
                 * Unused elements of pmatch up to pmatch[ nmatch-1] shall be filled with -1.
                 */
                REQ("regexec.09", "", TODO_REQ());

                /*
                 * If there are more than nmatch subexpressions in pattern ( pattern itself counts
                 * as a subexpression), then regexec() shall still do the match, but shall record
                 * only the first nmatch substrings.
                 */
                REQ("regexec.10", "", TODO_REQ());

                /*
                 * When matching a basic or extended regular expression, any given parenthesized
                 * subexpression of pattern might participate in the match of several different
                 * substrings of string, or it might not match any substring even though the
                 * pattern as a whole did match.
                 */
                REQ("regexec.11", "", TODO_REQ());

                /*
                 * The following rules shall be used to determine which substrings to report in
                 * pmatch when matching regular expressions:
                 *
                 * If subexpression i in a regular expression is not contained within another
                 * subexpression, and it participated in the match several times, then the byte
                 * offsets in pmatch[ i] shall delimit the last such match.
                 */
                REQ("regexec.12.01", "", TODO_REQ());

                /*
                 * If subexpression i is not contained within another subexpression, and it did
                 * not participate in an otherwise successful match, the byte offsets in pmatch[ i]
                 * shall be -1.
                 */
                REQ("regexec.12.02.01", "", TODO_REQ());

                /*
                 * A subexpression does not participate in the match when:
                 *
                 * '*' or "\{\}" appears immediately after the subexpression in a basic regular
                 * expression, or '*', '?', or "{}" appears immediately after the subexpression in
                 * an extended regular expression, and the subexpression did not match (matched 0
                 * times)
                 */
                REQ("regexec.12.02.02.01", "", TODO_REQ());

                /*
                 * A subexpression does not participate in the match when:
                 *
                 * '|' is used in an extended regular expression to select this subexpression or
                 * another, and the other subexpression matched.
                 */
                REQ("regexec.12.02.02.02", "", TODO_REQ());

                /*
                 * If subexpression i is contained within another subexpression j, and i is not
                 * contained within any other subexpression that is contained within j, and a
                 * match of subexpression j is reported in pmatch[ j], then the match or non-match
                 * of subexpression i reported in pmatch[ i] shall be as described in 1. and 2.
                 * above, but within the substring reported in pmatch[ j] rather than the whole
                 * string.
                 */
                REQ("regexec.12.03.01", "", TODO_REQ());

                /*
                 * The offsets in pmatch[ i] are still relative to the start of string.
                 */
                REQ("regexec.12.03.02", "", TODO_REQ());

                /*
                 * The following rules shall be used to determine which substrings to report in
                 * pmatch when matching regular expressions:
                 *
                 * If subexpression i is contained in subexpression j, and the byte offsets in
                 * pmatch[ j] are -1, then the pointers in pmatch[ i] shall also be -1.
                 */
                REQ("regexec.12.04", "", TODO_REQ());

                /*
                 * The following rules shall be used to determine which substrings to report in
                 * pmatch when matching regular expressions:
                 *
                 * If subexpression i matched a zero-length string, then both byte offsets in
                 * pmatch[ i] shall be the byte offset of the character or null terminator
                 * immediately following the zero-length string.
                 */
                REQ("regexec.12.05", "", TODO_REQ());
            }
        } else {
            /*
             * otherwise, it shall return non-zero indicating either no match or an error.
             */
            REQ( "regexec.03.02", "return non-zero indicating either no match or an error", regexec_spec->funcRes != 0 );

            if ( regexec_spec->funcRes == SUT_REG_NOMATCH ) {
                /*
                 * Otherwise, it shall return REG_NOMATCH to indicate no match.
                 */
                REQ("regexec.26.02", "return REG_NOMATCH to indicate no match", regexec_spec->funcRes == SUT_REG_NOMATCH );
            } else {
                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_NOMATCH regexec() failed to match.
                 */
                REQ("regexec.16.01", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADPAT Invalid regular expression.
                 */
                REQ("regexec.16.02", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ECOLLATE Invalid collating element referenced.
                 */
                REQ("regexec.16.03", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ECTYPE Invalid character class type referenced.
                 */
                REQ("regexec.16.04", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EESCAPE Trailing '\' in pattern.
                 */
                REQ("regexec.16.05", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ESUBREG Number in "\digit" invalid or in error.
                 */
                REQ("regexec.16.06", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EBRACK "[]" imbalance.
                 */
                REQ("regexec.16.07", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EPAREN "\(\)" or "()" imbalance.
                 */
                REQ("regexec.16.08", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_EBRACE "\{\}" imbalance.
                 */
                REQ("regexec.16.09", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADBR Content of "\{\}" invalid: not a number, number too large, more than
                 * two numbers, first larger than second.
                 */
                REQ("regexec.16.10", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ERANGE Invalid endpoint in range expression.
                 */
                REQ("regexec.16.11", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_ESPACE Out of memory.
                 */
                REQ("regexec.16.12", "", TODO_REQ());

                /*
                 * The following constants are defined as error return values:
                 *
                 * REG_BADRPT '?', '*', or '+' not preceded by valid regular expression.
                 */
                REQ("regexec.16.13", "", TODO_REQ());
            }
        }

        /*
         * Certain aspects of regular expression matching are optional; see
         * Internationalization and Regular Expressions.
         */
        REQ("regexec.30", "", TODO_REQ());

        /* [Check result] */
        REQ( "", "Check result", checkRegexecResult( str, nmatch, eflags, regexec_spec->funcRes, regexec_spec->pmatch ) );

        return true;
    }
}

specification
void regfree_spec( CallContext context, RegexTPtr preg ) {
    pre {
        /*
         * If the preg argument to regexec() or regfree() is not a compiled regular
         * expression returned by regcomp(), the result is undefined.
         */
        REQ( "app.regfree.24",
             "preg argument is not a compiled regular expression returned by regcomp",
             find_CompiledRegularExpressions( fromCallContext_CompiledRegularExpressions( context ), preg ) != NULL
           );

        return true;
    }
    post {
        bool checkResult =
             find_CompiledRegularExpressions( fromCallContext_CompiledRegularExpressions( context ), preg ) == NULL;

        /*
         * The regfree() function frees any memory allocated by regcomp() associated with
         * preg.
         */
        REQ( "regfree.02", "regfree() frees any memory allocated by regcomp() associated with preg", checkResult );

        /*
         * A preg is no longer treated as a compiled regular expression after it is given
         * to regfree().
         */
        REQ( "regfree.25", "preg is no longer treated as a compiled regular expression", checkResult );

        /*
         * The following constants are defined as error return values:
         *
         * REG_NOMATCH regexec() failed to match.
         */
        REQ("regfree.16.01", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_BADPAT Invalid regular expression.
         */
        REQ("regfree.16.02", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_ECOLLATE Invalid collating element referenced.
         */
        REQ("regfree.16.03", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_ECTYPE Invalid character class type referenced.
         */
        REQ("regfree.16.04", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_EESCAPE Trailing '\' in pattern.
         */
        REQ("regfree.16.05", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_ESUBREG Number in "\digit" invalid or in error.
         */
        REQ("regfree.16.06", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_EBRACK "[]" imbalance.
         */
        REQ("regfree.16.07", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_EPAREN "\(\)" or "()" imbalance.
         */
        REQ("regfree.16.08", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_EBRACE "\{\}" imbalance.
         */
        REQ("regfree.16.09", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_BADBR Content of "\{\}" invalid: not a number, number too large, more than
         * two numbers, first larger than second.
         */
        REQ("regfree.16.10", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_ERANGE Invalid endpoint in range expression.
         */
        REQ("regfree.16.11", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_ESPACE Out of memory.
         */
        REQ("regfree.16.12", "", TODO_REQ());

        /*
         * The following constants are defined as error return values:
         *
         * REG_BADRPT '?', '*', or '+' not preceded by valid regular expression.
         */
        REQ("regfree.16.13", "", TODO_REQ());

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

RegmatchT * create_RegmatchT( RegoffT rm_so, RegoffT rm_eo ) { return create( & type_RegmatchT, rm_so, rm_eo ); }

RegcompReturnType * create_RegcompReturnType( IntT funcRes, RegexTPtr preg ) {
    return create( & type_RegcompReturnType, funcRes, preg );
}

RegexecReturnType * create_RegexecReturnType( IntT funcRes, List /* RegmatchT */ * pmatch ) {
    return create( & type_RegexecReturnType, funcRes, pmatch );
}

RegerrorReturnType * create_RegerrorReturnType( SizeT funcRes, CString * errbuf ) {
    return create( & type_RegerrorReturnType, funcRes, errbuf );
}

static void traceReqIdsForFunc( List /* String */ * reqIds, const char * funcName ) {
    int i;
    for ( i = 0; i < size_List( reqIds ); i++ ) {
        String * reqId = get_List( reqIds, i );
        if ( startsWith_String( reqId, create_String( funcName ) ) ) {
            char * reqIdAsCharArray = (char *)toCharArray_String( reqId );
            traceRequirements( reqIdAsCharArray );
        }
    }
}

// FnmatchSheaf
specification typedef struct FnmatchSheaf FnmatchSheaf = {};

/* ... == "reqId1", ..., "reqIdn", NULL
 * n >= 0
 * minimal ... == NULL
 */
FnmatchSheaf * create_FnmatchSheaf( char * pattern, char * whereFind, IntT flags, IntT res, ... ) {
    List /* String */ * rIds = create_List( & type_String );
    char * ri;
    va_list list;
    va_start( list, res );
    while ( ( ri = va_arg( list, char * ) ) != NULL ) { append_List( rIds, create_String( ri ) ); }
    va_end( list );
    return create( & type_FnmatchSheaf, create_CString( pattern ), create_CString( whereFind ), flags, res, rIds );
}

FnmatchSheaf * currentFnmatchSheaf;

bool checkFnmatchResult( CString * pattern, CString * str, IntT flags, IntT res ) {
    assertion( currentFnmatchSheaf != NULL, "checkFnmatchResult : currentFnmatchSheaf is NULL\n" );
    assertion( equals( currentFnmatchSheaf->pattern, pattern ),
               "checkFnmatchResult : currentFnmatchSheaf->pattern not equals to pattern\n"
             );
    assertion( equals( currentFnmatchSheaf->whereFind, str ),
               "checkFnmatchResult : currentFnmatchSheaf->whereFind not equals to str\n"
             );
    assertion
        ( currentFnmatchSheaf->flags == flags, "checkFnmatchResult : currentFnmatchSheaf->flags not equals to flags\n" );
    traceReqIdsForFunc( currentFnmatchSheaf->reqIds, "fnmatch" );
    return currentFnmatchSheaf->res == res;
}

// RegexpSheaf
specification typedef struct RegexpSheaf RegexpSheaf = {};

/* ... == rm_so_1, rm_eo_1, ..., rm_so_m, rm_eo_m, -1, "reqId1", ..., "reqIdn", NULL
 * m >= 0, n >= 0
 * minimal ... == -1, NULL
 */
RegexpSheaf * create_RegexpSheaf( char * pattern, IntT cflags, IntT regcompRes,
                                  char * whereFind, SizeT nmatch, IntT eflags, IntT regexecRes, ...
                                ) {
    List /* RegmatchT */ * fits = create_List( & type_RegmatchT );
    List /* String    */ * rIds = create_List( & type_String    );
    int so;
    char * ri;
    va_list list;
    va_start( list, regexecRes );
    while ( ( so = va_arg( list, int    ) ) != -1   ) { append_List( fits, create_RegmatchT( so, va_arg( list, int ) ) ); }
    while ( ( ri = va_arg( list, char * ) ) != NULL ) { append_List( rIds, create_String   ( ri                      ) ); }
    va_end( list );
    while ( size_List( fits ) < nmatch ) { append_List( fits, create_RegmatchT( -1, -1 ) ); }
    return create( & type_RegexpSheaf, create_CString( pattern ), cflags,
                                       regcompRes,
                                       create_CString( whereFind ), nmatch, eflags,
                                       regexecRes, fits,
                                       rIds
                 );
}

RegexpSheaf * currentSheaf;

bool checkRegcompResult( CString * pattern, IntT cflags, IntT regcompRes ) {
    assertion( currentSheaf != NULL, "checkRegcompResult : currentSheaf is NULL\n" );
    assertion
        ( equals( currentSheaf->pattern, pattern ), "checkRegcompResult : currentSheaf->pattern not equals to pattern\n" );
    assertion( currentSheaf->cflags == cflags, "checkRegcompResult : currentSheaf->cflags not equals to cflags\n" );
    traceReqIdsForFunc( currentSheaf->reqIds, "regcomp" );
    return currentSheaf->regcompRes == regcompRes;
}

bool checkRegexecResult( CString * str, SizeT nmatch, IntT eflags, IntT regexecRes, List /* RegmatchT */ * pmatch ) {
    assertion( currentSheaf != NULL, "checkRegexecResult : currentSheaf is NULL\n" );
    assertion( equals( currentSheaf->whereFind, str ), "checkRegexecResult : currentSheaf->whereFind not equals to str\n" );
    assertion( currentSheaf->nmatch == nmatch, "checkRegexecResult : currentSheaf->nmatch not equals to nmatch\n" );
    assertion( currentSheaf->eflags == eflags, "checkRegexecResult : currentSheaf->eflags not equals to eflags\n" );
    traceReqIdsForFunc( currentSheaf->reqIds, "regexec" );
    return equals( currentSheaf->pmatch, pmatch ) && currentSheaf->regexecRes == regexecRes;
}
