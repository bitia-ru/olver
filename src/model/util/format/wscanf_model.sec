/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "util/format/scanf_model.seh"
#include "data/stdio_model.seh"
#include "util/format/wscanf_model.seh"
#include "common/common_media.seh"
#include "util/format/wscanf_config.h"

#pragma SEC subsystem format "util.format"

/*
   The group of functions 'util.format.wscanf' consists of:
       fwscanf [2]
       swscanf [2]
       wscanf [2]
       vfwscanf [1]
       vswscanf [1]
       vwscanf [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fwscanf, swscanf, wscanf - convert formatted wide-character input

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    int fwscanf(FILE *restrict stream, const wchar_t *restrict format, ... );
    int swscanf(const wchar_t *restrict ws,
    const wchar_t *restrict format, ... );
    int wscanf(const wchar_t *restrict format, ... );

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fwscanf() function shall read from the named input stream. The wscanf()
    function shall read from the standard input stream stdin. The swscanf()
    function shall read from the wide-character string ws. Each function reads
    wide characters, interprets them according to a format, and stores the
    results in its arguments. Each expects, as arguments, a control
    wide-character string format described below, and a set of pointer arguments
    indicating where the converted input should be stored. The result is
    undefined if there are insufficient arguments for the format. If the format
    is exhausted while arguments remain, the excess arguments are evaluated but
    are otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier wide character % (see below) is replaced by the
    sequence "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}].
    This feature provides for the definition of format wide-character strings
    that select arguments in an order appropriate to specific languages. In
    format wide-character strings containing the "%n$" form of conversion
    specifications, it is unspecified whether numbered arguments in the argument
    list can be referenced from the format wide-character string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"- but the two forms cannot normally be mixed within a single format
    wide-character string. The only exception to this is that %% or %* can be
    mixed with the "%n$" form. When numbered argument specifications are used,
    specifying the Nth argument requires that all the leading arguments, from
    the first to the ( N-1 )th, are pointers.

    The fwscanf() function in all its forms allows for detection of a
    language-dependent radix character in the input string, encoded as a
    wide-character value. The radix character is defined in the program's locale
    (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
    character is not defined, the radix character shall default to a period
    ( '.' ).

    The format is a wide-character string composed of zero or more directives.
    Each directive is composed of one of the following: one or more white-space
    wide characters ( <space>s, <tab>s, <newline>s, <vertical-tab>s, or
    <form-feed>s); an ordinary wide character (neither '%' nor a white-space
    character); or a conversion specification. Each conversion specification is
    introduced by a '%' or the sequence "%n$" after which the following appear
    in sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An optional length modifier that specifies the size of the receiving
          object.

        * A conversion specifier wide character that specifies the type of
          conversion to be applied. The valid conversion specifiers are
          described below.

    The fwscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space wide characters is executed
    by reading input until no more valid input can be read, or up to the first
    wide character which is not a white-space wide character, which remains
    unread.

    A directive that is an ordinary wide character shall be executed as follows.
    The next wide character is read from the input and compared with the wide
    character that comprises the directive; if the comparison shows that they
    are not equivalent, the directive shall fail, and the differing and
    subsequent wide characters remain unread. Similarly, if end-of-file, an
    encoding error, or a read error prevents a wide character from being read,
    the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion wide character. A
    conversion specification is executed in the following steps.

    Input white-space wide characters (as specified by iswspace()) shall be
    skipped, unless the conversion specification includes a [, c, or n
    conversion specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier wide character. An input item is defined
    as the longest sequence of input wide characters, not exceeding any
    specified field width, which is an initial subsequence of a matching
    sequence. The first wide character, if any, after the input item shall
    remain unread. If the length of the input item is zero, the execution of the
    conversion specification shall fail; this condition is a matching failure,
    unless end-of-file, an encoding error, or a read error prevented input from
    the stream, in which case it is an input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input wide characters)
    shall be converted to a type appropriate to the conversion wide character.
    If the input item is not a matching sequence, the execution of the
    conversion specification shall fail; this condition is a matching failure.
    Unless assignment suppression was indicated by a '*', the result of the
    conversion shall be placed in the object pointed to by the first argument
    following the format argument that has not already received a conversion
    result if the conversion specification is introduced by %, or in the nth
    argument if introduced by the wide-character sequence "%n$". If this object
    does not have an appropriate type, or if the result of the conversion cannot
    be represented in the space provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifier wide characters are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of wcstol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of wcstoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of wcstoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN
        whose format is the same as expected for the subject sequence of
        wcstod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fwprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fwscanf()
        family of functions shall recognize them as input.
    s
        Matches a sequence of non white-space wide characters. If no l (ell)
        qualifier is present, characters from the input field shall be converted
        as if by repeated calls to the wcrtomb() function, with the conversion
        state described by an mbstate_t object initialized to zero before the
        first wide character is converted. The application shall ensure that the
        corresponding argument is a pointer to a character array large enough to
        accept the sequence and the terminating null character, which shall be
        added automatically.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence
        and the terminating null wide character, which shall be added
        automatically.
    [
        Matches a non-empty sequence of wide characters from a set of expected
        wide characters (the wscanset). If no l (ell) qualifier is present, wide
        characters from the input field shall be converted as if by repeated
        calls to the wcrtomb() function, with the conversion state described by
        an mbstate_t object initialized to zero before the first wide character
        is converted. The application shall ensure that the corresponding
        argument is a pointer to a character array large enough to accept the
        sequence and the terminating null character, which shall be added
        automatically.

        If an l (ell) qualifier is present, the application shall ensure that
        the corresponding argument is a pointer to an array of wchar_t large
        enough to accept the sequence and the terminating null wide character,
        which shall be added automatically.

        The conversion specification includes all subsequent wide characters in
        the format string up to and including the matching right square bracket
        ( ']' ). The wide characters between the square brackets (the wscanlist)
        comprise the scanset, unless the wide character after the left square
        bracket is a circumflex ( '^' ), in which case the wscanset contains all
        wide characters that do not appear in the wscanlist between the
        circumflex and the right square bracket. If the conversion specification
        begins with "[]" or "[^]", the right square bracket is included in the
        wscanlist and the next right square bracket is the matching right square
        bracket that ends the conversion specification; otherwise, the first
        right square bracket is the one that ends the conversion specification.
        If a '-' is in the wscanlist and is not the first wide character, nor
        the second where the first wide character is a '^', nor the last wide
        character, the behavior is implementation-defined.
    c
        Matches a sequence of wide characters of exactly the number specified by
        the field width (1 if no field width is present in the conversion
        specification).

        If no l (ell) length modifier is present, characters from the input
        field shall be converted as if by repeated calls to the wcrtomb()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first wide character is converted. The
        corresponding argument shall be a pointer to the initial element of a
        character array large enough to accept the sequence. No null character
        is added.

        If an l (ell) length modifier is present, the corresponding argument
        shall be a pointer to the initial element of an array of wchar_t large
        enough to accept the sequence. No null wide character is added.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence.
        No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fwprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which is to be
        written the number of wide characters read from the input so far by this
        call to the fwscanf() functions. Execution of a %n conversion
        specification shall not increment the assignment count returned at the
        completion of execution of the function. No argument shall be converted,
        but one shall be consumed. If the conversion specification includes an
        assignment-suppressing wide character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' wide character; no conversion or assignment shall
        occur. The complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to, respectively, a, e, f, g, and x.

    If end-of-file is encountered during input, conversion is terminated. If
    end-of-file occurs before any wide characters matching the current
    conversion specification (except for %n ) have been read (other than leading
    white-space, where permitted), execution of the current conversion
    specification shall terminate with an input failure. Otherwise, unless
    execution of the current conversion specification is terminated with a
    matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in swscanf() shall be equivalent to
    encountering end-of-file for fwscanf().

    If conversion terminates on a conflicting input, the offending input shall
    be left unread in the input. Any trailing white space (including <newline>)
    shall be left unread unless matched by a conversion specification. The
    success of literal matches and suppressed assignments is only directly
    determinable via the %n conversion specification.

    The fwscanf() and wscanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgetwc(), fgets(),
    fgetws(), fread(), getc(), getwc(), getchar(), getwchar(), gets(),
    fwscanf(), or fwscanf() using stream that returns data not supplied by a
    prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fwscanf() functions shall fail and may
    fail, refer to fgetwc().

    In addition, fwscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT fwscanf_spec( CallContext context, FILETPtr * stream, WString * format, List /* NULL */ * arguments,
                   ErrorCode * errno, CString * fileForStreamName
                 )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for wscanf group] */
        REQ( "", "Common preconditions for wscanf group", checkWscanfPreconditions( "fwscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        WString * input = fwreadFile( context, stream, fileForStreamName, create_CString( "r" ) );

        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FWSCANF, "fwscanf.05.02;fwscanf.05.03", fwscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fwscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_FWSCANF, EILSEQ, "fwscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fwscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_FWSCANF, EINVAL, "fwscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkWscanfResult( "fwscanf", format, arguments, fwscanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fwscanf, swscanf, wscanf - convert formatted wide-character input

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    int fwscanf(FILE *restrict stream, const wchar_t *restrict format, ... );
    int swscanf(const wchar_t *restrict ws,
    const wchar_t *restrict format, ... );
    int wscanf(const wchar_t *restrict format, ... );

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fwscanf() function shall read from the named input stream. The wscanf()
    function shall read from the standard input stream stdin. The swscanf()
    function shall read from the wide-character string ws. Each function reads
    wide characters, interprets them according to a format, and stores the
    results in its arguments. Each expects, as arguments, a control
    wide-character string format described below, and a set of pointer arguments
    indicating where the converted input should be stored. The result is
    undefined if there are insufficient arguments for the format. If the format
    is exhausted while arguments remain, the excess arguments are evaluated but
    are otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier wide character % (see below) is replaced by the
    sequence "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}].
    This feature provides for the definition of format wide-character strings
    that select arguments in an order appropriate to specific languages. In
    format wide-character strings containing the "%n$" form of conversion
    specifications, it is unspecified whether numbered arguments in the argument
    list can be referenced from the format wide-character string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"- but the two forms cannot normally be mixed within a single format
    wide-character string. The only exception to this is that %% or %* can be
    mixed with the "%n$" form. When numbered argument specifications are used,
    specifying the Nth argument requires that all the leading arguments, from
    the first to the ( N-1 )th, are pointers.

    The fwscanf() function in all its forms allows for detection of a
    language-dependent radix character in the input string, encoded as a
    wide-character value. The radix character is defined in the program's locale
    (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
    character is not defined, the radix character shall default to a period
    ( '.' ).

    The format is a wide-character string composed of zero or more directives.
    Each directive is composed of one of the following: one or more white-space
    wide characters ( <space>s, <tab>s, <newline>s, <vertical-tab>s, or
    <form-feed>s); an ordinary wide character (neither '%' nor a white-space
    character); or a conversion specification. Each conversion specification is
    introduced by a '%' or the sequence "%n$" after which the following appear
    in sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An optional length modifier that specifies the size of the receiving
          object.

        * A conversion specifier wide character that specifies the type of
          conversion to be applied. The valid conversion specifiers are
          described below.

    The fwscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space wide characters is executed
    by reading input until no more valid input can be read, or up to the first
    wide character which is not a white-space wide character, which remains
    unread.

    A directive that is an ordinary wide character shall be executed as follows.
    The next wide character is read from the input and compared with the wide
    character that comprises the directive; if the comparison shows that they
    are not equivalent, the directive shall fail, and the differing and
    subsequent wide characters remain unread. Similarly, if end-of-file, an
    encoding error, or a read error prevents a wide character from being read,
    the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion wide character. A
    conversion specification is executed in the following steps.

    Input white-space wide characters (as specified by iswspace()) shall be
    skipped, unless the conversion specification includes a [, c, or n
    conversion specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier wide character. An input item is defined
    as the longest sequence of input wide characters, not exceeding any
    specified field width, which is an initial subsequence of a matching
    sequence. The first wide character, if any, after the input item shall
    remain unread. If the length of the input item is zero, the execution of the
    conversion specification shall fail; this condition is a matching failure,
    unless end-of-file, an encoding error, or a read error prevented input from
    the stream, in which case it is an input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input wide characters)
    shall be converted to a type appropriate to the conversion wide character.
    If the input item is not a matching sequence, the execution of the
    conversion specification shall fail; this condition is a matching failure.
    Unless assignment suppression was indicated by a '*', the result of the
    conversion shall be placed in the object pointed to by the first argument
    following the format argument that has not already received a conversion
    result if the conversion specification is introduced by %, or in the nth
    argument if introduced by the wide-character sequence "%n$". If this object
    does not have an appropriate type, or if the result of the conversion cannot
    be represented in the space provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifier wide characters are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of wcstol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of wcstoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of wcstoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN
        whose format is the same as expected for the subject sequence of
        wcstod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fwprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fwscanf()
        family of functions shall recognize them as input.
    s
        Matches a sequence of non white-space wide characters. If no l (ell)
        qualifier is present, characters from the input field shall be converted
        as if by repeated calls to the wcrtomb() function, with the conversion
        state described by an mbstate_t object initialized to zero before the
        first wide character is converted. The application shall ensure that the
        corresponding argument is a pointer to a character array large enough to
        accept the sequence and the terminating null character, which shall be
        added automatically.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence
        and the terminating null wide character, which shall be added
        automatically.
    [
        Matches a non-empty sequence of wide characters from a set of expected
        wide characters (the wscanset). If no l (ell) qualifier is present, wide
        characters from the input field shall be converted as if by repeated
        calls to the wcrtomb() function, with the conversion state described by
        an mbstate_t object initialized to zero before the first wide character
        is converted. The application shall ensure that the corresponding
        argument is a pointer to a character array large enough to accept the
        sequence and the terminating null character, which shall be added
        automatically.

        If an l (ell) qualifier is present, the application shall ensure that
        the corresponding argument is a pointer to an array of wchar_t large
        enough to accept the sequence and the terminating null wide character,
        which shall be added automatically.

        The conversion specification includes all subsequent wide characters in
        the format string up to and including the matching right square bracket
        ( ']' ). The wide characters between the square brackets (the wscanlist)
        comprise the scanset, unless the wide character after the left square
        bracket is a circumflex ( '^' ), in which case the wscanset contains all
        wide characters that do not appear in the wscanlist between the
        circumflex and the right square bracket. If the conversion specification
        begins with "[]" or "[^]", the right square bracket is included in the
        wscanlist and the next right square bracket is the matching right square
        bracket that ends the conversion specification; otherwise, the first
        right square bracket is the one that ends the conversion specification.
        If a '-' is in the wscanlist and is not the first wide character, nor
        the second where the first wide character is a '^', nor the last wide
        character, the behavior is implementation-defined.
    c
        Matches a sequence of wide characters of exactly the number specified by
        the field width (1 if no field width is present in the conversion
        specification).

        If no l (ell) length modifier is present, characters from the input
        field shall be converted as if by repeated calls to the wcrtomb()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first wide character is converted. The
        corresponding argument shall be a pointer to the initial element of a
        character array large enough to accept the sequence. No null character
        is added.

        If an l (ell) length modifier is present, the corresponding argument
        shall be a pointer to the initial element of an array of wchar_t large
        enough to accept the sequence. No null wide character is added.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence.
        No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fwprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which is to be
        written the number of wide characters read from the input so far by this
        call to the fwscanf() functions. Execution of a %n conversion
        specification shall not increment the assignment count returned at the
        completion of execution of the function. No argument shall be converted,
        but one shall be consumed. If the conversion specification includes an
        assignment-suppressing wide character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' wide character; no conversion or assignment shall
        occur. The complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to, respectively, a, e, f, g, and x.

    If end-of-file is encountered during input, conversion is terminated. If
    end-of-file occurs before any wide characters matching the current
    conversion specification (except for %n ) have been read (other than leading
    white-space, where permitted), execution of the current conversion
    specification shall terminate with an input failure. Otherwise, unless
    execution of the current conversion specification is terminated with a
    matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in swscanf() shall be equivalent to
    encountering end-of-file for fwscanf().

    If conversion terminates on a conflicting input, the offending input shall
    be left unread in the input. Any trailing white space (including <newline>)
    shall be left unread unless matched by a conversion specification. The
    success of literal matches and suppressed assignments is only directly
    determinable via the %n conversion specification.

    The fwscanf() and wscanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgetwc(), fgets(),
    fgetws(), fread(), getc(), getwc(), getchar(), getwchar(), gets(),
    fwscanf(), or fwscanf() using stream that returns data not supplied by a
    prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fwscanf() functions shall fail and may
    fail, refer to fgetwc().

    In addition, fwscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT swscanf_spec( CallContext context, WString * s, WString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for wscanf group] */
        REQ( "", "Common preconditions for wscanf group", checkWscanfPreconditions( "swscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SWSCANF, "swscanf.05.02;swscanf.05.03", swscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fwscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_SWSCANF, EILSEQ, "swscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fwscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_SWSCANF, EINVAL, "swscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkWscanfResult( "swscanf", format, arguments, swscanf_spec, s, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfwscanf, vswscanf, vwscanf - wide-character formatted input of a stdarg
    argument list


SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>
    #include <wchar.h>

    int vfwscanf(FILE *restrict stream, const wchar_t *restrict format,
           va_list arg);
    int vswscanf(const wchar_t *restrict ws, const wchar_t *restrict format,
           va_list arg);
    int vwscanf(const wchar_t *restrict format, va_list arg);

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The vfwscanf(), vswscanf(), and vwscanf() functions shall be equivalent to
    the fwscanf(), swscanf(), and wscanf() functions, respectively, except that
    instead of being called with a variable number of arguments, they are called
    with an argument list as defined in the <stdarg.h> header. These functions
    shall not invoke the va_end macro. As these functions invoke the va_arg
    macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fwscanf() function shall read from the named input stream. The wscanf()
    function shall read from the standard input stream stdin. The swscanf()
    function shall read from the wide-character string ws. Each function reads
    wide characters, interprets them according to a format, and stores the
    results in its arguments. Each expects, as arguments, a control
    wide-character string format described below, and a set of pointer arguments
    indicating where the converted input should be stored. The result is
    undefined if there are insufficient arguments for the format. If the format
    is exhausted while arguments remain, the excess arguments are evaluated but
    are otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier wide character % (see below) is replaced by the
    sequence "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}].
    This feature provides for the definition of format wide-character strings
    that select arguments in an order appropriate to specific languages. In
    format wide-character strings containing the "%n$" form of conversion
    specifications, it is unspecified whether numbered arguments in the argument
    list can be referenced from the format wide-character string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"- but the two forms cannot normally be mixed within a single format
    wide-character string. The only exception to this is that %% or %* can be
    mixed with the "%n$" form. When numbered argument specifications are used,
    specifying the Nth argument requires that all the leading arguments, from
    the first to the ( N-1 )th, are pointers.

    The fwscanf() function in all its forms allows for detection of a
    language-dependent radix character in the input string, encoded as a
    wide-character value. The radix character is defined in the program's locale
    (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
    character is not defined, the radix character shall default to a period
    ( '.' ).

    The format is a wide-character string composed of zero or more directives.
    Each directive is composed of one of the following: one or more white-space
    wide characters ( <space>s, <tab>s, <newline>s, <vertical-tab>s, or
    <form-feed>s); an ordinary wide character (neither '%' nor a white-space
    character); or a conversion specification. Each conversion specification is
    introduced by a '%' or the sequence "%n$" after which the following appear
    in sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An optional length modifier that specifies the size of the receiving
          object.

        * A conversion specifier wide character that specifies the type of
          conversion to be applied. The valid conversion specifiers are
          described below.

    The fwscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space wide characters is executed
    by reading input until no more valid input can be read, or up to the first
    wide character which is not a white-space wide character, which remains
    unread.

    A directive that is an ordinary wide character shall be executed as follows.
    The next wide character is read from the input and compared with the wide
    character that comprises the directive; if the comparison shows that they
    are not equivalent, the directive shall fail, and the differing and
    subsequent wide characters remain unread. Similarly, if end-of-file, an
    encoding error, or a read error prevents a wide character from being read,
    the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion wide character. A
    conversion specification is executed in the following steps.

    Input white-space wide characters (as specified by iswspace()) shall be
    skipped, unless the conversion specification includes a [, c, or n
    conversion specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier wide character. An input item is defined
    as the longest sequence of input wide characters, not exceeding any
    specified field width, which is an initial subsequence of a matching
    sequence. The first wide character, if any, after the input item shall
    remain unread. If the length of the input item is zero, the execution of the
    conversion specification shall fail; this condition is a matching failure,
    unless end-of-file, an encoding error, or a read error prevented input from
    the stream, in which case it is an input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input wide characters)
    shall be converted to a type appropriate to the conversion wide character.
    If the input item is not a matching sequence, the execution of the
    conversion specification shall fail; this condition is a matching failure.
    Unless assignment suppression was indicated by a '*', the result of the
    conversion shall be placed in the object pointed to by the first argument
    following the format argument that has not already received a conversion
    result if the conversion specification is introduced by %, or in the nth
    argument if introduced by the wide-character sequence "%n$". If this object
    does not have an appropriate type, or if the result of the conversion cannot
    be represented in the space provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifier wide characters are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of wcstol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of wcstoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of wcstoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN
        whose format is the same as expected for the subject sequence of
        wcstod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fwprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fwscanf()
        family of functions shall recognize them as input.
    s
        Matches a sequence of non white-space wide characters. If no l (ell)
        qualifier is present, characters from the input field shall be converted
        as if by repeated calls to the wcrtomb() function, with the conversion
        state described by an mbstate_t object initialized to zero before the
        first wide character is converted. The application shall ensure that the
        corresponding argument is a pointer to a character array large enough to
        accept the sequence and the terminating null character, which shall be
        added automatically.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence
        and the terminating null wide character, which shall be added
        automatically.
    [
        Matches a non-empty sequence of wide characters from a set of expected
        wide characters (the wscanset). If no l (ell) qualifier is present, wide
        characters from the input field shall be converted as if by repeated
        calls to the wcrtomb() function, with the conversion state described by
        an mbstate_t object initialized to zero before the first wide character
        is converted. The application shall ensure that the corresponding
        argument is a pointer to a character array large enough to accept the
        sequence and the terminating null character, which shall be added
        automatically.

        If an l (ell) qualifier is present, the application shall ensure that
        the corresponding argument is a pointer to an array of wchar_t large
        enough to accept the sequence and the terminating null wide character,
        which shall be added automatically.

        The conversion specification includes all subsequent wide characters in
        the format string up to and including the matching right square bracket
        ( ']' ). The wide characters between the square brackets (the wscanlist)
        comprise the scanset, unless the wide character after the left square
        bracket is a circumflex ( '^' ), in which case the wscanset contains all
        wide characters that do not appear in the wscanlist between the
        circumflex and the right square bracket. If the conversion specification
        begins with "[]" or "[^]", the right square bracket is included in the
        wscanlist and the next right square bracket is the matching right square
        bracket that ends the conversion specification; otherwise, the first
        right square bracket is the one that ends the conversion specification.
        If a '-' is in the wscanlist and is not the first wide character, nor
        the second where the first wide character is a '^', nor the last wide
        character, the behavior is implementation-defined.
    c
        Matches a sequence of wide characters of exactly the number specified by
        the field width (1 if no field width is present in the conversion
        specification).

        If no l (ell) length modifier is present, characters from the input
        field shall be converted as if by repeated calls to the wcrtomb()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first wide character is converted. The
        corresponding argument shall be a pointer to the initial element of a
        character array large enough to accept the sequence. No null character
        is added.

        If an l (ell) length modifier is present, the corresponding argument
        shall be a pointer to the initial element of an array of wchar_t large
        enough to accept the sequence. No null wide character is added.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence.
        No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fwprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which is to be
        written the number of wide characters read from the input so far by this
        call to the fwscanf() functions. Execution of a %n conversion
        specification shall not increment the assignment count returned at the
        completion of execution of the function. No argument shall be converted,
        but one shall be consumed. If the conversion specification includes an
        assignment-suppressing wide character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' wide character; no conversion or assignment shall
        occur. The complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to, respectively, a, e, f, g, and x.

    If end-of-file is encountered during input, conversion is terminated. If
    end-of-file occurs before any wide characters matching the current
    conversion specification (except for %n ) have been read (other than leading
    white-space, where permitted), execution of the current conversion
    specification shall terminate with an input failure. Otherwise, unless
    execution of the current conversion specification is terminated with a
    matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in swscanf() shall be equivalent to
    encountering end-of-file for fwscanf().

    If conversion terminates on a conflicting input, the offending input shall
    be left unread in the input. Any trailing white space (including <newline>)
    shall be left unread unless matched by a conversion specification. The
    success of literal matches and suppressed assignments is only directly
    determinable via the %n conversion specification.

    The fwscanf() and wscanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgetwc(), fgets(),
    fgetws(), fread(), getc(), getwc(), getchar(), getwchar(), gets(),
    fwscanf(), or fwscanf() using stream that returns data not supplied by a
    prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fwscanf() functions shall fail and may
    fail, refer to fgetwc().

    In addition, fwscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT vfwscanf_spec( CallContext context, FILETPtr * stream, WString * format, List /* NULL */ * arguments,
                    ErrorCode * errno, CString * fileForStreamName
                  )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for wscanf group] */
        REQ( "", "Common preconditions for wscanf group", checkWscanfPreconditions( "vfwscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        WString * input = fwreadFile( context, stream, fileForStreamName, create_CString( "r" ) );

        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_VFWSCANF, "vfwscanf.05.02;vfwscanf.05.03", vfwscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fwscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_VFWSCANF, EILSEQ, "vfwscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fwscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_VFWSCANF, EINVAL, "vfwscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkWscanfResult( "vfwscanf", format, arguments, vfwscanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfwscanf, vswscanf, vwscanf - wide-character formatted input of a stdarg
    argument list


SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>
    #include <wchar.h>

    int vfwscanf(FILE *restrict stream, const wchar_t *restrict format,
           va_list arg);
    int vswscanf(const wchar_t *restrict ws, const wchar_t *restrict format,
           va_list arg);
    int vwscanf(const wchar_t *restrict format, va_list arg);

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The vfwscanf(), vswscanf(), and vwscanf() functions shall be equivalent to
    the fwscanf(), swscanf(), and wscanf() functions, respectively, except that
    instead of being called with a variable number of arguments, they are called
    with an argument list as defined in the <stdarg.h> header. These functions
    shall not invoke the va_end macro. As these functions invoke the va_arg
    macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fwscanf() function shall read from the named input stream. The wscanf()
    function shall read from the standard input stream stdin. The swscanf()
    function shall read from the wide-character string ws. Each function reads
    wide characters, interprets them according to a format, and stores the
    results in its arguments. Each expects, as arguments, a control
    wide-character string format described below, and a set of pointer arguments
    indicating where the converted input should be stored. The result is
    undefined if there are insufficient arguments for the format. If the format
    is exhausted while arguments remain, the excess arguments are evaluated but
    are otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier wide character % (see below) is replaced by the
    sequence "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}].
    This feature provides for the definition of format wide-character strings
    that select arguments in an order appropriate to specific languages. In
    format wide-character strings containing the "%n$" form of conversion
    specifications, it is unspecified whether numbered arguments in the argument
    list can be referenced from the format wide-character string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"- but the two forms cannot normally be mixed within a single format
    wide-character string. The only exception to this is that %% or %* can be
    mixed with the "%n$" form. When numbered argument specifications are used,
    specifying the Nth argument requires that all the leading arguments, from
    the first to the ( N-1 )th, are pointers.

    The fwscanf() function in all its forms allows for detection of a
    language-dependent radix character in the input string, encoded as a
    wide-character value. The radix character is defined in the program's locale
    (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
    character is not defined, the radix character shall default to a period
    ( '.' ).

    The format is a wide-character string composed of zero or more directives.
    Each directive is composed of one of the following: one or more white-space
    wide characters ( <space>s, <tab>s, <newline>s, <vertical-tab>s, or
    <form-feed>s); an ordinary wide character (neither '%' nor a white-space
    character); or a conversion specification. Each conversion specification is
    introduced by a '%' or the sequence "%n$" after which the following appear
    in sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An optional length modifier that specifies the size of the receiving
          object.

        * A conversion specifier wide character that specifies the type of
          conversion to be applied. The valid conversion specifiers are
          described below.

    The fwscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space wide characters is executed
    by reading input until no more valid input can be read, or up to the first
    wide character which is not a white-space wide character, which remains
    unread.

    A directive that is an ordinary wide character shall be executed as follows.
    The next wide character is read from the input and compared with the wide
    character that comprises the directive; if the comparison shows that they
    are not equivalent, the directive shall fail, and the differing and
    subsequent wide characters remain unread. Similarly, if end-of-file, an
    encoding error, or a read error prevents a wide character from being read,
    the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion wide character. A
    conversion specification is executed in the following steps.

    Input white-space wide characters (as specified by iswspace()) shall be
    skipped, unless the conversion specification includes a [, c, or n
    conversion specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier wide character. An input item is defined
    as the longest sequence of input wide characters, not exceeding any
    specified field width, which is an initial subsequence of a matching
    sequence. The first wide character, if any, after the input item shall
    remain unread. If the length of the input item is zero, the execution of the
    conversion specification shall fail; this condition is a matching failure,
    unless end-of-file, an encoding error, or a read error prevented input from
    the stream, in which case it is an input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input wide characters)
    shall be converted to a type appropriate to the conversion wide character.
    If the input item is not a matching sequence, the execution of the
    conversion specification shall fail; this condition is a matching failure.
    Unless assignment suppression was indicated by a '*', the result of the
    conversion shall be placed in the object pointed to by the first argument
    following the format argument that has not already received a conversion
    result if the conversion specification is introduced by %, or in the nth
    argument if introduced by the wide-character sequence "%n$". If this object
    does not have an appropriate type, or if the result of the conversion cannot
    be represented in the space provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifier wide characters are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of wcstol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of wcstoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of wcstoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN
        whose format is the same as expected for the subject sequence of
        wcstod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fwprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fwscanf()
        family of functions shall recognize them as input.
    s
        Matches a sequence of non white-space wide characters. If no l (ell)
        qualifier is present, characters from the input field shall be converted
        as if by repeated calls to the wcrtomb() function, with the conversion
        state described by an mbstate_t object initialized to zero before the
        first wide character is converted. The application shall ensure that the
        corresponding argument is a pointer to a character array large enough to
        accept the sequence and the terminating null character, which shall be
        added automatically.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence
        and the terminating null wide character, which shall be added
        automatically.
    [
        Matches a non-empty sequence of wide characters from a set of expected
        wide characters (the wscanset). If no l (ell) qualifier is present, wide
        characters from the input field shall be converted as if by repeated
        calls to the wcrtomb() function, with the conversion state described by
        an mbstate_t object initialized to zero before the first wide character
        is converted. The application shall ensure that the corresponding
        argument is a pointer to a character array large enough to accept the
        sequence and the terminating null character, which shall be added
        automatically.

        If an l (ell) qualifier is present, the application shall ensure that
        the corresponding argument is a pointer to an array of wchar_t large
        enough to accept the sequence and the terminating null wide character,
        which shall be added automatically.

        The conversion specification includes all subsequent wide characters in
        the format string up to and including the matching right square bracket
        ( ']' ). The wide characters between the square brackets (the wscanlist)
        comprise the scanset, unless the wide character after the left square
        bracket is a circumflex ( '^' ), in which case the wscanset contains all
        wide characters that do not appear in the wscanlist between the
        circumflex and the right square bracket. If the conversion specification
        begins with "[]" or "[^]", the right square bracket is included in the
        wscanlist and the next right square bracket is the matching right square
        bracket that ends the conversion specification; otherwise, the first
        right square bracket is the one that ends the conversion specification.
        If a '-' is in the wscanlist and is not the first wide character, nor
        the second where the first wide character is a '^', nor the last wide
        character, the behavior is implementation-defined.
    c
        Matches a sequence of wide characters of exactly the number specified by
        the field width (1 if no field width is present in the conversion
        specification).

        If no l (ell) length modifier is present, characters from the input
        field shall be converted as if by repeated calls to the wcrtomb()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first wide character is converted. The
        corresponding argument shall be a pointer to the initial element of a
        character array large enough to accept the sequence. No null character
        is added.

        If an l (ell) length modifier is present, the corresponding argument
        shall be a pointer to the initial element of an array of wchar_t large
        enough to accept the sequence. No null wide character is added.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence.
        No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fwprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which is to be
        written the number of wide characters read from the input so far by this
        call to the fwscanf() functions. Execution of a %n conversion
        specification shall not increment the assignment count returned at the
        completion of execution of the function. No argument shall be converted,
        but one shall be consumed. If the conversion specification includes an
        assignment-suppressing wide character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' wide character; no conversion or assignment shall
        occur. The complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to, respectively, a, e, f, g, and x.

    If end-of-file is encountered during input, conversion is terminated. If
    end-of-file occurs before any wide characters matching the current
    conversion specification (except for %n ) have been read (other than leading
    white-space, where permitted), execution of the current conversion
    specification shall terminate with an input failure. Otherwise, unless
    execution of the current conversion specification is terminated with a
    matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in swscanf() shall be equivalent to
    encountering end-of-file for fwscanf().

    If conversion terminates on a conflicting input, the offending input shall
    be left unread in the input. Any trailing white space (including <newline>)
    shall be left unread unless matched by a conversion specification. The
    success of literal matches and suppressed assignments is only directly
    determinable via the %n conversion specification.

    The fwscanf() and wscanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgetwc(), fgets(),
    fgetws(), fread(), getc(), getwc(), getchar(), getwchar(), gets(),
    fwscanf(), or fwscanf() using stream that returns data not supplied by a
    prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fwscanf() functions shall fail and may
    fail, refer to fgetwc().

    In addition, fwscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT vswscanf_spec( CallContext context, WString * s, WString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for wscanf group] */
        REQ( "", "Common preconditions for wscanf group", checkWscanfPreconditions( "vswscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_VSWSCANF, "vswscanf.05.02;vswscanf.05.03", vswscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fwscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_VSWSCANF, EILSEQ, "vswscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fwscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_VSWSCANF, EINVAL, "vswscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkWscanfResult( "vswscanf", format, arguments, vswscanf_spec, s, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfwscanf, vswscanf, vwscanf - wide-character formatted input of a stdarg
    argument list


SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>
    #include <wchar.h>

    int vfwscanf(FILE *restrict stream, const wchar_t *restrict format,
           va_list arg);
    int vswscanf(const wchar_t *restrict ws, const wchar_t *restrict format,
           va_list arg);
    int vwscanf(const wchar_t *restrict format, va_list arg);

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The vfwscanf(), vswscanf(), and vwscanf() functions shall be equivalent to
    the fwscanf(), swscanf(), and wscanf() functions, respectively, except that
    instead of being called with a variable number of arguments, they are called
    with an argument list as defined in the <stdarg.h> header. These functions
    shall not invoke the va_end macro. As these functions invoke the va_arg
    macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fwscanf() function shall read from the named input stream. The wscanf()
    function shall read from the standard input stream stdin. The swscanf()
    function shall read from the wide-character string ws. Each function reads
    wide characters, interprets them according to a format, and stores the
    results in its arguments. Each expects, as arguments, a control
    wide-character string format described below, and a set of pointer arguments
    indicating where the converted input should be stored. The result is
    undefined if there are insufficient arguments for the format. If the format
    is exhausted while arguments remain, the excess arguments are evaluated but
    are otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier wide character % (see below) is replaced by the
    sequence "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}].
    This feature provides for the definition of format wide-character strings
    that select arguments in an order appropriate to specific languages. In
    format wide-character strings containing the "%n$" form of conversion
    specifications, it is unspecified whether numbered arguments in the argument
    list can be referenced from the format wide-character string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"- but the two forms cannot normally be mixed within a single format
    wide-character string. The only exception to this is that %% or %* can be
    mixed with the "%n$" form. When numbered argument specifications are used,
    specifying the Nth argument requires that all the leading arguments, from
    the first to the ( N-1 )th, are pointers.

    The fwscanf() function in all its forms allows for detection of a
    language-dependent radix character in the input string, encoded as a
    wide-character value. The radix character is defined in the program's locale
    (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
    character is not defined, the radix character shall default to a period
    ( '.' ).

    The format is a wide-character string composed of zero or more directives.
    Each directive is composed of one of the following: one or more white-space
    wide characters ( <space>s, <tab>s, <newline>s, <vertical-tab>s, or
    <form-feed>s); an ordinary wide character (neither '%' nor a white-space
    character); or a conversion specification. Each conversion specification is
    introduced by a '%' or the sequence "%n$" after which the following appear
    in sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An optional length modifier that specifies the size of the receiving
          object.

        * A conversion specifier wide character that specifies the type of
          conversion to be applied. The valid conversion specifiers are
          described below.

    The fwscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space wide characters is executed
    by reading input until no more valid input can be read, or up to the first
    wide character which is not a white-space wide character, which remains
    unread.

    A directive that is an ordinary wide character shall be executed as follows.
    The next wide character is read from the input and compared with the wide
    character that comprises the directive; if the comparison shows that they
    are not equivalent, the directive shall fail, and the differing and
    subsequent wide characters remain unread. Similarly, if end-of-file, an
    encoding error, or a read error prevents a wide character from being read,
    the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion wide character. A
    conversion specification is executed in the following steps.

    Input white-space wide characters (as specified by iswspace()) shall be
    skipped, unless the conversion specification includes a [, c, or n
    conversion specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier wide character. An input item is defined
    as the longest sequence of input wide characters, not exceeding any
    specified field width, which is an initial subsequence of a matching
    sequence. The first wide character, if any, after the input item shall
    remain unread. If the length of the input item is zero, the execution of the
    conversion specification shall fail; this condition is a matching failure,
    unless end-of-file, an encoding error, or a read error prevented input from
    the stream, in which case it is an input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input wide characters)
    shall be converted to a type appropriate to the conversion wide character.
    If the input item is not a matching sequence, the execution of the
    conversion specification shall fail; this condition is a matching failure.
    Unless assignment suppression was indicated by a '*', the result of the
    conversion shall be placed in the object pointed to by the first argument
    following the format argument that has not already received a conversion
    result if the conversion specification is introduced by %, or in the nth
    argument if introduced by the wide-character sequence "%n$". If this object
    does not have an appropriate type, or if the result of the conversion cannot
    be represented in the space provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifier wide characters are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of wcstol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of wcstoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of wcstoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN
        whose format is the same as expected for the subject sequence of
        wcstod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fwprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fwscanf()
        family of functions shall recognize them as input.
    s
        Matches a sequence of non white-space wide characters. If no l (ell)
        qualifier is present, characters from the input field shall be converted
        as if by repeated calls to the wcrtomb() function, with the conversion
        state described by an mbstate_t object initialized to zero before the
        first wide character is converted. The application shall ensure that the
        corresponding argument is a pointer to a character array large enough to
        accept the sequence and the terminating null character, which shall be
        added automatically.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence
        and the terminating null wide character, which shall be added
        automatically.
    [
        Matches a non-empty sequence of wide characters from a set of expected
        wide characters (the wscanset). If no l (ell) qualifier is present, wide
        characters from the input field shall be converted as if by repeated
        calls to the wcrtomb() function, with the conversion state described by
        an mbstate_t object initialized to zero before the first wide character
        is converted. The application shall ensure that the corresponding
        argument is a pointer to a character array large enough to accept the
        sequence and the terminating null character, which shall be added
        automatically.

        If an l (ell) qualifier is present, the application shall ensure that
        the corresponding argument is a pointer to an array of wchar_t large
        enough to accept the sequence and the terminating null wide character,
        which shall be added automatically.

        The conversion specification includes all subsequent wide characters in
        the format string up to and including the matching right square bracket
        ( ']' ). The wide characters between the square brackets (the wscanlist)
        comprise the scanset, unless the wide character after the left square
        bracket is a circumflex ( '^' ), in which case the wscanset contains all
        wide characters that do not appear in the wscanlist between the
        circumflex and the right square bracket. If the conversion specification
        begins with "[]" or "[^]", the right square bracket is included in the
        wscanlist and the next right square bracket is the matching right square
        bracket that ends the conversion specification; otherwise, the first
        right square bracket is the one that ends the conversion specification.
        If a '-' is in the wscanlist and is not the first wide character, nor
        the second where the first wide character is a '^', nor the last wide
        character, the behavior is implementation-defined.
    c
        Matches a sequence of wide characters of exactly the number specified by
        the field width (1 if no field width is present in the conversion
        specification).

        If no l (ell) length modifier is present, characters from the input
        field shall be converted as if by repeated calls to the wcrtomb()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first wide character is converted. The
        corresponding argument shall be a pointer to the initial element of a
        character array large enough to accept the sequence. No null character
        is added.

        If an l (ell) length modifier is present, the corresponding argument
        shall be a pointer to the initial element of an array of wchar_t large
        enough to accept the sequence. No null wide character is added.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence.
        No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fwprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which is to be
        written the number of wide characters read from the input so far by this
        call to the fwscanf() functions. Execution of a %n conversion
        specification shall not increment the assignment count returned at the
        completion of execution of the function. No argument shall be converted,
        but one shall be consumed. If the conversion specification includes an
        assignment-suppressing wide character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' wide character; no conversion or assignment shall
        occur. The complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to, respectively, a, e, f, g, and x.

    If end-of-file is encountered during input, conversion is terminated. If
    end-of-file occurs before any wide characters matching the current
    conversion specification (except for %n ) have been read (other than leading
    white-space, where permitted), execution of the current conversion
    specification shall terminate with an input failure. Otherwise, unless
    execution of the current conversion specification is terminated with a
    matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in swscanf() shall be equivalent to
    encountering end-of-file for fwscanf().

    If conversion terminates on a conflicting input, the offending input shall
    be left unread in the input. Any trailing white space (including <newline>)
    shall be left unread unless matched by a conversion specification. The
    success of literal matches and suppressed assignments is only directly
    determinable via the %n conversion specification.

    The fwscanf() and wscanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgetwc(), fgets(),
    fgetws(), fread(), getc(), getwc(), getchar(), getwchar(), gets(),
    fwscanf(), or fwscanf() using stream that returns data not supplied by a
    prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fwscanf() functions shall fail and may
    fail, refer to fgetwc().

    In addition, fwscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT vwscanf_spec( CallContext context, WString * format, List /* NULL */ * arguments, WString * input, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for wscanf group] */
        REQ( "", "Common preconditions for wscanf group", checkWscanfPreconditions( "vwscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_VWSCANF, "vwscanf.05.02;vwscanf.05.03", vwscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fwscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_VWSCANF, EILSEQ, "vwscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fwscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_VWSCANF, EINVAL, "vwscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkWscanfResult( "vwscanf", format, arguments, vwscanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fwscanf, swscanf, wscanf - convert formatted wide-character input

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    int fwscanf(FILE *restrict stream, const wchar_t *restrict format, ... );
    int swscanf(const wchar_t *restrict ws,
    const wchar_t *restrict format, ... );
    int wscanf(const wchar_t *restrict format, ... );

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fwscanf() function shall read from the named input stream. The wscanf()
    function shall read from the standard input stream stdin. The swscanf()
    function shall read from the wide-character string ws. Each function reads
    wide characters, interprets them according to a format, and stores the
    results in its arguments. Each expects, as arguments, a control
    wide-character string format described below, and a set of pointer arguments
    indicating where the converted input should be stored. The result is
    undefined if there are insufficient arguments for the format. If the format
    is exhausted while arguments remain, the excess arguments are evaluated but
    are otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier wide character % (see below) is replaced by the
    sequence "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}].
    This feature provides for the definition of format wide-character strings
    that select arguments in an order appropriate to specific languages. In
    format wide-character strings containing the "%n$" form of conversion
    specifications, it is unspecified whether numbered arguments in the argument
    list can be referenced from the format wide-character string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"- but the two forms cannot normally be mixed within a single format
    wide-character string. The only exception to this is that %% or %* can be
    mixed with the "%n$" form. When numbered argument specifications are used,
    specifying the Nth argument requires that all the leading arguments, from
    the first to the ( N-1 )th, are pointers.

    The fwscanf() function in all its forms allows for detection of a
    language-dependent radix character in the input string, encoded as a
    wide-character value. The radix character is defined in the program's locale
    (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
    character is not defined, the radix character shall default to a period
    ( '.' ).

    The format is a wide-character string composed of zero or more directives.
    Each directive is composed of one of the following: one or more white-space
    wide characters ( <space>s, <tab>s, <newline>s, <vertical-tab>s, or
    <form-feed>s); an ordinary wide character (neither '%' nor a white-space
    character); or a conversion specification. Each conversion specification is
    introduced by a '%' or the sequence "%n$" after which the following appear
    in sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An optional length modifier that specifies the size of the receiving
          object.

        * A conversion specifier wide character that specifies the type of
          conversion to be applied. The valid conversion specifiers are
          described below.

    The fwscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space wide characters is executed
    by reading input until no more valid input can be read, or up to the first
    wide character which is not a white-space wide character, which remains
    unread.

    A directive that is an ordinary wide character shall be executed as follows.
    The next wide character is read from the input and compared with the wide
    character that comprises the directive; if the comparison shows that they
    are not equivalent, the directive shall fail, and the differing and
    subsequent wide characters remain unread. Similarly, if end-of-file, an
    encoding error, or a read error prevents a wide character from being read,
    the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion wide character. A
    conversion specification is executed in the following steps.

    Input white-space wide characters (as specified by iswspace()) shall be
    skipped, unless the conversion specification includes a [, c, or n
    conversion specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier wide character. An input item is defined
    as the longest sequence of input wide characters, not exceeding any
    specified field width, which is an initial subsequence of a matching
    sequence. The first wide character, if any, after the input item shall
    remain unread. If the length of the input item is zero, the execution of the
    conversion specification shall fail; this condition is a matching failure,
    unless end-of-file, an encoding error, or a read error prevented input from
    the stream, in which case it is an input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input wide characters)
    shall be converted to a type appropriate to the conversion wide character.
    If the input item is not a matching sequence, the execution of the
    conversion specification shall fail; this condition is a matching failure.
    Unless assignment suppression was indicated by a '*', the result of the
    conversion shall be placed in the object pointed to by the first argument
    following the format argument that has not already received a conversion
    result if the conversion specification is introduced by %, or in the nth
    argument if introduced by the wide-character sequence "%n$". If this object
    does not have an appropriate type, or if the result of the conversion cannot
    be represented in the space provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifier wide characters are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of wcstol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of wcstoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of wcstoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of wcstoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN
        whose format is the same as expected for the subject sequence of
        wcstod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fwprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fwscanf()
        family of functions shall recognize them as input.
    s
        Matches a sequence of non white-space wide characters. If no l (ell)
        qualifier is present, characters from the input field shall be converted
        as if by repeated calls to the wcrtomb() function, with the conversion
        state described by an mbstate_t object initialized to zero before the
        first wide character is converted. The application shall ensure that the
        corresponding argument is a pointer to a character array large enough to
        accept the sequence and the terminating null character, which shall be
        added automatically.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence
        and the terminating null wide character, which shall be added
        automatically.
    [
        Matches a non-empty sequence of wide characters from a set of expected
        wide characters (the wscanset). If no l (ell) qualifier is present, wide
        characters from the input field shall be converted as if by repeated
        calls to the wcrtomb() function, with the conversion state described by
        an mbstate_t object initialized to zero before the first wide character
        is converted. The application shall ensure that the corresponding
        argument is a pointer to a character array large enough to accept the
        sequence and the terminating null character, which shall be added
        automatically.

        If an l (ell) qualifier is present, the application shall ensure that
        the corresponding argument is a pointer to an array of wchar_t large
        enough to accept the sequence and the terminating null wide character,
        which shall be added automatically.

        The conversion specification includes all subsequent wide characters in
        the format string up to and including the matching right square bracket
        ( ']' ). The wide characters between the square brackets (the wscanlist)
        comprise the scanset, unless the wide character after the left square
        bracket is a circumflex ( '^' ), in which case the wscanset contains all
        wide characters that do not appear in the wscanlist between the
        circumflex and the right square bracket. If the conversion specification
        begins with "[]" or "[^]", the right square bracket is included in the
        wscanlist and the next right square bracket is the matching right square
        bracket that ends the conversion specification; otherwise, the first
        right square bracket is the one that ends the conversion specification.
        If a '-' is in the wscanlist and is not the first wide character, nor
        the second where the first wide character is a '^', nor the last wide
        character, the behavior is implementation-defined.
    c
        Matches a sequence of wide characters of exactly the number specified by
        the field width (1 if no field width is present in the conversion
        specification).

        If no l (ell) length modifier is present, characters from the input
        field shall be converted as if by repeated calls to the wcrtomb()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first wide character is converted. The
        corresponding argument shall be a pointer to the initial element of a
        character array large enough to accept the sequence. No null character
        is added.

        If an l (ell) length modifier is present, the corresponding argument
        shall be a pointer to the initial element of an array of wchar_t large
        enough to accept the sequence. No null wide character is added.

        Otherwise, the application shall ensure that the corresponding argument
        is a pointer to an array of wchar_t large enough to accept the sequence.
        No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fwprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which is to be
        written the number of wide characters read from the input so far by this
        call to the fwscanf() functions. Execution of a %n conversion
        specification shall not increment the assignment count returned at the
        completion of execution of the function. No argument shall be converted,
        but one shall be consumed. If the conversion specification includes an
        assignment-suppressing wide character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' wide character; no conversion or assignment shall
        occur. The complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to, respectively, a, e, f, g, and x.

    If end-of-file is encountered during input, conversion is terminated. If
    end-of-file occurs before any wide characters matching the current
    conversion specification (except for %n ) have been read (other than leading
    white-space, where permitted), execution of the current conversion
    specification shall terminate with an input failure. Otherwise, unless
    execution of the current conversion specification is terminated with a
    matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in swscanf() shall be equivalent to
    encountering end-of-file for fwscanf().

    If conversion terminates on a conflicting input, the offending input shall
    be left unread in the input. Any trailing white space (including <newline>)
    shall be left unread unless matched by a conversion specification. The
    success of literal matches and suppressed assignments is only directly
    determinable via the %n conversion specification.

    The fwscanf() and wscanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgetwc(), fgets(),
    fgetws(), fread(), getc(), getwc(), getchar(), getwchar(), gets(),
    fwscanf(), or fwscanf() using stream that returns data not supplied by a
    prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fwscanf() functions shall fail and may
    fail, refer to fgetwc().

    In addition, fwscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT wscanf_spec( CallContext context, WString * format, List /* NULL */ * arguments, WString * input, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for wscanf group] */
        REQ( "", "Common preconditions for wscanf group", checkWscanfPreconditions( "wscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_WSCANF, "wscanf.05.02;wscanf.05.03", wscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fwscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_WSCANF, EILSEQ, "wscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fwscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_WSCANF, EINVAL, "wscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkWscanfResult( "wscanf", format, arguments, wscanf_spec, input, errno ) );

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool checkWscanfPreconditions( char * funcName, WString * format, List /* NULL */ * arguments ) {
    String * reqPrefix = concat_String
                             ( create_String( "app." ), concat_String( create_String( funcName ), create_String( "." ) ) );
    String * commonReqPrefix = create_String( "app.all_wscan." );
    List /* String */ * preconditionsReqIds = create_List( & type_String );
    int i;
    append_List( preconditionsReqIds, create_String( "app.all_wscan.03"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_wscan.04"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_wscan.05"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_wscan.13.07" ) );
    append_List( preconditionsReqIds, create_String( "app.all_wscan.14"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_wscan.15.01" ) );
    append_List( preconditionsReqIds, create_String( "app.all_wscan.15.11" ) );
    for ( i = 0; i < size_List( preconditionsReqIds ); i++ ) {
        String * reqId = get_List( preconditionsReqIds, i );
        char * reqIdAsCharArray;
        // app.all_wscan.postfix +> app.funcName.postfix
        if ( startsWith_String( reqId, commonReqPrefix ) ) {
            reqId = clone( reqId );
            reqId = substringFrom_String( reqId, length_String( commonReqPrefix ) );
            reqId = concat_String( reqPrefix, reqId );
        }
        reqIdAsCharArray = (char *)toCharArray_String( reqId );
        if ( startsWith_String( reqId, reqPrefix ) ) { traceRequirements( reqIdAsCharArray ); }
    }
    return true;
}

bool checkWscanfResult( char * funcName, WString * format, List /* NULL */ * arguments,
                        IntT returnValue, WString * input, ErrorCode * errno
                      ){
    bool verdict = returnValue < 0 || checkExpectedResult( funcName, arguments, "all_wscan" );
    if ( ! verdict ) {
        List /* NULL */ * expectedArguments = getExpectedResult( funcName );
        String * expectedArgumentsAsString = toString_List( expectedArguments );
        String * argumentsAsString         = toString_List( arguments         );
        String * formatAsString            = toString     ( format            );
        String * inputAsString             = toString     ( input             );
        verbose( "checkWscanfResult\n"                                                                               );
        verbose( "checkWscanfResult : returned value    is [%ld]\n", returnValue                                     );
        verbose( "checkWscanfResult : expectedArguments is [%s]\n" , toCharArray_String( expectedArgumentsAsString ) );
        verbose( "checkWscanfResult : arguments         is [%s]\n" , toCharArray_String( argumentsAsString         ) );
        verbose( "checkWscanfResult : format            is [%s]\n" , toCharArray_String( formatAsString            ) );
        verbose( "checkWscanfResult : input             is [%s]\n" , toCharArray_String( inputAsString             ) );
        verbose( "checkWscanfResult : errno             is [%ld]\n", * errno                                         );
    }
    // "close" data
    clearExpectedResultAndReqIds( funcName );
    // assertion( verdict, "stop" ); // for debug purpose
    return verdict;
}
