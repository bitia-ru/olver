/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "data/stdio_model.seh"
#include "util/format/scanf_model.seh"
#include "common/common_media.seh"
#include "util/format/scanf_config.h"

#pragma SEC subsystem format "util.format"

/*
   The group of functions 'util.format.scanf' consists of:
       fscanf [2]
       scanf [2]
       sscanf [2]
       vfscanf [1]
       vscanf [1]
       vsscanf [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fscanf, scanf, sscanf - convert formatted input

SYNOPSIS

    #include <stdio.h>

    int fscanf(FILE *restrict stream, const char *restrict format, ... );
    int scanf(const char *restrict format, ... );
    int sscanf(const char *restrict s, const char *restrict format, ... );

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fscanf() function shall read from the named input stream. The scanf()
    function shall read from the standard input stream stdin. The sscanf()
    function shall read from the string s. Each function reads bytes, interprets
    them according to a format, and stores the results in its arguments. Each
    expects, as arguments, a control string format described below, and a set of
    pointer arguments indicating where the converted input should be stored. The
    result is undefined if there are insufficient arguments for the format. If
    the format is exhausted while arguments remain, the excess arguments shall
    be evaluated but otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This
    feature provides for the definition of format strings that select arguments
    in an order appropriate to specific languages. In format strings containing
    the "%n$" form of conversion specifications, it is unspecified whether
    numbered arguments in the argument list can be referenced from the format
    string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"-but the two forms cannot be mixed within a single format string.
    The only exception to this is that %% or %* can be mixed with the "%n$"
    form. When numbered argument specifications are used, specifying the Nth
    argument requires that all the leading arguments, from the first to the
    ( N-1 )th, are pointers.

    The fscanf() function in all its forms shall allow detection of a
    language-dependent radix character in the input string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    The format is a character string, beginning and ending in its initial shift
    state, if any, composed of zero or more directives. Each directive is
    composed of one of the following: one or more white-space characters (
    <space>s, <tab>s, <newline>s, <vertical-tab>s, or <form-feed>s); an ordinary
    character (neither '%' nor a white-space character); or a conversion
    specification. Each conversion specification is introduced by the character
    '%' or the character sequence "%n$", after which the following appear in
    sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An option length modifier that specifies the size of the receiving
          object.

        * A conversion specifier character that specifies the type of conversion
          to be applied. The valid conversion specifiers are described below.

    The fscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space characters shall be executed
    by reading input until no more valid input can be read, or up to the first
    byte which is not a white-space character, which remains unread.

    A directive that is an ordinary character shall be executed as follows: the
    next byte shall be read from the input and compared with the byte that
    comprises the directive; if the comparison shows that they are not
    equivalent, the directive shall fail, and the differing and subsequent bytes
    shall remain unread. Similarly, if end-of-file, an encoding error, or a read
    error prevents a character from being read, the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion character. A
    conversion specification shall be executed in the following steps.

    Input white-space characters (as specified by isspace()) shall be skipped,
    unless the conversion specification includes a [, c, C, or n conversion
    specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier. An input item shall be defined as the
    longest sequence of input bytes (up to any specified maximum field width,
    which may be measured in characters or bytes dependent on the conversion
    specifier) which is an initial subsequence of a matching sequence. The first
    byte, if any, after the input item shall remain unread. If the length of the
    input item is 0, the execution of the conversion specification shall fail;
    this condition is a matching failure, unless end-of-file, an encoding error,
    or a read error prevented input from the stream, in which case it is an
    input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input bytes) shall be
    converted to a type appropriate to the conversion character. If the input
    item is not a matching sequence, the execution of the conversion
    specification fails; this condition is a matching failure. Unless assignment
    suppression was indicated by a '*', the result of the conversion shall be
    placed in the object pointed to by the first argument following the format
    argument that has not already received a conversion result if the conversion
    specification is introduced by %, or in the nth argument if introduced by
    the character sequence "%n$". If this object does not have an appropriate
    type, or if the result of the conversion cannot be represented in the space
    provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifiers are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of strtol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of strtoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of strtoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN,
        whose format is the same as expected for the subject sequence of
        strtod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fscanf() family
        of functions shall recognize them as input.
    s
        Matches a sequence of bytes that are not white-space characters. The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence and a terminating null character
        code, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character shall
        be converted to a wide character as if by a call to the mbrtowc()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.
    [
        Matches a non-empty sequence of bytes from a set of expected bytes (the
        scanset). The normal skip over white-space characters shall be
        suppressed in this case. The application shall ensure that the
        corresponding argument is a pointer to the initial byte of an array of
        char, signed char, or unsigned char large enough to accept the sequence
        and a terminating null byte, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence shall be converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.

        The conversion specification includes all subsequent bytes in the format
        string up to and including the matching right square bracket ( ']' ).
        The bytes between the square brackets (the scanlist) comprise the
        scanset, unless the byte after the left square bracket is a circumflex
        ( '^' ), in which case the scanset contains all bytes that do not appear
        in the scanlist between the circumflex and the right square bracket. If
        the conversion specification begins with "[]" or "[^]", the right square
        bracket is included in the scanlist and the next right square bracket is
        the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that
        ends the conversion specification. If a '-' is in the scanlist and is
        not the first character, nor the second where the first character is a
        '^', nor the last character, the behavior is implementation-defined.
    c
        Matches a sequence of bytes of the number specified by the field width
        (1 if no field width is present in the conversion specification). The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence. No null byte is added. The normal
        skip over white-space characters shall be suppressed in this case.

        If an l (ell) qualifier is present, the input shall be a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence is converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the resulting sequence of
        wide characters. No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion specification is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which shall be
        written the number of bytes read from the input so far by this call to
        the fscanf() functions. Execution of a %n conversion specification shall
        not increment the assignment count returned at the completion of
        execution of the function. No argument shall be converted, but one shall
        be consumed. If the conversion specification includes an
        assignment-suppressing character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' character; no conversion or assignment occurs. The
        complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to a, e, f, g, and x, respectively.

    If end-of-file is encountered during input, conversion shall be terminated.
    If end-of-file occurs before any bytes matching the current conversion
    specification (except for %n ) have been read (other than leading
    white-space characters, where permitted), execution of the current
    conversion specification shall terminate with an input failure. Otherwise,
    unless execution of the current conversion specification is terminated with
    a matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in sscanf() shall be equivalent to
    encountering end-of-file for fscanf().

    If conversion terminates on a conflicting input, the offending input is left
    unread in the input. Any trailing white space (including <newline>s) shall
    be left unread unless matched by a conversion specification. The success of
    literal matches and suppressed assignments is only directly determinable via
    the %n conversion specification.

    The fscanf() and scanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fread(),
    getc(), getchar(), gets(), fscanf(), or fscanf() using stream that returns
    data not supplied by a prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fscanf() functions fail and may fail,
    refer to fgetc() or fgetwc().

    In addition, fscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT fscanf_spec( CallContext context, FILETPtr * stream, CString * format, List /* NULL */ * arguments,
                  ErrorCode * errno, CString * fileForStreamName
                )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for scanf group] */
        REQ( "", "Common preconditions for scanf group", checkScanfPreconditions( "fscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * input = freadFile( context, stream, fileForStreamName, create_CString( "r" ) );

        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FSCANF, "fscanf.05.02;fscanf.05.03", fscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_FSCANF, EILSEQ, "fscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_FSCANF, EINVAL, "fscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkScanfResult( "fscanf", format, arguments, fscanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fscanf, scanf, sscanf - convert formatted input

SYNOPSIS

    #include <stdio.h>

    int fscanf(FILE *restrict stream, const char *restrict format, ... );
    int scanf(const char *restrict format, ... );
    int sscanf(const char *restrict s, const char *restrict format, ... );

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fscanf() function shall read from the named input stream. The scanf()
    function shall read from the standard input stream stdin. The sscanf()
    function shall read from the string s. Each function reads bytes, interprets
    them according to a format, and stores the results in its arguments. Each
    expects, as arguments, a control string format described below, and a set of
    pointer arguments indicating where the converted input should be stored. The
    result is undefined if there are insufficient arguments for the format. If
    the format is exhausted while arguments remain, the excess arguments shall
    be evaluated but otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This
    feature provides for the definition of format strings that select arguments
    in an order appropriate to specific languages. In format strings containing
    the "%n$" form of conversion specifications, it is unspecified whether
    numbered arguments in the argument list can be referenced from the format
    string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"-but the two forms cannot be mixed within a single format string.
    The only exception to this is that %% or %* can be mixed with the "%n$"
    form. When numbered argument specifications are used, specifying the Nth
    argument requires that all the leading arguments, from the first to the
    ( N-1 )th, are pointers.

    The fscanf() function in all its forms shall allow detection of a
    language-dependent radix character in the input string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    The format is a character string, beginning and ending in its initial shift
    state, if any, composed of zero or more directives. Each directive is
    composed of one of the following: one or more white-space characters (
    <space>s, <tab>s, <newline>s, <vertical-tab>s, or <form-feed>s); an ordinary
    character (neither '%' nor a white-space character); or a conversion
    specification. Each conversion specification is introduced by the character
    '%' or the character sequence "%n$", after which the following appear in
    sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An option length modifier that specifies the size of the receiving
          object.

        * A conversion specifier character that specifies the type of conversion
          to be applied. The valid conversion specifiers are described below.

    The fscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space characters shall be executed
    by reading input until no more valid input can be read, or up to the first
    byte which is not a white-space character, which remains unread.

    A directive that is an ordinary character shall be executed as follows: the
    next byte shall be read from the input and compared with the byte that
    comprises the directive; if the comparison shows that they are not
    equivalent, the directive shall fail, and the differing and subsequent bytes
    shall remain unread. Similarly, if end-of-file, an encoding error, or a read
    error prevents a character from being read, the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion character. A
    conversion specification shall be executed in the following steps.

    Input white-space characters (as specified by isspace()) shall be skipped,
    unless the conversion specification includes a [, c, C, or n conversion
    specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier. An input item shall be defined as the
    longest sequence of input bytes (up to any specified maximum field width,
    which may be measured in characters or bytes dependent on the conversion
    specifier) which is an initial subsequence of a matching sequence. The first
    byte, if any, after the input item shall remain unread. If the length of the
    input item is 0, the execution of the conversion specification shall fail;
    this condition is a matching failure, unless end-of-file, an encoding error,
    or a read error prevented input from the stream, in which case it is an
    input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input bytes) shall be
    converted to a type appropriate to the conversion character. If the input
    item is not a matching sequence, the execution of the conversion
    specification fails; this condition is a matching failure. Unless assignment
    suppression was indicated by a '*', the result of the conversion shall be
    placed in the object pointed to by the first argument following the format
    argument that has not already received a conversion result if the conversion
    specification is introduced by %, or in the nth argument if introduced by
    the character sequence "%n$". If this object does not have an appropriate
    type, or if the result of the conversion cannot be represented in the space
    provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifiers are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of strtol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of strtoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of strtoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN,
        whose format is the same as expected for the subject sequence of
        strtod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fscanf() family
        of functions shall recognize them as input.
    s
        Matches a sequence of bytes that are not white-space characters. The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence and a terminating null character
        code, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character shall
        be converted to a wide character as if by a call to the mbrtowc()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.
    [
        Matches a non-empty sequence of bytes from a set of expected bytes (the
        scanset). The normal skip over white-space characters shall be
        suppressed in this case. The application shall ensure that the
        corresponding argument is a pointer to the initial byte of an array of
        char, signed char, or unsigned char large enough to accept the sequence
        and a terminating null byte, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence shall be converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.

        The conversion specification includes all subsequent bytes in the format
        string up to and including the matching right square bracket ( ']' ).
        The bytes between the square brackets (the scanlist) comprise the
        scanset, unless the byte after the left square bracket is a circumflex
        ( '^' ), in which case the scanset contains all bytes that do not appear
        in the scanlist between the circumflex and the right square bracket. If
        the conversion specification begins with "[]" or "[^]", the right square
        bracket is included in the scanlist and the next right square bracket is
        the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that
        ends the conversion specification. If a '-' is in the scanlist and is
        not the first character, nor the second where the first character is a
        '^', nor the last character, the behavior is implementation-defined.
    c
        Matches a sequence of bytes of the number specified by the field width
        (1 if no field width is present in the conversion specification). The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence. No null byte is added. The normal
        skip over white-space characters shall be suppressed in this case.

        If an l (ell) qualifier is present, the input shall be a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence is converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the resulting sequence of
        wide characters. No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion specification is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which shall be
        written the number of bytes read from the input so far by this call to
        the fscanf() functions. Execution of a %n conversion specification shall
        not increment the assignment count returned at the completion of
        execution of the function. No argument shall be converted, but one shall
        be consumed. If the conversion specification includes an
        assignment-suppressing character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' character; no conversion or assignment occurs. The
        complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to a, e, f, g, and x, respectively.

    If end-of-file is encountered during input, conversion shall be terminated.
    If end-of-file occurs before any bytes matching the current conversion
    specification (except for %n ) have been read (other than leading
    white-space characters, where permitted), execution of the current
    conversion specification shall terminate with an input failure. Otherwise,
    unless execution of the current conversion specification is terminated with
    a matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in sscanf() shall be equivalent to
    encountering end-of-file for fscanf().

    If conversion terminates on a conflicting input, the offending input is left
    unread in the input. Any trailing white space (including <newline>s) shall
    be left unread unless matched by a conversion specification. The success of
    literal matches and suppressed assignments is only directly determinable via
    the %n conversion specification.

    The fscanf() and scanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fread(),
    getc(), getchar(), gets(), fscanf(), or fscanf() using stream that returns
    data not supplied by a prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fscanf() functions fail and may fail,
    refer to fgetc() or fgetwc().

    In addition, fscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT scanf_spec( CallContext context, CString * format, List /* NULL */ * arguments, CString * input, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for scanf group] */
        REQ( "", "Common preconditions for scanf group", checkScanfPreconditions( "scanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SCANF, "scanf.05.02;scanf.05.03", scanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_SCANF, EILSEQ, "scanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_SCANF, EINVAL, "scanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkScanfResult( "scanf", format, arguments, scanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fscanf, scanf, sscanf - convert formatted input

SYNOPSIS

    #include <stdio.h>

    int fscanf(FILE *restrict stream, const char *restrict format, ... );
    int scanf(const char *restrict format, ... );
    int sscanf(const char *restrict s, const char *restrict format, ... );

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fscanf() function shall read from the named input stream. The scanf()
    function shall read from the standard input stream stdin. The sscanf()
    function shall read from the string s. Each function reads bytes, interprets
    them according to a format, and stores the results in its arguments. Each
    expects, as arguments, a control string format described below, and a set of
    pointer arguments indicating where the converted input should be stored. The
    result is undefined if there are insufficient arguments for the format. If
    the format is exhausted while arguments remain, the excess arguments shall
    be evaluated but otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This
    feature provides for the definition of format strings that select arguments
    in an order appropriate to specific languages. In format strings containing
    the "%n$" form of conversion specifications, it is unspecified whether
    numbered arguments in the argument list can be referenced from the format
    string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"-but the two forms cannot be mixed within a single format string.
    The only exception to this is that %% or %* can be mixed with the "%n$"
    form. When numbered argument specifications are used, specifying the Nth
    argument requires that all the leading arguments, from the first to the
    ( N-1 )th, are pointers.

    The fscanf() function in all its forms shall allow detection of a
    language-dependent radix character in the input string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    The format is a character string, beginning and ending in its initial shift
    state, if any, composed of zero or more directives. Each directive is
    composed of one of the following: one or more white-space characters (
    <space>s, <tab>s, <newline>s, <vertical-tab>s, or <form-feed>s); an ordinary
    character (neither '%' nor a white-space character); or a conversion
    specification. Each conversion specification is introduced by the character
    '%' or the character sequence "%n$", after which the following appear in
    sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An option length modifier that specifies the size of the receiving
          object.

        * A conversion specifier character that specifies the type of conversion
          to be applied. The valid conversion specifiers are described below.

    The fscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space characters shall be executed
    by reading input until no more valid input can be read, or up to the first
    byte which is not a white-space character, which remains unread.

    A directive that is an ordinary character shall be executed as follows: the
    next byte shall be read from the input and compared with the byte that
    comprises the directive; if the comparison shows that they are not
    equivalent, the directive shall fail, and the differing and subsequent bytes
    shall remain unread. Similarly, if end-of-file, an encoding error, or a read
    error prevents a character from being read, the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion character. A
    conversion specification shall be executed in the following steps.

    Input white-space characters (as specified by isspace()) shall be skipped,
    unless the conversion specification includes a [, c, C, or n conversion
    specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier. An input item shall be defined as the
    longest sequence of input bytes (up to any specified maximum field width,
    which may be measured in characters or bytes dependent on the conversion
    specifier) which is an initial subsequence of a matching sequence. The first
    byte, if any, after the input item shall remain unread. If the length of the
    input item is 0, the execution of the conversion specification shall fail;
    this condition is a matching failure, unless end-of-file, an encoding error,
    or a read error prevented input from the stream, in which case it is an
    input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input bytes) shall be
    converted to a type appropriate to the conversion character. If the input
    item is not a matching sequence, the execution of the conversion
    specification fails; this condition is a matching failure. Unless assignment
    suppression was indicated by a '*', the result of the conversion shall be
    placed in the object pointed to by the first argument following the format
    argument that has not already received a conversion result if the conversion
    specification is introduced by %, or in the nth argument if introduced by
    the character sequence "%n$". If this object does not have an appropriate
    type, or if the result of the conversion cannot be represented in the space
    provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifiers are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of strtol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of strtoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of strtoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN,
        whose format is the same as expected for the subject sequence of
        strtod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fscanf() family
        of functions shall recognize them as input.
    s
        Matches a sequence of bytes that are not white-space characters. The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence and a terminating null character
        code, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character shall
        be converted to a wide character as if by a call to the mbrtowc()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.
    [
        Matches a non-empty sequence of bytes from a set of expected bytes (the
        scanset). The normal skip over white-space characters shall be
        suppressed in this case. The application shall ensure that the
        corresponding argument is a pointer to the initial byte of an array of
        char, signed char, or unsigned char large enough to accept the sequence
        and a terminating null byte, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence shall be converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.

        The conversion specification includes all subsequent bytes in the format
        string up to and including the matching right square bracket ( ']' ).
        The bytes between the square brackets (the scanlist) comprise the
        scanset, unless the byte after the left square bracket is a circumflex
        ( '^' ), in which case the scanset contains all bytes that do not appear
        in the scanlist between the circumflex and the right square bracket. If
        the conversion specification begins with "[]" or "[^]", the right square
        bracket is included in the scanlist and the next right square bracket is
        the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that
        ends the conversion specification. If a '-' is in the scanlist and is
        not the first character, nor the second where the first character is a
        '^', nor the last character, the behavior is implementation-defined.
    c
        Matches a sequence of bytes of the number specified by the field width
        (1 if no field width is present in the conversion specification). The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence. No null byte is added. The normal
        skip over white-space characters shall be suppressed in this case.

        If an l (ell) qualifier is present, the input shall be a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence is converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the resulting sequence of
        wide characters. No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion specification is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which shall be
        written the number of bytes read from the input so far by this call to
        the fscanf() functions. Execution of a %n conversion specification shall
        not increment the assignment count returned at the completion of
        execution of the function. No argument shall be converted, but one shall
        be consumed. If the conversion specification includes an
        assignment-suppressing character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' character; no conversion or assignment occurs. The
        complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to a, e, f, g, and x, respectively.

    If end-of-file is encountered during input, conversion shall be terminated.
    If end-of-file occurs before any bytes matching the current conversion
    specification (except for %n ) have been read (other than leading
    white-space characters, where permitted), execution of the current
    conversion specification shall terminate with an input failure. Otherwise,
    unless execution of the current conversion specification is terminated with
    a matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in sscanf() shall be equivalent to
    encountering end-of-file for fscanf().

    If conversion terminates on a conflicting input, the offending input is left
    unread in the input. Any trailing white space (including <newline>s) shall
    be left unread unless matched by a conversion specification. The success of
    literal matches and suppressed assignments is only directly determinable via
    the %n conversion specification.

    The fscanf() and scanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fread(),
    getc(), getchar(), gets(), fscanf(), or fscanf() using stream that returns
    data not supplied by a prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fscanf() functions fail and may fail,
    refer to fgetc() or fgetwc().

    In addition, fscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT sscanf_spec( CallContext context, CString * s, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for scanf group] */
        REQ( "", "Common preconditions for scanf group", checkScanfPreconditions( "sscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SSCANF, "sscanf.05.02;sscanf.05.03", sscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_SSCANF, EILSEQ, "sscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_SSCANF, EINVAL, "sscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkScanfResult( "sscanf", format, arguments, sscanf_spec, s, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfscanf, vscanf, vsscanf - format input of a stdarg argument list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfscanf(FILE *restrict stream, const char *restrict format,
           va_list arg);
    int vscanf(const char *restrict format, va_list arg);
    int vsscanf(const char *restrict s, const char *restrict format,
           va_list arg);

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The vscanf(), vfscanf(), and vsscanf() functions shall be equivalent to the
    scanf(), fscanf(), and sscanf() functions, respectively, except that instead
    of being called with a variable number of arguments, they are called with an
    argument list as defined in the <stdarg.h> header. These functions shall not
    invoke the va_end macro. As these functions invoke the va_arg macro, the
    value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fscanf() function shall read from the named input stream. The scanf()
    function shall read from the standard input stream stdin. The sscanf()
    function shall read from the string s. Each function reads bytes, interprets
    them according to a format, and stores the results in its arguments. Each
    expects, as arguments, a control string format described below, and a set of
    pointer arguments indicating where the converted input should be stored. The
    result is undefined if there are insufficient arguments for the format. If
    the format is exhausted while arguments remain, the excess arguments shall
    be evaluated but otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This
    feature provides for the definition of format strings that select arguments
    in an order appropriate to specific languages. In format strings containing
    the "%n$" form of conversion specifications, it is unspecified whether
    numbered arguments in the argument list can be referenced from the format
    string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"-but the two forms cannot be mixed within a single format string.
    The only exception to this is that %% or %* can be mixed with the "%n$"
    form. When numbered argument specifications are used, specifying the Nth
    argument requires that all the leading arguments, from the first to the
    ( N-1 )th, are pointers.

    The fscanf() function in all its forms shall allow detection of a
    language-dependent radix character in the input string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    The format is a character string, beginning and ending in its initial shift
    state, if any, composed of zero or more directives. Each directive is
    composed of one of the following: one or more white-space characters (
    <space>s, <tab>s, <newline>s, <vertical-tab>s, or <form-feed>s); an ordinary
    character (neither '%' nor a white-space character); or a conversion
    specification. Each conversion specification is introduced by the character
    '%' or the character sequence "%n$", after which the following appear in
    sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An option length modifier that specifies the size of the receiving
          object.

        * A conversion specifier character that specifies the type of conversion
          to be applied. The valid conversion specifiers are described below.

    The fscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space characters shall be executed
    by reading input until no more valid input can be read, or up to the first
    byte which is not a white-space character, which remains unread.

    A directive that is an ordinary character shall be executed as follows: the
    next byte shall be read from the input and compared with the byte that
    comprises the directive; if the comparison shows that they are not
    equivalent, the directive shall fail, and the differing and subsequent bytes
    shall remain unread. Similarly, if end-of-file, an encoding error, or a read
    error prevents a character from being read, the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion character. A
    conversion specification shall be executed in the following steps.

    Input white-space characters (as specified by isspace()) shall be skipped,
    unless the conversion specification includes a [, c, C, or n conversion
    specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier. An input item shall be defined as the
    longest sequence of input bytes (up to any specified maximum field width,
    which may be measured in characters or bytes dependent on the conversion
    specifier) which is an initial subsequence of a matching sequence. The first
    byte, if any, after the input item shall remain unread. If the length of the
    input item is 0, the execution of the conversion specification shall fail;
    this condition is a matching failure, unless end-of-file, an encoding error,
    or a read error prevented input from the stream, in which case it is an
    input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input bytes) shall be
    converted to a type appropriate to the conversion character. If the input
    item is not a matching sequence, the execution of the conversion
    specification fails; this condition is a matching failure. Unless assignment
    suppression was indicated by a '*', the result of the conversion shall be
    placed in the object pointed to by the first argument following the format
    argument that has not already received a conversion result if the conversion
    specification is introduced by %, or in the nth argument if introduced by
    the character sequence "%n$". If this object does not have an appropriate
    type, or if the result of the conversion cannot be represented in the space
    provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifiers are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of strtol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of strtoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of strtoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN,
        whose format is the same as expected for the subject sequence of
        strtod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fscanf() family
        of functions shall recognize them as input.
    s
        Matches a sequence of bytes that are not white-space characters. The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence and a terminating null character
        code, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character shall
        be converted to a wide character as if by a call to the mbrtowc()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.
    [
        Matches a non-empty sequence of bytes from a set of expected bytes (the
        scanset). The normal skip over white-space characters shall be
        suppressed in this case. The application shall ensure that the
        corresponding argument is a pointer to the initial byte of an array of
        char, signed char, or unsigned char large enough to accept the sequence
        and a terminating null byte, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence shall be converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.

        The conversion specification includes all subsequent bytes in the format
        string up to and including the matching right square bracket ( ']' ).
        The bytes between the square brackets (the scanlist) comprise the
        scanset, unless the byte after the left square bracket is a circumflex
        ( '^' ), in which case the scanset contains all bytes that do not appear
        in the scanlist between the circumflex and the right square bracket. If
        the conversion specification begins with "[]" or "[^]", the right square
        bracket is included in the scanlist and the next right square bracket is
        the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that
        ends the conversion specification. If a '-' is in the scanlist and is
        not the first character, nor the second where the first character is a
        '^', nor the last character, the behavior is implementation-defined.
    c
        Matches a sequence of bytes of the number specified by the field width
        (1 if no field width is present in the conversion specification). The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence. No null byte is added. The normal
        skip over white-space characters shall be suppressed in this case.

        If an l (ell) qualifier is present, the input shall be a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence is converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the resulting sequence of
        wide characters. No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion specification is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which shall be
        written the number of bytes read from the input so far by this call to
        the fscanf() functions. Execution of a %n conversion specification shall
        not increment the assignment count returned at the completion of
        execution of the function. No argument shall be converted, but one shall
        be consumed. If the conversion specification includes an
        assignment-suppressing character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' character; no conversion or assignment occurs. The
        complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to a, e, f, g, and x, respectively.

    If end-of-file is encountered during input, conversion shall be terminated.
    If end-of-file occurs before any bytes matching the current conversion
    specification (except for %n ) have been read (other than leading
    white-space characters, where permitted), execution of the current
    conversion specification shall terminate with an input failure. Otherwise,
    unless execution of the current conversion specification is terminated with
    a matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in sscanf() shall be equivalent to
    encountering end-of-file for fscanf().

    If conversion terminates on a conflicting input, the offending input is left
    unread in the input. Any trailing white space (including <newline>s) shall
    be left unread unless matched by a conversion specification. The success of
    literal matches and suppressed assignments is only directly determinable via
    the %n conversion specification.

    The fscanf() and scanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fread(),
    getc(), getchar(), gets(), fscanf(), or fscanf() using stream that returns
    data not supplied by a prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fscanf() functions fail and may fail,
    refer to fgetc() or fgetwc().

    In addition, fscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT vfscanf_spec( CallContext context, FILETPtr * stream, CString * format, List /* NULL */ * arguments,
                   ErrorCode * errno, CString * fileForStreamName
                 )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for scanf group] */
        REQ( "", "Common preconditions for scanf group", checkScanfPreconditions( "vfscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * input = freadFile( context, stream, fileForStreamName, create_CString( "r" ) );

        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_VFSCANF, "vfscanf.05.02;vfscanf.05.03", vfscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_VFSCANF, EILSEQ, "vfscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_VFSCANF, EINVAL, "vfscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkScanfResult( "vfscanf", format, arguments, vfscanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfscanf, vscanf, vsscanf - format input of a stdarg argument list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfscanf(FILE *restrict stream, const char *restrict format,
           va_list arg);
    int vscanf(const char *restrict format, va_list arg);
    int vsscanf(const char *restrict s, const char *restrict format,
           va_list arg);

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The vscanf(), vfscanf(), and vsscanf() functions shall be equivalent to the
    scanf(), fscanf(), and sscanf() functions, respectively, except that instead
    of being called with a variable number of arguments, they are called with an
    argument list as defined in the <stdarg.h> header. These functions shall not
    invoke the va_end macro. As these functions invoke the va_arg macro, the
    value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fscanf() function shall read from the named input stream. The scanf()
    function shall read from the standard input stream stdin. The sscanf()
    function shall read from the string s. Each function reads bytes, interprets
    them according to a format, and stores the results in its arguments. Each
    expects, as arguments, a control string format described below, and a set of
    pointer arguments indicating where the converted input should be stored. The
    result is undefined if there are insufficient arguments for the format. If
    the format is exhausted while arguments remain, the excess arguments shall
    be evaluated but otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This
    feature provides for the definition of format strings that select arguments
    in an order appropriate to specific languages. In format strings containing
    the "%n$" form of conversion specifications, it is unspecified whether
    numbered arguments in the argument list can be referenced from the format
    string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"-but the two forms cannot be mixed within a single format string.
    The only exception to this is that %% or %* can be mixed with the "%n$"
    form. When numbered argument specifications are used, specifying the Nth
    argument requires that all the leading arguments, from the first to the
    ( N-1 )th, are pointers.

    The fscanf() function in all its forms shall allow detection of a
    language-dependent radix character in the input string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    The format is a character string, beginning and ending in its initial shift
    state, if any, composed of zero or more directives. Each directive is
    composed of one of the following: one or more white-space characters (
    <space>s, <tab>s, <newline>s, <vertical-tab>s, or <form-feed>s); an ordinary
    character (neither '%' nor a white-space character); or a conversion
    specification. Each conversion specification is introduced by the character
    '%' or the character sequence "%n$", after which the following appear in
    sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An option length modifier that specifies the size of the receiving
          object.

        * A conversion specifier character that specifies the type of conversion
          to be applied. The valid conversion specifiers are described below.

    The fscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space characters shall be executed
    by reading input until no more valid input can be read, or up to the first
    byte which is not a white-space character, which remains unread.

    A directive that is an ordinary character shall be executed as follows: the
    next byte shall be read from the input and compared with the byte that
    comprises the directive; if the comparison shows that they are not
    equivalent, the directive shall fail, and the differing and subsequent bytes
    shall remain unread. Similarly, if end-of-file, an encoding error, or a read
    error prevents a character from being read, the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion character. A
    conversion specification shall be executed in the following steps.

    Input white-space characters (as specified by isspace()) shall be skipped,
    unless the conversion specification includes a [, c, C, or n conversion
    specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier. An input item shall be defined as the
    longest sequence of input bytes (up to any specified maximum field width,
    which may be measured in characters or bytes dependent on the conversion
    specifier) which is an initial subsequence of a matching sequence. The first
    byte, if any, after the input item shall remain unread. If the length of the
    input item is 0, the execution of the conversion specification shall fail;
    this condition is a matching failure, unless end-of-file, an encoding error,
    or a read error prevented input from the stream, in which case it is an
    input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input bytes) shall be
    converted to a type appropriate to the conversion character. If the input
    item is not a matching sequence, the execution of the conversion
    specification fails; this condition is a matching failure. Unless assignment
    suppression was indicated by a '*', the result of the conversion shall be
    placed in the object pointed to by the first argument following the format
    argument that has not already received a conversion result if the conversion
    specification is introduced by %, or in the nth argument if introduced by
    the character sequence "%n$". If this object does not have an appropriate
    type, or if the result of the conversion cannot be represented in the space
    provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifiers are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of strtol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of strtoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of strtoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN,
        whose format is the same as expected for the subject sequence of
        strtod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fscanf() family
        of functions shall recognize them as input.
    s
        Matches a sequence of bytes that are not white-space characters. The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence and a terminating null character
        code, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character shall
        be converted to a wide character as if by a call to the mbrtowc()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.
    [
        Matches a non-empty sequence of bytes from a set of expected bytes (the
        scanset). The normal skip over white-space characters shall be
        suppressed in this case. The application shall ensure that the
        corresponding argument is a pointer to the initial byte of an array of
        char, signed char, or unsigned char large enough to accept the sequence
        and a terminating null byte, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence shall be converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.

        The conversion specification includes all subsequent bytes in the format
        string up to and including the matching right square bracket ( ']' ).
        The bytes between the square brackets (the scanlist) comprise the
        scanset, unless the byte after the left square bracket is a circumflex
        ( '^' ), in which case the scanset contains all bytes that do not appear
        in the scanlist between the circumflex and the right square bracket. If
        the conversion specification begins with "[]" or "[^]", the right square
        bracket is included in the scanlist and the next right square bracket is
        the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that
        ends the conversion specification. If a '-' is in the scanlist and is
        not the first character, nor the second where the first character is a
        '^', nor the last character, the behavior is implementation-defined.
    c
        Matches a sequence of bytes of the number specified by the field width
        (1 if no field width is present in the conversion specification). The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence. No null byte is added. The normal
        skip over white-space characters shall be suppressed in this case.

        If an l (ell) qualifier is present, the input shall be a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence is converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the resulting sequence of
        wide characters. No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion specification is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which shall be
        written the number of bytes read from the input so far by this call to
        the fscanf() functions. Execution of a %n conversion specification shall
        not increment the assignment count returned at the completion of
        execution of the function. No argument shall be converted, but one shall
        be consumed. If the conversion specification includes an
        assignment-suppressing character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' character; no conversion or assignment occurs. The
        complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to a, e, f, g, and x, respectively.

    If end-of-file is encountered during input, conversion shall be terminated.
    If end-of-file occurs before any bytes matching the current conversion
    specification (except for %n ) have been read (other than leading
    white-space characters, where permitted), execution of the current
    conversion specification shall terminate with an input failure. Otherwise,
    unless execution of the current conversion specification is terminated with
    a matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in sscanf() shall be equivalent to
    encountering end-of-file for fscanf().

    If conversion terminates on a conflicting input, the offending input is left
    unread in the input. Any trailing white space (including <newline>s) shall
    be left unread unless matched by a conversion specification. The success of
    literal matches and suppressed assignments is only directly determinable via
    the %n conversion specification.

    The fscanf() and scanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fread(),
    getc(), getchar(), gets(), fscanf(), or fscanf() using stream that returns
    data not supplied by a prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fscanf() functions fail and may fail,
    refer to fgetc() or fgetwc().

    In addition, fscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT vscanf_spec( CallContext context, CString * format, List /* NULL */ * arguments, CString * input, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for scanf group] */
        REQ( "", "Common preconditions for scanf group", checkScanfPreconditions( "vscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_VSCANF, "vscanf.05.02;vscanf.05.03", vscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_VSCANF, EILSEQ, "vscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_VSCANF, EINVAL, "vscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkScanfResult( "vscanf", format, arguments, vscanf_spec, input, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfscanf, vscanf, vsscanf - format input of a stdarg argument list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfscanf(FILE *restrict stream, const char *restrict format,
           va_list arg);
    int vscanf(const char *restrict format, va_list arg);
    int vsscanf(const char *restrict s, const char *restrict format,
           va_list arg);

DESCRIPTION

    The scanf() family of functions shall behave as described in ISO POSIX
    (2003), except as noted below.

    Differences
    The %s, %S and %[ conversion specifiers shall accept an option length
    modifier a, which shall cause a memory buffer to be allocated to hold the
    string converted. In such a case, the argument corresponding to the
    conversion specifier should be a reference to a pointer value that will
    receive a pointer to the allocated buffer. If there is insufficient memory
    to allocate a buffer, the function may set errno to ENOMEM and a conversion
    error results.

    Note: This directly conflicts with the ISO C (1999) usage of %a as a
    conversion specifier for hexadecimal float values. While this conversion
    specifier should be supported, a format specifier such as "%aseconds" will
    have a different meaning on an LSB conforming system.

    The vscanf(), vfscanf(), and vsscanf() functions shall be equivalent to the
    scanf(), fscanf(), and sscanf() functions, respectively, except that instead
    of being called with a variable number of arguments, they are called with an
    argument list as defined in the <stdarg.h> header. These functions shall not
    invoke the va_end macro. As these functions invoke the va_arg macro, the
    value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fscanf() function shall read from the named input stream. The scanf()
    function shall read from the standard input stream stdin. The sscanf()
    function shall read from the string s. Each function reads bytes, interprets
    them according to a format, and stores the results in its arguments. Each
    expects, as arguments, a control string format described below, and a set of
    pointer arguments indicating where the converted input should be stored. The
    result is undefined if there are insufficient arguments for the format. If
    the format is exhausted while arguments remain, the excess arguments shall
    be evaluated but otherwise ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This
    feature provides for the definition of format strings that select arguments
    in an order appropriate to specific languages. In format strings containing
    the "%n$" form of conversion specifications, it is unspecified whether
    numbered arguments in the argument list can be referenced from the format
    string more than once.

    The format can contain either form of a conversion specification-that is, %
    or "%n$"-but the two forms cannot be mixed within a single format string.
    The only exception to this is that %% or %* can be mixed with the "%n$"
    form. When numbered argument specifications are used, specifying the Nth
    argument requires that all the leading arguments, from the first to the
    ( N-1 )th, are pointers.

    The fscanf() function in all its forms shall allow detection of a
    language-dependent radix character in the input string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    The format is a character string, beginning and ending in its initial shift
    state, if any, composed of zero or more directives. Each directive is
    composed of one of the following: one or more white-space characters (
    <space>s, <tab>s, <newline>s, <vertical-tab>s, or <form-feed>s); an ordinary
    character (neither '%' nor a white-space character); or a conversion
    specification. Each conversion specification is introduced by the character
    '%' or the character sequence "%n$", after which the following appear in
    sequence:

        * An optional assignment-suppressing character '*'.

        * An optional non-zero decimal integer that specifies the maximum field
          width.

        * An option length modifier that specifies the size of the receiving
          object.

        * A conversion specifier character that specifies the type of conversion
          to be applied. The valid conversion specifiers are described below.

    The fscanf() functions shall execute each directive of the format in turn.
    If a directive fails, as detailed below, the function shall return. Failures
    are described as input failures (due to the unavailability of input bytes)
    or matching failures (due to inappropriate input).

    A directive composed of one or more white-space characters shall be executed
    by reading input until no more valid input can be read, or up to the first
    byte which is not a white-space character, which remains unread.

    A directive that is an ordinary character shall be executed as follows: the
    next byte shall be read from the input and compared with the byte that
    comprises the directive; if the comparison shows that they are not
    equivalent, the directive shall fail, and the differing and subsequent bytes
    shall remain unread. Similarly, if end-of-file, an encoding error, or a read
    error prevents a character from being read, the directive shall fail.

    A directive that is a conversion specification defines a set of matching
    input sequences, as described below for each conversion character. A
    conversion specification shall be executed in the following steps.

    Input white-space characters (as specified by isspace()) shall be skipped,
    unless the conversion specification includes a [, c, C, or n conversion
    specifier.

    An item shall be read from the input, unless the conversion specification
    includes an n conversion specifier. An input item shall be defined as the
    longest sequence of input bytes (up to any specified maximum field width,
    which may be measured in characters or bytes dependent on the conversion
    specifier) which is an initial subsequence of a matching sequence. The first
    byte, if any, after the input item shall remain unread. If the length of the
    input item is 0, the execution of the conversion specification shall fail;
    this condition is a matching failure, unless end-of-file, an encoding error,
    or a read error prevented input from the stream, in which case it is an
    input failure.

    Except in the case of a % conversion specifier, the input item (or, in the
    case of a %n conversion specification, the count of input bytes) shall be
    converted to a type appropriate to the conversion character. If the input
    item is not a matching sequence, the execution of the conversion
    specification fails; this condition is a matching failure. Unless assignment
    suppression was indicated by a '*', the result of the conversion shall be
    placed in the object pointed to by the first argument following the format
    argument that has not already received a conversion result if the conversion
    specification is introduced by %, or in the nth argument if introduced by
    the character sequence "%n$". If this object does not have an appropriate
    type, or if the result of the conversion cannot be represented in the space
    provided, the behavior is undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to signed char or unsigned
        char.
    h
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to short or unsigned short.
    l (ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long or unsigned long; that
        a following a, A, e, E, f, F, g, or G conversion specifier applies to an
        argument with type pointer to double; or that a following c, s, or [
        conversion specifier applies to an argument with type pointer to
        wchar_t.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to long long or unsigned long
        long.
    j
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to intmax_t or uintmax_t.
    z
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to size_t or the corresponding
        signed integer type.
    t
        Specifies that a following d, i, o, u, x, X, or n conversion specifier
        applies to an argument with type pointer to ptrdiff_t or the
        corresponding unsigned type.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to an argument with type pointer to long double.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The following conversion specifiers are valid:

    d
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtol() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to int.
    i
        Matches an optionally signed integer, whose format is the same as
        expected for the subject sequence of strtol() with 0 for the base
        argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to int.
    o
        Matches an optionally signed octal integer, whose format is the same as
        expected for the subject sequence of strtoul() with the value 8 for the
        base argument. In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to unsigned.
    u
        Matches an optionally signed decimal integer, whose format is the same
        as expected for the subject sequence of strtoul() with the value 10 for
        the base argument. In the absence of a size modifier, the application
        shall ensure that the corresponding argument is a pointer to unsigned.
    x
        Matches an optionally signed hexadecimal integer, whose format is the
        same as expected for the subject sequence of strtoul() with the value 16
        for the base argument. In the absence of a size modifier, the
        application shall ensure that the corresponding argument is a pointer to
        unsigned.
    a, e, f, g
        Matches an optionally signed floating-point number, infinity, or NaN,
        whose format is the same as expected for the subject sequence of
        strtod(). In the absence of a size modifier, the application shall
        ensure that the corresponding argument is a pointer to float.

        If the fprintf() family of functions generates character string
        representations for infinity and NaN (a symbolic entity encoded in
        floating-point format) to support IEEE Std 754-1985, the fscanf() family
        of functions shall recognize them as input.
    s
        Matches a sequence of bytes that are not white-space characters. The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence and a terminating null character
        code, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character shall
        be converted to a wide character as if by a call to the mbrtowc()
        function, with the conversion state described by an mbstate_t object
        initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.
    [
        Matches a non-empty sequence of bytes from a set of expected bytes (the
        scanset). The normal skip over white-space characters shall be
        suppressed in this case. The application shall ensure that the
        corresponding argument is a pointer to the initial byte of an array of
        char, signed char, or unsigned char large enough to accept the sequence
        and a terminating null byte, which shall be added automatically.

        If an l (ell) qualifier is present, the input is a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence shall be converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the sequence and the
        terminating null wide character, which shall be added automatically.

        The conversion specification includes all subsequent bytes in the format
        string up to and including the matching right square bracket ( ']' ).
        The bytes between the square brackets (the scanlist) comprise the
        scanset, unless the byte after the left square bracket is a circumflex
        ( '^' ), in which case the scanset contains all bytes that do not appear
        in the scanlist between the circumflex and the right square bracket. If
        the conversion specification begins with "[]" or "[^]", the right square
        bracket is included in the scanlist and the next right square bracket is
        the matching right square bracket that ends the conversion
        specification; otherwise, the first right square bracket is the one that
        ends the conversion specification. If a '-' is in the scanlist and is
        not the first character, nor the second where the first character is a
        '^', nor the last character, the behavior is implementation-defined.
    c
        Matches a sequence of bytes of the number specified by the field width
        (1 if no field width is present in the conversion specification). The
        application shall ensure that the corresponding argument is a pointer to
        the initial byte of an array of char, signed char, or unsigned char
        large enough to accept the sequence. No null byte is added. The normal
        skip over white-space characters shall be suppressed in this case.

        If an l (ell) qualifier is present, the input shall be a sequence of
        characters that begins in the initial shift state. Each character in the
        sequence is converted to a wide character as if by a call to the
        mbrtowc() function, with the conversion state described by an mbstate_t
        object initialized to zero before the first character is converted. The
        application shall ensure that the corresponding argument is a pointer to
        an array of wchar_t large enough to accept the resulting sequence of
        wide characters. No null wide character is added.
    p
        Matches an implementation-defined set of sequences, which shall be the
        same as the set of sequences that is produced by the %p conversion
        specification of the corresponding fprintf() functions. The application
        shall ensure that the corresponding argument is a pointer to a pointer
        to void. The interpretation of the input item is implementation-defined.
        If the input item is a value converted earlier during the same program
        execution, the pointer that results shall compare equal to that value;
        otherwise, the behavior of the %p conversion specification is undefined.
    n
        No input is consumed. The application shall ensure that the
        corresponding argument is a pointer to the integer into which shall be
        written the number of bytes read from the input so far by this call to
        the fscanf() functions. Execution of a %n conversion specification shall
        not increment the assignment count returned at the completion of
        execution of the function. No argument shall be converted, but one shall
        be consumed. If the conversion specification includes an
        assignment-suppressing character or a field width, the behavior is
        undefined.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Matches a single '%' character; no conversion or assignment occurs. The
        complete conversion specification shall be %%.

    If a conversion specification is invalid, the behavior is undefined.

    The conversion specifiers A, E, F, G, and X are also valid and shall be
    equivalent to a, e, f, g, and x, respectively.

    If end-of-file is encountered during input, conversion shall be terminated.
    If end-of-file occurs before any bytes matching the current conversion
    specification (except for %n ) have been read (other than leading
    white-space characters, where permitted), execution of the current
    conversion specification shall terminate with an input failure. Otherwise,
    unless execution of the current conversion specification is terminated with
    a matching failure, execution of the following conversion specification (if
    any) shall be terminated with an input failure.

    Reaching the end of the string in sscanf() shall be equivalent to
    encountering end-of-file for fscanf().

    If conversion terminates on a conflicting input, the offending input is left
    unread in the input. Any trailing white space (including <newline>s) shall
    be left unread unless matched by a conversion specification. The success of
    literal matches and suppressed assignments is only directly determinable via
    the %n conversion specification.

    The fscanf() and scanf() functions may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fread(),
    getc(), getchar(), gets(), fscanf(), or fscanf() using stream that returns
    data not supplied by a prior call to ungetc().

RETURN VALUE

    Upon successful completion, these functions shall return the number of
    successfully matched and assigned input items; this number can be zero in
    the event of an early matching failure. If the input ends before the first
    matching failure or conversion, EOF shall be returned. If a read error
    occurs, the error indicator for the stream is set, EOF shall be returned,
    and errno shall be set to indicate the error.

ERRORS

    For the conditions under which the fscanf() functions fail and may fail,
    refer to fgetc() or fgetwc().

    In addition, fscanf() may fail if:

    [EILSEQ]
        Input byte sequence does not form a valid character.
    [EINVAL]
        There are insufficient arguments.
*/
specification
IntT vsscanf_spec( CallContext context, CString * s, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for scanf group] */
        REQ( "", "Common preconditions for scanf group", checkScanfPreconditions( "vsscanf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the input ends before the first matching failure or conversion, EOF shall be returned.
         * If a read error occurs, the error indicator for the stream is set, EOF shall be returned,
         * and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_VSSCANF, "vsscanf.05.02;vsscanf.05.03", vsscanf_spec == SUT_EOF, * errno )
            /*
             * In addition, fscanf() may fail if:
             *
             * [EILSEQ] [XSI] Input byte sequence does not form a valid character.
             */
            ERROR_MAY( POSIX_VSSCANF, EILSEQ, "vsscanf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, fscanf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_VSSCANF, EINVAL, "vsscanf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check arguments] */
        REQ( "", "Check arguments", checkScanfResult( "vsscanf", format, arguments, vsscanf_spec, s, errno ) );

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool checkScanfPreconditions( char * funcName, CString * format, List /* NULL */ * arguments ) {
    String * reqPrefix = concat_String
                             ( create_String( "app." ), concat_String( create_String( funcName ), create_String( "." ) ) );
    String * commonReqPrefix = create_String( "app.all_scan." );
    List /* String */ * preconditionsReqIds = create_List( & type_String );
    int i;
    append_List( preconditionsReqIds, create_String( "app.all_scan.03"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_scan.04"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_scan.05"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_scan.13.07" ) );
    append_List( preconditionsReqIds, create_String( "app.all_scan.14"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_scan.15.01" ) );
    append_List( preconditionsReqIds, create_String( "app.all_scan.15.11" ) );
    for ( i = 0; i < size_List( preconditionsReqIds ); i++ ) {
        String * reqId = get_List( preconditionsReqIds, i );
        char * reqIdAsCharArray;
        // app.all_scan.postfix +> app.funcName.postfix
        if ( startsWith_String( reqId, commonReqPrefix ) ) {
            reqId = clone( reqId );
            reqId = substringFrom_String( reqId, length_String( commonReqPrefix ) );
            reqId = concat_String( reqPrefix, reqId );
        }
        reqIdAsCharArray = (char *)toCharArray_String( reqId );
        if ( startsWith_String( reqId, reqPrefix ) ) { traceRequirements( reqIdAsCharArray ); }
    }
    return true;
}

String * toString_List( List /* NULL */ * list ) {
    String * res = create_String( "" );
    String * dataAsString = create_String( "< " );
    int i;
    for ( i = 0; i < size_List( list ); i++ ) {
        Object * cur = get_List( list, i );
        const Type * curType = type( cur );
        if ( curType == & type_IntTObj ) {
            IntTObj * x = cur;
            dataAsString = concat_String( dataAsString, format_String( "%d", * x ) );
        } else if ( curType == & type_LongDoubleTObj ) {
            LongDoubleTObj * x = cur;
            dataAsString = concat_String( dataAsString, format_String( "%.12Lf", * x ) );
        } else if ( curType == & type_DoubleTObj ) {
            DoubleTObj * x = cur;
            dataAsString = concat_String( dataAsString, format_String( "%.12f", * x ) );
        } else if ( curType == & type_FloatTObj ) {
            FloatTObj * x = cur;
            dataAsString = concat_String( dataAsString, format_String( "%.12f", * x ) );
        } else {
            dataAsString = concat_String( dataAsString, toString( cur ) );
        }
        if ( i != size_List( list ) - 1 ) { dataAsString = concat_String( dataAsString, create_String( ", " ) ); }
    }
    dataAsString = concat_String( dataAsString, create_String( " >" ) );
    res = concat_String( res, valueOfInt_String( size_List( list ) ) );
    res = concat_String( res, create_String( " : " ) );
    res = concat_String( res, dataAsString );
    return res;
}

bool checkScanfResult( char * funcName, CString * format, List /* NULL */ * arguments,
                       IntT returnValue, CString * input, ErrorCode * errno
                     ){
    bool verdict = returnValue < 0 || checkExpectedResult( funcName, arguments, "all_scan" );
    if ( ! verdict ) {
        List /* NULL */ * expectedArguments = getExpectedResult( funcName );
        String * expectedArgumentsAsString = toString_List( expectedArguments );
        String * argumentsAsString         = toString_List( arguments         );
        String * formatAsString            = toString     ( format            );
        String * inputAsString             = toString     ( input             );
        verbose( "checkScanfResult\n"                                                                               );
        verbose( "checkScanfResult : returned value    is [%ld]\n", returnValue                                     );
        verbose( "checkScanfResult : expectedArguments is [%s]\n" , toCharArray_String( expectedArgumentsAsString ) );
        verbose( "checkScanfResult : arguments         is [%s]\n" , toCharArray_String( argumentsAsString         ) );
        verbose( "checkScanfResult : format            is [%s]\n" , toCharArray_String( formatAsString            ) );
        verbose( "checkScanfResult : input             is [%s]\n" , toCharArray_String( inputAsString             ) );
        verbose( "checkScanfResult : errno             is [%ld]\n", * errno                                         );
    }
    // "close" data
    clearExpectedResultAndReqIds( funcName );
    // assertion( verdict, "stop" ); // for debug purpose
    return verdict;
}
