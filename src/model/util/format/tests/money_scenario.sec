/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "util/format/tests/money_scenario.seh"
#include "util/format/money_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "atl/double.h"


/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/
static const int maxSize=1024; 
/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context;
static VoidTPtr buffer; 
static StringTPtr buf;
static StringTPtr fmt;


bool checkStrfmon(String* expRet,String* format,DoubleList* args)
{
    IntT ret;
    const IntT fmtsizemax=100;
    writeString_VoidTPtr(fmt,format);
    ret=strfmon_spec(context,&buf,fmtsizemax,fmt,args,requestErrorCode());
    return equals(expRet,readString_VoidTPtr(buf));
}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_money_scenario(int argc, char** argv)
{
    // Init test scenario data
    context = getContext();  
    buffer=allocateMemoryBlock(context,maxSize);
    fmt=allocateMemoryBlock(context,maxSize);
    buf=allocateMemoryBlock(context,maxSize);
    return true;
}
static void finish_money_scenario(void)
{
    if(!isNULL_VoidTPtr(buffer))
        deallocateMemoryBlock(context, buffer);
    if(!isNULL_VoidTPtr(fmt))
        deallocateMemoryBlock(context, fmt);
    if(!isNULL_VoidTPtr(buf))
        deallocateMemoryBlock(context,buf);

    TEST_SCENARIO_VERDICT_VERBOSE(money_scenario);
}
/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/
scenario
bool strfmon_scen()
{
    DoubleList* lst;

    INIT_REQ_SCEN;

    lst=create_DoubleList(create_List(&type_DoubleTObj));
    /*
        * The format is a character string, beginning and ending in its initial state, if 
        * any, that contains two types of objects:
        * 
        * plain characters, which are simply copied to the output stream
    */
    add_List(lst->data,0,create_DoubleTObj(12.34));
    REQ_SCEN("strfmon.03.01","Checks that plain characters are simply copied",checkStrfmon(create_String("abcabc"),create_String("abcabc"),lst));
    
    /*
        * The format is a character string, beginning and ending in its initial state, if 
        * any, that contains two types of objects:
        *
        * conversion specifications, each of which shall result in the fetching of zero 
        * or more arguments which are converted and formatted.
    */
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(123.45));
    REQ_SCEN("strfmon.03.02", "Checks that conversation specifications result the arguments", checkStrfmon(create_String("123.45"),create_String("%n"),lst));
    /*
        * If the format is exhausted while arguments remain, the excess arguments are 
        * simply ignored.
    */
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(123.45));
    add_List(lst->data,1,create_DoubleTObj(567.89));
    add_List(lst->data,2,create_DoubleTObj(123.45));
    REQ_SCEN("strfmon.05", "Checks that that excess arguments are ignored", checkStrfmon(create_String("123.45"),create_String("%n"),lst));


   

    /*
        * The conversion specifier characters and their meanings are:
        * 
        * % 
        * 
        * Convert to a '%' ; no argument is converted. The entire conversion 
        * specification shall be %%. 
    */
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(123.45));
    add_List(lst->data,1,create_DoubleTObj(12.00));
    REQ_SCEN("strfmon.conversion.03", "Checks %% conversion specification",checkStrfmon(create_String("%123.45"),create_String("%%%n"),lst) );
    
    /*
        * One or more of the following optional flags can be specified to control the 
        * conversion:
        * 
        * =f 
        * 
        * An '=' followed by a single character f which is used as the numeric fill 
        * character. In order to work with precision or width counts, the fill character 
        * shall be a single byte character; if not, the behavior is undefined. The 
        * default numeric fill character is the <space>. This flag does not affect 
        * field width filling which always uses the <space>. This flag is ignored 
        * unless a left precision (see below) is specified. 
    */
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(123.45));
    add_List(lst->data,1,create_DoubleTObj(123.45));
    REQ_SCEN("strfmon.flags.01", "Checks the = conversion symbol", checkStrfmon(create_String("123.45 **123.45"),create_String("%=*n%=*#5n"),lst));
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(-123.45));
    REQ_SCEN("strfmon.flags.01", "Checks the = conversion symbol", checkStrfmon(create_String("-**123.45"),create_String("%=*#5n"),lst));
    
    
    /*
        * One or more of the following optional flags can be specified to control the 
        * conversion:
        * 
        * ^ 
        * 
        * Do not format the currency amount with grouping characters. The default is to 
        * insert the grouping characters if defined for the current locale. 
        */
        
    // in POSIX locale  mon_grouping   -1(empty)   so this requirement must be checked not in the POSIX locale
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(3456.78));
    REQ_SCEN("strfmon.flags.02", "Checks the ^ conversion symbol",checkStrfmon(create_String("3456.78"),create_String("%^n"),lst));
    
    
    /*
        * One or more of the following optional flags can be specified to control the 
        * conversion:
        * 
        * + or ( 
        * 
        * Specify the style of representing positive and negative currency amounts. Only 
        * one of '+' or '(' may be specified. If '+' is specified, the locale's 
        * equivalent of '+' and '-' are used (for example, in the U.S., the empty string 
        * if positive and '-' if negative). If '(' is specified, negative amounts are 
        * enclosed within parentheses. If neither flag is specified, the '+' style is 
        * used. 
    */
         
    // WORKS only in POSIX locale
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(12.0));
    add_List(lst->data,1,create_DoubleTObj(-12.0));
    add_List(lst->data,2,create_DoubleTObj(12.0));
    add_List(lst->data,3,create_DoubleTObj(-12.0));
    REQ_SCEN("strfmon.flags.03", "Checks + or ( conversion symbol", checkStrfmon(create_String("12.00(12.00)12.00-12.00"),create_String("%(n%(n%+n%+n"),lst));
        
     
    /*
        * One or more of the following optional flags can be specified to control the 
        * conversion:
        * 
        * ! 
        * 
        * Suppress the currency symbol from the output conversion. 
    */
    
    //  in POSIX locale currency symbol is empty
    clear_List(lst->data);
    add_List(lst->data,0,create_DoubleTObj(123.45)); 
    REQ_SCEN("strfmon.flags.04", "Checks the ! conversion symbol", checkStrfmon(create_String("123.45"),create_String("%!n"),lst));

    
    /*
        * One or more of the following optional flags can be specified to control the 
        * conversion:
        * 
        * - 
        * 
        * Specify the alignment. If this flag is present the result of the conversion is 
        * left-justified (padded to the right) rather than right-justified. This flag 
        * shall be ignored unless a field width (see below) is specified. 
    */
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    REQ_SCEN("strfmon.flags.05", "Checks the - conversion symbol", checkStrfmon(create_String("12.00 "),create_String("%-6n"),lst));
    
    
    /*
        * #n 
        * 
        * A '#' followed by a decimal digit string n specifying a maximum number of 
        * digits expected to be formatted to the left of the radix character. This 
        * option can be used to keep the formatted output from multiple calls to the 
        * strfmon() function aligned in the same columns. It can also be used to fill 
        * unused positions with a special character as in "$***123.45". This 
        * option causes an amount to be formatted as if it has the number of digits 
        * specified by n.
    */
    // only in POSIX locale
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    REQ_SCEN("strfmon.lprecision.01", "Checks the # conversion symbol", checkStrfmon(create_String("    12.00"),create_String("%#5n"),lst));
    
    
    
    /*
        * #n 
        * 
        * If more than n digit positions are required, this conversion specification is 
        * ignored.
        */
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(123.0));  
    add_List(lst->data,1,create_DoubleTObj(123.0));     
    REQ_SCEN("strfmon.lprecision.02", "Checks that if more than n digit positions are requred this conversion is ignored",checkStrfmon(create_String(" 123.00  123.00"),create_String("%#1n%#4n"),lst));    
    /*
        * #n 
        * 
        * Digit positions in excess of those actually required are filled with the 
        * numeric fill character (see the =f flag above). 
    */
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    REQ_SCEN("strfmon.lprecision.03", "Checks that digit positions in excess are filled with fill character", checkStrfmon(create_String(" ***12.00"),create_String("%=*#5n"),lst));

    /*
        * #n 
        * 
        * Grouping separators are not applied to fill characters even if the fill 
        * character is a digit.
    */
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    REQ_SCEN("strfmon.lprecision.05", "Checks that grouping separator is not applied to fill characters", checkStrfmon(create_String(" 444412.00"),create_String("%=4#6n"),lst));

    /*
        * #n 
        * 
        * To ensure alignment, any characters appearing before or after the number in the 
        * formatted output such as currency or sign symbols are padded as necessary with 
        * <space>s to make their positive and negative formats an equal length.
    */
         
    // in POSIX locale currency symbol is empty so 1 half of this requirement cant be checked
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    add_List(lst->data,1,create_DoubleTObj(-12.0)); 
    REQ_SCEN("strfmon.lprecision.06", "Checks that currency or sign symbols are padded",checkStrfmon(create_String(" ***12.00-***12.00"),create_String("%=*#5n%=*#5n"),lst));

    /*
        * .p 
        * 
        * A period followed by a decimal digit string p specifying the number of digits 
        * after the radix character. If the value of the right precision p is 0, no 
        * radix character appears. If a right precision is not included, a default 
        * specified by the current locale is used. The amount being formatted is rounded 
        * to the specified number of digits prior to formatting. 
    */
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    add_List(lst->data,1,create_DoubleTObj(12.0)); 
    add_List(lst->data,2,create_DoubleTObj(12.0)); 
    add_List(lst->data,3,create_DoubleTObj(12.0)); 
    REQ_SCEN("strfmon.rprecision", "Checks the right precision", checkStrfmon(create_String("1212.012.00012.00"),create_String("%.0n%.1n%.3n%n"),lst));

    /*
        * w 
        * 
        * A decimal digit string w specifying a minimum field width in bytes in which the 
        * result of the conversion is right-justified (or left-justified if the flag '-' 
        * is specified). The default is 0. 
    */
    clear_List(lst->data); 
    add_List(lst->data,0,create_DoubleTObj(12.0)); 
    add_List(lst->data,1,create_DoubleTObj(12.0)); 
    add_List(lst->data,2,create_DoubleTObj(12.0)); 
    REQ_SCEN("strfmon.width", "Checks the minimum field width", checkStrfmon(create_String(" 12.0012.00  12.00"),create_String("%6n%1n%7n"),lst));
    
    VERDICT_REQ_SCEN;
    return true;
}
/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm money_scenario =
{
    .init = init_money_scenario,
    .finish = finish_money_scenario,
    .actions = { 
                    strfmon_scen,
                    NULL 
                }
};

#ifdef FORMAT_MONEY_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "util/format/money_media.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initUtilFormatMoneySubsystem();
}


bool main_util_format_money(int argc, char** argv)
{
    addTraceToFile("trace.xml");
    money_scenario(argc,argv);
    return true;
}


int main(int argc, char** argv)
{
    //
    initTestSystem();
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    main_util_format_money(argc,argv);

    //  unloadSUT();
    return 0;
}


#endif
