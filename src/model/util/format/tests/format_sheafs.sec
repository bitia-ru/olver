/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdarg.h>
#include "util/format/tests/format_sheafs.seh"
#include "process/process/process_common.seh"

/********************************************************************/
/**                          Sheaf Atoms                           **/
/********************************************************************/

specification typedef struct PrintedSheafAtom  PrintedSheafAtom  = {};
specification typedef struct WprintedSheafAtom WprintedSheafAtom = {};
specification typedef struct ScanedSheafAtom   ScanedSheafAtom   = {};
specification typedef struct WscanedSheafAtom  WscanedSheafAtom  = {};

/* ... == "reqId1", ..., "reqIdn", NULL */
PrintedSheafAtom * create_PrintedSheafAtom( char * format, Object * data, bool mustBeLast, char * result, ... ) {
    List /* String */ * reqIds = create_List( & type_String );
    char * reqId;
    va_list list;
    va_start( list, result );
    while ( ( reqId = va_arg( list, char * ) ) != NULL ) { append_List( reqIds, create_String( reqId ) ); }
    va_end( list );
    return create( & type_PrintedSheafAtom, create_CString( format ), data, create_CString( result ), mustBeLast, reqIds );
}

/* ... == "reqId1", ..., "reqIdn", NULL */
WprintedSheafAtom * create_WprintedSheafAtom( char * format, Object * data, bool mustBeLast, char * result, ... ) {
    List /* String */ * reqIds = create_List( & type_String );
    char * reqId;
    va_list list;
    va_start( list, result );
    while ( ( reqId = va_arg( list, char * ) ) != NULL ) { append_List( reqIds, create_String( reqId ) ); }
    va_end( list );
    return create
               ( & type_WprintedSheafAtom, createW_String( format ), data, createW_String( result ), mustBeLast, reqIds );
}

/* ... == "reqId1", ..., "reqIdn", NULL */
ScanedSheafAtom * create_ScanedSheafAtom( char * format, Object * result, Object * place, char * data, ... ) {
    List /* String */ * reqIds = create_List( & type_String );
    char * reqId;
    va_list list;
    va_start( list, data );
    assertion( ( result == NULL && place == NULL                                    ) ||
               ( result != NULL && place != NULL && type( result ) == type( place ) ),
               "create_ScanedSheafAtom : type( result ) != type( place )"
             );
    while ( ( reqId = va_arg( list, char * ) ) != NULL ) { append_List( reqIds, create_String( reqId ) ); }
    va_end( list );
    // verbose( "create_ScanedSheafAtom : result is %sNULL\n", result != NULL ? "not " : "" );
    return create( & type_ScanedSheafAtom, create_CString( format ), create_CString( data ), result, place, reqIds );
}

/* ... == "reqId1", ..., "reqIdn", NULL */
WscanedSheafAtom * create_WscanedSheafAtom( char * format, Object * result, Object * place, char * data, ... ) {
    List /* String */ * reqIds = create_List( & type_String );
    char * reqId;
    va_list list;
    va_start( list, data );
    assertion( ( result == NULL && place == NULL                                    ) ||
               ( result != NULL && place != NULL && type( result ) == type( place ) ),
               "create_WscanedSheafAtom : type( result ) != type( place )"
             );
    while ( ( reqId = va_arg( list, char * ) ) != NULL ) { append_List( reqIds, create_String( reqId ) ); }
    va_end( list );
    // verbose( "create_WscanedSheafAtom : result is %sNULL\n", result != NULL ? "not " : "" );
    return create( & type_WscanedSheafAtom, createW_String( format ), createW_String( data ), result, place, reqIds );
}

/********************************************************************/
/**                              Sheaf                             **/
/********************************************************************/

specification typedef struct PrintedSheaf  PrintedSheaf  = {};
specification typedef struct WprintedSheaf WprintedSheaf = {};
specification typedef struct ScanedSheaf   ScanedSheaf   = {};
specification typedef struct WscanedSheaf  WscanedSheaf  = {};

PrintedSheaf * create_PrintedSheaf( void )
{
    return create( & type_PrintedSheaf,
                   create_CString( "" ), create_List( NULL ), create_CString( "" ), create_List( & type_String )
                 );
}

WprintedSheaf * create_WprintedSheaf( void )
{
    return create( & type_WprintedSheaf,
                   createW_String( "" ), create_List( NULL ), createW_String( "" ), create_List( & type_String )
                 );
}

ScanedSheaf * create_ScanedSheaf( void )
{
    return create( & type_ScanedSheaf, create_CString( "" ), create_CString( "" ),
                                       create_List( NULL ), create_List( NULL ), create_List( & type_String )
                 );
}

WscanedSheaf * create_WscanedSheaf( void )
{
    return create( & type_WscanedSheaf, createW_String( "" ), createW_String( "" ),
                                        create_List( NULL ), create_List( NULL ), create_List( & type_String )
                 );
}

PrintedSheaf * append_PrintedSheaf( PrintedSheaf * self, PrintedSheafAtom * x ) {
    int i;
    self->format = concat_CString( self->format, x->formatFragment );
    if ( x->data != NULL ) { append_List( self->data, x->data ); }
    self->result = concat_CString( self->result, x->resultFragment );
    for ( i = 0; i < size_List( x->reqIds ); i++ ) {
        String * reqId = get_List( x->reqIds, i );
        if ( ! contains_List( self->reqIds, reqId ) ) { append_List( self->reqIds, reqId ); }
    }
    return self;
}

WprintedSheaf * append_WprintedSheaf( WprintedSheaf * self, WprintedSheafAtom * x ) {
    int i;
    self->format = concat_WString( self->format, x->formatFragment );
    if ( x->data != NULL ) { append_List( self->data, x->data ); }
    self->result = concat_WString( self->result, x->resultFragment );
    for ( i = 0; i < size_List( x->reqIds ); i++ ) {
        String * reqId = get_List( x->reqIds, i );
        if ( ! contains_List( self->reqIds, reqId ) ) { append_List( self->reqIds, reqId ); }
    }
    return self;
}

ScanedSheaf * append_ScanedSheaf( ScanedSheaf * self, ScanedSheafAtom * x ) {
    int i;
    self->format = concat_CString( self->format, x->formatFragment );
    self->data = concat_CString( self->data, x->data );
    // verbose( "append_ScanedSheaf : x->resultFragment is %sNULL\n", x->resultFragment != NULL ? "not " : "" );
    if ( x->resultFragment != NULL ) { append_List( self->result, x->resultFragment ); }
    if ( x->placeFragment  != NULL ) { append_List( self->place , x->placeFragment  ); }
    for ( i = 0; i < size_List( x->reqIds ); i++ ) {
        String * reqId = get_List( x->reqIds, i );
        if ( ! contains_List( self->reqIds, reqId ) ) { append_List( self->reqIds, reqId ); }
    }
    return self;
}

WscanedSheaf * append_WscanedSheaf( WscanedSheaf * self, WscanedSheafAtom * x ) {
    int i;
    self->format = concat_WString( self->format, x->formatFragment );
    self->data = concat_WString( self->data, x->data );
    // verbose( "append_WscanedSheaf : x->resultFragment is %sNULL\n", x->resultFragment != NULL ? "not " : "" );
    if ( x->resultFragment != NULL ) { append_List( self->result, x->resultFragment ); }
    if ( x->placeFragment  != NULL ) { append_List( self->place , x->placeFragment  ); }
    for ( i = 0; i < size_List( x->reqIds ); i++ ) {
        String * reqId = get_List( x->reqIds, i );
        if ( ! contains_List( self->reqIds, reqId ) ) { append_List( self->reqIds, reqId ); }
    }
    return self;
}
