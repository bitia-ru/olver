/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "util/format/fmtmsg_model.seh"


#pragma SEC subsystem format "util.format"



/*
   The group of functions 'util.format.fmtmsg' consists of:
       fmtmsg [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fmtmsg - display a message in the specified format on standard error and/or
    a system console

SYNOPSIS

    [XSI]  #include <fmtmsg.h>

    int fmtmsg(long classification, const char *label, int severity,
        const char *text, const char *action, const char *tag);

DESCRIPTION

    The fmtmsg() function shall display messages in a specified format instead
    of the traditional printf() function.

    Based on a message's classification component, fmtmsg() shall write a
    formatted message either to standard error, to the console, or to both.

    A formatted message consists of up to five components as defined below. The
    component classification is not part of a message displayed to the user,
    but defines the source of the message and directs the display of the
    formatted message.

        classification
        Contains the sum of identifying values constructed from the constants
        defined below. Any one identifier from a subclass may be used in
        combination with a single identifier from a different subclass. Two or
        more identifiers from the same subclass should not be used together,
        with the exception of identifiers from the display subclass. (Both
        display subclass identifiers may be used so that messages can be
        displayed to both standard error and the system console.)

            Major Classifications
            Identifies the source of the condition. Identifiers are: MM_HARD
            (hardware), MM_SOFT (software), and MM_FIRM (firmware).

            Message Source Subclassifications
            Identifies the type of software in which the problem is detected.
            Identifiers are: MM_APPL (application), MM_UTIL (utility), and
            MM_OPSYS (operating system).

            Display Subclassifications
            Indicates where the message is to be displayed. Identifiers are:
            MM_PRINT to display the message on the standard error stream,
            MM_CONSOLE to display the message on the system console. One or
            both identifiers may be used.

            Status Subclassifications
            Indicates whether the application can recover from the condition.
            Identifiers are: MM_RECOVER (recoverable) and MM_NRECOV
            (non-recoverable).
            An additional identifier, MM_NULLMC, indicates that no
            classification component is supplied for the message.

    label
    Identifies the source of the message. The format is two fields separated by
    a colon. The first field is up to 10 bytes, the second is up to 14 bytes.

    severity
    Indicates the seriousness of the condition. Identifiers for the levels of
    severity are:

        MM_HALT
        Indicates that the application has encountered a severe fault and is
        halting. Produces the string "HALT".

        MM_ERROR
        Indicates that the application has detected a fault. Produces the
        string "ERROR".

        MM_WARNING
        Indicates a condition that is out of the ordinary, that might be a
        problem, and should be watched. Produces the string "WARNING".

        MM_INFO
        Provides information about a condition that is not in error. Produces
        the string "INFO".

        MM_NOSEV
        Indicates that no severity level is supplied for the message.

    text
    Describes the error condition that produced the message. The character
    string is not limited to a specific size.If the character string is empty,
    then the text produced is unspecified.

    action
    Describes the first step to be taken in the error-recovery process. The
    fmtmsg() function precedes the action string with the prefix: "TO FIX:".
    The action string is not limited to a specific size.

    tag
    An identifier that references on-line documentation for the message.
    Suggested usage is that tag includes the label and a unique identifying
    number. A sample tag is "XSI:cat:146".

    The MSGVERB environment variable (for message verbosity) shall determine
    for fmtmsg() which message components it is to select when writing messages
    to standard error. The value of MSGVERB shall be a colon-separated list of
    optional keywords. Valid keywords are: label, severity, text, action, and
    tag. If MSGVERB contains a keyword for a component and the component's
    value is not the component's null value, fmtmsg() shall include that
    component in the message when writing the message to standard error.If
    MSGVERB does not include a keyword for a message component, that component
    shall not be included in the display of the message. The keywords may
    appear in any order.If MSGVERB is not defined, if its value is the null
    string, if its value is not of the correct format, or if it contains
    keywords other than the valid ones listed above, fmtmsg() shall select all
    components.

    MSGVERB shall determine which components are selected for display to
    standard error. All message components shall be included in console
    messages.

RETURN VALUE

    The fmtmsg() function shall return one of the following values:

        MM_OK
        The function succeeded.

        MM_NOTOK
        The function failed completely.

        MM_NOMSG
        The function was unable to generate a message on standard error, but
        otherwise succeeded.

        MM_NOCON
        The function was unable to generate a console message, but otherwise
        succeeded.

ERRORS

        None.
*/
specification typedef struct FmtmsgReturnType FmtmsgReturnType = {};

FmtmsgReturnType * create_FmtmsgReturnType(
    IntT funcRes,
    CString* resStr
)
{
    return create(&type_FmtmsgReturnType,
        funcRes,
        resStr);
}

specification typedef struct MsgClassAndSeverity MsgClassAndSeverity = {};

specification
FmtmsgReturnType* fmtmsg_spec( CallContext context, MsgClassAndSeverity* clsf, CString* label1, CString* label2, CString* text, CString* action, CString* tag)
{
    pre
    {
        /*
        * If the character string is empty, then the text produced is unspecified.
        */
        REQ("app.fmtmsg.08.03", "Text string shall not be empty", length_CString(text)!=0);

        /*
         * classification
         *
         * Two or more identifiers from the same subclass should not be used together,
         * with the exception of identifiers from the display subclass.
         */
        /*
         * classification
         *
         * Any one identifier from a subclass may be used in combination with a single
         * identifier from a different subclass.
         */
        /*
         * classification
         *
         * Major Classifications
         *
         * Identifies the source of the condition. Identifiers are: MM_HARD (hardware),
         * MM_SOFT (software), and MM_FIRM (firmware).
         */
        /*
         * classification
         *
         * Message Source Subclassifications
         *
         * Identifiers are: MM_APPL (application), MM_UTIL (utility), and
         * MM_OPSYS (operating system).
         */
        /*
         * classification
         *
         * Status Subclassifications
         *
         * Identifiers are: MM_RECOVER (recoverable) and MM_NRECOV (non-recoverable).
         */
        /*
         * classification
         *
         * An additional identifier, MM_NULLMC, indicates that no classification component
         * is supplied for the message.
         */
        REQ("app.fmtmsg.05.03;app.fmtmsg.05.02;fmtmsg.05.05.01;fmtmsg.05.06.02;fmtmsg.05.08.02;fmtmsg.05.09", "Message classification shall be valid",
            (((clsf->majorClass==SUT_MM_HARD || clsf->majorClass==SUT_MM_SOFT || clsf->majorClass==SUT_MM_FIRM)
            &&
            (clsf->messageSource==SUT_MM_APPL || clsf->messageSource==SUT_MM_UTIL || clsf->messageSource==SUT_MM_OPSYS)
            &&
            (clsf->messageStatus==SUT_MM_RECOVER || clsf->messageStatus==SUT_MM_NRECOV))
            ||
            (clsf->majorClass==0 && clsf->messageSource==0 && clsf->messageStatus==0))
            &&
            (clsf->messageSeverity==SUT_MM_HALT || clsf->messageSeverity==SUT_MM_ERROR || clsf->messageSeverity==SUT_MM_WARNING || clsf->messageSeverity==SUT_MM_INFO || clsf->messageSeverity==SUT_MM_NOSEV));

        /*
         * label
         *
         * The first field is up to 10 bytes, the second is up to 14 bytes.
         */
        REQ("app.fmtmsg.06.03", "The first field is up to 10 bytes, the second is up to 14 bytes", length_CString(label1)<=10 && length_CString(label2)<=14);

        return true;
    }
    post
    {
        if (fmtmsg_spec->funcRes == SUT_EOK)
        {
            CString* model_res = fmtmsg_model(clsf, label1, label2, text, action, tag);

            /*
             * The fmtmsg() function shall display messages in a specified format instead of
             * the traditional printf() function.
             */
            REQ("fmtmsg.01", "String printed shall be valid", compare_CStrings_NoSpaces(model_res, fmtmsg_spec->resStr)==0);

            /*
             * The MSGVERB environment variable (for message verbosity) shall determine for
             * fmtmsg() which message components it is to select when writing messages to
             * standard error.
             */
            REQ("fmtmsg.11", "", TODO_REQ());

            /*
             * The value of MSGVERB shall be a colon-separated list of optional keywords.
             */
            REQ("fmtmsg.12", "", TODO_REQ());

            /*
             * Valid keywords are: label, severity, text, action, and tag.
             */
            REQ("fmtmsg.13", "", TODO_REQ());

            /*
             * If MSGVERB contains a keyword for a component and the component's value is not
             * the component's null value, fmtmsg() shall include that component in the
             * message when writing the message to standard error.
             */
            REQ("fmtmsg.14", "", TODO_REQ());

            /*
             * If MSGVERB does not include a keyword for a message component, that component
             * shall not be included in the display of the message.
             */
            REQ("fmtmsg.15", "", TODO_REQ());

            /*
             * The keywords may appear in any order.
             */
            REQ("fmtmsg.16", "", TODO_REQ());

            /*
             * If MSGVERB is not defined, if its value is the null string, if its value is not
             * of the correct format, or if it contains keywords other than the valid ones
             * listed above, fmtmsg() shall select all components.
             */
            REQ("fmtmsg.17", "", TODO_REQ());

            /*
             * MSGVERB shall determine which components are selected for display to standard
             * error.
             */
            REQ("fmtmsg.18", "", TODO_REQ());

            /*
             * ll message components shall be included in console messages.
             */
            REQ("fmtmsg.19", "", TODO_REQ());


        }
        else
        {

            /*
             * The fmtmsg() function shall return one of the following values:
             *
             * MM_NOTOK The function failed completely.
             */
            /*
             * The fmtmsg() function shall return one of the following values:
             *
             * MM_NOMSG The function was unable to generate a message on standard error, but
             * otherwise succeeded.
             */

            /*
             * The fmtmsg() function shall return one of the following values:
             *
             * MM_NOCON The function was unable to generate a console message, but otherwise
             * succeeded.
             */
            REQ("fmtmsg.20.02;fmtmsg.20.03;fmtmsg.20.04", "Return value on error shall be valid", fmtmsg_spec->funcRes == SUT_MM_NOTOK
                || fmtmsg_spec->funcRes == SUT_MM_NOMSG ||  fmtmsg_spec->funcRes == SUT_MM_NOCON);
        }

        return true;
    }
}

CString* fmtmsg_model(MsgClassAndSeverity* clsf, CString* label1, CString* label2, CString* text, CString* action, CString* tag)
{
    CString* res=create_CString("");

    res=concat_CString(res, label1);
    res=concat_CString(res, create_CString(":"));
    res=concat_CString(res, label2);
    res=concat_CString(res, create_CString(":"));


    if (clsf->messageSeverity==SUT_MM_HALT)
    {
         /*
         * severity
         *
         * Indicates the seriousness of the condition. Identifiers for the levels of
         * severity are:
         *
         * MM_HALT Indicates that the application has encountered a severe fault and is
         * halting. Produces the string "HALT".
         */
        IMPLEMENT_REQ("fmtmsg.07.01.01");

        res=concat_CString(res, create_CString("HALT:"));
    }
    else if (clsf->messageSeverity==SUT_MM_ERROR)
    {
         /*
         * severity
         *
         * Indicates the seriousness of the condition. Identifiers for the levels of
         * severity are:
         *
         * MM_ERROR Indicates that the application has detected a fault. Produces the
         * string "ERROR".
         */
        IMPLEMENT_REQ("fmtmsg.07.01.02");

        res=concat_CString(res, create_CString("ERROR:"));
    }
    else if (clsf->messageSeverity==SUT_MM_WARNING )
    {
        /*
         * severity
         *
         * Indicates the seriousness of the condition. Identifiers for the levels of
         * severity are:
         *
         * MM_WARNING Indicates a condition that is out of the ordinary, that might be a
         * problem, and should be watched. Produces the string "WARNING".
         */
        IMPLEMENT_REQ("fmtmsg.07.01.03");

        res=concat_CString(res, create_CString("WARNING:"));
    }
    else if (clsf->messageSeverity==SUT_MM_INFO )
    {
        /*
         * severity
         *
         * Indicates the seriousness of the condition. Identifiers for the levels of
         * severity are:
         *
         * MM_INFO Provides information about a condition that is not in error. Produces
         * the string "INFO".
         */
        IMPLEMENT_REQ("fmtmsg.07.01.04");

        res=concat_CString(res, create_CString("INFO:"));
    }
    else if (clsf->messageSeverity==SUT_MM_NOSEV)
    {
        /*
         * severity
         *
         * Indicates the seriousness of the condition. Identifiers for the levels of
         * severity are:
         *
         * MM_NOSEV Indicates that no severity level is supplied for the message.
         */
        IMPLEMENT_REQ("fmtmsg.07.01.05");

        res = res;
    }
    else
    {
        setBadVerdict("Invalid message severity");
    }

    res=concat_CString(res, text);

    /*
     * action
     *
     * The fmtmsg() function precedes the action string with the prefix: "TO FIX:".
     */
    IMPLEMENT_REQ("fmtmsg.09.02");

    res=concat_CString(res, create_CString("TO FIX:"));

    res=concat_CString(res, action);

    res=concat_CString(res, tag);

    return res;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

CString* removeSpaces(CString* str)
{
    CString* res=create_CString("");
    IntT i=0;

    for (i=0;i<length_CString(str);i++)
    {
        CharT curCh=charAt_CString(str, i);
        if (!isspace(curCh) && curCh!='\n' && curCh!='\r')
        {
            res = concatChar_CString(res, curCh);
        }
    }
    return res;
}


bool compare_CStrings_NoSpaces(CString* str1, CString* str2)
{
    CString* s1=removeSpaces(str1);
    CString* s2=removeSpaces(str2);

    return compare(s1, s2);
}


MsgClassAndSeverity* create_MsgClassAndSeverity(IntT majorClass, IntT messageSource, IntT messageStatus, IntT messageSeverity)
{
    return create(&type_MsgClassAndSeverity, majorClass, messageSource, messageStatus, messageSeverity);
}
