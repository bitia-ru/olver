/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "util/format/money_model.seh"

#include <atl/integer.h>
#include "common/pointer.seh"

#include "config/interpretation.seh"
#include "util/format/money_config.h"
#include "data/errno_model.seh"
#include "config/system_config.seh"

#pragma SEC subsystem format "util.format"


/* 
   The group of functions 'util.format.money' consists of: 
       strfmon [2]
 */
/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strfmon - convert monetary value to a string

SYNOPSIS

    [XSI] #include <monetary.h>

    ssize_t strfmon(char *restrict s, size_t maxsize,

    const char *restrict format, ...);

DESCRIPTION

    The strfmon() function shall place characters into the array pointed to by s as
    controlled by the string pointed to by format. No more than maxsize bytes are
    placed into the array.

    The format is a character string, beginning and ending in its initial state, if
    any, that contains two types of objects: plain characters, which are simply
    copied to the output stream, and conversion specifications, each of which shall
    result in the fetching of zero or more arguments which are converted and
    formatted. The results are undefined if there are insufficient arguments for
    the format. If the format is exhausted while arguments remain, the excess
    arguments are simply ignored.

    The application shall ensure that a conversion specification consists of the
    following sequence:

    * A '%' character

    * Optional flags

    * Optional field width

    * Optional left precision

    * Optional right precision

    * A required conversion specifier character that determines the conversion to
    be performed

    Flags One or more of the following optional flags can be specified to control
    the conversion:

    =f An '=' followed by a single character f which is used as the numeric fill
    character. In order to work with precision or width counts, the fill character
    shall be a single byte character; if not, the behavior is undefined. The
    default numeric fill character is the <space>. This flag does not affect
    field width filling which always uses the <space>. This flag is ignored
    unless a left precision (see below) is specified.

    ^ Do not format the currency amount with grouping characters. The default is to
    insert the grouping characters if defined for the current locale.

    + or ( Specify the style of representing positive and negative currency amounts.
    Only one of '+' or '(' may be specified. If '+' is specified, the locale's
    equivalent of '+' and '-' are used (for example, in the U.S., the empty string
    if positive and '-' if negative). If '(' is specified, negative amounts are
    enclosed within parentheses. If neither flag is specified, the '+' style is
    used.

    ! Suppress the currency symbol from the output conversion.

    - Specify the alignment. If this flag is present the result of the conversion
    is left-justified (padded to the right) rather than right-justified. This flag
    shall be ignored unless a field width (see below) is specified.

    Field Width w A decimal digit string w specifying a minimum field width in
    bytes in which the result of the conversion is right-justified (or left-
    justified if the flag '-' is specified). The default is 0.

    Left Precision #n A '#' followed by a decimal digit string n specifying a
    maximum number of digits expected to be formatted to the left of the radix
    character. This option can be used to keep the formatted output from multiple
    calls to the strfmon() function aligned in the same columns. It can also be
    used to fill unused positions with a special character as in "$***123.45". This
    option causes an amount to be formatted as if it has the number of digits
    specified by n. If more than n digit positions are required, this conversion
    specification is ignored. Digit positions in excess of those actually required
    are filled with the numeric fill character (see the =f flag above). If grouping
    has not been suppressed with the '^' flag, and it is defined for the current
    locale, grouping separators are inserted before the fill characters (if any)
    are added. Grouping separators are not applied to fill characters even if the
    fill character is a digit.

    To ensure alignment, any characters appearing before or after the number in the
    formatted output such as currency or sign symbols are padded as necessary with &
    lt;space>s to make their positive and negative formats an equal length.

    Right Precision .p A period followed by a decimal digit string p specifying the
    number of digits after the radix character. If the value of the right precision
    p is 0, no radix character appears. If a right precision is not included, a
    default specified by the current locale is used. The amount being formatted is
    rounded to the specified number of digits prior to formatting.

    Conversion Specifier Characters The conversion specifier characters and their
    meanings are:

    i The double argument is formatted according to the locale's international
    currency format (for example, in the U.S.: USD 1,234.56). If the argument is ±
    Inf or NaN, the result of the conversion is unspecified.

    n The double argument is formatted according to the locale's national currency
    format (for example, in the U.S.: $1,234.56). If the argument is ±Inf or NaN,
    the result of the conversion is unspecified.

    % Convert to a '%' ; no argument is converted. The entire conversion
    specification shall be %%.

    Locale Information The LC_MONETARY category of the program's locale affects the
    behavior of this function including the monetary radix character (which may be
    different from the numeric radix character affected by the LC_NUMERIC
    category), the grouping separator, the currency symbols, and formats. The
    international currency symbol should be conformant with the ISO 4217:2001
    standard.

    If the value of maxsize is greater than {SSIZE_MAX}, the result is
    implementation-defined.

RETURN VALUE

    If the total number of resulting bytes including the terminating null byte is
    not more than maxsize, strfmon() shall return the number of bytes placed into
    the array pointed to by s, not including the terminating null byte. Otherwise, -
    1 shall be returned, the contents of the array are unspecified, and errno shall
    be set to indicate the error.

ERRORS

    The strfmon() function shall fail if:

    [E2BIG] Conversion stopped due to lack of space in the buffer.
*/

bool CheckStrfmonReq2(StringTPtr s, IntT maxsize);
bool CheckStrfmonReq4(StringTPtr format, DoubleList* parameters);
bool CheckStrfmonReq6(StringTPtr format);

specification
IntT strfmon_spec( CallContext context, StringTPtr* s, IntT maxsize,
                  StringTPtr format, DoubleList* parameters, ErrorCode* errno)
{
    pre
    {

        /*
            * The results are undefined if there are insufficient arguments for the format. 
        */
        REQ("app.strfmon.04", "Checks if there are  insufficient arguments", CheckStrfmonReq4(format,parameters));

        /*
            * The application shall ensure that a conversion specification consists of the 
            * following sequence: 
            * 
            * A '%' character 
            * 
            * Optional flags 
            * 
            * Optional field width 
            * 
            * Optional left precision 
            * 
            * Optional right precision 
            * 
            * A required conversion specifier character that determines the conversion to be 
            * performed 
        */    
        REQ("app.strfmon.06", "Checks the order of conversion characters", CheckStrfmonReq6(format));
        /*
            * If the value of maxsize is greater than {SSIZE_MAX}, the result is 
            * implementation-defined.
        */
        REQ("app.strfmon.locale.02", "Checks maxsize", maxsize < max_SSizeT);

        return true;
    }
    coverage MaxSizeCoverage
    {
        if (maxsize>0)
            return { PositiveMaxSize, "Max Size is greater than 0" };
        else
            if (maxsize==0)
            {
                 return { NullMaxSize, "Max Size is 0" };
            }
    }
    post
    {
        ERROR_BEGIN(POSIX_STRFMON, "strfmon.error", strfmon_spec==-1,  *errno )
        /*
            * The strfmon() function shall fail if:
            * 
            * [E2BIG] 
            * 
            * Conversion stopped due to lack of space in the buffer. 
        */
        ERROR_SHALL(POSIX_STRFMON, E2BIG, "strfmon.error.01", TODO_ERR(E2BIG))
            
        ERROR_END()
    /*
        * No more than maxsize bytes are placed into the array.
    */
    REQ("strfmon.02", "Checks that no more than maxsize bytes are placed", CheckStrfmonReq2(*s,maxsize));
  
    


    /*
        * The LC_MONETARY category of the program's locale affects the behavior of this 
        * function including the monetary radix character (which may be different from 
        * the numeric radix character affected by the LC_NUMERIC category), the grouping 
        * separator, the currency symbols, and formats. The international currency symbol 
        * should be conformant with the ISO 4217:2001 standard.
    */
    REQ("strfmon.locale.01", "Checks that LC_MONETARY category affects strfmon behavior", TODO_REQ());
    /*
         * If the total number of resulting bytes including the terminating null byte is 
         * not more than maxsize, strfmon() shall return the number of bytes placed into 
         * the array pointed to by s, not including the terminating null byte.
    */    
    REQ("strfmon.ret.01", "Checks that number of resulting bytes not more than maxsize", (strfmon_spec+1<=maxsize) && (strfmon_spec==length_CString(readCString_VoidTPtr(*s))));

    /*
         * Otherwise, -1 shall be returned, the contents of the array are unspecified, 
         * and errno shall be set to indicate the error.
    */
    REQ("strfmon.ret.02", "Checks that -1 shall be returned and error shall be set if resulting bytes more than maxsize", strfmon_spec==-1 ? *errno!=0 : *errno==0);
    
    
    
     /*
        # This is the POSIX locale definition for
        # the LC_MONETARY category.
        #
        int_curr_symbol      ""
        currency_symbol      ""
        so it is impossible to check the conversion requirements in POSIX locale.
    /*
    /*
        * The conversion specifier characters and their meanings are:
        * 
        * i 
        * 
        * The double argument is formatted according to the locale's international 
        * currency format (for example, in the U.S.: USD 1,234.56). If the argument is ± 
        * Inf or NaN, the result of the conversion is unspecified. 
    */
    REQ("strfmon.conversion.01", "", TODO_REQ());
      
    /*
        * The conversion specifier characters and their meanings are:
        * 
        * n 
        * 
        * The double argument is formatted according to the locale's national currency 
        * format (for example, in the U.S.: $1,234.56). If the argument is ±Inf or NaN, 
        * the result of the conversion is unspecified. 
    */
    REQ("strfmon.conversion.02", "", TODO_REQ());
    
     /*
        * #n 
        * 
        * If grouping has not been suppressed with the '^' flag, and it is defined for 
        * the current locale, grouping separators are inserted before the fill 
        * characters (if any) are added.
    */
         
    // could not be tested in POSIX locale ... grouping separator is not defined
    REQ("strfmon.lprecision.04", "", TODO_REQ());
    
    return true;
    }
}



/********************************************************************/
/**                       Specification Types                      **/
/********************************************************************/
specification typedef struct DoubleList DoubleList={};

DoubleList* create_DoubleList(List* data)
{
    return create(&type_DoubleList, data);
}



/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/




bool CheckStrfmonReq2(StringTPtr s, IntT maxsize)
{
    /*
        * No more than maxsize bytes are placed into the array.
    */
    CString* mys=readCString_VoidTPtr(s);
    if(length_CString(mys)*sizeof_CharT>maxsize) return false;
    return true;
}
bool CheckStrfmonReq4(StringTPtr format, DoubleList* parameters)
{
    /*
        * The results are undefined if there are insufficient arguments for the format. 
    */

    CString* mys;
    int sizelist;
    char ch;
    int i=0;
    bool open=false;
    int num=0;
    int len=0;
    
    mys=readCString_VoidTPtr(format);
    sizelist=size_List(parameters->data);
    len=length_CString(mys);
    for(i=0;i<len;i++)
    {
        ch=charAt_CString(mys,i);
        if((ch=='%') && !open)
        {
            open=!open;continue;
        }

        if((ch=='i') || (ch=='n') || (ch=='%'))
        {
            if(open) 
            {
                open=!open;num++;
            }
        }
    }
    if(sizelist<num) return false;
    return true;
}

bool CheckStrfmonReq6(StringTPtr format)
{
    CString* mys;
    int len=0;
    int i;
    bool open;
    bool w;
    bool lp;
    bool rp;
    char ch;
    mys=readCString_VoidTPtr(format);
    len=length_CString(mys);
    open=false;
    w=false;
    lp=false;
    rp=false;
    for(i=0;i<len;i++)
    {
        ch=charAt_CString(mys,i);
        switch(ch)
        {
            case '=':
                i++;continue;break;
            case '!':case '+':case '(' : case '^' : case '-':
                if(open) {continue;break;}
            case '#':
                if (open) {lp=true;w=false;rp=false;continue;break;}
            case '.':
                if (open) {rp=true;w=false;lp=false;continue;break;}
            case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':
            if (lp==false && rp==false && w==false && open)
                {w=true;continue;break;}
            if ((w || lp || rp) && open)
                {continue;break;}
            case 'n': case 'i': case '%':
                if (open){open=!open;continue;break;}else {if (ch=='%') {open=true;continue;break;}}
            default:
                if(!open){continue;break;}
        }
        return false;
    }
    return true;
}
