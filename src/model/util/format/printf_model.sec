/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "util/format/printf_model.seh"
#include "common/common_media.seh"
#include "util/format/printf_config.h"

#pragma SEC subsystem format "util.format"

/*
   The group of functions 'util.format.printf' consists of:
       asprintf [1]
       fprintf [2]
       printf [2]
       snprintf [2]
       sprintf [2]
       vasprintf [1]
       vdprintf [1]
       vfprintf [2]
       vprintf [2]
       vsnprintf [2]
       vsprintf [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    asprintf -- write formatted output to a dynamically allocated string

SYNOPSIS

    #include <stdio.h>
    int asprintf(char ** restrict ptr, const char * restrict format, ...);

DESCRIPTION

    The asprintf() function shall behave as sprintf(), except that the output
    string shall be dynamically allocated space of sufficient length to hold the
    resulting string. The address of this dynamically allocated string shall be
    stored in the location referenced by ptr.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT asprintf_spec
         ( CallContext context, StringTPtr * ptr, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "asprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * output;
        if ( asprintf_spec < 0 ) { output = NULL                         ; }
                            else { output = readCString_VoidTPtr( * ptr ); }

        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_ASPRINTF, "asprintf.05.02", asprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( LSB_ASPRINTF, EILSEQ, "asprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_ASPRINTF, EINVAL, "asprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /*
         * The address of this dynamically allocated string shall be stored in the
         * location referenced by ptr.
         */
        REQ( "asprintf.31", "string shall be stored in the location referenced by ptr", ! isNULL_VoidTPtr( * ptr ) );

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "asprintf", format, arguments, asprintf_spec, output, errno ) );

        /*
         * The asprintf() function shall behave as sprintf(), except that the output
         * string shall be dynamically allocated space of sufficient length to hold the
         * resulting string.
         */
        REQ( "asprintf.30", "asprintf() shall behave as sprintf()", true );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fprintf, printf, snprintf, sprintf - print formatted output

SYNOPSIS

    #include <stdio.h>

    int fprintf(FILE *restrict stream, const char *restrict format, ...);
    int printf(const char *restrict format, ...);
    int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
    int sprintf(char *restrict s, const char *restrict format, ...);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT fprintf_spec( CallContext context, FILETPtr * stream, CString * format, List /* NULL */ * arguments,
                   ErrorCode * errno, CString * fileForStreamName, CString * fileForStreamMode
                 )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "fprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * output = freadFile( context, stream, fileForStreamName, fileForStreamMode );

        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( POSIX_FPRINTF, "fprintf.05.02", fprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ]
             * [XSI] A wide-character code that does not correspond to a valid character has
             * been detected.
             */
            ERROR_MAY( POSIX_FPRINTF, EILSEQ, "fprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL]
             * [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_FPRINTF, EINVAL, "fprintf.06.02", TODO_ERR(EINVAL) )

            /*
             * The printf() and fprintf() functions may fail if:
             *
             * [ENOMEM]
             * [XSI] Insufficient storage space is available.
             */
            ERROR_MAY( POSIX_FPRINTF, ENOMEM, "fprintf.07.01", TODO_ERR(ENOMEM) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "fprintf", format, arguments, fprintf_spec, output, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fprintf, printf, snprintf, sprintf - print formatted output

SYNOPSIS

    #include <stdio.h>

    int fprintf(FILE *restrict stream, const char *restrict format, ...);
    int printf(const char *restrict format, ...);
    int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
    int sprintf(char *restrict s, const char *restrict format, ...);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT printf_spec( CallContext context, CString * format, List /* NULL */ * arguments, CString * output, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "printf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( POSIX_PRINTF, "printf.05.02", printf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( POSIX_PRINTF, EILSEQ, "printf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_PRINTF, EINVAL, "printf.06.02", TODO_ERR(EINVAL) )

            /*
             * The printf() and fprintf() functions may fail if:
             *
             * [ENOMEM] [XSI] Insufficient storage space is available.
             */
            ERROR_MAY( POSIX_PRINTF, ENOMEM, "printf.07.01", TODO_ERR(ENOMEM) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "printf", format, arguments, printf_spec, output, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fprintf, printf, snprintf, sprintf - print formatted output

SYNOPSIS

    #include <stdio.h>

    int fprintf(FILE *restrict stream, const char *restrict format, ...);
    int printf(const char *restrict format, ...);
    int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
    int sprintf(char *restrict s, const char *restrict format, ...);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT snprintf_spec
         ( CallContext context, CString * s, SizeT n, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "snprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( POSIX_SNPRINTF, "snprintf.05.02", snprintf_spec < 0, * errno )
            /*
             * The snprintf() function shall fail if:
             *
             * [EOVERFLOW] [XSI] The value of n is greater than {INT_MAX} or the number of
             * bytes needed to hold the output excluding the terminating null is greater than
             * {INT_MAX}.
             */
            ERROR_SHALL( POSIX_SNPRINTF, EOVERFLOW, "snprintf.19.01", TODO_ERR(EOVERFLOW) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( POSIX_SNPRINTF, EILSEQ, "snprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_SNPRINTF, EINVAL, "snprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "snprintf", format, arguments, snprintf_spec, s, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fprintf, printf, snprintf, sprintf - print formatted output

SYNOPSIS

    #include <stdio.h>

    int fprintf(FILE *restrict stream, const char *restrict format, ...);
    int printf(const char *restrict format, ...);
    int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
    int sprintf(char *restrict s, const char *restrict format, ...);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT sprintf_spec( CallContext context, CString * s, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "sprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( POSIX_SPRINTF, "sprintf.05.02", sprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( POSIX_SPRINTF, EILSEQ, "sprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( POSIX_SPRINTF, EINVAL, "sprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "sprintf", format, arguments, sprintf_spec, s, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    vasprintf -- write formatted output to a dynamically allocated string

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vasprintf(char * * restrict ptr, const char * restrict format,
            va_list arg);

DESCRIPTION

    The vasprintf() function shall write formatted output to a dynamically
    allocated string, and store the address of that string in the location
    referenced by ptr. It shall behave as asprintf(), except that instead of
    being called with a variable number of arguments, it is called with an
    argument list as defined by <stdarg.h>.

    The asprintf() function shall behave as sprintf(), except that the output
    string shall be dynamically allocated space of sufficient length to hold the
    resulting string. The address of this dynamically allocated string shall be
    stored in the location referenced by ptr.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT vasprintf_spec
         ( CallContext context, StringTPtr * ptr, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "vasprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * output;
        if ( vasprintf_spec < 0 ) { output = NULL                         ; }
                             else { output = readCString_VoidTPtr( * ptr ); }

        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_VASPRINTF, "vasprintf.05.02", vasprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( LSB_VASPRINTF, EILSEQ, "vasprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_VASPRINTF, EINVAL, "vasprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /*
         * The vasprintf() function shall write formatted output to a dynamically
         * allocated string, and store the address of that string in the location
         * referenced by ptr.
         */
        REQ( "vasprintf.30", "store the address of that string in ptr", ! isNULL_VoidTPtr( * ptr ) );

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "vasprintf", format, arguments, vasprintf_spec, output, errno ) );

        /*
         * It shall behave as asprintf(), except that instead of being called with a
         * variable number of arguments, it is called with an argument list as defined by .
         */
        REQ( "vasprintf.31", "It shall behave as asprintf()", true );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    vdprintf -- write formatted output to a file descriptor

SYNOPSIS

    #include <stdio.h>

    int vdprintf(int fd, const char * restrict format, va_list arg);

DESCRIPTION

    The vdprintf() function shall behave as vfprintf(), except that vdprintf()
    shall write output to the file associated with the file descriptor specified
    by the fd argument, rather than place output on a stream (as defined by ISO
    POSIX (2003)).

    The vprintf(), vfprintf(), vsnprintf(), and vsprintf() functions shall be
    equivalent to printf(), fprintf(), snprintf(), and sprintf() respectively,
    except that instead of being called with a variable number of arguments,
    they are called with an argument list as defined by <stdarg.h>.

    These functions shall not invoke the va_end macro. As these functions invoke
    the va_arg macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT vdprintf_spec( CallContext context, FileDescId * fd, CString * format, List /* NULL */ * arguments,
                    ErrorCode * errno, CString * fileForFdName, OpenFlags oflag
                  )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "vdprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * output = readFile( context, fd, fileForFdName, oflag );

        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_VDPRINTF, "vdprintf.05.02", vdprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( LSB_VDPRINTF, EILSEQ, "vdprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_VDPRINTF, EINVAL, "vdprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /*
         * The vdprintf() function shall behave as vfprintf(), except that vdprintf()
         * shall write output to the file associated with the file descriptor specified by
         * the fd argument, rather than place output on a stream (as defined by ISO
         * POSIX (2003)).
         */
        REQ( "vdprintf.30", "", output != NULL );

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "vdprintf", format, arguments, vdprintf_spec, output, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfprintf, vprintf, vsnprintf, vsprintf - format output of a stdarg argument
    list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfprintf(FILE *restrict stream, const char *restrict format,
           va_list ap);
    int vprintf(const char *restrict format, va_list ap);
    int vsnprintf(char *restrict s, size_t n, const char *restrict format,
           va_list ap);
    int vsprintf(char *restrict s, const char *restrict format, va_list ap);

DESCRIPTION

    The vprintf(), vfprintf(), vsnprintf(), and vsprintf() functions shall be
    equivalent to printf(), fprintf(), snprintf(), and sprintf() respectively,
    except that instead of being called with a variable number of arguments,
    they are called with an argument list as defined by <stdarg.h>.

    These functions shall not invoke the va_end macro. As these functions invoke
    the va_arg macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT vfprintf_spec( CallContext context, FILETPtr * stream, CString * format, List /* NULL */ * arguments,
                    ErrorCode * errno, CString * fileForStreamName, CString * fileForStreamMode
                  )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "vfprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        CString * output = freadFile( context, stream, fileForStreamName, fileForStreamMode );

        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_VFPRINTF, "vfprintf.05.02", vfprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ]
             * [XSI] A wide-character code that does not correspond to a valid character has
             * been detected.
             */
            ERROR_MAY( LSB_VFPRINTF, EILSEQ, "vfprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL]
             * [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_VFPRINTF, EINVAL, "vfprintf.06.02", TODO_ERR(EINVAL) )

            /*
             * The printf() and fprintf() functions may fail if:
             *
             * [ENOMEM]
             * [XSI] Insufficient storage space is available.
             */
            ERROR_MAY( LSB_VFPRINTF, ENOMEM, "vfprintf.07.01", TODO_ERR(ENOMEM) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "vfprintf", format, arguments, vfprintf_spec, output, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfprintf, vprintf, vsnprintf, vsprintf - format output of a stdarg argument
    list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfprintf(FILE *restrict stream, const char *restrict format,
           va_list ap);
    int vprintf(const char *restrict format, va_list ap);
    int vsnprintf(char *restrict s, size_t n, const char *restrict format,
           va_list ap);
    int vsprintf(char *restrict s, const char *restrict format, va_list ap);

DESCRIPTION

    The vprintf(), vfprintf(), vsnprintf(), and vsprintf() functions shall be
    equivalent to printf(), fprintf(), snprintf(), and sprintf() respectively,
    except that instead of being called with a variable number of arguments,
    they are called with an argument list as defined by <stdarg.h>.

    These functions shall not invoke the va_end macro. As these functions invoke
    the va_arg macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT vprintf_spec
         ( CallContext context, CString * format, List /* NULL */ * arguments, CString * output, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "vprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_VPRINTF, "vprintf.05.02", vprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( LSB_VPRINTF, EILSEQ, "vprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_VPRINTF, EINVAL, "vprintf.06.02", TODO_ERR(EINVAL) )

            /*
             * The printf() and fprintf() functions may fail if:
             *
             * [ENOMEM] [XSI] Insufficient storage space is available.
             */
            ERROR_MAY( LSB_VPRINTF, ENOMEM, "vprintf.07.01", TODO_ERR(ENOMEM) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "vprintf", format, arguments, vprintf_spec, output, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfprintf, vprintf, vsnprintf, vsprintf - format output of a stdarg argument
    list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfprintf(FILE *restrict stream, const char *restrict format,
           va_list ap);
    int vprintf(const char *restrict format, va_list ap);
    int vsnprintf(char *restrict s, size_t n, const char *restrict format,
           va_list ap);
    int vsprintf(char *restrict s, const char *restrict format, va_list ap);

DESCRIPTION

    The vprintf(), vfprintf(), vsnprintf(), and vsprintf() functions shall be
    equivalent to printf(), fprintf(), snprintf(), and sprintf() respectively,
    except that instead of being called with a variable number of arguments,
    they are called with an argument list as defined by <stdarg.h>.

    These functions shall not invoke the va_end macro. As these functions invoke
    the va_arg macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT vsnprintf_spec
         ( CallContext context, CString * s, SizeT n, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "vsnprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_VSNPRINTF, "vsnprintf.05.02", vsnprintf_spec < 0, * errno )
            /*
             * The snprintf() function shall fail if:
             *
             * [EOVERFLOW] [XSI] The value of n is greater than {INT_MAX} or the number of
             * bytes needed to hold the output excluding the terminating null is greater than
             * {INT_MAX}.
             */
            ERROR_SHALL( LSB_VSNPRINTF, EOVERFLOW, "vsnprintf.19.01", TODO_ERR(EOVERFLOW) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( LSB_VSNPRINTF, EILSEQ, "vsprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_VSNPRINTF, EINVAL, "vsprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "vsnprintf", format, arguments, vsnprintf_spec, s, errno ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfprintf, vprintf, vsnprintf, vsprintf - format output of a stdarg argument
    list

SYNOPSIS

    #include <stdarg.h>
    #include <stdio.h>

    int vfprintf(FILE *restrict stream, const char *restrict format,
           va_list ap);
    int vprintf(const char *restrict format, va_list ap);
    int vsnprintf(char *restrict s, size_t n, const char *restrict format,
           va_list ap);
    int vsprintf(char *restrict s, const char *restrict format, va_list ap);

DESCRIPTION

    The vprintf(), vfprintf(), vsnprintf(), and vsprintf() functions shall be
    equivalent to printf(), fprintf(), snprintf(), and sprintf() respectively,
    except that instead of being called with a variable number of arguments,
    they are called with an argument list as defined by <stdarg.h>.

    These functions shall not invoke the va_end macro. As these functions invoke
    the va_arg macro, the value of ap after the return is unspecified.

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The fprintf() function shall place output on the named output stream. The
    printf() function shall place output on the standard output stream stdout.
    The sprintf() function shall place output followed by the null byte, '\0',
    in consecutive bytes starting at *s; it is the user's responsibility to
    ensure that enough space is available.

    The snprintf() function shall be equivalent to sprintf(), with the addition
    of the n argument which states the size of the buffer referred to by s. If n
    is zero, nothing shall be written and s may be a null pointer. Otherwise,
    output bytes beyond the n-1st shall be discarded instead of being written to
    the array, and a null byte is written at the end of the bytes actually
    written into the array.

    If copying takes place between objects that overlap as a result of a call to
    sprintf() or snprintf(), the results are undefined.

    Each of these functions converts, formats, and prints its arguments under
    control of the format. The format is a character string, beginning and
    ending in its initial shift state, if any. The format is composed of zero or
    more directives: ordinary characters, which are simply copied to the output
    stream, and conversion specifications, each of which shall result in the
    fetching of zero or more arguments. The results are undefined if there are
    insufficient arguments for the format. If the format is exhausted while
    arguments remain, the excess arguments shall be evaluated but are otherwise
    ignored.

    Conversions can be applied to the nth argument after the format in the
    argument list, rather than to the next unused argument. In this case, the
    conversion specifier character % (see below) is replaced by the sequence
    "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the
    position of the argument in the argument list. This feature provides for the
    definition of format strings that select arguments in an order appropriate
    to specific languages (see the EXAMPLES section).

    The format can contain either numbered argument conversion specifications
    (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
    (that is, % and * ), but not both. The only exception to this is that %% can
    be mixed with the "%n$" form. The results of mixing numbered and unnumbered
    argument specifications in a format string are undefined. When numbered
    argument specifications are used, specifying the Nth argument requires that
    all the leading arguments, from the first to the (N-1)th, are specified in
    the format string.

    In format strings containing the "%n$" form of conversion specification,
    numbered arguments in the argument list can be referenced from the format
    string as many times as required.

    In format strings containing the % form of conversion specification, each
    conversion specification uses the first unused argument in the argument
    list.

    All forms of the fprintf() functions allow for the insertion of a
    language-dependent radix character in the output string. The radix character
    is defined in the program's locale (category LC_NUMERIC ). In the POSIX
    locale, or in a locale where the radix character is not defined, the radix
    character shall default to a period ( '.' ).

    Each conversion specification is introduced by the '%' character or by the
    character sequence "%n$", after which the following appear in sequence:

        * Zero or more flags (in any order), which modify the meaning of the
          conversion specification.

        * An optional minimum field width. If the converted value has fewer
          bytes than the field width, it shall be padded with spaces by default
          on the left; it shall be padded on the right if the left-adjustment
          flag ( '-' ), described below, is given to the field width. The field
          width takes the form of an asterisk ( '*' ), described below, or a
          decimal integer.

        * An optional precision that gives the minimum number of digits to
          appear for the d, i, o, u, x, and X conversion specifiers; the number
          of digits to appear after the radix character for the a, A, e, E, f,
          and F conversion specifiers; the maximum number of significant digits
          for the g and G conversion specifiers; or the maximum number of bytes
          to be printed from a string in the s and S conversion specifiers. The
          precision takes the form of a period ( '.' ) followed either by an
          asterisk ( '*' ), described below, or an optional decimal digit
          string, where a null digit string is treated as zero. If a precision
          appears with any other conversion specifier, the behavior is
          undefined.

        * An optional length modifier that specifies the size of the argument.

        * A conversion specifier character that indicates the type of conversion
          to be applied.

    A field width, or precision, or both, may be indicated by an asterisk ( '*'
    ). In this case an argument of type int supplies the field width or
    precision. Applications shall ensure that arguments specifying field width,
    or precision, or both appear in that order before the argument, if any, to
    be converted. A negative field width is taken as a '-' flag followed by a
    positive field width. A negative precision is taken as if the precision were
    omitted. In format strings containing the "%n$" form of a conversion
    specification, a field width or precision may be indicated by the sequence
    "*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the
    position in the argument list (after the format argument) of an integer
    argument containing the field width or precision, for example:

printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

    The flag characters and their meanings are:

    '
        The integer portion of the result of a decimal conversion ( %i, %d, %u,
        %f, %F, %g, or %G ) shall be formatted with thousands' grouping
        characters. For other conversions the behavior is undefined. The
        non-monetary grouping character is used.
    -
        The result of the conversion shall be left-justified within the field.
        The conversion is right-justified if this flag is not specified.
    +
        The result of a signed conversion shall always begin with a sign ( '+'
        or '-' ). The conversion shall begin with a sign only when a negative
        value is converted if this flag is not specified.
    <space>
        If the first character of a signed conversion is not a sign or if a
        signed conversion results in no characters, a <space> shall be prefixed
        to the result. This means that if the <space> and '+' flags both appear,
        the <space> flag shall be ignored.
    #
        Specifies that the value is to be converted to an alternative form. For
        o conversion, it increases the precision (if necessary) to force the
        first digit of the result to be zero. For x or X conversion specifiers,
        a non-zero result shall have 0x (or 0X) prefixed to it. For a, A, e, E,
        f, F, g , and G conversion specifiers, the result shall always contain a
        radix character, even if no digits follow the radix character. Without
        this flag, a radix character appears in the result of these conversions
        only if a digit follows it. For g and G conversion specifiers, trailing
        zeros shall not be removed from the result as they normally are. For
        other conversion specifiers, the behavior is undefined.
    0
        For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversion specifiers,
        leading zeros (following any indication of sign or base) are used to pad
        to the field width; no space padding is performed. If the '0' and '-'
        flags both appear, the '0' flag is ignored. For d, i, o, u, x, and X
        conversion specifiers, if a precision is specified, the '0' flag is
        ignored. If the '0' and '" flags both appear, the grouping characters
        are inserted before zero padding. For other conversions, the behavior is
        undefined.

    The length modifiers and their meanings are:

    hh
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a signed char or unsigned char argument (the argument will
        have been promoted according to the integer promotions, but its value
        shall be converted to signed char or unsigned char before printing); or
        that a following n conversion specifier applies to a pointer to a signed
        char argument.
    h
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a short or unsigned short argument (the argument will have
        been promoted according to the integer promotions, but its value shall
        be converted to short or unsigned short before printing); or that a
        following n conversion specifier applies to a pointer to a short
        argument.
    l (ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long or unsigned long argument; that a following n
        conversion specifier applies to a pointer to a long argument; that a
        following c conversion specifier applies to a wint_t argument; that a
        following s conversion specifier applies to a pointer to a wchar_t
        argument; or has no effect on a following a, A, e, E, f, F, g, or G
        conversion specifier.
    ll (ell-ell)
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a long long or unsigned long long argument; or that a
        following n conversion specifier applies to a pointer to a long long
        argument.
    j
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to an intmax_t or uintmax_t argument; or that a following n
        conversion specifier applies to a pointer to an intmax_t argument.
    z
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a size_t or the corresponding signed integer type argument;
        or that a following n conversion specifier applies to a pointer to a
        signed integer type corresponding to a size_t argument.
    t
        Specifies that a following d, i, o, u, x, or X conversion specifier
        applies to a ptrdiff_t or the corresponding unsigned type argument; or
        that a following n conversion specifier applies to a pointer to a
        ptrdiff_t argument.
    L
        Specifies that a following a, A, e, E, f, F, g, or G conversion
        specifier applies to a long double argument.

    If a length modifier appears with any conversion specifier other than as
    specified above, the behavior is undefined.

    The conversion specifiers and their meanings are:

    d, i
        The int argument shall be converted to a signed decimal in the style
        "[-]dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    o
        The unsigned argument shall be converted to unsigned octal format in the
        style "dddd". The precision specifies the minimum number of digits to
        appear; if the value being converted can be represented in fewer digits,
        it shall be expanded with leading zeros. The default precision is 1. The
        result of converting zero with an explicit precision of zero shall be no
        characters.
    u
        The unsigned argument shall be converted to unsigned decimal format in
        the style "dddd". The precision specifies the minimum number of digits
        to appear; if the value being converted can be represented in fewer
        digits, it shall be expanded with leading zeros. The default precision
        is 1. The result of converting zero with an explicit precision of zero
        shall be no characters.
    x
        The unsigned argument shall be converted to unsigned hexadecimal format
        in the style "dddd"; the letters "abcdef" are used. The precision
        specifies the minimum number of digits to appear; if the value being
        converted can be represented in fewer digits, it shall be expanded with
        leading zeros. The default precision is 1. The result of converting zero
        with an explicit precision of zero shall be no characters.
    X
        Equivalent to the x conversion specifier, except that letters "ABCDEF"
        are used instead of "abcdef" .
    f, F
        The double argument shall be converted to decimal notation in the style
        "[-]ddd.ddd", where the number of digits after the radix character is
        equal to the precision specification. If the precision is missing, it
        shall be taken as 6; if the precision is explicitly zero and no '#' flag
        is present, no radix character shall appear. If a radix character
        appears, at least one digit appears before it. The low-order digit shall
        be rounded in an implementation-defined manner.

        A double argument representing an infinity shall be converted in one of
        the styles "[-]inf" or "[-]infinity" ; which style is
        implementation-defined. A double argument representing a NaN shall be
        converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan" ;
        which style, and the meaning of any n-char-sequence, is
        implementation-defined. The F conversion specifier produces "INF",
        "INFINITY", or "NAN" instead of "inf", "infinity", or "nan",
        respectively.
    e, E
        The double argument shall be converted in the style "[-]d.ddde±dd",
        where there is one digit before the radix character (which is non-zero
        if the argument is non-zero) and the number of digits after it is equal
        to the precision; if the precision is missing, it shall be taken as 6;
        if the precision is zero and no '#' flag is present, no radix character
        shall appear. The low-order digit shall be rounded in an
        implementation-defined manner. The E conversion specifier shall produce
        a number with 'E' instead of 'e' introducing the exponent. The exponent
        shall always contain at least two digits. If the value is zero, the
        exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    g, G
        The double argument shall be converted in the style f or e (or in the
        style F or E in the case of a G conversion specifier), with the
        precision specifying the number of significant digits. If an explicit
        precision is zero, it shall be taken as 1. The style used depends on the
        value converted; style e (or E ) shall be used only if the exponent
        resulting from such a conversion is less than -4 or greater than or
        equal to the precision. Trailing zeros shall be removed from the
        fractional portion of the result; a radix character shall appear only if
        it is followed by a digit or a '#' flag is present.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    a, A
        A double argument representing a floating-point number shall be
        converted in the style "[-]0xh.hhhhp±d", where there is one hexadecimal
        digit (which shall be non-zero if the argument is a normalized
        floating-point number and is otherwise unspecified) before the
        decimal-point character and the number of hexadecimal digits after it is
        equal to the precision; if the precision is missing and FLT_RADIX is a
        power of 2, then the precision shall be sufficient for an exact
        representation of the value; if the precision is missing and FLT_RADIX
        is not a power of 2, then the precision shall be sufficient to
        distinguish values of type double, except that trailing zeros may be
        omitted; if the precision is zero and the '#' flag is not specified, no
        decimal-point character shall appear. The letters "abcdef" shall be used
        for a conversion and the letters "ABCDEF" for A conversion. The A
        conversion specifier produces a number with 'X' and 'P' instead of 'x'
        and 'p'. The exponent shall always contain at least one digit, and only
        as many more digits as necessary to represent the decimal exponent of 2.
        If the value is zero, the exponent shall be zero.

        A double argument representing an infinity or NaN shall be converted in
        the style of an f or F conversion specifier.
    c
        The int argument shall be converted to an unsigned char, and the
        resulting byte shall be written.

        If an l (ell) qualifier is present, the wint_t argument shall be
        converted as if by an ls conversion specification with no precision and
        an argument that points to a two-element array of type wchar_t, the
        first element of which contains the wint_t argument to the ls conversion
        specification and the second element contains a null wide character.
    s
        The argument shall be a pointer to an array of char. Bytes from the
        array shall be written up to (but not including) any terminating null
        byte. If the precision is specified, no more than that many bytes shall
        be written. If the precision is not specified or is greater than the
        size of the array, the application shall ensure that the array contains
        a null byte.

        If an l (ell) qualifier is present, the argument shall be a pointer to
        an array of type wchar_t. Wide characters from the array shall be
        converted to characters (each as if by a call to the wcrtomb() function,
        with the conversion state described by an mbstate_t object initialized
        to zero before the first wide character is converted) up to and
        including a terminating null wide character. The resulting characters
        shall be written up to (but not including) the terminating null
        character (byte). If no precision is specified, the application shall
        ensure that the array contains a null wide character. If a precision is
        specified, no more than that many characters (bytes) shall be written
        (including shift sequences, if any), and the array shall contain a null
        wide character if, to equal the character sequence length given by the
        precision, the function would need to access a wide character one past
        the end of the array. In no case shall a partial character be written.
    p
        The argument shall be a pointer to void. The value of the pointer is
        converted to a sequence of printable characters, in an
        implementation-defined manner.
    n
        The argument shall be a pointer to an integer into which is written the
        number of bytes written to the output so far by this call to one of the
        fprintf() functions. No argument is converted.
    C
        Equivalent to lc.
    S
        Equivalent to ls.
    %
        Print a '%' character; no argument is converted. The complete conversion
        specification shall be %%.

    If a conversion specification does not match one of the above forms, the
    behavior is undefined. If any argument is not the correct type for the
    corresponding conversion specification, the behavior is undefined.

    In no case shall a nonexistent or small field width cause truncation of a
    field; if the result of a conversion is wider than the field width, the
    field shall be expanded to contain the conversion result. Characters
    generated by fprintf() and printf() are printed as if fputc() had been
    called.

    For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the
    value shall be correctly rounded to a hexadecimal floating number with the
    given precision.

    For a and A conversions, if FLT_RADIX is not a power of 2 and the result is
    not exactly representable in the given precision, the result should be one
    of the two adjacent numbers in hexadecimal floating style with the given
    precision, with the extra stipulation that the error should have a correct
    sign for the current rounding direction.

    For the e, E, f, F, g, and G conversion specifiers, if the number of
    significant decimal digits is at most DECIMAL_DIG, then the result should be
    correctly rounded. If the number of significant decimal digits is more than
    DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG
    digits, then the result should be an exact representation with trailing
    zeros. Otherwise, the source value is bounded by two adjacent decimal
    strings L < U, both having DECIMAL_DIG significant digits; the value of the
    resultant decimal string D should satisfy L <= D <= U, with the extra
    stipulation that the error should have a correct sign for the current
    rounding direction.

    The st_ctime and st_mtime fields of the file shall be marked for update
    between the call to a successful execution of fprintf() or printf() and the
    next successful completion of a call to fflush() or fclose() on the same
    stream or a call to exit() or abort().

RETURN VALUE

    Upon successful completion, the fprintf() and printf() functions shall
    return the number of bytes transmitted.

    Upon successful completion, the sprintf() function shall return the number
    of bytes written to s, excluding the terminating null byte.

    Upon successful completion, the snprintf() function shall return the number
    of bytes that would be written to s had n been sufficiently large excluding
    the terminating null byte.

    If an output error was encountered, these functions shall return a negative
    value.

    If the value of n is zero on a call to snprintf(), nothing shall be written,
    the number of bytes that would have been written had n been sufficiently
    large excluding the terminating null shall be returned, and s may be a null
    pointer.

ERRORS

    For the conditions under which fprintf() and printf() fail and may fail,
    refer to fputc() or fputwc().

    In addition, all forms of fprintf() may fail if:

    [EILSEQ]
        A wide-character code that does not correspond to a valid character has
        been detected.
    [EINVAL]
        There are insufficient arguments.

    The printf() and fprintf() functions may fail if:

    [ENOMEM]
        Insufficient storage space is available.

    The snprintf() function shall fail if:

    [EOVERFLOW]
        The value of n is greater than {INT_MAX} or the number of bytes needed
        to hold the output excluding the terminating null is greater than
        {INT_MAX}.
*/
specification
IntT vsprintf_spec( CallContext context, CString * s, CString * format, List /* NULL */ * arguments, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /* [common preconditions for printf group] */
        REQ( "", "Common preconditions for printf group", checkPrintfPreconditions( "vsprintf", format, arguments ) );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an output error was encountered, these functions shall return a negative
         * value.
         */
        ERROR_BEGIN( LSB_VSNPRINTF, "vsprintf.05.02", vsprintf_spec < 0, * errno )
            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EILSEQ] [XSI] A wide-character code that does not correspond to a valid
             * character has been detected.
             */
            ERROR_MAY( LSB_VSPRINTF, EILSEQ, "vsnprintf.06.01", TODO_ERR(EILSEQ) )

            /*
             * In addition, all forms of fprintf() may fail if:
             *
             * [EINVAL] [XSI] There are insufficient arguments.
             */
            ERROR_MAY( LSB_VSPRINTF, EINVAL, "vsnprintf.06.02", TODO_ERR(EINVAL) )
        ERROR_END()

        /* [Check output] */
        REQ( "", "Check output", checkPrintfResult( "vsprintf", format, arguments, vsprintf_spec, s, errno ) );

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool checkPrintfPreconditions( char * funcName, CString * format, List /* NULL */ * arguments ) {
    String * reqPrefix = concat_String
                             ( create_String( "app." ), concat_String( create_String( funcName ), create_String( "." ) ) );
    String * commonReqPrefix = create_String( "app.all_print." );
    List /* String */ * preconditionsReqIds = create_List( & type_String );
    int i;
    append_List( preconditionsReqIds, create_String( "app.all_print.03"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.04"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.05"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.06"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.11.03" ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.13.01" ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.13.05" ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.13.06" ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.14"    ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.15.01" ) );
    append_List( preconditionsReqIds, create_String( "app.all_print.15.02" ) );
    for ( i = 0; i < size_List( preconditionsReqIds ); i++ ) {
        String * reqId = get_List( preconditionsReqIds, i );
        char * reqIdAsCharArray;
        // app.all_print.postfix +> app.funcName.postfix
        if ( startsWith_String( reqId, commonReqPrefix ) ) {
            reqId = clone( reqId );
            reqId = substringFrom_String( reqId, length_String( commonReqPrefix ) );
            reqId = concat_String( reqPrefix, reqId );
        }
        reqIdAsCharArray = (char *)toCharArray_String( reqId );
        if ( startsWith_String( reqId, reqPrefix ) ) { traceRequirements( reqIdAsCharArray ); }
    }
    return true;
}

bool checkPrintfResult( char * funcName, CString * format, List /* NULL */ * arguments,
                        IntT returnValue, CString * output, ErrorCode * errno
                      ) {
    bool verdict = returnValue < 0 || checkExpectedResult( funcName, output, "all_print" );
    if ( ! verdict ) {
        verbose( "checkPrintfResult\n"                                        );
        verbose( "checkPrintfResult : returned value is [%ld]\n", returnValue );
        verbose( "checkPrintfResult : errno          is [%ld]\n", * errno     );
    }
    // "close" data
    clearExpectedResultAndReqIds( funcName );
    // assertion( verdict, "stop" ); // for debug purpose
    return verdict;
}

/*CString * freadFile( CallContext context, FILETPtr * file, CString * fileName, CString * fileMode ) {
    ErrorCode * errno        ;
    OffT        oldOffset    ;
    IntT        resultSize   ;
    VoidTPtr    resultPtr    ;
    CString   * result       ;
    CString   * newFileMode  ;
    String    * tmpForReplace;
    if ( isNULL_VoidTPtr( * file ) ) { return NULL; }
    errno = requestErrorCode();
    // save old file state
    oldOffset = ftell_spec( context, * file, errno, LongType );
    fclose_spec( context, * file, errno );
    // read file contents
    * file = fopen_spec( context, fileName, create_CString( "r" ), errno, false );
    resultSize = 0;
    while ( fgetc_spec( context, * file, errno, F_Type ) != EOF ) { resultSize++; }
    fseek_spec( context, * file, 0, SEEK_SET, LongType, errno );
    resultPtr = allocateMemoryBlock( context, resultSize + 1 ); // + 1 - for final 0
    fread_spec( context, resultPtr, resultSize, 1, * file, errno );
    result = substring_CString( readCString_VoidTPtr( resultPtr ), 0, resultSize );
    deallocateMemoryBlock( context, resultPtr );
    fclose_spec( context, * file, errno );
    // restore old file state
    // newFileMode = replace_CString( fileMode, 'w', 'a' ); - but no replace_CString exists
    tmpForReplace = toString( fileMode );
    tmpForReplace = replace_String( tmpForReplace, 'w', 'a' );
    newFileMode = create_CString( (char *)toCharArray_String( tmpForReplace ) );
    * file = fopen_spec( context, fileName, newFileMode, errno, false );
    fseek_spec( context, * file, oldOffset, SEEK_SET, LongType, errno );
    return result;
}

CString * readFile( CallContext context,
                    FileDescId * fd, CString * fileName, OpenFlags fileOflag, FilePermissions * fileMode
                  ) {
    ErrorCode * errno        ;
    OffT        oldOffset    ;
    FILETPtr    file         ;
    IntT        resultSize   ;
    VoidTPtr    resultPtr    ;
    CString   * result       ;
    errno = requestErrorCode();
    // save old file state
    oldOffset = lseek_spec( context, * fd, 0, SEEK_CUR, errno, false );
    close_spec( context, * fd, errno );
    // read file contents
    file = fopen_spec( context, fileName, create_CString( "r" ), errno, false );
    resultSize = 0;
    while ( fgetc_spec( context, file, errno, F_Type ) != EOF ) { resultSize++; }
    fseek_spec( context, file, 0, SEEK_SET, LongType, errno );
    resultPtr = allocateMemoryBlock( context, resultSize + 1 ); // + 1 - for final 0
    fread_spec( context, resultPtr, resultSize, 1, file, errno );
    result = substring_CString( readCString_VoidTPtr( resultPtr ), 0, resultSize );
    deallocateMemoryBlock( context, resultPtr );
    fclose_spec( context, file, errno );
    // restore old file state
    fileOflag.creat  = false;
    fileOflag.trunc  = false;
    fileOflag.append = true ;
    * fd = open_spec( context, fileName, fileOflag, fileMode, errno, false );
    lseek_spec( context, * fd, oldOffset, SEEK_SET, errno, false );
    return result;
}*/
