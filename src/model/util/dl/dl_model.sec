/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "util/dl/dl_model.seh"
#include "util/dl/dl_config.h"
#include "process/process/process_model.seh"


#pragma SEC subsystem dl "util.dl"

/* 
   The group of functions 'util.dl' consists of: 
       dladdr 
       dlclose [2]
       dlerror [2]
       dlopen 
       dlsym 
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    dladdr -- find the shared object containing a given address

SYNOPSIS

    #include <dlfcn.h> typedef struct { const char *dli_fname; void *
    dli_fbase; const char *dli_sname; void *dli_saddr; }Dl_info;

    int dladdr (const void * addr, Dl_info * dlip);

DESCRIPTION

    The dladdr() function shall query the dynamic linker for information about the
    shared object containing the address addr. The information shall be returned in
    the user supplied data structure referenced by dlip.

    {dladdr.lsb.03} The structure shall contain at least the following members:

    dli_fname The pathname of the shared object containing the address

    dli_fbase The base address at which the shared object is mapped into the
    address space of the calling process.

    dli_sname The name of the nearest runtime symbol with value less than or equal
    to addr. Where possible, the symbol name shall be returned as it would appear
    in C source code.

    If no symbol with a suitable value is found,both this field and dli_saddr shall
    be set to NULL.

    dli_saddr The address of the symbol returned in dli_sname. This address has
    type "pointer to type", where type is the type of the symbol dli_sname.

    Example: If the symbol in dli_sname is a function, then the type of dli_saddr
    is of type"pointer to function".

    The behavior of dladdr() is only specified in dynamically linked programs.

RETURN VALUE

    On success, dladdr() shall return non-zero, and the structure referenced by
    dlip shall be filled in as described. Otherwise, dladdr() shall return zero,
    and the cause of the error can be fetched with dlerror().

ERRORS

    See dlerror().

Environment

    Cjdto LD_LIBRARY_PATH directory search-path for object files

    LD_LIBRARY_PATH directory search path for object files ADAPTED FOR HIGHLIGHTING
    HTML CODE -->
*/

specification
IntT dladdr_spec(CallContext context, VoidTPtr addr, DLInfo* dlip)
{
    pre
    {
        /*
         * The behavior of dladdr() is only specified in dynamically linked programs.
         */
        REQ("app.dladdr.lsb.04", "", TODO_REQ());

        return true;
    }

    post
    {
        if(dladdr_spec != 0)
        {
            int i;
            VoidTPtrObj* curAddr;
            DLObject* dlo;

            ObjectsInMemory* mapDLObjects = getTypedObjectsInMemory(context, &type_DLObject);

            for(i = 0; i < size_Map(mapDLObjects); i++)
            {
                curAddr = key_Map(mapDLObjects, i);

                dlo = get_Map(mapDLObjects, curAddr);

                if(containsKey_Map(dlo->mapSymbols, dlip->sname)) break;
            }

            if(i < size_Map(mapDLObjects))
            {
                /*
                 * The information shall be returned in the user supplied data structure 
                 * referenced by dlip.
                 *
                 * dli_sname
                 *
                 * The name of the nearest runtime symbol with value less than or equal to addr. 
                 * Where possible, the symbol name shall be returned as it would appear in C 
                 * source code.
                 */
                /*
                 * The information shall be returned in the user supplied data structure 
                 * referenced by dlip.
                 *
                 * dli_saddr
                 *
                 * The address of the symbol returned in dli_sname. This address has type "pointer 
                 * to type", where type is the type of the symbol dli_sname.
                 */
                REQ("dladdr.lsb.02.03.01;dladdr.lsb.02.04.01", "dli_sname and dli_saddr filling",
                    equals(get_Map(dlo->mapSymbols, dlip->sname), create_VoidTPtrObj(dlip->saddr))
                   );
            }

            /*
             * The information shall be returned in the user supplied data structure 
             * referenced by dlip.
             *
             * The pathname of the shared object containing the address
             */
            REQ("dladdr.lsb.02.01", "", TODO_REQ());

            /*
             * The information shall be returned in the user supplied data structure 
             * referenced by dlip.
             *
             * The base address at which the shared object is mapped into the address space of 
             * the calling process.
             */
            REQ("dladdr.lsb.02.02", "", TODO_REQ());

            /*
             * On success, dladdr() shall return non-zero, and the structure referenced by 
             * dlip shall be filled in as described.
             */
            REQ("dladdr.lsb.05", "shall return non-zero", true);
        }
        else
        {
            /* this requirements are not implemented by current implementation: */
            /*
             * The information shall be returned in the user supplied data structure 
             * referenced by dlip.
             *
             * dli_sname
             *
             * If no symbol with a suitable value is found,both this field and dli_saddr shall 
             * be set to NULL.
             */
            //REQ("dladdr.lsb.02.03.02", "dli_sname == NULL", isNULL_VoidTPtr(dlip->sname));

            /*
             * The information shall be returned in the user supplied data structure 
             * referenced by dlip.
             *
             * dli_saddr
             *
             * If no symbol with a suitable value is found,both this field and dli_saddr shall 
             * be set to NULL.
             */
            //REQ("dladdr.lsb.02.04.02", "dli_saddr == NULL", isNULL_VoidTPtr(dlip->saddr));
        }

       

        return true;
    }
}

void onDLAddr(CallContext context, VoidTPtr addr, DLInfo* dlip, IntT res)
{
    if(res == 0)
    {
        setDLError(context, true);
    }
}

/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6 
    IEEE Std 1003.1, 2004 Edition 
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    dlclose - close a dlopen object 

    SYNOPSIS

    [XSI] #include <dlfcn.h>

    int dlclose(void *handle); 

    DESCRIPTION

    The dlclose() function shall inform the system that the object referenced by a 
    handle returned from a previous dlopen() invocation is no longer needed by the 
    application.

    The use of dlclose() reflects a statement of intent on the part of the process, 
    but does not create any requirement upon the implementation, such as removal of 
    the code or symbols referenced by handle. Once an object has been closed using 
    dlclose() an application should assume that its symbols are no longer available 
    to dlsym(). All objects loaded automatically as a result of invoking dlopen() 
    on the referenced object shall also be closed if this is the last reference to 
    it. 

    Although a dlclose() operation is not required to remove structures from an 
    address space, neither is an implementation prohibited from doing so. The only 
    restriction on such a removal is that no object shall be removed to which 
    references have been relocated, until or unless all such references are removed. 
    For instance, an object that had been loaded with a dlopen() operation 
    specifying the RTLD_GLOBAL flag might provide a target for dynamic relocations 
    performed in the processing of other objects-in such environments, an 
    application may assume that no relocation, once made, shall be undone or remade 
    unless the object requiring the relocation has itself been removed.

    RETURN VALUE

    If the referenced object was successfully closed, dlclose() shall return 0. If 
    the object could not be closed, or if handle does not refer to an open object, 
    dlclose() shall return a non-zero value. More detailed diagnostic information 
    shall be available through dlerror(). 

    ERRORS

    No errors are defined.
*/

specification
IntT dlclose_spec(CallContext context, VoidTPtr handle)
{
    pre
    {
        /*
         * Once an object has been closed using dlclose() an application should assume 
         * that its symbols are no longer available to dlsym().
         */
        REQ("app.dlclose.02", "", TODO_REQ());

        /*
         * All objects loaded automatically as a result of invoking dlopen() on the 
         * referenced object shall also be closed if this is the last reference to it.
         */
        REQ("app.dlclose.03", "", TODO_REQ());

        return true;
    }

    DL_HANDLE_COVERAGE(handle)

    post
    {
        /*
         * The only restriction on such a removal is that no object shall be removed to 
         * which references have been relocated, until or unless all such references are 
         * removed.
         */
        REQ("dlclose.04", "", TODO_REQ());

        return true;
    }
}

void onDLClose(CallContext context, VoidTPtr handle, IntT res)
{
}


/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6 
    IEEE Std 1003.1, 2004 Edition 
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    dlerror - get diagnostic information 

    SYNOPSIS

    [XSI] #include <dlfcn.h>

    char *dlerror(void); 

    DESCRIPTION

    The dlerror() function shall return a null-terminated character string (with no 
    trailing <newline>) that describes the last error that occurred during 
    dynamic linking processing. If no dynamic linking errors have occurred since 
    the last invocation of dlerror(), dlerror() shall return NULL. Thus, invoking 
    dlerror() a second time, immediately following a prior invocation, shall result 
    in NULL being returned. 

    The dlerror() function need not be reentrant. A function that is not required 
    to be reentrant is not required to be thread-safe. 

    RETURN VALUE

    If successful, dlerror() shall return a null-terminated character string; 
    otherwise, NULL shall be returned. 

    ERRORS

    No errors are defined.
*/

specification
CString* dlerror_spec(CallContext context)
{
    pre
    {
        return true;
    }

    post
    {
        if(dlerror_spec)
        {
            /*
             * The dlerror() function shall return a null-terminated character string (with no 
             * trailing <newline>) that describes the last error that occurred during 
             * dynamic linking processing.
             */
            REQ("dlerror.01", "with no trailing <newline>",
                charAt_CString(dlerror_spec, length_CString(dlerror_spec)-1) != '\n');
        }

        if(@isDLError(context) == false)
        {
            /*
             * If no dynamic linking errors have occurred since the last invocation of 
             * dlerror(), dlerror() shall return NULL.
             */
            /*
             * Thus, invoking dlerror() a second time, immediately following a prior 
             * invocation, shall result in NULL being returned.
             */
            /*
             * otherwise, NULL shall be returned.
             */
            REQ("dlerror.02;dlerror.03;dlerror.06", "shall return NULL", !dlerror_spec);
        }
        else if(DL_ERROR_NO_INTERNAL_ERRORS)
            /* this requirement is not implemented by current implementation: */
            /*
             * If successful, dlerror() shall return a null-terminated character string;
             */
            REQ("dlerror.05", "shall return a string", dlerror_spec);

        return true;
    }
}

void onDLError(CallContext context, CString* res)
{
    setDLError(context, false);
}

/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6 
    IEEE Std 1003.1, 2004 Edition 
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    dlopen - gain access to an executable object file 

    SYNOPSIS

    [XSI] #include <dlfcn.h>

    void *dlopen(const char *file, int mode); 

    DESCRIPTION

    The dlopen() function shall make an executable object file specified by file 
    available to the calling program. The class of files eligible for this 
    operation and the manner of their construction are implementation-defined, 
    though typically such files are executable objects such as shared libraries, 
    relocatable files, or programs. Note that some implementations permit the 
    construction of dependencies between such objects that are embedded within 
    files. In such cases, a dlopen() operation shall load such dependencies in 
    addition to the object referenced by file. {dlopen.03} Implementations may also 
    impose specific constraints on the construction of programs that can employ 
    dlopen() and its related services. 

    A successful dlopen() shall return a handle which the caller may use on 
    subsequent calls to dlsym() and dlclose(). The value of this handle should not 
    be interpreted in any way by the caller.

    The file argument is used to construct a pathname to the object file. If file 
    contains a slash character, the file argument is used as the pathname for the 
    file. Otherwise, file is used in an implementation-defined manner to yield a 
    pathname. 

    If the value of file is 0, dlopen() shall provide a handle on a global symbol 
    object. This object shall provide access to the symbols from an ordered set of 
    objects consisting of the original program image file, together with any 
    objects loaded at program start-up as specified by that process image file (for 
    example, shared libraries), and the set of objects loaded using a dlopen() 
    operation together with the RTLD_GLOBAL flag. As the latter set of objects can 
    change during execution, the set identified by handle can also change 
    dynamically.

    Only a single copy of an object file is brought into the address space, even if 
    dlopen() is invoked multiple times in reference to the file, and even if 
    different pathnames are used to reference the file.

    The mode parameter describes how dlopen() shall operate upon file with respect 
    to the processing of relocations and the scope of visibility of the symbols 
    provided within file. When an object is brought into the address space of a 
    process, it may contain references to symbols whose addresses are not known 
    until the object is loaded. These references shall be relocated before the 
    symbols can be accessed. The mode parameter governs when these relocations take 
    place and may have the following values: 

    RTLD_LAZY Relocations shall be performed at an implementation-defined time, 
    ranging from the time of the dlopen() call until the first reference to a given 
    symbol occurs. Specifying RTLD_LAZY should improve performance on 
    implementations supporting dynamic symbol binding as a process may not 
    reference all of the functions in any given object. And, for systems supporting 
    dynamic symbol resolution for normal process execution, this behavior mimics 
    the normal handling of process execution.

    RTLD_NOW All necessary relocations shall be performed when the object is first 
    loaded. This may waste some processing if relocations are performed for 
    functions that are never referenced. This behavior may be useful for 
    applications that need to know as soon as an object is loaded that all symbols 
    referenced during execution are available.

    Any object loaded by dlopen() that requires relocations against global symbols 
    can reference the symbols in the original process image file, any objects 
    loaded at program start-up, from the object itself as well as any other object 
    included in the same dlopen() invocation, and any objects that were loaded in 
    any dlopen() invocation and which specified the RTLD_GLOBAL flag. To determine 
    the scope of visibility for the symbols loaded with a dlopen() invocation, the 
    mode parameter should be a bitwise-inclusive OR with one of the following 
    values: 

    RTLD_GLOBAL The object's symbols shall be made available for the relocation 
    processing of any other object. In addition, symbol lookup using dlopen(0, mode) 
    and an associated dlsym() allows objects loaded with this mode to be searched.

    RTLD_LOCAL The object's symbols shall not be made available for the relocation 
    processing of any other object.

    If neither RTLD_GLOBAL nor RTLD_LOCAL are specified, then the default behavior 
    is unspecified.

    If a file is specified in multiple dlopen() invocations, mode is interpreted at 
    each invocation. Note, however, that once RTLD_NOW has been specified all 
    relocations shall have been completed rendering further RTLD_NOW operations 
    redundant and any further RTLD_LAZY operations irrelevant. Similarly, note that 
    once RTLD_GLOBAL has been specified the object shall maintain the RTLD_GLOBAL 
    status regardless of any previous or future specification of RTLD_LOCAL, as 
    long as the object remains in the address space (see dlclose()) . 

    Symbols introduced into a program through calls to dlopen() may be used in 
    relocation activities. Symbols so introduced may duplicate symbols already 
    defined by the program or previous dlopen() operations. To resolve the 
    ambiguities such a situation might present, the resolution of a symbol 
    reference to symbol definition is based on a symbol resolution order. Two such 
    resolution orders are defined: load or dependency ordering. Load order 
    establishes an ordering among symbol definitions, such that the definition 
    first loaded (including definitions from the image file and any dependent 
    objects loaded with it) has priority over objects added later (via dlopen()). 
    Load ordering is used in relocation processing. Dependency ordering uses a 
    breadth-first order starting with a given object, then all of its dependencies, 
    then any dependents of those, iterating until all dependencies are satisfied. 
    With the exception of the global symbol object obtained via a dlopen() 
    operation on a file of 0, dependency ordering is used by the dlsym() function. 
    Load ordering is used in dlsym() operations upon the global symbol object.

    When an object is first made accessible via dlopen() it and its dependent 
    objects are added in dependency order. Once all the objects are added, 
    relocations are performed using load order. Note that if an object or its 
    dependencies had been previously loaded, the load and dependency orders may 
    yield different resolutions.

    The symbols introduced by dlopen() operations and available through dlsym() are 
    at a minimum those which are exported as symbols of global scope by the object. 
    Typically such symbols shall be those that were specified in (for example) C 
    source code as having extern linkage. The precise manner in which an 
    implementation constructs the set of exported symbols for a dlopen() object is 
    specified by that implementation.

    RETURN VALUE

    If file cannot be found, cannot be opened for reading, is not of an appropriate 
    object format for processing by dlopen(), or if an error occurs during the 
    process of loading file or relocating its symbolic references, dlopen() shall 
    return NULL. More detailed diagnostic information shall be available through 
    dlerror(). 

    ERRORS

    No errors are defined.
*/

specification
VoidTPtr dlopen_spec(CallContext context, CString* file, IntT mode)
{
    pre
    {
        return true;
    }

    coverage FName
    {
        if(file == NULL)
            return { NULL_FILENAME, "getting the global object" };
        else if(isFileNamePath(file))
            return { PATH_FILENAME, "file is a path of file" };
        /* else */
            return { UNDEF_FILENAME, "file is an implementation-defined file name" };
    }

    coverage ModeScope
    {
        if(mode & SUT_RTLD_GLOBAL)
            return { GlobalObject, "loading the global object" };
        /* if(mode & SUT_RTLD_LOCAL) */
            return { LocalObject, "loading the file as single object" };
    }

    coverage ModeLoad
    {
        if(mode & SUT_RTLD_NOW)
            return { ImmediatelyLoad, "relocate symbols immediately" };
        /* if(mode & SUT_RTLD_LAZY) */
            return { LazyLoad, "relocate symbols when needed" };
    }

    post
    {
        /*
         * This step shall be skipped for setuid and setgid executables.
         */
        REQ("dlopen.lsb.03", "", TODO_REQ());

        /*
         * If the file argument does not contain a slash character, then the system shall 
         * look for a library of that name in at least the following directories, and use 
         * the first one which is found:
         *
         * A set of directories sufficient to contain the libraries specified in this 
         * standard.
         */
        REQ("dlopen.lsb.02.04", "", TODO_REQ());

        return true;
    }
}

void onDLOpen(CallContext context, CString* file, IntT mode, VoidTPtr res)
{
    if(isNULL_VoidTPtr(res))
    {
        setDLError(context, true);
    }
    else
    {
        Object* Obj = getTypedObjectInMemory(res, &type_DLObject);
        if(Obj == NULL)
            registerObjectInMemory(res, 0, create_DLObject(res, file));
        else { /* TODO: base1 */ }
    }
}


/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6 
    IEEE Std 1003.1, 2004 Edition 
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    dlsym - obtain the address of a symbol from a dlopen object 

    SYNOPSIS

    [XSI] #include <dlfcn.h>

    void *dlsym(void *restrict handle, const char *restrict name); 

    DESCRIPTION

    The dlsym() function shall obtain the address of a symbol defined within an 
    object made accessible through a dlopen() call. The handle argument is the 
    value returned from a call to dlopen() (and which has not since been released 
    via a call to dlclose()), and name is the symbol's name as a character string. 

    The dlsym() function shall search for the named symbol in all objects loaded 
    automatically as a result of loading the object referenced by handle (see 
    dlopen()). Load ordering is used in dlsym() operations upon the global symbol 
    object. The symbol resolution algorithm used shall be dependency order as 
    described in dlopen(). 

    {dlsym.05} The RTLD_DEFAULT and RTLD_NEXT flags are reserved for future use.

    RETURN VALUE

    If handle does not refer to a valid object opened by dlopen(), or if the named 
    symbol cannot be found within any of the objects associated with handle, dlsym() 
    shall return NULL. More detailed diagnostic information shall be available 
    through dlerror(). 

    ERRORS

    No errors are defined.
*/

specification
VoidTPtr dlsym_spec(CallContext context, VoidTPtr handle, CString* name)
{
    pre
    {
        return true;
    }

    DL_HANDLE_COVERAGE(handle)

    post
    {
        /*
         * Load ordering is used in dlsym() operations upon the global symbol object.
         */
        REQ("dlsym.04", "", TODO_REQ());

        /*
         * The symbol resolution algorithm used shall be dependency order as described in 
         * dlopen().
         */
        REQ("dlsym.05", "", TODO_REQ());

        /*
         * Specifies the next object after this one that defines name. This one refers to 
         * the object containing the invocation of dlsym(). The next object is the one 
         * found upon the application of a load order symbol resolution algorithm (see 
         * dlopen()). The next object is either one of global scope (because it was 
         * introduced as part of the original process image or because it was added with a 
         * dlopen() operation including the RTLD_GLOBAL flag), or is an object that was 
         * included in the same dlopen() operation that loaded this one.
         */
        /*
         * The value RTLD_NEXT, which is reserved for future use shall be available, with 
         * the behavior as described in ISO POSIX (2003).
         */
        REQ("dlsym.lsb.01", "", TODO_REQ());

      

        if(@isHeapBlockPointer(handle))
        {
            DLObject* Obj = clone(@getObjectInMemory(handle));

            if(containsKey_Map(Obj->mapSymbols, name)) REQ("", "for equal names return pointer shall be equal",
                equals(get_Map(Obj->mapSymbols, name), create_VoidTPtrObj(dlsym_spec)));
        }

       
        return true;
    }
}

void onDLSym(CallContext context, VoidTPtr handle, CString* name, VoidTPtr res)
{
    DLObject* Obj;

    if(isNULL_VoidTPtr(res))
    {
        setDLError(context, true);
    }
    else
    {
        Obj = getObjectInMemory(handle);

        put_Map(Obj->mapSymbols, name, create_VoidTPtrObj(res));
    }
}

/********************************************************************/
/**                      Specification Types                       **/
/********************************************************************/
specification typedef struct DLInfo DLInfo = {};

DLInfo* create_DLInfo(void)
{
    return create(&type_DLInfo, NULL, NULL_VoidTPtr,
        NULL, NULL_VoidTPtr);
}

specification typedef struct DLObject DLObject = {};

Object* create_DLObject(VoidTPtr hObject, CString* sName)
{
    Set* files;

    if(sName)
    {
        files = create_Set(&type_CString);
        add_Set(files, sName);
    }

    return create(  &type_DLObject,
                    hObject,
                    files,
                    create_Map(&type_CString, &type_VoidTPtrObj)
                    );
}

/********************************************************************/
/**                          Model State                           **/
/********************************************************************/

specification typedef struct DLState DLState = {};

Object* create_DLState(void)
{
    return create(&type_DLState,

        false           // bool bError
    );
}

bool isDLError(CallContext context)
{
    DLState* dlState = getProcessDLState(context);

    return dlState->bError;
}

void setDLError(CallContext context, bool bError)
{
    DLState* dlState = getProcessDLState(context);

    dlState->bError = bError;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool isFileNamePath(CString* name)
{
    int i;

    if(name == NULL) return false;

    for(i = 0; i < length_CString(name); i++)
        if(charAt_CString(name, i) == '/') return true;

    return false;
}

DLState* getProcessDLState(CallContext context)
{
    registerProcessStaticData(context, _CS("util.dl"), create_DLState());

    return getProcessStaticData(context, _CS("util.dl"));
}

VoidTPtr getDLObjectHandleByName(CallContext context, CString* name)
{
    int i;
    Map* mapObjects = getTypedObjectsInMemory(context, &type_DLObject);

    assertion(name != NULL, "name is NULL");

    for(i = 0; i < size_Map(mapObjects); i++)
    {
        DLObject* Obj = get_Map(mapObjects, key_Map(mapObjects, i));

        if(Obj->sNames == NULL) continue;

        if(contains_Set(Obj->sNames, name))
        {
            VoidTPtrObj* resO;
            VoidTPtr res;

            resO = key_Map(mapObjects, i);

            res.system = resO->system;
            res.process = resO->process;
            res.address = resO->address;

            return res;
        }
    }

    return NULL_VoidTPtr;
}

bool isDLRootObjectHandle(VoidTPtr handle)
{
    MemoryBlock* Obj = getTypedObjectInMemory(handle, &type_DLObject);

    return Obj != NULL && Obj->data != NULL
        && ((DLObject*)(Obj->data))->sNames == NULL;
}

bool isDLObjectHandle(VoidTPtr handle)
{
    MemoryBlock* Obj = getTypedObjectInMemory(handle, &type_DLObject);

    return Obj != NULL && Obj->data != NULL;
}
