/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef UTIL_WORDEXP_MODEL_SEH
#define UTIL_WORDEXP_MODEL_SEH

#include "common/common_model.seh"

/*****************************************************************************/
/**                          Defines                                        **/
/*****************************************************************************/

/*
 * If the argument words contains an unquoted comment character (number sign)
 * that is the beginning of a token, wordexp() shall either treat the comment
 * character as a regular character, or interpret it as a comment indicator and
 * ignore the remainder of words.
 */
#define POSIX_UTIL_WORDEXP_SHALL_IGNORE_COMMENTS 0 

/*****************************************************************************/
/**                            Coverages                                    **/
/*****************************************************************************/
#define WORDEXP_COVERAGE(pwordexp, covid, covstr)                             \
{                                                                             \
    WordExpT *wordexp = getWordExpT(pwordexp);                                \
                                                                              \
    if(wordexp == NULL)                                                       \
    {                                                                         \
        return { covid##_WordExpIsNull,                                       \
            covstr ", wordexp is NULL" };                                     \
    }                                                                         \
    else if(wordexp->offs == 0 && wordexp->wordc == 0)                        \
    {                                                                         \
        return { covid##_OffsetIsZero_CountIsZero,                            \
            covstr ", offset is zero, count is zero" };                       \
    }                                                                         \
    else if(wordexp->offs == 0 && wordexp->wordc != 0)                        \
    {                                                                         \
        return { covid##_OffsetIsZero_CountIsNotZero,                         \
            covstr ", offset is zero, count is not zero" };                   \
    }                                                                         \
    else if(wordexp->offs != 0 && wordexp->wordc == wordexp->offs)            \
    {                                                                         \
        return { covid##_OffsetIsNotZero_CountIsEqualToOffset,                \
            covstr ", offset is not zero, count is equal to offset" };        \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        return { covid##_OffsetIsNotZero_CountIsNotEqualToOffset,             \
            covstr ", offset is not zero, count is not equal to offset" };    \
    }                                                                         \
}                                                                             \

#define WORD_COVERAGE(word, covid, covstr)                                    \
{                                                                             \
    int i, size;                                                              \
                                                                              \
    bool e = false;                                                           \
    bool t = false;                                                           \
    bool p = false;                                                           \
    bool c = false;                                                           \
    bool a = false;                                                           \
                                                                              \
    size = size_List(word);                                                   \
    for(i = 0; i < size; i++)                                                 \
    {                                                                         \
        WordExp *wordexp = get_List(word, i);                                 \
                                                                              \
        switch(wordexp->type)                                                 \
        {                                                                     \
        case EmptyExpansion:                                                  \
            e = true;                                                         \
            break;                                                            \
        case TildeExpansion:                                                  \
            t = true;                                                         \
            break;                                                            \
        case ParameterExpansion:                                              \
            p = true;                                                         \
            break;                                                            \
        case CommandSubstitution:                                             \
            c = true;                                                         \
            break;                                                            \
        case ArithmeticExpansion:                                             \
            a = true;                                                         \
            break;                                                            \
        }                                                                     \
    }                                                                         \
                                                                              \
    switch((e ? 0x01 : 0x00) |                                                \
           (t ? 0x02 : 0x00) |                                                \
           (p ? 0x04 : 0x00) |                                                \
           (c ? 0x08 : 0x00) |                                                \
           (a ? 0x10 : 0x00))                                                 \
    {                                                                         \
    case 0:                                                                   \
        return { covid##_Empty0_Tilde0_Parameter0_Command0_Arithmetic0,       \
        covstr ", empty=0, tilde=0, parameter=0, command=0, arithmetic=0" };  \
    case 1:                                                                   \
        return { covid##_Empty1_Tilde0_Parameter0_Command0_Arithmetic0,       \
        covstr ", empty=1, tilde=0, parameter=0, command=0, arithmetic=0" };  \
    case 2:                                                                   \
        return { covid##_Empty0_Tilde1_Parameter0_Command0_Arithmetic0,       \
        covstr ", empty=0, tilde=1, parameter=0, command=0, arithmetic=0" };  \
    case 3:                                                                   \
        return { covid##_Empty1_Tilde1_Parameter0_Command0_Arithmetic0,       \
        covstr ", empty=1, tilde=1, parameter=0, command=0, arithmetic=0" };  \
    case 4:                                                                   \
        return { covid##_Empty0_Tilde0_Parameter1_Command0_Arithmetic0,       \
        covstr ", empty=0, tilde=0, parameter=1, command=0, arithmetic=0" };  \
    case 5:                                                                   \
        return { covid##_Empty1_Tilde0_Parameter1_Command0_Arithmetic0,       \
        covstr ", empty=1, tilde=0, parameter=1, command=0, arithmetic=0" };  \
    case 6:                                                                   \
        return { covid##_Empty0_Tilde1_Parameter1_Command0_Arithmetic0,       \
        covstr ", empty=0, tilde=1, parameter=1, command=0, arithmetic=0" };  \
    case 7:                                                                   \
        return { covid##_Empty1_Tilde1_Parameter1_Command0_Arithmetic0,       \
        covstr ", empty=1, tilde=1, parameter=1, command=0, arithmetic=0" };  \
    case 8:                                                                   \
        return { covid##_Empty0_Tilde0_Parameter0_Command1_Arithmetic0,       \
        covstr ", empty=0, tilde=0, parameter=0, command=1, arithmetic=0" };  \
    case 9:                                                                   \
        return { covid##_Empty1_Tilde0_Parameter0_Command1_Arithmetic0,       \
        covstr ", empty=1, tilde=0, parameter=0, command=1, arithmetic=0" };  \
    case 10:                                                                  \
        return { covid##_Empty0_Tilde1_Parameter0_Command1_Arithmetic0,       \
        covstr ", empty=0, tilde=1, parameter=0, command=1, arithmetic=0" };  \
    case 11:                                                                  \
        return { covid##_Empty1_Tilde1_Parameter0_Command1_Arithmetic0,       \
        covstr ", empty=1, tilde=1, parameter=0, command=1, arithmetic=0" };  \
    case 12:                                                                  \
        return { covid##_Empty0_Tilde0_Parameter1_Command1_Arithmetic0,       \
        covstr ", empty=0, tilde=0, parameter=1, command=1, arithmetic=0" };  \
    case 13:                                                                  \
        return { covid##_Empty1_Tilde0_Parameter1_Command1_Arithmetic0,       \
        covstr ", empty=1, tilde=0, parameter=1, command=1, arithmetic=0" };  \
    case 14:                                                                  \
        return { covid##_Empty0_Tilde1_Parameter1_Command1_Arithmetic0,       \
        covstr ", empty=0, tilde=1, parameter=1, command=1, arithmetic=0" };  \
    case 15:                                                                  \
        return { covid##_Empty1_Tilde1_Parameter1_Command1_Arithmetic0,       \
        covstr ", empty=1, tilde=1, parameter=1, command=1, arithmetic=0" };  \
    case 16:                                                                  \
        return { covid##_Empty0_Tilde0_Parameter0_Command0_Arithmetic1,       \
        covstr ", empty=0, tilde=0, parameter=0, command=0, arithmetic=1" };  \
    case 17:                                                                  \
        return { covid##_Empty1_Tilde0_Parameter0_Command0_Arithmetic1,       \
        covstr ", empty=1, tilde=0, parameter=0, command=0, arithmetic=1" };  \
    case 18:                                                                  \
        return { covid##_Empty0_Tilde1_Parameter0_Command0_Arithmetic1,       \
        covstr ", empty=0, tilde=1, parameter=0, command=0, arithmetic=1" };  \
    case 19:                                                                  \
        return { covid##_Empty1_Tilde1_Parameter0_Command0_Arithmetic1,       \
        covstr ", empty=1, tilde=1, parameter=0, command=0, arithmetic=1" };  \
    case 20:                                                                  \
        return { covid##_Empty0_Tilde0_Parameter1_Command0_Arithmetic1,       \
        covstr ", empty=0, tilde=0, parameter=1, command=0, arithmetic=1" };  \
    case 21:                                                                  \
        return { covid##_Empty1_Tilde0_Parameter1_Command0_Arithmetic1,       \
        covstr ", empty=1, tilde=0, parameter=1, command=0, arithmetic=1" };  \
    case 22:                                                                  \
        return { covid##_Empty0_Tilde1_Parameter1_Command0_Arithmetic1,       \
        covstr ", empty=0, tilde=1, parameter=1, command=0, arithmetic=1" };  \
    case 23:                                                                  \
        return { covid##_Empty1_Tilde1_Parameter1_Command0_Arithmetic1,       \
        covstr ", empty=1, tilde=1, parameter=1, command=0, arithmetic=1" };  \
    case 24:                                                                  \
        return { covid##_Empty0_Tilde0_Parameter0_Command1_Arithmetic1,       \
        covstr ", empty=0, tilde=0, parameter=0, command=1, arithmetic=1" };  \
    case 25:                                                                  \
        return { covid##_Empty1_Tilde0_Parameter0_Command1_Arithmetic1,       \
        covstr ", empty=1, tilde=0, parameter=0, command=1, arithmetic=1" };  \
    case 26:                                                                  \
        return { covid##_Empty0_Tilde1_Parameter0_Command1_Arithmetic1,       \
        covstr ", empty=0, tilde=1, parameter=0, command=1, arithmetic=1" };  \
    case 27:                                                                  \
        return { covid##_Empty1_Tilde1_Parameter0_Command1_Arithmetic1,       \
        covstr ", empty=1, tilde=1, parameter=0, command=1, arithmetic=1" };  \
    case 28:                                                                  \
        return { covid##_Empty0_Tilde0_Parameter1_Command1_Arithmetic1,       \
        covstr ", empty=0, tilde=0, parameter=1, command=1, arithmetic=1" };  \
    case 29:                                                                  \
        return { covid##_Empty1_Tilde0_Parameter1_Command1_Arithmetic1,       \
        covstr ", empty=1, tilde=0, parameter=1, command=1, arithmetic=1" };  \
    case 30:                                                                  \
        return { covid##_Empty0_Tilde1_Parameter1_Command1_Arithmetic1,       \
        covstr ", empty=0, tilde=1, parameter=1, command=1, arithmetic=1" };  \
    default:                                                                  \
        return { covid##_Empty1_Tilde1_Parameter1_Command1_Arithmetic1,       \
        covstr ", empty=1, tilde=1, parameter=1, command=1, arithmetic=1" };  \
    }                                                                         \
}                                                                             \

/*****************************************************************************/
/**                          Shell Variable                                 **/
/*****************************************************************************/
typedef specification struct ShellVariable
{
    CString *name;
    CString *value;
} ShellVariable;

/*
 * Creates shell variable with given name and value.
 */
ShellVariable* create_ShellVariable(CString *name, CString *value);

/*
 * Creates shell variable with given name and null value.
 */
ShellVariable* null_ShellVariable(CString *name);

/*
 * Creates shell variable with given name and empty value.
 */
ShellVariable* empty_ShellVariable(CString *name);

/*
 * Returns true, iff the shell variable is null.
 */
bool isNull_ShellVariable(ShellVariable *var);

/*
 * Returns the name of the shell variable.
 */
CString* getName_ShellVariable(ShellVariable *var);

/*
 * Returns the value of the shell variable.
 */
CString* getValue_ShellVariable(ShellVariable *name);

/*****************************************************************************/
/**                          Shell Variables                                **/
/*****************************************************************************/
typedef Map ShellVariables;

/*
 * Creates set of shell variables based on environment variables.
 */
ShellVariables* create_ShellVariables(Map* env);

/*
 * Creates empty set of shell variables.
 */
ShellVariables* empty_ShellVariables(void);

/*
 * Returns the value of the shell variable or NULL, if the shell variable is
 * unset.
 */
CString* get_ShellVariables(ShellVariables *vars, CString *name);

/*
 * Sets the value of the shell variable.
 */
void set_ShellVariables(ShellVariables* vars, CString* name, CString* value);

/*
 * Unsets the value of the shell variable.
 */
void unset_ShellVariables(ShellVariables* vars, CString* name);

/*
 * Returns true, iff the shell variable is set.
 */
bool isSet_ShellVariables(ShellVariables* vars, CString* name);

/*
 * Returns true, iff the shell variable is set and has the null value.
 */
bool isNull_ShellVariables(ShellVariables* vars, CString* name);

/*
 * This type represents flags used to control the behavior of wordexp().
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'wordexp.h'.
 */
typedef struct WordExpFlags
{
    bool append;                /* WRDE_APPEND */
    bool dooffs;                /* WRDE_DOOFFS */
    bool nocmd;                 /* WRDE_NOCMD */
    bool reuse;                 /* WRDE_REUSE */
    bool showerr;               /* WRDE_SHOWERR */
    bool undef;                 /* WRDE_UNDEF */
} WordExpFlags;

WordExpFlags default_WordExpFlags(void);

specification typedef WordExpFlags WordExpFlagsObj;

WordExpFlagsObj* create_WordExpFlagsObj(WordExpFlags flags);

WordExpFlagsObj* default_WordExpFlagsObj(void);

/*
 * This type represents error return values of wordexp().
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'wordexp.h'.
 */
typedef enum WordExpErrorCode
{
    SUT_WRDE_OK         =  0,
    SUT_WRDE_UNKNOWN    = -1,
    SUT_WRDE_BADCHAR    =  1,   /* WRDE_BADCHAR */
    SUT_WRDE_BADVAL     =  2,   /* WRDE_BADVAL */
    SUT_WRDE_CMDSUB     =  3,   /* WRDE_CMDSUB */
    SUT_WRDE_NOSPACE    =  4,   /* WRDE_NOSPACE */
    SUT_WRDE_SYNTAX     =  5    /* WRDE_SYNTAX */
} WordExpErrorCode;

/*****************************************************************************/
/**                                Field                                    **/
/*****************************************************************************/
typedef CString Field;

CString* toString_Field(Field *field);

/*****************************************************************************/
/**                                Fields                                   **/
/*****************************************************************************/
typedef List Fields;

Fields* create_Fields(void);

CString* toString_Fields(Fields *fields, char ifs);

/*****************************************************************************/
/**                                 Word                                    **/
/*****************************************************************************/
typedef List Word;

Word* create_Word(void);

CString* toString_Word(Word *word);

void processTildeExpansion(CallContext context, ShellVariables *vars, Word *word);
void processParameterExpansion(CallContext context, ShellVariables *vars, Word *word);
void processCommandSubstitution(CallContext context, ShellVariables *vars, Word *word);
void processArithmeticExpansion(CallContext context, ShellVariables *vars, Word *word);

Fields* processFieldSplitting(CallContext context, ShellVariables *vars, Word *word);

void processPathnameExpansion(CallContext context, Fields *fields);
void processQuoteRemoval(CallContext context, Fields *fields);

Word* preprocess_CString(CString *str);

Fields* process_Word(CallContext context, Word *word);

/*****************************************************************************/
/**                            Empty Expansion                              **/
/*****************************************************************************/
specification typedef struct EmptyWordExp
{
    CString *word;
} EmptyWordExp;

EmptyWordExp* create_EmptyWordExp(CString *word);

CString* toString_EmptyWordExp(EmptyWordExp *wordexp);

CString* getValue_EmptyWordExp(CallContext context, ShellVariables *vars, EmptyWordExp *wordexp);

/*****************************************************************************/
/**                            Tilde Expansion                              **/
/*****************************************************************************/
typedef enum TildeWordExpType
{
    HomeExpansion                      = 0,
    LoginNameExpansion                 = 1
} TildeWordExpType;

specification typedef struct TildeWordExp
{
    TildeWordExpType type;
    CString *name;
} TildeWordExp;

TildeWordExp* create_TildeWordExp(TildeWordExpType type, CString *name);

CString* toString_TildeWordExp(TildeWordExp *wordexp);

CString* getValue_TildeWordExp(CallContext context, ShellVariables *vars, TildeWordExp *wordexp);

/*****************************************************************************/
/**                          Parameter Expansion                            **/
/*****************************************************************************/
typedef enum ParameterWordExpType
{
    RegularParameterExpansion          =  0, /* ${parameter}         */
    UseDefaultValuesIfUnset            =  1, /* ${parameter-word}    */
    UseDefaultValuesIfUnsetOrNull      =  2, /* ${parameter:-word}   */
    AssignDefaultValuesIfUnset         =  3, /* ${parameter=word}    */
    AssignDefaultValuesIfUnsetOrNull   =  4, /* ${parameter:=word}   */
    IndicateErrorIfUnset               =  5, /* ${parameter?[word]}  */
    IndicateErrorIfUnsetOrNull         =  6, /* ${parameter:?[word]} */
    UseAlternativeValueIfSet           =  7, /* ${parameter+word}    */
    UseAlternativeValueIfSetAndNotNull =  8, /* ${parameter:+word}   */
    StringLength                       =  9, /* ${#parameter}        */
    RemoveSmallestSuffixPattern        = 10, /* ${parameter%word}    */
    RemoveLargestSuffixPattern         = 11, /* ${parameter%%word}   */
    RemoveSmallestPrefixPattern        = 12, /* ${parameter#word}    */
    RemoveLargestPrefixPattern         = 13  /* ${parameter##word}   */
} ParameterWordExpType;

specification typedef struct ParameterWordExp
{
    ParameterWordExpType type;
    CString *param;
    CString *word;
} ParameterWordExp;

ParameterWordExp* create_ParameterWordExp
(
    ParameterWordExpType type,
    CString *param,
    CString *word
);

CString* toString_ParameterWordExp(ParameterWordExp *wordexp);

CString* getValue_ParameterWordExp(CallContext context, ShellVariables *vars, ParameterWordExp *wordexp);

/*****************************************************************************/
/**                         Command Substitution                            **/
/*****************************************************************************/
specification typedef struct CommandWordExp
{
    CString *cmd;
    CString *res;
} CommandWordExp;

CommandWordExp* create_CommandWordExp(CString *cmd, CString *res);

CString* toString_CommandWordExp(CommandWordExp *wordexp);

CString* getValue_CommandWordExp(CallContext context, ShellVariables *vars, CommandWordExp *wordexp);

/*****************************************************************************/
/**                         Arithmetic Expansion                            **/
/*****************************************************************************/
typedef enum ArithmeticOperator
{
    IntegerValue,                           /* Integer value */
    VariableName,                           /* Shell variable */
    ParenthesisOperator,                    /* () */
    UnaryPlusOperator,                      /* unary + */
    UnaryMinusOperator,                     /* unary - */
    BitwiseNegationOperator,                /* ~ */
    NegationOperator,                       /* ! */
    MultiplicationOperator,                 /* * */
    DivisionOperator,                       /* / */
    RemainderOperator,                      /* % */
    AdditionOperator,                       /* + */
    SubstractionOperator,                   /* - */
    BitwiseShiftLeftOperator,               /* << */
    BitwiseShiftRightOperator,              /* >> */
    GreaterThanOperator,                    /* < */
    GreaterThanOrEqualToOperator,           /* <= */
    LessThanOperator,                       /* > */
    LessThanOrEqualToOperator,              /* >= */
    EqualityOperator,                       /* == */
    InequalityOperator,                     /* != */
    BitwiseAndOperator,                     /* & */
    BitwiseExclusiveOrOperator,             /* ^ */
    BitwiseOrOperator,                      /* | */
    LogicalAndOperator,                     /* && */
    LogicalOrOperator,                      /* || */
    ConditionalOperator,                    /* expr?expr:expr */
    AssignmentOperator,                     /* = */
    MultiplicationAssignmentOperator,       /* *= */
    DivisionAssignmentOperator,             /* /= */
    RemainderAssignmentOperator,            /* %= */
    AdditionAssignmentOperator,             /* += */
    SubstractionAssignmentOperator,         /* -= */
    ShiftLeftAssignmentOperator,            /* <<= */
    ShiftRightAssignmentOperator,           /* >>= */
    BitwiseAndAssignmentOperator,           /* &= */
    BitwiseExclusiveOrAssignmentOperator,   /* ^= */
    BitwiseOrAssignmentOperator,            /* |= */
} ArithmeticOperator;

bool isUnary_ArithmeticOperator(ArithmeticOperator o);
bool isBinary_ArithmeticOperator(ArithmeticOperator o);
bool isTernary_ArithmeticOperator(ArithmeticOperator o);

bool isAssignment_ArithmeticOperator(ArithmeticOperator o);

specification typedef struct ArithmeticExpression ArithmeticExpression;

specification typedef struct ArithmeticExpression
{
    ArithmeticOperator o;
    ArithmeticExpression *arg0;
    ArithmeticExpression *arg1;
    ArithmeticExpression *arg2;
    LongT val;
    CString *var;
} ArithmeticExpression;

ArithmeticExpression* create_ArithmeticExpression
(
    ArithmeticOperator o,
    ArithmeticExpression *arg0,
    ArithmeticExpression *arg1,
    ArithmeticExpression *arg2,
    LongT val,
    CString *var
);

ArithmeticExpression* create_IntegerValue(LongT val);

CString* toString_ArithmeticExpression(ArithmeticExpression *exp);

LongT getValue_ArithmeticExpression(ShellVariables *vars, ArithmeticExpression *exp);

specification typedef struct ArithmeticWordExp
{
    ArithmeticExpression* exp;
} ArithmeticWordExp;

ArithmeticWordExp* create_ArithmeticWordExp(ArithmeticExpression* exp);

CString* toString_ArithmeticWordExp(ArithmeticWordExp *wordexp);

CString* getValue_ArithmeticWordExp(CallContext context, ShellVariables *vars, ArithmeticWordExp *wordexp);

/*****************************************************************************/
/**                             Word Expansion                              **/
/*****************************************************************************/
typedef enum WordExpType
{
    EmptyExpansion      = 0,
    TildeExpansion      = 1,
    ParameterExpansion  = 2,
    CommandSubstitution = 3,
    ArithmeticExpansion = 4
} WordExpType;

specification typedef struct WordExp
{
    WordExpType type;
    Object *wordexp;
} WordExp;

WordExp* create_WordExp(WordExpType type, Object *wordexp);

WordExp* create_EmptyExpansion(CString *word);
WordExp* create_TildeExpansion(TildeWordExpType type, CString *name);
WordExp* create_ParameterExpansion(ParameterWordExpType type, CString *param, CString *word);
WordExp* create_CommandSubstitution(CString *cmd, CString *res);
WordExp* create_ArithmeticExpansion(ArithmeticExpression *exp);

CString* toString_WordExp(WordExp *wordexp);

CString* getValue_WordExp(CallContext context, ShellVariables *vars, WordExp *wordexp);

void process_WordExp(CallContext context, ShellVariables *vars, WordExp *wordexp);

typedef VoidTPtr WordExpTPtr;

/*
 * This type represents wordexp_t type
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'wordexp.h'.
 */
specification typedef struct WordExpT
{
    WordExpTPtr address;
    SizeT wordc;
    SizeT offs;
    Fields* wordv;
} WordExpT;

WordExpT* create_WordExpT(WordExpTPtr address, SizeT wordc, SizeT offs, Fields* wordv);

WordExpT* default_WordExpT(void);

WordExpT* getWordExpT(WordExpTPtr address);

/*****************************************************************************/
/**                   Auxiliary Specification Functions                     **/
/*****************************************************************************/

/** setwordexp_spec **/
specification
void setwordexp_spec(CallContext context, WordExpTPtr pwordexp, WordExpT *wordexp);

/*****************************************************************************/
/**                          Interface Functions                            **/
/*****************************************************************************/

/** wordexp_spec **/
specification
WordExpErrorCode wordexp_spec(CallContext context, Word *words, WordExpTPtr pwordexp,
                              WordExpFlags flags);

/** wordfree_spec **/
specification
void wordfree_spec(CallContext context, WordExpTPtr pwordexp);

#endif
