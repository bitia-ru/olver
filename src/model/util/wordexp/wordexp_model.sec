/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "config/interpretation.seh"
#include "util/wordexp/wordexp_config.h"
#include "process/process/process_model.seh"
#include "system/user/user_model.seh"
#include "util/wordexp/wordexp_model.seh"
#include "data/errno_model.seh"

#pragma SEC subsystem wordexp "util.wordexp"

/*
   The group of functions 'util.wordexp' consists of: 
       wordexp  [SUSv3]
       wordfree [SUSv3]
 */

/*****************************************************************************/
/**                          Interface Functions                            **/
/*****************************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    wordexp, wordfree - perform word expansions

SYNOPSIS

    #include <wordexp.h>

    int wordexp(const char *restrict words, wordexp_t *restrict pwordexp,
           int flags);
    void wordfree(wordexp_t *pwordexp);

DESCRIPTION

    The wordexp() function shall perform word expansions as described in the
    Shell and Utilities volume of IEEE Std 1003.1-2001, Section 2.6, Word
    Expansions, subject to quoting as in the Shell and Utilities volume of IEEE
    Std 1003.1-2001, Section 2.2, Quoting, and place the list of expanded words
    into the structure pointed to by pwordexp.

    The words argument is a pointer to a string containing one or more words to
    be expanded. The expansions shall be the same as would be performed by the
    command line interpreter if words were the part of a command line
    representing the arguments to a utility. Therefore, the application shall
    ensure that words does not contain an unquoted <newline> or any of the
    unquoted shell special characters '|', '&', ';', '<', '>' except in the
    context of command substitution as specified in the Shell and Utilities
    volume of IEEE Std 1003.1-2001, Section 2.6.3, Command Substitution. It
    also shall not contain unquoted parentheses or braces, except in the
    context of command or variable substitution. The application shall ensure
    that every member of words which it expects to have expanded by wordexp()
    does not contain an unquoted initial comment character. The application
    shall also ensure that any words which it intends to be ignored (because
    they begin or continue a comment) are deleted from words. If the argument
    words contains an unquoted comment character (number sign) that is the
    beginning of a token, wordexp() shall either treat the comment character as
    a regular character, or interpret it as a comment indicator and ignore the
    remainder of words.

    The structure type wordexp_t is defined in the <wordexp.h> header and
    includes at least the following members:

    Member Type     Member Name     Description

    size_t          we_wordc        Count of words matched by words.

    char **         we_wordv        Pointer to list of expanded words.

    size_t          we_offs         Slots to reserve at the beginning of
                                    pwordexp->we_wordv.

    The wordexp() function shall store the number of generated words into
    pwordexp->we_wordc and a pointer to a list of pointers to words in
    pwordexp->we_wordv. Each individual field created during field splitting
    (see the Shell and Utilities volume of IEEE Std 1003.1-2001, Section 2.6.5,
    Field Splitting) or pathname expansion (see the Shell and Utilities volume
    of IEEE Std 1003.1-2001, Section 2.6.6, Pathname Expansion) shall be a
    separate word in the pwordexp->we_wordv list. The words shall be in order
    as described in the Shell and Utilities volume of IEEE Std 1003.1-2001,
    Section 2.6, Word Expansions. The first pointer after the last word pointer
    shall be a null pointer. The expansion of special parameters described in
    the Shell and Utilities volume of IEEE Std 1003.1-2001, Section 2.5.2,
    Special Parameters is unspecified.

    It is the caller's responsibility to allocate the storage pointed to by
    pwordexp. The wordexp() function shall allocate other space as needed,
    including memory pointed to by pwordexp->we_wordv. The wordfree() function
    frees any memory associated with pwordexp from a previous call to
    wordexp().

    The flags argument is used to control the behavior of wordexp(). The value
    of flags is the bitwise-inclusive OR of zero or more of the following
    constants, which are defined in <wordexp.h>:

    WRDE_APPEND
        Append words generated to the ones from a previous call to wordexp().
    WRDE_DOOFFS
        Make use of pwordexp->we_offs. If this flag is set, pwordexp->we_offs
        is used to specify how many null pointers to add to the beginning of
        pwordexp->we_wordv. In other words, pwordexp->we_wordv shall point to
        pwordexp->we_offs null pointers, followed by pwordexp->we_wordc word
        pointers, followed by a null pointer.
    WRDE_NOCMD
        If the implementation supports the utilities defined in the Shell and
        Utilities volume of IEEE Std 1003.1-2001, fail if command substitution,
        as specified in the Shell and Utilities volume of IEEE Std 1003.1-2001,
        Section 2.6.3, Command Substitution, is requested.
    WRDE_REUSE
        The pwordexp argument was passed to a previous successful call to
        wordexp(), and has not been passed to wordfree(). The result shall be
        the same as if the application had called wordfree() and then called
        wordexp() without WRDE_REUSE.
    WRDE_SHOWERR
        Do not redirect stderr to /dev/null.
    WRDE_UNDEF
        Report error on an attempt to expand an undefined shell variable.

    The WRDE_APPEND flag can be used to append a new set of words to those
    generated by a previous call to wordexp(). The following rules apply to
    applications when two or more calls to wordexp() are made with the same
    value of pwordexp and without intervening calls to wordfree():

       1. The first such call shall not set WRDE_APPEND. All subsequent calls
          shall set it.

       2. All of the calls shall set WRDE_DOOFFS, or all shall not set it.

       3. After the second and each subsequent call, pwordexp->we_wordv shall
          point to a list containing the following:

             1. Zero or more null pointers, as specified by WRDE_DOOFFS and
                pwordexp->we_offs

             2. Pointers to the words that were in the pwordexp->we_wordv list
                before the call, in the same order as before

             3. Pointers to the new words generated by the latest call, in the
                specified order

       4. The count returned in pwordexp->we_wordc shall be the total number of
          words from all of the calls.

       5. The application can change any of the fields after a call to
          wordexp(), but if it does it shall reset them to the original value
          before a subsequent call, using the same pwordexp value, to
          wordfree() or wordexp() with the WRDE_APPEND or WRDE_REUSE flag.

    If the implementation supports the utilities defined in the Shell and
    Utilities volume of IEEE Std 1003.1-2001, and words contains an unquoted
    character- <newline>, '|', '&', ';', '<', '>', '(', ')', '{', '}' - in an
    inappropriate context, wordexp() shall fail, and the number of expanded
    words shall be 0.

    Unless WRDE_SHOWERR is set in flags, wordexp() shall redirect stderr to
    /dev/null for any utilities executed as a result of command substitution
    while expanding words. If WRDE_SHOWERR is set, wordexp() may write messages
    to stderr if syntax errors are detected while expanding words.

    The application shall ensure that if WRDE_DOOFFS is set, then
    pwordexp->we_offs has the same value for each wordexp() call and wordfree()
    call using a given pwordexp.

    The following constants are defined as error return values:

    WRDE_BADCHAR
        One of the unquoted characters- <newline>, '|', '&', ';', '<', '>',
        '(', ')', '{', '}' - appears in words in an inappropriate context.
    WRDE_BADVAL
        Reference to undefined shell variable when WRDE_UNDEF is set in flags.
    WRDE_CMDSUB
        Command substitution requested when WRDE_NOCMD was set in flags.
    WRDE_NOSPACE
        Attempt to allocate memory failed.
    WRDE_SYNTAX
        Shell syntax error, such as unbalanced parentheses or unterminated
        string.

RETURN VALUE

    Upon successful completion, wordexp() shall return 0. Otherwise, a non-zero
    value, as described in <wordexp.h>, shall be returned to indicate an error.
    If wordexp() returns the value WRDE_NOSPACE, then pwordexp->we_wordc and
    pwordexp->we_wordv shall be updated to reflect any words that were
    successfully expanded. In other cases, they shall not be modified.

    The wordfree() function shall not return a value.

ERRORS

    No errors are defined.
*/
specification
WordExpErrorCode wordexp_spec(CallContext context, Word *words, WordExpTPtr pwordexp,
                              WordExpFlags flags)
{
    WordExpT *pre_wordexp = clone(getWordExpT(pwordexp));

    pre
    {
        traceFormattedUserInfo("wordexp_spec: words=$(obj)", toString_Word(words));

        /*
         * It is the caller's responsibility to allocate the storage pointed to
         * by pwordexp.
         */
        REQ("app.wordexp.01", "pwordexp is valid", isValidPointer(context, pwordexp));

        return true;
    }
    coverage C
    {
        WORD_COVERAGE(words, wordexp, "wordexp()");
    }
    coverage C_wordexp
    {
        WORDEXP_COVERAGE(pwordexp, wordexp, "wordexp()");
    }
    post
    {
        WordExpT *post_wordexp = getWordExpT(pwordexp);
        Fields* fields = process_Word(context, words);

        SizeT size = post_wordexp->wordc - (flags.dooffs ? post_wordexp->offs : 0);

        traceFormattedUserInfo("wordexp_spec: fields=$(obj)", fields);
        traceFormattedUserInfo("wordexp_spec: wordv=$(obj)", post_wordexp->wordv);


        if(wordexp_spec != SUT_WRDE_OK)
        {
            /* If wordexp() returns the value WRDE_NOSPACE */
            if(wordexp_spec == SUT_WRDE_NOSPACE)
            {
                int i, j;

                /*
                 * then pwordexp->we_wordc and pwordexp->we_wordv shall be
                 * updated to reflect any words that were successfully
                 * expanded.
                 */
                REQ("wordexp.02.06", "wordexp() shall not expand more than it is expected",
                    size <= size_List(fields));

                for(i = j = 0; (SizeT)i < size; i++)
                {
                    if(!equals(get_List(fields, i), get_List(post_wordexp->wordv, i)))
                    {
                        j = -1;
                        break;
                    }
                }

                REQ("wordexp.02.06", "wordexp() shall update pwordexp", j == 0);
            }
            else
            {
                if(pre_wordexp != NULL)
                {
                    /* In other cases, they shall not be modified */
                    REQ("wordexp.02.07", "wordexp() shall not modify pwordexp",
                        equals(post_wordexp, pre_wordexp));
                }
            }
        }

        /*
         * [On error,] a non-zero value, as described in <wordexp.h>, shall be
         * returned to indicate an error.
         */
        ERROR_BEGIN(POSIX_WORDEXP, "wordexp.20.02", wordexp_spec != SUT_WRDE_OK, wordexp_spec);

            /*
             * WRDE_BADCHAR
             *
             * One of the unquoted characters- <newline>, '|', '&', ';', '<',
             * '>', '(', ')', '{', '}' - appears in words in an inappropriate
             * context.
             */
            ERROR_UNCHECKABLE(POSIX_WORDEXP, WRDE_BADCHAR, "wordexp.20.02.01",
                "TODO");

            /*
             * WRDE_BADVAL
             * 
             * Reference to undefined shell variable when WRDE_UNDEF is set in
             * flags.
             */
            ERROR_UNCHECKABLE(POSIX_WORDEXP, WRDE_BADVAL, "wordexp.20.02.02",
                "TODO");

            /*
             * WRDE_CMDSUB
             *
             * Command substitution requested when WRDE_NOCMD was set in flags.
             */
            ERROR_UNCHECKABLE(POSIX_WORDEXP, WRDE_CMDSUB, "wordexp.20.02.03",
                "TODO");

            /*
             * WRDE_NOSPACE
             *
             * Attempt to allocate memory failed.
             */
            ERROR_UNCHECKABLE(POSIX_WORDEXP, WRDE_NOSPACE, "wordexp.20.02.04",
                "Memory allocation failure");

            /*
             * WRDE_SYNTAX
             *
             * Shell syntax error, such as unbalanced parentheses or
             * unterminated string.
             */
            ERROR_UNCHECKABLE(POSIX_WORDEXP, WRDE_SYNTAX, "wordexp.20.02.05",
                "TODO");

        ERROR_END();

        /* Upon successful completion, wordexp() shall return 0 */
        REQ("wordexp.20.01", "On success, wordexp() shall return 0",
            wordexp_spec == SUT_WRDE_OK);

        /*
         * WRDE_APPEND
         *
         * Append words generated to the ones from a previous call to
         * wordexp().
         */
        REQ("wordexp.05.01", 
            "Append words generated to the ones from a previous call", 
            true);

        /*
         * WRDE_DOOFFS
         *
         * Make use of pwordexp->we_offs. If this flag is set,
         * pwordexp->we_offs is used to specify how many null pointers to add
         * to the beginning of pwordexp->we_wordv. In other words,
         * pwordexp->we_wordv shall point to pwordexp->we_offs null pointers,
         * followed by pwordexp->we_wordc word pointers, followed by a null
         * pointer.
         */
        REQ("wordexp.05.02", 
            "Make use WRDE_DOOFFS", 
            true);

        /*
         * WRDE_NOCMD
         * 
         * If the implementation supports the utilities defined in the Shell
         * and Utilities volume of IEEE Std 1003.1-2001, fail if command
         * substitution, as specified in the Shell and Utilities volume of IEEE
         * Std 1003.1-2001, Section 2.6.3, Command Substitution, is requested.
         */
        REQ("wordexp.05.03", 
            "Make use WRDE_NOCMD", 
            true);

        /*
         * WRDE_REUSE
         *
         * The pwordexp argument was passed to a previous successful call to
         * wordexp(), and has not been passed to wordfree(). The result shall
         * be the same as if the application had called wordfree() and then
         * called wordexp() without WRDE_REUSE.
         */
        REQ("wordexp.05.04", 
            "Make use WRDE_REUSE", 
            true);

        /*
         * WRDE_SHOWERR
         *
         * Do not redirect stderr to /dev/null.
         */

        /*
         * Unless WRDE_SHOWERR is set in flags, wordexp() shall redirect stderr
         * to /dev/null for any utilities executed as a result of command
         * substitution while expanding words.
         */
        REQ("wordexp.05.01", 
            "Make use WRDE_SHOWERR", 
            true);

        /*
         * If WRDE_SHOWERR is set, wordexp() may write messages to stderr if
         * syntax errors are detected while expanding words.
         */
        REQ("wordexp.05.02", 
            "Make use WRDE_SHOWERR", 
            true);

        /*
         * WRDE_UNDEF
         *
         * Report error on an attempt to expand an undefined shell variable.
         */
        REQ("wordexp.05.06", 
            "Make use WRDE_UNDEF", 
            true);

        /*
         * The wordexp() function shall store the number of generated words
         * into pwordexp->we_wordc and a pointer to a list of pointers to words
         * in pwordexp->we_wordv.
         */
        REQ("wordexp.01", "wordexp() shall generate words into pwordexp->we_wordv",
            equals(fields, post_wordexp->wordv));

        REQ("wordexp.01", "wordexp() shall set pwordexp->we_wordc",
            size_List(post_wordexp->wordv) == size);

    /*
     * Next, the shell shall treat this as an arithmetic expression and
     * substitute the value of the expression.
     */
    REQ("sh.wordexp.arithmetic.02","",TODO_REQ());


    /* Embedded <newline>s before the end of the output shall not be removed */
    REQ("sh.wordexp.command.02","",TODO_REQ());


    /*
     * The results of command substitution shall not be processed for further
     * tilde expansion, parameter expansion, command substitution, or
     * arithmetic expansion.
     */
    REQ("sh.wordexp.command.03","",TODO_REQ());

        return true;
    }
}

specification
void wordfree_spec(CallContext context, WordExpTPtr pwordexp)
{
    pre
    {
        /* [Consistency of test suite] */
        REQ("", "pwordexp is valid", isValidPointer(context, pwordexp));

        return true;
    }
    coverage C
    {
        WORDEXP_COVERAGE(pwordexp, wordfree, "wordfree()");
    }
    post
    {
        /*
         * The wordfree() function frees any memory associated with pwordexp
         * from a previous call to wordexp().
         */
        REQ("?wordfree.01", "wordfree() shall frees memory",
            equals(getWordExpT(pwordexp), NULL));

        return true;
    }
}

/*****************************************************************************/
/**                          Shell Variable                                 **/
/*****************************************************************************/
typedef specification struct ShellVariable ShellVariable = {};

/*
 * Creates shell variable with given name and value.
 */
ShellVariable* create_ShellVariable(CString *name, CString *value)
{
    assertion(name != NULL, "create_ShellVariable: name is NULL");

    return create(&type_ShellVariable, name, value);
}

/*
 * Creates shell variable with given name and null value.
 */
ShellVariable* null_ShellVariable(CString *name)
{
    assertion(name != NULL, "null_ShellVariable: name is NULL");

    return create_ShellVariable(name, NULL);
}

/*
 * Creates shell variable with given name and empty value.
 */
ShellVariable* empty_ShellVariable(CString *name)
{
    assertion(name != NULL, "empty_ShellVariable: name is NULL");

    return create_ShellVariable(name, create_CString(""));
}

/*
 * Returns true, iff the shell variable is null.
 */
bool isNull_ShellVariable(ShellVariable *var)
{
    assertion(var != NULL, "isNull_ShellVariable: var is NULL");

    return var->value == NULL;
}

/*
 * Returns the name of the shell variable.
 */
CString* getName_ShellVariable(ShellVariable *var)
{
    assertion(var != NULL, "getName_ShellVariable: var is NULL");

    return var->name;
}

/*
 * Returns the value of the shell variable.
 */
CString* getValue_ShellVariable(ShellVariable *var)
{
    assertion(var != NULL, "getValue_ShellVariable: var is NULL");

    return var->value;
}

/*****************************************************************************/
/**                          Shell Variables                                **/
/*****************************************************************************/

/*
 * Creates set of shell variables based on environment variables.
 */
ShellVariables* create_ShellVariables(Map* env)
{
    int i, size;
    ShellVariables *vars;

    assertion(env != NULL, "create_ShellVariables: env is NULL");

    vars = empty_ShellVariables();
    
    size = size_Map(env);
    for(i = 0; i < size; i++)
    {
        CString *name = key_Map(env, i);

        set_ShellVariables(vars, name, get_Map(env, name));
    }

    return vars;
}

/*
 * Creates empty set of shell variables.
 */
ShellVariables* empty_ShellVariables(void)
{
    return create_Map(&type_CString, &type_ShellVariable);
}

/*
 * Returns the value of the shell variable or NULL, if the shell variable is
 * unset.
 */
CString* get_ShellVariables(ShellVariables *vars, CString *name)
{
    ShellVariable *var;

    assertion(vars != NULL, "get_ShellVariables: vars is NULL");
    assertion(name != NULL, "get_ShellVariables: name is NULL");

    return (var = get_Map(vars, name)) != NULL ? getValue_ShellVariable(var) : NULL;
}

/*
 * Sets the value of the shell variable.
 */
void set_ShellVariables(ShellVariables* vars, CString* name, CString* value)
{
    ShellVariable *var;

    assertion(vars != NULL, "set_ShellVariables: vars is NULL");
    assertion(name != NULL, "set_ShellVariables: name is NULL");

    if(var == NULL)
    {
        put_Map(vars, name, create_ShellVariable(name, value));
    }
    else
    {
        var->value = value;
    }
}

/*
 * Unsets the value of the shell variable.
 */
void unset_ShellVariables(ShellVariables* vars, CString* name)
{
    assertion(vars != NULL, "unset_ShellVariables: vars is NULL");
    assertion(name != NULL, "unset_ShellVariables: name is NULL");

    remove_Map(vars, name);
}

/*
 * Returns true, iff the shell variable is set.
 */
bool isSet_ShellVariables(ShellVariables* vars, CString* name)
{
    assertion(vars != NULL, "isSet_ShellVariables: vars is NULL");
    assertion(name != NULL, "isSet_ShellVariables: name is NULL");

    return !equals(get_Map(vars, name), NULL);    
}

/*
 * Returns true, iff the shell variable is set and has the null value.
 */
bool isNull_ShellVariables(ShellVariables* vars, CString* name)
{
    ShellVariable *var;

    assertion(vars != NULL, "isNull_ShellVariables: vars is NULL");
    assertion(name != NULL, "isNull_ShellVariables: name is NULL");

    return (var = get_Map(vars, name)) != NULL && var->value == NULL;
}

/*
 * This type represents wordexp_t type
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'wordexp.h'.
 */
specification typedef struct WordExpT WordExpT = {};

WordExpT* create_WordExpT(WordExpTPtr address, SizeT wordc, SizeT offs, Fields* wordv)
{
    return create(&type_WordExpT, address, wordc, offs, wordv);
}

WordExpT* default_WordExpT(void)
{
    return create_WordExpT
    (
        NULL_VoidTPtr,              /* address */
        0,                          /* wordc */
        0,                          /* offs */
        create_List(&type_CString)  /* wordv */
    );
}

WordExpT* getWordExpT(WordExpTPtr address)
{
    return getObjectInMemory(address);
}

/*
 * This type represents flags values used to control the behavior of wordexp().
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'wordexp.h'.
 */
WordExpFlags default_WordExpFlags(void)
{
    WordExpFlags flags = { false, false, false, false, false, false };

    return flags;
}

specification typedef WordExpFlags WordExpFlagsObj = {};

WordExpFlagsObj* create_WordExpFlagsObj(WordExpFlags flags)
{
    return create
    (
        &type_WordExpFlagsObj,
        flags.append,
        flags.dooffs,
        flags.nocmd,
        flags.reuse,
        flags.showerr,
        flags.undef
    );
}

WordExpFlagsObj* default_WordExpFlagsObj(void)
{
    return create_WordExpFlagsObj(default_WordExpFlags());
}

/*****************************************************************************/
/**                                Field                                    **/
/*****************************************************************************/
CString* toString_Field(Field *field)
{
    assertion(field != NULL, "toString_Field: field is NULL");

    return field;
}

/*****************************************************************************/
/**                                Fields                                   **/
/*****************************************************************************/
Fields* create_Fields(void)
{
    return create_List(&type_CString);
}

CString* toString_Fields(Fields *fields, char ifs)
{
    int i, size;
    CString *res;

    assertion(fields != NULL, "toString_Fields: fields is NULL");

    res = (size = size_List(fields)) > 0 ?
        create_CString(get_List(fields, 0)) : create_CString("");

    for(i = 1; i < size; i++)
    {
        res = concat_CString(res, format_CString("%c", ifs));
        res = concat_CString(res, get_List(fields, i));
    }

    return res;
}

/*****************************************************************************/
/**                                 Word                                    **/
/*****************************************************************************/
Word* create_Word(void)
{
    return create_List(&type_WordExp);
}

CString* toString_Word(Word *word)
{
    int i, size;
    CString *str, *res;

    assertion(word != NULL, "toString_Word: word is NULL");

    size = size_List(word);
    res = create_CString("");
    for(i = 0; i < size; i++)
    {
        str = toString_WordExp(get_List(word, i));

        assertion(str != NULL, "toString_Word: str is NULL");

        res = concat_CString(res, str);
    }

    return res;
}

void processTildeExpansion(CallContext context, ShellVariables *vars, Word *word)
{
    int i, size;

    assertion(word != NULL, "processTildeExpansions: word is NULL");
    assertion(vars != NULL, "processTildeExpansions: vars is NULL");

    size = size_List(word);
    for(i = 0; i < size; i++)
    {
        WordExp *wordexp = get_List(word, i);
        if(wordexp->type == TildeExpansion)
        {
            process_WordExp(context, vars, wordexp);
        }
    }
}

void processParameterExpansion(CallContext context, ShellVariables *vars, Word *word)
{
    int i, size;

    assertion(word != NULL, "processParameterExpansion: word is NULL");
    assertion(vars != NULL, "processParameterExpansion: vars is NULL");

    size = size_List(word);
    for(i = 0; i < size; i++)
    {
        WordExp *wordexp = get_List(word, i);
        if(wordexp->type == ParameterExpansion)
        {
            process_WordExp(context, vars, wordexp);
        }
    }
}

void processCommandSubstitution(CallContext context, ShellVariables *vars, Word *word)
{
    int i, size;

    assertion(word != NULL, "processCommandSubstitution: word is NULL");
    assertion(vars != NULL, "processCommandSubstitution: vars is NULL");

    size = size_List(word);
    for(i = 0; i < size; i++)
    {
        WordExp *wordexp = get_List(word, i);
        if(wordexp->type == CommandSubstitution)
        {
            process_WordExp(context, vars, wordexp);
        }
    }
}

void processArithmeticExpansion(CallContext context, ShellVariables *vars, Word *word)
{
    int i, size;

    assertion(word != NULL, "processArithmeticExpansion: word is NULL");
    assertion(vars != NULL, "processArithmeticExpansion: word is NULL");

    size = size_List(word);
    for(i = 0; i < size; i++)
    {
        WordExp *wordexp = get_List(word, i);
        if(wordexp->type == ArithmeticExpansion)
        {
            process_WordExp(context, vars, wordexp);
        }
    }
}

static bool isSpaceTabNewline_CString(CString *ifs)
{
    int i, length;
    bool space, tab, newline, other;

    assertion(ifs != NULL, "isSpaceTabNewline_CString: ifs is NULL");

    length = length_CString(ifs);
    space = tab = newline = other = false;
    for(i = 0; i < length; i++)
    {
        switch(charAt_CString(ifs, i))
        {
        case ' ':
            space = true;
            break;
        case '\t':
            tab = true;
            break;
        case '\n':
            newline = true;
            break;
        default:
            return false;
        }
    }

    return space && tab && newline;
}

static CString* getIFSWhiteSpace_CString(CString *ifs)
{
    int i = 0;
    CharT white_space[7];

    assertion(ifs != NULL, "getIFSWhiteSpace_CString: ifs is NULL");

    if(indexOfChar_CString(ifs, ' ') != -1)
        white_space[i++] = ' ';
    if(indexOfChar_CString(ifs, '\f') != -1)
        white_space[i++] = '\f';
    if(indexOfChar_CString(ifs, '\n') != -1)
        white_space[i++] = '\n';
    if(indexOfChar_CString(ifs, '\r') != -1)
        white_space[i++] = '\r';
    if(indexOfChar_CString(ifs, '\t') != -1)
        white_space[i++] = '\t';
    if(indexOfChar_CString(ifs, '\v') != -1)
        white_space[i++] = '\v';
    
    white_space[i] = '\x00';

    return create_CString(white_space);
}

Fields* processFieldSplitting(CallContext context, ShellVariables *vars, Word *word)
{
    int i, j, k, length;
    bool is_empty_field, is_ifs, is_ifs_white_space;
    CString *str, *ifs, *ifs_white_space;
    Fields *res;

    assertion(vars != NULL, "processFieldSplitting: vars is NULL");
    assertion(word != NULL, "processFieldSplitting: word is NULL");

    str = toString_Word(word);

    traceFormattedUserInfo("processFieldSplitting: word=$(obj)", str);

    res = create_Fields();

    /*
     * If a command substitution occurs inside double-quotes, field splitting
     * and pathname expansion shall not be performed on the results of the
     * substitution.
     */
    IMPLEMENT_REQ("sh.wordexp.command.04");



    /* If the value of IFS is null */
    if(isNull_ShellVariables(vars, create_CString("IFS")))
    {
        /* no field splitting shall be performed */
        IMPLEMENT_REQ("sh.wordexp.field.02");

        append_List(res, str);

        return res;
    }

    /*
     * If IFS is not set, the shell shall behave as if the value of IFS is
     * <space>, <tab>, and <newline>;
     */
    ifs = !isSet_ShellVariables(vars, create_CString("IFS")) ?
        create_CString(" \t\n") : get_ShellVariables(vars, create_CString("IFS"));

    ifs_white_space = getIFSWhiteSpace_CString(ifs);

    /*
     * If the value of IFS is a <space>, <tab>, and <newline>, or if it is
     * unset
     */
    if(isSpaceTabNewline_CString(ifs))
    {
        /*
         * any sequence of <space>s, <tab>s, or <newline>s at the beginning
         * or end of the input shall be ignored and any sequence of those
         * characters within the input shall delimit a field.
         */
        IMPLEMENT_REQ("sh.wordexp.field.01");
    }

    length = length_CString(str);
    for(i = 0; i < length; i++)
    {
        if(indexOfChar_CString(ifs_white_space, charAt_CString(str, i)) != -1)
        {
            /*
             * IFS white space shall be ignored at the beginning and end of the
             * input.
             */
            IMPLEMENT_REQ("sh.wordexp.field.03.01");
        }
        else
        {
            break;
        }
    }

    if(i == length)
    {
        return res;
    }

    for(;length > i; length--)
    {
        if(indexOfChar_CString(ifs_white_space, charAt_CString(str, i)) != -1)
        {
            /*
             * IFS white space shall be ignored at the beginning and end of the
             * input.
             */
            IMPLEMENT_REQ("sh.wordexp.field.03.01");
        }
        else
        {
            break;
        }
    }

    is_ifs_white_space = true;
    is_ifs = is_empty_field = false;
    for(j = -1; i < length; i++)
    {
        /* [Not an IFS character] */
        if(indexOfChar_CString(ifs, charAt_CString(str, i)) == -1)
        {
            if(j == -1 && is_ifs)
            {
                if(!is_ifs_white_space)
                {
                    /*
                     * Each occurrence in the input of an IFS character that is
                     * not IFS white space, along with any adjacent IFS white
                     * space, shall delimit a field, as described previously.
                     */
                    IMPLEMENT_REQ("sh.wordexp.field.03.02");
                }
                else
                {
                    /* Non-zero-length IFS white space shall delimit a field */
                    IMPLEMENT_REQ("sh.wordexp.field.03.03");
                }

                is_ifs = false;
                is_ifs_white_space = true;
            }

            k = i; j = j == -1 ? i : j;
        }
        /* [An IFS character] */
        else
        {
            bool is_ifs_white_space_character =
                indexOfChar_CString(ifs_white_space, charAt_CString(str, i)) != -1;

            is_ifs = true;
            is_ifs_white_space = is_ifs_white_space && is_ifs_white_space_character;

            if(j != -1)
            {
                append_List(res, substring_CString(str, j, k + 1));

                j = -1; is_empty_field = false;
            }
            /* [Not an IFS white-space character] */
            else if(!is_ifs_white_space_character)
            {
                if(is_empty_field)
                {
                    append_List(res, create_CString(""));
                }
 
                is_empty_field = true;
            }
        }
    }

    if(j != -1)
    {
        append_List(res, substring_CString(str, j, k + 1));
    }
    else if(is_empty_field)
    {
        append_List(res, create_CString(""));
    }

    return res;
}

void processPathnameExpansion(CallContext context, Fields *fields)
{
    assertion(fields != NULL, "processPathnameExpansion: fields is NULL");

    traceFormattedUserInfo("processPathnameExpansion: fields=$(obj)", fields);

    /*
     * After field splitting, if set -f is not in effect, each field in the
     * resulting command line shall be expanded using the algorithm described
     * in Pattern Matching Notation , qualified by the rules in Patterns Used
     * for Filename Expansion.
     */
    IMPLEMENT_REQ("sh.wordexp.pathname.01");

}

void processQuoteRemoval(CallContext context, Fields *fields)
{
    int i, j, size;
    
    assertion(fields != NULL, "processQuoteRemoval: fields is NULL");

    traceFormattedUserInfo("processQuoteRemoval: fields=$(obj)", fields);

    /*
     * The quote characters: '\', '", and '' (backslash, single-quote,
     * double-quote) that were present in the original word shall be removed
     * unless they have themselves been quoted.
     */
    IMPLEMENT_REQ("sh.wordexp.quote.01");

    size = size_List(fields);
    for(i = 0; i < size; i++)
    {
        Field *field = get_List(fields, i);
        CharT *array = toCharArray_CString(field);
        CharT *res = malloc((length_CString(field) + 1) * sizeof(CharT));

        assertion(res != NULL, "processQuoteRemoval: res is NULL");

        for(j = 0; *array != '\x00'; array++)
        {
            if(*array == '\\' && *(array + 1) != '\x00')
            {
                res[j++] = *++array;
            }
            else if(*array != '\\' && *array != '\'' && *array != '"')
            {
                res[j++] = *array;
            }
        }

        res[j] = '\x00';

        copy(create_CString(res), field);

        free(res);
    }
}

Word* preprocess_CString(CString *str)
{
    assertion(str != NULL, "preprocess_CString: str is NULL");


    assertion(false, "preprocess_CString: not supported yet");

    return NULL;
}

Fields* process_Word(CallContext context, Word *word)
{
    Fields *fields;
    ShellVariables *vars;

    Map *env = getProcessEnvironment(context);
        
    assertion(word != NULL, "process_Word: word is NULL");
    assertion(env != NULL, "process_Word: env is NULL");

    vars = create_ShellVariables(env);

    processTildeExpansion(context, vars, word);
    processParameterExpansion(context, vars, word);
    processCommandSubstitution(context, vars, word);
    processArithmeticExpansion(context, vars, word);

    fields = processFieldSplitting(context, vars, word);

    processPathnameExpansion(context, fields);
    processQuoteRemoval(context, fields);
    
    return fields;
}

/*****************************************************************************/
/**                            Empty Expansion                              **/
/*****************************************************************************/
specification typedef struct EmptyWordExp EmptyWordExp = {};

EmptyWordExp* create_EmptyWordExp(CString *word)
{
    return create(&type_EmptyWordExp, word);
}

CString* toString_EmptyWordExp(EmptyWordExp *wordexp)
{
    assertion(wordexp != NULL, "toString_EmptyWordExp: wordexp is NULL");

    return wordexp->word;
}

CString* getValue_EmptyWordExp(CallContext context, ShellVariables *vars, EmptyWordExp *wordexp)
{
    assertion(wordexp != NULL, "getValue_EmptyWordExp: wordexp is NULL");
    assertion(vars != NULL, "getValue_EmptyWordExp: vars is NULL");

    return wordexp->word;
}

/*****************************************************************************/
/**                            Tilde Expansion                              **/
/*****************************************************************************/
specification typedef struct TildeWordExp TildeWordExp = {};

TildeWordExp* create_TildeWordExp(TildeWordExpType type, CString *name)
{
    return create(&type_TildeWordExp, type, name);
}

CString* toString_TildeWordExp(TildeWordExp *wordexp)
{
    assertion(wordexp != NULL, "toString_TildeWordExp: wordexp is NULL");

    switch(wordexp->type)
    {
    case HomeExpansion:
        return create_CString("~");
    case LoginNameExpansion:
        return format_CString("~$(obj)", wordexp->name);
    default:
        assertion(false, "toString_TildeWordExp: Unknown tilde expansion type");
        break;
    }

    return NULL;
}

CString* getValue_TildeWordExp(CallContext context, ShellVariables *vars, TildeWordExp *wordexp)
{
    ProcessState *process_state;

    assertion(wordexp != NULL, "getValue_TildeWordExp: wordexp is NULL");
    assertion(vars != NULL, "getValue_TildeWordExp: word is NULL");

    switch(wordexp->type)
    {
    case HomeExpansion:
        /*
         * If the login name is null (that is, the tilde-prefix contains only
         * the tilde), the tilde-prefix is replaced by the value of the
         * variable HOME.
         */
        IMPLEMENT_REQ("sh.wordexp.tilde.01");

        return get_ShellVariables(vars, create_CString("HOME"));
    case LoginNameExpansion:
        /*
         * Otherwise, the tilde-prefix shall be replaced by a pathname of the
         * initial working directory associated with the login name obtained
         * using the getpwnam() function as defined in the System Interfaces
         * volume of IEEE Std 1003.1-2001.
         */
        IMPLEMENT_REQ("sh.wordexp.tilde.02");

        process_state = getProcessState_CallContext(context);

        assertion(process_state != NULL, "getValue_TildeWordExp: process_state is NULL");
        assertion(process_state->users != NULL, "getValue_TildeWordExp: process_state->users is NULL");

        if(process_state->isSetFilled)
        {
            Passwd *passwd = getpwnam_model(process_state->users, wordexp->name);

            assertion(passwd != NULL, "getValue_TildeWordExp: passwd is NULL");

            return passwd->pw_dir;
        }

        break;
    default:
        assertion(false, "getValue_TildeWordExp: Unknown tilde expansion type");
        break;
    }

    return NULL;
}

/*****************************************************************************/
/**                          Parameter Expansion                            **/
/*****************************************************************************/
specification typedef struct ParameterWordExp ParameterWordExp = {};

ParameterWordExp* create_ParameterWordExp
(
    ParameterWordExpType type,
    CString *param,
    CString *word
)
{
    return create(&type_ParameterWordExp, type, param, word);
}

CString* toString_ParameterWordExp(ParameterWordExp *wordexp)
{
    CString *res;

    assertion(wordexp != NULL, "toString_ParameterWordExp: wordexp is NULL");

    switch(wordexp->type)
    {
    /* ${parameter} */
    case RegularParameterExpansion:
        res = concat_CString(create_CString("${"), wordexp->param);
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter-word} */
    case UseDefaultValuesIfUnset:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)-$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter:-word} */
    case UseDefaultValuesIfUnsetOrNull:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj):-$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter=word} */
    case AssignDefaultValuesIfUnset:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)=$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter:=word} */
    case AssignDefaultValuesIfUnsetOrNull:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj):=$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter?[word]} */
    case IndicateErrorIfUnset:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)?$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter:?[word]} */
    case IndicateErrorIfUnsetOrNull:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj):?$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter+word} */
    case UseAlternativeValueIfSet:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)+$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter:+word} */
    case UseAlternativeValueIfSetAndNotNull:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj):+$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${#parameter} */
    case StringLength:
        res = concat_CString(create_CString("${#"), wordexp->param);
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter%word} */
    case RemoveSmallestSuffixPattern:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)%$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter%%word} */
    case RemoveLargestSuffixPattern:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)%%$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter#word} */
    case RemoveSmallestPrefixPattern:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)#$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    /* ${parameter##word} */
    case RemoveLargestPrefixPattern:
        res = concat_CString(create_CString("${"),
            format_CString("$(obj)##%$(obj)", wordexp->param, wordexp->word));
        res = concat_CString(res, create_CString("}"));
        return res;
    default:
        assertion(false, "toString_ParameterWordExp: Unknown parameter expansion type");
        break;
    }

    return NULL;
}

CString* getValue_ParameterWordExp(CallContext context, ShellVariables *vars, ParameterWordExp *wordexp)
{
    CString* val;
    bool is_set, is_null;

    assertion(wordexp != NULL, "getValue_ParameterWordExp: wordexp is NULL");
    assertion(vars != NULL, "getValue_ParameterWordExp: vars is NULL");

    is_set = isSet_ShellVariables(vars, wordexp->param);
    is_null = isNull_ShellVariables(vars, wordexp->param);

    val = get_ShellVariables(vars, wordexp->param);

    if(val == NULL)
    {
        val = create_CString("");
    }

    switch(wordexp->type)
    {
    /* ${parameter} */
    case RegularParameterExpansion:
        /* The value, if any, of parameter shall be substituted */
        IMPLEMENT_REQ("sh.wordexp.parameter.01");
        
        return val;
    /* ${parameter-word} */
    case UseDefaultValuesIfUnset:
        if(!is_set)
        {
            /* substitute word */
            IMPLEMENT_REQ("sh.wordexp.parameter.06.01");

            return  wordexp->word;
        }

        /* substitute parameter */
        IMPLEMENT_REQ("sh.wordexp.parameter.06.02");

        return val;
    /* ${parameter:-word} */
    case UseDefaultValuesIfUnsetOrNull:
        if(!is_set || is_null)
        {
            /* substitute word */
            IMPLEMENT_REQ("sh.wordexp.parameter.02.01");

            return wordexp->word;
        }

        /* substitute parameter */
        IMPLEMENT_REQ("sh.wordexp.parameter.02.02");

        return val;
    /* ${parameter=word} */
    case AssignDefaultValuesIfUnset:
        if(!is_set)
        {
            /* assign word */
            IMPLEMENT_REQ("sh.wordexp.parameter.07.01");

            set_ShellVariables(vars, wordexp->param, val = wordexp->word);
            return val;
        }

        /* substitute parameter */
        IMPLEMENT_REQ("sh.wordexp.parameter.07.02");

        return val;
    /* ${parameter:=word} */
    case AssignDefaultValuesIfUnsetOrNull:
        if(!is_set || is_null)
        {
            /* assign word */
            IMPLEMENT_REQ("sh.wordexp.parameter.03.01");

            set_ShellVariables(vars, wordexp->param, val = wordexp->word);
            return val;
        }

        /* substitute parameter */
        IMPLEMENT_REQ("sh.wordexp.parameter.03.02");

        return val;
    /* ${parameter?[word]} */
    case IndicateErrorIfUnset:
        if(!is_set)
        {
            /* error, exit */
            IMPLEMENT_REQ("sh.wordexp.parameter.08.01");

            assertion(wordexp->word != NULL && length_CString(wordexp->word) != 0,
                "getValue_ParameterWordExp: ${parameter?} is not supported");

            // TODO: substitute to word and exit
            return NULL;
        }

        /* substitute parameter */
        IMPLEMENT_REQ("sh.wordexp.parameter.08.02");

        return val;
    /* ${parameter:?[word]} */
    case IndicateErrorIfUnsetOrNull:
        if(!is_set || is_null)
        {
            /* error, exit */
            IMPLEMENT_REQ("sh.wordexp.parameter.04.01");
            
            assertion(wordexp->word != NULL && length_CString(wordexp->word) != 0,
                "getValue_ParameterWordExp: ${parameter:?} is not supported");

            // TODO: substitute to word and exit
            return NULL;
        }

        /* substitute parameter */
        IMPLEMENT_REQ("sh.wordexp.parameter.04.02");

        return val;
    /* ${parameter+word} */
    case UseAlternativeValueIfSet:
        if(is_set)
        {
            /* substitute word */
            IMPLEMENT_REQ("sh.wordexp.parameter.09.01");

            return wordexp->word;
        }

        /* substitute null */
        IMPLEMENT_REQ("sh.wordexp.parameter.09.02");

        return val;
    /* ${parameter:+word} */
    case UseAlternativeValueIfSetAndNotNull:
        if(is_set && !is_null)
        {
            /* substitute word */
            IMPLEMENT_REQ("sh.wordexp.parameter.05.01");

            return wordexp->word;
        }

        /* substitute null */
        IMPLEMENT_REQ("sh.wordexp.parameter.05.02");

        return val;
    /* ${#parameter} */
    case StringLength:
        /*
         * The length in characters of the value of parameter shall be
         * substituted.
         */
        IMPLEMENT_REQ("sh.wordexp.parameter.10");

        return format_CString("%ld", val != NULL ? length_CString(val) : 0);
    /* ${parameter%word} */
    case RemoveSmallestSuffixPattern:
        /*
         * The word shall be expanded to produce a pattern. The parameter
         * expansion shall then result in parameter, with the smallest portion
         * of the suffix matched by the pattern deleted.
         */
        IMPLEMENT_REQ("sh.wordexp.parameter.11");

        assertion(false, "getValue_ParameterWordExp: ${parameter%word} is not supported yet");
        break;
    /* ${parameter%%word} */
    case RemoveLargestSuffixPattern:
        /*
         * The word shall be expanded to produce a pattern. The parameter
         * expansion shall then result in parameter, with the largest portion
         * of the suffix matched by the pattern deleted.
         */
        IMPLEMENT_REQ("sh.wordexp.parameter.12");


        assertion(false, "getValue_ParameterWordExp: ${parameter%%word} is not supported yet");
        break;
    /* ${parameter#word} */
    case RemoveSmallestPrefixPattern:
        /*
         * The word shall be expanded to produce a pattern. The parameter
         * expansion shall then result in parameter, with the smallest portion
         * of the prefix matched by the pattern deleted.
         */
        IMPLEMENT_REQ("sh.wordexp.parameter.13");


        assertion(false, "getValue_ParameterWordExp: ${parameter#word} is not supported yet");
        break;
    /* ${parameter##word} */
    case RemoveLargestPrefixPattern:
        /*
         * The word shall be expanded to produce a pattern. The parameter
         * expansion shall then result in parameter, with the largest portion
         * of the prefix matched by the pattern deleted.
         */
        IMPLEMENT_REQ("sh.wordexp.parameter.14");

        assertion(false, "getValue_ParameterWordExp: ${parameter##word} is not supported yet");
        break;
    default:
        assertion(false, "getValue_ParameterWordExp: Unknown parameter expansion type");
        break;
    }

    return NULL;
}

/*****************************************************************************/
/**                         Command Substitution                            **/
/*****************************************************************************/
specification typedef struct CommandWordExp CommandWordExp = {};

CommandWordExp* create_CommandWordExp(CString *cmd, CString *res)
{
    return create(&type_CommandWordExp, cmd, res);
}

CString* toString_CommandWordExp(CommandWordExp *wordexp)
{
    CString *res;

    assertion(wordexp != NULL, "toString_CommandWordExp: wordexp is NULL");

    res = concat_CString(create_CString("$("), wordexp->cmd);
    res = concat_CString(res, create_CString(")"));

    return res;
}

CString* getValue_CommandWordExp(CallContext context, ShellVariables *vars, CommandWordExp *wordexp)
{
    assertion(wordexp != NULL, "getValue_CommandWordExp: wordexp is NULL");
    assertion(vars != NULL, "getValue_CommandWordExp: vars is NULL");

    /*
     * The shell shall expand the command substitution by executing command in
     * a subshell environment (see Shell Execution Environment) and replacing
     * the command substitution (the text of command plus the enclosing "$()"
     * or backquotes) with the standard output of the command, removing
     * sequences of one or more <newline>s at the end of the substitution.
     */
    IMPLEMENT_REQ("sh.wordexp.command.01");
    
    

    return wordexp->res;
}

/*****************************************************************************/
/**                         Arithmetic Expansion                            **/
/*****************************************************************************/
bool isUnary_ArithmeticOperator(ArithmeticOperator o)
{
    return o == IntegerValue
        || o == VariableName
        || o == ParenthesisOperator
        || o == UnaryPlusOperator
        || o == UnaryMinusOperator
        || o == BitwiseNegationOperator
        || o == NegationOperator;
}

bool isBinary_ArithmeticOperator(ArithmeticOperator o)
{
    return !(isUnary_ArithmeticOperator(o) || isTernary_ArithmeticOperator(o));
}

bool isTernary_ArithmeticOperator(ArithmeticOperator o)
{
    return o == ConditionalOperator;
}

bool isAssignment_ArithmeticOperator(ArithmeticOperator o)
{
    switch(o)
    {
    case AssignmentOperator:
    case MultiplicationAssignmentOperator:
    case DivisionAssignmentOperator:
    case RemainderAssignmentOperator:
    case AdditionAssignmentOperator:
    case SubstractionAssignmentOperator:
    case ShiftLeftAssignmentOperator:
    case ShiftRightAssignmentOperator:
    case BitwiseAndAssignmentOperator:
    case BitwiseExclusiveOrAssignmentOperator:
    case BitwiseOrAssignmentOperator:
        return true;
    }
    return false;
}

specification typedef struct ArithmeticExpression ArithmeticExpression = {};

ArithmeticExpression* create_ArithmeticExpression
(
    ArithmeticOperator o,
    ArithmeticExpression *arg0,
    ArithmeticExpression *arg1,
    ArithmeticExpression *arg2,
    LongT val,
    CString *var
)
{
    return create(&type_ArithmeticExpression, o, arg0, arg1, arg2, val, var);
}

ArithmeticExpression* create_IntegerValue(LongT val)
{
    return create_ArithmeticExpression(IntegerValue, NULL, NULL, NULL, val, NULL);
}

CString* toString_ArithmeticExpression(ArithmeticExpression *exp)
{
    assertion(exp != NULL, "toString_ArithmeticExpression: exp is NULL");

    if(isAssignment_ArithmeticOperator(exp->o))
    {
        /*
         * All changes to variables in an arithmetic expression shall be in
         * effect after the arithmetic expansion, as in the parameter expansion
         * "${x=value}".
         */
        IMPLEMENT_REQ("sh.wordexp.arithmetic.03");
    }

    switch(exp->o)
    {
    /* Integer value */
    case IntegerValue:
        return format_CString("%ld", exp->val);
    /* Shell variable */
    case VariableName:
        return format_CString("$(obj)", exp->var);
    /* () */
    case ParenthesisOperator:
        return format_CString("($(obj))",
            toString_ArithmeticExpression(exp->arg0));
    /* unary + */
    case UnaryPlusOperator:
        return format_CString("+$(obj)",
            toString_ArithmeticExpression(exp->arg0));
    /* unary - */
    case UnaryMinusOperator:
        return format_CString("-$(obj)",
            toString_ArithmeticExpression(exp->arg0));
    /* ~ */
    case BitwiseNegationOperator:
        return format_CString("~$(obj)",
            toString_ArithmeticExpression(exp->arg0));
    /* ! */
    case NegationOperator:
        return format_CString("!$(obj)",
            toString_ArithmeticExpression(exp->arg0));
    /* * */
    case MultiplicationOperator:
        return format_CString("$(obj)*$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* / */
    case DivisionOperator:
        return format_CString("$(obj)/$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* % */
    case RemainderOperator:
        return format_CString("$(obj)%$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* + */
    case AdditionOperator:
        return format_CString("$(obj)+$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* - */
    case SubstractionOperator:
        return format_CString("$(obj)-$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* << */
    case BitwiseShiftLeftOperator:
        return format_CString("$(obj)<<$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* >> */
    case BitwiseShiftRightOperator:
        return format_CString("$(obj)>>$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* > */
    case GreaterThanOperator:
        return format_CString("$(obj)>$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* >= */
    case GreaterThanOrEqualToOperator:
        return format_CString("$(obj)>=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* < */
    case LessThanOperator:
        return format_CString("$(obj)<$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* <= */
    case LessThanOrEqualToOperator:
        return format_CString("$(obj)<=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* == */
    case EqualityOperator:
        return format_CString("$(obj)==$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* != */
    case InequalityOperator:
        return format_CString("$(obj)!=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* & */
    case BitwiseAndOperator:
        return format_CString("$(obj)&$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* ^ */
    case BitwiseExclusiveOrOperator:
        return format_CString("$(obj)^$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* | */
    case BitwiseOrOperator:
        return format_CString("$(obj)|$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* && */
    case LogicalAndOperator:
        return format_CString("$(obj)&&$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* || */
    case LogicalOrOperator:
        return format_CString("$(obj)||$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* expr?expr:expr */
    case ConditionalOperator:
        return format_CString("$(obj)?$(obj):$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1),
            toString_ArithmeticExpression(exp->arg2));
    /* = */
    case AssignmentOperator:
        return format_CString("$(obj)=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* *= */
    case MultiplicationAssignmentOperator:
        return format_CString("$(obj)*=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* /= */
    case DivisionAssignmentOperator:
        return format_CString("$(obj)/=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* %= */
    case RemainderAssignmentOperator:
        return format_CString("$(obj)%=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* += */
    case AdditionAssignmentOperator:
        return format_CString("$(obj)+=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* -= */
    case SubstractionAssignmentOperator:
        return format_CString("$(obj)-=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* <<= */
    case ShiftLeftAssignmentOperator:
        return format_CString("$(obj)<<=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* >>= */
    case ShiftRightAssignmentOperator:
        return format_CString("$(obj)>>=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* &= */
    case BitwiseAndAssignmentOperator:
        return format_CString("$(obj)&=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* ^= */
    case BitwiseExclusiveOrAssignmentOperator:
        return format_CString("$(obj)^=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    /* |= */
    case BitwiseOrAssignmentOperator:
        return format_CString("$(obj)|=$(obj)",
            toString_ArithmeticExpression(exp->arg0),
            toString_ArithmeticExpression(exp->arg1));
    default:
        assertion(false, "toString_ArithmeticExpression: Unexpected arithmetic operator");
        break;
    }

    return NULL;
}

static LongT getValue_CString(CString *val)
{
    CharT *array;
    LongT factor, res;

    array = toCharArray_CString(val);

    if(array == NULL || *array == '\x00')
    {
        return 0;
    }

    factor = 10;

    if(*array == '0')
    {
        if(*++array == '\x00')
        {
            return 0;
        }

        factor = *array == 'x' || *array == 'X' ? 16 : 8;
    }

    for(res = 0; *array != '\x00'; res = factor * res + *array++);

    return res;
}

LongT getValue_ArithmeticExpression(ShellVariables *vars, ArithmeticExpression *exp)
{
    LongT res;

    assertion(exp != NULL, "getValue_ArithmeticExpression: exp is NULL");
    assertion(vars != NULL, "getValue_ArithmeticExpression: vars is NULL");

    switch(exp->o)
    {
    /* Integer value */
    case IntegerValue:
        return  exp->val;
    /* Shell variable */
    case VariableName:
        return  getValue_CString(get_ShellVariables(vars, exp->var));
    /* () */
    case ParenthesisOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0);
    /* unary + */
    case UnaryPlusOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0);
    /* unary - */
    case UnaryMinusOperator:
        return -getValue_ArithmeticExpression(vars, exp->arg0);
    /* ~ */
    case BitwiseNegationOperator:
        return ~getValue_ArithmeticExpression(vars, exp->arg0);
    /* ! */
    case NegationOperator:
        return !getValue_ArithmeticExpression(vars, exp->arg0);
    /* * */
    case MultiplicationOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) *
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* / */
    case DivisionOperator:
        // TODO: Division by zero
        return  getValue_ArithmeticExpression(vars, exp->arg0) /
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* % */
    case RemainderOperator:
        // TODO: Division by zero
        return  getValue_ArithmeticExpression(vars, exp->arg0) %
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* + */
    case AdditionOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) +
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* - */
    case SubstractionOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) -
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* << */
    case BitwiseShiftLeftOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) <<
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* >> */
    case BitwiseShiftRightOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) >>
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* > */
    case GreaterThanOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) >
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* >= */
    case GreaterThanOrEqualToOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) >=
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* < */
    case LessThanOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) <
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* <= */
    case LessThanOrEqualToOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) <=
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* == */
    case EqualityOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) ==
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* != */
    case InequalityOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) !=
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* & */
    case BitwiseAndOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) &
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* ^ */
    case BitwiseExclusiveOrOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) ^
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* | */
    case BitwiseOrOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) |
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* && */
    case LogicalAndOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) &&
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* || */
    case LogicalOrOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) ||
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* expr?expr:expr */
    case ConditionalOperator:
        return  getValue_ArithmeticExpression(vars, exp->arg0) ?
                getValue_ArithmeticExpression(vars, exp->arg1) :
                getValue_ArithmeticExpression(vars, exp->arg1);
    /* = */
    case AssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* *= */
    case MultiplicationAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) *
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* /= */
    case DivisionAssignmentOperator:
        // TODO: Division by zero
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) /
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* %= */
    case RemainderAssignmentOperator:
        // TODO: Division by zero
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) %
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* += */
    case AdditionAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) +
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* -= */
    case SubstractionAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) -
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* <<= */
    case ShiftLeftAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) <<
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* >>= */
    case ShiftRightAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) >>
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* &= */
    case BitwiseAndAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) &
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* ^= */
    case BitwiseExclusiveOrAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) ^
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    /* |= */
    case BitwiseOrAssignmentOperator:
        res  =  getValue_ArithmeticExpression(vars, exp->arg0) |
                getValue_ArithmeticExpression(vars, exp->arg1);
        set_ShellVariables(vars, exp->arg0->var, format_CString("%ld", res));
        return res;
    default:
        assertion(false, "getValue_ArithmeticExpression: Unknown arithmetic operator");
        break;
    }

    return -1;
}

specification typedef struct ArithmeticWordExp ArithmeticWordExp = {};

ArithmeticWordExp* create_ArithmeticWordExp(ArithmeticExpression* exp)
{
    return create(&type_ArithmeticWordExp, exp);
}

CString* toString_ArithmeticWordExp(ArithmeticWordExp *wordexp)
{
    CString *res;

    assertion(wordexp != NULL, "toString_ArithmeticWordExp: wordexp is NULL");

    res = concat_CString(create_CString("$(("), toString_ArithmeticExpression(wordexp->exp));
    res = concat_CString(res, create_CString("))"));

    return res;
}

CString* getValue_ArithmeticWordExp(CallContext context, ShellVariables* vars, ArithmeticWordExp *wordexp)
{
    LongT res;

    assertion(wordexp != NULL, "getValue_ArithmeticWordExp: wordexp is NULL");
    assertion(vars != NULL, "getValue_ArithmeticWordExp: vars is NULL");

    /*
     * The shell shall expand all tokens in the expression for parameter
     * expansion, command substitution, and quote removal.
     */
    IMPLEMENT_REQ("sh.wordexp.arithmetic.01");

    

    res = getValue_ArithmeticExpression(vars, wordexp->exp);
    
    return format_CString("%ld", res);
}

/*****************************************************************************/
/**                             Word Expansion                              **/
/*****************************************************************************/
specification typedef struct WordExp WordExp = {};

WordExp* create_WordExp(WordExpType type, Object *wordexp)
{
    return create(&type_WordExp, type, wordexp);
}

WordExp* create_EmptyExpansion(CString *word)
{
    return create_WordExp(EmptyExpansion, create_EmptyWordExp(word));
}

WordExp* create_TildeExpansion(TildeWordExpType type, CString *name)
{
    return create_WordExp(TildeExpansion, create_TildeWordExp(type, name));
}

WordExp* create_ParameterExpansion(ParameterWordExpType type, CString *param, CString *word)
{
    return create_WordExp(ParameterExpansion, create_ParameterWordExp(type, param, word));
}

WordExp* create_CommandSubstitution(CString *cmd, CString *res)
{
    return create_WordExp(CommandSubstitution, create_CommandWordExp(cmd, res));
}

WordExp* create_ArithmeticExpansion(ArithmeticExpression *exp)
{
    return create_WordExp(ArithmeticExpansion, create_ArithmeticWordExp(exp));
}

CString* toString_WordExp(WordExp *wordexp)
{
    assertion(wordexp != NULL, "toString_WordExp: wordexp is NULL");

    switch(wordexp->type)
    {
    case EmptyExpansion:
        return toString_EmptyWordExp(wordexp->wordexp);
    case TildeExpansion:
        return toString_TildeWordExp(wordexp->wordexp);
    /* ${expression} */
    case ParameterExpansion:
        return toString_ParameterWordExp(wordexp->wordexp);
    /* $(command) */
    case CommandSubstitution:
        return toString_CommandWordExp(wordexp->wordexp);
    /* $((expression)) */
    case ArithmeticExpansion:
        return toString_ArithmeticWordExp(wordexp->wordexp);
    default:
        assertion(false, "toString_WordExp: Unknown word expansion type");
        break;
    }

    return NULL;
}

CString* getValue_WordExp(CallContext context, ShellVariables *vars, WordExp *wordexp)
{
    assertion(wordexp != NULL, "getValue_WordExp: wordexp is NULL");

    switch(wordexp->type)
    {
    case EmptyExpansion:
        return getValue_EmptyWordExp(context, vars, wordexp->wordexp);
    case TildeExpansion:
        return getValue_TildeWordExp(context, vars, wordexp->wordexp);
    /* ${expression} */
    case ParameterExpansion:
        return getValue_ParameterWordExp(context, vars, wordexp->wordexp);
    /* $(command) */
    case CommandSubstitution:
        return getValue_CommandWordExp(context, vars, wordexp->wordexp);
    /* $((expression)) */
    case ArithmeticExpansion:
        return getValue_ArithmeticWordExp(context, vars, wordexp->wordexp);
    default:
        assertion(false, "getValue_WordExp: Unknown word expansion type");
        break;
    }

    return NULL;
}

void process_WordExp(CallContext context, ShellVariables *vars, WordExp *wordexp)
{
    CString* word;

    assertion(wordexp != NULL, "process_WordExp: wordexp is NULL");
    assertion(vars != NULL, "process_WordExp: vars is NULL");

    /* [Evaluate word expansion] */
    word = getValue_WordExp(context, vars, wordexp);

    assertion(word != NULL, "process_WordExp: getValue_WordExp() returned NULL");

    /* [Make substitution] */
    wordexp->type = EmptyExpansion;
    wordexp->wordexp = create_EmptyWordExp(word);
}

/*****************************************************************************/
/**                   Auxiliary Specification Functions                     **/
/*****************************************************************************/

/** setwordexp_spec **/
specification
void setwordexp_spec(CallContext context, WordExpTPtr pwordexp, WordExpT *wordexp)
{
    pre        { return true;}
    coverage C { return { TheOnlyBranch, "The only branch" }; }
    post       { return true; }
}
