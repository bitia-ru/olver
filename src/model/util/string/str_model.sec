/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#define NEWREQ

#include "util/string/str_model.seh"
#include "data/basis.seh"
#include "data/errno_model.seh"
#include "config/type_config.seh"
#include "config/interpretation.seh"
#include "util/string/str_config.h"
#include "memory/heap/heap_model.seh"

#pragma SEC subsystem string "util.string"

/*
   The group of functions 'util.string.str' consists of:
       __stpcpy [1]
       __strdup [1]
       index [2]
       rindex [2]
       stpcpy [1]
       stpncpy [1]
       strcat [2]
       strchr [2]
       strcmp [2]
       strcpy [2]
       strcspn [2]
       strdup [2]
       strlen [2]
       strncat [2]
       strncmp [2]
       strncpy [2]
       strndup [1]
       strnlen [1]
       strpbrk [2]
       strrchr [2]
       strspn [2]
       strstr [2]
 */


/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

      __stpcpy -- copy a string returning a pointer to its end

SYNOPSIS

    #include <string.h>

    char * __stpcpy(char * dest, const char * src);

DESCRIPTION

    __stpcpy() copies the string src (including the terminating /0 character)
    to the array dest. The strings may not overlap, and dest must be large
    enough to receive the copy.

RETURN VALUE

    __stpcpy() returns a pointer to the end of the string dest (that is,
    the address of the terminating NULL character) rather than the beginning.

    __stpcpy() has the same specification as stpcpy().

    __stpcpy() is not in the source standard; it is only in the binary
    standard.

*/

specification
StringTPtr stpcpy_spec(CallContext context, StringTPtr dest, StringTPtr src)
{
/* The stpcpy() function shall be equivalent to stpcpy(). */
/* START EQUIVALENT SPECIFICATION: stpcpy_spec */

    SizeT len;

    CString* src_pre;
    CString* src_post;
    CString* dest_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "dest is not NULL", !isNULL_VoidTPtr(dest));
        REQ("", "src is not NULL", !isNULL_VoidTPtr(src));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by dest is available in the context", isValidPointer(context, dest));
        REQ("", "Memory pointed to by src is available in the context", isValidPointer(context, src));

        /* [Get the source string] */
        src_pre = readCString_VoidTPtr(src);

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(src_pre) + 1;

        /* [Implicit precondition] */
        /*
         * the destination string dest shall be large enough to receive the copy
         */
        REQ("app.__stpcpy.stpcpy.03", "Memory pointed to by dest is enough", sizeWMemoryAvailable(dest) >= len);
        REQ("", "Memory pointed to by src is enough", sizeRMemoryAvailable(src) >= len);

        /*
         * The strings may not overlap
         */
        REQ("app.__stpcpy.stpcpy.02", "Objects are not overlapped", !areObjectsOverlapped(dest, len, src, len));

        return true;
    }

    ALIGNMENT_COVERAGE(dest)
    ALIGNMENT_COVERAGE(src)

    post
    {
        /* [Preliminary reading of almost all the data we need] */
        src_post = readCString_VoidTPtr(src);
        dest_post = readCString_VoidTPtr(dest);

        /*
         * __stpcpy() returns a pointer to the end of the string dest (that is, the address 
         * of the terminating null character) rather than the beginning.
         */
        REQ("__stpcpy.stpcpy.04", "__stpcpy.stpcpy() function shall return a pointer to the end of dest",
            equals_VoidTPtr(stpcpy_spec, add_VoidTPtr(dest, len - 1)));

        /*
         * The __stpcpy() function shall copy the string pointed to by src (including the 
         * terminating null character) to the array pointed to by dest.
         */
        REQ("__stpcpy.stpcpy.01", "dest contains the string from src", equals(dest_post, src_pre));

        /* [The object pointed to by src shall not be changed] */
        REQ("", "src shall not be changed", equals(src_post, src_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(dest), dest, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(dest), dest, len)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(src), dest, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(src), dest, len)
                  )
           );

        return true;
    }

/* END EQUIVALENT SPECIFICATION: stpcpy_spec */
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __strdup -- alias for strdup

SYNOPSIS

    char * __strdup(const char* string);

DESCRIPTION

    __strdup() has the same specification as strdup().

    __strdup() is not in the source standard; it is only in the binary
    standard.

*/

specification
StringTPtr __strdup_spec( CallContext context, StringTPtr s1, ErrorCode* errno)
{
/* The __strdup() function shall be equivalent to strdup(). */
/* START EQUIVALENT SPECIFICATION: strdup_spec */

    SizeT len;
    CString* s1_pre;

    pre
    {
        /* [Consistency with legacy memory management mode] */
        REQ("app.brk.04;app.sbrk.04", "Consistency with legacy memory management mode", isMallocAllowed(context) );

        /* [Implicit precondition] */
        REQ("",  "s1 is not NULL", !isNULL_VoidTPtr(s1) );

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));

        /* [Load the strings to the instrumental machine] */
        s1_pre = readCString_VoidTPtr(s1);

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(s1_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len);

        return true;
    }

    coverage C
    {
        if(len == 1) return { Se, "s1 is empty" };
        else return { Sne, "s1 is not empty" };
    }

    ALIGNMENT_COVERAGE(s1)

    post
    {
        CString* s1_post = readCString_VoidTPtr(s1);
        CString* s2_post = readCString_VoidTPtr(__strdup_spec);

        /*
         * A null pointer is returned if the new string cannot be created. 
         * 
         * it shall return a null pointer and set errno to indicate the error. 
         */
        ERROR_BEGIN(POSIX_STRDUP, "__strdup.strdup.04;__strdup.strdup.03.01", isNULL_VoidTPtr(__strdup_spec), *errno)
        /*
         * The __strdup() function may fail if:
         * 
         * [ENOMEM] Storage space available is insufficient. 
         */
            ERROR_MAY(POSIX_STRDUP, ENOMEM, "__strdup.strdup.04.01", TODO_ERR(ENOMEM))

        ERROR_END()

        /*
         * The __strdup() function shall return a pointer to a new string, which is a 
         * duplicate of the string pointed to by s1.
         * 
         * The __strdup() function shall return a pointer to a new string on success.
         */
        REQ("__strdup.strdup.01.01", "Input and output strings must be equal", equals(s1_pre, s2_post));

        /* [The object pointed to by s1 shall not be changed] */
        REQ("", "s1 shall not be changed", equals(s1_pre, s1_post));

        /* [Return string and output string can not overlap] */
        REQ("", "Input and output strings can not have common areas",
            !areObjectsOverlapped(s1,len,__strdup_spec,len)
          );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len)
                  )
           );

        /*
         * The returned pointer can be passed to free().
         */
        REQ("__strdup.strdup.02", "already checked by scenario", true);

        return true;
    }
/* END EQUIVALENT SPECIFICATION: strdup_spec */
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    stpcpy -- copy a string returning a pointer to its end

SYNOPSIS

    #include <string.h>

    char * stpcpy(char * restrict dest, const char * restrict src);

DESCRIPTION

    The stpcpy() function shall copy the string pointed to by src (including
    the terminating null character) to the array pointed to by dest.
    The strings may not overlap, and the destination string dest shall be
    large enough to receive the copy.

RETURN VALUE

    stpcpy() returns a pointer to the end of the string dest (that is, the
    address of the terminating null character) rather than the beginning.

*/

/* REFERENCES: __stpcpy_spec() refers the stpcpy_spec() */

specification
StringTPtr __stpcpy_spec(CallContext context, StringTPtr dest, StringTPtr src)
{
    SizeT len;

    CString* src_pre;
    CString* src_post;
    CString* dest_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "dest is not NULL", !isNULL_VoidTPtr(dest));
        REQ("", "src is not NULL", !isNULL_VoidTPtr(src));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by dest is available in the context", isValidPointer(context, dest));
        REQ("", "Memory pointed to by src is available in the context", isValidPointer(context, src));

        /* [Get the source string] */
        src_pre = readCString_VoidTPtr(src);

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(src_pre) + 1;

        /* [Implicit precondition] */
        /*
         * the destination string dest shall be large enough to receive the copy
         */
        REQ("app.stpcpy.03", "Memory pointed to by dest is enough", sizeWMemoryAvailable(dest) >= len);
        REQ("", "Memory pointed to by src is enough", sizeRMemoryAvailable(src) >= len);

        /*
         * The strings may not overlap
         */
        REQ("app.stpcpy.02", "Objects are not overlapped", !areObjectsOverlapped(dest, len, src, len));

        return true;
    }

    ALIGNMENT_COVERAGE(dest)
    ALIGNMENT_COVERAGE(src)

    post
    {
        /* [Preliminary reading of almost all the data we need] */
        src_post = readCString_VoidTPtr(src);
        dest_post = readCString_VoidTPtr(dest);

        /*
         * stpcpy() returns a pointer to the end of the string dest (that is, the address 
         * of the terminating null character) rather than the beginning.
         */
        REQ("stpcpy.04", "stpcpy() function shall return a pointer to the end of dest",
            equals_VoidTPtr(__stpcpy_spec, add_VoidTPtr(dest, len - 1)));

        /*
         * The stpcpy() function shall copy the string pointed to by src (including the 
         * terminating null character) to the array pointed to by dest.
         */
        REQ("stpcpy.01", "dest contains the string from src", equals(dest_post, src_pre));

        /* [The object pointed to by src shall not be changed] */
        REQ("", "src shall not be changed", equals(src_post, src_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(dest), dest, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(dest), dest, len)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(src), dest, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(src), dest, len)
                  )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    stpncpy -- copy a fixed-size string, returning a pointer to its end

SYNOPSIS

    #include <string.h>

    char * stpncpy(char * restrict dest, const char * restrict src, size_t n);

DESCRIPTION

    The stpncpy() function shall copy at most n characters from the string
    pointed to by src, including the terminating null character, to the array
    pointed to by dest. Exactly n characters are written at dest. If the length
    strlen()(src) is smaller than n, the remaining characters in dest are
    filled with '\0' characters. If the length strlen(src) is greater than
    or equal to n, dest will not be null terminated.

    The strings may not overlap.

    The programmer shall ensure that there is room for at least n characters at
    dest.

RETURN VALUE

    The stpncpy() function shall return a pointer to the terminating NULL in
    dest, or, if dest is not NULL-terminated, dest + n.

*/

specification
StringTPtr stpncpy_spec(CallContext context, StringTPtr dest, StringTPtr src, SizeT n)
{
    SizeT len, len_clr;

    CString* src_pre;
    CString* src_post;
    CString* dest_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "dest is not NULL", !isNULL_VoidTPtr(dest));
        REQ("", "src is not NULL", !isNULL_VoidTPtr(src));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by dest is available in the context", isValidPointer(context, dest));
        REQ("", "Memory pointed to by src is available in the context", isValidPointer(context, src));

        /* [Get the source string] */
        src_pre = readLimitedCString_VoidTPtr(src, n);

        /* [Get the number of bytes to copy considering the trailing null byte if present.] */
        len = length_CString(src_pre);
        len_clr = len;
        if (len < n) len++;

        /*
         * The programmer shall ensure that there is room for at least n characters at 
         * dest.
         */
        REQ("app.stpncpy.04", "Memory pointed to by dest is enough", sizeWMemoryAvailable(dest) >= n);
        REQ("", "Memory pointed to by src is enough", sizeRMemoryAvailable(src) >= len);

        /*
         * The strings may not overlap.
         */
        REQ("app.stpncpy.03", "Objects are not overlapped", !areObjectsOverlapped(dest, n, src, len));

        return true;
    }

    coverage C
    {
        if (n == 0)
            return {Z, "Copy zero chars"};
        else if (len_clr == 0)
            return {E, "Copy empty string"};
        else if (len_clr < n)
            return {S, "Copy non-empty string"};
        else
            return {N, "Copy n chars"};
    }

    ALIGNMENT_COVERAGE(dest)
    ALIGNMENT_COVERAGE(src)

    post
    {
        /* [Preliminary reading of almost all the data we need] */
        src_post = readLimitedCString_VoidTPtr(src, n);
        dest_post = readLimitedCString_VoidTPtr(dest, n);

        /*
         * The stpncpy() function shall copy at most n characters from the string pointed 
         * to by src, including the terminating null character, to the array pointed to by 
         * dest.
         */
        REQ("stpncpy.01", "dest contains the string with length <= n chars from src",
            equals(dest_post, src_pre));

        if (len < n)
        {
            /*
             * Exactly n characters are written at dest.
             *
             * If the length strlen()(src) is smaller than n, the remaining characters in dest 
             * are filled with '\0' characters.
             */
            REQ("stpncpy.02.01", "The rest of dest memory contains null bytes",
                isZeroArray(add_VoidTPtr(dest, len), n - len));
        }
        else
        {
            /*
             * Exactly n characters are written at dest.
             *
             * If the length strlen(src) is greater than or equal to n, dest will not be null 
             * terminated.
             */
            REQ("stpncpy.02.02", "already checked by stpncpy.01", true);
       }

        /* [The object pointed to by src shall not be changed] */
        REQ("", "src shall not be changed", equals(src_post, src_pre));

        /*
         * The stpncpy() function shall return a pointer to the terminating NULL in dest, 
         * or, if dest is not NULL-terminated, dest + n.
         */
        REQ("stpncpy.05", "shall return a valid pointer", n == 0 ? equals_VoidTPtr(stpncpy_spec, dest) :
            (len_clr >= n ? equals_VoidTPtr(stpncpy_spec, add_VoidTPtr(dest, n)) :
                equals_VoidTPtr(stpncpy_spec, add_VoidTPtr(dest, len - 1))));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(dest), dest, n),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(dest), dest, n)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(src), dest, n),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(src), dest, n)
                  )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strcat - concatenate two strings

SYNOPSIS

    #include <string.h>

    char *strcat(char *restrict s1, const char *restrict s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard.

    The strcat() function shall append a copy of the string pointed to by s2
    (including the terminating null byte) to the end of the string pointed to
    by s1. The initial byte of s2 overwrites the null byte at the end of s1. If
    copying takes place between objects that overlap, the behavior is
    undefined.

RETURN VALUE

    The strcat() function shall return s1; no return value is reserved to
    indicate an error.

ERRORS

    No errors are defined.

*/

specification
StringTPtr strcat_spec(CallContext context, StringTPtr s1, StringTPtr s2)
{
    SizeT len1, len2, len;

    CString* s2_pre;
    CString* s2_post;
    CString* s1_pre;
    CString* s1_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context, s2));

        /* [Load the strings to the instrumental machine] */
        s1_pre = readCString_VoidTPtr(s1);
        s2_pre = readCString_VoidTPtr(s2);

        /* [Get the lengths of the strings including the terminating null byte] */
        len1 = length_CString(s1_pre) + 1;
        len2 = length_CString(s2_pre) + 1;
        len = len1 + len2 - 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeWMemoryAvailable(s1) >= len);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        /*
         * If copying takes place between objects that overlap, the behavior is undefined.
         */
        REQ("app.strcat.03", "Objects are not overlapped", !areObjectsOverlapped(s1, len, s2, len2));

        return true;
    }

    coverage C
    {
        if((len1 == 1) && (len2 == 1)) return { S12, "s1 and s2 are empty" };
        else if((len1 == 1) && (len2 != 1)) return { S1, "s1 is empty" };
        else if((len1 != 1) && (len2 == 1)) return { S2, "s2 is empty" };
        else return { S, "s1 and s2 both are not empty" };
    }

    ALIGNMENT_COVERAGE(s1)
    ALIGNMENT_COVERAGE(s2)

    post
    {
        /* [Preliminary reading of almost all the data we need] */
        s1_post = readCString_VoidTPtr(s1);
        s2_post = readCString_VoidTPtr(s2);

        /*
         * The strcat() function shall append a copy of the string
         * pointed to by s2 (including the terminating null byte)
         * to the end of the string pointed to by s1.
         */
        /*
         * The initial byte of s2 overwrites the null byte at the end of s1.
         */
        REQ("strcat.01;strcat.02", "s1 contains the concatenation of the s1 and s2",
            equals(s1_post, concat_CString(s1_pre, s2_pre))
           );

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s2 shall not be changed",
            equals(s2_post, s2_pre)
           );

        /* The strcat() function shall return s1 */
        REQ("strcat.04", "strcat() function shall return s1", equals_VoidTPtr(strcat_spec, s1));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, len)
                  )
           );

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    index - character string operations (LEGACY)

SYNOPSIS

    #include <strings.h>

    char *index(const char *s, int c); [Option End]

DESCRIPTION

    The index() function shall be equivalent to strchr().

RETURN VALUE

    See strchr().

ERRORS

    See strchr().

*/

specification
StringTPtr index_spec(CallContext context, StringTPtr s, IntT c)
{

/* The index() function shall be equivalent to strchr(). */
/* START EQUIVALENT SPECIFICATION: strchr_spec */

    SizeT len;
    CString* s_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s is not NULL", !isNULL_VoidTPtr(s));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context",
            isValidPointer(context, s));

        /* [Load the string to the instrumental machine] */
        s_pre = readCString_VoidTPtr(s);

        /* [Get length of the string including the terminating null byte] */
        len = length_CString(s_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    coverage NullCharacterC
    {
        if(c == 0) return { Zero, "Search for null termination" };
        else return { NonZero, "Search for not null character" };
    }

    coverage SymbolExistanceC
    {
        if(strchr_model(s_pre, c) == -1)
            return { SymbolNotIncluded, "Symbol is not in the string" };

        return { SymbolIncluded, "Symbol is in the string" };
    }

    coverage EmptySearchedString
    {
        if(len == 1) return { SearhedStringEmpty, "Searched string is empty" };
        return { SearhedStringNotEmpty, "Searched string is not empty" };
    }

    post
    {
        CString* s_post = readCString_VoidTPtr(s);

        IntT searchResult = strchr_model(s_pre, c);

        if(searchResult == -1)
        {
            /*
             * The index() function shall locate the first occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * a null pointer if the byte was not found
             */
            REQ("index.01.03", "null pointer is returned if the byte was not found",
                isNULL_VoidTPtr(index_spec));
        }
        else
        {
            /*
             * The index() function shall locate the first occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * index() shall return a pointer to the byte
             */
            REQ("index.01.02", "index() shall return a valid result",
                searchResult == diff_VoidTPtr(index_spec, s));
        }

        /*
         * The index() function shall locate the first occurrence of c (converted to a 
         * char) in the string pointed to by s.
         * 
         * The terminating null byte is considered to be part of the string.
         */
        if(c == '\0') REQ("index.01.01", "already checked by index.01.02", true);

        /* [Nothing should be changed in s] */
        REQ("", "Nothing should be changed in s", equals(s_post, s_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals(
                    readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );

        return true;
    }

/* END EQUIVALENT SPECIFICATION: strchr_spec */
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    strchr - string scanning operation

SYNOPSIS

    #include <string.h>

    char *strchr(const char *s, int c);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard.

    The strchr() function shall locate the first occurrence of c (converted to
    a char) in the string pointed to by s. The terminating null byte is
    considered to be part of the string.

RETURN VALUE

    Upon completion, strchr() shall return a pointer to the byte, or a null pointer
    if the byte was not found.

ERRORS

    No errors are defined.

*/

/* REFERENCES: index_spec() refers the strchr_spec() */

specification
StringTPtr strchr_spec(CallContext context, StringTPtr s, IntT c)
{
    SizeT len;
    CString* s_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s is not NULL", !isNULL_VoidTPtr(s));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context",
            isValidPointer(context, s));

        /* [Load the string to the instrumental machine] */
        s_pre = readCString_VoidTPtr(s);

        /* [Get length of the string including the terminating null byte] */
        len = length_CString(s_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    coverage NullCharacterC
    {
        if(c == 0) return { Zero, "Search for null termination" };
        else return { NonZero, "Search for not null character" };
    }

    coverage SymbolExistanceC
    {
        if(strchr_model(s_pre, c) == -1)
            return { SymbolNotIncluded, "Symbol is not in the string" };

        return { SymbolIncluded, "Symbol is in the string" };
    }

    coverage EmptySearchedString
    {
        if(len == 1) return { SearhedStringEmpty, "Searched string is empty" };
        return { SearhedStringNotEmpty, "Searched string is not empty" };
    }

    post
    {
        CString* s_post = readCString_VoidTPtr(s);

        IntT searchResult = strchr_model(s_pre, c);

        if(searchResult == -1)
        {
            /*
             * The strchr() function shall locate the first occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * a null pointer if the byte was not found
             */
            REQ("strchr.01.03", "null pointer is returned if the byte was not found",
                isNULL_VoidTPtr(strchr_spec));
        }
        else
        {
            /*
             * The strchr() function shall locate the first occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * strchr() shall return a pointer to the byte
             */
            REQ("strchr.01.02", "strchr() shall return a valid result",
                searchResult == diff_VoidTPtr(strchr_spec, s));
        }

        /*
         * The strchr() function shall locate the first occurrence of c (converted to a 
         * char) in the string pointed to by s.
         * 
         * The terminating null byte is considered to be part of the string.
         */
        if(c == '\0') REQ("strchr.01.01", "already checked by strchr.01.02", true);

        /* [Nothing should be changed in s] */
        REQ("", "Nothing should be changed in s", equals(s_post, s_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals(
                    readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );

        return true;
    }
}

IntT strchr_model(CString* s, IntT c)
{
    int i;

    SizeT len = length_CString(s);

    CharT l = (CharT)c;

    if (l == 0)
    {
        return len;
    }

    for(i = 0; i < len; i++)
    {
        CharT t = charAt_CString(s, i);
        if (l == t)
        {
            return i;
        }
    }
    return -1;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    strcmp - compare two strings

SYNOPSIS

    #include <string.h>

    int strcmp(const char *s1, const char *s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the
    ISO C standard. Any conflict between the requirements described here and
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    The strcmp() function shall compare the string pointed to by s1 to the
    string pointed to by s2.

    The sign of a non-zero return value shall be determined by the sign of the
    difference between the values of the first pair of bytes (both interpreted
    as type unsigned char) that differ in the strings being compared.

RETURN VALUE

    Upon completion, strcmp() shall return an integer greater than, equal to,
    or less than 0, if the string pointed to by s1 is greater than, equal to,
    or less than the string pointed to by s2, respectively.

ERRORS

    No errors are defined.

*/

specification
IntT strcmp_spec( CallContext context, StringTPtr s1, StringTPtr s2 )
{
    SizeT len1;
    SizeT len2;

    CString* s1_pre;
    CString* s2_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("",  "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("",  "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context,s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context,s2));

        /* [Load the strings to the instrumental machine] */
        s1_pre = readCString_VoidTPtr(s1);
        s2_pre = readCString_VoidTPtr(s2);

        /* [Get lengths of the strings including the terminating null byte] */
        len1 = length_CString(s1_pre) + 1;
        len2 = length_CString(s2_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len1);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        return true;
    }

    coverage C
    {
        IntT compResult = strcmp_model(s1_pre, s2_pre);

        if (len1 == 1) return { LeftStringEmpty, "s1 is empty" };
        else if (len2 == 1) return { RightStringEmpty, "s2 is empty" };
        else if (compResult > 0) return { LeftIsGreater, "s1 > s2" };
        else if (compResult < 0) return { RightIsGreater, "s1 < s2" };
        else return { EqualStrings, "s1 == s2" };
    }

    post
    {
        CString* s1_post = readCString_VoidTPtr(s1);
        CString* s2_post = readCString_VoidTPtr(s2);

        IntT compResult = strcmp_model(s1_pre, s2_pre);

        /*
         * The strcmp() function shall compare the string pointed to by s1 to the string 
         * pointed to by s2.
         *
         * The sign of a non-zero return value shall be determined by the sign of the 
         * difference between the values of the first pair of bytes (both interpreted as 
         * type unsigned char) that differ in the strings being compared.
         *
         * strcmp() shall return an integer greater than, equal to, or less than 0, if the 
         * string pointed to by s1 is greater than, equal to, or less than the string 
         * pointed to by s2, respectively
         */
        REQ("strcmp.01.01.01", "Compare result is valid", (compResult > 0 && strcmp_spec > 0)
                                     || (compResult < 0 && strcmp_spec < 0)
                                     || (compResult == 0 && strcmp_spec == 0));

        /* [Nothing should be changed in s1] */
        REQ("", "Nothing should be changed in s1", equals(s1_post, s1_pre));

        /* [Nothing should be changed in s2] */
        REQ("", "Nothing should be changed in s2", equals(s2_post, s2_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2)
                  )
           );

        return true;
    }
}

IntT strcmp_model(CString* s1, CString* s2)
{
    int i;

    SizeT len1 = length_CString(s1);
    SizeT len2 = length_CString(s2);

    SizeT len = len2 > len1 ? len1 : len2;

    for(i = 0; i < len; i++)
    {
        UCharT c1 = (UCharT)charAt_CString(s1, i);
        UCharT c2 = (UCharT)charAt_CString(s2, i);

        if (c1 > c2)
        {
            return 1;
        }
        if (c1 < c2)
        {
            return -1;
        }
    }

    if (len1 != len2)
    {
        if (len1 > len2)
            return 1;
        else
            return -1;
    }
    else
        return 0;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strcpy - copy a string

SYNOPSIS

    #include <string.h>

    char *strcpy(char *restrict s1, const char *restrict s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the
    ISO C standard. Any conflict between the requirements described here and
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    The strcpy() function shall copy the string pointed to by s2 (including
    the terminating null byte) into the array pointed to by s1. If copying
    takes place between objects that overlap, the behavior is undefined.

RETURN VALUE

    The strcpy() function shall return s1; no return value is reserved to
    indicate an error.

ERRORS

    No errors are defined.

*/

specification
StringTPtr strcpy_spec(CallContext context, StringTPtr s1, StringTPtr s2)
{
    SizeT len;

    CString* s2_pre;
    CString* s2_post;
    CString* s1_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context, s2));

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(readCString_VoidTPtr(s2)) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeWMemoryAvailable(s1) >= len);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len);

        /*
         * If copying takes place between objects that overlap, the behavior is undefined.
         */
        REQ("app.strcpy.02", "Objects are not overlapped", !areObjectsOverlapped(s1, len, s2, len));
        return true;
    }

    coverage C
    {
        if (len == 1)
            return { S2e, "s2 is empty" };
        else
            return { S2ne, "s2 is not empty" };
    }

    ALIGNMENT_COVERAGE(s1)
    ALIGNMENT_COVERAGE(s2)

    post
    {
        /* [Preliminary reading of almost all the data we need] */
        s2_pre = @readCString_VoidTPtr(s2);
        s2_post = readCString_VoidTPtr(s2);
        s1_post = readCString_VoidTPtr(s1);

        /*
         * The strcpy() function shall copy the string pointed to by s2 (including the 
         * terminating null byte) into the array pointed to by s1.
         */
        REQ("strcpy.01", "s1 contains the string from s2", equals(s1_post, s2_pre));

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s2 shall not be changed", equals(s2_post, s2_pre));

        /*
         * The strcpy() function shall return s1
         */
        REQ("strcpy.03", "function shall return s1", equals_VoidTPtr(strcpy_spec, s1));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, len)
                  )
           );

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strcspn - get the length of a complementary substring

SYNOPSIS

    #include <string.h>

    size_t strcspn(const char *s1, const char *s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the
    ISO C standard. Any conflict between the requirements described here and
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    The strcspn() function shall compute the length (in bytes) of the maximum
    initial segment of the string pointed to by s1 which consists entirely of
    bytes not from the string pointed to by s2.

RETURN VALUE

    The strcspn() function shall return the length of the computed segment of
    the string pointed to by s1; no return value is reserved to indicate an
    error.

ERRORS

    No errors are defined.

*/

specification
SizeT strcspn_spec(CallContext context, StringTPtr s1, StringTPtr s2)
{
    SizeT len1;
    SizeT len2;

    CString* s1_pre;
    CString* s2_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1) );
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2) );

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context,s1) );
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context,s2) );

        /* [Load the strings to the instrumental machine] */
        s1_pre = readCString_VoidTPtr(s1);
        s2_pre = readCString_VoidTPtr(s2);

        /* [Get lengths of the strings including the terminating null byte] */
        len1 = length_CString(s1_pre) + 1;
        len2 = length_CString(s2_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len1);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        return true;
    }

    coverage C
    {
        if (len1 == 1 && len2 == 1)
        {
            return { EmptyStrings, "Both strings are empty" };
        }
        else if (len1 > 1 && len2 == 1)
        {
            return { PatternEmpty, "Pattern string is empty" };
        }
        else if (len1 == 1 && len2 > 1)
        {
            return { StringEmpty, "Search string is empty" };
        }
        else if (strcspn_model(s1_pre, s2_pre) == 0)
        {
            return { SegmentEmpty, "Segment is empty" };
        }
        else
        {
            return { SegmentNotEmpty, "Segment is not empty" };
        }
    }

    post
    {
        CString* s1_post = readCString_VoidTPtr(s1);
        CString* s2_post = readCString_VoidTPtr(s2);

        SizeT segmentLength = strcspn_model(s1_pre, s2_pre);

        /*
         * The strcspn() function shall compute the length (in bytes) of the maximum 
         * initial segment of the string pointed to by s1 which consists entirely of bytes 
         * not from the string pointed to by s2.
         * 
         * The strcspn() function shall return the length of the computed segment of the 
         * string pointed to by s1
         */
        REQ("strcspn.01.01", "Function shall return correct value",
            segmentLength == strcspn_spec);

        /* [Nothing should be changed in s1] */
        REQ("",  "Nothing should be changed in s1", equals(s1_post, s1_pre));

        /* [Nothing should be changed in s2] */
        REQ("",  "Nothing should be changed in s2", equals(s2_post, s2_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2)
                  )
           );

        return true;
    }
}

SizeT strcspn_model(CString* s1, CString* s2)
{
    int i;
    int j;

    SizeT len1 = length_CString(s1);    
    SizeT len2 = length_CString(s2);    

    if (len1 == 0 || len2 == 0)
    {
        return len1;
    }

    for(i = 0; i < len1; i++)
    {
        CharT c = charAt_CString(s1, i);

        for(j = 0; j < len2; j++)
        {
            CharT t = charAt_CString(s2, j);

            if (c == t)
            {
                return i;
            }
        }
    }

    return i;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strdup - duplicate a string

SYNOPSIS

    #include <string.h>

    char *strdup(const char *s1);

DESCRIPTION

    The strdup() function shall return a pointer to a new string, which is a
    duplicate of the string pointed to by s1. The returned pointer can be
    passed to free(). A null pointer is returned if the new string cannot be
    created.

RETURN VALUE

    The strdup() function shall return a pointer to a new string on success.
    Otherwise, it shall return a null pointer and set errno to indicate the
    error.

ERRORS

    The strdup() function may fail if:

    [ENOMEM]
        Storage space available is insufficient.

*/

/* REFERENCES: __strdup_spec() refers the strdup_spec() */

specification
StringTPtr strdup_spec(CallContext context, StringTPtr s1, ErrorCode* errno)
{
    SizeT len;
    CString* s1_pre;

    pre
    {
        /* [Consistency with legacy memory management mode] */
        REQ("app.brk.04;app.sbrk.04", "Consistency with legacy memory management mode", isMallocAllowed(context) );

        /* [Implicit precondition] */
        REQ("",  "s1 is not NULL", !isNULL_VoidTPtr(s1) );

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));

        /* [Load the strings to the instrumental machine] */
        s1_pre = readCString_VoidTPtr(s1);

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(s1_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len);

        return true;
    }

    coverage C
    {
        if(len == 1) return { Se, "s1 is empty" };
        else return { Sne, "s1 is not empty" };
    }

    ALIGNMENT_COVERAGE(s1)

    post
    {
        CString* s1_post = readCString_VoidTPtr(s1);
        CString* s2_post = readCString_VoidTPtr(strdup_spec);

        /*
         * A null pointer is returned if the new string cannot be created. 
         * 
         * it shall return a null pointer and set errno to indicate the error. 
         */
        ERROR_BEGIN(POSIX_STRDUP, "strdup.04;strdup.03.01", isNULL_VoidTPtr(strdup_spec), *errno)
        /*
         * The strdup() function may fail if:
         * 
         * [ENOMEM] Storage space available is insufficient. 
         */
            ERROR_MAY(POSIX_STRDUP, ENOMEM, "strdup.04.01", TODO_ERR(ENOMEM))

        ERROR_END()

        /*
         * The strdup() function shall return a pointer to a new string, which is a 
         * duplicate of the string pointed to by s1.
         * 
         * The strdup() function shall return a pointer to a new string on success.
         */
        REQ("strdup.01.01", "Input and output strings must be equal", equals(s1_pre, s2_post));

        /* [The object pointed to by s1 shall not be changed] */
        REQ("", "s1 shall not be changed", equals(s1_pre, s1_post));

        /* [Return string and output string can not overlap] */
        REQ("", "Input and output strings can not have common areas",
            !areObjectsOverlapped(s1,len,strdup_spec,len)
          );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len)
                  )
           );

        /*
         * The returned pointer can be passed to free().
         */
        REQ("strdup.02", "already checked by scenario", true);

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strlen - get string length

SYNOPSIS

    #include <string.h>

    size_t strlen(const char *s);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard.

    The strlen() function shall compute the number of bytes in the string to
    which s points, not including the terminating null byte.

RETURN VALUE

    The strlen() function shall return the length of s; no return value shall 
    be reserved to indicate an error.

ERRORS

    No errors are defined.

*/

specification
SizeT strlen_spec(CallContext context, StringTPtr s)
{
    SizeT len;
    CString* s_pre;
    pre
    {
        /* [Implicit precondition] */
        REQ("", "s is not NULL", !isNULL_VoidTPtr(s));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context",
            isValidPointer(context, s));

        /* [Load the strings to the instrumental machine] */
        s_pre = readCString_VoidTPtr(s);

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(s_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    coverage SizeC
    {
        if(len==1)      
            return { EmptyString, "Empty String" };

        if(len==2)      
            return { OneCharacterString, "One Character String" };

        return {GeneralString, "General String"};
    }

    ALIGNMENT_COVERAGE(s)

    post
    {
        CString* s_post = readCString_VoidTPtr(s);

        /* [The object pointed to by s shall not be changed] */
        REQ("", "s shall not be changed", equals(s_pre, s_post));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );

        /*
         * The strlen() function shall compute the number of bytes in the string to which 
         * s points, not including the terminating null byte.
         * 
         * The strlen() function shall return the length of s
         */
        REQ("strlen.01.01", "Return value equals the string size", strlen_spec == (len-1));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strncat - concatenate a string with part of another

SYNOPSIS

    #include <string.h>
    char *strncat(char *restrict s1, const char *restrict s2, size_t n);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard.

    The strncat() function shall append not more than n bytes (a null byte and
    bytes that follow it are not appended) from the array pointed to by s2 to
    the end of the string pointed to by s1. The initial byte of s2 overwrites
    the null byte at the end of s1. A terminating null byte is always appended
    to the result. If copying takes place between objects that overlap, the
    behavior is undefined.

RETURN VALUE

    The strncat() function shall return s1; no return value shall be reserved
    to indicate an error.

ERRORS

    No errors are defined.

*/

specification
StringTPtr strncat_spec(CallContext context, StringTPtr s1, StringTPtr s2, SizeT n)
{
    SizeT len1, len2, len, rlen;

    CString* s2_pre;
    CString* s1_pre;
    CString* s2_post;
    CString* s1_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context, s2));

        /* [Get the source and destination strings] */
        s2_pre = readLimitedCString_VoidTPtr(s2, n);
        s1_pre = readCString_VoidTPtr(s1);

        /* [Get the lengths of the strings including the terminating null byte] */
        len2 = length_CString(s2_pre) + 1;
        len1 = length_CString(s1_pre) + 1;
        len = len1 + len2 - 1;

        /* [Number of bytes to read from s2] */
        rlen = (n >= len2 ? len2 : n);

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeWMemoryAvailable(s1) >= len);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= rlen);

        /*
         * If copying takes place between objects that overlap, the behavior is undefined.
         */
        REQ("app.strncat.04", "Objects are not overlapped", !areObjectsOverlapped(s1, len, s2, rlen));

        return true;
    }

    coverage C
    {
        if (len1 == 1)
        {
            if (n == 0)
                return {EZ, "Add zero chars to empty string"};
            else if (len2 == 1)
                return {EE, "Add empty string to empty string"};
            else if (len2 < n + 1)
                return {ES, "Add non-empty string to empty string"};
            else
                return {EN, "Add n chars to empty string"};
        }
        else
        {
            if (n == 0)
                return {NZ, "Add zero chars to non-empty string"};
            else if (len2 == 1)
                return {NE, "Add empty string to non-empty string"};
            else if (len2 < n + 1)
                return {NS, "Add non-empty string to non-empty string"};
            else
                return {NN, "Add n chars to non-empty string"};
        }
    }

    ALIGNMENT_COVERAGE(s1)
    ALIGNMENT_COVERAGE(s2)

    post
    {
        s2_post = readLimitedCString_VoidTPtr(s2, n);
        s1_post = readCString_VoidTPtr(s1);

        /*
         * The strncat() function shall append not more than n bytes (a null byte and 
         * bytes that follow it are not appended) from the array pointed to by s2 to the 
         * end of the string pointed to by s1.
         */
        /*
         * The initial byte of s2 overwrites the null byte at the end of s1.
         */
        /*
         * A terminating null byte is always appended to the result.
         */
        REQ("strncat.01;strncat.02;strncat.03", "s1 contains the concatenation of the s1 and <= n chars from s2",
            equals(s1_post, concat_CString(s1_pre, s2_pre)));

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s2 shall not be changed", equals(s2_post, s2_pre));

        /*
         * The strncat() function shall return s1
         */
        REQ("strncat.05", "strncat() function shall return s1", equals_VoidTPtr(strncat_spec, s1));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, len)
                  )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strncmp - compare part of two strings

SYNOPSIS

    #include <string.h>

    int strncmp(const char *s1, const char *s2, size_t n);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the 
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The strncmp() function shall compare not more than n bytes (bytes that 
    follow a null byte are not compared) from the array pointed to by s1 to 
    the array pointed to by s2.

    The sign of a non-zero return value is determined by the sign of the 
    difference between the values of the first pair of bytes (both interpreted 
    as type unsigned char) that differ in the strings being compared.

RETURN VALUE

    Upon successful completion, strncmp() shall return an integer greater than,
    equal to, or less than 0, if the possibly null-terminated array pointed to 
    by s1 is greater than, equal to, or less than the possibly null-terminated 
    array pointed to by s2 respectively.

ERRORS

    No errors are defined.

*/

specification
IntT strncmp_spec(CallContext context, StringTPtr s1, StringTPtr s2, SizeT n)
{
    SizeT len1, len1_clr;
    SizeT len2, len2_clr;

    CString* s1_pre;
    CString* s2_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1) );
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2) );

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context,s1) );
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context,s2) );

        /* [Load the strings to the instrumental machine] */
        s1_pre = readLimitedCString_VoidTPtr(s1, n);
        s2_pre = readLimitedCString_VoidTPtr(s2, n);

        /* [Get the "clear" lengths of the strings, without the terminating null chars] */
        len1 = len1_clr = length_CString(s1_pre);
        len2 = len2_clr = length_CString(s2_pre);

        /* [Get lengths of the arrays to compare] */
        if (len1 < n)
            len1++;
        if (len2 < n)
            len2++;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len1);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        return true;
    }

    coverage ResultC
    {
        IntT compResult = strncmp_model(s1_pre, s2_pre, n);

        if (compResult > 0)
            return { LeftIsGreater, "s1 > s2"};
        else if (compResult < 0)
            return { RightIsGreater, "s1 < s2"};
        else
            return { EqualStrings, "s1 == s2"};
    }

    coverage ConfineC
    {
        if ((len1_clr == n) && (len2_clr == n))
            return {ConfineBoth, "Both strings are confined"};
        if (len1_clr == n)
            return {ConfineFirst, "First string is confined"};
        if (len2_clr == n)
            return {ConfineSecond, "Second string is confined"};
        return {NotConfine, "Strings are not confined"};
    }

    post
    {
        CString* s1_post = readLimitedCString_VoidTPtr(s1, n);
        CString* s2_post = readLimitedCString_VoidTPtr(s2, n);

        IntT compResult = strncmp_model(s1_pre, s2_pre, n);

        /*
         * The strncmp() function shall compare not more than n bytes (bytes that follow a 
         * null byte are not compared) from the array pointed to by s1 to the array 
         * pointed to by s2.
         *
         * strncmp() shall return an integer greater than, equal to, or less than 0, if 
         * the possibly null-terminated array pointed to by s1 is greater than, equal to, 
         * or less than the possibly null-terminated array pointed to by s2 respectively.
         *
         * -------
         *
         * The sign of a non-zero return value is determined by the sign of the difference 
         * between the values of the first pair of bytes (both interpreted as type 
         * unsigned char) that differ in the strings being compared.
         */
        REQ("strncmp.01.01;strncmp.02", "Compare result is valid", (compResult > 0 && strncmp_spec > 0)
                                     || (compResult < 0 && strncmp_spec < 0)
                                     || (compResult == 0 && strncmp_spec == 0));

        /* [Nothing should be changed in s1] */
        REQ("", "Nothing should be changed in s1",
            equals(s1_post, s1_pre)
           );

        /* [Nothing should be changed in s2] */
        REQ("", "Nothing should be changed in s2",
            equals(s2_post, s2_pre)
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2)
                  )
           );

        return true;
    }
}

IntT strncmp_model(CString* s1, CString* s2, SizeT n)
{
    int i;
    bool confined = false;

    SizeT len1 = length_CString(s1);
    SizeT len2 = length_CString(s2);

    SizeT len = len2 > len1 ? len1 : len2;

    if(len >= n)
    {
        confined = true;
        len = n;
    }

    for(i = 0; i < len; i++)
    {
        UCharT c1 = (UCharT)charAt_CString(s1, i);
        UCharT c2 = (UCharT)charAt_CString(s2, i);

        if (c1 > c2)
        {
            return 1;
        }
        if (c1 < c2)
        {
            return -1;
        }
    }

    if(!confined)
    {
        if (len1 != len2)
        {
            if (len1 > len2)
                return 1;
            else
                return -1;
        }
        else
            return 0;
    }
    else
        return 0;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strncpy - copy part of a string

SYNOPSIS

    #include <string.h>

    char *strncpy(char *restrict s1, const char *restrict s2, size_t n);

DESCRIPTION

    The functionality described on this reference page is aligned with the
    ISO C standard. Any conflict between the requirements described here and
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    The strncpy() function shall copy not more than n bytes (bytes that
    follow a null byte are not copied) from the array pointed to by s2 to
    the array pointed to by s1. If copying takes place between objects that
    overlap, the behavior is undefined.

    If the array pointed to by s2 is a string that is shorter than n bytes,
    null bytes shall be appended to the copy in the array pointed to by s1,
    until n bytes in all are written.

RETURN VALUE

    The strncpy() function shall return s1; no return value is reserved to
    indicate an error.

ERRORS

    No errors are defined.

*/

specification
StringTPtr strncpy_spec(CallContext context, StringTPtr s1, StringTPtr s2, SizeT n)
{
    SizeT len, len_clr;

    CString* s2_pre;
    CString* s2_post;
    CString* s1_post;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context, s2));

        /* [Get the source string] */
        s2_pre = readLimitedCString_VoidTPtr(s2, n);

        /* [Get the number of bytes to copy considering the trailing null byte if present.] */
        len = length_CString(s2_pre);
        len_clr = len;
        if (len < n) len++;


        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeWMemoryAvailable(s1) >= n);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len);

        /*
         * If copying takes place between objects that overlap, the behavior is undefined.
         */
        REQ("app.strncpy.02", "Objects are not overlapped", !areObjectsOverlapped(s1, n, s2, len));

        return true;
    }
    coverage C
    {
        if (n == 0)
            return {Z, "Copy zero chars"};
        else if (len_clr == 0)
            return {E, "Copy empty string"};
        else if (len_clr < n)
            return {S, "Copy non-empty string"};
        else
            return {N, "Copy n chars"};
    }
    ALIGNMENT_COVERAGE(s1)
    ALIGNMENT_COVERAGE(s2)
    post
    {
        /* [Preliminary reading of almost all the data we need] */
        s2_post = readLimitedCString_VoidTPtr(s2, n);
        s1_post = readLimitedCString_VoidTPtr(s1, n);

        /*
         * The strncpy() function shall copy not more than n bytes (bytes that follow a 
         * null byte are not copied) from the array pointed to by s2 to the array pointed 
         * to by s1.
         * 
         * If the array pointed to by s2 is a string that is shorter than n bytes, null 
         * bytes shall be appended to the copy in the array pointed to by s1, until n 
         * bytes in all are written.
         */
        REQ("strncpy.01.01", "s1 contains the string with length <= n chars from s2",
            equals(s1_post, s2_pre));

        if (len < n)
        {
            /*
             * Null bytes shall be appended to the copy in the array pointed to by s1,
             * until n bytes in all are written.
             */
            REQ("", "The rest of s1 memory contains null bytes",
                isZeroArray(add_VoidTPtr(s1, len), n - len)
               );
        }

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s2 shall not be changed", equals(s2_post, s2_pre));

        /*
         * The strncpy() function shall return s1
         */
        REQ("strncpy.03", "strncpy() function shall return s1", equals_VoidTPtr(strncpy_spec, s1));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, n),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, n)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, n),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s1, n)
                  )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    strndup -- return a malloc'd copy of at most the specified number of bytes 
    of a string 

SYNOPSIS

    #include <string.h>

    char * strndup(const char * string, size_t n);

DESCRIPTION

    The strndup() function shall return a malloc()'d copy of at most n bytes of
    string. The resultant string shall be terminated even if no NULL terminator
    appears before string+n.

RETIRN VALUE

    On success, strndup() shall return a pointer to a newly allocated block of 
    memory containing a copy of at most n bytes of string. Otherwise, strndup()
    shall return NULL and set errno to indicate the error.

ERRORS

    ENOMEM Insufficient memory available.

*/

specification
StringTPtr strndup_spec(CallContext context, StringTPtr s, SizeT n, ErrorCode* errno)
{
    SizeT len, len_clr;
    CString* s_pre;

    pre
    {
        /* [Consistency with legacy memory management mode] */
        REQ("app.brk.04;app.sbrk.04",  "Consistency with legacy memory management mode", isMallocAllowed(context) );

        /* [Implicit precondition] */
        REQ("",  "s is not NULL", !isNULL_VoidTPtr(s) );

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context", isValidPointer(context, s));

        /* [Load the strings to the instrumental machine] */
        s_pre = readLimitedCString_VoidTPtr(s, n);

        /* [Get the "clear" lengths of the strings, without the terminating null chars] */
        len = len_clr = length_CString(s_pre);

       /* [Get length of the array to copy] */
        if (len < n) len++;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    coverage ConfineC
    {
        if(len_clr < n)
            return { NotConfined, "String is not confined"};
        else 
            return { Confined, "String is confined"};
    }

    coverage LengthC
    {
        if(len_clr == 0)
            return { EmptyString, "Empty String" };
        if(len_clr == 1)
            return { OneCharacterString, "One Character String"};
        return { GeneralString, "GeneralString"};
    }

    ALIGNMENT_COVERAGE(s)

    post
    {
        CString* s_post = readLimitedCString_VoidTPtr(s, n);
        CString* res_post = readCString_VoidTPtr(strndup_spec);

        ERROR_BEGIN(LSB_STRNDUP, "strndup.04.01", isNULL_VoidTPtr(strndup_spec), *errno)
        /*
         * strndup() shall return NULL and set errno to indicate the error 
         * 
         * Errors
         * 
         * [ENOMEM] Insufficient memory available. 
         */
            ERROR_MAY(LSB_STRNDUP, ENOMEM, "strndup.04.01.01", TODO_ERR(ENOMEM))

        ERROR_END()

        /*
         *   The strndup() function shall return a malloc()'d copy of at most 
         *   n bytes of string. The resultant string shall be terminated even 
         *   if no NULL terminator appears before string+n.
         */
            /*
             * The strndup() function shall return a malloc()'d copy of at most n bytes of 
             * string . 
             */
            /*
             * The resultant string shall be terminated even if no NULL terminator appears 
             * before string + n . 
             */
            /*
             * strndup() shall return a pointer to a newly allocated block of memory 
             * containing a copy of at most n bytes of string 
             */
        REQ("strndup.01;strndup.02;strndup.03",  "Input and output strings must be equal",
            strncmp_model(s_pre, res_post, n) == 0
          );

        /* [Return string and output string can not overlap] */
        REQ("",  "Input and output strings can not have common areas",
            !areObjectsOverlapped(s,len,strndup_spec,length_CString(res_post)+1)
          );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    strnlen -- determine the length of a fixed-size string

SYNOPSIS

    #include <string.h>

    size_t strnlen(const char * s, size_t maxlen);

DESCRIPTION

    strnlen() returns the number of characters in the string s, not including 
    the terminating \0 character, but at most maxlen. In doing this, strnlen() 
    looks only at the first maxlen characters at s and never beyond s + maxlen.

RETURN VALUE

    strnlen() returns strlen(s), if that is less than maxlen, or maxlen if 
    there is no \0 character among the first maxlen characters pointed to by s.
*/

specification
SizeT strnlen_spec(CallContext context, StringTPtr s, SizeT n)
{
    SizeT len, len_clr;
    CString* s_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s is not NULL", !isNULL_VoidTPtr(s) );

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context", isValidPointer(context, s));

        /* [Load the string to the instrumental machine] */
        s_pre = readLimitedCString_VoidTPtr(s, n);

        /* [Get the length of the string including the terminating null byte] */
        len = length_CString(s_pre);
        len_clr = len;
        if (len < n) len++;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    ALIGNMENT_COVERAGE(s)

    coverage SizeC
    {
        if(len_clr == 0)      
            return { EmptyString, "Empty String" };
        else if (len_clr == 1)      
            return { OneCharacterString, "One Character String" };
        else
            return {GeneralString, "General String"};
    }

    coverage ConfineC
    {
        if(len_clr < n)
            return { NotConfined, "String is not confined"};
        else 
            return { Confined, "String is confined"};
    }

    post
    {
        CString* s_post = readLimitedCString_VoidTPtr(s, n);

        /* [The object pointed to by s shall not be changed] */
        REQ("", "s shall not be changed", equals(s_pre, s_post));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );

        /*
         * strnlen() returns the number of characters in the string s, not including the 
         * terminating \0 character, but at most maxlen.
         * 
         * strnlen() returns strlen(s), if that is less than maxlen, or maxlen if there is 
         * no \0 character among the first maxlen characters pointed to by s.
         */
        /*
         * strnlen() returns the number of characters in the string s, not including the 
         * terminating \0 character, but at most maxlen.
         *
         * In doing this, strnlen() looks only at the first maxlen characters at s and 
         * never beyond s + maxlen.
         */
        REQ("strnlen.01.01;strnlen.01.02", "Return value equals the string size",
            strnlen_spec == len_clr);

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strpbrk - scan a string for a byte

SYNOPSIS

    #include <string.h>

    char *strpbrk(const char *s1, const char *s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the
    ISO C standard. Any conflict between the requirements described here and
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    The strpbrk() function shall locate the first occurrence in the string
    pointed to by s1 of any byte from the string pointed to by s2.

RETURN VALUE

    Upon successful completion, strpbrk() shall return a pointer to the byte
    or a null pointer if no byte from s2 occurs in s1.

ERRORS

    No errors are defined.

*/

specification
StringTPtr strpbrk_spec(CallContext context, StringTPtr s1, StringTPtr s2)
{
    SizeT len1;
    SizeT len2;

    CString* s1_pre;
    CString* s2_pre;

    pre
    {
       /* [Implicit precondition] */
        REQ("",  "s1 is not NULL", !isNULL_VoidTPtr(s1) );
        REQ("",  "s2 is not NULL", !isNULL_VoidTPtr(s2) );

        /* [Consistency of test suite] */
        REQ("",  "Memory pointed to by s1 is available in the context", isValidPointer(context,s1) );
        REQ("",  "Memory pointed to by s2 is available in the context", isValidPointer(context,s2) );

        /* [Load the strings to the instrumental machine] */
        s1_pre = readCString_VoidTPtr(s1);
        s2_pre = readCString_VoidTPtr(s2);

        /* [Get lengths of the strings including the terminating null byte] */
        len1 = length_CString(s1_pre) + 1;
        len2 = length_CString(s2_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len1);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        return true;
    }

    coverage C
    {
        if (len1 == 1 && len2 == 1)
        {
            return { EmptyStrings, "Both strings are empty" };
        }
        else if (len1 > 1 && len2 == 1)
        {
            return { PatternEmpty, "Pattern string is empty" };
        }
        else if (len1 == 1 && len2 > 1)
        {
            return { StringEmpty, "Search string is empty" };
        }
        else if (strpbrk_model(s1_pre, s2_pre) == -1)
        {
            return { CharacterNotFound, "Character not found" };
        }
        else
        {
            return { CharacterFound, "Character found" };
        }
    }

    post
    {
        CString* s1_post = readCString_VoidTPtr(s1);
        CString* s2_post = readCString_VoidTPtr(s2);

        IntT charPosition = strpbrk_model(s1_pre, s2_pre);

        if (charPosition == -1)
        {
            /*
             * The strpbrk() function shall locate the first occurrence in the string pointed 
             * to by s1 of any byte from the string pointed to by s2.
             * 
             * a null pointer if no byte from s2 occurs in s1
             */
            REQ("strpbrk.01.02", "null pointer is returned if no byte was not found",
                isNULL_VoidTPtr(strpbrk_spec));
        }
        else
        {
            /*
             * The strpbrk() function shall locate the first occurrence in the string pointed 
             * to by s1 of any byte from the string pointed to by s2.
             * 
             * strpbrk() shall return a pointer to the byte
             */
            REQ("strpbrk.01.01", "strpbrk() shall return a pointer to a byte found",
                charPosition == diff_VoidTPtr(strpbrk_spec, s1));
        }

        /* [Nothing should be changed in s1] */
        REQ("",  "Nothing should be changed in s1", equals(s1_post, s1_pre));

        /* [Nothing should be changed in s2] */
        REQ("",  "Nothing should be changed in s2", equals(s2_post, s2_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2)
                  )
           );

        return true;
    }
}

IntT strpbrk_model(CString* s1, CString* s2)
{
    int i;
    int j;

    SizeT len1 = length_CString(s1);    
    SizeT len2 = length_CString(s2);    

    if (len1 == 0 || len2 == 0)
    {
        return -1;
    }

    for(i = 0; i < len1; i++)
    {
        CharT c = charAt_CString(s1, i);

        for(j = 0; j < len2; j++)
        {
            CharT t = charAt_CString(s2, j);

            if (c == t)
            {
                return i;
            }
        }
    }

    return -1;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strrchr - string scanning operation

SYNOPSIS

    #include <string.h>

    char *strrchr(const char *s, int c);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO 
    C standard. Any conflict between the requirements described here and the 
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The strrchr() function shall locate the last occurrence of c (converted to 
    a char) in the string pointed to by s. The terminating null byte is 
    considered to be part of the string.

RETURN VALUE

    Upon successful completion, strrchr() shall return a pointer to the byte or
    a null pointer if c does not occur in the string.

ERRORS

    No errors are defined.

*/

/* REFERENCES: rindex_spec() refers the strrchr_spec() */

specification
StringTPtr strrchr_spec(CallContext context, StringTPtr s, IntT c)
{
    SizeT len;
    CString* s_pre;
    pre
    {
        /* [Implicit precondition] */
        REQ("", "s is not NULL", !isNULL_VoidTPtr(s));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context", isValidPointer(context,s));

        /* [Load the string to the instrumental machine] */
        s_pre = readCString_VoidTPtr(s);

        /* [Get length of the string including the terminating null byte] */
        len = length_CString(s_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    coverage NullCharacterC
    {
        if (c == 0)
            return { Zero, "Search for null termination"};
        else
            return { NonZero, "Search for not null character" };
    }

    coverage SymbolExistanceC
    {
        if(strrchr_model(s_pre, c)==-1)
            return {SymbolNotIncluded, "Symbol is not in the string"};
        return {SymbolIncluded, "Symbol is in the string"};
    }

    coverage EmptySearchedString
    {
        if(len==1)
            return {SearhedStringEmpty, "Searched string is empty"};
        return {SearhedStringNotEmpty, "Searched string is not empty"};
    }

    post
    {
        IntT searchResult;
        CString* s_post = readCString_VoidTPtr(s);

        searchResult = strrchr_model(s_pre, c);

        if(searchResult == -1)
        {
            /*
             * The strrchr() function shall locate the last occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * a null pointer if c does not occur in the string
             */
            REQ("strrchr.01.02", "null pointer is returned if the byte was not found",
                isNULL_VoidTPtr(strrchr_spec));
        }
        else
        {
            /*
             * The strrchr() function shall locate the last occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * strrchr() shall return a pointer to the byte
             */
            REQ("strrchr.01.01", "strrchr() shall return a pointer to the byte",
                searchResult == diff_VoidTPtr(strrchr_spec, s));
        }

        /*
         * The terminating null byte is considered to be part of the string.
         */
        if(c == '\0') REQ("strrchr.02", "already checked by strrchr.01.01", true);

        /* [Nothing should be changed in s] */
        REQ("", "Nothing should be changed in s", equals(s_post, s_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );

        return true;
    }
}

IntT strrchr_model(CString* s, IntT c)
{
    int i;
    SizeT len;
    CharT l;

    len = length_CString(s);

    l = (CharT)c;

    if (l == 0)
    {
        return len;
    }

    for(i = len-1; i>=0; i--)
    {
        CharT t ;
        t = charAt_CString(s, i);
        if (l == t)
        {
            return i;
        }
    }
    return -1;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.


NAME

    rindex - character string operations (LEGACY)

SYNOPSIS

    #include <strings.h>

    char *rindex(const char *s, int c); 

DESCRIPTION

    The rindex() function shall be equivalent to strrchr().

RETURN VALUE

    Refer to strrchr().

ERRORS

    Refer to strrchr().
*/

specification
StringTPtr rindex_spec(CallContext context, StringTPtr s, IntT c)
{

/* The rindex() function shall be equivalent to strrchr(). */
/* START EQUIVALENT SPECIFICATION: strrchr_spec */

    SizeT len;
    CString* s_pre;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s is not NULL", !isNULL_VoidTPtr(s));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s is available in the context", isValidPointer(context,s));

        /* [Load the string to the instrumental machine] */
        s_pre = readCString_VoidTPtr(s);

        /* [Get length of the string including the terminating null byte] */
        len = length_CString(s_pre) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s is enough", sizeRMemoryAvailable(s) >= len);

        return true;
    }

    coverage NullCharacterC
    {
        if (c == 0)
            return { Zero, "Search for null termination"};
        else
            return { NonZero, "Search for not null character" };
    }

    coverage SymbolExistanceC
    {
        if(strrchr_model(s_pre, c)==-1)
            return {SymbolNotIncluded, "Symbol is not in the string"};
        return {SymbolIncluded, "Symbol is in the string"};
    }

    coverage EmptySearchedString
    {
        if(len==1)
            return {SearhedStringEmpty, "Searched string is empty"};
        return {SearhedStringNotEmpty, "Searched string is not empty"};
    }

    post
    {
        IntT searchResult;
        CString* s_post = readCString_VoidTPtr(s);

        searchResult = strrchr_model(s_pre, c);

        if (searchResult == -1)
        {
            /*
             * The rindex() function shall locate the last occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * a null pointer if c does not occur in the string
             */
            REQ("rindex.01.02", "null pointer is returned if the byte was not found",
                isNULL_VoidTPtr(rindex_spec));
        }
        else
        {
            /*
             * The rindex() function shall locate the last occurrence of c (converted to a 
             * char) in the string pointed to by s.
             * 
             * rindex() shall return a pointer to the byte
             */
            REQ("rindex.01.01", "rindex() shall return a pointer to the byte",
                searchResult == diff_VoidTPtr(rindex_spec, s));
        }

        /*
         * The terminating null byte is considered to be part of the string.
         */
        if(c == '\0') REQ("rindex.02", "already checked by rindex.01.01", true);

        /* [Nothing should be changed in s] */
        REQ("", "Nothing should be changed in s", equals(s_post, s_pre));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s), s, len)
                  )
           );

        return true;
    }

/* END EQUIVALENT SPECIFICATION: strrchr_spec */
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strspn - get length of a substring

SYNOPSIS

    #include <string.h>

    size_t strspn(const char *s1, const char *s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The strspn() function shall compute the length (in bytes) of the maximum
    initial segment of the string pointed to by s1 which consists entirely of
    bytes from the string pointed to by s2.

RETURN VALUE

    The strspn() function shall return the length of s1; no return value is
    reserved to indicate an error.

ERRORS

    No errors are defined.

*/

specification
SizeT strspn_spec(CallContext context, StringTPtr s1, StringTPtr s2)
{
    SizeT len1, len2, res;

    CString* string1Old;
    CString* string1New;
    CString* string2Old;
    CString* string2New;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context, s2));

        /* [Get the lengths of the strings including the terminating null byte] */
        string1Old = readCString_VoidTPtr(s1);
        string2Old = readCString_VoidTPtr(s2);
        len1 = length_CString(string1Old) + 1;
        len2 = length_CString(string2Old) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len1);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        res = strspn_model(string1Old, string2Old);

        return true;
    }

    coverage C
    {
        if ((len1 == 1) && (len2 == 1))
            return {S12, "s1 and s2 are empty"};
        else if ((len1 == 1) && (len2 != 1))
            return {S1, "s1 is empty"};
        else if ((len1 != 1) && (len2 == 1))
            return {S2, "s2 is empty"};
        else
        {
            if (res == 0)
                return {E, "Empty segment"};
            else
                return {N, "Non-empty segment"};
        }
    }

    ALIGNMENT_COVERAGE(s1)
    ALIGNMENT_COVERAGE(s2)

    post
    {
        /* [Preliminary reading of almost all the data we need] */
        string1New = readCString_VoidTPtr(s1);
        string2New = readCString_VoidTPtr(s2);

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s1 shall not be changed", equals(string1New, string1Old));

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s2 shall not be changed", equals(string2New, string2Old));

        /*
         * The strspn() function shall compute the length (in bytes) of the maximum 
         * initial segment of the string pointed to by s1 which consists entirely of bytes 
         * from the string pointed to by s2.
         * 
         * The strspn() function shall return the length of s1
         */
        REQ("strspn.01.01", "function shall return the length of s1", (res == strspn_spec));

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2)
                  )
           );

        return true;
    }
}

SizeT strspn_model(CString* s1, CString* s2)
{
    int i;
    int j;
    bool found;

    SizeT len1 = length_CString(s1);    
    SizeT len2 = length_CString(s2);    

    if ((len1 == 0) || (len2 == 0))
    {
        return 0;
    }

    for(i = 0; i < len1; i++)
    {
        CharT c = charAt_CString(s1, i);
        found = false;

        for(j = 0; j < len2; j++)
        {
            if (c == charAt_CString(s2, j))
            {
                found = true;
                break;
            }
        }
        if (!found)
            return i;
    }

    return i;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strstr - find a substring

SYNOPSIS

    #include <string.h>

    char *strstr(const char *s1, const char *s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The strstr() function shall locate the first occurrence in the string
    pointed to by s1 of the sequence of bytes (excluding the terminating null
    byte) in the string pointed to by s2.

RETURN VALUE

    Upon successful completion, strstr() shall return a pointer to the located
    string or a null pointer if the string is not found.

    If s2 points to a string with zero length, the function shall return s1.

ERRORS

    No errors are defined.

*/

specification
StringTPtr strstr_spec(CallContext context, StringTPtr s1, StringTPtr s2)
{
    SizeT len1, len2;

    CString* string1Old;
    CString* string1New;
    CString* string2Old;
    CString* string2New;

    pre
    {
        /* [Implicit precondition] */
        REQ("", "s1 is not NULL", !isNULL_VoidTPtr(s1));
        REQ("", "s2 is not NULL", !isNULL_VoidTPtr(s2));

        /* [Consistency of test suite] */
        REQ("", "Memory pointed to by s1 is available in the context", isValidPointer(context, s1));
        REQ("", "Memory pointed to by s2 is available in the context", isValidPointer(context, s2));

        /* [Get the lengths of the strings including the terminating null byte] */
        string1Old = readCString_VoidTPtr(s1);
        string2Old = readCString_VoidTPtr(s2);
        len1 = length_CString(string1Old) + 1;
        len2 = length_CString(string2Old) + 1;

        /* [Implicit precondition] */
        REQ("", "Memory pointed to by s1 is enough", sizeRMemoryAvailable(s1) >= len1);
        REQ("", "Memory pointed to by s2 is enough", sizeRMemoryAvailable(s2) >= len2);

        return true;
    }

    coverage C
    {
        if (len1 == 1)
        {
            if (len2 == 1)
                return {EE, "Find empty substring in empty string"};
            else if (len2 == 2)
                return {CE, "Find single char in empty string"};
            else
                return {SE, "Find some substring in empty string"};
        }
        else if (len1 == 2)
        {
            if (len2 == 1)
                return {EC, "Find empty substring in single char"};
            else if (len2 == 2)
                return {CC, "Find single char in single char"};
            else
                return {SC, "Find some substring in single char"};
        }
        else
        {
            if (len2 == 1)
                return {ES, "Find empty substring in non-empty string"};
            else if (len2 == 2)
                return {CS, "Find single char in non-empty string"};
            else
                return {SS, "Find some substring in non-empty string"};
        }
    }

    ALIGNMENT_COVERAGE(s1)
    ALIGNMENT_COVERAGE(s2)

    post
    {
        IntT res;

        /* [Preliminary reading of almost all the data we need] */
        string1New = readCString_VoidTPtr(s1);
        string2New = readCString_VoidTPtr(s2);

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s1 shall not be changed", equals(string1New, string1Old));

        /* [The object pointed to by s2 shall not be changed] */
        REQ("", "s2 shall not be changed", equals(string2New, string2Old));

        res = strstr_model(string1Old, string2Old);

        if (res == -1)
        {
            /*
             * The strstr() function shall locate the first occurrence in the string pointed 
             * to by s1 of the sequence of bytes (excluding the terminating null byte) in the 
             * string pointed to by s2.
             * 
             * a null pointer if the string is not found
             */
            REQ("strstr.01.02", "null pointer is returned if the string was not found",
                isNULL_VoidTPtr(strstr_spec));
        }
        else
        {
            /*
             * The strstr() function shall locate the first occurrence in the string pointed 
             * to by s1 of the sequence of bytes (excluding the terminating null byte) in the 
             * string pointed to by s2.
             * 
             * strstr() shall return a pointer to the located string
             */
            REQ("strstr.01.01", "strstr() shall return a pointer to the string",
                res == diff_VoidTPtr(strstr_spec, s1));
        }

        /*
         * If s2 points to a string with zero length, the function shall return s1.
         */
        if(len2 == 1) REQ("strstr.02", "already checked by strstr.01.01", true);

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s1), s1, len1)
                  )
           );

        /* [Other memory shall not be changed] */
        REQ("", "Other memory shall not be changed",
            equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2),
                   @readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(s2), s2, len2)
                  )
           );

        return true;
    }
}

IntT strstr_model(CString* s1, CString* s2)
{
    int i = 0;
    int j;
    bool found;

    SizeT len1 = length_CString(s1);
    SizeT len2 = length_CString(s2);

    /* If s2 points to a string with zero length, the function shall return s1. */
    if (len2 == 0)
        return 0;

    while (i < len1)
    {
        if (charAt_CString(s1, i) == charAt_CString(s2, 0))
        {
            /* The rest is too short, s2 cannot be there. */
            if (i + len2 > len1)
                return -1;

            found = true;
            for (j=0; j<len2; j++)
            {
                if (charAt_CString(s1, i + j) != charAt_CString(s2, j))
                {
                    found = false;
                    break;
                }
            }
            if (found)
                return i;
        }
        ++i;
    }

    return -1;
}
