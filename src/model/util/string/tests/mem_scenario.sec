/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "util/string/tests/mem_scenario.seh"
#include "util/string/mem_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"


/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

#define MAX_SIZE 32800
static int maxSize = MAX_SIZE;

static int sizes[] = {
  0, 1, 5, 32767, 32768, 32769
};

static int numSizes = sizeof(sizes)/sizeof(int);

static int offsets[] = {
  0, 17, 500, 32769
};
static int numOffsets = sizeof(offsets)/sizeof(int);

// memccpy searched chars
static int memccpyChars[] = {
    0, 200};

static int numMemccpyChars = sizeof(memccpyChars)/sizeof(int);


// memchr
static int memchrSizes[] = {
  0, 1, 5, 100, 200, 600, 32767, 32768, 32769
};

static int numMemchrSizes = sizeof(memchrSizes)/sizeof(int);


static int memchrOffsets[] = {
  0, 100, 200, 300, 32769
};

static int numMemchrOffsets = sizeof(memchrOffsets)/sizeof(int);

static int memchrChars[] = {
    0, 100, 200, 300, 400 };

static int numMemchrChars = sizeof(memchrChars)/sizeof(int);

// memmem
static int needleSizes[] = {
    1, 10, 32769
};

static int numNeedleSizes = sizeof(needleSizes)/sizeof(int);

// memset
static int memsetChars[] = {
    0, 100, 200, 300, 400 };

static int numMemsetChars = sizeof(memsetChars)/sizeof(int);


// swab
static int swabSizes[] = {
  0, 1, -5, 7, 64, 32768, 32769
};

static int numSwabSizes = sizeof(swabSizes)/sizeof(int);



// rawmemchr

static int rawmemchrChars[] = {
    0, 20, 50, 100, 150, 200, 250, 300, 350, 400 };

static int numRawMemchrChars = sizeof(rawmemchrChars)/sizeof(int);

static int rawOffsets[] = {
  0, 17, 21, 68, 500, 32768, 32769, MAX_SIZE*2-256
};
static int numRawOffsets = sizeof(rawOffsets)/sizeof(int);


/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context;
static VoidTPtr src,dst, dblspace;

static VoidTPtr buf1Ptr, buf2Ptr;

static VoidTPtr zeroBuf;

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/
static bool init_mem_scenario(int argc,char** argv)
{
    int i;

    // Init test scenario data
    context = getContext();

    src = allocateMemoryBlock(context,maxSize);
    if (isNULL_VoidTPtr(src))
        return false;

    dst = allocateMemoryBlock(context,maxSize);
    if (isNULL_VoidTPtr(dst))
    {
        deallocateMemoryBlock(context,src);
        return false;
    }

    dblspace = allocateMemoryBlock(context,maxSize*2);
    if (isNULL_VoidTPtr(dblspace))
    {
        deallocateMemoryBlock(context,src);
        deallocateMemoryBlock(context,dst);
        return false;
    }

    {
        UCharT refBuff[MAX_SIZE*2];

        for(i=0;i<2*maxSize;i++)
        {
            refBuff[i] = (CharT)i;
        }

        buf1Ptr = allocateMemoryBlock(context,maxSize*2);
        if (isNULL_VoidTPtr(buf1Ptr))
        {
            deallocateMemoryBlock(context,src);
            deallocateMemoryBlock(context,dst);
            deallocateMemoryBlock(context,dblspace);
            return false;
        }

        buf2Ptr = allocateMemoryBlock(context,maxSize*2);
        if (isNULL_VoidTPtr(buf2Ptr))
        {
            deallocateMemoryBlock(context,src);
            deallocateMemoryBlock(context,dst);
            deallocateMemoryBlock(context,dblspace);
            deallocateMemoryBlock(context,buf1Ptr);
            return false;
        }

        zeroBuf = allocateMemoryBlock(context,maxSize*2);
        if (isNULL_VoidTPtr(zeroBuf))
        {
            deallocateMemoryBlock(context,src);
            deallocateMemoryBlock(context,dst);
            deallocateMemoryBlock(context,dblspace);
            deallocateMemoryBlock(context,buf1Ptr);
            deallocateMemoryBlock(context,buf2Ptr);
            return false;
        }

        writeCByteArray_VoidTPtr(buf1Ptr, create_CByteArray(refBuff,
            sizeof(refBuff)/sizeof(UCharT)) );
        writeCByteArray_VoidTPtr(buf2Ptr, create_CByteArray(refBuff,
            sizeof(refBuff)/sizeof(UCharT)) );
        writeCByteArray_VoidTPtr(zeroBuf, create_CByteArray(refBuff,
            sizeof(refBuff)/sizeof(UCharT)) );
        writeCByteArray_VoidTPtr(dblspace, create_CByteArray(refBuff,
            sizeof(refBuff)/sizeof(UCharT)) );
    }

    return true;
}

static void finish_mem_scenario(void)
{
    deallocateMemoryBlock(context,src);
    deallocateMemoryBlock(context,dst);
    deallocateMemoryBlock(context,dblspace);
    deallocateMemoryBlock(context,buf1Ptr);
    deallocateMemoryBlock(context,buf2Ptr);
    deallocateMemoryBlock(context,zeroBuf);
}


/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/


/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario
bool __mempcpy_scen()
{
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < sizeof_Type(context,"int");
                                offset1++; )
        {
            iterate( unsigned offset2 = 0;
                    offset2 < sizeof_Type(context,"int"); offset2++; )
            {
                __mempcpy_spec( context, add_VoidTPtr(dst,offset1),
                        add_VoidTPtr(src,offset2), sizes[size] );
            }
        }
    }
    return true;
}

scenario
bool __rawmemchr_scen(){

    iterate (int cInd=0; cInd<numRawMemchrChars; cInd++;)
    {
        iterate ( unsigned offset1 = 0; offset1 < numRawOffsets; offset1++; )
        {
            __rawmemchr_spec(context,
                add_VoidTPtr(   buf1Ptr,rawOffsets[offset1]),
                rawmemchrChars[cInd]);
        }
    }
    return true;

}

scenario
bool bcmp_diff_scen(){

    /* [Different buffers] */
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            iterate( unsigned offset2 = 0; offset2 < numOffsets; offset2++; )
            {
                bcmp_spec( context, add_VoidTPtr(buf1Ptr,offsets[offset1]),
                    add_VoidTPtr(buf2Ptr,offsets[offset2]), sizes[size] );
            }
        }
    }

    return true;
}


scenario
bool bcmp_same_scen()
{
    /* [Same buffer] */
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            bcmp_spec( context, add_VoidTPtr(buf1Ptr,offsets[offset1]),
                add_VoidTPtr(buf1Ptr,offsets[offset1]), sizes[size] );
        }
    }

    return true;
}





scenario
bool bcopy_scen()
{
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            iterate( unsigned offset2 = 0; offset2 < numOffsets; offset2++; )
            {
                bcopy_spec( context, add_VoidTPtr(dblspace,offsets[offset1]),
                    add_VoidTPtr(dblspace,offsets[offset2]), sizes[size] );
            }
        }
    }

    return true;
}


scenario
bool bzero_scen()
{
    iterate (int counter = 0; counter < 2; counter++; )
    {
        iterate( int size = 0; size < numSizes; size++; )
        {
            iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
            {
                    bzero_spec( context,
                        add_VoidTPtr(zeroBuf,offsets[offset1]), sizes[size] );
            }
        }
    }

    return true;
}


scenario
bool memccpy_scen()
{
    iterate (int cInd=0; cInd<numMemccpyChars; cInd++;)
    {
        iterate( int size = 0; size < numSizes; size++; )
        {
            iterate ( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
            {
                iterate ( unsigned offset2 = 0;
                            offset2 < numOffsets; offset2++; )
                {
                    memccpy_spec(context,
                        add_VoidTPtr(dblspace,offsets[offset1]),
                        add_VoidTPtr(buf2Ptr,offsets[offset2]),
                        memccpyChars[cInd], sizes[size]);
                }
            }
        }
    }

    return true;
}


scenario
bool memchr_scen()
{
    iterate (int cInd=0; cInd<numMemchrChars; cInd++;)
    {
        iterate( int size = 0; size < numMemchrSizes; size++; )
        {
            iterate ( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
            {
                memchr_spec(context, add_VoidTPtr(buf1Ptr,offsets[offset1]),
                    memchrChars[cInd], memchrSizes[size]);
            }
        }
    }

    return true;
}


scenario
bool memcmp_diff_scen()
{
    /* [Different buffers] */
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            iterate( unsigned offset2 = 0; offset2 < numOffsets; offset2++; )
            {
                memcmp_spec( context, add_VoidTPtr(buf1Ptr,offsets[offset1]),
                    add_VoidTPtr(buf2Ptr,offsets[offset2]), sizes[size] );
            }
        }
    }

    return true;
}


scenario
bool memcmp_same_scen()
{
    /* [Same buffer] */
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            iterate( unsigned offset2 = 0; offset2 < numOffsets; offset2++; )
            {
                memcmp_spec( context, add_VoidTPtr(buf1Ptr,offsets[offset1]),
                    add_VoidTPtr(buf1Ptr,offsets[offset2]), sizes[size] );
            }
        }
    }

    return true;
}

scenario
bool memcpy_scen()
{
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < sizeof_Type(context,"int");
                    offset1++; )
        {
            iterate( unsigned offset2 = 0;
                    offset2 < sizeof_Type(context,"int"); offset2++; )
            {
                memcpy_spec( context, add_VoidTPtr(dst,offset1),
                            add_VoidTPtr(src,offset2), sizes[size] );
            }
        }
    }

    return true;
}

scenario
bool memmem_diff_scen()
{
    iterate( int size = 1; size < numSizes; size++; )
    {
        iterate(int needleSize = 0; needleSize < numNeedleSizes; needleSize++;)
        {
            iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
            {
                iterate(unsigned offset2 = 0; offset2 < numOffsets; offset2++;)
                {
                    memmem_spec( context,
                        add_VoidTPtr(buf1Ptr,offsets[offset1]), sizes[size],
                        add_VoidTPtr(buf2Ptr,offsets[offset2]),
                        needleSizes[needleSize] );
                }
            }
        }
    }

    return true;
}

scenario
bool memmem_same_scen()
{
    iterate( int size = 1; size < numSizes/2; size++; )
    {
        iterate(int needleSize = 0; needleSize < numNeedleSizes; needleSize++;)
        {
            iterate( unsigned offset1 = 0; offset1 < numOffsets/2; offset1++; )
            {
                iterate( unsigned offset2 = 0; offset2 < numOffsets/2;
                            offset2++; )
                {
                    memmem_spec( context,
                        add_VoidTPtr(buf1Ptr,offsets[offset1]), sizes[size],
                        add_VoidTPtr(buf1Ptr,offsets[offset2]),
                        needleSizes[needleSize] );
                }
            }
        }
    }

    return true;
}

scenario
bool memmove_scen()
{
    iterate( int size = 0; size < numSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            iterate( unsigned offset2 = 0; offset2 < numOffsets; offset2++; )
            {
                memmove_spec( context, add_VoidTPtr(dblspace,offsets[offset1]),
                    add_VoidTPtr(dblspace,offsets[offset2]), sizes[size] );
            }
        }
    }

    return true;
}


scenario
bool memrchr_scen()
{
    iterate (int cInd=0; cInd<numMemchrChars; cInd++;)
    {
        iterate( int size = 0; size < numSizes; size++; )
        {
            iterate ( unsigned offset1 = 0; offset1 < numMemchrOffsets;
                offset1++; )
            {
                memrchr_spec(context,
                    add_VoidTPtr(buf1Ptr,memchrOffsets[offset1]),
                    memchrChars[cInd], sizes[size]);
            }
        }
    }

    return true;
}


scenario
bool memset_scen()
{
    iterate (int cInd=0; cInd<numMemsetChars; cInd++;)
    {
        iterate( int size = 0; size < numSizes; size++; )
        {
            iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
            {
                memset_spec( context, add_VoidTPtr(zeroBuf,offsets[offset1]),
                    memsetChars[cInd], sizes[size] );
            }
        }
   }
    return true;
}


scenario
bool swab_scen(){

    iterate( int size = 0; size < numSwabSizes; size++; )
    {
        iterate( unsigned offset1 = 0; offset1 < numOffsets; offset1++; )
        {
            iterate( unsigned offset2 = 0; offset2 < numOffsets; offset2++; )
            {
                swab_spec( context, add_VoidTPtr(buf1Ptr, offsets[offset1]),
                    add_VoidTPtr(dblspace, offsets[offset2]), swabSizes[size]);
            }
        }
    }

    return true;
}


/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm util_string_mem_scenario =
{
    .init = init_mem_scenario,
        .finish = finish_mem_scenario,
        .actions = {
        __mempcpy_scen,
        __rawmemchr_scen,
        bcmp_same_scen,
        bcmp_diff_scen,
        bcopy_scen,
        bzero_scen,
        memccpy_scen,
        memchr_scen,
        memcmp_same_scen,
        memcmp_diff_scen,
        memcpy_scen,
        memmove_scen,
        memrchr_scen,
        memmem_same_scen,
        memmem_diff_scen,
        memset_scen,
        swab_scen,
        NULL
    }
};

bool main_util_string_mem( int argc, char** argv )
{
    util_string_mem_scenario(argc,argv);
    return true;
}

#ifdef UTIL_STRING_MEM_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "util/string/mem_media.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    //initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initUtilStringMemSubsystem();
}

int main(int argc, char** argv)
{
    //
    initTestSystem();
    loadSUT();

    // Set up tracer
    //setTraceEncoding("windows-1251");
    addTraceToFile("trace.xml");

    // Run test scenario
    main_util_string_mem(argc,argv);

    //  unloadSUT();
    return 0;
}
#endif
