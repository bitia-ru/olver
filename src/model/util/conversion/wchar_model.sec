/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "config/interpretation.seh"
#include "util/conversion/wchar_config.h"
#include "util/conversion/wchar_model.seh"
#include "data/errno_model.seh"


#pragma SEC subsystem conversion "util.conversion"



/*
   The group of functions 'util.conversion.wchar' consists of:
       btowc [2]
       mblen [2]
       mbrlen [2]
       mbrtowc [2]
       mbsinit [2]
       mbsnrtowcs [1]
       mbsrtowcs [2]
       mbstowcs [2]
       mbtowc [2]
       wcrtomb [2]
       wcsnrtombs [1]
       wcsrtombs [2]
       wcstombs [2]
       wctob [2]
       wctomb [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    btowc - single byte to wide character conversion

SYNOPSIS

    #include <stdio.h>

    #include <wchar.h>

    wint_t btowc(int c);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The btowc() function shall determine whether c constitutes a valid (one-byte)
character in the initial shift state.

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

The btowc() function shall return WEOF if c has the value EOF or if (unsigned
char) c does not constitute a valid (one-byte) character in the initial shift
state. Otherwise, it shall return the wide-character representation of that
character.

ERRORS

    No errors are defined.
*/

specification
WIntT btowc_spec( CallContext context, IntT c)
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * The btowc() function shall determine whether c constitutes a
         * valid (one-byte) character in the initial shift state.
         */
        REQ("btowc.01", "", TODO_REQ());

        /*
         * The behavior of this function shall be affected by the
         * LC_CTYPE category of the  current locale.
         */
        REQ("btowc.02", "", TODO_REQ());

        /*
         * The btowc() function shall return WEOF if c has the value EOF
         */
        REQ("btowc.03", "", TODO_REQ());

        /*
         * or if (unsigned char) c does not constitute a valid
         * (one-byte) character in the initial shift state.
         */
        REQ("btowc.04", "", TODO_REQ());

        /*
         * Otherwise, it shall return the wide-character representation
         * of that character.
         */
        REQ("btowc.05", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mblen - get number of bytes in a character

SYNOPSIS

    #include <stdlib.h>

    int mblen(const char *s, size_t n);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

If s is not a null pointer, mblen() shall determine the number of bytes
constituting the character pointed to by s. Except that the shift state
of mbtowc() is not affected, it shall be equivalent to:

mbtowc((wchar_t *)0, s, n);

The implementation shall behave as if no function defined in this volume of
IEEE Std 1003.1-2001 calls mblen().

The behavior of this function is affected by the LC_CTYPE category of the
current locale. For a state-dependent encoding, this function shall be placed
into its initial state by a call for which its character pointer argument, s,
is a null pointer. Subsequent calls with s as other than a null pointer shall
cause the internal state of the function to be altered as necessary. A call
with s as a null pointer shall cause this function to return a non-zero value
if encodings have state dependency, and 0 otherwise. If the implementation
employs special bytes to change the shift state, these bytes shall not produce
separate wide-character codes, but shall be grouped with an adjacent character.
Changing the LC_CTYPE category causes the shift state of this function to be
unspecified.

RETURN VALUE

If s is a null pointer, mblen() shall return a non-zero or 0 value, if
character encodings, respectively, do or do not have state-dependent encodings.
If s is not a null pointer, mblen() shall either return 0 (if s points to the
null byte), or return the number of bytes that constitute the character (if
the next n or fewer bytes form a valid character), or return -1 (if they do
not form a valid character) [CX]  and may set errno to indicate the error.
In no case shall the value returned be greater than n or the value of the {
MB_CUR_MAX} macro.

ERRORS

    The mblen() function may fail if:

    [EILSEQ]

        [XSI] Invalid character sequence is detected.
*/
specification
IntT mblen_spec( CallContext context, StringTPtr s, IntT n, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(POSIX_MBLEN, "mblen.14", *errno!=SUT_EOK,  *errno )
        /*
         * The mblen() function may fail if:
         *
         * [EILSEQ]
         *
         * [XSI] Invalid character sequence is detected.
         */
            ERROR_MAY(POSIX_MBLEN, EILSEQ, "mblen.14.01", TODO_ERR(EILSEQ))

        ERROR_END()
        /*
         * If s is not a null pointer, mblen() shall determine the
         * number of bytes constituting the character pointed to by s.
         */
        REQ("mblen.01", "", TODO_REQ());

        /*
         * Except that the shift state of mbtowc() is not affected,
         * it shall be equivalent to:
         *
         * mbtowc((wchar_t *)0, s, n);
         */
        REQ("mblen.02.child", "", TODO_REQ());

        /*
         * The implementation shall behave as if no function defined in
         * this volume of IEEE Std 1003.1-2001 calls mblen().
         */
        REQ("mblen.03", "", TODO_REQ());

        /*
         * The behavior of this function is affected by the LC_CTYPE
         * category of the current locale.
         */
        REQ("mblen.04", "", TODO_REQ());

        /*
         * For a state-dependent encoding, this function shall be placed
         * into its initial state by a call for which its character
         * pointer argument, s, is a null pointer.
         *
         */
        REQ("mblen.05", "", TODO_REQ());

        /*
         * Subsequent calls with s as other than a null pointer shall
         * cause the internal state of the function
         * to be altered as necessary.
         */
        REQ("mblen.06", "", TODO_REQ());

        /*
         * A call with s as a null pointer shall cause this function
         * to return a non-zero value if encodings have
         * state dependency, and 0 otherwise.
         */
        REQ("mblen.07", "", TODO_REQ());

        /*
         * If the implementation employs special bytes to change the
         * shift state, these bytes shall not produce separate
         * wide-character codes, but shall be grouped with
         * an adjacent character.
         */
        REQ("mblen.08", "", TODO_REQ());

        /*
         * Changing the LC_CTYPE category causes the shift state
         * of this function to be unspecified.
         */
        REQ("mblen.09", "", TODO_REQ());

        /*
         * If s is a null pointer, mblen() shall return a non-zero
         * or 0 value, if character encodings, respectively,
         * do or do not have state-dependent encodings.
         */
        REQ("mblen.10", "", TODO_REQ());

        /*
         * If s is not a null pointer, mblen() shall either return 0
         * (if s points to the null byte),
         */
        REQ("mblen.11", "", TODO_REQ());

        /*
         * or return the number of bytes that constitute the character
         * (if the next n or fewer bytes form a valid character),
         */
        REQ("mblen.12", "", TODO_REQ());

        /*
         * In no case shall the value returned be greater than n or
         * the value of the { MB_CUR_MAX} macro.
         */
        REQ("mblen.13", "", TODO_REQ());

        /*
         * or return -1 (if they do not form a valid character)
         * [CX]  and may set errno to indicate the error.
         */
        REQ("mblen.15", "", TODO_REQ());
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mbrlen - get number of bytes in a character (restartable)

SYNOPSIS

    #include <wchar.h>

    size_t mbrlen(const char *restrict s, size_t n,

        mbstate_t *restrict ps);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

If s is not a null pointer, mbrlen() shall determine the number of bytes
constituting the character pointed to by s. It shall be equivalent to:

mbstate_t internal; mbrtowc(NULL, s, n, ps != NULL ? ps : &internal);

If ps is a null pointer, the mbrlen() function shall use its own internal
mbstate_t object, which is initialized at program start-up to the initial
conversion state. Otherwise, the mbstate_t object pointed to by ps shall be
used to completely describe the current conversion state of the associated
character sequence. The implementation shall behave as if no function defined
in this volume of IEEE Std 1003.1-2001 calls mbrlen().

The behavior of this function is affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

The mbrlen() function shall return the first of the following that applies:

    0

    If the next n or fewer bytes complete the character that corresponds to the
    null wide character.


    positive

    If the next n or fewer bytes complete a valid character; the value returned
    shall be the number of bytes that complete the character.


    (size_t)-2

    If the next n bytes contribute to an incomplete but potentially valid
    character, and all n bytes have been processed. When n has at least the
    value of the { MB_CUR_MAX} macro, this case can only occur if s points at a
    sequence of redundant shift sequences (for implementations with
    state-dependent encodings).

    (size_t)-1

    If an encoding error occurs, in which case the next n or fewer bytes do not
    contribute to a complete and valid character. In this case, [EILSEQ] shall
    be stored in errno and the conversion state is undefined.

ERRORS

    The mbrlen() function may fail if:

    [EINVAL]

        ps points to an object that contains an invalid conversion state.

    [EILSEQ]

        Invalid character sequence is detected.
*/

specification
IntT mbrlen_spec( CallContext context, StringTPtr s, IntT n, Mbstate* ps,
                 ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(POSIX_MBRLEN, "mbrlen.07.01", *errno!=SUT_EOK, *errno)
        /*
         * The mbrlen() function may fail if:
         *
         * [EINVAL]
         *
         * ps points to an object that contains an invalid conversion state.
         */
            ERROR_MAY(POSIX_MBRLEN, EINVAL, "mbrlen.07.01", TODO_ERR(EINVAL))

        /*
         * The mbrlen() function may fail if:
         *
         * [EILSEQ]
         *
         * Invalid character sequence is detected.
         */
            ERROR_MAY(POSIX_MBRLEN, EILSEQ, "mbrlen.07.02", TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * If s is not a null pointer, mbrlen() shall determine the number
         * of bytes constituting the character pointed to by s. It shall
         * be equivalent to:
         *
         * mbstate_t internal;
         * mbrtowc(NULL, s, n, ps != NULL ? ps : &internal);
         */
        REQ("mbrlen.01", "", TODO_REQ());

        /*
         * If ps is a null pointer, the mbrlen() function shall use
         * its own internal mbstate_t object, which is initialized
         * at program start-up to the initial conversion state.
         */
        REQ("mbrlen.02", "", TODO_REQ());

        /*
         * Otherwise, the mbstate_t object pointed to by ps shall
         * be used to completely describe the current conversion
         * state of the associated character sequence
         */
        REQ("mbrlen.03", "", TODO_REQ());

        /*
         * The implementation shall behave as if no function
         * defined in this volume of IEEE Std 1003.1-2001 calls mbrlen().
         */
        REQ("mbrlen.04", "", TODO_REQ());

        /*
         * The behavior of this function is affected by the LC_CTYPE
         * category of the current locale.
         */
        REQ("mbrlen.05", "", TODO_REQ());

        /*
         * The mbrlen() function shall return the first of the following
         * that applies:
         *
         * 0
         *
         * If the next n or fewer bytes complete the character that
         * corresponds to the null wide character.
         */
        REQ("mbrlen.06.01", "", TODO_REQ());

        /*
         * The mbrlen() function shall return the first of the following
         * that applies:
         *
         * positive
         *
         * If the next n or fewer bytes complete a valid character;
         * the value returned shall be the number of bytes
         * that complete the character.
         */
        REQ("mbrlen.06.02", "", TODO_REQ());

        /*
         * The mbrlen() function shall return the first of the following
         * that applies:
         *
         * (size_t)-2
         *
         * If the next n bytes contribute to an incomplete but potentially
         * valid character, and all n bytes have been processed. When n
         * has at least the value of the {MB_CUR_MAX} macro, this case can
         * only occur if s points at a sequence of redundant shift
         * sequences (for implementations with state-dependent encodings).
         */
        REQ("mbrlen.06.03", "", TODO_REQ());

        /*
         * The mbrlen() function shall return the first of the following
         * that applies:
         *
         * (size_t)-1
         *
         * If an encoding error occurs, in which case the next n
         * or fewer bytes do not contribute to a complete and valid
         * character. In this case, [EILSEQ] shall be stored in
         * errno and the conversion state is undefined.
         */
        REQ("mbrlen.06.04", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mbrtowc - convert a character to a wide-character code (restartable)

SYNOPSIS

    #include <wchar.h>

    size_t mbrtowc(wchar_t *restrict pwc, const char *restrict s,

        size_t n, mbstate_t *restrict ps);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

If s is a null pointer, the mbrtowc() function shall be equivalent to the call:

mbrtowc(NULL, "", 1, ps)

In this case, the values of the arguments pwc and n are ignored.

If s is not a null pointer, the mbrtowc() function shall inspect at most n
bytes beginning at the byte pointed to by s to determine the number of bytes
needed to complete the next character (including any shift sequences). If the
function determines that the next character is completed, it shall determine
the value of the corresponding wide character and then, if pwc is not a null
pointer, shall store that value in the object pointed to by pwc. If the
corresponding wide character is the null wide character, the resulting state
described shall be the initial conversion state.

If ps is a null pointer, the mbrtowc() function shall use its own internal
mbstate_t object, which shall be initialized at program start-up to the
initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the
associated character sequence. The implementation shall behave as if no
function defined in this volume of IEEE Std 1003.1-2001 calls mbrtowc().

The behavior of this function is affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

The mbrtowc() function shall return the first of the following that applies:

    0

    If the next n or fewer bytes complete the character that corresponds to the
    null wide character (which is the value stored).


    between 1 and n inclusive

    If the next n or fewer bytes complete a valid character (which is the value
    stored); the value returned shall be the number of bytes that complete the
    character.


    (size_t)-2

    If the next n bytes contribute to an incomplete but potentially valid
    character, and all n bytes have been processed (no value is stored). When n
    has at least the value of the {MB_CUR_MAX} macro, this case can only occur
    if s points at a sequence of redundant shift sequences (for implementations
    with state-dependent encodings).


    (size_t)-1

    If an encoding error occurs, in which case the next n or fewer bytes do not
    contribute to a complete and valid character (no value is stored). In this
    case, [EILSEQ] shall be stored in errno and the conversion state is
    undefined.

ERRORS

    The mbrtowc() function may fail if:

    [EINVAL]

        [CX] ps points to an object that contains an invalid conversion state.

    [EILSEQ]

        Invalid character sequence is detected.
*/

specification
IntT mbrtowc_spec( CallContext context, WStringTPtr* pwc, StringTPtr s, IntT n,
                    Mbstate* ps, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(POSIX_MBRTOWC, "mbrtowc.11.01", *errno!=SUT_EOK, *errno)
        /*
         * The mbrtowc() function may fail if:
         *
         * [EINVAL]
         *
         * [CX] ps points to an object that contains an invalid
         * conversion state.
         */
            ERROR_MAY(POSIX_MBRTOWC, EINVAL, "mbrtowc.11.01", TODO_ERR(EINVAL))

        /*
         * The mbrtowc() function may fail if:
         *
         * [EILSEQ]
         *
         * Invalid character sequence is detected.
         */
            ERROR_MAY(POSIX_MBRTOWC, EILSEQ, "mbrtowc.11.02", TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * If s is a null pointer, the mbrtowc() function shall be
         * equivalent to the call:
         *
         * mbrtowc(NULL, "", 1, ps)
         *
         * In this case, the values of the arguments pwc and n are ignored.
         */
        REQ("mbrtowc.01", "", TODO_REQ());

        /*
         * If s is not a null pointer, the mbrtowc() function shall
         * inspect at most n bytes beginning at the byte pointed to
         * by s to determine the number of bytes needed to complete
         * the next character (including any shift sequences).
         */
        REQ("mbrtowc.02", "", TODO_REQ());

        /*
         * If the function determines that the next character is
         * completed, it shall determine the value of the
         * corresponding wide character
         */
        REQ("mbrtowc.03", "", TODO_REQ());

        /*
         * and then, if pwc is not a null pointer, shall store that
         * value in the object pointed to by pwc.
         */
        REQ("mbrtowc.04", "", TODO_REQ());

        /*
         * If the corresponding wide character is the null wide
         * character, the resulting state described shall be the
         * initial conversion state.
         */
        REQ("mbrtowc.05", "", TODO_REQ());

        /*
         * If ps is a null pointer, the mbrtowc() function shall
         * use its own internal mbstate_t object, which shall be
         * initialized at program start-up to the initial
         * conversion state.
         */
        REQ("mbrtowc.06", "", TODO_REQ());

        /*
         * Otherwise, the mbstate_t object pointed to by ps shall
         * be used to completely describe the current conversion
         * state of the associated character sequence.
         */
        REQ("mbrtowc.07", "", TODO_REQ());

        /*
         * The implementation shall behave as if no function defined
         * in this volume of IEEE Std 1003.1-2001 calls mbrtowc().
         */
        REQ("mbrtowc.08", "", TODO_REQ());

        /*
         * The behavior of this function is affected by the LC_CTYPE
         * category of the current locale.
         */
        REQ("mbrtowc.09", "", TODO_REQ());

        /*
         * The mbrtowc() function shall return the first of the
         * following that applies:
         *
         * 0
         *
         * If the next n or fewer bytes complete the character that
         * corresponds to the null wide character (which is the
         * value stored).
         */
        REQ("mbrtowc.10.01", "", TODO_REQ());

        /*
         * The mbrtowc() function shall return the first of the
         * following that applies:
         *
         * between 1 and n inclusive
         *
         * If the next n or fewer bytes complete a valid character
         * (which is the value stored);
         * the value returned shall be the number of bytes that
         * complete the character.
         */
        REQ("mbrtowc.10.02", "", TODO_REQ());

        /*
         * The mbrtowc() function shall return the first of the
         * following that applies:
         *
         * (size_t)-2
         *
         * If the next n bytes contribute to an incomplete but
         * potentially valid character, and all n bytes have been
         * processed (no value is stored).
         * When n has at least the value of the {MB_CUR_MAX} macro,
         * this case can only occur if s points at a sequence of
         * redundant shift sequences (for implementations with
         * state-dependent encodings).
         */
        REQ("mbrtowc.10.03", "", TODO_REQ());

        /*
         * The mbrtowc() function shall return the first of the
         * following that applies:
         *
         * (size_t)-1
         *
         * If an encoding error occurs, in which case the next n or fewer
         * bytes do not contribute to a complete and valid character
         * (no value is stored). In this case, [EILSEQ] shall be stored
         * in errno and the conversion state is undefined.
         */
        REQ("mbrtowc.10.04", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mbsinit - determine conversion object status

SYNOPSIS

    #include <wchar.h>

    int mbsinit(const mbstate_t *ps);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

If ps is not a null pointer, the mbsinit() function shall determine whether the
object pointed to by ps describes an initial conversion state.

RETURN VALUE

The mbsinit() function shall return non-zero if ps is a null pointer, or if the
pointed-to object describes an initial conversion state; otherwise, it shall
return zero.

If an mbstate_t object is altered by any of the functions described as "
restartable", and is then used with a different character sequence, or in
the other conversion direction, or with a different LC_CTYPE category setting
than on earlier function calls, the behavior is undefined.

ERRORS

    No errors are defined.
*/

specification
IntT mbsinit_spec( CallContext context, Mbstate* ps)
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * If ps is not a null pointer, the mbsinit() function shall
         * determine whether the object pointed to by ps describes an
         * initial conversion state.
         */
        REQ("mbsinit.01", "", TODO_REQ());

        /*
         * The mbsinit() function shall return non-zero if ps is a
         * null pointer, or if the pointed-to object describes an
         * initial conversion state;
         */
        REQ("mbsinit.02", "", TODO_REQ());

        /*
         * otherwise, it shall return zero.
         */
        REQ("mbsinit.03", "", TODO_REQ());

        /*
         * If an mbstate_t object is altered by any of the functions
         * described as "restartable", and is then used with a
         * different character sequence, or in the other conversion
         * direction, or with a different LC_CTYPE category setting
         * than on earlier function calls, the behavior is undefined.
         */
        REQ("mbsinit.04", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  mbsnrtowcs

Name
    mbsnrtowcs -- convert a multibyte string to a wide character string

Synopsis

    #include <wchar.h>

    size_t mbsnrtowcs(wchar_t * dest, const char * * src, size_t nms,
        size_t len, mbstate_t * ps);

Description

    mbsnrtowcs() is like mbsrtowcs(), except that the number of bytes to be
    converted, starting at src, is limited to nms. If dest is not a NULL
    pointer, mbsnrtowcs() converts at most nms bytes from the multibyte string
    src to a wide-character string starting at dest. At most, len wide
    characters are written to dest. The state ps is updated.

    The conversion is effectively performed by repeatedly calling:

    mbrtowc(dest, *src, n, ps)

    where n is some positive number, as long as this call succeeds, and then
    incrementing dest by one and src by the number of bytes consumed.

    The conversion can stop for three reasons:

    An invalid multibyte sequence has been encountered. In this case src is
    left pointing to the invalid multibyte sequence, (size_t)(-1) is returned,
    and errno is set to EILSEQ.

    The nms limit forces a stop, or len non-L'\0' wide characters have been
    stored at dest. In this case, src is left pointing to the next multibyte
    sequence to be converted, and the number of wide characters written to dest
    is returned.

    The multibyte string has been completely converted, including the
    terminating '\0' (which has the side effect of bringing back ps to the
    initial state). In this case, src is set to NULL, and the number of wide
    characters written to dest, excluding the terminating L'\0' character,
    is returned.

    If dest is NULL, len is ignored, and the conversion proceeds as above,
    except that the converted wide characters are not written out to memory,
    and that no destination length limit exists.

    In both of the above cases, if ps is a NULL pointer, a static anonymous
    state only known to mbsnrtowcs() is used instead.

    The programmer shall ensure that there is room for at least len wide
    characters at dest.

Return Value

    mbsnrtowcs() returns the number of wide characters that make up the
    converted part of the wide character string, not including the terminating
    null wide character. If an invalid multibyte sequence was encountered,
    (size_t)(-1) is returned, and the global variable errno is set to [EILSEQ].
*/
specification
IntT mbsnrtowcs_spec( CallContext context, WStringTPtr* dst, StringTPtr* src,
                     IntT nms ,IntT len, Mbstate* ps, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(LSB_MBSNRTOWCS, "mbsnrtowcs.11", mbsnrtowcs_spec==-1, *errno)
        /*
         * If an invalid multibyte sequence was encountered, (size_t)(-1)
         * is returned, and the global variable errno is set to [EILSEQ].
         */
            ERROR_SHALL(LSB_MBSNRTOWCS, EILSEQ, "mbsnrtowcs.11",
                TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * mbsnrtowcs() is like mbsrtowcs(), except that the number
         * of bytes to be converted, starting at src, is limited to nms.
         */
        REQ("mbsnrtowcs.01", "", TODO_REQ());

        /*
         * If dest is not a NULL pointer, mbsnrtowcs() converts at most nms
         * bytes from the multibyte string src to a wide-character string
         * starting at dest.
         */
        REQ("mbsnrtowcs.02", "", TODO_REQ());

        /*
         * At most, len wide characters are written to dest.
         */
        REQ("mbsnrtowcs.03", "", TODO_REQ());

        /*
         * The state ps is updated.
         */
        REQ("mbsnrtowcs.04", "", TODO_REQ());

        /*
         * The conversion is effectively performed by repeatedly calling:
         *
         * mbrtowc(dest, *src, n, ps) where n is some positive number, as
         * long as this call succeeds, and then incrementing dest by one
         * and src by the number of bytes consumed.
         */
        REQ("mbsnrtowcs.05", "", TODO_REQ());

        /*
         * The conversion can stop for three reasons:
         *
         * An invalid multibyte sequence has been encountered. In this
         * case src is left pointing to the invalid multibyte sequence,
         * (size_t)(-1) is returned, and errno is set to EILSEQ.
         */
        REQ("mbsnrtowcs.06.01", "", TODO_REQ());

        /*
         * The conversion can stop for three reasons:
         *
         * The nms limit forces a stop, or len non-L'\0' wide
         * characters have been stored at dest. In this case, src
         * is left pointing to the next multibyte
         * sequence to be converted, and the number of wide
         * characters written to dest is returned.
         */
        REQ("mbsnrtowcs.06.02", "", TODO_REQ());

        /*
         * The conversion can stop for three reasons:
         *
         * The multibyte string has been completely converted, including
         * the terminating '\0' (which has the side effect of bringing
         * back ps to the initial state). In this case, src is set to
         * NULL, and the number of wide characters written to
         * dest, excluding the terminating L'\0' character, is returned.
         */
        REQ("mbsnrtowcs.06.03", "", TODO_REQ());

        /*
         * If dest is NULL, len is ignored, and the conversion proceeds
         * as above, except that the converted wide characters are not
         * written out to memory, and that no destination length
         * limit exists.
         */
        REQ("mbsnrtowcs.07", "", TODO_REQ());

        /*
         * In both of the above cases, if ps is a NULL pointer, a
         * static anonymous state only known to mbsnrtowcs() is
         * used instead.
         */
        REQ("mbsnrtowcs.08", "", TODO_REQ());

        /*
         * The programmer shall ensure that there is room for at least
         * len wide characters at dest.
         */
        REQ("mbsnrtowcs.09", "", TODO_REQ());

        /*
         * mbsnrtowcs() returns the number of wide characters that make
         * up the converted part of the wide character string, not
         * including the terminating null wide character.
         */
        REQ("mbsnrtowcs.10", "", TODO_REQ());


        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mbsrtowcs - convert a character string to a wide-character string
    (restartable)

SYNOPSIS

    #include <wchar.h>

    size_t mbsrtowcs(wchar_t *restrict dst, const char **restrict src,

        size_t len, mbstate_t *restrict ps);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The mbsrtowcs() function shall convert a sequence of characters, beginning in
the conversion state described by the object pointed to by ps, from the array
indirectly pointed to by src into a sequence of corresponding wide characters.
If dst is not a null pointer, the converted characters shall be stored into the
array pointed to by dst. Conversion continues up to and including a terminating
null character, which shall also be stored. Conversion shall stop early in
either of the following cases:

A sequence of bytes is encountered that does not form a valid character.

len codes have been stored into the array pointed to by dst (and dst is not a
null pointer).

Each conversion shall take place as if by a call to the mbrtowc() function.

If dst is not a null pointer, the pointer object pointed to by src shall be
assigned either a null pointer (if conversion stopped due to reaching a
terminating null character) or the address just past the last character
converted (if any). If conversion stopped due to reaching a terminating null
character, and if dst is not a null pointer, the resulting state described
shall be the initial conversion state.

If ps is a null pointer, the mbsrtowcs() function shall use its own internal
mbstate_t object, which is initialized at program start-up to the initial
conversion state. Otherwise, the mbstate_t object pointed to by ps shall be
used to completely describe the current conversion state of the associated
character sequence. The implementation behaves as if no function defined in
this volume of IEEE Std 1003.1-2001 calls mbsrtowcs().

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

If the input conversion encounters a sequence of bytes that do not form a valid
character, an encoding error occurs. In this case, the mbsrtowcs() function
stores the value of the macro [EILSEQ] in errno and shall return (size_t)-1;
the conversion state is undefined. Otherwise, it shall return the number of
characters successfully converted, not including the terminating null (if any).

ERRORS

    The mbsrtowcs() function may fail if:

    [EINVAL]

        [CX] ps points to an object that contains an invalid conversion state.

    [EILSEQ]

        Invalid character sequence is detected.
*/
specification
IntT mbsrtowcs_spec( CallContext context, WStringTPtr* dst, StringTPtr* src,
                    IntT len, Mbstate* ps, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_MBSRTOWCS, "mbsrtowcs.16.01", *errno!=SUT_EOK, *errno)
        /*
         * The mbsrtowcs() function may fail if:
         *
         * [EINVAL]
         *
         * [CX] ps points to an object that contains an invalid
         * conversion state.
         */
            ERROR_MAY(POSIX_MBSRTOWCS, EINVAL, "mbsrtowcs.16.01",
                TODO_ERR(EINVAL))

        /*
         * The mbsrtowcs() function may fail if:
         *
         * [EILSEQ]
         *
         * Invalid character sequence is detected.
         */
            ERROR_MAY(POSIX_MBSRTOWCS, EILSEQ, "mbsrtowcs.16.02",
                TODO_ERR(EILSEQ))

        ERROR_END()
        /*
         * The mbsrtowcs() function shall convert a sequence of characters,
         * beginning in the conversion state described by the object
         * pointed to by ps, from the array indirectly pointed to by src
         * into a sequence of corresponding wide characters.
         */
        REQ("mbsrtowcs.01", "", TODO_REQ());

        /*
         * If dst is not a null pointer, the converted characters shall
         * be stored into the array pointed to by dst.
         */
        REQ("mbsrtowcs.02", "", TODO_REQ());

        /*
         * Conversion continues up to and including a terminating null
         * character, which shall also be stored.
         */
        REQ("mbsrtowcs.03", "", TODO_REQ());

        /*
         * Conversion shall stop early in either of the following cases:
         *
         * A sequence of bytes is encountered that does not form a
         * valid character.
         */
        REQ("mbsrtowcs.04.01", "", TODO_REQ());

        /*
         * Conversion shall stop early in either of the following cases:
         *
         * len codes have been stored into the array pointed to by
         * dst (and dst is not a null pointer).
         */
        REQ("mbsrtowcs.04.02", "", TODO_REQ());

        /*
         * Each conversion shall take place as if by a call to the
         * mbrtowc() function.
         */
        REQ("mbsrtowcs.05", "", TODO_REQ());

        /*
         * If dst is not a null pointer, the pointer object pointed to
         * by src shall be assigned either a null pointer
         * (if conversion stopped due to reaching a terminating
         * null character)
         */
        REQ("mbsrtowcs.06", "", TODO_REQ());

        /*
         * or the address just past the last character converted (if any).
         */
        REQ("mbsrtowcs.07", "", TODO_REQ());

        /*
         * If conversion stopped due to reaching a terminating null
         * character, and if dst is not a null pointer, the
         * resulting state described shall be the initial
         * conversion state.
         */
        REQ("mbsrtowcs.08", "", TODO_REQ());

        /*
         * If ps is a null pointer, the mbsrtowcs() function
         * shall use its own internal mbstate_t object, which
         * is initialized at program start-up to the initial
         * conversion state.
         */
        REQ("mbsrtowcs.09", "", TODO_REQ());

        /*
         * Otherwise, the mbstate_t object pointed to by ps shall
         * be used to completely describe the current conversion
         * state of the associated character sequence.
         */
        REQ("mbsrtowcs.10", "", TODO_REQ());

        /*
         * The implementation behaves as if no function defined in
         * this volume of IEEE  Std 1003.1-2001 calls mbsrtowcs().
         */
        REQ("mbsrtowcs.11", "", TODO_REQ());

        /*
         * The behavior of this function shall be affected by the
         * LC_CTYPE category of the current locale.
         */
        REQ("mbsrtowcs.12", "", TODO_REQ());

        /*
         * If the input conversion encounters a sequence of bytes
         * that do not form a valid character, an encoding error
         * occurs. In this case, the mbsrtowcs() function
         * stores the value of the macro [EILSEQ] in errno
         * and shall return (size_t)-1; the conversion state is undefined.
         */
        REQ("mbsrtowcs.14", "", TODO_REQ());

        /*
         * Otherwise, it shall return the number of characters
         * successfully converted, not
         * including the terminating null (if any).
         */
        REQ("mbsrtowcs.15", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mbstowcs - convert a character string to a wide-character string

SYNOPSIS

    #include <stdlib.h>

    size_t mbstowcs(wchar_t *restrict pwcs, const char *restrict s,

        size_t n);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The mbstowcs() function shall convert a sequence of characters that begins in
the initial shift state from the array pointed to by s into a sequence of
corresponding wide-character codes and shall store not more than n wide-
character codes into the array pointed to by pwcs. No characters that follow
a null byte (which is converted into a wide-character code with value 0) shall
be examined or converted. Each character shall be converted as if by a call to
mbtowc(), except that the shift state of mbtowc() is not affected.

No more than n elements shall be modified in the array pointed to by pwcs. If
copying takes place between objects that overlap, the behavior is undefined.

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale. [XSI]  If pwcs is a null pointer, mbstowcs() shall return the
length required to convert the entire array regardless of the value of n, but
no values are stored.

RETURN VALUE

If an invalid character is encountered, mbstowcs() shall return (size_t)-1 [CX]
and may set errno to indicate the error.

Otherwise, mbstowcs() shall return the number of the array elements modified [
XSI]  (or required if pwcs is null), not including a terminating 0 code, if
any. The array shall not be zero-terminated if the value returned is n.

ERRORS

    The mbstowcs() function may fail if:

    [EILSEQ]

        [XSI] Invalid byte sequence is detected.
*/

specification
IntT mbstowcs_spec( CallContext context, WStringTPtr* pwcs, StringTPtr s,
                   IntT n, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_MBSTOWCS, "mbstowcs.11.01", *errno!=SUT_EOK, *errno)
        /*
         * The mbstowcs() function may fail if:
         *
         * [EILSEQ]
         *
         * [XSI] Invalid byte sequence is detected.
         */
            ERROR_MAY(POSIX_MBSTOWCS, EILSEQ, "mbstowcs.11.01",
                TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * The mbstowcs() function shall convert a sequence of characters
         * that begins in the initial shift state from the array
         * pointed to by s into a sequence of
         * corresponding wide-character codes and shall store not
         * more than n wide-character codes into the array pointed
         * to by pwcs.
         */
        REQ("mbstowcs.01", "", TODO_REQ());

        /*
         * No characters that follow a null byte (which is converted
         * into a wide-character
         * code with value 0) shall be examined or converted.
         */
        REQ("mbstowcs.02", "", TODO_REQ());

        /*
         * Each character shall be converted as if by a call to
         * mbtowc(), except that the
         * shift state of mbtowc() is not affected.
         */
        REQ("mbstowcs.03", "", TODO_REQ());

        /*
         * No more than n elements shall be modified in the
         * array pointed to by pwcs
         */
        REQ("mbstowcs.04", "", TODO_REQ());

        /*
         * If copying takes place between objects that overlap,
         * the behavior is undefined.
         */
        REQ("mbstowcs.05", "", TODO_REQ());

        /*
         * The behavior of this function shall be affected by the
         * LC_CTYPE category of the current locale.
         */
        REQ("mbstowcs.06", "", TODO_REQ());

        /*
         * [XSI]  If pwcs is a null pointer, mbstowcs() shall return
         * the length required to convert the entire array regardless
         * of the value of n, but no values are stored.
         */
        REQ("mbstowcs.07", "", TODO_REQ());

        /*
         * If an invalid character is encountered, mbstowcs() shall
         * return (size_t)-1 [CX] and may set errno to indicate
         * the error.
         */
        REQ("mbstowcs.08", "", TODO_REQ());

        /*
         * Otherwise, mbstowcs() shall return the number of the array
         * elements modified [XSI]  (or required if pwcs is null),
         * not including a terminating 0 code, if any.
         */
        REQ("mbstowcs.09", "", TODO_REQ());

        /*
         * The array shall not be zero-terminated
         * if the value returned is n.
         */
        REQ("mbstowcs.10", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mbtowc - convert a character to a wide-character code

SYNOPSIS

    #include <stdlib.h>

    int mbtowc(wchar_t *restrict pwc, const char *restrict s, size_t n);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

If s is not a null pointer, mbtowc() shall determine the number of bytes that
constitute the character pointed to by s. It shall then determine the wide-
character code for the value of type wchar_t that corresponds to that
character. (The value of the wide-character code corresponding to the null
byte is 0.) If the character is valid and pwc is not a null pointer, mbtowc()
shall store the wide-character code in the object pointed to by pwc.

The behavior of this function is affected by the LC_CTYPE category of the
current locale. For a state-dependent encoding, this function is placed into
its initial state by a call for which its character pointer argument, s, is a
null pointer. Subsequent calls with s as other than a null pointer shall cause
the internal state of the function to be altered as necessary. A call with s
as a null pointer shall cause this function to return a non-zero value if
encodings have state dependency, and 0 otherwise. If the implementation
employs special bytes to change the shift state, these bytes shall not produce
separate wide-character codes, but shall be grouped with an adjacent character.
Changing the LC_CTYPE category causes the shift state of this function to be
unspecified. At most n bytes of the array pointed to by s shall be examined.

The implementation shall behave as if no function defined in this volume of
IEEE Std 1003.1-2001 calls mbtowc().

RETURN VALUE

If s is a null pointer, mbtowc() shall return a non-zero or 0 value, if
character encodings, respectively, do or do not have state-dependent encodings.
If s is not a null pointer, mbtowc() shall either return 0 (if s points to the
null byte), or return the number of bytes that constitute the converted
character (if the next n or fewer bytes form a valid character), or return -1
[CX]  and may set errno to indicate the error (if they do not form a valid
character).

In no case shall the value returned be greater than n or the value of the {
MB_CUR_MAX} macro.

ERRORS

    The mbtowc() function may fail if:

    [EILSEQ]

        [XSI] Invalid character sequence is detected.
*/

specification
IntT mbtowc_spec( CallContext context, WStringTPtr* pwc, StringTPtr s, IntT n,
                 ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(POSIX_MBTOWC, "mbtowc.18.01", *errno!=SUT_EOK, *errno)
        /*
         * The mbtowc() function may fail if:
         *
         * [EILSEQ]
         *
         * [XSI] Invalid character sequence is detected.
         */
            ERROR_MAY(POSIX_MBTOWC, EILSEQ, "mbtowc.18.01", TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * If s is not a null pointer, mbtowc() shall determine the
         * number of bytes that constitute the character pointed to by s.
         */
        REQ("mbtowc.01", "", TODO_REQ());

        /*
         * It shall then determine the wide-character code for
         * the value of type wchar_t
         * that corresponds to that character.
         */
        REQ("mbtowc.02", "", TODO_REQ());

        /*
         * (The value of the wide-character code corresponding
         * to the null byte is 0.)
         */
        REQ("mbtowc.03", "", TODO_REQ());

        /*
         * If the character is valid and pwc is not a null pointer,
         * mbtowc() shall store
         * the wide-character code in the object pointed to by pwc.
         */
        REQ("mbtowc.04", "", TODO_REQ());

        /*
         * The behavior of this function is affected by the
         * LC_CTYPE category of the
         * current locale
         */
        REQ("mbtowc.05", "", TODO_REQ());

        /*
         * For a state-dependent encoding, this function is placed
         * into its initial state
         * by a call for which its character pointer argument, s,
         * is a null pointer.
         */
        REQ("mbtowc.06", "", TODO_REQ());

        /*
         * Subsequent calls with s as other than a null pointer
         * shall cause the internal
         * state of the function to be altered as necessary.
         */
        REQ("mbtowc.07", "", TODO_REQ());

        /*
         * A call with s as a null pointer shall cause this
         * function to return a non-zero
         * value if encodings have state dependency, and 0 otherwise.
         */
        REQ("mbtowc.08", "", TODO_REQ());

        /*
         * If the implementation employs special bytes to change
         * the shift state, these bytes shall not produce separate
         * wide-character codes, but shall be grouped
         * with an adjacent character.
         */
        REQ("mbtowc.09", "", TODO_REQ());

        /*
         * Changing the LC_CTYPE category causes the shift state
         * of this function to be unspecified.
         */
        REQ("mbtowc.10", "", TODO_REQ());

        /*
         * At most n bytes of the array pointed to by s shall be examined.
         */
        REQ("mbtowc.11", "", TODO_REQ());

        /*
         * The implementation shall behave as if no function
         * defined in this volume of
         * IEEE Std 1003.1-2001 calls mbtowc().
         */
        REQ("mbtowc.12", "", TODO_REQ());

        /*
         * If s is a null pointer, mbtowc() shall return a
         * non-zero or 0 value, if
         * character encodings, respectively, do or do not
         * have state-dependent encodings.
         */
        REQ("mbtowc.13", "", TODO_REQ());

        /*
         * If s is not a null pointer, mbtowc() shall either return 0
         * (if s points to the null byte)
         */
        REQ("mbtowc.14", "", TODO_REQ());

        /*
         * or return the number of bytes that constitute the converted
         * character (if the next n or fewer bytes form a valid character),
         */
        REQ("mbtowc.15", "", TODO_REQ());

        /*
         * or return -1 [CX]  and may set errno to indicate the error
         * (if they do not form a valid character).
         */
        REQ("mbtowc.16", "", TODO_REQ());

        /*
         * In no case shall the value returned be greater than n or
         * the value of the { MB_CUR_MAX} macro.
         */
        REQ("mbtowc.17", "", TODO_REQ());
        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wcrtomb - convert a wide-character code to a character (restartable)

SYNOPSIS

    #include <stdio.h>

    size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict ps);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

If s is a null pointer, the wcrtomb() function shall be equivalent to the call:

wcrtomb(buf, L'\0', ps)

where buf is an internal buffer.

If s is not a null pointer, the wcrtomb() function shall determine the number
of bytes needed to represent the character that corresponds to the wide
character given by wc (including any shift sequences), and store the resulting
bytes in the array whose first element is pointed to by s. At most {
MB_CUR_MAX} bytes are stored. If wc is a null wide character, a null byte
shall be stored, preceded by any shift sequence needed to restore the initial
shift state. The resulting state described shall be the initial conversion
state.

If ps is a null pointer, the wcrtomb() function shall use its own internal
mbstate_t object, which is initialized at program start-up to the initial
conversion state. Otherwise, the mbstate_t object pointed to by ps shall be
used to completely describe the current conversion state of the associated
character sequence. The implementation shall behave as if no function defined
in this volume of IEEE Std 1003.1-2001 calls wcrtomb().

[CX] If the application uses any of the _POSIX_THREAD_SAFE_FUNCTIONS or
_POSIX_THREADS functions, the application shall ensure that the wcrtomb()
function is called with a non-NULL ps argument.

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

The wcrtomb() function shall return the number of bytes stored in the array
object (including any shift sequences). When wc is not a valid wide
character, an encoding error shall occur. In this case, the function shall
store the value of the macro [EILSEQ] in errno and shall return (size_t)-1;
the conversion state shall be undefined.

ERRORS

    The wcrtomb() function may fail if:

    [EINVAL]

        [CX] ps points to an object that contains an invalid conversion state.

    [EILSEQ]

        Invalid wide-character code is detected.
*/

specification
IntT wcrtomb_spec( CallContext context, StringTPtr* s, WCharT wc, Mbstate* ps,
                  ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(POSIX_WCRTOMB, "wcrtomb.15.01", *errno!=SUT_EOK, *errno)
        /*
         * The wcrtomb() function may fail if:
         *
         * [EINVAL]
         *
         * [CX] ps points to an object that contains an invalid conversion
         * state.
         */
            ERROR_MAY(POSIX_WCRTOMB, EINVAL, "wcrtomb.15.01", TODO_ERR(EINVAL))

        /*
         * The wcrtomb() function may fail if:
         *
         * [EILSEQ]
         *
         * Invalid wide-character code is detected.
         */
            ERROR_MAY(POSIX_WCRTOMB, EILSEQ, "wcrtomb.15.02", TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * If s is a null pointer, the wcrtomb() function shall be
         * equivalent to the call:
         *
         * wcrtomb(buf, L'\0', ps)
         *
         * where buf is an internal buffer.
         */
        REQ("wcrtomb.01", "", TODO_REQ());

        /*
         * If s is not a null pointer, the wcrtomb() function shall
         * determine the number of bytes needed to represent the
         * character that corresponds to the wide
         * character given by wc (including any shift sequences),
         */
        REQ("wcrtomb.02", "", TODO_REQ());

        /*
         * and store the resulting bytes in the array whose first
         * element is pointed to by s.
         */
        REQ("wcrtomb.03", "", TODO_REQ());

        /*
         * At most {MB_CUR_MAX} bytes are stored.
         */
        REQ("wcrtomb.04", "", TODO_REQ());

        /*
         * If wc is a null wide character, a null byte shall be
         * stored, preceded by any shift sequence needed to restore
         * the initial shift state.
         */
        REQ("wcrtomb.05", "", TODO_REQ());

        /*
         * The resulting state described shall be the initial
         * conversion state.
         */
        REQ("wcrtomb.06", "", TODO_REQ());

        /*
         * If ps is a null pointer, the wcrtomb() function shall use
         * its own internal
         * mbstate_t object, which is initialized at program
         * start-up to the initial conversion state.
         */
        REQ("wcrtomb.07", "", TODO_REQ());

        /*
         * Otherwise, the mbstate_t object pointed to by ps shall be
         * used to completely describe the current conversion state
         * of the associated character sequence.
         */
        REQ("wcrtomb.08", "", TODO_REQ());

        /*
         * The implementation shall behave as if no function defined
         * in this volume of
         * IEEE Std 1003.1-2001 calls wcrtomb().
         */
        REQ("wcrtomb.09", "", TODO_REQ());

        /*
         * [CX] If the application uses any of the
         * _POSIX_THREAD_SAFE_FUNCTIONS or
         * _POSIX_THREADS functions, the application shall ensure
         * that the wcrtomb()
         * function is called with a non-NULL ps argument.
         */
        REQ("wcrtomb.10", "", TODO_REQ());

        /*
         * The behavior of this function shall be affected by the
         * LC_CTYPE category of the current locale.
         */
        REQ("wcrtomb.11", "", TODO_REQ());

        /*
         * The wcrtomb() function shall return the number of bytes
         * stored in the array object (including any shift sequences).
         */
        REQ("wcrtomb.12", "", TODO_REQ());

        /*
         * When wc is not a valid wide character, an encoding
         * error shall occur.
         */
        REQ("wcrtomb.13", "", TODO_REQ());

        /*
         * In this case, the function shall store the value of the
         * macro [EILSEQ] in
         * errno and shall return (size_t)-1; the conversion state
         * shall be undefined.
         */
        REQ("wcrtomb.14", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  wcsnrtombs

Name

    wcsnrtombs -- convert a wide character string to a multi-byte string

Synopsis

    #include <wchar.h>

    size_t wcsnrtombs(char * dest, const wchar_t * * src, size_t nwc,
        size_t len, mbstate_t * ps);

Description

    wcsnrtombs() is like wcsrtombs(), except that the number of wide characters
    to be converted, starting at src, is limited to nwc.

    If dest is not a NULL pointer, wcsnrtombs() converts at most nwc wide
    characters from the wide-character string src to a multibyte string
    starting at dest. At most len bytes are written to dest. The state ps is
    updated.

    The conversion is effectively performed by repeatedly calling:

    wcrtomb(dest, *src, ps)

    as long as this call succeeds, and then incrementing dest by the number
    of bytes written and src by 1.

    The conversion can stop for three reasons:

    A wide character has been encountered that cannot be represented as a
    multibyte sequence (according to the current locale). In this case src
    is left pointing to the invalid wide character, (size_t)(-1) is returned,
    and errno is set to EILSEQ.

    nws wide characters have been converted without encountering a null wide
    character code, or the length limit forces a stop. In this case, src is
    left pointing to the next wide character to be converted, and the number
    bytes written to dest is returned.

    The wide-character string has been completely converted, including the
    terminating null wide character code (which has the side effect of bringing
    back ps to the initial state). In this case, src is set to NULL, and the
    number of bytes written to dest, excluding the terminating null wide
    character code, is returned.

    If dest is NULL, len is ignored, and the conversion proceeds as above,
    except that the converted bytes are not written out to memory, and that no
    destination length limit exists.

    In both of the above cases, if ps is a NULL pointer, a static anonymous
    state only known to wcsnrtombs() is used instead.

    The programmer shall ensure that there is room for at least len bytes at
    dest.

Return Value

    wcsnrtombs() returns the number of bytes that make up the converted part of
    multibyte sequence, not including the terminating null wide character code.
    If a wide character was encountered which could not be converted,
    (size_t)(-1) is returned, and the global variable errno set to [EILSEQ].
*/
specification
IntT wcsnrtombs_spec( CallContext context, StringTPtr* dst, WStringTPtr* src,
                     IntT nws, IntT len, Mbstate* ps, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
         ERROR_BEGIN(LSB_WCSNRTOMBS, "wcsnrtombs.11", *errno!=SUT_EOK, *errno)
        /*
         * If a wide character was encountered which could not be converted,
         * (size_t)(-1)
         * is returned, and the global variable errno set to [EILSEQ].
         */
            ERROR_SHALL(LSB_WCSNRTOMBS, EILSEQ, "wcsnrtombs.11",
                TODO_ERR(EILSEQ))

        ERROR_END()

        /*
         * wcsnrtombs() is like wcsrtombs(), except that the number of
         * wide characters to
         * be converted, starting at src, is limited to nwc.
         */
        REQ("wcsnrtombs.01", "", TODO_REQ());

        /*
         * If dest is not a NULL pointer, wcsnrtombs() converts at most
         * nwc wide characters from the wide-character string src to
         * a multibyte string starting at dest
         */
        REQ("wcsnrtombs.02", "", TODO_REQ());

        /*
         * At most len bytes are written to dest.
         */
        REQ("wcsnrtombs.03", "", TODO_REQ());

        /*
         * The state ps is updated.
         */
        REQ("wcsnrtombs.04", "", TODO_REQ());

        /*
         * The conversion is effectively performed by repeatedly calling:
         * wcrtomb(dest, *src, ps) as long as this call succeeds, and
         * then incrementing dest by the number of bytes written
         * and src by 1.
         */
        REQ("wcsnrtombs.05", "", TODO_REQ());

        /*
         * The conversion can stop for three reasons:
         *
         * A wide character has been encountered that cannot be
         * represented as a multibyte sequence (according to the
         * current locale). In this case src is
         * left pointing to the invalid wide character,
         * (size_t)(-1) is returned, and errno is set to EILSEQ.
         */
        REQ("wcsnrtombs.06.01", "", TODO_REQ());

        /*
         * The conversion can stop for three reasons:
         *
         * nws wide characters have been converted without
         * encountering a null wide character code, or the length
         * limit forces a stop. In this case, src is left
         * pointing to the next wide character to be converted, and
         * the number bytes written to dest is returned.
         */
        REQ("wcsnrtombs.06.02", "", TODO_REQ());

        /*
         * The conversion can stop for three reasons:
         *
         * The wide-character string has been completely converted,
         * including the terminating null wide character code
         * (which has the side effect of bringing
         * back ps to the initial state). In this case, src is set
         * to NULL, and the number of bytes written to dest,
         * excluding the terminating null wide character code, is returned.
         */
        REQ("wcsnrtombs.06.03", "", TODO_REQ());

        /*
         * If dest is NULL, len is ignored, and the conversion
         * proceeds as above, except that the converted bytes
         * are not written out to memory, and that no
         * destination length limit exists.
         */
        REQ("wcsnrtombs.07", "", TODO_REQ());

        /*
         * In both of the above cases, if ps is a NULL pointer,
         * a static anonymous state only known to wcsnrtombs()
         * is used instead.
         */
        REQ("wcsnrtombs.08", "", TODO_REQ());

        /*
         * The programmer shall ensure that there is room for at
         * least len bytes at dest.
         */
        REQ("wcsnrtombs.09", "", TODO_REQ());

        /*
         * wcsnrtombs() returns the number of bytes that make up
         * the converted part of
         * multibyte sequence, not including the terminating null
         * wide character code
         */
        REQ("wcsnrtombs.10", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wcsrtombs - convert a wide-character string to a character string
        (restartable)

SYNOPSIS

    #include <wchar.h>

    size_t wcsrtombs(char *restrict dst, const wchar_t **restrict src,

        size_t len, mbstate_t *restrict ps);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The wcsrtombs() function shall convert a sequence of wide characters from the
array indirectly pointed to by src into a sequence of corresponding characters,
beginning in the conversion state described by the object pointed to by ps. If
dst is not a null pointer, the converted characters shall then be stored into
the array pointed to by dst. Conversion continues up to and including a
terminating null wide character, which shall also be stored. Conversion shall
stop earlier in the following cases:

When a code is reached that does not correspond to a valid character

When the next character would exceed the limit of len total bytes to be stored
in the array pointed to by dst (and dst is not a null pointer)

Each conversion shall take place as if by a call to the wcrtomb() function.

If dst is not a null pointer, the pointer object pointed to by src shall be
assigned either a null pointer (if conversion stopped due to reaching a
terminating null wide character) or the address just past the last wide
character converted (if any). If conversion stopped due to reaching a
terminating null wide character, the resulting state described shall be the
initial conversion state.

If ps is a null pointer, the wcsrtombs() function shall use its own internal
mbstate_t object, which is initialized at program start-up to the initial
conversion state. Otherwise, the mbstate_t object pointed to by ps shall be
used to completely describe the current conversion state of the associated
character sequence. The implementation shall behave as if no function defined
in this volume of IEEE Std 1003.1-2001 calls wcsrtombs().

[CX] If the application uses any of the _POSIX_THREAD_SAFE_FUNCTIONS or
_POSIX_THREADS functions, the application shall ensure that the wcsrtombs()
function is called with a non-NULL ps argument.

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

If conversion stops because a code is reached that does not correspond to a
valid character, an encoding error occurs. In this case, the wcsrtombs()
function shall store the value of the macro [EILSEQ] in errno and return (
size_t)-1; the conversion state is undefined. Otherwise, it shall return the
number of bytes in the resulting character sequence, not including the
terminating null (if any).

ERRORS

    The wcsrtombs() function may fail if:

    [EINVAL]

        [CX] ps points to an object that contains an invalid conversion state.

    [EILSEQ]

        A wide-character code does not correspond to a valid character.
*/

specification
IntT wcsrtombs_spec( CallContext context, StringTPtr* dst, WStringTPtr* src,
                    IntT len, Mbstate* ps, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_WCSRTOMBS, "wcsrtombs.17.01", *errno!=SUT_EOK, *errno)
        /*
         * The wcsrtombs() function may fail if:
         *
         * [EINVAL]
         *
         * [CX] ps points to an object that contains an invalid conversion
         * state.
         */
            ERROR_MAY(POSIX_WCSRTOMBS, EINVAL, "wcsrtombs.17.01",
                TODO_ERR(EINVAL))

        /*
         * The wcsrtombs() function may fail if:
         *
         * [EILSEQ]
         *
         * A wide-character code does not correspond to a valid character.
         */
            ERROR_MAY(POSIX_WCSRTOMBS, EILSEQ, "wcsrtombs.17.02",
                TODO_ERR(EILSEQ))

        ERROR_END()
        /*
         * The wcsrtombs() function shall convert a sequence of wide
         * characters from the array indirectly pointed to by src
         * into a sequence of corresponding characters,
         * beginning in the conversion state described by the object
         * pointed to by ps.
         */
        REQ("wcsrtombs.01", "", TODO_REQ());

        /*
         * If dst is not a null pointer, the converted characters
         * shall then be stored
         * into the array pointed to by dst.
         */
        REQ("wcsrtombs.02", "", TODO_REQ());

        /*
         * Conversion continues up to and including a terminating
         * null wide character, which shall also be stored.
         */
        REQ("wcsrtombs.03", "", TODO_REQ());

        /*
         * Conversion shall stop earlier in the following cases:
         *
         * When a code is reached that does not correspond
         * to a valid character
         */
        REQ("wcsrtombs.04.01", "", TODO_REQ());

        /*
         * Conversion shall stop earlier in the following cases:
         *
         * When the next character would exceed the limit of len
         * total bytes to be stored
         * in the array pointed to by dst (and dst is not a null pointer)
         */
        REQ("wcsrtombs.04.02", "", TODO_REQ());

        /*
         * Each conversion shall take place as if by a call to
         * the wcrtomb() function.
         */
        REQ("wcsrtombs.05", "", TODO_REQ());

        /*
         * If dst is not a null pointer, the pointer object pointed to
         * by src shall be
         * assigned either a null pointer (if conversion stopped due
         * to reaching a  terminating null wide character)
         */
        REQ("wcsrtombs.06", "", TODO_REQ());

        /*
         * or the address just past the last wide character converted (if any).
         */
        REQ("wcsrtombs.07", "", TODO_REQ());

        /*
         * If conversion stopped due to reaching a terminating
         * null wide character, the
         * resulting state described shall be the initial
         * conversion state.
         */
        REQ("wcsrtombs.08", "", TODO_REQ());

        /*
         * If ps is a null pointer, the wcsrtombs() function shall
         * use its own internal
         * mbstate_t object, which is initialized at program
         * start-up to the initial conversion state.
         */
        REQ("wcsrtombs.09", "", TODO_REQ());

        /*
         * Otherwise, the mbstate_t object pointed to by ps shall
         * be used to completely
         * describe the current conversion state of the associated
         * character sequence.
         */
        REQ("wcsrtombs.10", "", TODO_REQ());

        /*
         * The implementation shall behave as if no function defined
         * in this volume of IEEE Std 1003.1-2001 calls wcsrtombs().
         */
        REQ("wcsrtombs.11", "", TODO_REQ());

        /*
         * [CX] If the application uses any of the
         * _POSIX_THREAD_SAFE_FUNCTIONS or
         * _POSIX_THREADS functions, the application shall
         * ensure that the wcsrtombs()
         * function is called with a non-NULL ps argument.
         */
        REQ("wcsrtombs.12", "", TODO_REQ());

        /*
         * The behavior of this function shall be affected by
         * the LC_CTYPE category of the current locale.
         */
        REQ("wcsrtombs.13", "", TODO_REQ());

        /*
         * If conversion stops because a code is reached that
         * does not correspond to a valid character, an
         * encoding error occurs.
         */
        REQ("wcsrtombs.14", "", TODO_REQ());

        /*
         * In this case, the wcsrtombs() function shall store
         * the value of the macro [EILSEQ] in errno and return
         * (size_t)-1; the conversion state is undefined.
         */
        REQ("wcsrtombs.15", "", TODO_REQ());

        /*
         * Otherwise, it shall return the number of bytes in the
         * resulting character
         * sequence, not including the terminating null (if any).
         */
        REQ("wcsrtombs.16", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wcstombs - convert a wide-character string to a character string

SYNOPSIS

    #include <stdlib.h>

    size_t wcstombs(char *restrict s, const wchar_t *restrict pwcs,

        size_t n);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The wcstombs() function shall convert the sequence of wide-character codes that
are in the array pointed to by pwcs into a sequence of characters that
begins in the initial shift state and store these characters into the array
pointed to by s, stopping if a character would exceed the limit of n total
bytes or if a null byte is stored. Each wide-character code shall be
converted as if by a call to wctomb(), except that the shift state of wctomb()
shall not be affected.

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale.

No more than n bytes shall be modified in the array pointed to by s. If
copying takes place between objects that overlap, the behavior is undefined.
[CX]  If s is a null pointer, wcstombs() shall return the length required to
convert the entire array regardless of the value of n, but no values are
stored.

The wcstombs() function need not be reentrant. A function that is not required
to be reentrant is not required to be thread-safe.

RETURN VALUE

If a wide-character code is encountered that does not correspond to a valid
character (of one or more bytes each), wcstombs() shall return (size_t)-1.
Otherwise, wcstombs() shall return the number of bytes stored in the character
array, not including any terminating null byte. The array shall not be null-
terminated if the value returned is n.

ERRORS

    The wcstombs() function may fail if:

    [EILSEQ]

        [CX] A wide-character code does not correspond to a valid character.
*/
specification
IntT wcstombs_spec( CallContext context, StringTPtr* s, WStringTPtr pwcs,
                   IntT n, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_WCSTOMBS, "wcstombs.10.01", *errno!=SUT_EOK, *errno)
        /*
         * The wcstombs() function may fail if:
         *
         * [EILSEQ]
         *
         * [CX] A wide-character code does not correspond to a valid character.
         */
            ERROR_MAY(POSIX_WCSTOMBS, EILSEQ, "wcstombs.10.01",
                        TODO_ERR(EILSEQ))

        ERROR_END()
        /*
         * If a wide-character code is encountered that does not correspond
         * to a valid
         * character (of one or more bytes each), wcstombs() shall
         * return (size_t)-1.
         */
        REQ("wcstombs.07", "", TODO_REQ());

        /*
         * Otherwise, wcstombs() shall return the
         * number of bytes stored in the character
         * array, not including any terminating null byte.
         */
        REQ("wcstombs.08", "", TODO_REQ());

        /*
         * The array shall not be null-terminated if
         * the value returned is n.
         */
        REQ("wcstombs.09", "", TODO_REQ());

        /*
         * The wcstombs() function shall convert
         * the sequence of wide-character codes that
         * are in the array pointed to by pwcs into
         * a sequence of characters that
         * begins in the initial shift state and
         * store these characters into the array
         * pointed to by s, stopping if a character
         * would exceed the limit of n total
         * bytes or if a null byte is stored.
         */
        REQ("wcstombs.01", "", TODO_REQ());

        /*
         * Each wide-character code shall be
         * converted as if by a call to wctomb(),
         * except that the shift state of
         * wctomb() shall not be affected.
         */
        REQ("wcstombs.02", "", TODO_REQ());

        /*
         * The behavior of this function shall
         * be affected by the LC_CTYPE category of the
         * current locale.
         */
        REQ("wcstombs.03", "", TODO_REQ());

        /*
         * If copying takes place between objects
         * that overlap, the behavior is undefined.
         */
        REQ("wcstombs.04", "", TODO_REQ());

        /*
         * [CX]  If s is a null pointer, wcstombs()
         * shall return the length required to
         * convert the entire array regardless of
         * the value of n, but no values are
         * stored.
         */
        REQ("wcstombs.05", "", TODO_REQ());

        /*
         * The wcstombs() function need not be
         * reentrant. A function that is not required
         * to be reentrant is not required to
         * be thread-safe.
         */
        REQ("wcstombs.06", "", TODO_REQ());

        /*
         * No more than n bytes shall be modified
         * in the array pointed to by s.
         */
        REQ("wcstombs.11", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wctob - wide-character to single-byte conversion

SYNOPSIS

    #include <stdio.h>

    #include <wchar.h>

    int wctob(wint_t c);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The wctob() function shall determine whether c corresponds to a member of the
extended character set whose character representation is a single byte when in
the initial shift state.

The behavior of this function shall be affected by the LC_CTYPE category of the
current locale.

RETURN VALUE

    The wctob() function shall return EOF if c does not correspond to
    a character with length one in the initial shift state. Otherwise, it
    shall return the single-byte representation of that character as an
    unsigned char converted to int.

ERRORS

    No errors are defined.
*/

specification
IntT wctob_spec( CallContext context, WIntT c )
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * The wctob() function shall determine whether c corresponds to a member of the
         * extended character set whose character representation is a single byte when in
         * the initial shift state.
         */
        REQ("wctob.01", "", TODO_REQ());

        /*
         * The behavior of this function shall be affected by the LC_CTYPE category of the
         * current locale.
         */
        REQ("wctob.02", "", TODO_REQ());

        /*
         * The wctob() function shall return EOF if c does not correspond to a character
         * with length one in the initial shift state.
         */
        REQ("wctob.03", "", TODO_REQ());

        /*
         * Otherwise, it shall return the single-byte representation of that character as
         * an unsigned char converted to int.
         */
        REQ("wctob.04", "", TODO_REQ());
        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wctomb - convert a wide-character code to a character

SYNOPSIS

    #include <stdlib.h>

    int wctomb(char *s, wchar_t wchar);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The wctomb() function shall determine the number of bytes needed to represent
the character corresponding to the wide-character code whose value is wchar (
including any change in the shift state). It shall store the character
representation (possibly multiple bytes and any special bytes to change shift
state) in the array object pointed to by s (if s is not a null pointer). At
most {MB_CUR_MAX} bytes shall be stored. If wchar is 0, a null byte shall be
stored, preceded by any shift sequence needed to restore the initial shift
state, and wctomb() shall be left in the initial shift state.

[CX] The behavior of this function is affected by the LC_CTYPE category of
the current locale. For a state-dependent encoding, this function shall be
placed into its initial state by a call for which its character pointer
argument, s, is a null pointer. Subsequent calls with s as other than a null
pointer shall cause the internal state of the function to be altered as
necessary. A call with s as a null pointer shall cause this function to return
a non-zero value if encodings have state dependency, and 0 otherwise.
Changing the LC_CTYPE category causes the shift state of this function to be
unspecified.

The wctomb() function need not be reentrant. A function that is not required to
be reentrant is not required to be thread-safe.

The implementation shall behave as if no function defined in this volume of
IEEE Std 1003.1-2001 calls wctomb().

RETURN VALUE

If s is a null pointer, wctomb() shall return a non-zero or 0 value, if
character encodings, respectively, do or do not have state-dependent encodings.
If s is not a null pointer, wctomb() shall return -1 if the value of wchar
does not correspond to a valid character, or return the number of bytes that
constitute the character corresponding to the value of wchar.

In no case shall the value returned be greater than the value of the {
MB_CUR_MAX} macro.

ERRORS

    No errors are defined.
*/

specification
IntT wctomb_spec( CallContext context, StringTPtr* s, WCharT wchar )
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * The wctomb() function shall determine the
         * number of bytes needed to represent
         * the character corresponding to the
         * wide-character code whose value is wchar
         * (including any change in the shift state).
         */
        REQ("wctomb.01", "", TODO_REQ());

        /*
         * It shall store the character representation
         * (possibly multiple bytes and any
         * special bytes to change shift state) in
         * the array object pointed to by s
         */
        REQ("wctomb.02", "", TODO_REQ());

        /*
         * (if s is not a null pointer)
         */
        REQ("wctomb.03", "", TODO_REQ());

        /*
         * At most {MB_CUR_MAX} bytes shall be stored.
         */
        REQ("wctomb.04", "", TODO_REQ());

        /*
         * If wchar is 0, a null byte shall be
         * stored, preceded by any shift sequence
         * needed to restore the initial shift
         * state, and wctomb() shall be left in the
         * initial shift state.
         */
        REQ("wctomb.05", "", TODO_REQ());

        /*
         * The behavior of this function is affected
         * by the LC_CTYPE category of the
         * current locale.
         */
        REQ("wctomb.06", "", TODO_REQ());

        /*
         * For a state-dependent encoding, this
         * function shall be placed into its initial
         * state by a call for which its character
         * pointer argument, s, is a null pointer.
         */
        REQ("wctomb.07", "", TODO_REQ());

        /*
         * Subsequent calls with s as other than
         * a null pointer shall cause the internal
         * state of the function to be altered as necessary.
         */
        REQ("wctomb.08", "", TODO_REQ());

        /*
         * A call with s as a null pointer shall
         * cause this function to return a non-zero
         * value if encodings have state
         * dependency, and 0 otherwise.
         */
        REQ("wctomb.09", "", TODO_REQ());

        /*
         * Changing the LC_CTYPE category causes
         * the shift state of this function to be
         * unspecified.
         */
        REQ("wctomb.10", "", TODO_REQ());

        /*
         * The wctomb() function need not be
         * reentrant. A function that is not required to
         * be reentrant is not required to be thread-safe.
         */
        REQ("wctomb.11", "", TODO_REQ());

        /*
         * The implementation shall behave as if
         * no function defined in this volume of
         * IEEE Std 1003.1-2001 calls wctomb().
         */
        REQ("wctomb.12", "", TODO_REQ());

        /*
         * If s is a null pointer, wctomb() shall
         * return a non-zero or 0 value, if
         * character encodings, respectively,
         * do or do not have state-dependent encodings.
         */
        REQ("wctomb.13", "", TODO_REQ());

        /*
         * If s is not a null pointer, wctomb()
         * shall return -1 if the value of wchar
         * does not correspond to a valid character,
         */
        REQ("wctomb.14", "", TODO_REQ());

        /*
         * or return the number of bytes that
         * constitute the character corresponding to
         * the value of wchar.
         */
        REQ("wctomb.15", "", TODO_REQ());

        /*
         * In no case shall the value returned
         * be greater than the value of the {
         * MB_CUR_MAX} macro.
         */
        REQ("wctomb.16", "", TODO_REQ());

        return true;
    }
}



/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

specification typedef struct Mbstate Mbstate={};

Mbstate*  create_Mbstate(IntT c, LongT v)
{
    return create(&type_Mbstate, c, v);
}
