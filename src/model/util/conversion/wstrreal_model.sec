/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "util/conversion/wstrreal_model.seh"
#include "util/conversion/wstrreal_config.h"

#pragma SEC subsystem conversion "util.conversion"



/*
   The group of functions 'util.conversion.wstrreal' consists of:
       __wcstod_internal [1]
       __wcstof_internal [1]
       __wcstold_internal [1]
       wcstod [2]
       wcstof [2]
       wcstold [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------
NAME

    wcstod, wcstof, wcstold - convert a wide-character string to a double-precision
    number

SYNOPSIS

    #include <wchar.h>

    double wcstod(const wchar_t *restrict nptr, wchar_t **restrict endptr);

    float wcstof(const wchar_t *restrict nptr, wchar_t **restrict endptr);

    long double wcstold(const wchar_t *restrict nptr, wchar_t **restrict endptr);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. These functions shall convert the initial portion of the wide-
    character string pointed to by nptr to double, float, and long double
    representation, respectively.

    First, they shall decompose the input wide-character string into three parts:

        * An initial, possibly empty, sequence of white-space wide-character codes (as
        specified by iswspace())

        * A subject sequence interpreted as a floating-point constant or representing
        infinity or NaN

        * A final wide-character string of one or more unrecognized wide-character
        codes, including the terminating null wide-character code of the input wide-
        character string

    Then they shall attempt to convert the subject sequence to a floating-point
    number, and return the result.

    The expected form of the subject sequence is an optional plus or minus sign,
    then one of the following: * A non-empty sequence of decimal digits optionally
    containing a radix character, then an optional exponent part

        * A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally
        containing a radix character, then an optional binary exponent part

        * One of INF or INFINITY, or any other wide string equivalent except for case

        * One of NAN or NAN(n-wchar-sequenceopt), or any other wide string ignoring
        case in the NAN part, where:

    n-wchar-sequence: digit nondigit n-wchar-sequence digit n-wchar-sequence
    nondigit

    The subject sequence is defined as the longest initial subsequence of the input
    wide string, starting with the first non-white-space wide character, that is of
    the expected form. The subject sequence contains no wide characters if the
    input wide string is not of the expected form.

    If the subject sequence has the expected form for a floating-point number, the
    sequence of wide characters starting with the first digit or the radix
    character (whichever occurs first) shall be interpreted as a floating constant
    according to the rules of the C language, except that the radix character shall
    be used in place of a period, and that if neither an exponent part nor a radix
    character appears in a decimal floating-point number, or if a binary exponent
    part does not appear in a hexadecimal floating-point number, an exponent part
    of the appropriate type with value zero shall be assumed to follow the last
    digit in the string. If the subject sequence begins with a minus sign, the
    sequence shall be interpreted as negated. A wide-character sequence INF or
    INFINITY shall be interpreted as an infinity, if representable in the return
    type, else as if it were a floating constant that is too large for the range of
    the return type. A wide-character sequence NAN or NAN(n-wchar-sequenceopt)
    shall be interpreted as a quiet NaN, if supported in the return type, else as
    if it were a subject sequence part that does not have the expected form; the
    meaning of the n-wchar sequences is implementation-defined. A pointer to the
    final wide string shall be stored in the object pointed to by endptr, provided
    that endptr is not a null pointer.

    If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2,
    the conversion shall be rounded in an implementation-defined manner.

    [CX] The radix character shall be as defined in the program's locale (category
    LC_NUMERIC ). In the POSIX locale, or in a locale where the radix character is
    not defined, the radix character shall default to a period ( '.' ).

    In other than the C [CX] or POSIX locales, other implementation-defined subject
    sequences may be accepted.

    If the subject sequence is empty or does not have the expected form, no
    conversion shall be performed; the value of nptr shall be stored in the object
    pointed to by endptr, provided that endptr is not a null pointer.

    [CX] The wcstod() function shall not change the setting of errno if successful.

    Since 0 is returned on error and is also a valid return on success, an
    application wishing to check for error situations should set errno to 0, then
    call wcstod(), wcstof(), or wcstold(), then check errno.

RETURN VALUE

    Upon successful completion, these functions shall return the converted value.
    If no conversion could be performed, 0 shall be returned [CX] and errno may be
    set to [EINVAL].

    If the correct value is outside the range of representable values, �HUGE_VAL, �
    HUGE_VALF, or �HUGE_VALL shall be returned (according to the sign of the
    value), and errno shall be set to [ERANGE].

    If the correct value would cause underflow, a value whose magnitude is no
    greater than the smallest normalized positive number in the return type shall
    be returned and errno set to [ERANGE].

ERRORS

    The wcstod() function shall fail if:

        [ERANGE] The value to be returned would cause overflow or underflow.

    The wcstod() function may fail if:

        [EINVAL] [CX] No conversion could be performed.
*/

/** __wcstod_internal_spec **/
//This specification refers to: __wcstof_internal, __wcstod_internal, __wcstold_internal
specification
Unifloat * __wcstod_internal_spec
               ( CallContext context, WString * st, WString ** endptr, UnifloatType type, ErrorCode * errno, IntT group )
{
    char filter[3][50] = {"__wcstod_internal",
                        "__wcstof_internal",
                        "__wcstold_internal"};

    FILTER(filter[type]);

    pre
    {
        /* [endpt should be not NULL] */
        REQ("", "endpt should be not NULL", endptr != NULL);

        /*
         * group shall be 0 or the behavior of __wcstod_internal() is undefined.
         *
         * group shall be 0 or the behavior of __wcstof_internal() is undefined.
         *
         * group shall be 0 or the behavior of __wcstold_internal() is undefined.
         */
        REQ( "app.__wcstod_internal.30;app.__wcstof_internal.30;app.__wcstold_internal.30",
             "__group shall be 0 or the behavior of __wcsto(d|f|ul)_internal() is undefined", group == 0
           );

        return true;
    }
    post
    {
        WString* model_endptr;
        IntT model_err = 0;
        Unifloat* model_res = wcstod_model(st, &model_endptr, type, &model_err);
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        if (model_err == 0)
        {
            traceExtraProperty( "expected result", model_res );
            traceExtraProperty( "expected endptr", model_endptr );
        }

        round_Unifloat(__wcstod_internal_spec, mant[type]);
        round_Unifloat(model_res, mant[type]);

        if (model_err == 1)
        {
            /*
             * If the subject sequence is empty or does not have the expected
             * form, no conversion shall be performed; the value of nptr shall
             * be stored in the object pointed to by endptr, provided that
             * endptr is not a null pointer.
             */
            REQ("__wcstod_internal.wcstod.13;__wcstof_internal.wcstof.13;"
                "__wcstold_internal.wcstold.13",
                "If no convertion is performed, the value of nptr shall be"
                "stored in the object pointed to by endptr",
                equals(st, *endptr));
        }

        if (model_err == 0)
        {
            /*
             * [CX] The wcstod() function shall not change the setting of
             * errno if successful.
             */
            REQ("__wcstod_internal.wcstod.14;__wcstof_internal.wcstof.14;"
                "__wcstold_internal.wcstold.14",
                "It shall not change the setting of errno if successful",
                *errno == 0);
        }

        if (*errno == SUT_EINVAL)
        {
            /*
             * Upon successful completion, these functions shall return the
             * converted value. If no conversion could be performed, 0 shall be
             * returned [CX] and errno may be set to [EINVAL].
             */
            REQ("__wcstod_internal.wcstod.15;__wcstof_internal.wcstof.15;"
                "__wcstold_internal.wcstold.15",
                "If no conversion could be performed, 0 shall be returned",
                isZero_Unifloat(__wcstod_internal_spec));
        }

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct value is outside the range of representable
             * values, �HUGE_VAL, �HUGE_VALF, or �HUGE_VALL shall be returned
             * (according to the sign of the value), and errno shall be set
             * to [ERANGE].
             */
            REQ("__wcstod_internal.wcstod.16;__wcstof_internal.wcstof.16;"
                "__wcstold_internal.wcstold.16",
                "If the correct value is outside the range of representable "
                "values, �HUGE_VAL shall be returned",
                isInfinity_Unifloat(__wcstod_internal_spec));
        }

        if (isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct value would cause underflow, a value whose
             * magnitude is no greater than the smallest normalized positive
             * number in the return type shall be returned and errno set
             * to [ERANGE].
             */

            print_WString(st);
            printExp_Unifloat(min_Unifloat(type), PRECISION);
            printExp_Unifloat(__wcstod_internal_spec, PRECISION);

            REQ("__wcstod_internal.wcstod.17;__wcstof_internal.wcstof.17;"
                "__wcstold_internal.wcstold.17",
                "If the correct value would cause underflow, the smallest"
                " normalized positive number shall be returned",
                (compare_Unifloat(abs_Unifloat(__wcstod_internal_spec), min_Unifloat(type)) != 1) &&
                (__wcstod_internal_spec->sign == 1));
        }

        /*
         * The wcstod() function shall fail if:
         *
         * [ERANGE] The value to be returned would cause overflow
         * or underflow.
         *
         * The wcstod() function may fail if:
         *
         * [EINVAL]
         * [CX] No conversion could be performed.
         */
        ERROR_BEGIN(LSB___WCSTOD_INTERNAL,
            "__wcstod_internal.wcstod.18.01;__wcstof_internal.wcstof.18.01;"
            "__wcstold_internal.wcstold.18.01;"
            "__wcstod_internal.wcstod.19.01;__wcstof_internal.wcstof.19.01;"
            "__wcstold_internal.wcstold.19.01",
            *errno, *errno)

            /*
             * The wcstod() function shall fail if:
             *
             * [ERANGE] The value to be returned would cause overflow
             * or underflow.
             */
            ERROR_SHALL(LSB___WCSTOD_INTERNAL, ERANGE,
            "__wcstod_internal.wcstod.18.01;__wcstof_internal.wcstof.18.01;"
            "__wcstold_internal.wcstold.18.01",
            isOverflow_Unifloat(model_res) || isUnderflow_Unifloat(model_res))

            /*
             * The wcstod() function may fail if:
             *
             * [EINVAL]
             * [CX] No conversion could be performed.
             */
            ERROR_MAY(LSB___WCSTOD_INTERNAL, EINVAL,
            "__wcstod_internal.wcstod.19.01;__wcstof_internal.wcstof.19.01;"
            "__wcstold_internal.wcstold.19.01", model_err == 1)

        ERROR_END()

        if (!isOverflow_Unifloat(model_res) &&
            !isUnderflow_Unifloat(model_res))
        {
            /*
             * These functions shall convert the initial portion of the wide-
             * character string pointed to by nptr to double, float, and long
             * double representation, respectively.
             *
             * Then they shall attempt to convert the subject sequence to a
             * floating-point number, and return the result.
             */
            REQ("__wcstod_internal.wcstod.01.01;__wcstof_internal.wcstof.01.01;"
                "__wcstold_internal.wcstold.01.01",
                "It shall attempt to convert the subject sequence to a "
                " floating-point number, and return the result",
                compareWithPrecision_Unifloat(model_res, __wcstod_internal_spec, mant[type]) == 0);
        }

        /*
         * A pointer to the final wide string shall be stored in the object
         * pointed to by endptr, provided that endptr is not a null pointer.
         */
        REQ("__wcstod_internal.wcstod.11;__wcstof_internal.wcstof.11;"
            "__wcstold_internal.wcstold.11",
            "A pointer to the final wide string shall be stored in the object"
            " pointed to by endptr",
            equals(*endptr, model_endptr));

        /*
         * __wcstod_internal(nptr, endptr, 0) shall behave as wcstod(nptr, endptr) as
         * specified by ISO POSIX (2003).
         *
         * __wcstof_internal(nptr, endptr, 0) shall behave as wcstof(nptr, endptr) as
         * specified in ISO POSIX (2003).
         *
         * __wcstold_internal(nptr, endptr, 0) shall behave as wcstold(nptr, endptr) as
         * specified by ISO POSIX (2003).
         */
        REQ( "__wcstod_internal.30;app.__wcstof_internal.30;__wcstold_internal.30",
             "__wcsto(d|f|ld)_internal(nptr, endptr, 0) shall behave as wcsto(d|f|ld)(nptr, endptr)", true
           );

        return true;
    }
    FILTER_CLEAN;
}

/** wcstod_spec **/
//This specification refers to: wcstof, wcstod, wcstold
specification
Unifloat* wcstod_spec(CallContext context, WString* st, WString** endptr,
                      UnifloatType type, ErrorCode* errno)
{
    char filter[3][50] = {"wcstod", "wcstof", "wcstold"};

    FILTER(filter[type]);

    pre
    {
        /* [endpt should be not NULL] */
        REQ("", "endpt should be not NULL", endptr != NULL);

        return true;
    }
    post
    {
        WString* model_endptr;
        IntT model_err = 0;
        Unifloat* model_res = wcstod_model(st, &model_endptr, type, &model_err);
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        if (model_err == 0)
        {
            traceExtraProperty( "expected result", model_res );
            traceExtraProperty( "expected endptr", model_endptr );
        }

        round_Unifloat(wcstod_spec, mant[type]);
        round_Unifloat(model_res, mant[type]);

        if (model_err == 1)
        {
            /*
             * If the subject sequence is empty or does not have the expected
             * form, no conversion shall be performed; the value of nptr shall
             * be stored in the object pointed to by endptr, provided that
             * endptr is not a null pointer.
             */
            REQ("wcstod.13;wcstof.13;wcstold.13",
                "If no convertion is performed, the value of nptr shall be"
                "stored in the object pointed to by endptr",
                equals(st, *endptr));
        }

        if (*errno == SUT_EINVAL)
        {
            /*
             * Upon successful completion, these functions shall return the
             * converted value. If no conversion could be performed, 0 shall be
             * returned [CX] and errno may be set to [EINVAL].
             */
            REQ("wcstod.15;wcstof.15;wcstold.15",
                "If no conversion could be performed, 0 shall be returned",
                isZero_Unifloat(wcstod_spec));
        }

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct value is outside the range of representable
             * values, �HUGE_VAL, �HUGE_VALF, or �HUGE_VALL shall be returned
             * (according to the sign of the value), and errno shall be set
             * to [ERANGE].
             */
            REQ("wcstod.16;wcstof.16;wcstold.16",
                "If the correct value is outside the range of representable "
                "values, �HUGE_VAL shall be returned",
                isInfinity_Unifloat(wcstod_spec));
        }

        if (isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct value would cause underflow, a value whose
             * magnitude is no greater than the smallest normalized positive
             * number in the return type shall be returned and errno set
             * to [ERANGE].
             */
            REQ("wcstod.17;wcstof.17;wcstold.17",
                "If the correct value would cause underflow, the smallest"
                " normalized positive number shall be returned",
                (compare_Unifloat(abs_Unifloat(wcstod_spec), min_Unifloat(type)) != 1) &&
                (wcstod_spec->sign == 1));
        }

        if (model_err == 0)
        {
            /*
             * [CX] The wcstod() function shall not change the setting of
             * errno if successful.
             */
            REQ("wcstod.14;wcstof.14;wcstold.14",
                "It shall not change the setting of errno if successful",
                *errno == 0);
        }
        /*
         * The wcstod() function shall fail if:
         *
         * [ERANGE] The value to be returned would cause overflow
         * or underflow.
         *
         * The wcstod() function may fail if:
         *
         * [EINVAL] [CX] No conversion could be performed.
         */
        ERROR_BEGIN(POSIX_WCSTOD,
            "wcstod.18.01;wcstof.18.01;wcstold.18.01;"
            "wcstod.19.01;wcstof.19.01;wcstold.19.01",
            *errno, *errno)

            /*
             * The wcstod() function shall fail if:
             *
             * [ERANGE] The value to be returned would cause overflow
             * or underflow.
             */
            ERROR_SHALL(POSIX_WCSTOD, ERANGE,
            "wcstod.18.01;wcstof.18.01;wcstold.18.01",
            isOverflow_Unifloat(model_res) || isUnderflow_Unifloat(model_res))

            /*
             * The wcstod() function may fail if:
             *
             * [EINVAL]
             * [CX] No conversion could be performed.
             */
            ERROR_MAY(POSIX_WCSTOD, EINVAL,
            "wcstod.19.01;wcstof.19.01;wcstold.19.01", model_err == 1)

        ERROR_END()

        if (!isOverflow_Unifloat(model_res) &&
            !isUnderflow_Unifloat(model_res))
        {
            /*
             * These functions shall convert the initial portion of the wide-
             * character string pointed to by nptr to double, float, and long
             * double representation, respectively.
             *
             * Then they shall attempt to convert the subject sequence to a
             * floating-point number, and return the result.
             */
            REQ("wcstod.01.01;wcstof.01.01;wcstold.01.01",
                "It shall attempt to convert the subject sequence to a "
                " floating-point number, and return the result",
                compareWithPrecision_Unifloat(model_res, wcstod_spec, mant[type]) == 0);
        }

        /*
         * A pointer to the final wide string shall be stored in the object
         * pointed to by endptr, provided that endptr is not a null pointer.
         */
        REQ("wcstod.11;wcstof.11;wcstold.11",
            "A pointer to the final wide string shall be stored in the object"
            " pointed to by endptr", equals(*endptr, model_endptr));

        return true;
    }
    FILTER_CLEAN;
}

Unifloat* wcstod_model(WString* st, WString** endptr, UnifloatType type, IntT* err)
{
    Unifloat* res = createZero_Unifloat(type);
    WString* number = clone(st);
    WString* subst;
    IntT i, sign = 1, j, k;
    IntT point_position, exp_position;
    WCharT c;

    *err = 0;
   /*
     * First, they shall decompose the input wide-character string into
     * three parts:
     * * An initial, possibly empty, sequence of white-space wide-
     * character codes (as specified by iswspace())
     * * A subject sequence interpreted as a floating-point constant or
     * representing infinity or NaN
     * * A final wide-character string of one or more unrecognized wide-
     * character codes, including the terminating null wide-character code
     * of the input wide-character string
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.02;__wcstof_internal.wcstof.02;"
        "__wcstold_internal.wcstold.02;wcstod.02;wcstof.02;wcstold.02");
    // delete wite-space characters
    for (i = 0; (i < length_WString(st)) && (wcharAt_WString(st, i) <= 32); i++);
    if (i != 0)
        number = substring_WString(st, i, length_WString(st));
    /*
     * If the subject sequence begins with a minus sign, the sequence
     * shall be interpreted as negated.
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.08;__wcstof_internal.wcstof.08;"
        "__wcstold_internal.wcstold.08;wcstod.08;wcstof.08;wcstold.08");

    // determination of number's sign
    if (wcharAt_WString(number, 0) == '-')
    {
        sign = -1;
        i++;
        number = substring_WString(number, 1, length_WString(number));
    }

    number = toLowerCase_WString(number);

    /*
     * The expected form of the subject sequence is an optional plus or
     * minus sign, then one of the following: * A non-empty sequence of
     * decimal digits optionally containing a radix character, then an
     * optional exponent part:
     * * A 0x or 0X, then a non-empty sequence of hexadecimal digits
     * optionally containing a radix character, then an optional binary
     * exponent part
     * * One of INF or INFINITY, or any other wide string equivalent
     * except for case
     * * One of NAN or NAN(n-wchar-sequenceopt), or any other wide string
     * ignoring case in the NAN part, where:
     * n-wchar-sequence:
     *            digit
     *         nondigit
     * n-wchar-sequence digit
     * n-wchar-sequence nondigit
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.03;__wcstof_internal.wcstof.03;"
        "__wcstold_internal.wcstold.03;wcstod.03;wcstof.03;wcstold.03");
    /*
     * A wide-character sequence INF or INFINITY shall be interpreted as
     * an infinity, if representable in the return type, else as if it
     * were a floating constant that is too large for the range of the
     * return type.
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.09;__wcstof_internal.wcstof.09;"
        "__wcstold_internal.wcstold.09;wcstod.09;wcstof.09;wcstold.09");
    // search infinity
    if (length_WString(number) >= 3)
    if (equals(substring_WString(number, 0, 3), createFromCharArray_WString("inf")))
    {
        i += 3;
        if (length_WString(number) >= 8)
            if (equals(substring_WString(number, 0, 8), createFromCharArray_WString("infinity")))
                i += 5;
        res = clone(infinity_Unifloat(type));
        res->sign = sign;
        *endptr = substring_WString(st, i, length_WString(st));
        return res;
    }
    /*
     * A wide-character sequence NAN or NAN(n-wchar-sequenceopt) shall be
     * interpreted as a quiet NaN, if supported in the return type, else
     * as if it were a subject sequence part that does not have the
     * expected form;
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.10;__wcstof_internal.wcstof.10;"
        "__wcstold_internal.wcstold.10;wcstod.10;wcstof.10;wcstold.10");
    // search NaN
    if (length_WString(number) >= 3)
    if (equals(substring_WString(number, 0, 3), createFromCharArray_WString("nan")))
    {
        i += 3;
        if (length_WString(number) > 3)
            if (wcharAt_WString(number, 3) == '(')
            {
                for (j = 4; j < length_WString(number) && (wcharAt_WString(number, j) != ')'); j++);
                if (j < length_WString(number))
                    if (wcharAt_WString(number, j) == ')')
                    {
                        for (k = 4; k < j; k++)
                        {
                            c = wcharAt_WString(number, k);
                            if (!((c >= 48) && (c <= 57)) && !((c >= 97) && (c <= 122)))
                                break;
                        }
                        if (k == j)
                            i += j - 3 + 1;
                    }
            }
        res = clone(nan_Unifloat(type));
        *endptr = substring_WString(st, i, length_WString(st));
        return res;
    }
    /*
     * These functions shall convert the initial portion of the wide-
     * character string pointed to by nptr to double, float, and long
     * double representation, respectively.
     *
     * If the subject sequence has the hexadecimal form and FLT_RADIX is a
     * power of 2, the conversion shall be rounded in an
     * implementation-defined manner.
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.01.02;__wcstof_internal.wcstof.01.02;"
        "__wcstold_internal.wcstold.01.02;wcstod.01.02;wcstof.01.02;wcstold.01.02");
    // search hexadecimal
    if (length_WString(number) > 2)
    if (equals(substring_WString(number, 0, 2), createFromCharArray_WString("0x")))
    {
        i += 2;
        for (j = 2; j< length_WString(number); j++)
        {
            c = wcharAt_WString(number, j);
            if (!( ((c >=48) && (c <= 57)) || ((c >= 97) && (c <= 102)) ))
                break;
        }
        res = convertHexString_Unifloat(convertWString_String(substring_WString(number, 2, j)), type);
        *endptr = substring_WString(st, i + j - 2, length_WString(st));
        res->sign = sign;
        return res;
    }
    /*
     * The subject sequence is defined as the longest initial subsequence
     * of the input wide string, starting with the first non-white-space
     * wide character, that is of the expected form.
     */
    /*
     * and that if neither an exponent part nor a radix character appears
     * in a decimal floating-point number, or if a binary exponent part
     * does not appear in a hexadecimal floating-point number, an
     * exponent part of the appropriate type with value zero shall be
     * assumed to follow the last digit in the string.
     */
    /*
     * [CX] The radix character shall be as defined in the program's
     * locale (category LC_NUMERIC ). In the POSIX locale, or in a locale
     * where the radix character is not defined, the radix character
     * shall default to a period ( '.' ).
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.04;__wcstof_internal.wcstof.04;"
        "__wcstold_internal.wcstold.04;__wcstod_internal.wcstod.07;"
        "__wcstof_internal.wcstof.07;__wcstold_internal.wcstold.07;"
        "__wcstod_internal.wcstod.12;__wcstof_internal.wcstof.12;"
        "__wcstold_internal.wcstold.12;wcstod.04;wcstof.04;wcstold.04;"
        "wcstod.07;wcstof.07;wcstold.07;wcstod.12;wcstof.12;wcstold.12");
    // search decimal float-point number
    point_position = -1;
    exp_position = -1;
    for (j = 0; j < length_WString(number); j++)
    {
        c = wcharAt_WString(number, j);
        if (c == '.')
            if (point_position != -1)
                break;
            else
                point_position = j;
        if (c == 'e')
            if (exp_position != -1)
                break;
            else
                exp_position = j;
        if ((c == '-') && (exp_position != j - 1))
            break;
        if ((c != '.') && (c != 'e') && (c != '-') && !((c >= 48) && (c <= 57)))
            break;
    }

    if (exp_position != -1)
    {
        for (k = exp_position + 1; k < j; k++)
        {
            c = wcharAt_WString(number, k);
            if ((c >= 48) && (c <=57))
                break;
        }

        if (k >= j) j = exp_position;
        if (point_position > exp_position)
            j = point_position;
    }

    i += j;

    number = substring_WString(number, 0, j);

    /*
     * The subject sequence contains no wide characters if the input wide
     * string is not of the expected form.
     */
    IMPLEMENT_REQ("__wcstod_internal.wcstod.05;__wcstof_internal.wcstof.05;"
        "__wcstold_internal.wcstold.05;wcstod.05;wcstof.05;wcstold.05");
    if ((length_WString(number) == 0) ||
        equals(number, createFromCharArray_WString(".")) ||
        equals(number, createFromCharArray_WString("-")) ||
        (exp_position == 0) )
    {
        *err = 1;
        i = 0;
    }
    else
    {
        res = convertString_Unifloat(convertWString_String(number), type);
        res->sign = sign;
    }

    if (isOverflow_Unifloat(res) || isUnderflow_Unifloat(res))
        *err = 2;

    *endptr = substring_WString(st, i, length_WString(st));

    return res;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
void print_WString(WString* st)
{
    WString *c;
    IntT i;
    for (i = 0; i<length_WString(st); i++)
    {
        c = substring_WString(st, i, i+1);
        verbose("%s", toWCharArray_WString(c));
    }
    verbose("\n");
}

WString* toLowerCase_WString(WString* st)
{
    WString* res = clone(st);
    IntT i;
    for (i = 0; i < length_WString(res); i++)
        if ((res->data[i] >=65) && (res->data[i] <= 90))
            res->data[i] = res->data[i] + 32;
    return res;
}

CString* convertWString_String(WString* st)
{
    CString* res = create_CString("");
    IntT i;
    WCharT c;
    IntT len = length_WString(st);
    for (i = 0; i < len; i++)
    {
        c = wcharAt_WString(st, i);
        if ( c < 256)
            res = concat_CString(res, format_CString("%c",(CharT)c));
    }
    return res;
}
