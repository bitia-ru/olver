/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "util/conversion/strreal_model.seh"
#include "util/conversion/strreal_config.h"
#include <math.h>

#pragma SEC subsystem conversion "util.conversion"



/* 
   The group of functions 'util.conversion.strreal' consists of: 
       __strtod_internal [1]
       __strtof_internal [1]
       __strtold_internal [1]
       atof [1]
       fcvt [1]
       fcvt [1]
       gcvt [1]
       strtod [1]
       strtof [2]
       strtold [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright � 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    strtod, strtof, strtold - convert a string to a double-precision number

SYNOPSIS

    #include <stdlib.h>

    double strtod(const char *restrict nptr, char **restrict endptr);
    float strtof(const char *restrict nptr, char **restrict endptr);
    long double strtold(const char *restrict nptr, char **restrict endptr);


DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with 
    the ISO C standard. Any conflict between the requirements described here 
    and the ISO C standard is unintentional. This volume of IEEE Std 
    1003.1-2001 defers to the ISO C standard. 

    These functions shall convert the initial portion of the string pointed to 
    by nptr to double, float, and long double representation, respectively. 
    First, they decompose the input string into three parts:

    An initial, possibly empty, sequence of white-space characters 
    (as specified by isspace())

    A subject sequence interpreted as a floating-point constant or representing
    infinity or NaN

    A final string of one or more unrecognized characters, including the 
    terminating null byte of the input string

    Then they shall attempt to convert the subject sequence to a floating-point
    number, and return the result.

    The expected form of the subject sequence is an optional plus or minus 
    sign, then one of the following:

    A non-empty sequence of decimal digits optionally containing a radix 
    character, then an optional exponent part

    A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally 
    containing a radix character, then an optional binary exponent part

    One of INF or INFINITY, ignoring case

    One of NAN or NAN(n-char-sequenceopt), ignoring case in the NAN part, 
    where:

        n-char-sequence:
        digit
        nondigit
        n-char-sequence digit
        n-char-sequence nondigit

    The subject sequence is defined as the longest initial subsequence of the 
    input string, starting with the first non-white-space character, that is of
    the expected form. The subject sequence contains no characters if the input
    string is not of the expected form.

    If the subject sequence has the expected form for a floating-point number, 
    the sequence of characters starting with the first digit or the 
    decimal-point character (whichever occurs first) shall be interpreted as a 
    floating constant of the C language, except that the radix character shall 
    be used in place of a period, and that if neither an exponent part nor a 
    radix character appears in a decimal floating-point number, or if a binary
    exponent part does not appear in a hexadecimal floating-point number, an 
    exponent part of the appropriate type with value zero is assumed to follow 
    the last digit in the string. If the subject sequence begins with a minus 
    sign, the sequence shall be interpreted as negated. A character sequence 
    INF or INFINITY shall be interpreted as an infinity, if representable in 
    the return type, else as if it were a floating constant that is too large 
    for the range of the return type. A character sequence NAN or NAN
    (n-char-sequenceopt) shall be interpreted as a quiet NaN, if supported in 
    the return type, else as if it were a subject sequence part that does not 
    have the expected form; the meaning of the n-char sequences is 
    implementation-defined. A pointer to the final string is stored in the 
    object pointed to by endptr, provided that endptr is not a null pointer.

    If the subject sequence has the hexadecimal form and FLT_RADIX is a power 
    of 2, the value resulting from the conversion is correctly rounded.

    [CX]  The radix character is defined in the program's locale (category 
    LC_NUMERIC ). In the POSIX locale, or in a locale where the radix character
    is not defined, the radix character shall default to a period ( '.' ). 

    In other than the C [CX]   or POSIX  locales, other implementation-defined 
    subject sequences may be accepted.

    If the subject sequence is empty or does not have the expected form, no 
    conversion shall be performed; the value of str is stored in the object 
    pointed to by endptr, provided that endptr is not a null pointer.

    [CX]  The strtod() function shall not change the setting of errno if 
    successful.

    Since 0 is returned on error and is also a valid return on success, an 
    application wishing to check for error situations should set errno to 0, 
    then call strtod(), strtof(), or strtold(), then check errno. 

RETURN VALUE
    Upon successful completion, these functions shall return the converted 
    value. If no conversion could be performed, 0 shall be returned, and errno 
    may be set to [EINVAL].

    If the correct value is outside the range of representable values, 
    �HUGE_VAL, �HUGE_VALF, or �HUGE_VALL shall be returned (according to the 
     sign of the value), and errno shall be set to [ERANGE].

    If the correct value would cause an underflow, a value whose magnitude is 
    no greater than the smallest normalized positive number in the return type
    shall be returned and errno set to [ERANGE].

ERRORS
    These functions shall fail if:

    [ERANGE] 
    The value to be returned would cause overflow [CX]   or underflow.  
    These functions may fail if:

    [EINVAL] 
    [CX]  No conversion could be performed.  

*/

specification
Unifloat* __strtod_internal_spec(CallContext context, CString* st,
                                 CString** endptr, UnifloatType type,
                                 ErrorCode* errno)
{
    char filter[3][50] = {"__strtod_internal",
                        "__strtof_internal",
                        "__strtold_internal"};

    FILTER(filter[type]);

    pre
    {
        /* [endpt should be not NULL] */
        REQ("", "endpt should be not NULL", endptr != NULL);

        return true;
    }
    post
    {
        CString* model_endptr;
        IntT model_err = 0;
        Unifloat* model_res = strtod_model(st, &model_endptr, type, &model_err);
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        if (model_err == 0)
        {
            traceExtraProperty( "expected result", model_res );
            traceExtraProperty( "expected endptr", model_endptr );
        }

        round_Unifloat(__strtod_internal_spec, mant[type]);
        round_Unifloat(model_res, mant[type]);

        if (model_err == 1)
        {
            /*
             * If the subject sequence is empty or does not have the expected
             * form, no conversion shall be performed; the value of nptr shall
             * be stored in the object pointed to by endptr, provided that
             * endptr is not a null pointer.
             */
            REQ("__strtod_internal.strtod.13;__strtof_internal.strtof.13;"
                "__strtold_internal.strtold.13",
                "If no convertion is performed, the value of nptr shall be"
                "stored in the object pointed to by endptr",
                equals(st, *endptr));
        }

        if (model_err == 0)
        {
            /*
             * [CX] The strtod() function shall not change the setting of
             * errno if successful.
             */
            REQ("__strtod_internal.strtod.14;__strtof_internal.strtof.14;"
                "__strtold_internal.strtold.14",
                "It shall not change the setting of errno if successful",
                *errno == 0);
        }

        if (*errno == SUT_EINVAL)
        {
            /*
             * Upon successful completion, these functions shall return the
             * converted value. If no conversion could be performed, 0 shall be
             * returned [CX] and errno may be set to [EINVAL].
             */
            REQ("__strtod_internal.strtod.15;__strtof_internal.strtof.15;"
                "__strtold_internal.strtold.15",
                "If no conversion could be performed, 0 shall be returned",
                isZero_Unifloat(__strtod_internal_spec));
        }

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct value is outside the range of representable
             * values, �HUGE_VAL, �HUGE_VALF, or �HUGE_VALL shall be returned
             * (according to the sign of the value), and errno shall be set
             * to [ERANGE].
             */
            REQ("__strtod_internal.strtod.16;__strtof_internal.strtof.16;"
                "__strtold_internal.strtold.16",
                "If the correct value is outside the range of representable "
                "values, �HUGE_VAL shall be returned",
                isInfinity_Unifloat(__strtod_internal_spec));
        }

        if (isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct value would cause underflow, a value whose
             * magnitude is no greater than the smallest normalized positive
             * number in the return type shall be returned and errno set
             * to [ERANGE].
             */

            printExp_Unifloat(min_Unifloat(type), PRECISION);
            printExp_Unifloat(__strtod_internal_spec, PRECISION);

            REQ("__strtod_internal.strtod.17;__strtof_internal.strtof.17;"
                "__strtold_internal.strtold.17",
                "If the correct value would cause underflow, the smallest"
                " normalized positive number shall be returned",
                (compare_Unifloat(abs_Unifloat(__strtod_internal_spec), min_Unifloat(type)) != 1) &&
                (__strtod_internal_spec->sign == 1));
        }

        /*
         * The strtod() function shall fail if:
         *
         * [ERANGE] The value to be returned would cause overflow
         * or underflow.
         *
         * The strtod() function may fail if:
         *
         * [EINVAL]
         * [CX] No conversion could be performed.
         */
        ERROR_BEGIN(LSB___STRTOD_INTERNAL,
            "__strtod_internal.strtod.18.01;__strtof_internal.strtof.18.01;"
            "__strtold_internal.strtold.18.01;"
            "__strtod_internal.strtod.19.01;__strtof_internal.strtof.19.01;"
            "__strtold_internal.strtold.19.01",
            *errno, *errno)

            /*
             * The strtod() function shall fail if:
             *
             * [ERANGE] The value to be returned would cause overflow
             * or underflow.
             */
            ERROR_SHALL(LSB___STRTOD_INTERNAL, ERANGE,
            "__strtod_internal.strtod.18.01;__strtof_internal.strtof.18.01;"
            "__strtold_internal.strtold.18.01",
            isOverflow_Unifloat(model_res) || isUnderflow_Unifloat(model_res))

            /*
             * The strtod() function may fail if:
             *
             * [EINVAL]
             * [CX] No conversion could be performed.
             */
            ERROR_MAY(LSB___STRTOD_INTERNAL, EINVAL,
            "__strtod_internal.strtod.19.01;__strtof_internal.strtof.19.01;"
            "__strtold_internal.strtold.19.01", model_err == 1)

        ERROR_END()

        if (!isOverflow_Unifloat(model_res) &&
            !isUnderflow_Unifloat(model_res))
        {
            /*
             * These functions shall convert the initial portion of the 
             * character string pointed to by nptr to double, float, and long
             * double representation, respectively.
             *
             * Then they shall attempt to convert the subject sequence to a
             * floating-point number, and return the result.
             */
            REQ("__strtod_internal.strtod.01.01;__strtof_internal.strtof.01.01;"
                "__strtold_internal.strtold.01.01",
                "It shall attempt to convert the subject sequence to a "
                " floating-point number, and return the result",
                compareWithPrecision_Unifloat(model_res, __strtod_internal_spec, mant[type]) == 0);
        }

        /*
         * A pointer to the final wide string shall be stored in the object
         * pointed to by endptr, provided that endptr is not a null pointer.
         */
        REQ("__strtod_internal.strtod.11;__strtof_internal.strtof.11;"
            "__strtold_internal.strtold.11",
            "A pointer to the final wide string shall be stored in the object"
            " pointed to by endptr",
            equals(*endptr, model_endptr));

        return true;
    }
    FILTER_CLEAN;
}


/** strtod_spec **/
//This specification refers to: strtof, strtod, strtold
specification
Unifloat* strtod_spec(CallContext context, CString* st, CString** endptr,
                      UnifloatType type, ErrorCode* errno)
{
    char filter[3][50] = {"strtod", "strtof", "strtold"};

    FILTER(filter[type]);

    pre
    {
        /* [endpt should be not NULL] */
        REQ("", "endpt should be not NULL", endptr != NULL);

        return true;
    }
    post
    {
        CString* model_endptr;
        IntT model_err = 0;
        Unifloat* model_res = strtod_model(st, &model_endptr, type, &model_err);
        int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

        if (model_err == 0)
        {
            traceExtraProperty( "expected result", model_res );
            traceExtraProperty( "expected endptr", model_endptr );
        }

        round_Unifloat(strtod_spec, mant[type]);
        round_Unifloat(model_res, mant[type]);

        if (model_err == 1)
        {
            /*
             * If the subject sequence is empty or does not have the expected
             * form, no conversion shall be performed; the value of nptr shall
             * be stored in the object pointed to by endptr, provided that
             * endptr is not a null pointer.
             */
            REQ("strtod.13;strtof.13;strtold.13",
                "If no convertion is performed, the value of nptr shall be"
                "stored in the object pointed to by endptr",
                equals(st, *endptr));
        }

        if (*errno == SUT_EINVAL)
        {
            /*
             * Upon successful completion, these functions shall return the
             * converted value. If no conversion could be performed, 0 shall be
             * returned [CX] and errno may be set to [EINVAL].
             */
            REQ("strtod.15;strtof.15;strtold.15",
                "If no conversion could be performed, 0 shall be returned",
                isZero_Unifloat(strtod_spec));
        }

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct value is outside the range of representable
             * values, �HUGE_VAL, �HUGE_VALF, or �HUGE_VALL shall be returned
             * (according to the sign of the value), and errno shall be set
             * to [ERANGE].
             */
            REQ("strtod.16;strtof.16;strtold.16",
                "If the correct value is outside the range of representable "
                "values, �HUGE_VAL shall be returned",
                isInfinity_Unifloat(strtod_spec));
        }

        if (isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct value would cause underflow, a value whose
             * magnitude is no greater than the smallest normalized positive
             * number in the return type shall be returned and errno set
             * to [ERANGE].
             */
            REQ("strtod.17;strtof.17;strtold.17",
                "If the correct value would cause underflow, the smallest"
                " normalized positive number shall be returned",
                (compare_Unifloat(abs_Unifloat(strtod_spec), min_Unifloat(type)) != 1) &&
                (strtod_spec->sign == 1));
        }

        if (model_err == 0)
        {
            /*
             * [CX] The strtod() function shall not change the setting of
             * errno if successful.
             */
            REQ("strtod.14;strtof.14;strtold.14",
                "It shall not change the setting of errno if successful",
                *errno == 0);
        }
        /*
         * The strtod() function shall fail if:
         *
         * [ERANGE] The value to be returned would cause overflow
         * or underflow.
         *
         * The strtod() function may fail if:
         *
         * [EINVAL] [CX] No conversion could be performed.
         */
        ERROR_BEGIN(POSIX_STRTOD,
            "strtod.18.01;strtof.18.01;strtold.18.01;"
            "strtod.19.01;strtof.19.01;strtold.19.01",
            *errno, *errno)

            /*
             * The strtod() function shall fail if:
             *
             * [ERANGE] The value to be returned would cause overflow
             * or underflow.
             */
            ERROR_SHALL(POSIX_STRTOD, ERANGE,
            "strtod.18.01;strtof.18.01;strtold.18.01",
            isOverflow_Unifloat(model_res) || isUnderflow_Unifloat(model_res))

            /*
             * The strtod() function may fail if:
             *
             * [EINVAL]
             * [CX] No conversion could be performed.
             */
            ERROR_MAY(POSIX_STRTOD, EINVAL,
            "strtod.19.01;strtof.19.01;strtold.19.01", model_err == 1)

        ERROR_END()

        if (!isOverflow_Unifloat(model_res) &&
            !isUnderflow_Unifloat(model_res))
        {
            /*
             * These functions shall convert the initial portion of the wide-
             * character string pointed to by nptr to double, float, and long
             * double representation, respectively.
             *
             * Then they shall attempt to convert the subject sequence to a
             * floating-point number, and return the result.
             */
            REQ("strtod.01.01;strtof.01.01;strtold.01.01",
                "It shall attempt to convert the subject sequence to a "
                " floating-point number, and return the result",
                compareWithPrecision_Unifloat(model_res, strtod_spec, mant[type]) == 0);
        }

        /*
         * A pointer to the final string shall be stored in the object
         * pointed to by endptr, provided that endptr is not a null pointer.
         */
        REQ("strtod.11;strtof.11;strtold.11",
            "A pointer to the final string shall be stored in the object"
            " pointed to by endptr", equals(*endptr, model_endptr));

        return true;
    }
    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

atof - convert a string to a double-precision number

SYNOPSIS

#include <stdlib.h>

double atof(const char *str);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the ISO
C standard. Any conflict between the requirements described here and the ISO C
standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
ISO C standard. The call atof(str) shall be equivalent to:

strtod(str,(char **)NULL),

except that the handling of errors may differ. If the value cannot be
represented, the behavior is undefined.

RETURN VALUE

The atof() function shall return the converted value if the value can be
represented.

ERRORS

No errors are defined.
*/


/** atof_spec **/
//This specification refers to: atof
specification
Unifloat* atof_spec(CallContext context, CString* st,  
                    ErrorCode* errno)
{
CString* model_endptr;
UnifloatType type = 1;
IntT model_err = 0;
Unifloat* model_res = strtod_model(st, &model_endptr, type, &model_err);
int mant[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};

    pre
    {
        /*
         * If the value cannot be represented, the behavior is undefined.
         */
        REQ("app.atof.17", "", TODO_REQ());

        return true;
    }
    post
    {
        traceExtraProperty( "expected result", model_res );

        round_Unifloat(atof_spec, mant[type]);
        round_Unifloat(model_res, mant[type]);

        if (*errno == SUT_EINVAL)
        {
            /*
             * Upon successful completion, these functions shall return the
             * converted value. If no conversion could be performed, 0 shall be
             * returned [CX] and errno may be set to [EINVAL].
             */
            REQ("atof.strtod.13",
                "If no conversion could be performed, 0 shall be returned",
                isZero_Unifloat(atof_spec));
        }

        if (isOverflow_Unifloat(model_res))
        {
            /*
             * If the correct value is outside the range of representable
             * values, �HUGE_VAL, �HUGE_VALF, or �HUGE_VALL shall be returned
             * (according to the sign of the value), and errno shall be set
             * to [ERANGE].
             */
            REQ("atof.strtod.14",
                "If the correct value is outside the range of representable "
                "values, �HUGE_VAL shall be returned",
                isInfinity_Unifloat(atof_spec));
        }

        if (isUnderflow_Unifloat(model_res))
        {
            /*
             * If the correct value would cause underflow, a value whose
             * magnitude is no greater than the smallest normalized positive
             * number in the return type shall be returned and errno set
             * to [ERANGE].
             */
            REQ("atof.strtod.15",
                "If the correct value would cause underflow, the smallest"
                " normalized positive number shall be returned",
                (compare_Unifloat(abs_Unifloat(atof_spec), min_Unifloat(type)) != 1) &&
                (atof_spec->sign == 1));
        }

        if (model_err == 0)
        {
            /*
             * [CX] The strtod() function shall not change the setting of
             * errno if successful.
             */
            REQ("atof.strtod.12",
                "It shall not change the setting of errno if successful",
                *errno == 0);
        }

        if (!isOverflow_Unifloat(model_res) &&
            !isUnderflow_Unifloat(model_res))
        {
            /*
             * These functions shall convert the initial portion of the wide-
             * character string pointed to by nptr to double, float, and long
             * double representation, respectively.
             *
             * Then they shall attempt to convert the subject sequence to a
             * floating-point number, and return the result.
             */
            REQ("atof.strtod.01.01",
                "It shall attempt to convert the subject sequence to a "
                " floating-point number, and return the result",
                compareWithPrecision_Unifloat(model_res, atof_spec, mant[type]) == 0);
        }

       /*
         * The call atof(str) shall be equivalent to: strtod(str,(char **)NULL), except
         * that the handling of errors may differ.
         */
        REQ("atof.16", "", GENERAL_REQ("atof.*"));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

ecvt, fcvt, gcvt - convert a floating-point number to a string (LEGACY)

SYNOPSIS

[XSI] #include <stdlib.h>

char *ecvt(double value, int ndigit, int *restrict decpt,

int *restrict sign);

char *fcvt(double value, int ndigit, int *restrict decpt,

int *restrict sign);

char *gcvt(double value, int ndigit, char *buf);

DESCRIPTION

The ecvt(), fcvt(), and gcvt() functions shall convert floating-point numbers
to null-terminated strings.

The ecvt() function shall convert value to a null-terminated string of ndigit
digits (where ndigit is reduced to an unspecified limit determined by the
precision of a double) and return a pointer to the string. The high-order digit
shall be non-zero, unless the value is 0. The low-order digit shall be rounded
in an implementation-defined manner. The position of the radix character
relative to the beginning of the string shall be stored in the integer pointed
to by decpt (negative means to the left of the returned digits). If value is
zero, it is unspecified whether the integer pointed to by decpt would be 0 or 1.
The radix character shall not be included in the returned string. If the sign
of the result is negative, the integer pointed to by sign shall be non-zero;
otherwise, it shall be 0.

If the converted value is out of range or is not representable, the contents of
the returned string are unspecified.

The fcvt() function shall be equivalent to ecvt(), except that ndigit specifies
the number of digits desired after the radix character. The total number of
digits in the result string is restricted to an unspecified limit as determined
by the precision of a double.

The gcvt() function shall convert value to a null-terminated string (similar to
that of the %g conversion specification format of printf()) in the array
pointed to by buf and shall return buf. It shall produce ndigit significant
digits (limited to an unspecified value determined by the precision of a double)
in the %f conversion specification format of printf() if possible, or the %e
conversion specification format of printf() (scientific notation) otherwise. A
minus sign shall be included in the returned string if value is less than 0. A
radix character shall be included in the returned string if value is not a
whole number. Trailing zeros shall be suppressed where value is not a whole
number. The radix character is determined by the current locale. If setlocale()
has not been called successfully, the default locale, POSIX, is used. The
default locale specifies a period ( '.' ) as the radix character. The
LC_NUMERIC category determines the value of the radix character within the
current locale.

These functions need not be reentrant. A function that is not required to be
reentrant is not required to be thread-safe.

RETURN VALUE

The ecvt() and fcvt() functions shall return a pointer to a null-terminated
string of digits.

The gcvt() function shall return buf.

The return values from ecvt() and fcvt() may point to static data which may be
overwritten by subsequent calls to these functions.

ERRORS

No errors are defined.
*/

/** ecvt_spec **/
//This specification refers to: ecvt 
specification
CString* ecvt_spec(CallContext context, Unifloat * x, IntT ndigit, IntT* decpt, IntT* sign)
{
    pre
    {
       /*
         * If the converted value is out of range or is not representable, the contents of
         * the returned string are unspecified.
         */
        REQ("app.ecvt.09", "incorrect input value", isNormal_Unifloat(x));
    	
       /*
         * These functions need not be reentrant. A function that is not required to be
         * reentrant is not required to be thread-safe.
         */
        REQ("app.ecvt.11", "", TODO_REQ());

        /*
         * The return values from ecvt() and ecvt() may point to static data which may be
         * overwritten by subsequent calls to these functions.
         */
        REQ("app.ecvt.13", "", TODO_REQ());
    	
        return true;
    }
    post
    {
	IntT model_decpt;
	IntT model_sign;
    CString* model_res = ecvt_model(x, ndigit, &model_decpt, &model_sign);

    traceExtraProperty( "expected result", model_res );
    traceExtraFormattedProperty( "expected decpt", "%ld", (long)model_decpt );

    /*
     * The high-order digit shall be non-zero, unless the value is 0.
     */
    REQ("ecvt.03", "high-order digit shall be non-zero, unless the value is 0", ((charAt_CString(ecvt_spec, 0) != '0') || (isZero_Unifloat(x))));

    /*
     * The low-order digit shall be rounded in an implementation-defined manner.
     */
    REQ("ecvt.04", "low-order digit shall be rounded", charAt_CString(ecvt_spec, length_CString(ecvt_spec)-1) == charAt_CString(model_res, length_CString(model_res)-1));

    /*
     * The position of the radix character relative to the beginning of the string
     * shall be stored in the integer pointed to by decpt (negative means to the left
     * of the returned digits).
     */
    REQ("ecvt.05", "position of the radix character shall be stored in decpt", *decpt==model_decpt);

    if (isZero_Unifloat(x))
    {
	    /*
	     * If value is zero, it is unspecified whether the integer pointed to by decpt
	     * would be 0 or 1.
	     */
	    REQ("ecvt.06", "If value is zero, decpt is 1 or 0", (*decpt == 0) || (*decpt == 1));
    }

    /*
     * The radix character shall not be included in the returned string.
     */
    REQ("ecvt.07", "The radix character shall not be included in the returned string", indexOfChar_CString(ecvt_spec, '.') < 0);

    if (x->sign == -1)
    {
	    /*
	     * If the sign of the result is negative, the integer pointed to by sign shall be
	     * non-zero;
	     */
	    REQ("ecvt.08.01", "If the sign of the result is negative, sign shall be non-zero", *sign!=0);
    }

    if (x->sign == 1)
    {
	    /*
	     * otherwise, it shall be 0.
	     */
	    REQ("ecvt.08.02", "If the sign of the result is positive, sign shall be 0", *sign == 0);
    }

    /*
     * The ecvt() and ecvt() functions shall return a pointer to a null-terminated
     * string of digits.
     */
    /*
     * The ecvt() function shall convert value to a null-terminated string of ndigit
     * digits (where ndigit is reduced to an unspecified limit determined by the
     * precision of a double) and return a pointer to the string.
     */
    REQ("ecvt.02;ecvt.12", "Function shall convert value to a null-terminated string", compare_Unifloat(convertString_Unifloat(model_res, UniDoubleT),convertString_Unifloat(ecvt_spec, UniDoubleT)) == 0);

    /*
     * The ecvt(), ecvt(), and gcvt() functions shall convert floating-point numbers
     * to null-terminated strings.
     */
    REQ("ecvt.01", "Functions shall convert floating-point numbers to null-terminated strings", GENERAL_REQ("ecvt.*"));

    return true;
    }
}

/** fcvt_spec **/
//This specification refers to: fcvt 
specification
CString* fcvt_spec(CallContext context, Unifloat * x, IntT ndigit, IntT* decpt, IntT* sign)
{
    pre
    {
       /*
         * If the converted value is out of range or is not representable, the contents of
         * the returned string are unspecified.
         */
        REQ("app.fcvt.09", "incorrect input value", isNormal_Unifloat(x));
    	
       /*
         * These functions need not be reentrant. A function that is not required to be
         * reentrant is not required to be thread-safe.
         */
        REQ("app.fcvt.11", "", TODO_REQ());

        /*
         * The return values from fcvt() and fcvt() may point to static data which may be
         * overwritten by subsequent calls to these functions.
         */
        REQ("app.fcvt.13", "", TODO_REQ());
    	
        return true;
    }
    post
    {
	IntT model_decpt;
	IntT model_sign;
    CString* model_res = fcvt_model(x, ndigit, &model_decpt, &model_sign);

    traceExtraProperty( "expected result", model_res );
    traceExtraFormattedProperty( "expected decpt", "%ld", (long)model_decpt );

    /*
     * The high-order digit shall be non-zero, unless the value is 0.
     */
    REQ("fcvt.03", "high-order digit shall be non-zero, unless the value is 0", ((charAt_CString(fcvt_spec, 0) != '0') || (isZero_Unifloat(x))));

    /*
     * The low-order digit shall be rounded in an implementation-defined manner.
     */
    REQ("fcvt.04", "low-order digit shall be rounded", charAt_CString(fcvt_spec, length_CString(fcvt_spec)-1) == charAt_CString(model_res, length_CString(model_res)-1));

    /*
     * The position of the radix character relative to the beginning of the string
     * shall be stored in the integer pointed to by decpt (negative means to the left
     * of the returned digits).
     */
    REQ("fcvt.05", "position of the radix character shall be stored in decpt", *decpt==model_decpt);

    if (isZero_Unifloat(x))
    {
	    /*
	     * If value is zero, it is unspecified whether the integer pointed to by decpt
	     * would be 0 or 1.
	     */
	    REQ("fcvt.06", "If value is zero, decpt is 1 or 0", (*decpt == 0) || (*decpt == 1));
    }

    /*
     * The radix character shall not be included in the returned string.
     */
    REQ("fcvt.07", "The radix character shall not be included in the returned string", indexOfChar_CString(fcvt_spec, '.') < 0);

    if (x->sign == -1)
    {
	    /*
	     * If the sign of the result is negative, the integer pointed to by sign shall be
	     * non-zero;
	     */
	    REQ("fcvt.08.01", "If the sign of the result is negative, sign shall be non-zero", *sign!=0);
    }

    if (x->sign == 1)
    {
	    /*
	     * otherwise, it shall be 0.
	     */
	    REQ("fcvt.08.02", "If the sign of the result is positive, sign shall be 0", *sign == 0);
    }

    /*
     * The fcvt() function shall be equivalent to ecvt(), except that ndigit specifies
     * the number of digits desired after the radix character.
     */

    /*
     * The total number of digits in the result string is restricted to an unspecified
     * limit as determined by the precision of a double.
     */
    /*
     * The fcvt() and fcvt() functions shall return a pointer to a null-terminated
     * string of digits.
     */
    /*
     * The fcvt() function shall convert value to a null-terminated string of ndigit
     * digits (where ndigit is reduced to an unspecified limit determined by the
     * precision of a double) and return a pointer to the string.
     */
    REQ("fcvt.02;fcvt.12;fcvt.02.01;fcvt.02.02", "Function shall convert value to a null-terminated string", compare_Unifloat(convertString_Unifloat(model_res, UniDoubleT),convertString_Unifloat(fcvt_spec, UniDoubleT)) == 0);

    /*
     * The fcvt(), fcvt(), and gcvt() functions shall convert floating-point numbers
     * to null-terminated strings.
     */
    REQ("fcvt.01", "Functions shall convert floating-point numbers to null-terminated strings", GENERAL_REQ("fcvt.*"));

    return true;
    }
}

/** gcvt_spec **/
//This specification refers to: gcvt 
specification
CString* gcvt_spec(CallContext context, Unifloat * x, IntT ndigit, CString* buf)
{
    pre
    {
        /*
         * These functions need not be reentrant. A function that is not required to be
         * reentrant is not required to be thread-safe.
         */
        REQ("app.gcvt.11", "", TODO_REQ());

        return true;
    }
    post
    {	
    CString* model_buf;
    CString* model_res = gcvt_model(x, ndigit, model_buf);

    traceExtraProperty( "expected result", model_res );

	if (x->sign == -1)
	{
	    /*
	     * A minus sign shall be included in the returned string if value is less than 0.
	     */
	    REQ("gcvt.04", "A minus sign shall be included in the returned string if value is less than 0", charAt_CString(gcvt_spec, 0) == '-');
	}

	if (indexOfChar_CString(model_res, '.') >= 0) 
	{
	    /*
	     * A radix character shall be included in the returned string if value is not a
	     * whole number.
	     */
	    REQ("gcvt.05", "A radix character shall be included in the returned string if value is not a whole number", indexOfChar_CString(gcvt_spec, '.') >= 0);

	    /*
	     * Trailing zeros shall be suppressed where value is not a whole number.
	     */
	    REQ("gcvt.06", "Trailing zeros shall be suppressed where value is not a whole number", charAt_CString(gcvt_spec, length_CString(gcvt_spec)-1) != '0');
	}

    /*
     * The gcvt() function shall return buf.
     */
    REQ("gcvt.12", "The gcvt() function shall return buf", model_buf == buf);

    /*
     * It shall produce ndigit significant digits (limited to an unspecified value
     * determined by the precision of a double) in the %f conversion specification
     * format of printf() if possible, or the %e conversion specification format of
     * printf() (scientific notation) otherwise.
     */
    /*
     * The gcvt() function shall convert value to a null-terminated string (similar to
     * that of the %g conversion specification format of printf()) in the array
     * pointed to by buf and shall return buf.
     */
    REQ("gcvt.02;gcvt.03", "function shall convert value to a null-terminated string", compare_Unifloat(convertString_Unifloat(model_res, UniDoubleT),convertString_Unifloat(gcvt_spec, UniDoubleT)) == 0);

   /*
     * The ecvt(), fcvt(), and gcvt() functions shall convert floating-point numbers
     * to null-terminated strings.
     */
    REQ("gcvt.01", "", GENERAL_REQ("gcvt.*"));

    return true;
    }
}

Unifloat* strtod_model(CString* st, CString** endptr, UnifloatType type, IntT* err)
{
    Unifloat* res = createZero_Unifloat(type);
    CString* number = clone(st);
    CString* subst;
    IntT i, sign = 1, j, k;
    IntT point_position, exp_position;
    CharT c;

    *err = 0;
   /*
     * First, they shall decompose the input wide-character string into
     * three parts:
     * * An initial, possibly empty, sequence of white-space wide-
     * character codes (as specified by iswspace())
     * * A subject sequence interpreted as a floating-point constant or
     * representing infinity or NaN
     * * A final wide-character string of one or more unrecognized wide-
     * character codes, including the terminating null wide-character code
     * of the input wide-character string
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.02;__strtof_internal.strtof.02;"
        "__strtold_internal.strtold.02;strtod.02;strtof.02;strtold.02;atof.strtod.02");
    // delete wite-space characters
    for (i = 0; (i < length_CString(st)) && (charAt_CString(st, i) <= 32); i++);
    if (i != 0)
        number = substring_CString(st, i, length_CString(st));
    /*
     * If the subject sequence begins with a minus sign, the sequence
     * shall be interpreted as negated.
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.08;__strtof_internal.strtof.08;"
        "__strtold_internal.strtold.08;strtod.08;strtof.08;strtold.08;atof.strtod.08");

    // determination of number's sign
    if (charAt_CString(number, 0) == '-')
    {
        sign = -1;
        i++;
        number = substring_CString(number, 1, length_CString(number));
    }

    number = toLowerCase_CString(number);

    /*
     * The expected form of the subject sequence is an optional plus or
     * minus sign, then one of the following: * A non-empty sequence of
     * decimal digits optionally containing a radix character, then an
     * optional exponent part:
     * * A 0x or 0X, then a non-empty sequence of hexadecimal digits
     * optionally containing a radix character, then an optional binary
     * exponent part
     * * One of INF or INFINITY, or any other wide string equivalent
     * except for case
     * * One of NAN or NAN(n-wchar-sequenceopt), or any other wide string
     * ignoring case in the NAN part, where:
     * n-wchar-sequence:
     *            digit
     *         nondigit
     * n-wchar-sequence digit
     * n-wchar-sequence nondigit
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.03;__strtof_internal.strtof.03;"
        "__strtold_internal.strtold.03;strtod.03;strtof.03;strtold.03;atof.strtod.03");
    /*
     * A wide-character sequence INF or INFINITY shall be interpreted as
     * an infinity, if representable in the return type, else as if it
     * were a floating constant that is too large for the range of the
     * return type.
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.09;__strtof_internal.strtof.09;"
        "__strtold_internal.strtold.09;strtod.09;strtof.09;strtold.09;atof.strtod.09");
    // search infinity
    if (length_CString(number) >= 3)
    if (equals(substring_CString(number, 0, 3), create_CString("inf")))
    {
        i += 3;
        if (length_CString(number) >= 8)
            if (equals(substring_CString(number, 0, 8), create_CString("infinity")))
                i += 5;
        res = clone(infinity_Unifloat(type));
        res->sign = sign;
        *endptr = substring_CString(st, i, length_CString(st));
        return res;
    }
    /*
     * A wide-character sequence NAN or NAN(n-wchar-sequenceopt) shall be
     * interpreted as a quiet NaN, if supported in the return type, else
     * as if it were a subject sequence part that does not have the
     * expected form;
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.10;__strtof_internal.strtof.10;"
        "__strtold_internal.strtold.10;strtod.10;strtof.10;strtold.10;atof.strtod.10");
    // search NaN
    if (length_CString(number) >= 3)
    if (equals(substring_CString(number, 0, 3), create_CString("nan")))
    {
        i += 3;
        if (length_CString(number) > 3)
            if (charAt_CString(number, 3) == '(')
            {
                for (j = 4; j < length_CString(number) && (charAt_CString(number, j) != ')'); j++);
                if (j < length_CString(number))
                {
                    if (charAt_CString(number, j) == ')')
                    {
                        for (k = 4; k < j; k++)
                        {
                            c = charAt_CString(number, k);
                            if (!((c >= 48) && (c <= 57)) && !((c >= 97) && (c <= 122)))
                                break;
                        }
                        if (k == j)
                            i += j - 3 + 1;
                    }
                }
            }
        res = clone(nan_Unifloat(type));
        *endptr = substring_CString(st, i, length_CString(st));
        return res;
    }
    /*
     * These functions shall convert the initial portion of the wide-
     * character string pointed to by nptr to double, float, and long
     * double representation, respectively.
     *
     * If the subject sequence has the hexadecimal form and FLT_RADIX is a
     * power of 2, the conversion shall be rounded in an
     * implementation-defined manner.
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.01.02;__strtof_internal.strtof.01.02;"
        "__strtold_internal.strtold.01.02;strtod.01.02;strtof.01.02;strtold.01.02;atof.strtod.01.02");
    // search hexadecimal
    if (length_CString(number) > 2)
    if (equals(substring_CString(number, 0, 2), create_CString("0x")))
    {
        i += 2;
        for (j = 2; j< length_CString(number); j++)
        {
            c = charAt_CString(number, j);
            if (!( ((c >=48) && (c <= 57)) || ((c >= 97) && (c <= 102)) ))
                break;
        }
        res = convertHexString_Unifloat(substring_CString(number, 2, j), type);
        *endptr = substring_CString(st, i + j - 2, length_CString(st));
        res->sign = sign;
        return res;
    }
    /*
     * The subject sequence is defined as the longest initial subsequence
     * of the input wide string, starting with the first non-white-space
     * wide character, that is of the expected form.
     */
    /*
     * and that if neither an exponent part nor a radix character appears
     * in a decimal floating-point number, or if a binary exponent part
     * does not appear in a hexadecimal floating-point number, an
     * exponent part of the appropriate type with value zero shall be
     * assumed to follow the last digit in the string.
     */
    /*
     * [CX] The radix character shall be as defined in the program's
     * locale (category LC_NUMERIC ). In the POSIX locale, or in a locale
     * where the radix character is not defined, the radix character
     * shall default to a period ( '.' ).
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.04;__strtof_internal.strtof.04;atof.strtod.04;"
        "__strtold_internal.strtold.04;__strtod_internal.strtod.07;atof.strtod.07;"
        "__strtof_internal.strtof.07;__strtold_internal.strtold.07;"
        "__strtod_internal.strtod.12;__strtof_internal.strtof.12;atof.strtod.11;"
        "__strtold_internal.strtold.12;strtod.04;strtof.04;strtold.04;"
        "strtod.07;strtof.07;strtold.07;strtod.12;strtof.12;strtold.12");
    // search decimal float-point number
    point_position = -1;
    exp_position = -1;
    for (j = 0; j < length_CString(number); j++)
    {
        c = charAt_CString(number, j);
        if (c == '.')
            if (point_position != -1)
                break;
            else
                point_position = j;
        if (c == 'e')
            if (exp_position != -1)
                break;
            else
                exp_position = j;
        if ((c == '-') && (exp_position != j - 1))
            break;
        if ((c != '.') && (c != 'e') && (c != '-') && !((c >= 48) && (c <= 57)))
            break;
    }

    if (exp_position != -1)
    {
        for (k = exp_position + 1; k < j; k++)
        {
            c = charAt_CString(number, k);
            if ((c >= 48) && (c <=57))
                break;
        }

        if (k >= j) j = exp_position;
        if (point_position > exp_position)
            j = point_position;
    }

    i += j;

    number = substring_CString(number, 0, j);

    /*
     * The subject sequence contains no wide characters if the input wide
     * string is not of the expected form.
     */
    IMPLEMENT_REQ("__strtod_internal.strtod.05;__strtof_internal.strtof.05;"
        "__strtold_internal.strtold.05;strtod.05;strtof.05;strtold.05;atof.strtod.05");
    if ((length_CString(number) == 0) ||
        equals(number, create_CString(".")) ||
        equals(number, create_CString("-")) ||
        (exp_position == 0) )
    {
        *err = 1;
        i = 0;
    }
    else
    {
        res = convertString_Unifloat(number, type);
        res->sign = sign;
    }

    if (isOverflow_Unifloat(res) || isUnderflow_Unifloat(res))
        *err = 2;

    *endptr = substring_CString(st, i, length_CString(st));

    return res;
}

CString* ecvt_model(Unifloat* x, IntT ndigit, IntT* decpt, IntT* sign)
{
	long double res = 0.0;
    CString* st_exp;
	IntT exp;
	int i;
    CString* pat;
    CString* str;
	int pos_pt;
	int pos_e;
	CString* st1;
	CString* st2;
	CString* st3;
	Unifloat* y;
	int error;
	for (i = digMant_Unifloat(x->type); i > 0; i--)
	{
	    exp = x->exp + (-i);
	    res = res + powl(2, exp) * getMant_Unifloat((Unifloat*)x, i);
	}
    pat = format_CString("%%.%de",(ndigit-1));
    str = format_CString(toCharArray_CString(pat), (double)res);
	pos_pt = indexOfChar_CString(str, '.');
	pos_e = indexOfChar_CString(str, 'e');
	st1 = substring_CString(str, 0, pos_pt);
	st2 = substring_CString(str, pos_pt+1, pos_e);
	st3 = substring_CString(str, pos_e+1, length_CString(str));
	str = concat_CString(st1, st2);
	y = convertString_Unifloat(st3, UniDoubleT);
	exp = convertUnifloat_Integer(y, &error);
	*decpt = exp + 1;
	*sign = (x->sign == -1);
    return str;
}

CString* fcvt_model(Unifloat* x, IntT ndigit, IntT* decpt, IntT* sign)
{
	long double res = 0.0;
    CString* st_exp;
	IntT exp;
	int i;
    CString* pat1;
    CString* str1;
    CString* pat;
    CString* str;
	int pos_pt;
	int pos_e;
	CString* st1;
	CString* st2;
	CString* st3;
	Unifloat* y;
	int error;
	for (i = digMant_Unifloat(x->type); i > 0; i--)
	{
	    exp = x->exp + (-i);
	    res = res + powl(2, exp) * getMant_Unifloat((Unifloat*)x, i);
	}
    pat1 = format_CString("%%.%df",ndigit);
    str1 = format_CString(toCharArray_CString(pat1), (double)res);
    pat = format_CString("%%.%de",ndigit+1);
    str = format_CString(toCharArray_CString(pat), (double)res);
	pos_pt = indexOfChar_CString(str1, '.');
	pos_e = indexOfChar_CString(str, 'e');
	st1 = substring_CString(str1, 0, pos_pt);
	st2 = substring_CString(str1, pos_pt+1, length_CString(str1));
	st3 = substring_CString(str, pos_e+1, length_CString(str));
	str1 = concat_CString(st1, st2);
	y = convertString_Unifloat(st3, UniDoubleT);
	exp = convertUnifloat_Integer(y, &error);
	*decpt = exp + 1;
	*sign = (x->sign == -1);
    return str1;
}

CString* gcvt_model(Unifloat* x, IntT ndigit, CString* buf)
{
	long double res = 0.0;
 	IntT exp;
	CString* st;
	int i;
    CString* pat1;
	for (i = digMant_Unifloat(x->type); i > 0; i--)
	{
	    exp = x->exp + (-i);
	    res = res + powl(2, exp) * getMant_Unifloat((Unifloat*)x, i);
	}
	res = res*x->sign;
    /*
     * The radix character is determined by the current locale.
     * If setlocale() has not been called successfully, the default locale, POSIX, is
     * used.
     * The default locale specifies a period ( '.' ) as the radix character.
     * The LC_NUMERIC category determines the value of the radix character within the
     * current locale.
     */
    IMPLEMENT_REQ("gcvt.07;gcvt.08;gcvt.09;gcvt.10");
	
    pat1 = format_CString("%%.%dg",ndigit);
    st = format_CString(toCharArray_CString(pat1),(double)res);
	buf = clone(st);
 	return st;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

CString* toLowerCase_CString(CString* st)
{
    CString* res = clone(st);
    IntT i;
    for (i = 0; i < length_CString(res); i++)
        if ((res->data[i] >=65) && (res->data[i] <= 90))
            res->data[i] = res->data[i] + 32;
    return res;
}
