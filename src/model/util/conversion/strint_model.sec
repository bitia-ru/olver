/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "util/conversion/strint_model.seh"

#include "config/interpretation.seh"
#include "util/conversion/strint_config.h"
#include "data/errno_model.seh"
#include "common/common_scenario.seh"
#include "config/system_config.seh"


#pragma SEC subsystem conversion "util.conversion"



/*
   The group of functions 'util.conversion.strint' consists of:
       __strtol_internal [1]
       __strtoll_internal [1]
       __strtoul_internal [1]
       __strtoull_internal [1]
       a64l [1]
       atoi [1]
       atol [1]
       atoll [1]
       l64a [1]
       strtoimax [2]
       strtol [1]
       strtoll [2]
       strtoq [1]
       strtoul [1]
       strtoull [2]
       strtoumax [2]
       strtouq [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  __strtol_internal

Name
    __strtol_internal -- alias for strtol

Synopsis

    long int __strtol_internal(const char * __nptr, char * * __endptr, int __base, int __group);

Description

__group shall be 0 or the behavior of __strtol_internal() is undefined.

__strtol_internal(__nptr, __endptr, __base, 0) has the same specification as strtol(__nptr, __endptr, __base).

__strtol_internal() is not in the source standard; it is only in the binary standard.
*/
#define mytype LongT
#define mymin min_LongT
#define mymax max_LongT
#define over_pos OverPos_LI
#define over_neg OverNeg_LI
#define mayneg true
#define a_name "__strtol_internal"
#define mytype_size sizeof_LongT
#define model __strtol_internal_model
#define spec __strtol_internal_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX___STRTOL_INTERNAL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX___STRTOL_INTERNAL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX___STRTOL_INTERNAL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX___STRTOL_INTERNAL_HAS_EXTRA_CONDITION_ON_EINVAL
#define ParameterGroupExists
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

__strtoll_internal

Name
    __strtoll_internal -- underlying function for strtoll

Synopsis

    long long __strtoll_internal(const char * __nptr, char * * __endptr, int __base, int __group);

Description

__group shall be 0 or the behavior of __strtoll_internal() is undefined.

__strtoll_internal(__nptr, __endptr, __base, 0) has the same specification as strtoll(__nptr, __endptr, __base).

__strtoll_internal() is not in the source standard; it is only in the binary standard.

*/
#define mytype LLongT
#define mymin min_LLongT
#define mymax max_LLongT
#define over_pos OverPos_LLI
#define over_neg OverNeg_LLI
#define mayneg true
#define mytype_size sizeof_LLongT
#define a_name "__strtoll_internal"
#define model __strtoll_internal_model
#define spec __strtoll_internal_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX___STRTOLL_INTERNAL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX___STRTOLL_INTERNAL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX___STRTOLL_INTERNAL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX___STRTOLL_INTERNAL_HAS_EXTRA_CONDITION_ON_EINVAL
#define ParameterGroupExists
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  __strtoul_internal

Name
    __strtoul_internal -- underlying function for strtoul

Synopsis

    unsigned long int __strtoul_internal(const char * __nptr, char * * __endptr, int __base, int __group);

Description

__group shall be 0 or the behavior of __strtoul_internal() is undefined.

__strtoul_internal(__nptr, __endptr, __base, 0) has the same specification as strtoul(__nptr, __endptr, __base).

__strtoul_internal() is not in the source standard; it is only in the binary standard.
*/
#define mytype ULongT
#define mymin 0
#define mymax max_ULongT
#define over_pos OverPos_ULI
#define over_neg OverNeg_ULI
#define mayneg false
#define mytype_size sizeof_LongT
#define a_name "__strtoul_internal"
#define model __strtoul_internal_model
#define spec __strtoul_internal_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX___STRTOUL_INTERNAL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX___STRTOUL_INTERNAL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX___STRTOUL_INTERNAL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX___STRTOUL_INTERNAL_HAS_EXTRA_CONDITION_ON_EINVAL
#define ParameterGroupExists
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  __strtoull_internal

Name
    __strtoull_internal -- underlying function for strtoull

Synopsis

    unsigned long long __strtoull_internal(const char * __nptr, char * * __endptr, int __base, int __group);

Description

__group shall be 0 or the behavior of __strtoull_internal() is undefined.

__strtoull_internal(__nptr, __endptr, __base, 0) has the same specification as strtoull(__nptr, __endptr, __base).

__strtoull_internal() is not in the source standard; it is only in the binary standard.
*/
#define mytype ULLongT
#define mymin 0
#define mymax max_ULLongT
#define over_pos OverPos_ULLI
#define over_neg OverNeg_ULLI
#define mayneg false
#define mytype_size sizeof_LLongT
#define a_name "__strtoull_internal"
#define model __strtoull_internal_model
#define spec __strtoull_internal_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX___STRTOULL_INTERNAL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX___STRTOULL_INTERNAL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX___STRTOULL_INTERNAL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX___STRTOULL_INTERNAL_HAS_EXTRA_CONDITION_ON_EINVAL
#define ParameterGroupExists
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    a64l, l64a - convert between a 32-bit integer and a radix-64 ASCII string

SYNOPSIS

    [XSI] #include <stdlib.h>

    long a64l(const char *s);

    char *l64a(long value);

DESCRIPTION

These functions maintain numbers stored in radix-64 ASCII characters. This is
a notation by which 32-bit integers can be represented by up to six characters;
each character represents a digit in radix-64 notation. If the type long
contains more than 32 bits, only the low-order 32 bits shall be used for these
operations.

The characters used to represent digits are '.' (dot) for 0, '/' for 1, '0'
through '9' for [2,11], 'A' through 'Z' for [12,37], and 'a' through 'z' for [
38,63].

The a64l() function shall take a pointer to a radix-64 representation, in which
the first digit is the least significant, and return the corresponding long
value. If the string pointed to by s contains more than six characters, a64l()
shall use the first six. If the first six characters of the string contain a
null terminator, a64l() shall use only characters preceding the null
terminator. The a64l() function shall scan the character string from left to
right with the least significant digit on the left, decoding each character as
a 6-bit radix-64 number. If the type long contains more than 32 bits, the
resulting value is sign-extended. The behavior of a64l() is unspecified if s
is a null pointer or the string pointed to by s was not generated by a
previous call to l64a().

The l64a() function shall take a long argument and return a pointer to the
corresponding radix-64 representation. The behavior of l64a() is unspecified
if value is negative.

The value returned by l64a() may be a pointer into a static buffer. Subsequent
calls to l64a() may overwrite the buffer.

The l64a() function need not be reentrant. A function that is not required to
be reentrant is not required to be thread-safe.


RETURN VALUE

Upon successful completion, a64l() shall return the long value resulting from
conversion of the input string. If a string pointed to by s is an empty
string, a64l() shall return 0L.

The l64a() function shall return a pointer to the radix-64 representation. If
value is 0L, l64a() shall return a pointer to an empty string.


ERRORS

    No errors are defined.
*/

specification
LongT a64l_spec( CallContext context, CString* str)
{
    pre
    {
        /*
         * The behavior of a64l() is unspecified if s is a null pointer or the
         * string pointed to by s was not generated by a previous call to l64a().
         */
        REQ("a64l.11",
            "The behavior is unspecified if s is a null pointer",
            str!=NULL);
        return true;
    }
    post
    {
        IntT err=0;
        LongT ret=a64l_model(context, str, &err);
        DUMP("a64l: str==$(obj), ret==%ld\n", str, a64l_spec);

        if(err)
            return true;

        /*
         * These functions maintain numbers stored in radix-64 ASCII characters.
         */
        /*
         * This is a notation by which 32-bit integers can be represented by up to six
         * characters;
         */
        /*
         * each character represents a digit in radix-64 notation.
         */
        /*
         * If the type long contains more than 32 bits, only the low-order 32 bits shall
         * be used for these operations.
         */
        IMPLEMENT_REQ("a64l.01;a64l.02;a64l.03;a64l.04");

        /*
         * The characters used to represent digits are '.' (dot) for 0, '/' for 1, '0'
         * through '9' for [2,11], 'A' through 'Z' for [12,37], and 'a' through 'z' for [
         * 38,63].
         */
        REQ("a64l.05", "Only valid characters", ret!=-1);

        if(length_CString(str)==0)
        {
        /*
         * If a string pointed to by s is an empty string, a64l() shall return 0L.
         */
        REQ("a64l.13", "Empty==0L", ret==0);
        }

        DUMP("str==$(obj), model_ret==%ld, spec_ret==%ld\n", str, (long)ret, (long)a64l_spec);
        /*
         * Upon successful completion, a64l() shall return the long value resulting from
         * conversion of the input string.
         */
        REQ("a64l.12", "Model_ret equal to spec_ret", ret==a64l_spec);

        return true;
    }
}

LongT a64l_model( CallContext context, CString* str, IntT* err)
{
    IntT size=length_CString(str);
    IntT i=0;
    LongT ret=0, mul=1, curr;

    /*
     * The a64l() function shall take a pointer to a radix-64 representation, in which
     * the first digit is the least significant, and return the corresponding long
     * value.
     */
    /*
     * If the string pointed to by s contains more than six characters, a64l() shall
     * use the first six.
     */
    /*
     * If the first six characters of the string contain a null terminator, a64l()
     * shall use only characters preceding the null terminator.
     */
    /*
     * The a64l() function shall scan the character string from left to right with
     * the least significant digit on the left, decoding each character as a 6-bit
     * radix-64 number
     */
    IMPLEMENT_REQ("a64l.06;a64l.07;a64l.08;a64l.09");

    while(i<6 && i<size && charAt_CString(str, i)!='\0')
    {
        curr=char2_a64l(charAt_CString(str, i));

        if(curr==-1)
            return -1;

        ret+=mul*curr;
        mul*=64;
        i++;
    }

    if(sizeof_LongT>4)
    {
        /*
         * If the type long contains more than 32 bits, the resulting value is sign-
         * extended.
         */
        IMPLEMENT_REQ("a64l.10");
        if(ret&(1<<31))
        for(i=32;i<sizeof_LongT*8;i++)
            ret|=(1<<i);
    }

    return ret;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    atoi - convert a string to an integer

SYNOPSIS

    #include <stdlib.h>

    int atoi(const char *str);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The call atoi(str) shall be equivalent to:

(int) strtol(str, (char **)NULL, 10)

except that the handling of errors may differ. If the value cannot be
represented, the behavior is undefined.


RETURN VALUE

The atoi() function shall return the converted value if the value can be
represented.

ERRORS

    No errors are defined.
*/
#define model_mytype LongT
#define mytype IntT
#define mymin min_LongT
#define mymax max_LongT
#define over_pos OverPos_AI
#define over_neg OverNeg_AI
#define model_mytype_size sizeof_LongT
#define a_model atoi_model
#define a_spec atoi_spec
#define a_name "atoi"
#include "ato_model.seh"
#include "ato_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    atol, atoll - convert a string to a long integer

SYNOPSIS

    #include <stdlib.h>

    long atol(const char *str);

    long long atoll(const char *nptr);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The call atol(str) shall be equivalent to:

strtol(str, (char **)NULL, 10)

The call atoll(str) shall be equivalent to:

strtoll(nptr, (char **)NULL, 10)

except that the handling of errors may differ. If the value cannot be
represented, the behavior is undefined.


RETURN VALUE

These functions shall return the converted value if the value can be
represented.

ERRORS

    No errors are defined.
*/
#define model_mytype LongT
#define mytype LongT
#define mymin min_LongT
#define mymax max_LongT
#define over_pos OverPos_AL
#define over_neg OverNeg_AL
#define model_mytype_size sizeof_LongT
#define a_model atol_model
#define a_spec atol_spec
#define a_name "atol"
#include "ato_model.seh"
#include "ato_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    atol, atoll - convert a string to a long integer

SYNOPSIS

    #include <stdlib.h>

    long atol(const char *str);

    long long atoll(const char *nptr);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

The call atol(str) shall be equivalent to:

strtol(str, (char **)NULL, 10)

The call atoll(str) shall be equivalent to:

strtoll(nptr, (char **)NULL, 10)

except that the handling of errors may differ. If the value cannot be
represented, the behavior is undefined.


RETURN VALUE

These functions shall return the converted value if the value can be
represented.

ERRORS

    No errors are defined.
*/
#define model_mytype LLongT
#define mytype LLongT
#define mymin min_LLongT
#define mymax max_LLongT
#define over_pos OverPos_ALL
#define over_neg OverNeg_ALL
#define model_mytype_size sizeof_LLongT
#define a_model atoll_model
#define a_spec atoll_spec
#define a_name "atoll"
#include "ato_model.seh"
#include "ato_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    a64l, l64a - convert between a 32-bit integer and a radix-64 ASCII string

SYNOPSIS

    [XSI] #include <stdlib.h>

    long a64l(const char *s);

    char *l64a(long value);

DESCRIPTION

These functions maintain numbers stored in radix-64 ASCII characters. This is
a notation by which 32-bit integers can be represented by up to six characters;
each character represents a digit in radix-64 notation. If the type long
contains more than 32 bits, only the low-order 32 bits shall be used for these
operations.

The characters used to represent digits are '.' (dot) for 0, '/' for 1, '0'
through '9' for [2,11], 'A' through 'Z' for [12,37], and 'a' through 'z' for [
38,63].

The a64l() function shall take a pointer to a radix-64 representation, in which
the first digit is the least significant, and return the corresponding long
value. If the string pointed to by s contains more than six characters, a64l()
shall use the first six. If the first six characters of the string contain a
null terminator, a64l() shall use only characters preceding the null
terminator. The a64l() function shall scan the character string from left to
right with the least significant digit on the left, decoding each character as
a 6-bit radix-64 number. If the type long contains more than 32 bits, the
resulting value is sign-extended. The behavior of a64l() is unspecified if s
is a null pointer or the string pointed to by s was not generated by a
previous call to l64a().

The l64a() function shall take a long argument and return a pointer to the
corresponding radix-64 representation. The behavior of l64a() is unspecified
if value is negative.

The value returned by l64a() may be a pointer into a static buffer. Subsequent
calls to l64a() may overwrite the buffer.

The l64a() function need not be reentrant. A function that is not required to
be reentrant is not required to be thread-safe.

RETURN VALUE

Upon successful completion, a64l() shall return the long value resulting from
conversion of the input string. If a string pointed to by s is an empty
string, a64l() shall return 0L.

The l64a() function shall return a pointer to the radix-64 representation. If
value is 0L, l64a() shall return a pointer to an empty string.

ERRORS

    No errors are defined.
*/

specification
CString* l64a_spec( CallContext context, LongT value )
{
    pre
    {
        /*
         * The behavior of l64a() is unspecified if value is negative.
         */
        REQ("l64a.07", "value>=0", value>=0);
        return true;
    }
    post
    {
        IntT size, wrong_char=0;
        IntT i=0;
        LongT ret=0, mul=1, curr;
        CString* str;

        REQ("", "", l64a_spec!=NULL);

        str=clone(l64a_spec);
        size=length_CString(str);

        while(i<6 && i<size && charAt_CString(str, i)!='\0')
        {
            curr=char2_a64l(charAt_CString(str, i));

            if(curr==-1)
                wrong_char=1;

            ret+=mul*curr;
            mul*=64;
            i++;
        }

        /*
         * These functions maintain numbers stored in radix-64 ASCII characters.
         */
        /*
         * This is a notation by which 32-bit integers can be represented by up to six
         * characters;
         */
        /*
         * each character represents a digit in radix-64 notation.
         */
        /*
         * If the type long contains more than 32 bits, only the low-order 32 bits shall
         * be used for these operations.
         */
        IMPLEMENT_REQ("l64a.01;l64a.02;l64a.03;l64a.04;");


        /*
         * The characters used to represent digits are '.' (dot) for 0, '/' for 1, '0'
         * through '9' for [2,11], 'A' through 'Z' for [12,37], and 'a' through 'z' for [
         * 38,63].
         */
        REQ("l64a.05",
            "The characters used to represent digits",
            wrong_char!=1);

        if(value==0)
        {
        /*
         * If value is 0L, l64a() shall return a pointer to an empty string.
         */
        REQ("l64a.11",
            "If value is 0L, shall return a pointer to an empty string",
            length_CString(str)==0);
        }

        /*
         * The l64a() function shall take a long argument and return a pointer to the
         * corresponding radix-64 representation.
         */
        IMPLEMENT_REQ("l64a.06");

        /*
         * The value returned by l64a() may be a pointer into a static buffer. Subsequent
         * calls to l64a() may overwrite the buffer.
         */
        /*
         * The l64a() function need not be reentrant. A function that is not required to
         * be reentrant is not required to be thread-safe.
         */
        /*
         * The l64a() function shall return a pointer to the radix-64 representation.
         */
        REQ_UNCHECKABLE("l64a.08;l64a.09;l64a.10", "Poor description of the function behavior in standard");

        DUMP("l64a_spec==$(obj), value==%ld\n", l64a_spec, (long)value);
        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strtoimax, strtoumax - convert string to integer type

SYNOPSIS

    #include <inttypes.h>

    intmax_t strtoimax(const char *restrict nptr, char **restrict endptr,

        int base);

    uintmax_t strtoumax(const char *restrict nptr, char **restrict endptr,

        int base);


DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

These functions shall be equivalent to the strtol(), strtoll(), strtoul(), and
strtoull() functions, except that the initial portion of the string shall be
converted to intmax_t and uintmax_t representation, respectively.


RETURN VALUE

These functions shall return the converted value, if any.

If no conversion could be performed, zero shall be returned.

If the correct value is outside the range of representable values, {INTMAX_MAX},
{INTMAX_MIN}, or {UINTMAX_MAX} shall be returned (according to the return type
and sign of the value, if any), and errno shall be set to [ERANGE].


ERRORS

    These functions shall fail if:

    [ERANGE]

        The value to be returned is not representable.

    These functions may fail if:

    [EINVAL]

        The value of base is not supported.
*/
#define mytype IntMaxT
#define mymin min_IntMaxT
#define mymax max_IntMaxT
#define over_pos OverPos_IM
#define over_neg OverNeg_IM
#define mayneg true
#define mytype_size sizeof_LLongT
#define a_name "strtoimax"
#define model strtoimax_model
#define spec strtoimax_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOIMAX_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOIMAX_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOIMAX_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOIMAX_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strtol, strtoll - convert a string to a long integer

SYNOPSIS

    #include <stdlib.h>

    long strtol(const char *restrict str, char **restrict endptr, int base);

    long long strtoll(const char *restrict str, char **restrict endptr,

        int base)

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

These functions shall convert the initial portion of the string pointed to by
str to a type long and long long representation, respectively. First, they
decompose the input string into three parts:

An initial, possibly empty, sequence of white-space characters (as specified by
isspace())

A subject sequence interpreted as an integer represented in some radix
determined by the value of base

A final string of one or more unrecognized characters, including the
terminating null byte of the input string.

Then they shall attempt to convert the subject sequence to an integer, and
return the result.

If the value of base is 0, the expected form of the subject sequence is that of
a decimal constant, octal constant, or hexadecimal constant, any of which may
be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero
digit, and consists of a sequence of decimal digits. An octal constant
consists of the prefix '0' optionally followed by a sequence of the digits '0'
to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed
by a sequence of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' )
with values 10 to 15 respectively.

If the value of base is between 2 and 36, the expected form of the subject
sequence is a sequence of letters and digits representing an integer with the
radix specified by base, optionally preceded by a '+' or '-' sign. The letters
from 'a' (or 'A' ) to 'z' (or 'Z' ) inclusive are ascribed the values 10 to 35;
only letters whose ascribed values are less than that of base are permitted.
If the value of base is 16, the characters 0x or 0X may optionally precede the
sequence of letters and digits, following the sign if present.

The subject sequence is defined as the longest initial subsequence of the input
string, starting with the first non-white-space character that is of the
expected form. The subject sequence shall contain no characters if the input
string is empty or consists entirely of white-space characters, or if the
first non-white-space character is other than a sign or a permissible letter or
digit.

If the subject sequence has the expected form and the value of base is 0, the
sequence of characters starting with the first digit shall be interpreted as
an integer constant. If the subject sequence has the expected form and the
value of base is between 2 and 36, it shall be used as the base for conversion,
ascribing to each letter its value as given above. If the subject sequence
begins with a minus sign, the value resulting from the conversion shall be
negated. A pointer to the final string shall be stored in the object pointed
to by endptr, provided that endptr is not a null pointer.

In other than the C [CX]  or POSIX locales, other implementation-defined
subject sequences may be accepted.

If the subject sequence is empty or does not have the expected form, no
conversion is performed; the value of str is stored in the object pointed to
by endptr, provided that endptr is not a null pointer.

[CX] The strtol() function shall not change the setting of errno if
successful.

Since 0, {LONG_MIN} or {LLONG_MIN}, and {LONG_MAX} or {LLONG_MAX} are returned
on error and are also valid returns on success, an application wishing to
check for error situations should set errno to 0, then call strtol() or strtoll(
), then check errno.


RETURN VALUE

Upon successful completion, these functions shall return the converted value,
if any. If no conversion could be performed, 0 shall be returned [CX]  and
errno may be set to [EINVAL].

If the correct value is outside the range of representable values, {LONG_MIN}, {
LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall be returned (according to the
sign of the value), and errno set to [ERANGE].


ERRORS

    These functions shall fail if:

    [ERANGE]

        The value to be returned is not representable.

    These functions may fail if:

    [EINVAL]

        [CX] The value of base is not supported.
*/
#define mytype LongT
#define mymin min_LongT
#define mymax max_LongT
#define over_pos OverPos_L
#define over_neg OverNeg_L
#define mayneg true
#define mytype_size sizeof_LongT
#define a_name "strtol"
#define model strtol_model
#define spec strtol_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOL_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strtol, strtoll - convert a string to a long integer

SYNOPSIS

    #include <stdlib.h>

    long strtol(const char *restrict str, char **restrict endptr, int base);

    long long strtoll(const char *restrict str, char **restrict endptr,

        int base)

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

These functions shall convert the initial portion of the string pointed to by
str to a type long and long long representation, respectively. First, they
decompose the input string into three parts:

An initial, possibly empty, sequence of white-space characters (as specified by
isspace())

A subject sequence interpreted as an integer represented in some radix
determined by the value of base

A final string of one or more unrecognized characters, including the
terminating null byte of the input string.

Then they shall attempt to convert the subject sequence to an integer, and
return the result.

If the value of base is 0, the expected form of the subject sequence is that of
a decimal constant, octal constant, or hexadecimal constant, any of which may
be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero
digit, and consists of a sequence of decimal digits. An octal constant
consists of the prefix '0' optionally followed by a sequence of the digits '0'
to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed
by a sequence of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' )
with values 10 to 15 respectively.

If the value of base is between 2 and 36, the expected form of the subject
sequence is a sequence of letters and digits representing an integer with the
radix specified by base, optionally preceded by a '+' or '-' sign. The letters
from 'a' (or 'A' ) to 'z' (or 'Z' ) inclusive are ascribed the values 10 to 35;
only letters whose ascribed values are less than that of base are permitted.
If the value of base is 16, the characters 0x or 0X may optionally precede the
sequence of letters and digits, following the sign if present.

The subject sequence is defined as the longest initial subsequence of the input
string, starting with the first non-white-space character that is of the
expected form. The subject sequence shall contain no characters if the input
string is empty or consists entirely of white-space characters, or if the
first non-white-space character is other than a sign or a permissible letter or
digit.

If the subject sequence has the expected form and the value of base is 0, the
sequence of characters starting with the first digit shall be interpreted as
an integer constant. If the subject sequence has the expected form and the
value of base is between 2 and 36, it shall be used as the base for conversion,
ascribing to each letter its value as given above. If the subject sequence
begins with a minus sign, the value resulting from the conversion shall be
negated. A pointer to the final string shall be stored in the object pointed
to by endptr, provided that endptr is not a null pointer.

In other than the C [CX]  or POSIX locales, other implementation-defined
subject sequences may be accepted.

If the subject sequence is empty or does not have the expected form, no
conversion is performed; the value of str is stored in the object pointed to
by endptr, provided that endptr is not a null pointer.

[CX] The strtol() function shall not change the setting of errno if
successful.

Since 0, {LONG_MIN} or {LLONG_MIN}, and {LONG_MAX} or {LLONG_MAX} are returned
on error and are also valid returns on success, an application wishing to
check for error situations should set errno to 0, then call strtol() or strtoll(
), then check errno.


RETURN VALUE

Upon successful completion, these functions shall return the converted value,
if any. If no conversion could be performed, 0 shall be returned [CX]  and
errno may be set to [EINVAL].

If the correct value is outside the range of representable values, {LONG_MIN}, {
LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall be returned (according to the
sign of the value), and errno set to [ERANGE].


ERRORS

    These functions shall fail if:

    [ERANGE]

        The value to be returned is not representable.

    These functions may fail if:

    [EINVAL]

        [CX] The value of base is not supported.
*/
#define mytype LLongT
#define mymin min_LLongT
#define mymax max_LLongT
#define over_pos OverPos_LL
#define over_neg OverNeg_LL
#define mayneg true
#define mytype_size sizeof_LLongT
#define a_name "strtoll"
#define model strtoll_model
#define spec strtoll_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOLL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOLL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOLL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOLL_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    strtoq -- convert string value to a long or quad_t integer

SYNOPSIS

    #include <sys/types.h>
    #include <stdlib.h>
    #include <limits.h>

    long long strtoq(const char * nptr, char * * endptr, int base);

DESCRIPTION

    strtoq() converts the string nptr to a quadt value. The conversion is done
    according to the given base, which shall be between 2 and 36 inclusive, or
    be the special value 0.

    nptr may begin with an arbitrary amount of white space (as determined by
    isspace()), followed by a single optional + or - sign character. If base is
    0 or 16, the string may then include a 0x prefix, and the number will be
    read in base 16; otherwise, a 0 base is taken as 10 (decimal), unless the
    next character is 0, in which case it is taken as 8 (octal).

    The remainder of the string is converted to a long value in the obvious
    manner, stopping at the first character which is not a valid digit in the
    given base. (In bases above 10, the letter A in either upper or lower case
    represents 10, B represents 11, and so forth, with Z representing 35.)

RETURN VALUE

    strtoq() returns the result of the conversion, unless the value would
    underflow or overflow. If an underflow occurs, strtoq() returns QUAD_MIN. If
    an overflow occurs, strtoq() returns QUAD_MAX. In both cases, the global
    variable errno is set to ERANGE.

ERRORS

    [ERANGE]
        The given string was out of range; the value converted has been
        clamped.
*/
#define mytype LLongT
#define mymin min_LLongT
#define mymax max_LLongT
#define over_pos OverPos_Q
#define over_neg OverNeg_Q
#define mayneg true
#define mytype_size sizeof_LLongT
#define a_name "strtoq"
#define model strtoq_model
#define spec strtoq_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOQ_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOQ_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOQ_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOQ_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strtoul, strtoull - convert a string to an unsigned long

SYNOPSIS

    #include <stdlib.h>

    unsigned long strtoul(const char *restrict str,

        char **restrict endptr, int base);

    unsigned long long strtoull(const char *restrict str,

        char **restrict endptr, int base);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

These functions shall convert the initial portion of the string pointed to by
str to a type unsigned long and unsigned long long representation,
respectively. First, they decompose the input string into three parts:

An initial, possibly empty, sequence of white-space characters (as specified by
isspace())

A subject sequence interpreted as an integer represented in some radix
determined by the value of base

A final string of one or more unrecognized characters, including the
terminating null byte of the input string

Then they shall attempt to convert the subject sequence to an unsigned integer,
and return the result.

If the value of base is 0, the expected form of the subject sequence is that of
a decimal constant, octal constant, or hexadecimal constant, any of which may
be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero
digit, and consists of a sequence of decimal digits. An octal constant
consists of the prefix '0' optionally followed by a sequence of the digits '0'
to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed
by a sequence of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' )
with values 10 to 15 respectively.

If the value of base is between 2 and 36, the expected form of the subject
sequence is a sequence of letters and digits representing an integer with the
radix specified by base, optionally preceded by a '+' or '-' sign. The letters
from 'a' (or 'A' ) to 'z' (or 'Z' ) inclusive are ascribed the values 10 to 35;
only letters whose ascribed values are less than that of base are permitted.
If the value of base is 16, the characters 0x or 0X may optionally precede the
sequence of letters and digits, following the sign if present.

The subject sequence is defined as the longest initial subsequence of the input
string, starting with the first non-white-space character that is of the
expected form. The subject sequence shall contain no characters if the input
string is empty or consists entirely of white-space characters, or if the
first non-white-space character is other than a sign or a permissible letter or
digit.

If the subject sequence has the expected form and the value of base is 0, the
sequence of characters starting with the first digit shall be interpreted as
an integer constant. If the subject sequence has the expected form and the
value of base is between 2 and 36, it shall be used as the base for conversion,
ascribing to each letter its value as given above. If the subject sequence
begins with a minus sign, the value resulting from the conversion shall be
negated. A pointer to the final string shall be stored in the object pointed
to by endptr, provided that endptr is not a null pointer.

In other than the C [CX]  or POSIX locales, other implementation-defined
subject sequences may be accepted.

If the subject sequence is empty or does not have the expected form, no
conversion shall be performed; the value of str shall be stored in the object
pointed to by endptr, provided that endptr is not a null pointer.

[CX] The strtoul() function shall not change the setting of errno if
successful.

Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and are also valid
returns on success, an application wishing to check for error situations
should set errno to 0, then call strtoul() or strtoull(), then check errno.


RETURN VALUE

Upon successful completion, these functions shall return the converted value,
if any. If no conversion could be performed, 0 shall be returned [CX]  and
errno may be set to [EINVAL]. If the correct value is outside the range of
representable values, {ULONG_MAX} or {ULLONG_MAX} shall be returned and errno
set to [ERANGE].


ERRORS

    These functions shall fail if:

    [EINVAL]

        [CX] The value of base is not supported.

    [ERANGE]

        The value to be returned is not representable.

    These functions may fail if:

    [EINVAL]

        [CX] No conversion could be performed.
*/
#define mytype ULongT
#define mymin 0
#define mymax max_ULongT
#define over_pos OverPos_UL
#define over_neg OverNeg_UL
#define mayneg false
#define mytype_size sizeof_LongT
#define a_name "strtoul"
#define model strtoul_model
#define spec strtoul_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOUL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOUL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOUL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOUL_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strtoul, strtoull - convert a string to an unsigned long

SYNOPSIS

    #include <stdlib.h>

    unsigned long strtoul(const char *restrict str,

        char **restrict endptr, int base);

    unsigned long long strtoull(const char *restrict str,

        char **restrict endptr, int base);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

These functions shall convert the initial portion of the string pointed to by
str to a type unsigned long and unsigned long long representation,
respectively. First, they decompose the input string into three parts:

An initial, possibly empty, sequence of white-space characters (as specified by
isspace())

A subject sequence interpreted as an integer represented in some radix
determined by the value of base

A final string of one or more unrecognized characters, including the
terminating null byte of the input string

Then they shall attempt to convert the subject sequence to an unsigned integer,
and return the result.

If the value of base is 0, the expected form of the subject sequence is that of
a decimal constant, octal constant, or hexadecimal constant, any of which may
be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero
digit, and consists of a sequence of decimal digits. An octal constant
consists of the prefix '0' optionally followed by a sequence of the digits '0'
to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed
by a sequence of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' )
with values 10 to 15 respectively.

If the value of base is between 2 and 36, the expected form of the subject
sequence is a sequence of letters and digits representing an integer with the
radix specified by base, optionally preceded by a '+' or '-' sign. The letters
from 'a' (or 'A' ) to 'z' (or 'Z' ) inclusive are ascribed the values 10 to 35;
only letters whose ascribed values are less than that of base are permitted.
If the value of base is 16, the characters 0x or 0X may optionally precede the
sequence of letters and digits, following the sign if present.

The subject sequence is defined as the longest initial subsequence of the input
string, starting with the first non-white-space character that is of the
expected form. The subject sequence shall contain no characters if the input
string is empty or consists entirely of white-space characters, or if the
first non-white-space character is other than a sign or a permissible letter or
digit.

If the subject sequence has the expected form and the value of base is 0, the
sequence of characters starting with the first digit shall be interpreted as
an integer constant. If the subject sequence has the expected form and the
value of base is between 2 and 36, it shall be used as the base for conversion,
ascribing to each letter its value as given above. If the subject sequence
begins with a minus sign, the value resulting from the conversion shall be
negated. A pointer to the final string shall be stored in the object pointed
to by endptr, provided that endptr is not a null pointer.

In other than the C [CX]  or POSIX locales, other implementation-defined
subject sequences may be accepted.

If the subject sequence is empty or does not have the expected form, no
conversion shall be performed; the value of str shall be stored in the object
pointed to by endptr, provided that endptr is not a null pointer.

[CX] The strtoul() function shall not change the setting of errno if
successful.

Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and are also valid
returns on success, an application wishing to check for error situations
should set errno to 0, then call strtoul() or strtoull(), then check errno.


RETURN VALUE

Upon successful completion, these functions shall return the converted value,
if any. If no conversion could be performed, 0 shall be returned [CX]  and
errno may be set to [EINVAL]. If the correct value is outside the range of
representable values, {ULONG_MAX} or {ULLONG_MAX} shall be returned and errno
set to [ERANGE].

ERRORS

    These functions shall fail if:

    [EINVAL]

        [CX] The value of base is not supported.

    [ERANGE]

        The value to be returned is not representable.

    These functions may fail if:

    [EINVAL]

        [CX] No conversion could be performed.
*/
#define mytype ULLongT
#define mymin 0
#define mymax max_ULLongT
#define over_pos OverPos_ULL
#define over_neg OverNeg_ULL
#define mayneg false
#define mytype_size sizeof_LLongT
#define a_name "strtoull"
#define model strtoull_model
#define spec strtoull_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOULL_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOULL_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOULL_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOULL_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strtoimax, strtoumax - convert string to integer type

SYNOPSIS

    #include <inttypes.h>

    intmax_t strtoimax(const char *restrict nptr, char **restrict endptr,

        int base);

    uintmax_t strtoumax(const char *restrict nptr, char **restrict endptr,

        int base);

DESCRIPTION

[CX] The functionality described on this reference page is aligned with the
ISO C standard. Any conflict between the requirements described here and the
ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
the ISO C standard.

These functions shall be equivalent to the strtol(), strtoll(), strtoul(), and
strtoull() functions, except that the initial portion of the string shall be
converted to intmax_t and uintmax_t representation, respectively.


RETURN VALUE

These functions shall return the converted value, if any.

If no conversion could be performed, zero shall be returned.

If the correct value is outside the range of representable values, {INTMAX_MAX},
{INTMAX_MIN}, or {UINTMAX_MAX} shall be returned (according to the return type
and sign of the value, if any), and errno shall be set to [ERANGE].


ERRORS

    These functions shall fail if:

    [ERANGE]

        The value to be returned is not representable.

    These functions may fail if:

    [EINVAL]

        The value of base is not supported.
*/
#define mytype UIntMaxT
#define mymin 0
#define mymax max_UIntMaxT
#define over_pos OverPos_UIM
#define over_neg OverNeg_UIM
#define mayneg false
#define mytype_size sizeof_LLongT
#define a_name "strtoumax"
#define model strtoumax_model
#define spec strtoumax_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOUMAX_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOUMAX_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOUMAX_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOUMAX_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    strtouq -- convert a string to an unsigned long long

SYNOPSIS

    #include <sys/types.h>
    #include <stdlib.h>
    #include <limits.h>

    unsigned long long strtouq(const char * nptr, char * * endptr, int base);

DESCRIPTION

    strtouq() converts the string nptr to an unsigned long long value. The
    conversion is done according to the given base, which shall be between 2 and
    36 inclusive, or be the special value 0.

    nptr may begin with an arbitrary amount of white space (as determined by
    isspace()), followed by a single optional + or - sign character. If base is
    0 or 16, the string may then include a 0x prefix, and the number will be
    read in base 16; otherwise, a 0 base is taken as 10 (decimal), unless the
    next character is 0, in which case it is taken as 8 (octal).

    The remainder of the string is converted to an unsigned long value in the
    obvious manner, stopping at the end of the string or at the first character
    that does not produce a valid digit in the given base. (In bases above 10,
    the letter A in either upper or lower case represents 10, B represents 11,
    and so forth, with Z representing 35.)

RETURN VALUE

    On success, strtouq() returns either the result of the conversion or, if
    there was a leading minus sign, the negation of the result of the
    conversion, unless the original (non-negated) value would overflow. In the
    case of an overflow the function returns UQUAD_MAX and the global variable
    errno is set to ERANGE.

ERRORS

    [ERANGE]
        The given string was out of range; the value converted has been clamped.
*/
#define mytype ULLongT
#define mymin 0
#define mymax max_ULLongT
#define over_pos OverPos_UQ
#define over_neg OverNeg_UQ
#define mayneg false
#define mytype_size sizeof_LLongT
#define a_name "strtouq"
#define model strtouq_model
#define spec strtouq_spec
#define FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES POSIX_STRTOUQ_HAS_EXTRA_ERROR_CODES
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE POSIX_STRTOUQ_HAS_EXTRA_CONDITION_ON_ERANGE
#define FUNC_ERR_ID_FAILS_WITH_EINVAL POSIX_STRTOUQ_FAILS_WITH_EINVAL
#define FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL POSIX_STRTOUQ_HAS_EXTRA_CONDITION_ON_EINVAL
#include "strto_model.seh"
#include "strto_spec.seh"

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
bool isEINVAL_strtoll(IntT base)
{
    return !(base>=0 && base<=36 && base!=1);
}
bool isSpace(CharT ch)
{
    return ch==' ' || ch=='\t' || ch=='\n';
}
bool firstCharNotMatch_strtol(CharT wch, IntT base)
{
    CharT ch=tolower(wch);//??

    DUMP("ch==%c\n", ch);

    return  isalpha(ch) && ch-'a'>=base
        ||  ch>='0' && ch<='9' && ch-'0'>=base && base!=0;
}
IntT dec2Int_CharT(CharT wch)
{
    return wch>= '0' && wch<= '9' ? ( wch)-'0'
        :  -1;
}
IntT oct2Int_CharT(CharT wch)
{
    return wch>= '0' && wch<= '7' ? ( wch)-'0'
        :  -1;
}
IntT hex2Int_CharT(CharT wch)
{
    return wch>= '0' && wch<= '9' ? ( wch)-'0'
        :  wch>= 'a' && wch<= 'f' ? ( wch)-'a'+10
        :  wch>= 'A' && wch<= 'F' ? ( wch)-'A'+10
        :  -1;
}
IntT other2Int_CharT(CharT wch)
{
    return wch>= '0' && wch<= '9' ? ( wch)-'0'
        :  wch>= 'a' && wch<= 'z' ? ( wch)-'a'+10
        :  wch>= 'A' && wch<= 'Z' ? ( wch)-'A'+10
        :  -1;
}
LongT char2_a64l(CharT ch)
{
    if(ch=='.')
        return 0;
    if(ch=='/')
        return 1;
    if(ch>='0' && ch<='9')
        return ch-'0'+2;
    if(ch>='A' && ch<='Z')
        return ch-'A'+12;
    if(ch>='a' && ch<='z')
        return ch-'a'+38;

    return -1;
}
