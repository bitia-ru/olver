/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "util/conversion/wtoken_model.seh"
#include <atl/integer.h>

#include "config/interpretation.seh"
#include "fs/meta/meta_config.h"
#include "data/errno_model.seh"

#pragma SEC subsystem conversion "util.conversion"



/* 
   The group of functions 'util.conversion.wtoken' consists of: 
       wcstok [2]
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved. 

NAME 

    wcstok - split a wide-character string into tokens 

SYNOPSIS 

    #include <wchar.h>

    wchar_t *wcstok(wchar_t *restrict ws1, const wchar_t *restrict ws2,

    wchar_t **restrict ptr);

DESCRIPTION 

    [CX] The functionality described on this reference page is aligned with the 
    ISO C standard. Any conflict between the requirements described here and
    the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard. 

    A sequence of calls to wcstok() shall break the wide-character string
    pointed to by ws1 into a sequence of tokens, each of which shall be
    ws2ited by a wide-character code from the wide-character string pointed
    to by ws2. The ptr argument points to a caller-provided wchar_t pointer
    into which the wcstok() function shall store information necessary for it
    to continue scanning the same wide-character string. 

    The first call in the sequence has ws1 as its first argument, and is
    followed by calls with a null pointer as their first argument.
    The separator string pointed to by ws2 may be different from call to call. 

    The first call in the sequence shall search the wide-character string
    pointed to by ws1 for the first wide-character code that is not contained
    in the current separator string pointed to by ws2. If no such
    wide-character code is found, then there are no tokens in the
    wide-character string pointed to by ws1 and wcstok() shall return a null
    pointer. If such a wide-character code is found, it shall be the start of
    the first token. 

    The wcstok() function shall then search from there for a wide-character
    code that is contained in the current separator string. If no such
    wide-character code is found, the current token extends to the end of
    the wide-character string pointed to by ws1, and subsequent searches for a
    token shall return a null pointer. If such a wide-character code is found,
    it shall be overwritten by a null wide character, which terminates the
    current token. The wcstok() function shall save a pointer to the following
    wide-character code, from which the next search for a token shall start. 

    Each subsequent call, with a null pointer as the value of the first
    argument, shall start searching from the saved pointer and behave as
    described above. 

    The implementation shall behave as if no function calls wcstok(). 

RETURN VALUE 

    Upon successful completion, the wcstok() function shall return a pointer
    to the first wide-character code of a token. Otherwise, if there is no
    token, wcstok() shall return a null pointer. 

ERRORS 

    No errors are defined.
*/

specification
StringTPtr wcstok_spec( CallContext context, StringTPtr ws1,
                                        StringTPtr ws2, StringTPtr* ptr)
{
    WString* ws2_str;
    StringTPtr buff=NULL_VoidTPtr;
    WCharArray* byte_pre=NULL;
    
    pre
    {
        REQ("", "[Implicit precondition]", !isNULL_VoidTPtr(ws2));        
        ws2_str=readWString_VoidTPtr(ws2);
    }
    coverage C
    {
        if(isNULL_VoidTPtr(ws1))
        {
            buff=*ptr;
            if(!isNULL_VoidTPtr(buff))
                byte_pre=readWCharArray_MemoryBlock(getMemoryBlock(buff));
            DUMP("ws1==NULL: buff==%d\n", buff.address);
            return { Null_String, "Taking token from ptr" };
        }
        else
        {
            buff=ws1;
            byte_pre=readWCharArray_MemoryBlock(getMemoryBlock(buff));
            DUMP("ws1!=NULL: buff==%d\n", buff.address);
            return { New_String, "Getting new string" };
        }
    }
    post
    {
        StringTPtr ret=wcstok_spec;
        MemoryBlock* mb;
        WCharArray* byte_past;
        IntT begin;
        WString* ret_str;

        //Implemented in scenario
        /*
         * The first call in the sequence has ws1 as its first argument, and
         * is followed by calls with a null pointer as their first argument.
         * 
         */
        IMPLEMENT_REQ("wcstok.03");
        /*
         * The separator string pointed to by ws2 may be different from call
         * to call.
         * 
         */
        IMPLEMENT_REQ("wcstok.04");
        /*
         * Each subsequent call, with a null pointer as the value of the first
         * argument, shall start searching from the saved pointer and behave
         * as described above.
         * 
         */
        IMPLEMENT_REQ("wcstok.12");
        

        if(WNoToken(context, buff, ws2_str))
        {            
            /*
             * If no such wide-character code is found, then there are no
             * tokens in the wide-character string pointed to by ws1 and
             * wcstok() shall return a null pointer.
             */
            /*
             * Otherwise, if there is no token, wcstok() shall return a null
             * pointer.
             * 
             */
            REQ("wcstok.06;wcstok.15", 
                "If no such wide-character code is found, return null pointer", 
                isNULL_VoidTPtr(ret));
            DUMP("No tokens(post)\n");
            return true;
        }

        REQ("", "Non-null return value", !isNULL_VoidTPtr(ret));
        DUMP("Non-null return value\n");

        ret_str=readWString_VoidTPtr(ret);
        mb=getMemoryBlock(buff);
        byte_past=readWCharArray_MemoryBlock(mb);
        DUMP("buff.address - mb->address.address==%d\n",
            (IntT)(buff.address - mb->address.address));
        begin=(buff.address - mb->address.address)/sizeof(WCharT);
        

        /*
         * A sequence of calls to wcstok() shall break the wide-character
         * string pointed to by ws1 into a sequence of tokens, each of which
         * shall be ws2ited by a wide-character code from the wide-character
         * string pointed to by ws2.
         * 
         */
        REQ("wcstok.01", "Only correct changes of the ptr",
                WCorrectBuffChange(byte_pre, byte_past, begin, ws2_str));
        
        DUMP("Only correct changes of the ptr\n");

        /*
         * The wcstok() function shall save a pointer to the following
         * wide-character code, from which the next search for a token shall
         * start.
         */
        REQ("wcstok.11", "Checking ptr address correctness",
            checkWNewPtrBegin(byte_pre, begin, ws2_str, ptr, mb));

        /*
         * If such a wide-character code is found, it shall be the start of
         * the first token.
         */
        /*
         * Upon successful completion, the wcstok() function shall return a 
         * pointer to the first wide-character code of a token. 
         */
        REQ("wcstok.07;wcstok.14", "Checking ret address correctness",
                mb->address.address
                +
                sizeof(WCharT)*WRetBeginPos(byte_pre, begin, ws2_str)
                ==
                ret.address);

        DUMP("Model's return shall be equal to real return\n");

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
bool WCorrectBuffChange(WCharArray* byte_pre, WCharArray* byte_past,
                        IntT begin, WString* ws2_str)
{
    Set* mp=create_Set(&type_WCharTObj);
    IntT i, j;

    for(i=0;i<length_WString(ws2_str);i++)
        add_Set(mp, create_WCharTObj(wcharAt_WString(ws2_str, i)));
    
    i=0;    
    while(i<begin &&        wcharAt_WCharArray(byte_pre, i)
                        ==  wcharAt_WCharArray(byte_past, i))
        i++;

    if(i<begin)
    {
        DUMP("Err1: begin==%d, i==%d\n", begin, i);
        return false;//ptr has changes in part, that should remain unchanged
    }
    /*
     * The first call in the sequence shall search the wide-character string
     * pointed to by ws1 for the first wide-character code that is not
     * contained in the current separator string pointed to by ws2.
     */
    IMPLEMENT_REQ("wcstok.05");

    while(wcharAt_WCharArray(byte_pre, i)!=NULL_WCharT &&
        contains_Set(mp,  create_WCharTObj(wcharAt_WCharArray(byte_pre, i)))
        && wcharAt_WCharArray(byte_pre, i)==wcharAt_WCharArray(byte_past, i))
        i++;

    if( wcharAt_WCharArray(byte_pre, i)==NULL_WCharT)
    {
        DUMP("Err2: no token\n");
        return false; //No token checked before calling this function
    }

    if(wcharAt_WCharArray(byte_pre, i)!=wcharAt_WCharArray(byte_past, i))
    {
        DUMP("Err3: illegal ptr change");
        return false;//ptr has changes in part, that should remain unchanged
    }

    /*
     * The wcstok() function shall then search from there for a wide-character
     * code that is contained in the current separator string.
     */
    IMPLEMENT_REQ("wcstok.08");
    j=i;
    while(wcharAt_WCharArray(byte_pre, i)!=NULL_WCharT &&
        !contains_Set(mp,  create_WCharTObj(wcharAt_WCharArray(byte_pre, i)))
        && wcharAt_WCharArray(byte_pre, i)==wcharAt_WCharArray(byte_past, i))
        i++;

    if(wcharAt_WCharArray(byte_past, i)!=NULL_WCharT)
    {
        DUMP("Err4: %lc*\n", wcharAt_WCharArray(byte_past, i));
        return false;//End of token doesn't match with expected
    }

    /*
     * If no such wide-character code is found, the current token extends to
     * the end of the wide-character string pointed to by ws1, and subsequent
     * searches for a token shall return a null pointer.
     */
    /*
     * If such a wide-character code is found, it shall be overwritten by a
     * null wide character, which terminates the current token.
     */
    IMPLEMENT_REQ("wcstok.09;wcstok.10");
    if(wcharAt_WCharArray(byte_pre, i)==NULL_WCharT)
        return true;

    i++;

    while(wcharAt_WCharArray(byte_pre, i)!=NULL_WCharT &&
        wcharAt_WCharArray(byte_pre, i)==wcharAt_WCharArray(byte_past, i))
        i++;
    
    return wcharAt_WCharArray(byte_pre, i)==NULL_WCharT;
}
IntT checkWNewPtrBegin(WCharArray* byte_pre, IntT begin, WString* ws2_str,
                       StringTPtr* ptr, MemoryBlock* mb)
{
    Set* mp=create_Set(&type_WCharTObj);
    IntT i;

    for(i=0;i<length_WString(ws2_str);i++)
        add_Set(mp, create_WCharTObj(wcharAt_WString(ws2_str, i)));

    i=begin;
    while(  wcharAt_WCharArray(byte_pre, i)!=NULL_WCharT
            &&
            contains_Set(mp,
                create_WCharTObj(
                    wcharAt_WCharArray(byte_pre, i) ) ) )
        i++;
    while(  wcharAt_WCharArray(byte_pre, i)!=NULL_WCharT
            &&
            !contains_Set(mp,
                create_WCharTObj(
                    wcharAt_WCharArray(byte_pre, i) ) ) )
        i++;

    if(isNULL_VoidTPtr(*ptr))
        DUMP("ptr==NULL\n");
    else
        DUMP("ptr.address==%d", (IntT)ptr->address);
    DUMP("mb==%d, i+1==%d", mb->address.address, i+1);

    if(wcharAt_WCharArray(byte_pre, i)==NULL_WCharT)
        return isNULL_VoidTPtr(*ptr);
    else
        return ptr->address==mb->address.address+sizeof(WCharT)*(i+1);
}

IntT WRetBeginPos(WCharArray* byte_pre, IntT begin, WString* ws2_str)
{
    Set* mp=create_Set(&type_WCharTObj);
    IntT i;

    for(i=0;i<length_WString(ws2_str);i++)
        add_Set(mp, create_WCharTObj(wcharAt_WString(ws2_str, i)));

    i=begin;
    while(  wcharAt_WCharArray(byte_pre, i)!=NULL_WCharT
            &&
            contains_Set(mp,
                create_WCharTObj(
                    wcharAt_WCharArray(byte_pre, i) ) ) )
        i++;

    return i;
}
bool WNoToken(CallContext context, StringTPtr ptr, WString* ws2_str)
{
    WCharArray* byte_arr;
    MemoryBlock* mb;
    Set* mp=create_Set(&type_WCharTObj);
    IntT i;

    if(isNULL_VoidTPtr(ptr))
        return true;
    
    mb=getMemoryBlock(ptr);

    byte_arr=readWCharArray_MemoryBlock(mb);

     for(i=0;i<length_WString(ws2_str);i++)
        add_Set(mp, create_WCharTObj(wcharAt_WString(ws2_str, i)));

    i=(ptr.address - mb->address.address)/sizeof(WCharT);
    
    while(  wcharAt_WCharArray(byte_arr, i)!=NULL_WCharT
            &&
            contains_Set(mp,
                create_WCharTObj(
                    wcharAt_WCharArray(byte_arr, i) ) ) )
        i++;
    
    return wcharAt_WCharArray(byte_arr, i)==NULL_WCharT;
}
