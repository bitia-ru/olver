/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
specification
mytype spec( CallContext context, StringTPtr nptr,
                    StringTPtr* endptr, IntT base, ErrorCode* errno)
{
    ErrorCode* errno_pre=clone(errno);
    ErrorCode* my_errno=requestErrorCode();
    StringTPtr exp_end;

    pre
    {
//        REQ("", "Implement req", endptr!=NULL);
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        mytype ret=model(context, nptr, endptr, base, my_errno, &exp_end);

        //Implemented in agent
        /*
         * Since 0, {LONG_MIN} or {LLONG_MIN} and {LONG_MAX} or {LLONG_MAX} are returned 
         * on error and are also valid returns on success, an application wishing to 
         * check for error situations should set errno to 0, then call strtol() or strtoll( 
         * ), then check errno. 
         * 
         */
        /*
         * Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and 0 is also a 
         * valid return on success, an application wishing to check for error situations 
         * should set errno to 0, then call strtoul() or strtoull(), then check errno. 
         */
        
        IMPLEMENT_REQ("strtol.16;strtoul.16;__strtol_internal.16;__strtoul_internal.16;__strtoll_internal.16;__strtoull_internal.16;strtoll.16;strtoull.16;strtoq.16;strtouq.16;strtoimax.16;strtoumax.16");
        /*
         * If the subject sequence is empty or does not have the expected form, no 
         * conversion shall be performed; the value of nptr shall be stored in the object 
         * pointed to by endptr, provided that endptr is not a null pointer.
         * 
         */
        REQ("strtol.14;strtoul.14;__strtol_internal.14;__strtoul_internal.14;__strtoll_internal.14;__strtoull_internal.14;strtoll.14;strtoull.14;strtoq.14;strtouq.14;strtoimax.14;strtoumax.14", "", *my_errno==SUT_EINVAL ? equals_VoidTPtr(exp_end, nptr) : true);

        if(*my_errno==SUT_ERANGE)
        {
            /*
             * If the correct value is outside the range of representable values, {LONG_MIN}, { 
             * LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall be returned (according to the 
             * sign of the value), and errno set to [ERANGE].
             * 
             */
            /*
             * If the correct value is outside the range of representable values, {ULONG_MAX} 
             * or {ULLONG_MAX} respectively shall be returned and errno set to [ERANGE].
             */
            /*
             * If the correct value is outside the range of representable values, {INTMAX_MAX} 
             * , {INTMAX_MIN}, or {UINTMAX_MAX} shall be returned (according to the return 
             * type and sign of the value, if any), and errno shall be set to [ERANGE].
             */
            REQ("strtol.19;strtoul.19;__strtol_internal.19;__strtoul_internal.19;__strtoll_internal.19;__strtoull_internal.19;strtoll.19;strtoull.19;strtoq.19;strtouq.19;strtoimax.19;strtoumax.19", "ret==wctol_spec, checking for LONG_MIN, LONG_MAX, etc", ret==spec);
        }

        if(*my_errno==SUT_EINVAL)
        {
            /*
             * If no conversion could be performed, 0 shall be returned [CX]  and errno may 
             * be set to indicate the error. 
             * 
             */
            /*
             * If no conversion could be performed, zero shall be returned.
             */
            REQ("strtol.18;strtoul.18;__strtol_internal.18;__strtoul_internal.18;__strtoll_internal.18;__strtoull_internal.18;strtoll.18;strtoull.18;strtoq.18;strtouq.18;strtoimax.18;strtoumax.18", "No conversion", ret==spec);
        }

        ERROR_BEGIN(POSIX_STRTOL, "strtol.20.01;strtoul.20.01;__strtol_internal.20.01;__strtoul_internal.20.01;__strtoll_internal.20.01;__strtoull_internal.20.01;strtoll.20.01;strtoull.20.01;strtoq.20.01;strtouq.20.01;strtoimax.20.01;strtoumax.20.01", *errno!=SUT_EOK, *errno)
        /*
         * These functions shall fail if:
         * 
         * [ERANGE] 
         * 
         * The value to be returned is not representable. 
         * 
         */
        
         ERROR_SHALL(POSIX_STRTOL, ERANGE, "strtol.20.01;strtoul.20.01;__strtol_internal.20.01;__strtoul_internal.20.01;__strtoll_internal.20.01;__strtoull_internal.20.01;strtoll.20.01;strtoull.20.01;strtoq.20.01;strtouq.20.01;strtoimax.20.01;strtoumax.20.01", *my_errno==SUT_ERANGE)

        /*
         * These functions may fail if:
         * 
         * [EINVAL] 
         * 
         * [CX] No conversion could be performed. 
         * 
         */
         ERROR_MAY(POSIX_STRTOL, EINVAL, "strtol.21.01;strtoul.21.01;__strtol_internal.21.01;__strtoul_internal.21.01;__strtoll_internal.21.01;__strtoull_internal.21.01;strtoll.21.01;strtoull.21.01;strtoq.21.01;strtouq.21.01;strtoimax.21.01;strtoumax.21.01", *my_errno==SUT_EINVAL)

        ERROR_END()

        DUMP("\n\nnptr==%d, endptr==%d, exp_end==%d\n\n", (IntT)nptr.address, (endptr!=NULL) ? (IntT)endptr->address : 0, (IntT)exp_end.address);
        if(endptr!=NULL)
        {
            /*
             * A pointer to the final wide-character string shall be stored in the object 
             * pointed to by endptr, provided that endptr is not a null pointer.
             * 
             */
            REQ("strtol.12;strtoul.12;__strtol_internal.12;__strtoul_internal.12;__strtoll_internal.12;__strtoull_internal.12;strtoll.12;strtoull.12;strtoq.12;strtouq.12;strtoimax.12;strtoumax.12", "exp_end==endptr", exp_end.address==endptr->address);
        }
        /*
         * [CX] These functions shall not change the setting of errno if successful.
         * 
         */
        REQ("strtol.15;strtoul.15;__strtol_internal.15;__strtoul_internal.15;__strtoll_internal.15;__strtoull_internal.15;strtoll.15;strtoull.15;strtoq.15;strtouq.15;strtoimax.15;strtoumax.15", "", *errno==*errno_pre);

        /*
         * In other than the C [CX]  or POSIX locales, other implementation-defined 
         * subject sequences may be accepted.
         * 
         */
        REQ("strtol.13;strtoul.13;__strtol_internal.13;__strtoul_internal.13;__strtoll_internal.13;__strtoull_internal.13;strtoll.13;strtoull.13;strtoq.13;strtouq.13;strtoimax.13;strtoumax.13", "", TODO_REQ());

        /*
         * Upon successful completion, these functions shall return the converted value, 
         * if any.
         * 
         */
        /*
         * These functions shall convert the initial portion of the wide-character string 
         * pointed to by nptr to long, long long, unsigned long, and unsigned long long 
         * representation, respectively.
         * 
         */
        /*
         * The strtoul() and strtoull() functions shall convert the initial portion of the 
         * wide-character string pointed to by nptr to unsigned long and unsigned long 
         * long representation, respectively.
         */
        /*
         * These functions shall return the converted value, if any.
         */
        REQ("strtol.01;strtoul.01;__strtol_internal.01;__strtoul_internal.01;__strtoll_internal.01;__strtoull_internal.01;strtoll.01;strtoull.01;strtoq.01;strtouq.01;strtoimax.01;strtoumax.01;strtol.17;strtoul.17;__strtol_internal.17;__strtoul_internal.17;__strtoll_internal.17;__strtoull_internal.17;strtoll.17;strtoull.17;strtoq.17;strtouq.17;strtoimax.17;strtoumax.17", "ret==wctol_spec", ret==spec);

        return true;
    }
}

bool over_pos(mytype par, mytype mul, mytype m, mytype add)
{
    mytype tmp=par;

    while(--mul)
    {
        if(tmp>m-par)
            return true;
        tmp+=par;
    }
    if(tmp>m-add)
        return true;
   
    return false;
}
bool over_neg(mytype par, mytype mul, mytype m, mytype add)
{
    mytype tmp=par;

    while(--mul)
    {
        if(tmp<m-par)
            return true;
        tmp+=par;
    }
    if(tmp<m-add)
        return true;

    return false;
}
mytype model( CallContext context, StringTPtr nptr,
    StringTPtr* endptr, IntT base, ErrorCode* my_errno, StringTPtr* exp_end)
{
    mytype ret=0;
    CString* data=readCString_VoidTPtr(nptr);
    IntT i=0, size=length_CString(data);
    bool neg=false;
    IntT sh;

    /*
     * First, they shall decompose the input string into three parts:
     * 
     * An initial, possibly empty, sequence of white-space wide-character codes (as 
     * specified by iswspace())
     * 
     */
    IMPLEMENT_REQ("strtol.02.01;strtoul.02.01;__strtol_internal.02.01;__strtoul_internal.02.01;__strtoll_internal.02.01;__strtoull_internal.02.01;strtoll.02.01;strtoull.02.01;strtoq.02.01;strtouq.02.01;strtoimax.02.01;strtoumax.02.01");
    while(i<size && isWideSpace(charAt_CString(data, i)))
        i++;

    /*
     * First, they shall decompose the input string into three parts:
     * 
     * A subject sequence interpreted as an integer represented in some radix 
     * determined by the value of base
     * 
     */
    IMPLEMENT_REQ("strtol.02.02;strtoul.02.02;__strtol_internal.02.02;__strtoul_internal.02.02;__strtoll_internal.02.02;__strtoull_internal.02.02;strtoll.02.02;strtoull.02.02;strtoq.02.02;strtouq.02.02;strtoimax.02.02;strtoumax.02.02");
    /*
     * The subject sequence is defined as the longest initial subsequence of the input 
     * wide-character string, starting with the first non-white-space wide-character 
     * code that is of the expected form.
     * 
     */
    IMPLEMENT_REQ("strtol.07;strtoul.07;__strtol_internal.07;__strtoul_internal.07;__strtoll_internal.07;__strtoull_internal.07;strtoll.07;strtoull.07;strtoq.07;strtouq.07;strtoimax.07;strtoumax.07");

    /*
     * Then they shall attempt to convert the subject sequence to an integer, and 
     * return the result.
     * 
     */
    IMPLEMENT_REQ("strtol.03;strtoul.03;__strtol_internal.03;__strtoul_internal.03;__strtoll_internal.03;__strtoull_internal.03;strtoll.03;strtoull.03;strtoq.03;strtouq.03;strtoimax.03;strtoumax.03");

    if( i==size ||
        firstCharNotMatch_strtol(charAt_CString(data, i), base)
        ||  !(base>=0 && base<=36 && base!=1))
    {
        /*
         * The subject sequence contains no wide-character codes if the input wide- 
         * character string is empty or consists entirely of white-space wide-character 
         * code, or if the first non-white-space wide-character code is other than a sign 
         * or a permissible letter or digit.
         * 
         */
        IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
        *exp_end=nptr;
        *my_errno=SUT_EINVAL;
        return 0;
    }
    if(charAt_CString(data, i)==(CharT)'+')
        i++;

    /*
     * If the subject sequence begins with a minus sign, the value resulting from the 
     * conversion shall be negated.
     * 
     */
    IMPLEMENT_REQ("strtol.11;strtoul.11;__strtol_internal.11;__strtoul_internal.11;__strtoll_internal.11;__strtoull_internal.11;strtoll.11;strtoull.11;strtoq.11;strtouq.11;strtoimax.11;strtoumax.11");
    if(charAt_CString(data, i)==(CharT)'-')
    {
        neg=true;
        i++;
    }

    if(base==0)
    {
        if(charAt_CString(data, i)<(CharT)'0' && charAt_CString(data, i)>(CharT)'9')
        {
            /*
             * The subject sequence contains no wide-character codes if the input wide- 
             * character string is empty or consists entirely of white-space wide-character 
             * code, or if the first non-white-space wide-character code is other than a sign 
             * or a permissible letter or digit.
             * 
             */
            IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
            *exp_end=nptr;
            *my_errno=SUT_EINVAL;
            return 0;            
        }

        /*
         * If the subject sequence has the expected form and base is 0, the sequence of 
         * wide-character codes starting with the first digit shall be interpreted as an 
         * integer constant.
         * 
         */
        IMPLEMENT_REQ("strtol.09;strtoul.09;__strtol_internal.09;__strtoul_internal.09;__strtoll_internal.09;__strtoull_internal.09;strtoll.09;strtoull.09;strtoq.09;strtouq.09;strtoimax.09;strtoumax.09");
        if(charAt_CString(data, i)>(CharT)'0')//Decimal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal 
             * constant, octal constant, or hexadecimal constant, any of which may be 
             * preceded by a '+' or '-' sign.
             * 
             * A decimal constant begins with a non-zero digit, and consists of a sequence of 
             * decimal digits.
             * 
             */
            IMPLEMENT_REQ("strtol.04.01;strtoul.04.01;__strtol_internal.04.01;__strtoul_internal.04.01;__strtoll_internal.04.01;__strtoull_internal.04.01;strtoll.04.01;strtoull.04.01;strtoq.04.01;strtouq.04.01;strtoimax.04.01;strtoumax.04.01");
            DUMP("Dec...\n");
            while(i<size && isDecimal(charAt_CString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 10, mymin, -dec2Int_CharT(charAt_CString(data, i))))
                    //if(-ret*10-dec2Int_CharT(charAt_CString(data, i))>=mymin)
                        ret=ret*10+dec2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 10, mymax, dec2Int_CharT(charAt_CString(data, i))))
                    //if(ret*10+dec2Int_CharT(charAt_CString(data, i))<=mymax)
                        ret=ret*10+dec2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }                
                }                
                i++;
            }
        }
        else
        if(     i+2<size
            &&
            (   charAt_CString(data, i+1)==(CharT)'x'
            ||  charAt_CString(data, i+1)==(CharT)'X')
            && isHexadecimal(charAt_CString(data, i+2))
            )//hexadecimal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal 
             * constant, octal constant, or hexadecimal constant, any of which may be 
             * preceded by a '+' or '-' sign.
             * 
             * A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence 
             * of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' ) with values 
             * 10 to 15 respectively.
             * 
             */
            IMPLEMENT_REQ("strtol.04.03;strtoul.04.03;__strtol_internal.04.03;__strtoul_internal.04.03;__strtoll_internal.04.03;__strtoull_internal.04.03;strtoll.04.03;strtoull.04.03;strtoq.04.03;strtouq.04.03;strtoimax.04.03;strtoumax.04.03");
            DUMP("Hex...\n");
            i+=2;
            while(i<size && isHexadecimal(charAt_CString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 16, mymin, -hex2Int_CharT(charAt_CString(data, i))))
                    //if(-ret*16-hex2Int_CharT(charAt_CString(data, i))>=mymin)
                        ret=ret*16+hex2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 16, mymax, hex2Int_CharT(charAt_CString(data, i))))
//                    if(ret*16+hex2Int_CharT(charAt_CString(data, i))<=mymax)
                        ret=ret*16+hex2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }                
                }

                i++;
            }
        }
        else//Octal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal 
             * constant, octal constant, or hexadecimal constant, any of which may be 
             * preceded by a '+' or '-' sign.
             * 
             * An octal constant consists of the prefix '0' optionally followed by a sequence 
             * of the digits '0' to '7' only.
             * 
             */
            IMPLEMENT_REQ("strtol.04.02;strtoul.04.02;__strtol_internal.04.02;__strtoul_internal.04.02;__strtoll_internal.04.02;__strtoull_internal.04.02;strtoll.04.02;strtoull.04.02;strtoq.04.02;strtouq.04.02;strtoimax.04.02;strtoumax.04.02");
            DUMP("Octal...\n");
            i++;
            while(i<size && isOctal(charAt_CString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 8, mymin, -oct2Int_CharT(charAt_CString(data, i))))
                    //if(-ret*8-oct2Int_CharT(charAt_CString(data, i))>=mymin)
                        ret=ret*8+oct2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 8, mymax, oct2Int_CharT(charAt_CString(data, i))))
                    //if(ret*8+oct2Int_CharT(charAt_CString(data, i))<=mymax)
                        ret=ret*8+oct2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }                
                }
                i++;
            }        
        }

        /*
         * First, they shall decompose the input string into three parts:
         * 
         * A final wide-character string of one or more unrecognized wide-character codes, 
         * including the terminating null wide-character code of the input wide-character 
         * string
         * 
         */
        IMPLEMENT_REQ("strtol.02.03;strtoul.02.03;__strtol_internal.02.03;__strtoul_internal.02.03;__strtoll_internal.02.03;__strtoull_internal.02.03;strtoll.02.03;strtoull.02.03;strtoq.02.03;strtouq.02.03;strtoimax.02.03;strtoumax.02.03");
        *exp_end=nptr;
        if(charAt_CString(data, i-1)!=(CharT)'+' && charAt_CString(data, i-1)!=(CharT)'-')
            exp_end->address+=i*sizeof(CharT);

        if(neg)
            ret=-ret;

        if(mayneg)
            return (mytype)convert_L(ret, mytype_size);

        return (mytype)convert_U(ret, mytype_size);
    }

    //base!=0
    DUMP("base==%d!!!!!!!!!!!!\n", base);
    if(base==16)
    {
        if(charAt_CString(data, i)<(CharT)'0' && charAt_CString(data, i)>(CharT)'9')
        {
            /*
             * The subject sequence contains no wide-character codes if the input wide- 
             * character string is empty or consists entirely of white-space wide-character 
             * code, or if the first non-white-space wide-character code is other than a sign 
             * or a permissible letter or digit.
             * 
             */
            IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
            *exp_end=nptr;
            *my_errno=SUT_EINVAL;
            return 0;            
        }

        if(     i+2<size
            &&
            (   charAt_CString(data, i+1)==(CharT)'x'
            ||  charAt_CString(data, i+1)==(CharT)'X')
            && isHexadecimal(charAt_CString(data, i+2))
            )//hexadecimal
        {
            /*
             * If the value of base is 16, the wide-character code representations of 0x or 
             * 0X may optionally precede the sequence of letters and digits, following the 
             * sign if present.
             * 
             */
            IMPLEMENT_REQ("strtol.06;strtoul.06;__strtol_internal.06;__strtoul_internal.06;__strtoll_internal.06;__strtoull_internal.06;strtoll.06;strtoull.06;strtoq.06;strtouq.06;strtoimax.06;strtoumax.06");
            i+=2;           
        }
    }

    /*
     * only letters whose ascribed values are less than that of base shall
     * be permitted.        
     */
    IMPLEMENT_REQ("strtol.05.02;strtoul.05.02;__strtol_internal.05.02;__strtoul_internal.05.02;__strtoll_internal.05.02;__strtoull_internal.05.02;strtoll.05.02;strtoull.05.02;strtoq.05.02;strtouq.05.02;strtoimax.05.02;strtoumax.05.02");
    if(i==size || !isOther(charAt_CString(data, i), base))
    {
        /*
         * The subject sequence contains no wide-character codes if the input wide- 
         * character string is empty or consists entirely of white-space wide-character 
         * code, or if the first non-white-space wide-character code is other than a sign 
         * or a permissible letter or digit.
         * 
         */
        IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
        *exp_end=nptr;
        *my_errno=SUT_EINVAL;
        return 0;            
    }
    /*
     * If the value of base is between 2 and 36, the expected form of the subject 
     * sequence is a sequence of letters and digits representing an integer with the 
     * radix specified by base, optionally preceded by a '+' or '-' sign, but not 
     * including an integer suffix. The letters from 'a' (or 'A' ) to 'z' (or 'Z' ) 
     * inclusive are ascribed the values 10 to 35; 
     * 
     */
    IMPLEMENT_REQ("strtol.05.01;strtoul.05.01;__strtol_internal.05.01;__strtoul_internal.05.01;__strtoll_internal.05.01;__strtoull_internal.05.01;strtoll.05.01;strtoull.05.01;strtoq.05.01;strtouq.05.01;strtoimax.05.01;strtoumax.05.01");
    /*
     * If the subject sequence has the expected form and the value of base is between 
     * 2 and 36, it shall be used as the base for conversion, ascribing to each letter 
     * its value as given above.
     * 
     */
    IMPLEMENT_REQ("strtol.10;strtoul.10;__strtol_internal.10;__strtoul_internal.10;__strtoll_internal.10;__strtoull_internal.10;strtoll.10;strtoull.10;strtoq.10;strtouq.10;strtoimax.10;strtoumax.10");
    while(i<size && isOther(charAt_CString(data, i), base))
    {
        DUMP("isOther==%d, wchar!=Nul_wchar==%d!!!!!!!!!!!!\n", isOther(charAt_CString(data, i), base), charAt_CString(data, i)!='\0');
        if(neg && mayneg)
        {
            DUMP("neg!!!!!!!!!!!!\n");
            if(!over_neg(-ret, base, mymin, -other2Int_CharT(charAt_CString(data, i))))
            //if(-ret*base-other2Int_CharT(charAt_CString(data, i))>=mymin)
            {
                DUMP("other2Int_CharT(charAt_CString(data, i)==%d\n", other2Int_CharT(charAt_CString(data, i)));
                ret=ret*base+other2Int_CharT(charAt_CString(data, i));
            }
            else
            {
                *my_errno=SUT_ERANGE;
                return mymin;
            }
        }
        else
        {
            DUMP("pos!!!!!!!!!!!!\n");
            if(!over_pos(ret, base, mymax, other2Int_CharT(charAt_CString(data, i))))
            //if(ret*base+other2Int_CharT(charAt_CString(data, i))<=mymax)
            {
                DUMP("other2Int_CharT(charAt_CString(data, i)==%d\n", other2Int_CharT(charAt_CString(data, i)));
                ret=ret*base+other2Int_CharT(charAt_CString(data, i));
            }
            else
            {
                *my_errno=SUT_ERANGE;
                return mymax;
            }                
        }
        i++;
    }   

    /*
     * First, they shall decompose the input string into three parts:
     * 
     * A final wide-character string of one or more unrecognized wide-character codes, 
     * including the terminating null wide-character code of the input wide-character 
     * string
     * 
     */
    IMPLEMENT_REQ("strtol.02.03;strtoul.02.03;__strtol_internal.02.03;__strtoul_internal.02.03;__strtoll_internal.02.03;__strtoull_internal.02.03;strtoll.02.03;strtoull.02.03;strtoq.02.03;strtouq.02.03;strtoimax.02.03;strtoumax.02.03");
    *exp_end=nptr;
    if(charAt_CString(data, i-1)!=(CharT)'+' && charAt_CString(data, i-1)!=(CharT)'-')
        exp_end->address+=i*sizeof(CharT);
    
    if(neg)
        ret=-ret;

    if(mayneg)
        return (mytype)convert_L(ret, mytype_size);

    return (mytype)convert_U(ret, mytype_size);
//    return ((mytype)ret)&andable(mytype_size);
}
