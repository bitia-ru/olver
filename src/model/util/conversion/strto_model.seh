/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
bool over_pos(mytype par, mytype mul, mytype m, mytype add)
{
    mytype tmp=par;

    while(--mul)
    {
        if(tmp>m-par)
            return true;
        tmp+=par;
    }
    if(tmp>m-add)
        return true;
   
    return false;
}
bool over_neg(mytype par, mytype mul, mytype m, mytype add)
{
    mytype tmp=par;

    while(--mul)
    {
        if(tmp<m-par)
            return true;
        tmp+=par;
    }
    if(tmp<m-add)
        return true;

    return false;
}
mytype model( CallContext context, StringTPtr nptr,
    StringTPtr* endptr, IntT base, ErrorCode* my_errno, StringTPtr* exp_end)
{
    mytype ret=0;
    CString* data=readCString_VoidTPtr(nptr);
    IntT i=0, size=length_CString(data);
    bool neg=false;
    IntT sh;

    /*
     * First, they shall decompose the input string into three parts:
     * 
     * An initial, possibly empty, sequence of white-space  character codes (as 
     * specified by isspace())
     * 
     */
    IMPLEMENT_REQ("strtol.02.01;strtoul.02.01;__strtol_internal.02.01;__strtoul_internal.02.01;__strtoll_internal.02.01;__strtoull_internal.02.01;strtoll.02.01;strtoull.02.01;strtoq.02.01;strtouq.02.01;strtoimax.02.01;strtoumax.02.01");
    while(i<size && isSpace(charAt_CString(data, i)))
        i++;

    /*
     * First, they shall decompose the input string into three parts:
     * 
     * A subject sequence interpreted as an integer represented in some radix 
     * determined by the value of base
     * 
     */
    IMPLEMENT_REQ("strtol.02.02;strtoul.02.02;__strtol_internal.02.02;__strtoul_internal.02.02;__strtoll_internal.02.02;__strtoull_internal.02.02;strtoll.02.02;strtoull.02.02;strtoq.02.02;strtouq.02.02;strtoimax.02.02;strtoumax.02.02");
    /*
     * The subject sequence is defined as the longest initial subsequence of the input 
     *  character string, starting with the first non-white-space  character 
     * code that is of the expected form.
     * 
     */
    IMPLEMENT_REQ("strtol.07;strtoul.07;__strtol_internal.07;__strtoul_internal.07;__strtoll_internal.07;__strtoull_internal.07;strtoll.07;strtoull.07;strtoq.07;strtouq.07;strtoimax.07;strtoumax.07");

    /*
     * Then they shall attempt to convert the subject sequence to an integer, and 
     * return the result.
     * 
     */
    IMPLEMENT_REQ("strtol.03;strtoul.03;__strtol_internal.03;__strtoul_internal.03;__strtoll_internal.03;__strtoull_internal.03;strtoll.03;strtoull.03;strtoq.03;strtouq.03;strtoimax.03;strtoumax.03");

    if( i==size ||
        firstCharNotMatch_strtol(charAt_CString(data, i), base)
        ||  !(base>=0 && base<=36 && base!=1))
    {
        /*
         * The subject sequence contains no  character codes if the input   
         * character string is empty or consists entirely of white-space  character 
         * code, or if the first non-white-space  character code is other than a sign 
         * or a permissible letter or digit.
         * 
         */
        IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
        *exp_end=nptr;
        *my_errno=SUT_EINVAL;
        return 0;
    }
    if(charAt_CString(data, i)==(CharT)'+')
        i++;

    /*
     * If the subject sequence begins with a minus sign, the value resulting from the 
     * conversion shall be negated.
     * 
     */
    IMPLEMENT_REQ("strtol.11;strtoul.11;__strtol_internal.11;__strtoul_internal.11;__strtoll_internal.11;__strtoull_internal.11;strtoll.11;strtoull.11;strtoq.11;strtouq.11;strtoimax.11;strtoumax.11");
    if(charAt_CString(data, i)==(CharT)'-')
    {
        neg=true;
        i++;
    }

    if(base==0)
    {
        if(charAt_CString(data, i)<(CharT)'0' && charAt_CString(data, i)>(CharT)'9')
        {
            /*
             * The subject sequence contains no  character codes if the input   
             * character string is empty or consists entirely of white-space  character 
             * code, or if the first non-white-space  character code is other than a sign 
             * or a permissible letter or digit.
             * 
             */
            IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
            *exp_end=nptr;
            *my_errno=SUT_EINVAL;
            return 0;            
        }

        /*
         * If the subject sequence has the expected form and base is 0, the sequence of 
         *  character codes starting with the first digit shall be interpreted as an 
         * integer constant.
         * 
         */
        IMPLEMENT_REQ("strtol.09;strtoul.09;__strtol_internal.09;__strtoul_internal.09;__strtoll_internal.09;__strtoull_internal.09;strtoll.09;strtoull.09;strtoq.09;strtouq.09;strtoimax.09;strtoumax.09");
        if(charAt_CString(data, i)>(CharT)'0')//Decimal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal 
             * constant, octal constant, or hexadecimal constant, any of which may be 
             * preceded by a '+' or '-' sign.
             * 
             * A decimal constant begins with a non-zero digit, and consists of a sequence of 
             * decimal digits.
             * 
             */
            IMPLEMENT_REQ("strtol.04.01;strtoul.04.01;__strtol_internal.04.01;__strtoul_internal.04.01;__strtoll_internal.04.01;__strtoull_internal.04.01;strtoll.04.01;strtoull.04.01;strtoq.04.01;strtouq.04.01;strtoimax.04.01;strtoumax.04.01");
            DUMP("Dec...\n");
            while(i<size && isDecimal(charAt_CString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 10, mymin, -dec2Int_CharT(charAt_CString(data, i))))
                    //if(-ret*10-dec2Int_CharT(charAt_CString(data, i))>=mymin)
                        ret=ret*10+dec2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 10, mymax, dec2Int_CharT(charAt_CString(data, i))))
                    //if(ret*10+dec2Int_CharT(charAt_CString(data, i))<=mymax)
                        ret=ret*10+dec2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }                
                }                
                i++;
            }
        }
        else
        if(     i+2<size
            &&
            (   charAt_CString(data, i+1)==(CharT)'x'
            ||  charAt_CString(data, i+1)==(CharT)'X')
            && isHexadecimal(charAt_CString(data, i+2))
            )//hexadecimal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal 
             * constant, octal constant, or hexadecimal constant, any of which may be 
             * preceded by a '+' or '-' sign.
             * 
             * A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence 
             * of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' ) with values 
             * 10 to 15 respectively.
             * 
             */
            IMPLEMENT_REQ("strtol.04.03;strtoul.04.03;__strtol_internal.04.03;__strtoul_internal.04.03;__strtoll_internal.04.03;__strtoull_internal.04.03;strtoll.04.03;strtoull.04.03;strtoq.04.03;strtouq.04.03;strtoimax.04.03;strtoumax.04.03");
            DUMP("Hex...\n");
            i+=2;
            while(i<size && isHexadecimal(charAt_CString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 16, mymin, -hex2Int_CharT(charAt_CString(data, i))))
                    //if(-ret*16-hex2Int_CharT(charAt_CString(data, i))>=mymin)
                        ret=ret*16+hex2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 16, mymax, hex2Int_CharT(charAt_CString(data, i))))
//                    if(ret*16+hex2Int_CharT(charAt_CString(data, i))<=mymax)
                        ret=ret*16+hex2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }                
                }

                i++;
            }
        }
        else//Octal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal 
             * constant, octal constant, or hexadecimal constant, any of which may be 
             * preceded by a '+' or '-' sign.
             * 
             * An octal constant consists of the prefix '0' optionally followed by a sequence 
             * of the digits '0' to '7' only.
             * 
             */
            IMPLEMENT_REQ("strtol.04.02;strtoul.04.02;__strtol_internal.04.02;__strtoul_internal.04.02;__strtoll_internal.04.02;__strtoull_internal.04.02;strtoll.04.02;strtoull.04.02;strtoq.04.02;strtouq.04.02;strtoimax.04.02;strtoumax.04.02");
            DUMP("Octal...\n");
            i++;
            while(i<size && isOctal(charAt_CString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 8, mymin, -oct2Int_CharT(charAt_CString(data, i))))
                    //if(-ret*8-oct2Int_CharT(charAt_CString(data, i))>=mymin)
                        ret=ret*8+oct2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 8, mymax, oct2Int_CharT(charAt_CString(data, i))))
                    //if(ret*8+oct2Int_CharT(charAt_CString(data, i))<=mymax)
                        ret=ret*8+oct2Int_CharT(charAt_CString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }                
                }
                i++;
            }        
        }

        /*
         * First, they shall decompose the input string into three parts:
         * 
         * A final  character string of one or more unrecognized  character codes, 
         * including the terminating null  character code of the input  character 
         * string
         * 
         */
        IMPLEMENT_REQ("strtol.02.03;strtoul.02.03;__strtol_internal.02.03;__strtoul_internal.02.03;__strtoll_internal.02.03;__strtoull_internal.02.03;strtoll.02.03;strtoull.02.03;strtoq.02.03;strtouq.02.03;strtoimax.02.03;strtoumax.02.03");
        *exp_end=nptr;
        if(charAt_CString(data, i-1)!=(CharT)'+' && charAt_CString(data, i-1)!=(CharT)'-')
            exp_end->address+=i*sizeof(CharT);

        if(neg)
            ret=-ret;

        if(mayneg)
            return (mytype)convert_L(ret, mytype_size);

        return (mytype)convert_U(ret, mytype_size);
    }

    //base!=0
    DUMP("base==%d!!!!!!!!!!!!\n", base);
    if(base==16)
    {
        if(charAt_CString(data, i)<(CharT)'0' && charAt_CString(data, i)>(CharT)'9')
        {
            /*
             * The subject sequence contains no  character codes if the input   
             * character string is empty or consists entirely of white-space  character 
             * code, or if the first non-white-space  character code is other than a sign 
             * or a permissible letter or digit.
             * 
             */
            IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
            *exp_end=nptr;
            *my_errno=SUT_EINVAL;
            return 0;            
        }

        if(     i+2<size
            &&
            (   charAt_CString(data, i+1)==(CharT)'x'
            ||  charAt_CString(data, i+1)==(CharT)'X')
            && isHexadecimal(charAt_CString(data, i+2))
            )//hexadecimal
        {
            /*
             * If the value of base is 16, the  character code representations of 0x or 
             * 0X may optionally precede the sequence of letters and digits, following the 
             * sign if present.
             * 
             */
            IMPLEMENT_REQ("strtol.06;strtoul.06;__strtol_internal.06;__strtoul_internal.06;__strtoll_internal.06;__strtoull_internal.06;strtoll.06;strtoull.06;strtoq.06;strtouq.06;strtoimax.06;strtoumax.06");
            i+=2;           
        }
    }

    /*
     * only letters whose ascribed values are less than that of base shall
     * be permitted.        
     */
    IMPLEMENT_REQ("strtol.05.02;strtoul.05.02;__strtol_internal.05.02;__strtoul_internal.05.02;__strtoll_internal.05.02;__strtoull_internal.05.02;strtoll.05.02;strtoull.05.02;strtoq.05.02;strtouq.05.02;strtoimax.05.02;strtoumax.05.02");
    if(i==size || !isOther(charAt_CString(data, i), base))
    {
        /*
         * The subject sequence contains no  character codes if the input   
         * character string is empty or consists entirely of white-space  character 
         * code, or if the first non-white-space  character code is other than a sign 
         * or a permissible letter or digit.
         * 
         */
        IMPLEMENT_REQ("strtol.08;strtoul.08;__strtol_internal.08;__strtoul_internal.08;__strtoll_internal.08;__strtoull_internal.08;strtoll.08;strtoull.08;strtoq.08;strtouq.08;strtoimax.08;strtoumax.08");
        *exp_end=nptr;
        *my_errno=SUT_EINVAL;
        return 0;            
    }
    /*
     * If the value of base is between 2 and 36, the expected form of the subject 
     * sequence is a sequence of letters and digits representing an integer with the 
     * radix specified by base, optionally preceded by a '+' or '-' sign, but not 
     * including an integer suffix. The letters from 'a' (or 'A' ) to 'z' (or 'Z' ) 
     * inclusive are ascribed the values 10 to 35; 
     * 
     */
    IMPLEMENT_REQ("strtol.05.01;strtoul.05.01;__strtol_internal.05.01;__strtoul_internal.05.01;__strtoll_internal.05.01;__strtoull_internal.05.01;strtoll.05.01;strtoull.05.01;strtoq.05.01;strtouq.05.01;strtoimax.05.01;strtoumax.05.01");
    /*
     * If the subject sequence has the expected form and the value of base is between 
     * 2 and 36, it shall be used as the base for conversion, ascribing to each letter 
     * its value as given above.
     * 
     */
    IMPLEMENT_REQ("strtol.10;strtoul.10;__strtol_internal.10;__strtoul_internal.10;__strtoll_internal.10;__strtoull_internal.10;strtoll.10;strtoull.10;strtoq.10;strtouq.10;strtoimax.10;strtoumax.10");
    while(i<size && isOther(charAt_CString(data, i), base))
    {
        DUMP("isOther==%d, wchar!=Nul_wchar==%d!!!!!!!!!!!!\n", isOther(charAt_CString(data, i), base), charAt_CString(data, i)!='\0');
        if(neg && mayneg)
        {
            DUMP("neg!!!!!!!!!!!!\n");
            if(!over_neg(-ret, base, mymin, -other2Int_CharT(charAt_CString(data, i))))
            //if(-ret*base-other2Int_CharT(charAt_CString(data, i))>=mymin)
            {
                DUMP("other2Int_CharT(charAt_CString(data, i)==%d\n", other2Int_CharT(charAt_CString(data, i)));
                ret=ret*base+other2Int_CharT(charAt_CString(data, i));
            }
            else
            {
                *my_errno=SUT_ERANGE;
                return mymin;
            }
        }
        else
        {
            DUMP("pos!!!!!!!!!!!!\n");
            if(!over_pos(ret, base, mymax, other2Int_CharT(charAt_CString(data, i))))
            //if(ret*base+other2Int_CharT(charAt_CString(data, i))<=mymax)
            {
                DUMP("other2Int_CharT(charAt_CString(data, i)==%d\n", other2Int_CharT(charAt_CString(data, i)));
                ret=ret*base+other2Int_CharT(charAt_CString(data, i));
            }
            else
            {
                *my_errno=SUT_ERANGE;
                return mymax;
            }                
        }
        i++;
    }   

    /*
     * First, they shall decompose the input string into three parts:
     * 
     * A final  character string of one or more unrecognized  character codes, 
     * including the terminating null  character code of the input  character 
     * string
     * 
     */
    IMPLEMENT_REQ("strtol.02.03;strtoul.02.03;__strtol_internal.02.03;__strtoul_internal.02.03;__strtoll_internal.02.03;__strtoull_internal.02.03;strtoll.02.03;strtoull.02.03;strtoq.02.03;strtouq.02.03;strtoimax.02.03;strtoumax.02.03");
    *exp_end=nptr;
    if(charAt_CString(data, i-1)!=(CharT)'+' && charAt_CString(data, i-1)!=(CharT)'-')
        exp_end->address+=i*sizeof(CharT);
    
    if(neg)
        ret=-ret;

    if(mayneg)
        return (mytype)convert_L(ret, mytype_size);

    return (mytype)convert_U(ret, mytype_size);
//    return ((mytype)ret)&andable(mytype_size);
}
