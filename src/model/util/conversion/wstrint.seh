/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UTIL_CONVERSION_WSTRINT_SUBSYSTEM

#define UTIL_CONVERSION_WSTRINT_SUBSYSTEM
#pragma SEC subsystem conversion "util.conversion"

#endif

specification
#ifndef ParameterGroupExists
    mytype spec( CallContext context, WStringTPtr nptr, WStringTPtr * endptr, IntT base, ErrorCode * errno )
#else
    mytype spec( CallContext context, WStringTPtr nptr, WStringTPtr * endptr, IntT base, ErrorCode * errno, IntT group )
#endif
{
    ErrorCode* errno_pre=clone(errno);
    ErrorCode* my_errno=requestErrorCode();
    WStringTPtr exp_end;

    FILTER(a_name);

    pre
    {
#ifdef ParameterGroupExists
        /*
         * __group shall be 0 or the behavior of __wcstol_internal() is undefined.
         *
         * __group shall be 0 or the behavior of __wcstoul_internal() is undefined.
         */
        REQ( "app.__wcstol_internal.30;app.__wcstoul_internal.30",
             "__group shall be 0 or the behavior of __wcsto(l|ul)_internal() is undefined", group == 0
           );
#endif

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        mytype ret=model(context, nptr, endptr, base, my_errno, &exp_end);

        //Implemented in agent
        /*
         * Since 0, {LONG_MIN} or {LLONG_MIN} and {LONG_MAX} or {LLONG_MAX} are returned
         * on error and are also valid returns on success, an application wishing to
         * check for error situations should set errno to 0, then call wcstol() or wcstoll(
         * ), then check errno.
         *
         */
        /*
         * Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and 0 is also a
         * valid return on success, an application wishing to check for error situations
         * should set errno to 0, then call wcstoul() or wcstoull(), then check errno.
         */

        IMPLEMENT_REQ("wcstol.16;wcstoul.16;__wcstol_internal.16;__wcstoul_internal.16;wcstoll.16;wcstoull.16;wcstoq.16;wcstouq.16;wcstoimax.16;wcstoumax.16");
        /*
         * If the subject sequence is empty or does not have the expected form, no
         * conversion shall be performed; the value of nptr shall be stored in the object
         * pointed to by endptr, provided that endptr is not a null pointer.
         *
         */
        REQ("wcstol.14;wcstoul.14;__wcstol_internal.14;__wcstoul_internal.14;wcstoll.14;wcstoull.14;wcstoq.14;wcstouq.14;wcstoimax.14;wcstoumax.14", "", *my_errno==SUT_EINVAL ? equals_VoidTPtr(exp_end, nptr) : true);

        if(*my_errno==SUT_ERANGE)
        {
            /*
             * If the correct value is outside the range of representable values, {LONG_MIN}, {
             * LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall be returned (according to the
             * sign of the value), and errno set to [ERANGE].
             *
             */
            /*
             * If the correct value is outside the range of representable values, {ULONG_MAX}
             * or {ULLONG_MAX} respectively shall be returned and errno set to [ERANGE].
             */
            /*
             * If the correct value is outside the range of representable values, {INTMAX_MAX}
             * , {INTMAX_MIN}, or {UINTMAX_MAX} shall be returned (according to the return
             * type and sign of the value, if any), and errno shall be set to [ERANGE].
             */
            REQ("wcstol.19;wcstoul.19;__wcstol_internal.19;__wcstoul_internal.19;wcstoll.19;wcstoull.19;wcstoq.19;wcstouq.19;wcstoimax.19;wcstoumax.19", "ret==wctol_spec, checking for LONG_MIN, LONG_MAX, etc", ret==spec);
        }

        if(*my_errno==SUT_EINVAL)
        {
            /*
             * If no conversion could be performed, 0 shall be returned [CX]  and errno may
             * be set to indicate the error.
             *
             */
            /*
             * If no conversion could be performed, zero shall be returned.
             */
            REQ("wcstol.18;wcstoul.18;__wcstol_internal.18;__wcstoul_internal.18;wcstoll.18;wcstoull.18;wcstoq.18;wcstouq.18;wcstoimax.18;wcstoumax.18", "No conversion", ret==spec);
        }

        ERROR_BEGIN(FUNC_ERR_ID, "wcstol.20.01;wcstoul.20.01;__wcstol_internal.20.01;__wcstoul_internal.20.01;wcstoll.20.01;wcstoull.20.01;wcstoq.20.01;wcstouq.20.01;wcstoimax.20.01;wcstoumax.20.01", *errno!=SUT_EOK, *errno)
        /*
         * These functions shall fail if:
         *
         * [EINVAL]
         *
         * [CX] The value of base is not supported.
         *
         */
            ERROR_SHALL(FUNC_ERR_ID, EINVAL, "wcstol.20.01;wcstoul.20.01;__wcstol_internal.20.01;__wcstoul_internal.20.01;wcstoll.20.01;wcstoull.20.01;wcstoq.20.01;wcstouq.20.01;wcstoimax.20.01;wcstoumax.20.01", isEINVAL_wcstoll(base))

        /*
         * These functions shall fail if:
         *
         * [ERANGE]
         *
         * The value to be returned is not representable.
         *
         */

         ERROR_SHALL(FUNC_ERR_ID, ERANGE, "wcstol.20.02;wcstoul.20.02;__wcstol_internal.20.02;__wcstoul_internal.20.02;wcstoll.20.02;wcstoull.20.02;wcstoq.20.02;wcstouq.20.02;wcstoimax.20.02;wcstoumax.20.02", *my_errno==SUT_ERANGE)

        /*
         * These functions may fail if:
         *
         * [EINVAL]
         *
         * [CX] No conversion could be performed.
         *
         */
         ERROR_MAY(FUNC_ERR_ID, EINVAL, "wcstol.21.01;wcstoul.21.01;__wcstol_internal.21.01;__wcstoul_internal.21.01;wcstoll.21.01;wcstoull.21.01;wcstoq.21.01;wcstouq.21.01;wcstoimax.21.01;wcstoumax.21.01", *my_errno==SUT_EINVAL)

        ERROR_END()

        DUMP("\n\nnptr==%d, endptr==%d, exp_end==%d\n\n", (IntT)nptr.address, (endptr!=NULL) ? (IntT)endptr->address : 0, (IntT)exp_end.address);
        if(endptr!=NULL)
        {
            /*
             * A pointer to the final wide-character string shall be stored in the object
             * pointed to by endptr, provided that endptr is not a null pointer.
             *
             */
            REQ("wcstol.12;wcstoul.12;__wcstol_internal.12;__wcstoul_internal.12;wcstoll.12;wcstoull.12;wcstoq.12;wcstouq.12;wcstoimax.12;wcstoumax.12", "exp_end==endptr", exp_end.address==endptr->address);
        }
        /*
         * [CX] These functions shall not change the setting of errno if successful.
         *
         */
        REQ("wcstol.15;wcstoul.15;__wcstol_internal.15;__wcstoul_internal.15;wcstoll.15;wcstoull.15;wcstoq.15;wcstouq.15;wcstoimax.15;wcstoumax.15", "", *errno==*errno_pre);

        /*
         * In other than the C [CX]  or POSIX locales, other implementation-defined
         * subject sequences may be accepted.
         *
         */
        REQ("wcstol.13;wcstoul.13;__wcstol_internal.13;__wcstoul_internal.13;wcstoll.13;wcstoull.13;wcstoq.13;wcstouq.13;wcstoimax.13;wcstoumax.13", "", TODO_REQ());

        /*
         * Upon successful completion, these functions shall return the converted value,
         * if any.
         *
         */
        /*
         * These functions shall convert the initial portion of the wide-character string
         * pointed to by nptr to long, long long, unsigned long, and unsigned long long
         * representation, respectively.
         *
         */
        /*
         * The wcstoul() and wcstoull() functions shall convert the initial portion of the
         * wide-character string pointed to by nptr to unsigned long and unsigned long
         * long representation, respectively.
         */
        /*
         * These functions shall return the converted value, if any.
         */
        REQ("wcstol.01;wcstoul.01;__wcstol_internal.01;__wcstoul_internal.01;wcstoll.01;wcstoull.01;wcstoq.01;wcstouq.01;wcstoimax.01;wcstoumax.01;wcstol.17;wcstoul.17;__wcstol_internal.17;__wcstoul_internal.17;wcstoll.17;wcstoull.17;wcstoq.17;wcstouq.17;wcstoimax.17;wcstoumax.17", "ret==wctol_spec", ret==spec);

#ifdef ParameterGroupExists
        /*
         * __wcstol_internal(nptr, endptr, base, 0)() shall behave as wcstol(nptr,
         * endptr, base)() as specified by ISO POSIX (2003).
         *
         * __wcstoul_internal(nptr, endptr, base, 0)() shall behave as wcstoul(nptr,
         * endptr, base)() as specified by ISO POSIX (2003).
         */
        REQ( "__wcstol_internal.30;__wcstoul_internal.30",
             "__wcsto(l|ul)_internal(nptr, endptr, base, 0) equal to wcsto(l|ul)(nptr, endptr, base)", true
           );
#endif

        /*
         * The wcstoq() function shall convert the initial portion of the wide string nptr
         * to long long int representation.
         *
         * The wcstouq() function shall convert the initial portion of the wide string
         * nptr to unsigned long long int representation.
         */
        REQ( "wcstoq.30;wcstouq.30", "convert wide string to unsigned long long int", true );

        /*
         * It is identical to wcstoll().
         *
         * It is identical to wcstoull().
         */
        REQ( "wcstoq.31;wcstouq.31", "It is identical to wcsto(ll|ull)", true );

        return true;
    }

    FILTER_CLEAN;
}

bool over_pos(mytype par, mytype mul, mytype m, mytype add)
{
    mytype tmp=par;

    while(--mul)
    {
        if(tmp>m-par)
            return true;
        tmp+=par;
    }
    if(tmp>m-add)
        return true;

    return false;
}
bool over_neg(mytype par, mytype mul, mytype m, mytype add)
{
    mytype tmp=par;

    while(--mul)
    {
        if(tmp<m-par)
            return true;
        tmp+=par;
    }
    if(tmp<m-add)
        return true;

    return false;
}
mytype model( CallContext context, WStringTPtr nptr,
    WStringTPtr* endptr, IntT base, ErrorCode* my_errno, WStringTPtr* exp_end)
{
    mytype ret=0;
    WString* data=readWString_VoidTPtr(nptr);
    IntT i=0, size=length_WString(data);
    bool neg=false;
    IntT sh;

    /*
     * First, they shall decompose the input string into three parts:
     *
     * An initial, possibly empty, sequence of white-space wide-character codes (as
     * specified by iswspace())
     *
     */
    IMPLEMENT_REQ("wcstol.02.01;wcstoul.02.01;__wcstol_internal.02.01;__wcstoul_internal.02.01;wcstoll.02.01;wcstoull.02.01;wcstoq.02.01;wcstouq.02.01;wcstoimax.02.01;wcstoumax.02.01");
    while(i<size && isWideSpace(wcharAt_WString(data, i)))
        i++;

    /*
     * First, they shall decompose the input string into three parts:
     *
     * A subject sequence interpreted as an integer represented in some radix
     * determined by the value of base
     *
     */
    IMPLEMENT_REQ("wcstol.02.02;wcstoul.02.02;__wcstol_internal.02.02;__wcstoul_internal.02.02;wcstoll.02.02;wcstoull.02.02;wcstoq.02.02;wcstouq.02.02;wcstoimax.02.02;wcstoumax.02.02");
    /*
     * The subject sequence is defined as the longest initial subsequence of the input
     * wide-character string, starting with the first non-white-space wide-character
     * code that is of the expected form.
     *
     */
    IMPLEMENT_REQ("wcstol.07;wcstoul.07;__wcstol_internal.07;__wcstoul_internal.07;wcstoll.07;wcstoull.07;wcstoq.07;wcstouq.07;wcstoimax.07;wcstoumax.07");

    /*
     * Then they shall attempt to convert the subject sequence to an integer, and
     * return the result.
     *
     */
    IMPLEMENT_REQ("wcstol.03;wcstoul.03;__wcstol_internal.03;__wcstoul_internal.03;wcstoll.03;wcstoull.03;wcstoq.03;wcstouq.03;wcstoimax.03;wcstoumax.03");

    if( i==size ||
        firstCharNotMatch_wcstol(wcharAt_WString(data, i), base)
        ||  !(base>=0 && base<=36 && base!=1))
    {
        /*
         * The subject sequence contains no wide-character codes if the input wide-
         * character string is empty or consists entirely of white-space wide-character
         * code, or if the first non-white-space wide-character code is other than a sign
         * or a permissible letter or digit.
         *
         */
        IMPLEMENT_REQ("wcstol.08;wcstoul.08;__wcstol_internal.08;__wcstoul_internal.08;wcstoll.08;wcstoull.08;wcstoq.08;wcstouq.08;wcstoimax.08;wcstoumax.08");
        *exp_end=nptr;
        *my_errno=SUT_EINVAL;
        return 0;
    }
    if(wcharAt_WString(data, i)==(WCharT)'+')
        i++;

    /*
     * If the subject sequence begins with a minus sign, the value resulting from the
     * conversion shall be negated.
     *
     */
    IMPLEMENT_REQ("wcstol.11;wcstoul.11;__wcstol_internal.11;__wcstoul_internal.11;wcstoll.11;wcstoull.11;wcstoq.11;wcstouq.11;wcstoimax.11;wcstoumax.11");
    if(wcharAt_WString(data, i)==(WCharT)'-')
    {
        neg=true;
        i++;
    }

    if(base==0)
    {
        if(wcharAt_WString(data, i)<(WCharT)'0' && wcharAt_WString(data, i)>(WCharT)'9')
        {
            /*
             * The subject sequence contains no wide-character codes if the input wide-
             * character string is empty or consists entirely of white-space wide-character
             * code, or if the first non-white-space wide-character code is other than a sign
             * or a permissible letter or digit.
             *
             */
            IMPLEMENT_REQ("wcstol.08;wcstoul.08;__wcstol_internal.08;__wcstoul_internal.08;wcstoll.08;wcstoull.08;wcstoq.08;wcstouq.08;wcstoimax.08;wcstoumax.08");
            *exp_end=nptr;
            *my_errno=SUT_EINVAL;
            return 0;
        }

        /*
         * If the subject sequence has the expected form and base is 0, the sequence of
         * wide-character codes starting with the first digit shall be interpreted as an
         * integer constant.
         *
         */
        IMPLEMENT_REQ("wcstol.09;wcstoul.09;__wcstol_internal.09;__wcstoul_internal.09;wcstoll.09;wcstoull.09;wcstoq.09;wcstouq.09;wcstoimax.09;wcstoumax.09");
        if(wcharAt_WString(data, i)>(WCharT)'0')//Decimal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal
             * constant, octal constant, or hexadecimal constant, any of which may be
             * preceded by a '+' or '-' sign.
             *
             * A decimal constant begins with a non-zero digit, and consists of a sequence of
             * decimal digits.
             *
             */
            IMPLEMENT_REQ("wcstol.04.01;wcstoul.04.01;__wcstol_internal.04.01;__wcstoul_internal.04.01;wcstoll.04.01;wcstoull.04.01;wcstoq.04.01;wcstouq.04.01;wcstoimax.04.01;wcstoumax.04.01");
            DUMP("Dec...\n");
            while(i<size && isDecimal(wcharAt_WString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 10, mymin, -dec2Int_WCharT(wcharAt_WString(data, i))))
                        ret=ret*10+dec2Int_WCharT(wcharAt_WString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 10, mymax, dec2Int_WCharT(wcharAt_WString(data, i))))
                        ret=ret*10+dec2Int_WCharT(wcharAt_WString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }
                }
                i++;
            }
        }
        else
        if(     i+2<size
            &&
            (   wcharAt_WString(data, i+1)==(WCharT)'x'
            ||  wcharAt_WString(data, i+1)==(WCharT)'X')
            && isHexadecimal(wcharAt_WString(data, i+2))
            )//hexadecimal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal
             * constant, octal constant, or hexadecimal constant, any of which may be
             * preceded by a '+' or '-' sign.
             *
             * A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence
             * of the decimal digits and letters 'a' (or 'A' ) to 'f' (or 'F' ) with values
             * 10 to 15 respectively.
             *
             */
            IMPLEMENT_REQ("wcstol.04.03;wcstoul.04.03;__wcstol_internal.04.03;__wcstoul_internal.04.03;wcstoll.04.03;wcstoull.04.03;wcstoq.04.03;wcstouq.04.03;wcstoimax.04.03;wcstoumax.04.03");
            DUMP("Hex...\n");
            i+=2;
            while(i<size && isHexadecimal(wcharAt_WString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 16, mymin, -hex2Int_WCharT(wcharAt_WString(data, i))))
                        ret=ret*16+hex2Int_WCharT(wcharAt_WString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 16, mymax, hex2Int_WCharT(wcharAt_WString(data, i))))
                        ret=ret*16+hex2Int_WCharT(wcharAt_WString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }
                }

                i++;
            }
        }
        else//Octal
        {
            /*
             * If base is 0, the expected form of the subject sequence is that of a decimal
             * constant, octal constant, or hexadecimal constant, any of which may be
             * preceded by a '+' or '-' sign.
             *
             * An octal constant consists of the prefix '0' optionally followed by a sequence
             * of the digits '0' to '7' only.
             *
             */
            IMPLEMENT_REQ("wcstol.04.02;wcstoul.04.02;__wcstol_internal.04.02;__wcstoul_internal.04.02;wcstoll.04.02;wcstoull.04.02;wcstoq.04.02;wcstouq.04.02;wcstoimax.04.02;wcstoumax.04.02");
            DUMP("Octal...\n");
            i++;
            while(i<size && isOctal(wcharAt_WString(data, i)))
            {
                if(neg && mayneg)
                {
                    if(!over_neg(-ret, 8, mymin, -oct2Int_WCharT(wcharAt_WString(data, i))))
                        ret=ret*8+oct2Int_WCharT(wcharAt_WString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymin;
                    }
                }
                else
                {
                    if(!over_pos(ret, 8, mymax, oct2Int_WCharT(wcharAt_WString(data, i))))
                        ret=ret*8+oct2Int_WCharT(wcharAt_WString(data, i));
                    else
                    {
                        *my_errno=SUT_ERANGE;
                        return mymax;
                    }
                }
                i++;
            }
        }

        /*
         * First, they shall decompose the input string into three parts:
         *
         * A final wide-character string of one or more unrecognized wide-character codes,
         * including the terminating null wide-character code of the input wide-character
         * string
         *
         */
        IMPLEMENT_REQ("wcstol.02.03;wcstoul.02.03;__wcstol_internal.02.03;__wcstoul_internal.02.03;wcstoll.02.03;wcstoull.02.03;wcstoq.02.03;wcstouq.02.03;wcstoimax.02.03;wcstoumax.02.03");
        *exp_end=nptr;
        if(wcharAt_WString(data, i-1)!=(WCharT)'+' && wcharAt_WString(data, i-1)!=(WCharT)'-')
            exp_end->address+=i*sizeof(WCharT);

        if(neg)
            ret=-ret;

        if(mayneg)
            return (mytype)convert_L(ret, mytype_size);

        return (mytype)convert_U(ret, mytype_size);
    }

    //base!=0
    DUMP("base==%d!!!!!!!!!!!!\n", base);
    if(base==16)
    {
        if(wcharAt_WString(data, i)<(WCharT)'0' && wcharAt_WString(data, i)>(WCharT)'9')
        {
            /*
             * The subject sequence contains no wide-character codes if the input wide-
             * character string is empty or consists entirely of white-space wide-character
             * code, or if the first non-white-space wide-character code is other than a sign
             * or a permissible letter or digit.
             *
             */
            IMPLEMENT_REQ("wcstol.08;wcstoul.08;__wcstol_internal.08;__wcstoul_internal.08;wcstoll.08;wcstoull.08;wcstoq.08;wcstouq.08;wcstoimax.08;wcstoumax.08");
            *exp_end=nptr;
            *my_errno=SUT_EINVAL;
            return 0;
        }

        if(     i+2<size
            &&
            (   wcharAt_WString(data, i+1)==(WCharT)'x'
            ||  wcharAt_WString(data, i+1)==(WCharT)'X')
            && isHexadecimal(wcharAt_WString(data, i+2))
            )//hexadecimal
        {
            /*
             * If the value of base is 16, the wide-character code representations of 0x or
             * 0X may optionally precede the sequence of letters and digits, following the
             * sign if present.
             *
             */
            IMPLEMENT_REQ("wcstol.06;wcstoul.06;__wcstol_internal.06;__wcstoul_internal.06;wcstoll.06;wcstoull.06;wcstoq.06;wcstouq.06;wcstoimax.06;wcstoumax.06");
            i+=2;
        }
    }

    /*
     * only letters whose ascribed values are less than that of base shall
     * be permitted.
     */
    IMPLEMENT_REQ("wcstol.05.02;wcstoul.05.02;__wcstol_internal.05.02;__wcstoul_internal.05.02;wcstoll.05.02;wcstoull.05.02;wcstoq.05.02;wcstouq.05.02;wcstoimax.05.02;wcstoumax.05.02");
    if(i==size || !isOther(wcharAt_WString(data, i), base))
    {
        /*
         * The subject sequence contains no wide-character codes if the input wide-
         * character string is empty or consists entirely of white-space wide-character
         * code, or if the first non-white-space wide-character code is other than a sign
         * or a permissible letter or digit.
         *
         */
        IMPLEMENT_REQ("wcstol.08;wcstoul.08;__wcstol_internal.08;__wcstoul_internal.08;wcstoll.08;wcstoull.08;wcstoq.08;wcstouq.08;wcstoimax.08;wcstoumax.08");
        *exp_end=nptr;
        *my_errno=SUT_EINVAL;
        return 0;
    }
    /*
     * If the value of base is between 2 and 36, the expected form of the subject
     * sequence is a sequence of letters and digits representing an integer with the
     * radix specified by base, optionally preceded by a '+' or '-' sign, but not
     * including an integer suffix. The letters from 'a' (or 'A' ) to 'z' (or 'Z' )
     * inclusive are ascribed the values 10 to 35;
     *
     */
    IMPLEMENT_REQ("wcstol.05.01;wcstoul.05.01;__wcstol_internal.05.01;__wcstoul_internal.05.01;wcstoll.05.01;wcstoull.05.01;wcstoq.05.01;wcstouq.05.01;wcstoimax.05.01;wcstoumax.05.01");
    /*
     * If the subject sequence has the expected form and the value of base is between
     * 2 and 36, it shall be used as the base for conversion, ascribing to each letter
     * its value as given above.
     *
     */
    IMPLEMENT_REQ("wcstol.10;wcstoul.10;__wcstol_internal.10;__wcstoul_internal.10;wcstoll.10;wcstoull.10;wcstoq.10;wcstouq.10;wcstoimax.10;wcstoumax.10");
    while(i<size && isOther(wcharAt_WString(data, i), base))
    {
        DUMP("isOther==%d, wchar!=Nul_wchar==%d!!!!!!!!!!!!\n", isOther(wcharAt_WString(data, i), base), wcharAt_WString(data, i)!=NUL_WCharT);
        if(neg && mayneg)
        {
            DUMP("neg!!!!!!!!!!!!\n");
            if(!over_neg(-ret, base, mymin, -other2Int_WCharT(wcharAt_WString(data, i))))
            {
                DUMP("other2Int_WCharT(wcharAt_WString(data, i)==%d\n", other2Int_WCharT(wcharAt_WString(data, i)));
                ret=ret*base+other2Int_WCharT(wcharAt_WString(data, i));
            }
            else
            {
                *my_errno=SUT_ERANGE;
                return mymin;
            }
        }
        else
        {
            DUMP("pos!!!!!!!!!!!!\n");
            if(!over_pos(ret, base, mymax, other2Int_WCharT(wcharAt_WString(data, i))))
            {
                DUMP("other2Int_WCharT(wcharAt_WString(data, i)==%d\n", other2Int_WCharT(wcharAt_WString(data, i)));
                ret=ret*base+other2Int_WCharT(wcharAt_WString(data, i));
            }
            else
            {
                *my_errno=SUT_ERANGE;
                return mymax;
            }
        }
        i++;
    }

    /*
     * First, they shall decompose the input string into three parts:
     *
     * A final wide-character string of one or more unrecognized wide-character codes,
     * including the terminating null wide-character code of the input wide-character
     * string
     *
     */
    IMPLEMENT_REQ("wcstol.02.03;wcstoul.02.03;__wcstol_internal.02.03;__wcstoul_internal.02.03;wcstoll.02.03;wcstoull.02.03;wcstoq.02.03;wcstouq.02.03;wcstoimax.02.03;wcstoumax.02.03");
    *exp_end=nptr;
    if(wcharAt_WString(data, i-1)!=(WCharT)'+' && wcharAt_WString(data, i-1)!=(WCharT)'-')
        exp_end->address+=i*sizeof(WCharT);

    if(neg)
        ret=-ret;

    if(mayneg)
        return (mytype)convert_L(ret, mytype_size);

    return (mytype)convert_U(ret, mytype_size);
}

#undef mytype_size
#undef mayneg
#undef mytype
#undef mymin
#undef mymax
#undef over_pos
#undef over_neg
#undef model
#undef spec
#undef a_name
#undef FUNC_ERR_ID_HAS_EXTRA_ERROR_CODES
#undef FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_ERANGE
#undef FUNC_ERR_ID_FAILS_WITH_EINVAL
#undef FUNC_ERR_ID_HAS_EXTRA_CONDITION_ON_EINVAL
#ifdef ParameterGroupExists
    #undef ParameterGroupExists
#endif
