/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "util/compress/compress_model.seh"
#include "config/interpretation.seh"
#include "util/compress/compress_config.h"
#include "data/errno_model.seh"

#pragma SEC subsystem compress "util.compress"



/*
   The group of functions 'util.compress' consists of:
       adler32 [1]
       compress [1]
       compress2 [1]
       compressBound [1]
       crc32 [1]
       deflate [1]
       deflateBound [1]
       deflateCopy [1]
       deflateEnd [1]
       deflateInit2_ [1]
       deflateInit_ [1]
       deflateParams [1]
       deflateReset [1]
       deflateSetDictionary [1]
       get_crc_table [1]
       gzclose [1]
       gzdopen [1]
       gzeof [1]
       gzerror [1]
       gzflush [1]
       gzgetc [1]
       gzgets [1]
       gzopen [1]
       gzprintf [1]
       gzputc [1]
       gzputs [1]
       gzread [1]
       gzrewind [1]
       gzseek [1]
       gzsetparams [1]
       gztell [1]
       gzwrite [1]
       inflate [1]
       inflateEnd [1]
       inflateInit2_ [1]
       inflateInit_ [1]
       inflateReset [1]
       inflateSetDictionary [1]
       inflateSync [1]
       inflateSyncPoint [1]
       uncompress [1]
       zError [1]
       zlibVersion [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    adler32

NAME

    adler32 -- compute Adler 32 Checksum

SYNOPSYS

    #include <zlib.h>

    uLong adler32(uLong adler, const Bytef * buf, uInt len);

DESRIPTION

    The adler32() function shall compute a running Adler-32 checksum (as
    described in RFC 1950: ZLIB Compressed Data Format Specication). On entry,
    adler is the previous value for the checksum, and buf shall point to an
    array of len bytes of data to be added to this checksum. The adler32()
    function shall return the new checksum.

    If buf is NULL (or Z_NULL), adler32() shall return the initial checksum.

RETURN VALE

    The adler32() function shall return the new checksum value.

ERRORS

    None defined.
*/

specification
ULongT adler32_spec( CallContext context, ULongT adler, CByteArray* buf,
                                                                    UIntT len)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        if(buf==NULL)
        {
            /*
             * If buf is NULL (or Z_NULL), adler32() shall return
             * the initial checksum.
             */

            /*
             ZLIB Compressed Data Format Specification version 3.3:
             ...
             s1 is initialized to 1, s2 to zero. The Adler-32 checksum
             is stored as s2*65536 + s1 in most-significant-byte
             first (network) order.
             ...
            */
            REQ("adler32.04", "If buf is NULL", adler32_spec==1);

            return true;
        }

        /*
         * On entry, adler is the previous value for the checksum,
         * and buf shall point to an array of len bytes of data
         * to be added to this checksum.
         */
        IMPLEMENT_REQ("adler32.02");

        /*
         * The adler32() function shall compute a running Adler-32
         * checksum (as described in RFC 1950:
         * ZLIB Compressed Data Format Specication).
         */
        /*
         * The adler32() function shall return the new checksum value.
         */
        REQ("adler32.01;adler32.03;adler32.05",
            "Shall return the new checksum value",
            adler32_spec==adler32_model(adler, buf, len));

        return true;
    }
}

ULongT adler32_model(ULongT adler, CByteArray* buf, UIntT len)
{
    //I found a sample of adler32 work:
    //http://www.gzip.org/zlib/rfc-zlib.html

    ULongT s1 = adler & 0xffff;
    ULongT s2 = (adler >> 16) & 0xffff;
    UIntT n;

    for (n = 0; n < len; n++)
    {
        s1 = (s1 + (UCharT)byteAt_CByteArray(buf, n)) % BASE;
        s2 = (s2 + s1)     % BASE;
    }

    return (s2 << 16) + s1;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    compress

NAME

    compress -- compress data

SYNOPSIS

    #include <zlib.h>

    int compress(Bytef * dest, uLongf * destLen, const Bytef * source, uLong
        sourceLen);

DESCRIPTION

    The compress() function shall attempt to compress sourceLen bytes of data
    in the buffer source, placing the result in the buffer dest.

    On entry, destLen should point to a value describing the size of the dest
    buffer. The application should ensure that this value be at least (
    sourceLen * 1.001) + 12. On successful exit, the variable referenced by
    destLen shall be updated to hold the length of compressed data in dest.

    The compress() function is equivalent to compress2() with a level of
    Z_DEFAULT_LEVEL.

RETURN VALUE

    On success, compress() shall return Z_OK. Otherwise, compress() shall
    return a value to indicate the error.

ERRORS

    On error, compress() shall return a value as described below:

    [Z_BUF_ERROR]

        The buffer dest was not large enough to hold the compressed data.

    [Z_MEM_ERROR]

        Insufficient memory.
*/

specification
IntT compress_spec( CallContext context, StringTPtr* dest, ULongT* destLen,
                   StringTPtr source, ULongT sourceLen)
{
    pre
    {
        if(destLen!=NULL && !isNULL_VoidTPtr(*dest))
        {
            /*
             * On entry, destLen should point to a value
             * describing the size of the dest buffer
             */
            REQ("compress.02",
                "On entry, destLen should point to a value describing "
                "the size of the dest buffer",
                sizeWMemoryAvailable( *dest ) >= *destLen);
        }
        else
            return false;

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, compress() shall return a value to indicate the error.
         */
        ERROR_BEGIN(LSB_COMPRESS, "compress.07", compress_spec!=SUT_Z_OK,
                                                                compress_spec)
        /*
         * On error, compress() shall return a value as described below:
         *
         * [Z_BUF_ERROR]
         *
         * The buffer dest was not large enough to hold the compressed data.
         */
            ERROR_SHALL(LSB_COMPRESS, Z_BUF_ERROR, "compress.08.01",
                            TODO_ERR(Z_BUF_ERROR))
        /*
         * On error, compress() shall return a value as described below:
         *
         * [Z_MEM_ERROR]
         *
         * Insufficient memory.
         */
            ERROR_SHALL(LSB_COMPRESS, Z_MEM_ERROR, "compress.08.02",
                                TODO_ERR(Z_MEM_ERROR))

        ERROR_END()

        /*
         * On success, compress() shall return Z_OK.
         */
        REQ("compress.06",
            "On success, compress() shall return Z_OK",
            compress_spec==SUT_Z_OK);

        /*
         * The compress() function shall attempt to compress
         * sourceLen bytes of data in the buffer source,
         * placing the result in the buffer dest.
         */
        REQ("compress.01", "", TODO_REQ());

        /*
         * The application should ensure that this value be
         * at least (sourceLen * 1.001) + 12.
         */
        REQ("compress.03", "", TODO_REQ());

        if(destLen!=NULL && !isNULL_VoidTPtr(*dest))
        {
            /*
             * On successful exit, the variable referenced by
             * destLen shall be updated to  hold the length of
             * compressed data in dest.
             */
            REQ("compress.04",
                "On successful, variable referenced by destLen shall be "
                "updated to  hold the length of compressed data in dest",
                sizeRMemoryAvailable( *dest ) >= *destLen);
        }

        /*
         * The compress() function is equivalent to compress2()
         * with a level of Z_DEFAULT_LEVEL.
         */
        //Implemented in scenario
        IMPLEMENT_REQ("compress.05");

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    compress2

NAME

    compress2 -- compress data at a specified level

SYNOPSIS

    #include <zlib.h>

    int compress2(Bytef * dest, uLongf * destLen, const Bytef * source, uLong
        sourceLen, int level);

DESCRIPTION

    The compress2() function shall attempt to compress sourceLen bytes of
    data in the buffer source, placing the result in the buffer dest,
    at the level described by level. The level supplied shall be a value
    between 0 and 9, or the value Z_DEFAULT_COMPRESSION. A level of
    1 requests the highest speed, while a level of 9 requests the highest
    compression. A level of 0 indicates that no compression should be used, and
    the output shall be the same as the input.

    On entry, destLen should point to a value describing the size of the dest
    buffer. The application should ensure that this value be at least
    (sourceLen * 1.001) + 12. On successful exit, the variable referenced by
    destLen shall be updated to hold the length of compressed data in dest.

    The compress() function is equivalent to compress2() with a level of
    Z_DEFAULT_LEVEL.

RETURN VALUE

    On success, compress2() shall return Z_OK. Otherwise, compress2() shall
    return a value to indicate the error.

ERRORS

    On error, compress2() shall return a value as described below:

    [Z_BUF_ERROR]

        The buffer dest was not large enough to hold the compressed data.

    [Z_MEM_ERROR]

        Insufficient memory.

    [Z_STREAM_ERROR]

        The level was not Z_DEFAULT_LEVEL, or was not between 0 and 9.
*/

specification
IntT compress2_spec( CallContext context, StringTPtr* dest, ULongT* destLen,
                   StringTPtr source, ULongT sourceLen, IntT level)
{
    pre
    {
        /*
         * The level supplied shall be a value between 0 and 9,
         * or the value Z_DEFAULT_COMPRESSION.
         */
        REQ("compress2.02",
            "The level supplied shall be Z_DEFAULT_COMPRESSION or in [0, 9]",
                                level>=0 && level<=9
                                || level==SUT_Z_DEFAULT_COMPRESSION);

        if(destLen!=NULL && !isNULL_VoidTPtr(*dest))
        {
            /*
             * On entry, destLen should point to a value
             * describing the size of the dest buffer
             */
            REQ("compress2.05",
                "On entry, destLen should point to a value describing "
                "the size of the dest buffer",
                sizeWMemoryAvailable( *dest ) >= *destLen);
        }
        else
            return false;

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        DUMP("ret==%d, dest==%d\n", compress2_spec, *destLen);
        DUMP("dest==$(obj), source==$(obj)\n",
            readCByteArray_VoidTPtr(*dest, *destLen),
            readCByteArray_VoidTPtr(source, sourceLen));

        /*
         * Otherwise, compress2() shall return a value to indicate the error.
         */
        ERROR_BEGIN(LSB_COMPRESS2, "compress2.10", compress2_spec!=SUT_Z_OK,
                                                            compress2_spec)
        /*
         * On error, compress2() shall return a value as described below:
         *
         * [Z_BUF_ERROR]
         *
         * The buffer dest was not large enough to hold the compressed data.
         */
            ERROR_SHALL(LSB_COMPRESS2, Z_BUF_ERROR, "compress2.11.01",
                TODO_ERR(Z_BUF_ERROR))

        /*
         * On error, compress2() shall return a value as described below:
         *
         * [Z_MEM_ERROR]
         *
         * Insufficient memory.
         */
            ERROR_SHALL(LSB_COMPRESS2, Z_MEM_ERROR, "compress2.11.02",
                TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, compress2() shall return a value as described below:
         *
         * [Z_STREAM_ERROR]
         *
         * The level was not Z_DEFAULT_LEVEL, or was not between 0 and 9.
         */
            ERROR_SHALL(LSB_COMPRESS2, Z_STREAM_ERROR, "compress2.11.03",
                compress2_spec<-1 || compress2_spec>9)

        ERROR_END()

        /*
         * On success, compress2() shall return Z_OK.
         */
        REQ("compress2.09",
            "On success, compress2() shall return Z_OK",
            compress2_spec==SUT_Z_OK);

        /*
         * The compress2() function shall attempt to compress
         * sourceLen bytes of data in the buffer source, placing
         * the result in the buffer dest, at the level described by level.
         */
        REQ("compress2.01", "", TODO_REQ());

        /*
         * A level of 1 requests the highest speed, while a
         * level of 9 requests the highest compression.
         */
        REQ("compress2.03", "", TODO_REQ());

        /*
         * A level of 0 indicates that no compression should be used,
         * and the output shall be the same as the input.
         */
        REQ("compress2.04", "", TODO_REQ());

        /*
         * The application should ensure that this value be at least
         * (sourceLen * 1.001) + 12.
         */
        REQ("compress2.06", "", TODO_REQ());

        if(destLen!=NULL && !isNULL_VoidTPtr(*dest))
        {
            /*
             * On successful exit, the variable referenced by
             * destLen shall be updated to  hold the length of
             * compressed data in dest.
             */
            REQ("compress2.07",
                "On successful, variable referenced by destLen shall be "
                "updated to  hold the length of compressed data in dest",
                sizeRMemoryAvailable( *dest ) >= *destLen);
        }

        /*
         * The compress() function is equivalent to compress2()
         * with a level of Z_DEFAULT_LEVEL.
         */
        //Implemented in scenario
        IMPLEMENT_REQ("compress2.08");

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    compressBound

NAME

    compressBound -- compute compressed data size

SYNOPSIS

    #include <zlib.h>

    int compressBound(uLong sourceLen);

DESCRIPTION

    The compressBound() function shall estimate the size of buffer required to
    compress sourceLen bytes of data using the compress() or compress2()
    functions. If successful, the value returned shall be an upper bound for
    the size of buffer required to compress sourceLen bytes of data, using the
    parameters stored in stream, in a single call to compress() or compress2().

RETURN VALUE

    The compressBound() shall return a value representing the upper bound of an
    array to allocate to hold the compressed data in a single call to
    compress() or compress2(). This function may return a conservative value
    that may be larger than sourceLen.

ERRORS

    None defined.
*/

specification
IntT compressBound_spec( CallContext context, ULongT sourceLen)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The compressBound() function shall estimate the size of buffer
         * required to compress sourceLen bytes of data using the compress()
         * or compress2() functions.
         */
        /*
         * If successful, the value returned shall be an upper bound for
         * the size of buffer required to compress sourceLen bytes of data,
         * using the parameters stored in stream, in a single call
         * to compress() or compress2().
         */
        /*
         * The compressBound() shall return a value representing the upper
         * bound of an array to allocate to hold the compressed data in
         * a single call to compress() or compress2().
         */
        IMPLEMENT_REQ("compressBound.01;compressBound.02;compressBound.03");

        /*
         * This function may return a conservative value that may be
         * larger than sourceLen.
         */
        REQ("compressBound.04", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    crc32

NAME

    crc32 -- compute CRC-32 Checksum

SYNOPSIS

    #include <zlib.h>

    uLong crc32(uLong crc, const Bytef * buf, uInt len);

DESCRIPTION

    The crc32() function shall compute a running Cyclic Redundancy Check
    checksum, as defined in ITU-T V.42. On entry, crc is the previous value for
    the checksum, and buf shall point to an array of len bytes of data to be
    added to this checksum. The crc32() function shall return the new checksum.

    If buf is NULL (or Z_NULL), crc32() shall return the initial checksum.

RETURN VALUE

    The crc32() function shall return the new checksum value.

ERRORS

    None defined.
*/


specification
ULongT crc32_spec( CallContext context, ULongT crc, StringTPtr buf,
                  UIntT len)
{
    pre
    {

        if(!isNULL_VoidTPtr(buf))
        {
            /*
             * On entry, crc is the previous value for the checksum,
             * and buf shall point to an array of len bytes of data
             * to be added to this checksum.
             */
            REQ("crc32.02",
                "buf shall point to an array of len bytes of data",
                sizeRMemoryAvailable( buf ) >= len);
        }

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        if(isNULL_VoidTPtr(buf))
        {
            /*
             * If buf is NULL (or Z_NULL), crc32() shall return
             * the initial checksum.
             */
            REQ("crc32.04",
                "If buf is NULL, shall return the initial checksum",
                crc32_spec==0);

            return true;
        }

        /*
         * The crc32() function shall compute a running
         * Cyclic Redundancy Check checksum,
         * as defined in ITU-T V.42.
         */
        /*
         * The crc32() function shall return the new checksum value.
         */
        REQ("crc32.01;crc32.03;crc32.05",
            "Shall return the new checksum value",
            crc32_model(crc, buf, len)==crc32_spec);

        return true;
    }
}

ULongT crc32_model(ULongT crc, StringTPtr buf, UIntT len)
{
    IntT n;
    CByteArray* ba=readCByteArray_VoidTPtr(buf, len);
    List* crc_table=get_crc_table_model();

    crc = crc ^ 0xffffffffUL;

    for(n=0;(UIntT)n<len;n++)
        crc =   (crc>>8)
                ^
                *((ULongT*)get_List(crc_table,
                            (crc & 0xffUL) ^ byteAt_CByteArray(ba, n) ));

    return crc ^ 0xffffffffUL;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

deflate

NAME

    deflate -- compress data

SYNOPSIS

    #include <zlib.h>

    int deflate(z_streamp stream, int flush);

DESCRIPTION

    The deflate() function shall attempt to compress data until either the
    input buffer is empty or the output buffer is full. The stream references
    a z_stream structure. Before the first call to deflate(), this structure
    should have been initialized by a call to deflateInit2_().

    Note: deflateInit2_() is only in the binary standard; source level
    applications should initialize stream via a call to deflateInit() or
    deflateInit2().

    In addition, the stream input and output buffers should have been
    initialized as follows:

    next_in

        should point to the data to be compressed.

    avail_in

        should contain the number of bytes of data in the buffer referenced by
        next_in.

    next_out

        should point to a buffer where compressed data may be placed.

    avail_out

        should contain the size in bytes of the buffer referenced by next_out

    The deflate() function shall perform one or both of the following actions:

        Compress input data from next_in and update next_in, avail_in and
        total_in to reflect the data that has been compressed.

        Fill the output buffer referenced by next_out, and update next_out,
        avail_out and total_out to reflect the compressed data that has been
        placed there. If flush is not Z_NO_FLUSH, and avail_out indicates that
        there is still space in output buffer, this action shall always occur
        (see below for further details).

    The deflate() function shall return when either avail_in reaches zero (
    indicating that all the input data has been compressed), or avail_out
    reaches zero (indicating that the output buffer is full).

    On success, the deflate() function shall set the adler field of the stream
    to the adler32() checksum of all the input data compressed so far
    (represented by total_in).

    If the deflate() function shall attempt to determine the type of input data,
    and set field data_type in stream to Z_ASCII if the majority of the data
    bytes fall within the ASCII (ISO 646) printable character range. Otherwise,
    it shall set data_type to Z_BINARY. This data type is informational only,
    and does not affect the compression algorithm.

        Note: Future versions of the LSB may remove this requirement, since it
        is based on an outdated character set that does not support
        Internationalization, and does not affect the algorithm. It is included
        for information only at this release. Applications should not depend on
        this field.


    Flush Operation

    The parameter flush determines when compressed bits are added to the output
    buffer in next_out. If flush is Z_NO_FLUSH, deflate() may return with some
    data pending output, and not yet added to the output buffer.

    If flush is Z_SYNC_FLUSH, deflate() shall flush all pending output to
    next_out and align the output to a byte boundary. A synchronization point
    is generated in the output.

    If flush is Z_FULL_FLUSH, all output shall be flushed, as for Z_SYNC_FLUSH,
    and the compression state shall be reset. A synchronization point is
    generated in the output.

        Rationale: Z_SYNC_FLUSH is intended to ensure that the compressed data
        contains all the data compressed so far, and allows a decompressor to
        reconstruct all of the input data. Z_FULL_FLUSH allows decompression to
        restart from this point if the previous compressed data has been lost
        or damaged. Flushing is likely to degrade the performance of the
        compression system, and should only be used where necessary.

    If flush is set to Z_FINISH, all pending input shall be processed and
    deflate() shall return with Z_STREAM_END if there is sufficient space in
    the output buffer at next_out, as indicated by avail_out. If deflate() is
    called with flush set to Z_FINISH and there is insufficient space to store
    the compressed data, and no other error has occurred during compression,
    deflate() shall return Z_OK, and the application should call deflate()
    again with flush unchanged, and having updated next_out and avail_out.

    If all the compression is to be done in a single step, deflate() may be
    called with flush set to Z_FINISH immediately after the stream has been
    initialized if avail_out is set to at least the value returned by
    deflateBound().

RETURN VALUE

    On success, deflate() shall return Z_OK, unless flush was set to Z_FINISH
    and there was sufficient space in the output buffer to compress all of the
    input data. In this case, deflate() shall return Z_STREAM_END. On error,
    deflate() shall return a value to indicate the error.

        Note: If deflate() returns Z_OK and has set avail_out to zero, the
        function should be called again with the same value for flush, and with
        updated next_out and avail_out until deflate() returns with Z_OK
        (or Z_STREAM_END if flush is set to Z_FINISH) and a non-zero avail_out.

ERRORS

    On error, deflate() shall return a value as described below, and set the
    msg field of stream to point to a string describing the error:

    [Z_BUF_ERROR]

        No progress is possible; either avail_in or avail_out was zero.

    [Z_MEM_ERROR]

        Insufficient memory.

    [Z_STREAM_ERROR]

        The state (as represented in stream) is inconsistent, or stream was
        NULL.
*/

specification
IntT deflate_spec( CallContext context, ZStream* stream, IntT flush )
{
    CByteArray* adler_buf;
    bool deflate_zbuf_err=false;

    if(stream!=NULL)
    {
        adler_buf=
        readCByteArray_VoidTPtr(stream->next_in, stream->avail_in);
        deflate_zbuf_err = stream->avail_in==0 || stream->avail_out==0;
    }

    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * On error, deflate() shall return a value to indicate the error.
         */
        ERROR_BEGIN(LSB_DEFLATE, "deflate.22",
            deflate_has_error(stream, flush, deflate_spec), deflate_spec)
        /*
         * On error, deflate() shall return a value as described below,
         * and set the msg field of stream to point to a string
         * describing the error:
         *
         * [Z_BUF_ERROR]
         *
         * No progress is possible; either avail_in or avail_out was zero.
         */
            ERROR_SHALL(LSB_DEFLATE, Z_BUF_ERROR, "deflate.23.01",
                deflate_zbuf_err)

        /*
         * On error, deflate() shall return a value as described below,
         * and set the msg field of stream to point to a string
         * describing the error:
         *
         * [Z_MEM_ERROR]
         *
         * Insufficient memory.
         */
            ERROR_SHALL(LSB_DEFLATE, Z_MEM_ERROR, "deflate.23.02",
                TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, deflate() shall return a value as described below,
         * and set the msg field of stream to point to a string
         * describing the error:
         *
         * [Z_STREAM_ERROR]
         *
         * The state (as represented in stream) is inconsistent, or
         * stream was NULL.
         */
            ERROR_SHALL3(LSB_DEFLATE, Z_STREAM_ERROR, "deflate.23.03",
                stream==NULL ? True_Bool3 : Unknown_Bool3)

        ERROR_END()

        /*
         * The deflate() function shall attempt to compress data until either
         * the input buffer is empty or the output buffer is full.
         */
        /*
         * The deflate() function shall return when either avail_in reaches
         * zero (indicating that all the input data has been compressed),
         * or avail_out reaches zero
         * (indicating that the output buffer is full).
         */
        REQ("deflate.01;deflate.06",
            "Shall attempt to compress data",
            stream->avail_in==0 || stream->avail_out==0);

        /*
         * The stream references a z_stream structure.
         */
        REQ("deflate.02", "", TODO_REQ());

        /*
         * Before the first call to deflate(), this structure should have been
         * initialized by a call to deflateInit2_().
         */
        IMPLEMENT_REQ("deflate.03");

        /*
         * In addition, the stream input and output buffers should have been
         * initialized as follows:
         *
         * next_in should point to the data to be compressed.
         */
        /*
         * In addition, the stream input and output buffers should have been
         * initialized as follows:
         *
         * avail_in should contain the number of bytes of data in the buffer
         * referenced by next_in.
         */
        REQ("deflate.04.01;deflate.04.02",
            "The stream input and output buffers should have been initialized",
            sizeRMemoryAvailable( stream->next_in ) >= stream->avail_in);

        /*
         * In addition, the stream input and output buffers should have been
         * initialized as follows:
         *
         * next_out should point to a buffer where compressed data may be
         * placed.
         */
        /*
         * In addition, the stream input and output buffers should have been
         * initialized as follows:
         *
         * avail_out should contain the size in bytes of the buffer referenced
         * by next_out
         */
        REQ("deflate.04.03;deflate.04.04",
            "The stream input and output buffers should have been initialized",
            sizeWMemoryAvailable( stream->next_out ) >= stream->avail_out);

        /*
         * The deflate() function shall perform one or both of the following
         * actions:
         *
         * Compress input data from next_in and update next_in, avail_in and
         * total_in to reflect the data that has been compressed.
         */
        REQ("deflate.05.01", "", TODO_REQ());

        /*
         * The deflate() function shall perform one or both of the following
         * actions:
         *
         * Fill the output buffer referenced by next_out, and update next_out,
         * avail_out and total_out to reflect the compressed data that has been
         * placed there. If flush is not Z_NO_FLUSH, and avail_out indicates
         * that there is still space in output buffer, this action shall always
         * occur (see below for further details).
         */
        REQ("deflate.05.02", "", TODO_REQ());

        /*
         * On success, the deflate() function shall set the adler field of the
         * stream to the adler32() checksum of all the input data compressed so
         * far (represented by total_in).
         */
        REQ("deflate.07",
            "On success, shall set the adler field of the stream",
                                adler32_model(1, adler_buf, stream->total_in)
                                == stream->adler);

        /*
         * If the deflate() function shall attempt to determine the type of input data,
         * and set field data_type in stream to Z_ASCII if the majority of the data bytes
         * fall within the ASCII (ISO 646) printable character range. Otherwise, it shall
         * set data_type to Z_BINARY.This data type is informational only, and does not
         * affect the compression algorithm.
         */
        REQ( "deflate.08", "data_type is Z_ASCII or Z_BINARY", stream->data_type == SUT_Z_ASCII  ||
                                                               stream->data_type == SUT_Z_BINARY
           );

        /*
         * The parameter flush determines when compressed bits are added to the
         * output buffer in next_out.
         */
        REQ("deflate.11", "", TODO_REQ());

        if(flush == SUT_Z_NO_FLUSH)
        {
            /*
             * If flush is Z_NO_FLUSH, deflate() may return with some data
             * pending output, and not yet added to the output buffer.
             */
            REQ("deflate.12", "", TODO_REQ());
        }

        if(flush == SUT_Z_SYNC_FLUSH)
        {
            /*
             * If flush is Z_SYNC_FLUSH
             *
             * deflate() shall flush all pending output to next_out
             */
            REQ("deflate.13.01", "", TODO_REQ());

            /*
             * If flush is Z_SYNC_FLUSH
             *
             * align the output to a byte boundary
             */
            REQ("deflate.13.02", "", TODO_REQ());

            /*
             * A synchronization point is generated in the output.
             */
            //About SyncPoints read in inflateSyncPoint func...
            //will be implemented in scenario...
            REQ("deflate.14;deflate.16", "", TODO_REQ());
        }

        if(flush==SUT_Z_FULL_FLUSH)
        {
            /*
             * If flush is Z_FULL_FLUSH
             *
             * all output shall be flushed, as for Z_SYNC_FLUSH
             */
            REQ("deflate.15.01", "", TODO_REQ());

            /*
             * If flush is Z_FULL_FLUSH
             *
             * the compression state shall be reset
             */
            REQ("deflate.15.02", "", TODO_REQ());
        }

        if(flush == SUT_Z_FINISH)
        {
            /*
             * If flush is set to Z_FINISH
             *
             * all pending input shall be processed
             */
            REQ("deflate.17.01", "", TODO_REQ());

            /*
             * If flush is set to Z_FINISH
             *
             * deflate() shall return with Z_STREAM_END if there is sufficient
             * space in the output buffer at next_out, as indicated by
             * avail_out
             */
            REQ("deflate.17.02", "", TODO_REQ());

            /*
             * If deflate() is called with flush set to Z_FINISH and there is
             * insufficient space to store the compressed data, and no other
             * error has occurred during compression
             *
             * deflate() shall return Z_OK
             */
            REQ("deflate.18.01", "", TODO_REQ());

            /*
             * If deflate() is called with flush set to Z_FINISH and there is
             * insufficient space to store the compressed data, and no other
             * error has occurred during compression
             *
             * the application should call deflate() again with flush
             * unchanged, and having updated next_out and avail_out
             */
            REQ("deflate.18.02", "", TODO_REQ());

            /*
             * If all the compression is to be done in a single step
             *
             * if avail_out is set to at least the value returned by
             * deflateBound()
             *
             * deflate() may be called with flush set to Z_FINISH immediately
             * after the stream has been initialized
             */
            REQ("deflate.19.01.01", "", TODO_REQ());
        }

        if(flush == SUT_Z_FINISH /*&& sufficient space*/)
        {
            /*
             * In this case, deflate() shall return Z_STREAM_END
             */
            REQ("deflate.21", "", TODO_REQ());
        }
        else
        {
            /*
             * unless flush was set to Z_FINISH and there was sufficient space
             * in the output buffer to compress all of the input data
             *
             * On success, deflate() shall return Z_OK
             */
            REQ("deflate.20.01", "", TODO_REQ());
        }

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateBound

NAME

    deflateBound -- compute compressed data size

SYNOPSYS

    #include <zlib.h>

    int deflateBound(z_streamp stream, uLong sourceLen);

DESRIPTION

    The deflateBound() function shall estimate the size of buffer required to
    compress sourceLen bytes of data. If successful, the value returned shall
    be an upper bound for the size of buffer required to compress sourceLen
    bytes of data, using the parameters stored in stream, in a single call to
    deflate(...) with flush set to Z_FINISH.

    On entry, stream should have been initialized via a call to deflateInit_()
    or deflateInit2_().

RETURN VALUE

    The deflateBound() shall return a value representing the upper bound of an
    array to allocate to hold the compressed data in a single call to
    deflate(). If the stream is not correctly initialized, or is NULL, then
    deflateBound() may return a conservative value that may be larger than
    sourceLen.

ERRORS

    None defined.
*/

specification
IntT deflateBound_spec( CallContext context, ZStream* stream, ULongT sourceLen)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The deflateBound() function shall estimate the size of buffer
         * required to compress sourceLen bytes of data.
         */
        /*
         * If successful, the value returned shall be an upper bound for
         * the size of buffer required to compress sourceLen bytes of data,
         * using the parameters stored in stream, in a single call to
         * deflate() with flush set to Z_FINISH.
         */
        /*
         * The deflateBound() shall return a value representing the
         * upper bound of an array to allocate to hold the compressed
         * data in a single call to deflate().
         */
        IMPLEMENT_REQ("deflateBound.01;deflateBound.02;deflateBound.04");

        /*
         * On entry, stream should have been initialized via a call to
         * deflateInit_() or deflateInit2_().
         */
        IMPLEMENT_REQ("deflateBound.03");

        /*
         * If the stream is not correctly initialized, or is NULL,
         * then deflateBound() may return a conservative value that
         * may be larger than sourceLen.
         */
        REQ("deflateBound.05", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateCopy

NAME

    deflateCopy -- copy compression stream

SYNOPSIS

    #include <zlib.h>

    int deflateCopy(z_streamp dest, z_streamp source);

DESCRIPTION

    The deflateCopy() function shall copy the compression state information in
    source to the uninitialized z_stream structure referenced by dest.

    On successful return, dest will be an exact copy of the stream referenced
    by source. The input and output buffer pointers in next_in and next_out
    will reference the same data.

RETURN VALUE

    On success, deflateCopy() shall return Z_OK. Otherwise it shall return a
    value less than zero to indicate the error.

ERRORS

    On error, deflateCopy() shall return a value as described below:

    [Z_STREAM_ERROR]

        The state in source is inconsistent, or either source or dest was NULL.

    [Z_MEM_ERROR]

        Insufficient memory available.
*/

specification
IntT deflateCopy_spec( CallContext context, ZStream* dest, ZStream* source)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise it shall return a value less than zero
         * to indicate the error.
         */
        ERROR_BEGIN(LSB_DEFLATECOPY, "deflateCopy.05",
            deflateCopy_spec!=SUT_Z_OK, deflateCopy_spec)
        /*
         * On error, deflateCopy() shall return a value as described below:
         *
         * [Z_STREAM_ERROR]
         *
         *  The state in source is inconsistent, or either source or
         * dest was NULL.
         */
            ERROR_SHALL3(LSB_DEFLATECOPY, Z_STREAM_ERROR, "deflateCopy.06.01",
                        source==NULL || dest==NULL ?
                        True_Bool3 : Unknown_Bool3)

        /*
         * On error, deflateCopy() shall return a value as described below:
         *
         * [Z_MEM_ERROR]
         *
         *  Insufficient memory available.
         */
            ERROR_SHALL(LSB_DEFLATECOPY, Z_MEM_ERROR, "deflateCopy.06.02",
                        TODO_ERR(Z_MEM_ERROR))

        ERROR_END()

        /*
         * On success, deflateCopy() shall return Z_OK.
         */
        REQ("deflateCopy.04",
            "On success, deflateCopy() shall return Z_OK",
            deflateCopy_spec==SUT_Z_OK);

        /*
         * The deflateCopy() function shall copy the compression state
         * information in source to the uninitialized z_stream structure
         * referenced by dest.
         */
        /*
         * On successful return, dest will be an exact copy of the stream
         * referenced by source.
         */
        /*
         * The input and output buffer pointers in next_in and next_out
         * will reference the same data.
         */
        REQ("deflateCopy.01;deflateCopy.02;deflateCopy.03",
            "source == dest", deflateCopy_check(source, dest));

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateEnd

NAME

    deflateEnd -- free compression stream state

SYNOPSIS

    #include <zlib.h>

    int deflateEnd(z_streamp stream);

DESRIPTION

    The deflateEnd() function shall free all allocated state information
    referenced by stream. All pending output is discarded, and unprocessed
    input is ignored.

RETURN VALUE

    On success, deflateEnd() shall return Z_OK, or Z_DATA_ERROR if there was
    pending output discarded or input unprocessed. Otherwise it shall return
    Z_STREAM_ERROR to indicate the error.

ERRORS

    On error, deflateEnd() shall return Z_STREAM_ERROR.
    The following conditions shall be treated as an error:

        The state in stream is inconsistent or inappropriate.

        stream is NULL.
*/

specification
IntT deflateEnd_spec( CallContext context, ZStream* stream )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {

        if(deflateEnd_spec==SUT_Z_DATA_ERROR)
        {
            /*
             * On success, deflateEnd() shall return
             *
             * Z_DATA_ERROR
             *
             * if there was pending output discarded
             * or input unprocessed
             */
            REQ("deflateEnd.02.02", "", TODO_REQ());

            return true;
        }

        /*
         * Otherwise it shall return Z_STREAM_ERROR to indicate the error.
         */
        ERROR_BEGIN(LSB_DEFLATEEND, "deflateEnd.03", deflateEnd_spec!=SUT_Z_OK,
                                                        deflateEnd_spec)
        /*
         * The following conditions shall be treated as an error:
         *
         *      The state in stream is inconsistent or inappropriate.
         *
         *      stream is NULL.
         */
            ERROR_SHALL3(LSB_DEFLATEEND, Z_STREAM_ERROR,
                "deflateEnd.04.01.01;deflateEnd.04.01.02",
                stream==NULL ? True_Bool3 : Unknown_Bool3)

        ERROR_END()

        /*
         * On success, deflateEnd() shall return Z_OK
         */
        REQ("deflateEnd.02.01",
            "On success, deflateEnd() shall return Z_OK",
            deflateEnd_spec==SUT_Z_OK);

        /*
         * The deflateEnd() function shall free all allocated state information
         * referenced by stream. All pending output is discarded, and
         * unprocessed input is ignored.
         */
        REQ("deflateEnd.01",
            "Shall free all allocated state information referenced by stream",
            stream->int_state.address==0);

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateInit2_

NAME

    deflateInit2_ -- initialize compression system

SYNOPSIS

    #include <zlib.h>

    int deflateInit2_ (z_streamp strm, int level, int method, int windowBits,
        int memLevel, int strategy, char * version, int stream_size);

DESRIPTION

    The deflateInit2_() function shall initialize the compression system. On
    entry, strm shall refer to a user supplied z_stream object (a z_stream_s
    structure). The following fields shall be set on entry:

    zalloc

        a pointer to an alloc_func function, used to allocate state
        information. If this is NULL, a default allocation function will be
        used.

    zfree

        a pointer to a free_func function, used to free memory allocated by the
        zalloc function. If this is NULL a default free function will be used.

    opaque

        If alloc_func is not NULL, opaque is a user supplied pointer to data
        that will be passed to the alloc_func and free_func functions.

    If the version requested is not compatible with the version implemented, or
    if the size of the z_stream_s structure provided in stream_size does not
    match the size in the library implementation, deflateInit2_() shall fail,
    and return Z_VERSION_ERROR.

    The level supplied shall be a value between 0 and 9, or the value 
    Z_DEFAULT_COMPRESSION. A level of 1 requests the highest speed, while a
    level of 9 requests the highest compression. A level of 0 indicates that no 
    compression should be used, and the output shall be the same as the input.

    The method selects the compression algorithm to use. LSB conforming 
    implementation shall support the Z_DEFLATED method, and may support other 
    implementation defined methods.

    The windowBits parameter shall be a base 2 logarithm of the window size to 
    use, and shall be a value between 8 and 15. A smaller value will use less 
    memory, but will result in a poorer compression ratio, while a higher value 
    will give better compression but utilize more memory.

    The memLevel parameter specifies how much memory to use for the internal 
    state. The value of memLevel shall be between 1 and MAX_MEM_LEVEL. Smaller 
    values use less memory but are slower, while higher values use more memory
    to gain compression speed.

    The strategy parameter selects the compression strategy to use: 

    Z_DEFAULT_STRATEGY 

        use the system default compression strategy. Z_DEFAULT_STRATEGY is 
        particularly appropriate for text data.

    Z_FILTERED 

        use a compression strategy tuned for data consisting largely of small
        values with a fairly random distribution. Z_FILTERED uses more Huffman
        encoding and less string matching than Z_DEFAULT_STRATEGY.

    Z_HUFFMAN_ONLY 

        force Huffman encoding only, with no string match.

    The deflateInit2_() function is not in the source standard; it is only in
    the binary standard. Source applications should use the deflateInit2()
    macro.

RETURN VALUE

    On success, the deflateInit2_() function shall return Z_OK. Otherwise, 
    deflateInit2_() shall return a value as described below to indicate the
    error.

ERRORS

    On error, deflateInit2_() shall return one of the following error
    indicators: 

    [Z_STREAM_ERROR] 

        Invalid parameter.

    [Z_MEM_ERROR] 

        Insufficient memory available.

    [Z_VERSION_ERROR] 

        The version requested is not compatible with the library version, or the 
        z_stream size differs from that used by the library.

    In addition, the msg field of the strm may be set to an error message.
*/


specification
IntT deflateInit2__spec(    CallContext context, ZStream* strm, IntT level,
                            IntT method, IntT windowBits, IntT memLevel,
                            IntT strategy, CString* version, IntT stream_size )
{
    pre
    {
        /*
         * The level supplied shall be a value between 0 and 9,
         * or the value Z_DEFAULT_COMPRESSION.
         */
        REQ("deflateInit2_.05", 
            "The level supplied shall be Z_DEFAULT_COMPRESSION or in [0, 9]", 
                                    level>=0 && level<9
                                    || level==SUT_Z_DEFAULT_COMPRESSION);

        /*
         * The windowBits parameter shall be a base 2 logarithm
         * of the window size to use, and shall be a value
         * between 8 and 15.
         */
        REQ("deflateInit2_.09", 
            "The windowBits shall be log[2](window size) beetween 8 and 15", 
            windowBits>=8 && windowBits<=15);

        /*
         * The value of memLevel shall be between 1 and MAX_MEM_LEVEL.
         */
        REQ("deflateInit2_.12", 
            "The value of memLevel shall be between 1 and MAX_MEM_LEVEL", 
                                    memLevel>=1
                                    && memLevel<=SUT_MAX_MEM_LEVEL);

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, deflateInit2_() shall return a value as described
         * below to indicate the error.
         */
        ERROR_BEGIN(DEFLATEINIT2_, "deflateInit2_.17",
                            deflateInit2__spec!=SUT_Z_OK, deflateInit2__spec)
        /*
         * On error, deflateInit2_() shall return one of the
         * following error indicators: 
         * 
         * [Z_STREAM_ERROR]
         *
         * Invalid parameter.
         */
            ERROR_SHALL(DEFLATEINIT2_, Z_STREAM_ERROR, "deflateInit2_.18.01",
                                                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, deflateInit2_() shall return one of the
         * following error indicators: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available.
         */
            ERROR_SHALL(DEFLATEINIT2_, Z_MEM_ERROR, "deflateInit2_.18.02",
                    TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, deflateInit2_() shall return one of the
         * following error indicators: 
         * 
         * [Z_VERSION_ERROR]
         *
         * The version requested is not compatible with the library 
         * version, or the z_stream size differs from that used by the library.
         */
        /*
         * If the version requested is not compatible with the version
         * implemented, or if the size of the z_stream_s structure provided in
         * stream_size does not match the size in the library implementation,
         * deflateInit2_() shall fail, and  return Z_VERSION_ERROR.
         */
            ERROR_SHALL(DEFLATEINIT2_, Z_VERSION_ERROR,
                "deflateInit2_.18.03;deflateInit2_.04",
                SUT_ZLIB_VERSION[0]!=charAt_CString(version, 0))
//                ||
//                SUT_ZSTREAM_SIZE!=stream_size)

        ERROR_END()

        /*
         * On success, the deflateInit2_() function shall return Z_OK.
         */
        REQ("deflateInit2_.16", 
            "On success, shall return Z_OK", 
            deflateInit2__spec==SUT_Z_OK);
        
        /*
         * The deflateInit2_() function shall initialize
         * the compression system.
         */
        IMPLEMENT_REQ("deflateInit2_.01");

        /*
         * On entry, strm shall refer to a user supplied z_stream
         * object (a z_stream_s structure). 
         */
        IMPLEMENT_REQ("deflateInit2_.02");

        /*
         * The following fields shall be set on entry: 
         * 
         * zalloc
         *
         * a pointer to an alloc_func function, used
         * to allocate state information. If this is NULL, a
         * default allocation function will be used.
         */
        REQ("deflateInit2_.03.01", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * zfree
         *
         * a pointer to a free_func function, used
         * to free memory allocated by the zalloc function.
         * If this is NULL a default free function will be used.
         */
        REQ("deflateInit2_.03.02", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * opaque
         *
         * If alloc_func is not NULL, opaque is a user supplied
         * pointer to data that will be passed to the alloc_func
         * and free_func functions.
         */
        REQ("deflateInit2_.03.03", "", TODO_REQ());

        /*
         * A level of 1 requests the highest speed,
         * while a level of 9 requests the highest compression.
         */
        REQ("deflateInit2_.06", "", TODO_REQ());

        /*
         * A level of 0 indicates that no compression should
         * be used, and the output shall be the same as the input.
         */
        REQ("deflateInit2_.07", "", TODO_REQ());

        /*
         * The method selects the compression algorithm to use.
         * LSB conforming implementation shall support the
         * Z_DEFLATED method, and may support other 
         * implementation defined methods.
         */
        IMPLEMENT_REQ("deflateInit2_.08");

        /*
         * A smaller value will use less memory, but will result
         * in a poorer compression ratio, while a higher value will
         * give better compression but utilize more memory.
         */
        REQ("deflateInit2_.10", "", TODO_REQ());

        /*
         * The memLevel parameter specifies how much memory to use
         * for the internal state.
         */
        REQ("deflateInit2_.11", "", TODO_REQ());

        /*
         * Smaller values use less memory but are slower, while higher
         * values use more memory to gain compression speed.
         */
        REQ("deflateInit2_.13", "", TODO_REQ());

        if(strategy == SUT_Z_DEFAULT_STRATEGY)
        {        
            /*
             * The strategy parameter selects the compression strategy to use: 
             * 
             * Z_DEFAULT_STRATEGY
             *
             *      use the system default compression strategy. 
             *      Z_DEFAULT_STRATEGY is particularly appropriate for text
             *      data.
             */
            REQ("deflateInit2_.14.01", "", TODO_REQ());
        }
        else if(strategy == SUT_Z_FILTERED)
        {
            /*
             * The strategy parameter selects the compression strategy to use: 
             * 
             * Z_FILTERED
             *
             *      use a compression strategy tuned for data consisting
             *      largely of small values with a fairly random distribution.
             *      Z_FILTERED uses more Huffman encoding and less string
             *      matching than Z_DEFAULT_STRATEGY.
             */
            REQ("deflateInit2_.14.02", "", TODO_REQ());
        }
        else if(strategy == SUT_Z_HUFFMAN_ONLY)
        {
            /*
             * The strategy parameter selects the compression strategy to use: 
             * 
             * Z_HUFFMAN_ONLY
             *
             *      force Huffman encoding only, with no string match.
             */
            REQ("deflateInit2_.14.03", "", TODO_REQ());
        }

        /*
         * The deflateInit2_() function is not in the source standard;
         * it is only in the binary standard. Source applications should
         * use the deflateInit2() macro.
         */
        REQ("deflateInit2_.15", "", TODO_REQ());

        /*
         * In addition, the msg field of the strm may be set
         * to an error message.
         */
        REQ("deflateInit2_.19", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateInit_

NAME

    deflateInit_ -- initialize compression system

SYNOPSIS

    #include <zlib.h>

    int deflateInit_(z_streamp stream, int level, const char * version, int 
        stream_size);

DESCRIPTION

    The deflateInit_() function shall initialize the compression system. On 
    entry, stream shall refer to a user supplied z_stream object (a z_stream_s 
    structure). The following fields shall be set on entry: 

    zalloc 

        a pointer to an alloc_func function, used to allocate state
        information. If this is NULL, a default allocation function
        will be used.

    zfree 

        a pointer to a free_func function, used to free memory allocated by the 
        zalloc function. If this is NULL a default free function will be used.

    opaque 

        If alloc_func is not NULL, opaque is a user supplied pointer to data
        that will be passed to the alloc_func and free_func functions.

    If the version requested is not compatible with the version implemented, or 
    if the size of the z_stream_s structure provided in stream_size does not 
    match the size in the library implementation, deflateInit_() shall fail,
    and return Z_VERSION_ERROR.

    The level supplied shall be a value between 0 and 9, or the value 
    Z_DEFAULT_COMPRESSION. A level of 1 requests the highest speed, while a 
    level of 9 requests the highest compression. A level of 0 indicates that no 
    compression should be used, and the output shall be the same as the input.

    The deflateInit_() function is not in the source standard; it is only in
    the binary standard. Source applications should use the deflateInit() macro.

    The deflateInit_() function is equivalent to 

    deflateInit2_(stream, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, 
        Z_DEFAULT_STRATEGY, version, stream_size); 

RETURN VALUE

    On success, the deflateInit_() function shall return Z_OK. Otherwise, 
    deflateInit_() shall return a value as described below to indicate the
    error.

ERRORS

    On error, deflateInit_() shall return one of the following error indicators: 

    [Z_STREAM_ERROR] 

        Invalid parameter.

    [Z_MEM_ERROR] 

        Insufficient memory available.

    [Z_VERSION_ERROR] 

        The version requested is not compatible with the library version,
        or the z_stream size differs from that used by the library.

    In addition, the msg field of the stream may be set to an error message.
*/

specification
IntT deflateInit__spec(     CallContext context, ZStream* strm, IntT level,
                            CString* version, IntT stream_size )
{
    pre
    {
        /*
         * The level supplied shall be a value between 0 and 9,
         * or the value Z_DEFAULT_COMPRESSION
         */
        REQ("deflateInit_.05", 
            "The level supplied shall be Z_DEFAULT_COMPRESSION or in[0, 9]",  
                                    level>=-1 && level<=9
                                    ||  level==SUT_Z_DEFAULT_COMPRESSION);

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, deflateInit_() shall return a value as described below
         * to indicate the error.
         */
        ERROR_BEGIN(LSB_DEFLATEINIT_, "deflateInit_.11",
                            deflateInit__spec!=SUT_Z_OK, deflateInit__spec)
        /*
         * On error, deflateInit_() shall return one of the
         * following error indicators: 
         * 
         * [Z_STREAM_ERROR]
         *
         * Invalid parameter.
         */
            ERROR_SHALL(LSB_DEFLATEINIT_, Z_STREAM_ERROR, "deflateInit_.12.01",
                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, deflateInit_() shall return one of the
         * following error indicators: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available.
         */
            ERROR_SHALL(LSB_DEFLATEINIT_, Z_MEM_ERROR, "deflateInit_.12.02",
                TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, deflateInit_() shall return one of the
         * following error indicators: 
         * 
         * [Z_VERSION_ERROR]
         *
         * The version requested is not compatible with the library 
         * version, or the z_stream size differs from that used by the library.
         */
        /*
         * deflateInit_() shall fail, and return Z_VERSION_ERROR
         * 
         * If the version requested is not compatible with
         * the version implemented
         *
         *  or
         *
         * if the size of the z_stream_s structure provided in
         * stream_size does not match the size in the library implementation
         */
            ERROR_SHALL(LSB_DEFLATEINIT_, Z_VERSION_ERROR,
            "deflateInit_.04.01;deflateInit_.04.02;deflateInit_.12.03",
                charAt_CString(version, 0) != SUT_ZLIB_VERSION[0])
//                ||
//                stream_size !=  SUT_ZSTREAM_SIZE)

        ERROR_END()

        /*
         * On success, the deflateInit_() function shall return Z_OK.
         */
        REQ("deflateInit_.10", 
            "On success, shall return Z_OK", 
            deflateInit__spec==SUT_Z_OK);

        /*
         * The deflateInit_() function shall initialize the compression system.
         */
        IMPLEMENT_REQ("deflateInit_.01");

        /*
         * On entry, stream shall refer to a user supplied z_stream object (a 
         * z_stream_s structure).
         */
        IMPLEMENT_REQ("deflateInit_.02");

        /*
         * The following fields shall be set on entry: 
         * 
         * zalloc
         *
         * a pointer to an alloc_func function, used to allocate
         * state information. 
         * If this is NULL, a default allocation function will be used.
         */
        REQ("deflateInit_.03.01", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * zfree
         *
         * a pointer to a free_func function, used to free memory
         * allocated by the zalloc function. If this is NULL a default
         * free function will be used.
         */
        REQ("deflateInit_.03.02", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * opaque
         *
         * If alloc_func is not NULL, opaque is a user supplied
         * pointer to data that will be passed to the alloc_func
         * and free_func functions.
         */
        REQ("deflateInit_.03.03", "", TODO_REQ());


        /*
         * A level of 1 requests the highest speed, while
         * a level of 9 requests the highest compression
         */
        REQ("deflateInit_.06", "", TODO_REQ());

        /*
         * A level of 0 indicates that no compression should be used,
         * and the output shall be the same as the input
         */
        REQ("deflateInit_.07", "", TODO_REQ());

        /*
         * The deflateInit_() function is not in the source standard;
         * it is only in the binary standard.
         * Source applications should use the deflateInit() macro.
         */
        REQ("deflateInit_.08", "", TODO_REQ());

        /*
         * The deflateInit_() function is equivalent to 
         * 
         * deflateInit2_(stream, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, 
         * Z_DEFAULT_STRATEGY, version, stream_size);
         */
        //Implemented in scenario
        IMPLEMENT_REQ("deflateInit_.09.01");

        /*
         * In addition, the msg field of the stream may be set
         * to an error message.
         */
        REQ("deflateInit_.13", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateParams

NAME

    deflateParams -- set compression parameters

SYNOPSIS

    #include <zlib.h>

    int deflateParams(z_streamp stream, int level, int strategy);

DESCRIPTION

    The deflateParams() function shall dynamically alter the compression 
    parameters for the compression stream object stream. On entry, stream 
    shall refer to a user supplied z_stream object (a z_stream_s structure), 
    already initialized via a call to deflateInit_() or deflateInit2_().

    The level supplied shall be a value between 0 and 9, or the value 
    Z_DEFAULT_COMPRESSION. A level of 1 requests the highest speed, while a
    level of 9 requests the highest compression. A level of 0 indicates that no 
    compression should be used, and the output shall be the same as the input.
    If the compression level is altered by deflateParams(), and some data has
    already been compressed with this stream (i.e. total_in is not zero), and
    the new level requires a different underlying compression method, then
    stream shall be flushed by a call to deflate().

    The strategy parameter selects the compression strategy to use: 

    Z_DEFAULT_STRATEGY 

        use the system default compression strategy. Z_DEFAULT_STRATEGY is 
        particularly appropriate for text data.

    Z_FILTERED 

        use a compression strategy tuned for data consisting largely of small
        values with a fairly random distribution. Z_FILTERED uses more Huffman
        encoding and less string matching than Z_DEFAULT_STRATEGY.

    Z_HUFFMAN_ONLY 

        force Huffman encoding only, with no string match.

RETURN VALUE

    On success, the deflateParams() function shall return Z_OK. Otherwise, 
    deflateParams() shall return a value as described below to indicate the
    error.

ERRORS

    On error, deflateParams() shall return one of the following error
    indicators: 

    [Z_STREAM_ERROR] 

        Invalid parameter.

    [Z_MEM_ERROR] 

        Insufficient memory available.

    [Z_BUF_ERROR] 

        Insufficient space in stream to flush the current output.

    In addition, the msg field of the strm may be set to an error message.
*/

specification
IntT deflateParams_spec( CallContext context, ZStream* stream, IntT level,
                            IntT strategy )
{
    pre
    {
        /*
         * The level supplied shall be a value between 0 and 9, or the value 
         * Z_DEFAULT_COMPRESSION.
         */
        REQ("deflateParams.03", 
            "The level supplied shall be Z_DEFAULT_COMPRESSION or in [0, 9]",     
                                    level>=0 && level<=9
                                    ||  level==SUT_Z_DEFAULT_COMPRESSION);
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, deflateParams() shall return a value
         * as described below to indicate the error
         */
        ERROR_BEGIN(LSB_DEFLATEPARAMS, "deflateParams.09",
            deflateParams_spec!=SUT_Z_OK, deflateParams_spec)
        /*
         * On error, deflateParams() shall return one of the following error
         * indicators: 
         * 
         * [Z_STREAM_ERROR]
         *
         * Invalid parameter.
         */
            ERROR_SHALL(LSB_DEFLATEPARAMS, Z_STREAM_ERROR,
                "deflateParams.10.01", TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, deflateParams() shall return one of the following error
         * indicators: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available.
         */
            ERROR_SHALL(LSB_DEFLATEPARAMS, Z_MEM_ERROR, "deflateParams.10.02",
                TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, deflateParams() shall return one of the following error
         * indicators: 
         * 
         * [Z_BUF_ERROR]
         *
         * Insufficient space in stream to flush the current output.
         */
            ERROR_SHALL(LSB_DEFLATEPARAMS, Z_BUF_ERROR, "deflateParams.10.03",
                TODO_ERR(Z_BUF_ERROR))

        ERROR_END()

        /*
         * On success, the deflateParams() function shall return Z_OK. 
         */
        REQ("deflateParams.08", 
            "On success, shall return Z_OK", 
            deflateParams_spec==SUT_Z_OK);

        /*
         * The deflateParams() function shall dynamically alter the compression 
         * parameters for the compression stream object stream.
         */
        REQ("deflateParams.01", "", TODO_REQ());

        /*
         * On entry, stream shall refer to a user supplied z_stream object
         * (a z_stream_s structure), already initialized via a call
         * to deflateInit_() or deflateInit2_().
         */
        IMPLEMENT_REQ("deflateParams.02");

        /*
         * A level of 1 requests the highest speed, while a level of 9
         * requests the highest compression.
         */
        REQ("deflateParams.04", "", TODO_REQ());

        /*
         * A level of 0 indicates that no compression should be used,
         * and the output shall be the same as the input. 
         */
        REQ("deflateParams.05", "", TODO_REQ());

        /*
         * If the compression level is altered by deflateParams(),
         * and some data has already been compressed with this stream
         * (i.e. total_in is not zero), and the 
         * new level requires a different underlying compression method,
         * then stream shall be flushed by a call to deflate().
         */
        REQ("deflateParams.06", "", TODO_REQ());

       if(strategy == SUT_Z_DEFAULT_STRATEGY)
        {        
            /*
             * The strategy parameter selects the compression strategy to use: 
             * 
             * Z_DEFAULT_STRATEGY
             *
             *      use the system default compression strategy. 
             *      Z_DEFAULT_STRATEGY is particularly appropriate for text
             *      data.
             */
            REQ("deflateParams.07.01", "", TODO_REQ());
        }
        else if(strategy == SUT_Z_FILTERED)
        {
            /*
             * The strategy parameter selects the compression strategy to use: 
             * 
             * Z_FILTERED
             *
             *      use a compression strategy tuned for data consisting
             *      largely of small values with a fairly random distribution.
             *      Z_FILTERED uses more Huffman encoding and less string
             *      matching than Z_DEFAULT_STRATEGY.
             */
            REQ("deflateParams.07.02", "", TODO_REQ());
        }
        else if(strategy == SUT_Z_HUFFMAN_ONLY)
        {
            /*
             * The strategy parameter selects the compression strategy to use: 
             * 
             * Z_HUFFMAN_ONLY
             *
             *      force Huffman encoding only, with no string match.
             */
            REQ("deflateParams.07.03", "", TODO_REQ());
        }


        /*
         * In addition, the msg field of the strm may be set to
         * an error message.
         */
        REQ("deflateParams.11", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateReset

NAME

    deflateReset -- reset compression stream state

SYNOPSIS

    #include <zlib.h>

    int deflateReset(z_streamp stream);

DESCRIPTION

    The deflateReset() function shall reset all state associated with stream.
    All pending output shall be discarded, and the counts of processed bytes
    (total_in and total_out) shall be reset to zero.

RETURN VALUE

    On success, deflateReset() shall return Z_OK. Otherwise it shall return 
    Z_STREAM_ERROR to indicate the error.

ERRORS

    On error, deflateReset() shall return Z_STREAM_ERROR.
    The following conditions shall be treated as an error: 

        The state in stream is inconsistent or inappropriate.

        stream is NULL.
*/

specification
IntT deflateReset_spec( CallContext context, ZStream* stream )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise it shall return Z_STREAM_ERROR to indicate the error.
         */
        ERROR_BEGIN(LSB_DEFLATERESET, "deflateReset.04",
                            deflateReset_spec!=SUT_Z_OK, deflateReset_spec)
        /*
         * The following conditions shall be treated as an error: 
         *
         *      The state in stream is inconsistent or inappropriate.
         *
         *      stream is NULL.    
         */
            ERROR_SHALL3(LSB_DEFLATERESET, Z_STREAM_ERROR,
                "deflateReset.05.01.01;deflateReset.05.01.02",
                stream==NULL ? True_Bool3 : Unknown_Bool3)

        ERROR_END()

        /*
         * On success, deflateReset() shall return Z_OK.
         */
        REQ("deflateReset.03", 
            "On success, shall return Z_OK", 
            deflateReset_spec==SUT_Z_OK);

        /*
         * The deflateReset() function shall reset
         * all state associated with stream.
         */
        /*
         * All pending output shall be discarded, and the counts
         * of processed bytes (total_in and total_out) shall be reset to zero.
         */
        REQ("deflateReset.01;deflateReset.02", 
            "Shall reset all state associated with stream",
                stream->total_in==0
            &&  stream->total_out==0);

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    deflateSetDictionary

NAME

    deflateSetDictionary -- initialize compression dictionary

SYNOPSIS

    #include <zlib.h>

    int deflateSetDictionary(z_streamp stream, const Bytef * dictionary, uInt 
        dictlen);

DESCRIPTION

    The deflateSetDictionary() function shall initialize the compression 
    dictionary associated with stream using the dictlen bytes referenced by 
    dictionary.

    The implementation may silently use a subset of the provided dictionary if
    the dictionary cannot fit in the current window associated with stream
    (see deflateInit2_()). The application should ensure that the dictionary is
    sorted such that the most commonly used strings occur at the end of the
    dictionary.

    If the dictionary is successfully set, the Adler32 checksum of the entire 
    provided dictionary shall be stored in the adler member of stream. This 
    value may be used by the decompression system to select the correct
    dictionary. The compression and decompression systems must use the same
    dictionary.

    stream shall reference an initialized compression stream,
    with total_in zero (i.e. no data has been compressed since the stream
    was initialized).

RETURN VALUE

    On success, deflateSetDictionary() shall return Z_OK. Otherwise it shall 
    return Z_STREAM_ERROR to indicate an error.

ERRORS

    On error, deflateSetDictionary() shall return a value as described below: 

    [Z_STREAM_ERROR] 

        The state in stream is inconsistent, or stream was NULL.
*/

specification
IntT deflateSetDictionary_spec( CallContext context, ZStream* stream,
                               StringTPtr dictionary, UIntT dictlen)
{
    pre
    {
        /*
         * The application should ensure that the dictionary is sorted
         * such that the most commonly used strings occur at the end of
         * the dictionary.
         */
        REQ("app.deflateSetDictionary.03", "", TODO_REQ());

        /*
         * This value may be used by the decompression system
         * to select the correct dictionary.
         */
        REQ("app.deflateSetDictionary.05", "", TODO_REQ());

        /*
         * The compression and decompression systems must use
         * the same dictionary.
         */
        REQ("app.deflateSetDictionary.06", "", TODO_REQ());

        if(stream!=NULL)
        {        
            /*
             * stream shall reference an initialized compression stream,
             * with total_in zero (i.e. no data has been compressed since
             * the stream was initialized).
             */
            REQ("deflateSetDictionary.07", 
                "stream shall reference an initialized compression stream, "
                "with total_in zero", 
                stream->total_in == 0);
        }

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        CByteArray* adler_buf=readCByteArray_VoidTPtr(dictionary, dictlen);

        /*
         * Otherwise it shall return Z_STREAM_ERROR to indicate an error.
         */
        ERROR_BEGIN(LSB_DEFLATESETDICTIONARY, "deflateSetDictionary.09",
            deflateSetDictionary_spec!=SUT_Z_OK, deflateSetDictionary_spec)
        /*
         * On error, deflateSetDictionary() shall return a value
         * as described below: 
         * 
         * [Z_STREAM_ERROR]
         *
         * The state in stream is inconsistent, or stream was NULL.
         */
            ERROR_SHALL3(LSB_DEFLATESETDICTIONARY, Z_STREAM_ERROR,
            "deflateSetDictionary.10.01",
            stream==NULL ? True_Bool3 : Unknown_Bool3)

        ERROR_END()
        /*
         * On success, deflateSetDictionary() shall return Z_OK. 
         */
        REQ("deflateSetDictionary.08", "On success, shall return Z_OK",
            deflateSetDictionary_spec==SUT_Z_OK);

        /*
         * The deflateSetDictionary() function shall initialize the compression 
         * dictionary associated with stream using the dictlen bytes referenced
         * by dictionary.
         */
        REQ("deflateSetDictionary.01", "", TODO_REQ());

        /*
         * The implementation may silently use a subset of the provided
         * dictionary if the dictionary cannot fit in the current window
         * associated with stream (see deflateInit2_()). 
         */
        REQ("deflateSetDictionary.02", "", TODO_REQ());

        /*
         * If the dictionary is successfully set, the Adler32 checksum
         * of the entire provided dictionary shall be stored in the adler
         * member of stream.
         */
        REQ("deflateSetDictionary.04", "If the dictionary is successfully set",
            adler32_model(1, adler_buf, adler_buf->length) == stream->adler);

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    get_crc_table

NAME

    get_crc_table -- generate a table for crc calculations

SYNOPSIS

    #include <zlib.h>

    const uLongf * get_crc_table(void);

DESCRIPTION

    Generate tables for a byte-wise 32-bit CRC calculation based on the
    polynomial: 
    x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1

    In a multi-threaded application, get_crc_table() should be called by one 
    thread to initialize the tables before any other thread calls any libz 
    function.

RETURN VALUE

    The get_crc_table() function shall return a pointer to the first of a set of 
    tables used internally to calculate CRC-32 values (see crc32()).

Errors

    None defined.
*/
specification
List* get_crc_table_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * In a multi-threaded application, get_crc_table() should be called
         * by one thread to initialize the tables before any other thread
         * calls any libz function.
         */
        REQ("get_crc_table.02", "", TODO_REQ());

        /*
         * The get_crc_table() function shall return a pointer to the first
         * of a set of tables used internally to calculate CRC-32 values
         * (see crc32()).
         */
        /*
         * Generate tables for a byte-wise 32-bit CRC calculation based on
         * the polynomial: 
         * x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
         */
        REQ("get_crc_table.01;get_crc_table.03", 
            "Shall return a pointer to the first of a set of tables",
            equals(get_crc_table_spec, get_crc_table_model()));

        return true;
    }
}

List* get_crc_table_model()
{
    ULongT c;
    IntT n, k;
    ULongT poly;                 /* polynomial exclusive-or pattern */
    List* crc_table=create_List(&type_ULongTObj);
    /* terms of polynomial defining this crc (except x^32): */
    //static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

    /* make exclusive-or pattern from polynomial*/
    poly = 0UL;
    poly |= 1UL << (31 - 0);
    poly |= 1UL << (31 - 1);
    poly |= 1UL << (31 - 2);
    poly |= 1UL << (31 - 4);
    poly |= 1UL << (31 - 5);
    poly |= 1UL << (31 - 7);
    poly |= 1UL << (31 - 8);
    poly |= 1UL << (31 - 10);
    poly |= 1UL << (31 - 11);
    poly |= 1UL << (31 - 12);
    poly |= 1UL << (31 - 16);
    poly |= 1UL << (31 - 22);
    poly |= 1UL << (31 - 23);
    poly |= 1UL << (31 - 26);

    /* generate a crc for every 8-bit value */
    for (n = 0; n < 256; n++) {
        c = (ULongT)n;
        for (k = 0; k < 8; k++)
            c = c & 1 ? poly ^ (c >> 1) : c >> 1;
        append_List(crc_table, create_ULongTObj(c));
    }
   
    return crc_table;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzclose

NAME

    gzclose -- close a compressed file stream

SYNOPSIS

    #include <zlib.h>

    int gzclose (gzFile file );

DESCRIPTION

    The gzclose() function shall close the compressed file stream file. If 
    file was open for writing, gzclose() shall first flush any pending output.
    Any state information allocated shall be freed.

RETURN VALUE

    On success, gzclose() shall return Z_OK. Otherwise, gzclose() shall return
    an error value as described below.

ERRORS

    On error, gzclose() may set the global variable errno to indicate the
    error. The gzclose() shall return a value other than Z_OK on error. 

    [Z_STREAM_ERROR] 

        file was NULL (or Z_NULL), or did not refer to an open compressed file
        stream.

    [Z_ERRNO] 

        An error occurred in the underlying base libraries, and the application
        should check errno for further information.

    [Z_BUF_ERROR] 

        no compression progress is possible during buffer flush (see
        deflate()).
*/

specification
IntT gzclose_spec( CallContext context, VoidTPtr file, ErrorCode* errnum,
                                                    ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, gzclose() shall return an error value as described below.
         */
        /*
         * The gzclose() shall return a value other than Z_OK on error. 
         */
        ERROR_BEGIN(LSB_GZCLOSE, "gzclose.04;gzclose.06",
                                gzclose_spec!=SUT_Z_OK,
                                gzclose_spec!=SUT_Z_OK ? *errnum : SUT_Z_OK)
        /*
         * On error, gzclose() may set the global variable errno to indicate
         * the error.
         * 
         * [Z_STREAM_ERROR]
         *
         * file was NULL (or Z_NULL), or did not refer to an open 
         * compressed file stream.
         */
            ERROR_MAY3(LSB_GZCLOSE, Z_STREAM_ERROR, "gzclose.05.01",
                isNULL_VoidTPtr(file) ? True_Bool3 : Unknown_Bool3)

        /*
         * On error, gzclose() may set the global variable errno to indicate
         * the error.
         * 
         * [Z_ERRNO]
         *
         * An error occurred in the underlying base libraries, and the 
         * application should check errno for further information.
         */
            ERROR_MAY(LSB_GZCLOSE, Z_ERRNO, "gzclose.05.02",
                TODO_ERR(Z_ERRNO))

        /*
         * On error, gzclose() may set the global variable errno to indicate
         * the error.
         * 
         * [Z_BUF_ERROR]
         *
         * no compression progress is possible during buffer flush (see 
         * deflate()).
         */
            ERROR_MAY(LSB_GZCLOSE, Z_BUF_ERROR, "gzclose.05.03",
                TODO_ERR(Z_BUF_ERROR))

        ERROR_END()

        /*
         * On success, gzclose() shall return Z_OK.
         */
        REQ("gzclose.03", 
            "On success, shall return Z_OK", 
            gzclose_spec == SUT_Z_OK);

        /*
         * The gzclose() function shall close the compressed file stream file.
         */
        REQ("gzclose.01", "", TODO_REQ());

        /*
         * If file was open for writing, gzclose() shall first flush any
         * pending output. Any state information allocated shall be freed.
         */
        REQ("gzclose.02", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzdopen

NAME

    gzdopen -- open a compressed file

SYNOPSIS

    #include <zlib.h>

    gzFile gzdopen ( int fd, const char *mode );

DESCRIPTION

    The gzdopen() function shall attempt to associate the open file referenced
    by fd with a gzFile object. The mode argument is based on that of fopen(),
    but the mode parameter may also contain the following characters: 

    digit 

        set the compression level to digit. A low value (e.g. 1) means high
        speed, while a high value (e.g. 9) means high compression. A
        compression level of 0 (zero) means no compression.
        See defaultInit2_() for further details.

    [fhR] 

        set the compression strategy to [fhR]. The letter f corresponds to
        filtered data, the letter h corresponds to Huffman only compression,
        and the letter R corresponds to Run Length Encoding. See
        defaultInit2_() for further details. 

    If fd refers to an uncompressed file, and mode refers to a read mode, 
    gzdopen() shall attempt to open the file and return a gzFile object suitable 
    for reading directly from the file without any decompression.

    If mode is NULL, or if mode does not contain one of r, w, or a, gzdopen() 
    shall return Z_NULL, and need not set any other error condition.

RETURN VALUE

    On success, gzdopen() shall return a gzFile object. On failure, gzdopen() 
    shall return Z_NULL and may set errno accordingly. 

        Note: At version 1.2.2, zlib does not set errno for several error
        conditions. Applications may not be able to determine the cause of
        an error.

ERRORS

    On error, gzdopen() may set the global variable errno to indicate the
    error.
*/

specification
VoidTPtr gzdopen_spec( CallContext context, FileDescId fd, CString* mode,
                                            ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        if(!gzopen_mode_check(mode))
        {        
            /*
             * If mode is NULL, or if mode does not contain one of r, w, or a,
             * gzdopen() shall return Z_NULL, and need not set any other error
             * condition.
             */
            REQ("gzdopen.04", 
                "Return Z_NULL, if mode is NULL or does not contain r, w or a", 
                isNULL_VoidTPtr(gzdopen_spec));
        }

        /*
         * On failure, gzdopen() shall return Z_NULL and may set errno
         * accordingly. 
         */
        ERROR_BEGIN(LSB_GZDOPEN, "gzdopen.06;gzdopen.07", isNULL_VoidTPtr(gzdopen_spec),
                            *errno)
        ERROR_END()

        /*
         * The gzdopen() function shall attempt to associate the open file
         * referenced by fd with a gzFile object.
         */
        REQ("gzdopen.01", "", TODO_REQ());

        /*
         * The mode argument is based on that of fopen(), but the mode
         * parameter may also contain the following characters: 
         * 
         * digit
         *
         * set the compression level to digit. A low value (e.g. 1) means
         * high speed, while a high value (e.g. 9) means high compression. A
         * compression level of 0 (zero) means no compression.
         * See defaultInit2_() for further details.
         */
        REQ("gzdopen.02.01", "", TODO_REQ());

        /*
         * The mode argument is based on that of fopen(), but the mode
         * parameter may also contain the following characters: 
         * 
         * [fhR]
         *
         * set the compression strategy to [fhR]. The letter f corresponds to 
         * filtered data, the letter h corresponds to Huffman only compression,
         * and the letter R corresponds to Run Length Encoding. See
         * defaultInit2_() for further details.
         */
        REQ("gzdopen.02.02", "", TODO_REQ());

        /*
         * If fd refers to an uncompressed file, and mode refers to a read
         * mode, gzdopen() shall attempt to open the file and return a gzFile
         * object suitable for reading directly from the file without any
         * decompression.
         */
        REQ("gzdopen.03", "", TODO_REQ());

        /*
         * On success, gzdopen() shall return a gzFile object.
         */
        REQ("gzdopen.05", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzeof

NAME

    gzeof -- check for end-of-file on a compressed file stream

SYNOPSIS

    #include <zlib.h>

    int gzeof (gzFile file );

DESCRIPTION

    The gzeof() function shall test the compressed file stream file for end of 
    file.

RETURN VALUE

    If file was open for reading and end of file has been reached, gzeof()
    shall return 1. Otherwise, gzeof() shall return 0.

ERRORS

    None defined.
*/

specification
IntT gzeof_spec( CallContext context, VoidTPtr file )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gzeof() function shall test the compressed file stream file for
         * end of file.
         */
        REQ("gzeof.01", "", TODO_REQ());

        REQ("", "Implicit condition", gzeof_spec == 0 || gzeof_spec == 1);
        /*
         * If file was open for reading and end of file has been reached,
         * gzeof() shall return 1.
         */
        REQ("gzeof.02", "", TODO_REQ());

        /*
         * Otherwise, gzeof() shall return 0.
         */
        REQ("gzeof.03", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzerror

NAME

    gzerror -- decode an error on a compressed file stream

SYNOPSIS

    #include <zlib.h>

    const char * gzerror (gzFile file, int * errnum);

DESCRIPTION

    The gzerror() function shall return a string describing the last error to
    have occurred associated with the open compressed file stream referred to
    by file. It shall also set the location referenced by errnum to an integer
    value that further identifies the error. 

RETURN VALUE

    The gzerror() function shall return a string that describes the last error 
    associated with the given file compressed file stream. This string 
    shall have the format "%s: %s", with the name of the file, 
    followed by a colon, a space, and the description of the error. If the 
    compressed file stream was opened by a call to gzdopen(), the format of the 
    filename is unspecified. 

    It is unspecified if the string returned is determined by the setting of
    the LC_MESSAGES category in the current locale.

ERRORS

    None defined.
*/

specification
CString* gzerror_spec( CallContext context, VoidTPtr file, IntT* errnum)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gzerror() function shall return a string describing the last
         * error to have occurred associated with the open compressed file
         * stream referred to by file.
         */
        REQ("gzerror.01", "", TODO_REQ());

        /*
         * It shall also set the location referenced by errnum to an integer
         * value that further identifies the error. 
         */
        REQ("gzerror.02", "", TODO_REQ());

        /*
         * The gzerror() function shall return a string that describes the last
         * error associated with the given file compressed file stream. This
         * string shall have the format "%s: %s", with the name of the file, 
         * followed by a colon, a space, and the description of the error. 
         */
        REQ("gzerror.03", "", TODO_REQ());

        /*
         * If the compressed file stream was opened by a call to gzdopen(),
         * the format of the filename is unspecified. 
         */
        REQ("gzerror.04", "", TODO_REQ());

        /*
         * It is unspecified if the string returned is determined by the
         * setting of the LC_MESSAGES category in the current locale.
         */
        REQ("gzerror.05", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzflush

NAME

    gzflush -- flush a compressed file stream

SYNOPSIS

    #include <zlib.h>

    int gzflush(gzFile file, int flush);

DESCRIPTION

    The gzflush() function shall flush pending output to the compressed file 
    stream identified by file, which must be open for writing. 

    Flush Operation

    The parameter flush determines which compressed bits are added to the
    output file.

        If flush is Z_NO_FLUSH, gzflush() may return with some data pending 
        output, and not yet written to the file.

        If flush is Z_SYNC_FLUSH, gzflush() shall flush all pending output to
        file and align the output to a byte boundary. There may still be data
        pending compression that is not flushed.

        If flush is Z_FULL_FLUSH, all output shall be flushed, as for
        Z_SYNC_FLUSH, and the compression state shall be reset. There may still
        be data pending compression that is not flushed. 

        If flush is set to Z_FINISH, all pending uncompressed data shall be
        compressed and all output shall be flushed.

RETURN VALUE

    On success, gzflush() shall return the value Z_OK. Otherwise gzflush() shall 
    return a value to indicate the error, and may set the error number
    associated with the compressed file stream file. 

ERRORS

    On error, gzwrite() shall return an error value, and may set the error
    number associated with the stream identified by file to indicate the error. 
    Applications may use gzerror() to access this error value.

    [Z_ERRNO] 

        An underlying base library function has indicated an error. The global 
        variable errno may be examined for further information.

    [Z_STREAM_ERROR] 

        The stream is invalid, is not open for writing, or is in an invalid
        state.

    [Z_BUF_ERROR] 

        no compression progress is possible (see deflate()).

    [Z_MEM_ERROR] 

        Insufficient memory available to compress.
*/

specification
IntT gzflush_spec( CallContext context, VoidTPtr file, IntT flush,
                  ErrorCode* errnum, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise gzflush() shall return a value to indicate the error,
         * and may set the error number associated with the compressed file
         * stream file. 
         */
        ERROR_BEGIN(LSB_GZFLUSH, "gzflush.04",
            gzflush_spec!=SUT_Z_OK,
            gzflush_spec!=SUT_Z_OK ? *errnum: SUT_Z_OK)
        /*
         * On error, gzflush() shall return an error value, and may set the
         * error number associated with the stream identified by file to
         * indicate the error. 
         * Applications may use gzerror() to access this error value.
         * 
         * [Z_ERRNO]
         *
         *    An underlying base library function has indicated an error. The 
         *    global variable errno may be examined for further information.
         */
            ERROR_SHALL(LSB_GZFLUSH, Z_ERRNO, "gzflush.05.01",
                TODO_ERR(Z_ERRNO))

        /*
         * On error, gzflush() shall return an error value, and may set the
         * error number associated with the stream identified by file to
         * indicate the error. 
         * Applications may use gzerror() to access this error value.
         * 
         * [Z_STREAM_ERROR]
         *
         *    The stream is invalid, is not open for writing, or is in an 
         *    invalid state.
         */
            ERROR_SHALL(LSB_GZFLUSH, Z_STREAM_ERROR, "gzflush.05.02",
                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, gzflush() shall return an error value, and may set the
         * error number 
         * associated with the stream identified by file to indicate the error. 
         * Applications may use gzerror() to access this error value.
         * 
         * [Z_BUF_ERROR]
         *
         *    no compression progress is possible (see deflate()).
         */
            ERROR_SHALL(LSB_GZFLUSH, Z_BUF_ERROR, "gzflush.05.03",
                TODO_ERR(Z_BUF_ERROR))

        /*
         * On error, gzflush() shall return an error value, and may set the
         * error number 
         * associated with the stream identified by file to indicate the error. 
         * Applications may use gzerror() to access this error value.
         * 
         * [Z_MEM_ERROR]
         *
         *      Insufficient memory available to compress.
         */
            ERROR_SHALL(LSB_GZFLUSH, Z_MEM_ERROR, "gzflush.05.04",
                TODO_ERR(Z_MEM_ERROR))

        ERROR_END()

        /*
         * On success, gzflush() shall return the value Z_OK.
         */
        REQ("gzflush.03", 
            "On success, shall return the value Z_OK", 
            gzflush_spec == SUT_Z_OK);

        /*
         * The gzflush() function shall flush pending output to the compressed
         * file stream identified by file, which must be open for writing. 
         */
        REQ("gzflush.01", "", TODO_REQ());

        if(flush == SUT_Z_NO_FLUSH)
        {        
            /*
             * The parameter flush determines which compressed bits are added
             * to the output file.
             * 
             * If flush is Z_NO_FLUSH, gzflush() may return with some data
             * pending output, and not yet written to the file.
             */
            REQ("gzflush.02.01", "", TODO_REQ());
        }
        else if(flush == SUT_Z_SYNC_FLUSH)
        {
            /*
             * The parameter flush determines which compressed bits are added
             * to the output file.
             * 
             * If flush is Z_SYNC_FLUSH, gzflush() shall flush all pending
             * output to file and align the output to a byte boundary. There
             * may still be data pending compression that is not flushed.
             */
            REQ("gzflush.02.02", "", TODO_REQ());
        }
        else if(flush == SUT_Z_FULL_FLUSH)
        {        
            /*
             * The parameter flush determines which compressed bits are added
             * to the output file.
             * 
             * If flush is Z_FULL_FLUSH, all output shall be flushed, as for
             * Z_SYNC_FLUSH, and the compression state shall be reset. There
             * may still be data pending compression that is not flushed. 
             */
            REQ("gzflush.02.03", "", TODO_REQ());
        }
        else if(flush == SUT_Z_FINISH)
        {
            /*
             * The parameter flush determines which compressed bits are added 
             * to the output file.
             * 
             * If flush is set to Z_FINISH, all pending uncompressed data shall
             * be compressed and all output shall be flushed.
             */
            REQ("gzflush.02.04", "", TODO_REQ());
        }

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzgetc

NAME

    gzgetc -- read a character from a compressed file

SYNOPSIS

    #include <zlib.h>

    int gzgetc (gzFile file);

DESCRIPTION

    The gzgetc() function shall read the next single character from the
    compressed file stream referenced by file, which shall have been opened in
    a read mode (see gzopen() and gzdopen()).

RETURN VALUE

    On success, gzgetc() shall return the uncompressed character read,
    otherwise, on end of file or error, gzgetc() shall return -1.

ERRORS

    On end of file or error, gzgetc() shall return -1. Further information can
    be found by calling gzerror() with a pointer to the compressed file stream.
*/

specification
IntT gzgetc_spec( CallContext context, VoidTPtr file, ErrorCode* errno )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gzgetc() function shall read the next single character from the
         * compressed file stream referenced by file, which shall have been
         * opened in a read mode (see gzopen() and gzdopen()).
         */
        REQ("gzgetc.01", "", TODO_REQ());

        /*
         * On success, gzgetc() shall return the uncompressed character read
         */
        REQ("gzgetc.02", "", TODO_REQ());

        /*
         * otherwise, on end of file or error, gzgetc() shall return -1.
         */
        /*
         * On end of file or error, gzgetc() shall return -1.
         */
        REQ("gzgetc.03;gzgetc.04", "", TODO_REQ());

        /*
         * Further information can be found by calling gzerror() with a pointer
         * to the compressed file stream.
         */
        IMPLEMENT_REQ("gzgetc.05");

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzgets

NAME

    gzgets -- read a string from a compressed file

SYNOPSIS

    #include <zlib.h>

    char * gzgets (gzFile file, char * buf, int len);

DESCRIPTION

    The gzgets() function shall attempt to read data from the compressed file 
    stream file, uncompressing it into buf until either len-1 bytes have been 
    inserted into buf, or until a newline character has been uncompressed into
    buf. A null byte shall be appended to the uncompressed data. The file shall
    have been opened in for reading (see gzopen() and gzdopen()).

RETURN VALUE

    On success, gzgets() shall return a pointer to buf. Otherwise, gzgets() 
    shall return Z_NULL. Applications may examine the cause using gzerror().

ERRORS

On error, gzgets() shall return Z_NULL.
The following conditions shall always be treated as an error: 

    file is NULL, or does not refer to a file open for reading;
    
    buf is NULL;
    
    len is less than or equal to zero.
*/

specification
StringTPtr gzgets_spec( CallContext context, VoidTPtr file, StringTPtr buf,
                        IntT len, ErrorCode* errno)
{
    pre
    {

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Applications may examine the cause using gzerror().
         */
        IMPLEMENT_REQ("app.gzgets.06");

        /*
         * The gzgets() function shall attempt to read data from the compressed
         * file stream file, uncompressing it into buf until either len-1 bytes
         * have been inserted into buf, or until a newline character has been
         * uncompressed into buf.
         */
        REQ("gzgets.01", "", TODO_REQ());

        /*
         * A null byte shall be appended to the uncompressed data. 
         */
        REQ("gzgets.02", "", TODO_REQ());

        /*
         * The file shall have been opened in for reading (see gzopen() and
         * gzdopen()).
         */
        REQ("gzgets.03", "", TODO_REQ());

        /*
         * On success, gzgets() shall return a pointer to buf.
         */
        REQ("gzgets.04", "", TODO_REQ());

        if(isNULL_VoidTPtr(file)
            || /*!open 4 reading ||*/ isNULL_VoidTPtr(buf)
            || len <= 0)
        {        
            /*
             * Otherwise, gzgets() shall return Z_NULL.
             */
            /*
             * On error, gzgets() shall return Z_NULL. 
             */
            /*
             * The following conditions shall always be treated as an error: 
             * 
             * file is NULL, or does not refer to a file open for reading
             */
            /*
             * The following conditions shall always be treated as an error: 
             * 
             * buf is NULL;
             */
            /*
             * The following conditions shall always be treated as an error: 
             * 
             * len is less than or equal to zero.
             */
            REQ("gzgets.05;gzgets.07;gzgets.08.01;gzgets.08.02;gzgets.08.03",
                "gzgets == Z_NULL", isNULL_VoidTPtr(gzgets_spec));
        }

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzopen

NAME

    gzopen -- open a compressed file

SYNOPSIS

    #include <zlib.h>

    gzFile gzopen (const char *path , const char *mode );

DESCRIPTION

    The gzopen() function shall open the compressed file named by path. The
    mode argument is based on that of fopen(), but the mode parameter may also 
    contain the following characters: 

    digit 

        set the compression level to digit. A low value (e.g. 1) means high
        speed, while a high value (e.g. 9) means high compression. A
        compression level of 0 (zero) means no compression. See
        defaultInit2_() for further details.

    [fhR] 

        set the compression strategy to [fhR]. The letter f corresponds to
        filtered data, the letter h corresponds to Huffman only compression,
        and the letter R corresponds to Run Length Encoding.
        See defaultInit2_() for further details. 

    If path refers to an uncompressed file, and mode refers to a read mode, 
    gzopen() shall attempt to open the file and return a gzFile object suitable 
    for reading directly from the file without any decompression.

    If path or mode is NULL, or if mode does not contain one of r, w, or a, 
    gzopen() shall return Z_NULL, and need not set any other error condition.

    The gzFile object is also referred to as a compressed file stream.

RETURN VALUE

    On success, gzopen() shall return a gzFile object (also known as a
    compressed file stream). On failure, gzopen() shall return Z_NULL and may
    set errno accordingly. 

        Note: At version 1.2.2, zlib does not set errno for several error
        conditions. Applications may not be able to determine the cause of an
        error.

ERRORS

    On error, gzopen() may set the global variable errno to indicate the error.
*/

specification
VoidTPtr gzopen_spec( CallContext context, CString* path, CString* mode,
                                                            ErrorCode* errno)
{
    pre
    {
        /*
         * The gzFile object is also referred to as a compressed file stream.
         */
        REQ("app.gzopen.05", "", TODO_REQ());
        
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        if(path == NULL || !gzopen_mode_check(mode))
        {        
            /*
             * If path or mode is NULL, or if mode does not contain one of r,
             * w, or a, gzopen() shall return Z_NULL, and need not set any
             * other error condition.
             */
            REQ("gzopen.04", 
                "Return Z_NULL, if mode is NULL or does not contain r, w or a", 
                isNULL_VoidTPtr(gzopen_spec));

            return true;
        }

        /*
         * On failure, gzopen() shall return Z_NULL and may set errno
         * accordingly. 
         */
        ERROR_BEGIN(LSB_GZOPEN, "gzopen.07;gzopen.08",
                            isNULL_VoidTPtr(gzopen_spec),  *errno)
        ERROR_END()

        /*
         * The gzopen() function shall open the compressed file named by path.
         */
        REQ("gzopen.01", "", TODO_REQ());

        /*
         * The mode argument is based on that of fopen(), but the mode
         * parameter may also contain the following characters: 
         * 
         * digit
         *
         *      set the compression level to digit. A low value (e.g. 1) means
         *      high speed, while a high value (e.g. 9) means high compression.
         *      A compression level of 0 (zero) means no compression.
         *      See defaultInit2_() for further details.
         */
        REQ("gzopen.02.01", "", TODO_REQ());

        /*
         * The mode argument is based on that of fopen(), but the mode
         * parameter may also contain the following characters: 
         * 
         * [fhR]
         *
         *      set the compression strategy to [fhR]. The letter f corresponds
         *      to filtered data, the letter h corresponds to Huffman only
         *      compression, and the letter R corresponds to Run Length
         *      Encoding. See defaultInit2_() for further details.
         */
        REQ("gzopen.02.02", "", TODO_REQ());

        /*
         * If path refers to an uncompressed file, and mode refers to a read
         * mode, gzopen() shall attempt to open the file and return a gzFile
         * object suitable for reading directly from the file without any
         * decompression.
         */
        REQ("gzopen.03", "", TODO_REQ());

        /*
         * On success, gzopen() shall return a gzFile object (also known as a
         * compressed file stream).
         */
        REQ("gzopen.06", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

gzprintf
Name
gzprintf -- format data and compress
Synopsis

#include <zlib.h>

int gzprintf (gzFile file, const char * fmt, ...);

Description

    The gzprintf() function shall format data as for fprintf(), and write the resulting 
    string to the compressed file stream file.

Return Value

    The gzprintf() function shall return the number of uncompressed bytes actually written, 
    or a value less than or equal to 0 in the event of an error.

Errors

    If file is NULL, or refers to a compressed file stream that has not been opened for 
    writing, gzprintf() shall return Z_STREAM_ERROR.  Otherwise, errors are as for gzwrite().
*/

specification
IntT gzprintf_spec( CallContext context, VoidTPtr file, CString *str,
                 ErrorCode* errnum, ErrorCode* errno)

{
    pre
    {
       /*
         * Applications may examine the cause using gzerror().
         */
        IMPLEMENT_REQ("app.gzprintf.gzwrite.09");

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        ERROR_BEGIN(LSB_GZPRINTF, "", *errno, *errno )

            /*
             * If file is NULL, or refers to a compressed file stream that has not been opened for 
             * writing, gzprintf() shall return Z_STREAM_ERROR.  Otherwise, errors are as for gzwrite().
             */
            ERROR_SHALL(LSB_GZPRINTF, Z_STREAM_ERROR, "gzprintf.03", TODO_ERR(Z_STREAM_ERROR) )


            /*
             * On error, gzwrite() shall set the error number associated with the stream
             * identified by file to indicate the error.
             *
             * [Z_ERRNO] An underlying base library function has indicated an error. The
             * global variable errno may be examined for further information.
             */
            ERROR_SHALL(LSB_GZPRINTF, Z_ERRNO, "gzprintf.gzwrite.08.01", TODO_ERR(Z_ERRNO) )

            /*
             * On error, gzwrite() shall set the error number associated with the stream
             * identified by file to indicate the error.
             *
             * [Z_STREAM_ERROR] The stream is invalid, is not open for writing, or is in an
             * invalid state.
             */
            ERROR_SHALL(LSB_GZPRINTF, Z_STREAM_ERROR, "gzprintf.gzwrite.08.02", TODO_ERR(Z_STREAM_ERROR) )

            /*
             * On error, gzwrite() shall set the error number associated with the stream
             * identified by file to indicate the error.
             *
             * [Z_BUF_ERROR] no compression progress is possible (see deflate()).
             */
            ERROR_SHALL(LSB_GZPRINTF, Z_BUF_ERROR, "gzprintf.gzwrite.08.03", TODO_ERR(Z_BUF_ERROR) )

            /*
             * On error, gzwrite() shall set the error number associated with the stream
             * identified by file to indicate the error.
             *
             * [Z_MEM_ERROR] Insufficient memory available to compress.
             */
            ERROR_SHALL(LSB_GZPRINTF, Z_MEM_ERROR, "gzprintf.gzwrite.08.04", TODO_ERR(Z_MEM_ERROR) )

        ERROR_END()


        
        /*
         * The gzprintf() function shall format data as for fprintf(), and write the
         * resulting string to the compressed file stream file.
         */
        REQ("gzprintf.01", "", TODO_REQ());

        /*
         * The gzprintf() function shall return the number of uncompressed bytes actually
         * written, or a value less than or equal to 0 in the event of an error.
         */
        REQ("gzprintf.02", "", TODO_REQ());

        /*
         * Otherwise, errors are as for gzwrite().
         */
        REQ("gzprintf.04", "", TODO_REQ());
        
        
        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzputc

NAME

    gzputc -- write character to a compressed file

SYNOPSIS

    #include <zlib.h>

    int gzputc (gzFile file, int c);

DESCRIPTION

    The gzputc() function shall write the single character c, converted from 
    integer to unsigned character, to the compressed file referenced by file, 
    which shall have been opened in a write mode (see gzopen() and gzdopen()).

RETURN VALUE

    On success, gzputc() shall return the value written, otherwise gzputc()
    shall return -1.

ERRORS

    On error, gzputc() shall return -1.
*/

specification
IntT gzputc_spec( CallContext context, VoidTPtr file, IntT c)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gzputc() function shall write the single character c, converted
         * from integer to unsigned character, to the compressed file
         * referenced by file, which shall have been opened in a write mode
         * (see gzopen() and gzdopen()).
         */
        REQ("gzputc.01", "", TODO_REQ());

        if(gzputc_spec == -1)
        {        
            /*
             * otherwise gzputc() shall return -1.
             */
            /*
             * On error, gzputc() shall return -1.
             */
            REQ("gzputc.03;gzputc.04", "", TODO_REQ());
        }
        else
        {
            /*
             * On success, gzputc() shall return the value written
             */
            REQ("gzputc.02", 
                "On success, shall return the value written", 
                gzputc_spec == (UCharT)c);
        }

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzputs

NAME

    gzputs -- string write to a compressed file

SYNOPSIS

    #include <zlib.h>

    int gzputs (gzFile file, const char * s);

DESCRIPTION

    The gzputs() function shall write the null terminated string s to the 
    compressed file referenced by file, which shall have been opened in a write 
    mode (see gzopen() and gzdopen()). The terminating null character shall not 
    be written. The gzputs() function shall return the number of uncompressed 
    bytes actually written.

RETURN VALUE

    On success, gzputs() shall return the number of uncompressed bytes actually 
    written to file. On error gzputs() shall return a value less than or equal
    to 0. Applications may examine the cause using gzerror().

ERRORS

    On error, gzputs() shall set the error number associated with the stream 
    identified by file to indicate the error. Applications should use 
    gzerror() to access this error value. If file is NULL, gzputs() shall 
    return Z_STREAM_ERR.

    [Z_ERRNO] 

        An underlying base library function has indicated an error. The global 
        variable errno may be examined for further information.

    [Z_STREAM_ERROR] 

        The stream is invalid, is not open for writing, or is in an invalid
        state.

    [Z_BUF_ERROR] 

        no compression progress is possible (see deflate()).

    [Z_MEM_ERROR] 

        Insufficient memory available to compress.
*/

specification
IntT gzputs_spec( CallContext context, VoidTPtr file, CString* s,
                 ErrorCode* errnum, ErrorCode* errno)
{
    pre
    {
        /*
         * Applications may examine the cause using gzerror().
         */
        /*
         * Applications should use gzerror() to access this error value.
         */
        IMPLEMENT_REQ("app.gzputs.06;app.gzputs.08");
        
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * On error gzputs() shall return a value less than or equal to 0. 
         */
        ERROR_BEGIN(LSB_GZPUTS, "gzputs.05", gzputs_spec <= 0, 
            //Errors are set in file, we can use them only by calling gzerror
            gzputs_spec <= 0 ? *errnum : SUT_Z_OK)
        /*
         * On error, gzputs() shall set the error number associated with the
         * stream identified by file to indicate the error. 
         * 
         * [Z_ERRNO]
         *
         * An underlying base library function has indicated an error. The 
         * global variable errno may be examined for further information.
         */
            ERROR_SHALL(LSB_GZPUTS, Z_ERRNO, "gzputs.07.01", TODO_ERR(Z_ERRNO))

        /*
         * On error, gzputs() shall set the error number associated with the
         * stream identified by file to indicate the error. 
         * 
         * [Z_STREAM_ERROR]
         *
         * The stream is invalid, is not open for writing, or is in an 
         * invalid state.
         */
        /*
         * If file is NULL, gzputs() shall return Z_STREAM_ERR.
         */
            ERROR_SHALL3(LSB_GZPUTS, Z_STREAM_ERROR, "gzputs.09;gzputs.07.02",
                isNULL_VoidTPtr(file) ? True_Bool3 : Unknown_Bool3)

        /*
         * On error, gzputs() shall set the error number associated with the
         * stream identified by file to indicate the error. 
         * 
         * [Z_BUF_ERROR]
         *
         * no compression progress is possible (see deflate()).
         */
            ERROR_SHALL(LSB_GZPUTS, Z_BUF_ERROR, "gzputs.07.03",
                TODO_ERR(Z_BUF_ERROR))

        /*
         * On error, gzputs() shall set the error number associated with the
         * stream identified by file to indicate the error. 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available to compress.
         */
            ERROR_SHALL(LSB_GZPUTS, Z_MEM_ERROR, "gzputs.07.04",
                TODO_ERR(Z_MEM_ERROR))
        ERROR_END()

        /*
         * The gzputs() function shall write the null terminated string s to
         * the compressed file referenced by file, which shall have been
         * opened in a write mode (see gzopen() and gzdopen()).
         */
        REQ("gzputs.01", "", TODO_REQ());

        /*
         * The terminating null character shall not be written.
         */
        REQ("gzputs.02", "", TODO_REQ());

        /*
         * The gzputs() function shall return the number of uncompressed
         * bytes actually written.
         */
        /*
         * On success, gzputs() shall return the number of uncompressed
         * bytes actually written to file.
         */
        REQ("gzputs.03;gzputs.04", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzread

NAME

    gzread -- read from a compressed file

SYNOPSIS

    #include <zlib.h>

    int gzread (gzFile file, voidp buf, unsigned int len);

DESCRIPTION

    The gzread() function shall read data from the compressed file referenced
    by file, which shall have been opened in a read mode (see gzopen() and
    gzdopen() ). The gzread() function shall read data from file, and
    uncompress it into buf. At most, len bytes of uncompressed data shall be
    copied to buf. If the file is not compressed, gzread() shall simply copy
    data from file to buf without alteration.

RETURN VALUE

    On success, gzread() shall return the number of bytes decompressed into buf. 
    If gzread() returns 0, either the end-of-file has been reached or an 
    underlying read error has occurred. Applications should use gzerror() or 
    gzeof() to determine which occurred. On other errors, gzread() shall return
    a value less than 0 and and applications may examine the cause using
    gzerror(). 

ERRORS

    On error, gzread() shall set the error number associated with the stream 
    identified by file to indicate the error. Applications should use 
    gzerror() to access this error value.

    [Z_ERRNO] 

        An underlying base library function has indicated an error. The global 
        variable errno may be examined for further information.

    [Z_STREAM_END] 

        End of file has been reached on input.

    [Z_DATA_ERROR] 

        A CRC error occurred when reading data; the file is corrupt.

    [Z_STREAM_ERROR] 

        The stream is invalid, or is in an invalid state.

    [Z_NEED_DICT] 

        A dictionary is needed (see inflateSetDictionary()).

    [Z_MEM_ERROR] 

        Insufficient memory available to decompress.
*/

//errnum got by calling gzerror, errno is global
specification
IntT gzread_spec( CallContext context, VoidTPtr file, VoidTPtr buf, UIntT len,
                 ErrorCode* errnum, ErrorCode* errno)
{
    pre
    {
        /*
         * Applications should use gzerror() or gzeof() to determine which
         * occurred.
         */
        /*
         * Applications should use gzerror() to access this error value.
         */
        IMPLEMENT_REQ("app.gzread.06;app.gzread.09");
        
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * If gzread() returns 0, either the end-of-file has been reached
         * or an underlying read error has occurred.
         */
        /*
         * On other errors, gzread() shall return a value less than 0 and
         * applications may examine the cause using gzerror().
         */
        ERROR_BEGIN(LSB_GZREAD, "gzread.05;gzread.07",
            gzread_spec<=0, 
            //This construction added, cause function may return Z_STREAM_END
            //if function read some data and reached end-of-file
            (gzread_spec<=0 ? *errnum : SUT_Z_OK) )
        /*
         * On error, gzread() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_ERRNO]
         *
         * An underlying base library function has indicated an error. The 
         * global variable errno may be examined for further information.
         */
            ERROR_SHALL(LSB_GZREAD, Z_ERRNO, "gzread.08.01", TODO_ERR(Z_ERRNO))

        /*
         * On error, gzread() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_STREAM_END]
         *
         * End of file has been reached on input.
         */
            ERROR_SHALL(LSB_GZREAD, Z_STREAM_END, "gzread.08.02",
                TODO_ERR(Z_STREAM_END))

        /*
         * On error, gzread() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_DATA_ERROR]
         *
         * A CRC error occurred when reading data; the file is corrupt.
         */
            ERROR_SHALL(LSB_GZREAD, Z_DATA_ERROR, "gzread.08.03",
                TODO_ERR(Z_DATA_ERROR))

        /*
         * On error, gzread() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_STREAM_ERROR]
         *
         * The stream is invalid, or is in an invalid state.
         */
            ERROR_SHALL(LSB_GZREAD, Z_STREAM_ERROR, "gzread.08.04",
                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, gzread() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_NEED_DICT]
         *
         * A dictionary is needed (see inflateSetDictionary()).
         */
            ERROR_SHALL(LSB_GZREAD, Z_NEED_DICT, "gzread.08.05",
                TODO_ERR(Z_NEED_DICT))

        /*
         * On error, gzread() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available to decompress.
         */
            ERROR_SHALL(LSB_GZREAD, Z_MEM_ERROR, "gzread.08.06",
                TODO_ERR(Z_MEM_ERROR))

        ERROR_END()

        /*
         * The gzread() function shall read data from the compressed file
         * referenced by file, which shall have been opened in a read mode
         * (see gzopen() and gzdopen() ). The gzread() function shall read
         * data from file, and uncompress it into buf
         */
        REQ("gzread.01", "", TODO_REQ());

        /*
         * At most, len bytes of uncompressed data shall be copied to buf.
         */
        REQ("gzread.02", "", TODO_REQ());

        /*
         * If the file is not compressed, gzread() shall simply copy data
         * from file to buf without alteration.
         */
        REQ("gzread.03", "", TODO_REQ());

        /*
         * On success, gzread() shall return the number of bytes
         * decompressed into buf.
         */
        REQ("gzread.04", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzrewind

NAME

    gzrewind -- reset the file-position indicator on a compressed file stream

SYNOPSIS

    #include <zlib.h>

    int gzrewind(gzFile file);

DESCRIPTION

    The gzrewind() function shall set the starting position for the next read
    on compressed file stream file to the beginning of file. file must be open
    for reading.

    gzrewind() is equivalent to 

        (int)gzseek(file, 0L, SEEK_SET) .

RETUN VALUE

    On success, gzrewind() shall return 0. On error, gzrewind() shall return
    -1, and may set the error value for file accordingly.

ERRORS

    On error, gzrewind() shall return -1, indicating that file is NULL, or does 
    not represent an open compressed file stream, or represents a compressed
    file stream that is open for writing and is not currently at the beginning
    of file.
*/

specification
IntT gzrewind_spec( CallContext context, VoidTPtr file, ErrorCode* errnum)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gzrewind() function shall set the starting position for the next
         * read on compressed file stream file to the beginning of file. file
         * must be open for reading.
         */
        REQ("gzrewind.01", "", TODO_REQ());

        /*
         * gzrewind() is equivalent to 
         * 
         * (int)gzseek(file, 0L, SEEK_SET)
         */
        IMPLEMENT_REQ("gzrewind.02.01");

        if(gzrewind_spec == 0)
        {        
            /*
             * On success, gzrewind() shall return 0.
             */
            REQ("gzrewind.03", "", TODO_REQ());
        }
        else
        {
            /*
             * On error, gzrewind() shall return -1, and may set the error
             * value for file accordingly.
             */
            REQ("gzrewind.04", 
                "On error, shall return -1", 
                gzrewind_spec == -1);

            /*
             * On error, gzrewind() shall return -1, indicating that
             * file is NULL, or does not represent an open compressed
             * file stream, or represents a compressed file stream that
             * is open for writing and is not currently at the
             * beginning of file.
             */
            REQ("gzrewind.05", "", TODO_REQ());
        }

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzseek

NAME

    gzseek -- reposition a file-position indicator in a compressed file stream

SYNOPSIS

    #include <zlib.h>

    z_off_t gzseek(gzFile file, z_off_t offset, int whence);

DESCRIPTION

    The gzseek() function shall set the file-position indicator for the
    compressed file stream file. The file-position indicator controls where
    the next read or write operation on the compressed file stream shall take
    place. The offset indicates a byte offset in the uncompressed data. The
    whence parameter may be one of: 

    SEEK_SET 

        the offset is relative to the start of the uncompressed data.

    SEEK_CUR 

        the offset is relative to the current positition in the uncompressed
        data.

    If the file is open for writing, the new offset must be greater than or
    equal to the current offset. In this case, gzseek() shall compress a
    sequence of null bytes to fill the gap from the previous offset to the new
    offset.

RETURN VALUE

    On success, gzseek() shall return the resulting offset in the file
    expressed as a byte position in the uncompressed data stream. On error,
    gzseek() shall return -1, and may set the error value for file accordingly.

ERRORS

    On error, gzseek() shall return -1. The following conditions shall always 
    result in an error: 

        file is NULL

        file does not represent an open compressed file stream.

        file refers to a compressed file stream that is open for writing,
        and the newly computed offset is less than the current offset.

        The newly computed offset is less than zero.

        whence is not one of the supported values.
*/

specification
OffT gzseek_spec( CallContext context, VoidTPtr file, OffT offset,
                 IntT whence, ErrorCode* errnum)
{
    pre
    {
        /*
         * The file-position indicator controls where the next read or
         * write operation on the compressed file stream shall take place.
         */
        REQ("app.gzseek.02", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gzseek() function shall set the file-position indicator for
         * the compressed file stream file.
         */
        REQ("gzseek.01", "", TODO_REQ());

        /*
         * The offset indicates a byte offset in the uncompressed data.
         */
        REQ("gzseek.03", "", TODO_REQ());

        /*
         * The whence parameter may be one of: 
         * 
         * SEEK_SET
         *
         * the offset is relative to the start of the uncompressed data.
         */
        REQ("gzseek.04.01", "", TODO_REQ());

        /*
         * The whence parameter may be one of: 
         * 
         * SEEK_CUR
         *
         * the offset is relative to the current positition in the
         * uncompressed data.
         */
        REQ("gzseek.04.02", "", TODO_REQ());

        /*
         * If the file is open for writing, the new offset must be greater
         * than or equal to the current offset.
         * 
         * In this case, gzseek() shall compress a sequence of null bytes
         * to fill the gap from the previous offset to the new offset.
         */
        REQ("gzseek.05.01", "", TODO_REQ());

        /*
         * On success, gzseek() shall return the resulting offset in the
         * file expressed as a byte position in the uncompressed data stream.
         */
        REQ("gzseek.06", "", TODO_REQ());

        /*
         * On error, gzseek() shall return -1, and may set the error value
         * for file accordingly.
         */
        /*
         * On error, gzseek() shall return -1.
         */
        REQ("gzseek.07;gzseek.08", "", TODO_REQ());

        /*
         * The following conditions shall always result in an error: 
         * 
         * file is NULL
         */
        REQ("gzseek.09.01", "", TODO_REQ());

        /*
         * The following conditions shall always result in an error: 
         * 
         * file does not represent an open compressed file stream.
         */
        REQ("gzseek.09.02", "", TODO_REQ());

        /*
         * The following conditions shall always result in an error: 
         * 
         * file refers to a compressed file stream that is open for writing,
         * and the newly computed offset is less than the current offset.
         */
        REQ("gzseek.09.03", "", TODO_REQ());

        /*
         * The following conditions shall always result in an error: 
         * 
         * The newly computed offset is less than zero.
         */
        REQ("gzseek.09.04", "", TODO_REQ());

        /*
         * The following conditions shall always result in an error: 
         * 
         * whence is not one of the supported values.
         */
        REQ("gzseek.09.05", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzsetparams

NAME

    gzsetparams -- dynamically set compression parameters

SYNOPSIS

    #include <zlib.h>

    int gzsetparams (gzFile file, int level, int strategy);

DESCRIPTION

    The gzsetparams() function shall set the compression level and compression 
    strategy on the compressed file stream referenced by file. The 
    compressed file stream shall have been opened in a write mode. The level
    and strategy are as defined in deflateInit2_. If there is any data pending
    writing, it shall be flushed before the parameters are updated.

RETURN VALUE

    On success, the gzsetparams() function shall return Z_OK. 

ERRORS

    On error, gzsetparams() shall return one of the following error
    indications: 

    [Z_STREAM_ERROR] 

        Invalid parameter, or file not open for writing.

    [Z_BUF_ERROR] 

        An internal inconsistency was detected while flushing the previous
        buffer.
*/

specification
IntT gzsetparams_spec( CallContext context, VoidTPtr file, IntT level,
                      IntT strategy)
{
    pre
    {
        /*
         * The level supplied shall be a value between 0 and 9, or the value 
         * Z_DEFAULT_COMPRESSION.
         */
        REQ("gzsetparams.05", 
            "The level supplied shall be Z_DEFAULT_COMPRESSION or in [0, 9]",   
                                    level >=0 && level <=9
                                    || level == SUT_Z_DEFAULT_COMPRESSION);

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
    	
        /*
         * On success, the gzsetparams() function shall return Z_OK. 
         */
        ERROR_BEGIN(LSB_GZSETPARAMS, "gzsetparams.06",
            gzsetparams_spec!=SUT_Z_OK, gzsetparams_spec)
        /*
         * On error, gzsetparams() shall return one of the following error
         * indications: 
         * 
         * [Z_STREAM_ERROR]
         *
         * Invalid parameter, or file not open for writing.
         */
            ERROR_SHALL(LSB_GZSETPARAMS, Z_STREAM_ERROR, "gzsetparams.07.01",
                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, gzsetparams() shall return one of the following error
         * indications: 
         * 
         * [Z_BUF_ERROR]
         *
         * An internal inconsistency was detected while flushing the 
         * previous buffer.
         */
            ERROR_SHALL(LSB_GZSETPARAMS, Z_BUF_ERROR, "gzsetparams.07.02",
                TODO_ERR(Z_BUF_ERROR))

        ERROR_END()

        /*
         * The gzsetparams() function shall set the compression level
         * and compression strategy on the compressed file stream
         * referenced by file
         */
        REQ("gzsetparams.01", "", TODO_REQ());

        /*
         * The compressed file stream shall have been opened in a write mode
         */
        REQ("gzsetparams.02", "", TODO_REQ());

        /*
         * The level and strategy are as defined in deflateInit2_.
         */
        IMPLEMENT_REQ("gzsetparams.03");

        /*
         * If there is any data pending writing, it shall be flushed before
         * the parameters are updated.
         */
        REQ("gzsetparams.04", "", TODO_REQ());


        /*
         * A level of 1 requests the highest speed, while a level of 9
         * requests the highest compression.
         */
        REQ("gzsetparams.08", "", TODO_REQ());

        /*
         * A level of 0 indicates that no compression should be used,
         * and the output shall be the same as the input.
         */
        REQ("gzsetparams.07", "", TODO_REQ());

        /*
         * The strategy parameter selects the compression strategy to use: 
         * 
         * Z_DEFAULT_STRATEGY
         *
         *      use the system default compression strategy. 
         *      Z_DEFAULT_STRATEGY is particularly appropriate for text data.
         */
        REQ("gzsetparams.14.01", "", TODO_REQ());

        /*
         * The strategy parameter selects the compression strategy to use: 
         * 
         * Z_FILTERED
         *
         *      use a compression strategy tuned for data consisting largely of 
         *      small values with a fairly random distribution. Z_FILTERED uses
         *      more Huffman encoding and less string matching
         *      than Z_DEFAULT_STRATEGY.
         */
        REQ("gzsetparams.14.02", "", TODO_REQ());

        /*
         * The strategy parameter selects the compression strategy to use: 
         * 
         * Z_HUFFMAN_ONLY
         *
         *      force Huffman encoding only, with no string match.
         */
        REQ("gzsetparams.14.03", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gztell

NAME

    gztell -- find position on a compressed file stream

SYNOPSIS

    #include <zlib.h>

    z_off_t gztell (gzFile file );

DESCRIPTION

    The gztell() function shall return the starting position for the next read
    or write operation on compressed file stream file. This position represents
    the number of bytes from the beginning of file in the uncompressed data.

    gztell() is equivalent to 

        gzseek(file, 0L, SEEK_SET).

RETURN VALUE

    gztell() shall return the current offset in the file expressed as a byte 
    position in the uncompressed data stream. On error, gztell() shall return
    -1, and may set the error value for file accordingly.

ERRORS

    On error, gztell() shall return -1, indicating that file is NULL, or does 
    not represent an open compressed file stream.
*/

specification
OffT gztell_spec( CallContext context, VoidTPtr file, ErrorCode* errnum)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The gztell() function shall return the starting position
         * for the next read or write operation on compressed file
         * stream file.
         */
        REQ("gztell.01", "", TODO_REQ());

        /*
         * This position represents the number of bytes from the
         * beginning of file in the uncompressed data.
         */
        REQ("gztell.02", "", TODO_REQ());

        //WRONG: in fact gztell is equivalent to gzseek(file, 0L, SEEK_CUR)
        /*
         * gztell() is equivalent to 
         * 
         *      gzseek(file, 0L, SEEK_SET)
         */
        REQ("gztell.03.01", "", TODO_REQ());

        /*
         * gztell() shall return the current offset in the file
         * expressed as a byte position in the uncompressed data stream.
         */
        REQ("gztell.04", "", TODO_REQ());

        /*
         * On error, gztell() shall return -1, and may set the error
         * value for file accordingly.
         */
        /*
         * On error, gztell() shall return -1, indicating that file
         * is NULL, or does not represent an open compressed file stream.
         */
        REQ("gztell.05;gztell.06", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    gzwrite

NAME

    gzwrite -- write to a compressed file

SYNOPSIS

    #include <zlib.h>

    int gzwrite (gzFile file, voidpc buf, unsigned int len);

DESCRIPTION

    The gzwrite() function shall write data to the compressed file referenced
    by file, which shall have been opened in a write mode (see gzopen() and
    gzdopen()). On entry, buf shall point to a buffer containing lenbytes of
    uncompressed data. The gzwrite() function shall compress this data and
    write it to file. The gzwrite() function shall return the number of
    uncompressed bytes actually written.

RETURN VALUE

    On success, gzwrite() shall return the number of uncompressed bytes
    actually written to file. On error gzwrite() shall return a value less
    than or equal to 0. Applications may examine the cause using gzerror().

ERRORS

    On error, gzwrite() shall set the error number associated with the stream 
    identified by file to indicate the error. Applications should use 
    gzerror() to access this error value.

    [Z_ERRNO] 

        An underlying base library function has indicated an error. The global 
        variable errno may be examined for further information.

    [Z_STREAM_ERROR] 

        The stream is invalid, is not open for writing, or is in an invalid
        state.

    [Z_BUF_ERROR] 

        no compression progress is possible (see deflate()).

    [Z_MEM_ERROR] 

        Insufficient memory available to compress.
*/

specification
IntT gzwrite_spec( CallContext context, VoidTPtr file, VoidTPtr buf, UIntT len,
                 ErrorCode* errnum, ErrorCode* errno)
{
    pre
    {
        /*
         * Applications may examine the cause using gzerror().
         */
        /*
         * Applications should use gzerror() to access this error value.
         */
        IMPLEMENT_REQ("app.gzwrite.07;app.gzwrite.09");
        
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * On error gzwrite() shall return a value less than or equal to 0. 
         */
        ERROR_BEGIN(LSB_GZWRITE, "gzwrite.06", gzwrite_spec <= 0, *errnum)
        /*
         * On error, gzwrite() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_ERRNO]
         *
         * An underlying base library function has indicated an error. The 
         * global variable errno may be examined for further information.
         */
            ERROR_SHALL(LSB_GZWRITE, Z_ERRNO, "gzwrite.08.01",
                TODO_ERR(Z_ERRNO))

        /*
         * On error, gzwrite() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_STREAM_ERROR]
         *
         * The stream is invalid, is not open for writing, or is in an 
         * invalid state.
         */
            ERROR_SHALL(LSB_GZWRITE, Z_STREAM_ERROR, "gzwrite.08.02",
                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, gzwrite() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_BUF_ERROR]
         *
         * no compression progress is possible (see deflate()).
         */
            ERROR_SHALL(LSB_GZWRITE, Z_BUF_ERROR, "gzwrite.08.03",
                TODO_ERR(Z_BUF_ERROR))

        /*
         * On error, gzwrite() shall set the error number associated with the
         * stream identified by file to indicate the error.
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available to compress.
         */
            ERROR_SHALL(LSB_GZWRITE, Z_MEM_ERROR, "gzwrite.08.04",
                TODO_ERR(Z_MEM_ERROR))

        ERROR_END()

        /*
         * The gzwrite() function shall write data to the compressed file
         * referenced by file, which shall have been opened in a write mode
         * (see gzopen() and gzdopen()).
         */
        REQ("gzwrite.01", "", TODO_REQ());

        /*
         * On entry, buf shall point to a buffer containing len bytes of
         * uncompressed data.
         */
        REQ("gzwrite.02", 
            "Shall point to buffer containing len bytes of uncompressed data", 
            sizeRMemoryAvailable( buf ) >= len);

        /*
         * The gzwrite() function shall compress this data and write it
         * to file. 
         */
        REQ("gzwrite.03", "", TODO_REQ());

        /*
         * The gzwrite() function shall return the number of uncompressed
         * bytes actually written.
         */
        /*
         * On success, gzwrite() shall return the number of uncompressed
         * bytes actually written to file.
         */
        REQ("gzwrite.04;gzwrite.05", "", TODO_REQ());
        
        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflate

NAME

    inflate -- decompress data

SYNOPSIS

    #include <zlib.h>

    int inflate(z_streamp stream, int flush);

DESCRIPTION

    The inflate() function shall attempt to decompress data until either the
    input buffer is empty or the output buffer is full. The stream references a 
    z_stream structure. Before the first call to inflate(), this structure 
    should have been initialized by a call to inflateInit2_(). 

        Note: inflateInit2_() is only in the binary standard; source level 
        applications should initialize stream via a call to inflateInit() or 
        inflateInit2().

    In addition, the stream input and output buffers should have been
    initialized as follows: 

    next_in 

        should point to the data to be decompressed.

    avail_in 

        should contain the number of bytes of data in the buffer referenced by
        next_in. 

    next_out 

        should point to a buffer where decompressed data may be placed.

    avail_out 

        should contain the size in bytes of the buffer referenced by next_out

  
    The inflate() function shall perform one or both of the following actions: 

    Decompress input data from next_in and update next_in, avail_in and
    total_in to reflect the data that has been decompressed.

    Fill the output buffer referenced by next_out, and update next_out,
    avail_out, and total_out to reflect the decompressed data that has been
    placed there. If flush is not Z_NO_FLUSH, and avail_out indicates that
    there is still space in output buffer, this action shall always occur
    (see below for further details).

    The inflate() function shall return when either avail_in reaches zero
    ( indicating that all the input data has been compressed), or avail_out
    reaches zero (indicating that the output buffer is full).

    On success, the inflate() function shall set the adler field of the stream
    to the Adler-32 checksum of all the input data compressed so far
    (represented by total_in).


    Flush Operation

    The parameter flush determines when uncompressed bytes are added to the
    output buffer in next_out.
    
        If flush is Z_NO_FLUSH, inflate() may return with some data pending
        output, and not yet added to the output buffer.

        If flush is Z_SYNC_FLUSH, inflate() shall flush all pending output to 
        next_out, and update next_out and avail_out accordingly.

        If flush is set to Z_BLOCK, inflate() shall stop adding data to the
        output buffer if and when the next compressed block boundary is reached
        (see RFC 1951: DEFLATE Compressed Data Format Specification).

        If flush is set to Z_FINISH, all of the compressed input shall be
        decompressed and added to the output. If there is insufficient output
        space (i.e. the compressed input data uncompresses to more than
        avail_out bytes), then inflate() shall fail and return Z_BUF_ERROR.


RETURN VALUE

    On success, inflate() shall return Z_OK if decompression progress has been 
    made, or Z_STREAM_END if all of the input data has been decompressed and 
    there was sufficient space in the output buffer to store the uncompressed 
    result. On error, inflate() shall return a value to indicate the error. 

        Note: If inflate() returns Z_OK and has set avail_out to zero, the
        function should be called again with the same value for flush, and
        with updated next_out and avail_out until inflate() returns with
        either Z_OK or Z_STREAM_END and a non-zero avail_out.

    On success, inflate() shall set the adler to the Adler-32 checksum of the 
    output produced so far (i.e. total_out bytes).

ERRORS

    On error, inflate() shall return a value as described below, and may set
    the msg field of stream to point to a string describing the error: 

    [Z_BUF_ERROR] 

        No progress is possible; either avail_in or avail_out was zero.

    [Z_MEM_ERROR] 

        Insufficient memory.

    [Z_STREAM_ERROR] 

        The state (as represented in stream) is inconsistent, or stream was
        NULL.

    [Z_NEED_DICT] 

        A preset dictionary is required. The adler field shall be set to the
        Adler-32 checksum of the dictionary chosen by the compressor.
*/
#define inflate_has_error deflate_has_error

specification
IntT inflate_spec( CallContext context, ZStream* stream, IntT flush )
{
    CByteArray* adler_buf;
    bool inflate_zbuf_err=false;
    StringTPtr ptr;
  
    pre
    {
        /*
         * The stream references a z_stream structure. 
         */
        REQ("app.inflate.02", "", TODO_REQ());

        if(stream!=NULL)
            inflate_zbuf_err = stream->avail_in==0 || stream->avail_out==0;
        
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * On error, inflate() shall return a value to indicate the error. 
         */
        ERROR_BEGIN(LSB_INFLATE, "inflate.10",
            inflate_has_error(stream, flush, inflate_spec), inflate_spec)
        /*
         * On error, inflate() shall return a value as described below,
         * and may set the msg field of stream to point to a string
         * describing the error: 
         * 
         * [Z_BUF_ERROR]
         *
         * No progress is possible; either avail_in or avail_out was zero.
         */
        /*
         * If there is insufficient output space (i.e. the compressed
         * input data uncompresses to more than avail_out bytes),
         * then inflate() shall fail and return Z_BUF_ERROR.
         */
            ERROR_SHALL3(LSB_INFLATE, Z_BUF_ERROR,
                "inflate.12.01;inflate.08.04.02",
                inflate_zbuf_err ? True_Bool3 : 
                    flush == SUT_Z_FINISH ? Unknown_Bool3 : False_Bool3)

        /*
         * On error, inflate() shall return a value as described below,
         * and may set the msg field of stream to point to a string
         * describing the error: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory.
         */
            ERROR_SHALL(LSB_INFLATE, Z_MEM_ERROR, "inflate.12.02",
                TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, inflate() shall return a value as described below,
         * and may set the msg field of stream to point to a string
         * describing the error: 
         * 
         * [Z_STREAM_ERROR]
         *
         * The state (as represented in stream) is inconsistent, or 
         * stream was NULL.
         */
            ERROR_SHALL3(LSB_INFLATE, Z_STREAM_ERROR, "inflate.12.03",
                stream == NULL ? True_Bool3 : Unknown_Bool3)

        /*
         * On error, inflate() shall return a value as described below,
         * and may set the msg field of stream to point to a string
         * describing the error: 
         * 
         * [Z_NEED_DICT]
         *
         * A preset dictionary is required. The adler field shall be set to 
         * the Adler-32 checksum of the dictionary chosen by the compressor.
         */
            ERROR_SHALL(LSB_INFLATE, Z_NEED_DICT, "inflate.12.04",
                TODO_ERR(Z_NEED_DICT))

        ERROR_END()

        /*
         * The inflate() function shall attempt to decompress data until
         * either the input buffer is empty or the output buffer is full.
         */
        /*
         * The inflate() function shall return when either avail_in
         * reaches zero (indicating that all the input data has
         * been compressed), or avail_out reaches zero (indicating that
         * the output buffer is full).
         */
        REQ("inflate.01;inflate.06", 
            "Shall return when either avail_in ot avail_out reaches zero",        
                                            stream->avail_in  ==0
                                            ||  stream->avail_out ==0);

        /*
         * Before the first call to inflate(), this structure should have been 
         * initialized by a call to inflateInit2_(). 
         */
        IMPLEMENT_REQ("inflate.03");

        /*
         * In addition, the stream input and output buffers should have
         * been initialized as follows: 
         * 
         * next_in should point to the data to be decompressed.
         */
        /*
         * In addition, the stream input and output buffers should have
         * been initialized as follows: 
         * 
         * avail_in should contain the number of bytes of data in
         * the buffer referenced by next_in.
         */
        REQ("inflate.04.01;inflate.04.02", 
            "Stream input and output buffers should have been initialized", 
            sizeRMemoryAvailable( stream->next_in ) >= stream->avail_in);

        /*
         * In addition, the stream input and output buffers should have
         * been initialized as follows: 
         * 
         * next_out should point to a buffer where decompressed data
         * may be placed.
         */
        /*
         * In addition, the stream input and output buffers should have
         * been initialized as follows: 
         * 
         * avail_out should contain the size in bytes of
         * the buffer referenced by next_out
         */
        REQ("inflate.04.03;inflate.04.04", 
            "Stream input and output buffers should have been initialized", 
            sizeWMemoryAvailable( stream->next_out ) >= stream->avail_out);

        /*
         * The inflate() function shall perform one or both of the following
         * actions: 
         * 
         * Decompress input data from next_in and update next_in,
         * avail_in and total_in to reflect the data that
         * has been decompressed.
         */
        REQ("inflate.05.01", "", TODO_REQ());

        /*
         * The inflate() function shall perform one or both of the following
         * actions: 
         * 
         * Fill the output buffer referenced by next_out, and update next_out,
         * avail_out, and total_out to reflect the decompressed data that
         * has been placed there. If flush is not Z_NO_FLUSH, and avail_out
         * indicates that there is still space in output buffer, this action
         * shall always occur (see below for further details).
         */
        REQ("inflate.05.02", "", TODO_REQ());

        /*
         * On success, the inflate() function shall set the adler field of
         * the stream to the Adler-32 checksum of all the input data
         * compressed so far (represented by total_in).
         */
        //This requirement is wrong: contradiction with inflate.11
        //REQ("inflate.07", "",   adler32_model(1, adler_buf, stream->total_in)
        //                       == stream->adler);

        if(flush == SUT_Z_NO_FLUSH)
        {
            /*
             * The parameter flush determines when uncompressed bytes are added
             * to the output buffer in next_out. 
             * 
             * If flush is Z_NO_FLUSH, inflate() may return with some data
             * pending output, and not yet added to the output buffer.
             */
            REQ("inflate.08.01", "", TODO_REQ());
        }
        else if(flush == SUT_Z_SYNC_FLUSH)
        {
            /*
             * The parameter flush determines when uncompressed bytes are added
             * to the output buffer in next_out. 
             * 
             * If flush is Z_SYNC_FLUSH, inflate() shall flush all pending
             * output to next_out, and update next_out and avail_out
             * accordingly.
             */
            REQ("inflate.08.02", "", TODO_REQ());
        }
        else if(flush == SUT_Z_FINISH/*...BLOCK*/)
        {
            /*
             * The parameter flush determines when uncompressed bytes are added
             * to the output buffer in next_out. 
             * 
             * If flush is set to Z_BLOCK, inflate() shall stop adding data
             * to the output buffer if and when the next compressed block
             * boundary is reached (see RFC 1951: DEFLATE Compressed Data
             * Format Specification).
             */
            REQ("inflate.08.03", "", TODO_REQ());
        }
        else if(flush == SUT_Z_FINISH)
        {
            /*
             * If flush is set to Z_FINISH, all of the compressed input
             * shall be decompressed and added to the output.
             */
            REQ("inflate.08.04.01", "", TODO_REQ());
        }

        /*
         * On success, inflate() shall return
         * 
         * Z_OK
         *
         * if decompression progress has been made
         */
        REQ("inflate.09.01", "", TODO_REQ());

        /*
         * On success, inflate() shall return
         * 
         * Z_STREAM_END
         *
         * if all of the input data has been decompressed and there was 
         * sufficient space in the output buffer to store the uncompressed
         * result.
         */
        REQ("inflate.09.02", "", TODO_REQ());

        /*
         * On success, inflate() shall set the adler to the Adler-32 checksum
         * of the output produced so far (i.e. total_out bytes).
         */
        
        ptr = stream->next_out;
        ptr.address -= stream->total_out;
        adler_buf = readCByteArray_VoidTPtr(ptr, stream->avail_out);

        REQ("inflate.11", 
            "Shall set the adler", 
                                adler32_model(1, adler_buf, stream->total_out)
                                == stream->adler);


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateEnd

NAME

    inflateEnd -- free decompression stream state

SYNOPSIS

    #include <zlib.h>

    int inflateEnd(z_streamp stream);

DESCRIPTION

    The inflateEnd() function shall free all allocated state information 
    referenced by stream. All pending output is discarded, and unprocessed
    input is ignored.

RETURN VALUE

    On success, inflateEnd() shall return Z_OK. Otherwise it shall return 
    Z_STREAM_ERROR to indicate the error.

ERRORS

    On error, inflateEnd() shall return Z_STREAM_ERROR.
    The following conditions shall be treated as an error: 

        The state in stream is inconsistent.

        stream is NULL.

        The zfree function pointer is NULL.
*/

specification
IntT inflateEnd_spec( CallContext context, ZStream* stream )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise it shall return Z_STREAM_ERROR to indicate the error.
         */
        ERROR_BEGIN(LSB_INFLATEEND, "inflateEnd.03", inflateEnd_spec!=SUT_Z_OK,
                                                        inflateEnd_spec)
        /*
         * The following conditions shall be treated as an error: 
         *
         *      The state in stream is inconsistent or inappropriate.
         *
         *      stream is NULL.    
         *
         *      The zfree function pointer is NULL.
         */
            ERROR_SHALL3(LSB_INFLATEEND, Z_STREAM_ERROR,
                "inflateEnd.04.01.01;inflateEnd.04.01.02;inflateEnd.04.01.03",
                stream==NULL ? True_Bool3 : 
                    stream->zfree.address == 0 ? True_Bool3 : Unknown_Bool3)

        ERROR_END()

        /*
         * On success, inflateEnd() shall return Z_OK.
         */
        REQ("inflateEnd.02", 
            "On success, shall return Z_OK", 
            inflateEnd_spec==SUT_Z_OK);

        /*
         * The inflateEnd() function shall free all allocated state
         * information referenced by stream.
         * All pending output is discarded, and unprocessed input
         * is ignored.
         */
        REQ("inflateEnd.01", 
            "Shall free all allocated state information referenced by stream", 
            stream->int_state.address == 0);

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateInit2_

NAME

    inflateInit2_ -- initialize decompression system

SYNOPSIS

    #include <zlib.h>

    int inflateInit2_ (z_streamp strm, int windowBits, char * version, int 
        stream_size);

DESCRIPTION

    The inflateInit2_() function shall initialize the decompression system. On 
    entry, strm shall refer to a user supplied z_stream object (a z_stream_s 
    structure). The following fields shall be set on entry: 

    zalloc 

        a pointer to an alloc_func function, used to allocate state
        information. If this is NULL, a default allocation function will be
        used.

    zfree 

        a pointer to a free_func function, used to free memory allocated by the
        zalloc function. If this is NULL a default free function will be used.

    opaque 

        If alloc_func is not NULL, opaque is a user supplied pointer to data
        that will be passed to the alloc_func and free_func functions.

    If the version requested is not compatible with the version implemented, or
    if the size of the z_stream_s structure provided in stream_size does not
    match the size in the library implementation, inflateInit2_() shall fail,
    and return Z_VERSION_ERROR.

    The windowBits parameter shall be a base 2 logarithm of the maximum window 
    size to use, and shall be a value between 8 and 15. If the input data was 
    compressed with a larger window size, subsequent attempts to decompress
    this data will fail with Z_DATA_ERROR, rather than try to allocate a larger
    window.

    The inflateInit2_() function is not in the source standard; it is only in
    the binary standard. Source applications should use the inflateInit2()
    macro.

RETURN VALUE

    On success, the inflateInit2_() function shall return Z_OK. 
    Otherwise, inflateInit2_() shall return a value as described below to
    indicate the error.

ERRORS

    On error, inflateInit2_() shall return one of the following error
    indicators: 

    [Z_STREAM_ERROR] 

        Invalid parameter.

    [Z_MEM_ERROR] 

        Insufficient memory available.

    [Z_VERSION_ERROR] 

        The version requested is not compatible with the library version, or
        the z_stream size differs from that used by the library.

    In addition, the msg field of the strm may be set to an error message.
*/
specification
IntT inflateInit2__spec(    CallContext context, ZStream* strm,
                            IntT windowBits,
                            CString* version, IntT stream_size )
{
    pre
    {
        /*
         * On entry, strm shall refer to a user supplied z_stream object
         * (a z_stream_s structure). 
         */
        REQ("app.inflateInit2_.02", "", TODO_REQ());
        /*
         * The windowBits parameter shall be a base 2 logarithm
         * of the maximum window size to use, and shall be a value
         * between 8 and 15. 
         */
        REQ("inflateInit2_.05", 
            "The windowBits shall be log[2](maximum window size) in [8, 15]", 
            windowBits>=8 && windowBits<=15);

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, inflateInit2_() shall return a value as described below
         * to indicate the error.
         */
        ERROR_BEGIN(LSB_INFLATEINIT2_, "inflateInit2_.09",
                inflateInit2__spec!=SUT_Z_OK, inflateInit2__spec)
        /*
         * On error, inflateInit2_() shall return one of the following error
         * indicators: 
         * 
         * [Z_STREAM_ERROR]
         *
         * Invalid parameter.
         */
            ERROR_SHALL(LSB_INFLATEINIT2_, Z_STREAM_ERROR,
                "inflateInit2_.10.01", TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, inflateInit2_() shall return one of the following error
         * indicators: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available.
         */
            ERROR_SHALL(LSB_INFLATEINIT_, Z_MEM_ERROR,
                "inflateInit2_.10.02", TODO_ERR(Z_MEM_ERROR))

        /*
         * If the version requested is not compatible with the version
         * implemented, or if the size of the z_stream_s structure provided in
         * stream_size does not match the size in the library implementation,
         * inflateInit2_() shall fail, and return Z_VERSION_ERROR.
         */
        /*
         * On error, inflateInit2_() shall return one of the following error
         * indicators: 
         * 
         * [Z_VERSION_ERROR]
         *
         * The version requested is not compatible with the library 
         * version, or the z_stream size differs from that used by the library.
         */
            ERROR_SHALL(LSB_INFLATEINIT2_, Z_VERSION_ERROR,
                "inflateInit2_.04;inflateInit2_.10.03", 
                charAt_CString(version, 0) != SUT_ZLIB_VERSION[0])
//                ||
//                stream_size !=  SUT_ZSTREAM_SIZE)

        ERROR_END()
        
        /*
         * On success, the inflateInit2_() function shall return Z_OK. 
         */
        REQ("inflateInit2_.08", 
            "On success, shall return Z_OK", 
            inflateInit2__spec==SUT_Z_OK);

        /*
         * The inflateInit2_() function shall initialize the decompression
         * system. 
         */
        REQ("inflateInit2_.01", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * zalloc
         *
         * a pointer to an alloc_func function, used to allocate state
         * information. 
         * If this is NULL, a default allocation function will be used.
         */
        REQ("inflateInit2_.03.01", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * zfree
         *
         * a pointer to a free_func function, used to free memory allocated by
         * the zalloc function. If this is NULL a default free function will
         * be used.
         */
        REQ("inflateInit2_.03.02", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * opaque
         *
         * If alloc_func is not NULL, opaque is a user supplied pointer to data 
         * that will be passed to the alloc_func and free_func functions.
         */
        REQ("inflateInit2_.03.03", "", TODO_REQ());

        /*
         * If the input data was compressed with a larger window size,
         * subsequent attempts to decompress this data will fail with
         * Z_DATA_ERROR, rather than try to allocate a larger window.
         */
        REQ("inflateInit2_.06", "", TODO_REQ());

        /*
         * The inflateInit2_() function is not in the source standard;
         * it is only in the binary standard. Source applications should
         * use the inflateInit2() macro.
         */
        REQ("inflateInit2_.07", "", TODO_REQ());

        /*
         * In addition, the msg field of the strm may be set to an error
         * message.
         */
        REQ("inflateInit2_.11", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateInit_

NAME

    inflateInit_ -- initialize decompression system

SYNOPSIS

    #include <zlib.h>

    int inflateInit_(z_streamp stream, const char * version, int stream_size);

DESCRIPTION

    The inflateInit_() function shall initialize the decompression system. On 
    entry, stream shall refer to a user supplied z_stream object (a z_stream_s 
    structure). The following fields shall be set on entry: 

    zalloc 

        a pointer to an alloc_func function, used to allocate state
        information. If this is NULL, a default allocation function will
        be used.

    zfree 

        a pointer to a free_func function, used to free memory allocated by the
        zalloc function. If this is NULL a default free function will be used.

    opaque 

        If alloc_func is not NULL, opaque is a user supplied pointer to data
        that will be passed to the alloc_func and free_func functions.

    If the version requested is not compatible with the version implemented, or
    if the size of the z_stream_s structure provided in stream_size does not
    match the size in the library implementation, inflateInit_() shall fail,
    and return Z_VERSION_ERROR.

    The inflateInit_() function is not in the source standard; it is only in
    the binary standard. Source applications should use the inflateInit()
    macro.

    The inflateInit_() shall be equivalent to 

        inflateInit2_(strm, DEF_WBITS, version, stream_size); 

RETURN VALUE

    On success, the inflateInit_() function shall return Z_OK. Otherwise, 
    inflateInit_() shall return a value as described below to indicate the
    error.

ERRORS

    On error, inflateInit_() shall return one of the following error
    indicators: 

    [Z_STREAM_ERROR] 

        Invalid parameter.

    [Z_MEM_ERROR] 

        Insufficient memory available.

    [Z_VERSION_ERROR] 

        The version requested is not compatible with the library version, or
        the z_stream size differs from that used by the library.

    In addition, the msg field of the strm may be set to an error message.
*/
specification
IntT inflateInit__spec(     CallContext context, ZStream* strm,
                            CString* version, IntT stream_size )
{
    pre
    {
        /*
         * On entry, stream shall refer to a user supplied z_stream object
         * (a z_stream_s structure).
         */
        REQ("app.inflateInit_.02", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, inflateInit_() shall return a value as described below
         * to indicate the error.
         */
        ERROR_BEGIN(LSB_INFLATEINIT_, "inflateInit_.08",
                inflateInit__spec!=SUT_Z_OK, inflateInit__spec)
        /*
         * On error, inflateInit_() shall return one of the following error
         * indicators: 
         * 
         * [Z_STREAM_ERROR]
         *
         * Invalid parameter.
         */
            ERROR_SHALL(LSB_INFLATEINIT_, Z_STREAM_ERROR, "inflateInit_.09.01",
                TODO_ERR(Z_STREAM_ERROR))

        /*
         * On error, inflateInit_() shall return one of the following error
         * indicators: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory available.
         */
            ERROR_SHALL(LSB_INFLATEINIT_, Z_MEM_ERROR, "inflateInit_.09.02",
            TODO_ERR(Z_MEM_ERROR))
        /*
         * If the version requested is not compatible with the version
         * implemented, or if the size of the z_stream_s structure provided in
         * stream_size does not match the size in the library implementation,
         * inflateInit_() shall fail, and return Z_VERSION_ERROR.
         */
        /*
         * On error, inflateInit_() shall return one of the following error
         * indicators: 
         * 
         * [Z_VERSION_ERROR]
         *
         * The version requested is not compatible with the library 
         * version, or the z_stream size differs from that used by the library.
         */
            ERROR_SHALL(LSB_INFLATEINIT_, Z_VERSION_ERROR,
                "inflateInit_.04;inflateInit_.09.03", 
                charAt_CString(version, 0) != SUT_ZLIB_VERSION[0])
 //               ||
 //               stream_size !=  SUT_ZSTREAM_SIZE)

        ERROR_END()

        /*
         * On success, the inflateInit_() function shall return Z_OK.
         */
        REQ("inflateInit_.07", 
            "On success, shall return Z_OK", 
            inflateInit__spec==SUT_Z_OK);

        /*
         * The inflateInit_() function shall initialize the decompression
         * system.
         */
        REQ("inflateInit_.01", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * zalloc
         *
         * a pointer to an alloc_func function, used to allocate state
         * information. 
         * If this is NULL, a default allocation function will be used.
         */
        REQ("inflateInit_.03.01", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * zfree
         *
         * a pointer to a free_func function, used to free memory allocated by
         * the zalloc function. If this is NULL a default free function will
         * be used.
         */
        REQ("inflateInit_.03.02", "", TODO_REQ());

        /*
         * The following fields shall be set on entry: 
         * 
         * opaque
         *
         * If alloc_func is not NULL, opaque is a user supplied pointer
         * to data 
         * that will be passed to the alloc_func and free_func functions.
         */
        REQ("inflateInit_.03.03", "", TODO_REQ());

        /*
         * The inflateInit_() function is not in the source standard;
         * it is only in the binary standard.
         * Source applications should use the inflateInit() macro.
         */
        REQ("inflateInit_.05", "", TODO_REQ());

        /*
         * The inflateInit_() shall be equivalent to 
         * 
         * inflateInit2_(strm, DEF_WBITS, version, stream_size);
         */
        IMPLEMENT_REQ("inflateInit_.06.01");

        /*
         * In addition, the msg field of the strm may be set to
         * an error message.
         */
        REQ("inflateInit_.10", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateReset

NAME

    inflateReset -- reset decompression stream state

SYNOPSIS

    #include <zlib.h>

    int inflateReset(z_streamp stream);

DESCRIPTION

    The inflateReset() function shall reset all state associated with stream.
    All pending output shall be discarded, and the counts of processed bytes
    (total_in and total_out) shall be reset to zero.

RETURN VALUE

    On success, inflateReset() shall return Z_OK. Otherwise it shall return 
    Z_STREAM_ERROR to indicate the error.

ERRORS

On error, inflateReset() shall return Z_STREAM_ERROR.
The following conditions shall be treated as an error: 

    The state in stream is inconsistent or inappropriate.

    stream is NULL.
*/
specification
IntT inflateReset_spec( CallContext context, ZStream* stream )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise it shall return Z_STREAM_ERROR to indicate the error.
         */
        ERROR_BEGIN(LSB_INFLATERESET, "inflateReset.04",
                            inflateReset_spec!=SUT_Z_OK, inflateReset_spec)
        /*
         * The following conditions shall be treated as an error: 
         *
         *      The state in stream is inconsistent or inappropriate.
         *
         *      stream is NULL.    
         */
            ERROR_SHALL3(LSB_INFLATERESET, Z_STREAM_ERROR,
                "inflateReset.05.01.01;inflateReset.05.01.02",
                stream==NULL ? True_Bool3 : Unknown_Bool3)

        ERROR_END()

        /*
         * On success, inflateReset() shall return Z_OK.
         */
        REQ("inflateReset.03", 
            "On success, shall return Z_OK", 
            inflateReset_spec==SUT_Z_OK);

        /*
         * The inflateReset() function shall reset
         * all state associated with stream.
         */
        /*
         * All pending output shall be discarded, and the counts
         * of processed bytes (total_in and total_out) shall be reset to zero.
         */
        REQ("inflateReset.01;inflateReset.02", 
            "Shall reset all state associated with stream",
                stream->total_in==0
            &&  stream->total_out==0);

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateSetDictionary

NAME

    inflateSetDictionary -- initialize decompression dictionary

SYNOPSIS

    #include <zlib.h>

    int inflateSetDictionary(z_streamp stream, const Bytef * dictionary, uInt 
        dictlen);

DESCRIPTION

    The inflateSetDictionary() function shall initialize the decompression 
    dictionary associated with stream using the dictlen bytes referenced by 
    dictionary.

    The inflateSetDictionary() function should be called immediately after a
    call to inflate() has failed with return value Z_NEED_DICT. The dictionary
    must have the same Adler-32 checksum as the dictionary used for the
    compression (see deflateSetDictionary()).

    stream shall reference an initialized decompression stream, with total_in
    zero (i.e. no data has been decompressed since the stream was initialized).

RETURN VALUE

    On success, inflateSetDictionary() shall return Z_OK. Otherwise it shall 
    return a value as indicated below.

ERRORS

    On error, inflateSetDictionary() shall return a value as described below: 

    [Z_STREAM_ERROR] 

        The state in stream is inconsistent, or stream was NULL.

    [Z_DATA_ERROR] 

        The Adler-32 checksum of the supplied dictionary does not match that
        used for the compression.
*/
specification
IntT inflateSetDictionary_spec( CallContext context, ZStream* stream,
                               StringTPtr dictionary, UIntT dictlen)
{
    pre
    {
        /*
         * The inflateSetDictionary() function should be called immediately
         * after a call to inflate() has failed with return value Z_NEED_DICT.
         */
        //Implemented in scenario
        IMPLEMENT_REQ("app.inflateSetDictionary.02");

        if(stream!=NULL)
        {
            /*
             * stream shall reference an initialized decompression stream,
             * with total_in zero (i.e. no data has been decompressed since
             * the stream was initialized).
             */
            REQ("inflateSetDictionary.04", 
                "Stream shall reference an initialized decompression stream, "
                "with total_in zero", 
                stream->total_in == 0);
        }

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        CByteArray* adler_buf;
        /*
         * Otherwise it shall return a value as indicated below.
         */
        ERROR_BEGIN(LSB_INFLATESETDICTIONARY, "inflateSetDictionary.06",
            inflateSetDictionary_spec!=SUT_Z_OK, inflateSetDictionary_spec)
        /*
         * On error, inflateSetDictionary() shall return a value as
         * described below: 
         * 
         * [Z_STREAM_ERROR]
         *
         * The state in stream is inconsistent, or stream was NULL.
         */
            ERROR_SHALL3(LSB_INFLATESETDICTIONARY, Z_STREAM_ERROR,
                "inflateSetDictionary.07.01", 
                stream == NULL ? True_Bool3 : Unknown_Bool3)

        /*
         * On error, inflateSetDictionary() shall return a value
         * as described below: 
         * 
         * [Z_DATA_ERROR]
         *
         * The Adler-32 checksum of the supplied dictionary does not match 
         * that used for the compression.
         */
            ERROR_SHALL(LSB_INFLATESETDICTIONARY, Z_DATA_ERROR,
                "inflateSetDictionary.07.02", TODO_ERR(Z_DATA_ERROR))

        ERROR_END()

        /*
         * On success, inflateSetDictionary() shall return Z_OK. 
         */
        REQ("inflateSetDictionary.05", 
            "On success, shall return Z_OK",
            inflateSetDictionary_spec==SUT_Z_OK);

        /*
         * The inflateSetDictionary() function shall initialize the
         * decompression dictionary associated with stream using the
         * dictlen bytes referenced by dictionary.
         */
        REQ("inflateSetDictionary.01", "", TODO_REQ());

        adler_buf=readCByteArray_VoidTPtr(dictionary, dictlen);
        /*
         * The dictionary must have the same Adler-32 checksum as the
         * dictionary used for the compression (see deflateSetDictionary()).
         */
        REQ("inflateSetDictionary.03", 
            "The dictionary must have the same Adler-32 checksum as "
            "the dictionary used for the compression", 
            stream->adler == adler32_model(1, adler_buf, dictlen));

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateSync

NAME

    inflateSync -- advance compression stream to next sync point

SYNOPSYS

    #include <zlib.h>

    int inflateSync(z_streamp stream);

DESCRIPTION

    The inflateSync() function shall advance through the compressed data in
    stream, skipping any invalid compressed data, until the next full flush
    point is reached, or all input is exhausted. See the description for
    deflate() with flush level Z_FULL_FLUSH. No output is placed in next_out.

RETURN VALUE

    On success, inflateSync() shall return Z_OK, and update the next_in,, 
    avail_in, and, total_in fields of stream to reflect the number of bytes of 
    compressed data that have been skipped. Otherwise, inflateSync() shall
    return a value as described below to indicate the error.

ERRORS

    On error, inflateSync() shall return a value as described below: 

    [Z_STREAM_ERROR] 

        The state (as represented in stream) is inconsistent, or stream was NULL.

    [Z_BUF_ERROR] 

        There is no data available to skip over.

    [Z_DATA_ERROR] 

        No sync point was found.
*/

specification
IntT inflateSync_spec( CallContext context, ZStream* stream )
{
    CByteArray* next_out_pre =  stream == NULL ? 
        NULL :
        readCByteArray_VoidTPtr(stream->next_out,
                sizeRMemoryAvailable(stream->next_out));
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, inflateSync() shall return a value as described below
         * to indicate the error.
         */
        ERROR_BEGIN(LSB_INFLATESYNC, "inflateSync.04",
            inflateSync_spec!=SUT_Z_OK, inflateSync_spec)
        /*
         * On error, inflateSync() shall return a value as described below: 
         * 
         * [Z_STREAM_ERROR]
         *
         * The state (as represented in stream) is inconsistent, or 
         * stream was NULL.
         */
            ERROR_SHALL3(LSB_INFLATESYNC, Z_STREAM_ERROR,
                "inflateSync.05.01", 
                stream == NULL ? True_Bool3 : Unknown_Bool3)

        /*
         * On error, inflateSync() shall return a value as described below: 
         * 
         * [Z_BUF_ERROR]
         *
         * There is no data available to skip over.
         */
            ERROR_SHALL(LSB_INFLATESYNC, Z_BUF_ERROR,
                "inflateSync.05.02", TODO_ERR(Z_BUF_ERROR))

        /*
         * On error, inflateSync() shall return a value as described below: 
         * 
         * [Z_DATA_ERROR]
         *
         * No sync point was found.
         */
            ERROR_SHALL(LSB_INFLATESYNC, Z_DATA_ERROR,
                "inflateSync.05.03", TODO_ERR(Z_DATA_ERROR))

        ERROR_END()

        /*
         * The inflateSync() function shall advance through the compressed data
         * in stream, skipping any invalid compressed data, until the next full
         * flush point is reached, or all input is exhausted.
         */
        REQ("inflateSync.01", "", TODO_REQ());

        /*
         * No output is placed in next_out.
         */
        REQ("inflateSync.02", "next_out remains untouched",
                equals(
                    readCByteArray_VoidTPtr(stream->next_out,
                        sizeRMemoryAvailable(stream->next_out)),
                    next_out_pre));

        /*
         * On success, inflateSync() shall return Z_OK, and update the next_in, 
         * avail_in, and total_in fields of stream to reflect the number of
         * bytes of compressed data that have been skipped.
         */
        REQ("inflateSync.03", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    inflateSyncPoint

NAME

    inflateSyncPoint -- test for synchronization point

SYNOPSIS

    #include <zlib.h>

    int inflateSyncPoint(z_streamp stream);

DESCRIPTION

    The inflateSyncPoint() function shall return a non-zero value if the 
    compressed data stream referenced by stream is at a synchronization point. 

RETURN VALUE

    If the compressed data in stream is at a synchronization point (see
    deflate() with a flush level of Z_SYNC_FLUSH or Z_FULL_FLUSH),
    inflateSyncPoint() shall return a non-zero value, other than
    Z_STREAM_ERROR. Otherwise, if the stream is valid, inflateSyncPoint() shall
    return 0. If stream is invalid, or in an invalid state, inflateSyncPoint()
    shall return Z_STREAM_ERROR to indicate the error.

ERRORS

    On error, inflateSyncPoint() shall return a value as described below: 

    [Z_STREAM_ERROR] 

        The state (as represented in stream) is inconsistent,
        or stream was NULL.
*/
specification
IntT inflateSyncPoint_spec( CallContext context, ZStream* stream )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * If stream is invalid, or in an invalid state, inflateSyncPoint()
         * shall return Z_STREAM_ERROR to indicate the error.
         */
        ERROR_BEGIN(LSB_INFLATESYNCPOINT, "inflateSyncPoint.04",
            inflateSyncPoint_spec==SUT_Z_STREAM_ERROR, 
                inflateSyncPoint_spec)
        /*
         * On error, inflateSyncPoint() shall return a value as described below: 
         * 
         * [Z_STREAM_ERROR]
         *
         * The state (as represented in stream) is inconsistent, or 
         * stream was NULL.
         */
            ERROR_SHALL3(LSB_INFLATESYNCPOINT, Z_STREAM_ERROR,
            "inflateSyncPoint.05.01",
            stream == NULL ? True_Bool3 : Unknown_Bool3)

        ERROR_END()

        if(inSyncPoint())
        {        
            /*
             * The inflateSyncPoint() function shall return a non-zero value if
             * the compressed data stream referenced by stream is at a
             * synchronization point. 
             */
            /*
             * If the compressed data in stream is at a synchronization point
             * (see deflate() with a flush level of Z_SYNC_FLUSH
             * or Z_FULL_FLUSH), inflateSyncPoint() shall return a non-zero
             * value, other than Z_STREAM_ERROR.
             */
            REQ("inflateSyncPoint.01;inflateSyncPoint.02", "", TODO_REQ());
        }
        else
        {
            /*
             * Otherwise, if the stream is valid, inflateSyncPoint() shall
             * return 0.
             */
            REQ("inflateSyncPoint.03", "", TODO_REQ());
        }

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    uncompress

NAME

    uncompress -- uncompress data

SYNOPSIS

    #include <zlib.h>

    int uncompress(Bytef * dest, uLongf * destLen, const Bytef * source, uLong 
        sourceLen);

DESCRIPTION

    The uncompress() function shall attempt to uncompress sourceLen bytes of
    data in the buffer source, placing the result in the buffer dest. 

    On entry, destLen should point to a value describing the size of the dest 
    buffer. The application should ensure that this value is large enough to 
    hold the entire uncompressed data. 

    Note: The LSB does not describe any mechanism by which a compressor can 
    communicate the size required to the uncompressor. 

    On successful exit, the variable referenced by destLen shall be updated to 
    hold the length of uncompressed data in dest. 

RETURN VALUE

    On success, uncompress() shall return Z_OK. Otherwise, uncompress() shall 
    return a value to indicate the error.

ERRORS

    On error, uncompress() shall return a value as described below: 

    [Z_BUF_ERROR] 

        The buffer dest was not large enough to hold the uncompressed data.

    [Z_MEM_ERROR] 

        Insufficient memory.

    [Z_DATA_ERROR] 

        The compressed data (referenced by source) was corrupted.
*/

specification
IntT uncompress_spec( CallContext context, StringTPtr* dest, ULongT* destLen,
                   StringTPtr source, ULongT sourceLen)
{
    pre
    {
        if(destLen!=NULL && !isNULL_VoidTPtr(*dest))
        {        
            /*
             * On entry, destLen should point to a value
             * describing the size of the dest buffer
             */
            REQ("uncompress.02", 
                "On entry, destLen should point to a value describing "
                "the size of the dest buffer",
                sizeWMemoryAvailable( *dest ) >= *destLen);
        }
        else
            return false;

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, uncompress() shall return a value to indicate the error.
         */
        ERROR_BEGIN(LSB_UNCOMPRESS, "uncompress.06",
                    uncompress_spec!=SUT_Z_OK, uncompress_spec)
        /*
         * On error, uncompress() shall return a value as described below: 
         * 
         * [Z_BUF_ERROR]
         *
         * The buffer dest was not large enough to hold the uncompressed 
         * data.
         */
            ERROR_SHALL(LSB_UNCOMPRESS, Z_BUF_ERROR, "uncompress.07.01",
                        TODO_ERR(Z_BUF_ERROR))

        /*
         * On error, uncompress() shall return a value as described below: 
         * 
         * [Z_MEM_ERROR]
         *
         * Insufficient memory.
         */
            ERROR_SHALL(LSB_UNCOMPRESS, Z_MEM_ERROR, "uncompress.07.02",
                    TODO_ERR(Z_MEM_ERROR))

        /*
         * On error, uncompress() shall return a value as described below: 
         * 
         * [Z_DATA_ERROR]
         *
         * The compressed data (referenced by source) was corrupted.
         */
            ERROR_SHALL(LSB_UNCOMPRESS, Z_DATA_ERROR, "uncompress.07.03",
                    TODO_ERR(Z_DATA_ERROR))

        ERROR_END()

        /*
         * The uncompress() function shall attempt to uncompress
         * sourceLen bytes of data in the buffer source, placing
         * the result in the buffer dest. 
         */
        REQ("uncompress.01", "", TODO_REQ());

        /*
         * The application should ensure that this value is large
         * enough to hold the entire uncompressed data. 
         */
        REQ("uncompress.03", "", TODO_REQ());

        if(destLen!=NULL && !isNULL_VoidTPtr(*dest))
        {        
            /*
             * On successful exit, the variable referenced by destLen
             * shall be updated to hold the length of uncompressed data in dest
             */
            REQ("uncompress.04", 
                "On successful, the variable referenced by destLen shall be "
                "updated to hold the length of uncompressed data in dest", 
                sizeRMemoryAvailable( *dest ) >= *destLen);
        }


        /*
         * On success, uncompress() shall return Z_OK.
         */
        REQ("uncompress.05", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    zError

NAME

    zError -- translate error number to string

SYNOPSIS

    #include <zlib.h>

    const char * zError(int err);

DESCRIPTION

    The zError() function shall return the string identifying the error
    associated with err. This allows for conversion from error code to string
    for functions such as compress() and uncompress(), that do not always set
    the string version of an error.

RETURN VALUE

    The zError() function shall return a the string identifying the error 
    associated with err, or NULL if err is not a valid error code.

    It is unspecified if the string returned is determined by the setting of the 
    LC_MESSAGES category in the current locale.

ERRORS

    None defined.
*/
specification
CString* zError_spec( CallContext context, IntT err)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The zError() function shall return the string identifying
         * the error associated with err.
         */
        REQ("zError.01", "", TODO_REQ());

        /*
         * This allows for conversion from error code to string
         * for functions such as compress() and uncompress(),
         * that do not always set the string version of an error.
         */
        REQ("zError.02", "", TODO_REQ());

        if(err<-6 || err>2)
        {        
            /*
             * The zError() function shall return
             * 
             * NULL if err is not a valid error code.
             */
            REQ("zError.03.02", 
                "Shall return NULL if err is not a valid error code", 
                zError_spec==NULL);
        }
        else
        {
            /*
             * The zError() function shall return
             * 
             * a the string identifying the error associated with err
             */
            //Nobody defines that string format
            REQ("zError.03.01", "", TODO_REQ());
        }

        /*
         * It is unspecified if the string returned is determined
         * by the setting of the LC_MESSAGES category in the current locale.
         */
        REQ("zError.04", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

zlibVersion

NAME

    zlibVersion -- discover library version at run time

SYNOPSIS

    #include <zlib.h>

    const char * zlibVersion (void);

DESCRIPTION

    The zlibVersion() function shall return the string identifying the
    interface version at the time the library was built.

    Applications should compare the value returned from zlibVersion() with the 
    macro constant ZLIB_VERSION for compatibility.

RETURN VALUE

    The zlibVersion() function shall return a the string identifying the
    version of the library currently implemented.

ERRORS

    None defined.
*/

specification
CString* zlibVersion_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The zlibVersion() function shall return the string identifying
         * the interface version at the time the library was built.
         */
        REQ("zlibVersion.01", "", TODO_REQ());

        /*
         * Applications should compare the value returned from zlibVersion()
         * with the macro constant ZLIB_VERSION for compatibility.
         */
        REQ("zlibVersion.02", "", TODO_REQ());

        /*
         * The zlibVersion() function shall return a the string identifying
         * the version of the library currently implemented.
         */
        REQ("zlibVersion.03", "", TODO_REQ());

        return true;
    }
}

/********************************************************************/
/*       Specification types and their creation functions           */
/********************************************************************/

specification typedef struct ZStream ZStream = {};

ZStream* create_ZStream(StringTPtr next_in,
                        UIntT avail_in,
                        ULongT total_in,
                        StringTPtr next_out,
                        UIntT avail_out,
                        ULongT total_out,
                        CString* msg,
                        VoidTPtr int_state,
                        VoidTPtr zalloc,
                        VoidTPtr zfree,
                        VoidTPtr opaque,
                        IntT data_type,
                        ULongT adler,
                        ULongT reserved)
{
    return create(&type_ZStream,    next_in,
                                    avail_in,
                                    total_in,
                                    next_out,
                                    avail_out,
                                    total_out,
                                    msg,
                                    int_state,
                                    zalloc,
                                    zfree,
                                    opaque,
                                    data_type,
                                    adler,
                                    reserved);
}
ZStream* create_emptyZStream()
{
    return create_ZStream(
        NULL_VoidTPtr, 0, 0, NULL_VoidTPtr, 0, 0, NULL, NULL_VoidTPtr,
        NULL_VoidTPtr, NULL_VoidTPtr, NULL_VoidTPtr, 0, 0, 0);
}


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
bool deflate_has_error(ZStream* stream, IntT flush, IntT deflate_spec)
{
    return  !
            (
            deflate_spec==SUT_Z_OK 
            ||
            deflate_spec==SUT_Z_STREAM_END && flush==SUT_Z_FINISH
            //&&  "...and there was sufficient space in the output buffer to
            //compress all of the input data"
            )
            ;
}
IntT deflate_data_type(CByteArray* ba)
{
    int size=ba->length;
    int num_asc=0, num_bin=0;
    
    while(--size+1)
    {
        if(byteAt_CByteArray(ba, size)<128)
            num_asc++;
        else
            num_bin++;
    }

    if(num_asc>num_bin)
        return SUT_Z_ASCII;

    return SUT_Z_BINARY;
}
bool deflateCopy_check(ZStream* source, ZStream* dest)
{
    //I dont know how to check int_state equality, cause isn't specified
    //what it shall contain
    return  source->adler == dest->adler
        &&  source->avail_in == dest->avail_in
        &&  source->avail_out == dest->avail_out
        &&  source->data_type == dest->data_type
        &&  equals(source->msg, dest->msg)
        &&  source->next_in.address == dest->next_in.address
        &&  source->next_out.address == dest->next_out.address
        &&  source->opaque.address == dest->opaque.address
        &&  source->reserved == dest->reserved
        &&  source->total_in == dest->total_in
        &&  source->total_out == dest->total_out
        &&  source->zalloc.address == dest->zalloc.address
        &&  source->zfree.address == source->zfree.address;
}
bool equals_ZStream(ZStream* first, ZStream* second)
{
    CByteArray  *first_in, *first_out, *second_in, *second_out;
    //I dont know how to check int_state equality, cause isn't specified
    //what it shall contain

    if((first == NULL) != (second == NULL))
        return false;
    
    if((first == NULL) && (second == NULL))
        return true;

    first_in = readCByteArray_VoidTPtr(first->next_in, first->avail_in);
    first_out = readCByteArray_VoidTPtr(first->next_out, first->total_out);

    second_in = readCByteArray_VoidTPtr(second->next_in, second->avail_in);
    second_out = readCByteArray_VoidTPtr(second->next_out, second->total_out);

    return  first->adler == second->adler
        &&  first->avail_in == second->avail_in
        &&  first->avail_out == second->avail_out
        &&  first->data_type == second->data_type
        &&  equals(first->msg, second->msg)
        &&  first->reserved == second->reserved
        &&  first->total_in == second->total_in
        &&  first->total_out == second->total_out
        &&  first->zalloc.address == second->zalloc.address
        &&  first->zfree.address == second->zfree.address
        &&  equals(first_in, second_in)
        &&  equals(first_out, second_out);
}
bool inSyncPoint()
{
    return true;
}
bool gzopen_mode_check(CString* mode)
{
    IntT i;

    if(mode == NULL)
        return false;

    for(i=0;i<length_CString(mode);i++)
        if( charAt_CString(mode, i)=='r' ||
            charAt_CString(mode, i)=='w' ||
            charAt_CString(mode, i)=='a')
            return true;

    return false;
}
