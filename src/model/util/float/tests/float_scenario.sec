  /*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "util/float/tests/float_scenario.seh"
#include "util/float/float_media.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "math/math/math_data.seh"

#include <stdio.h>



/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context, context1;
static VoidTPtr ptr;
static CString* Four;
/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static bool init_util_float(int argc, char** argv)
{
    // Init test scenario data
    context = getContext();

    initReqFilters();

    ptr = allocateMemoryBlock(context, 1024);

    Four = create_CString("4");

    context1 = createProcess();

    setFinishMode(UNTIL_END);

    return true;
}
static void finish_util_float(void)
{
    deallocateMemoryBlock(context, ptr);
    TEST_SCENARIO_VERDICT_VERBOSE(util_float_scenario);
}
/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario bool __finite_finite_isinf_isnan_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par[5] = {
            Inf[type],
            Nan[type],
            One[type],
            createZero_Unifloat(type),
            clone(Almost_Zero[type])
        };
        for(i = 0; i<5; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                __finite_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign));
                __isinf_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign));
                __isnan_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign));
                finite_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign));
            }
    }
    return true;
}

scenario bool __fpclassify_scen()
{
    int leng_num[2] = {digMant_FloatT, digMant_DoubleT};
    Unifloat* Nan[2] = {clone(nan_FloatT), clone(nan_DoubleT)};
    Unifloat* One[2] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT)};
    Unifloat* Inf[2] = {clone(infinity_FloatT), clone(infinity_DoubleT)};
    Unifloat* Almost_Zero[2] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT)};

    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;

    iterate(int type = 0; type < 2; type++;)
    {
        iterate(int i = 0; i<5; i++;)
            iterate(int sign = 1; sign>-2; sign = sign - 2;)
            {
          Unifloat* _par[5] = {
            Inf[type],
            Nan[type],
            One[type],
            createZero_Unifloat(type),
            clone(Almost_Zero[type])
        };
                __fpclassify_spec(context, changeSign_Unifloat(
                    round_Unifloat(_par[i], leng_num[type]), sign));
            }
    }
    return true;
}

scenario bool __signbit_scen()
{
    int leng_num[2] = {digMant_FloatT, digMant_DoubleT};
    Unifloat* Nan[2] = {clone(nan_FloatT), clone(nan_DoubleT)};
    Unifloat* One[2] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT)};
    Unifloat* Inf[2] = {clone(infinity_FloatT), clone(infinity_DoubleT)};
    Unifloat* Almost_Zero[2] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT)};
    IntT err[1] = {1};
    int i, sign, type;

    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    for(type = 0; type < 2; type++)
    {
        for(i = 0; i<5; i++)
        {
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                Unifloat* _par[5] =
                {
                    Inf[type],
                    Nan[type],
                    One[type],
                    createZero_Unifloat(type),
                    clone(Almost_Zero[type])
                };

                *err = 1;
                if (type == 0)
                    __signbit_spec(context, changeSign_Unifloat(
                        round_Unifloat(_par[i], leng_num[type]), sign), err);
                else
                    __signbit_spec(context1, changeSign_Unifloat(
                        round_Unifloat(_par[i], leng_num[type]), sign), err);

                if (*err == 0)
                    break;
            }
            if (*err == 0)
                break;
            }
    }
    return true;
}

scenario bool frexp_ilogb_logb_scen()
{
    IntT exp;
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Almost_Inf[3] = { clone(max_FloatT), clone(max_DoubleT), clone(max_LongDoubleT)};
    Unifloat* One_Two_Three[3] = {
                    convertInteger_Unifloat(123, UniFloatT),
                    convertInteger_Unifloat(123, UniDoubleT),
                    convertInteger_Unifloat(123, UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par[8] = {
            Inf[type],
            Nan[type],
            One[type],
            createZero_Unifloat(type),
            clone(Almost_Zero[type]),
            clone(Almost_Inf[type]),
            clone(One_Two_Three[type]),
            clone(One_Two_Three[type])
        };
        par[7]->exp = -par[7]->exp;
        for(i = 0; i<8; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                frexp_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign), &exp);
                ilogb_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign),
                    requestErrorCode());
                logb_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign),
                    requestErrorCode());
            }
    }
    return true;
}

scenario bool ldexp_scen()
{
    IntT type, i, j, sign;

    Unifloat* testX[3][7] =
    {
        {
            clone(nan_FloatT),
            clone(infinity_FloatT),
            clone(max_FloatT),
            clone(min_FloatT),
            createOne_Unifloat(UniFloatT),
            createZero_Unifloat(UniFloatT),
            convertBinaryString_Unifloat(create_CString("10011010010.10010001011000010011110100110001101110011011011001101111100100110"), UniFloatT)
        },
        {
            clone(nan_DoubleT),
            clone(infinity_DoubleT),
            clone(max_DoubleT),
            clone(min_DoubleT),
            createOne_Unifloat(UniDoubleT),
            createZero_Unifloat(UniDoubleT),
            convertBinaryString_Unifloat(create_CString("10011010010.10010001011000010011110100110001101110011011011001101111100100110"), UniDoubleT)
        },
        {
            clone(nan_LongDoubleT),
            clone(infinity_LongDoubleT),
            clone(max_LongDoubleT),
            clone(min_LongDoubleT),
            createOne_Unifloat(UniLongDoubleT),
            createZero_Unifloat(UniLongDoubleT),
            convertBinaryString_Unifloat(create_CString("10011010010.10010001011000010011110100110001101110011011011001101111100100110"), UniLongDoubleT)
        }
    };

    IntT testE[5] = {-5, -1, 0, 1, 5};

    for(type = 0; type < 3; type++)
    {
        testX[type][4]->exp = minExp_Unifloat(type) - 5;

        for(i = digMant_Unifloat(type) - 5; i > 10; i--)
            setMant_Unifloat(testX[type][4], i, 1);
    }

    for(type = 0; type < 3; type++)
        for(i = 0; i < 7; i++)
            for(j = 0; j < 5; j++)
                for(sign = -1; sign < 2; sign += 2)
                    ldexp_spec(
                        context,
                        checkRange_Unifloat(changeSign_Unifloat(testX[type][i], sign)),
                        testE[j],
                        requestErrorCode()
                        );

    return true;
}

scenario bool nextafter_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(max_FloatT), clone(max_DoubleT), clone(max_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par_x[23] = { Nan[type], Nan[type], One[type],
            Nan[type], Inf[type], Inf[type], Inf[type], One[type],

            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),

            convertString_Unifloat(Four, type),
            convertString_Unifloat(Four, type),
            convertString_Unifloat(Four, type),
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            createZero_Unifloat(type),

            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),

            clone(Almost_Zero[type]),
            clone(Almost_Zero[type]),
            clone(Almost_Zero[type])
        };
          Unifloat* par_y[23] = { Nan[type], One[type], Nan[type],
            Inf[type], Nan[type], Inf[type], One[type], Inf[type],

            convertInteger_Unifloat(2,type),
            clone(Almost_Inf[type]),
            convertInteger_Unifloat(-2,type),

            convertInteger_Unifloat(16, type),
            convertString_Unifloat(Four, type),
            convertInteger_Unifloat(-6, type),
            convertInteger_Unifloat(10, type),
            createZero_Unifloat(type),
            convertInteger_Unifloat(-10, type),

            Inf[type],
            clone(Almost_Inf[type]),
            clone(Inf[type]),

            One[type],
            clone(Almost_Zero[type]),
            createZero_Unifloat(type)
        };
         par_x[8]->exp = 1; par_x[9]->exp = 1; par_x[10]->exp = 1;
                            par_y[9]->exp = 1;
         par_y[19]->sign = -1;

        for(i = 0; i<23; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                nextafter_spec(context, changeSign_Unifloat(round_Unifloat(par_x[i],
                    leng_num[type]), sign),changeSign_Unifloat(round_Unifloat(par_y[i], leng_num[type]), sign),
                    requestErrorCode());
            }
    }
}

scenario bool nexttoward_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(max_FloatT), clone(max_DoubleT), clone(max_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par_x[23] = {
            Nan[type],
            Nan[type],
            One[type],
            Nan[type],
            Inf[type],
            Inf[type],
            Inf[type],
            One[type],

            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),

            convertString_Unifloat(Four, type),
            convertString_Unifloat(Four, type),
            convertString_Unifloat(Four, type),
            createZero_Unifloat(type),
            createZero_Unifloat(type),
            createZero_Unifloat(type),

            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),

            clone(Almost_Zero[type]),
            clone(Almost_Zero[type]),
            clone(Almost_Zero[type])

        };
          Unifloat* par_y[23] = {
            Nan[UniLongDoubleT],
            One[UniLongDoubleT],
            Nan[UniLongDoubleT],
            Inf[UniLongDoubleT],
            Nan[UniLongDoubleT],
            Inf[UniLongDoubleT],
            One[UniLongDoubleT],
            Inf[UniLongDoubleT],

            convertInteger_Unifloat(2,UniLongDoubleT),
            clone(Almost_Inf[UniLongDoubleT]),
            convertInteger_Unifloat(-2,UniLongDoubleT),

            convertInteger_Unifloat(16, UniLongDoubleT),
            convertString_Unifloat(Four, UniLongDoubleT),
            convertInteger_Unifloat(-6, UniLongDoubleT),
            convertInteger_Unifloat(10, UniLongDoubleT),
            createZero_Unifloat(UniLongDoubleT),
            convertInteger_Unifloat(-10, UniLongDoubleT),

            Inf[UniLongDoubleT],
            clone(Almost_Inf[type]),
            clone(Inf[UniLongDoubleT]),

            One[UniLongDoubleT],
            clone(Almost_Zero[type]),
            createZero_Unifloat(UniLongDoubleT)

        };
         par_x[8]->exp = 1; par_x[9]->exp = 1; par_x[10]->exp = 1;
                            par_y[9]->exp = 1;
         par_y[19]->sign = -1;
         par_y[18]->type = UniLongDoubleT;
         par_y[21]->type = UniLongDoubleT;

        for(i = 0; i<23; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                nexttoward_spec(context, changeSign_Unifloat(round_Unifloat(par_x[i],
                    leng_num[type]), sign),changeSign_Unifloat(round_Unifloat(par_y[i], leng_num[UniLongDoubleT]), sign),
                    requestErrorCode());
            }
    }
    return true;
}

scenario bool scalb_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(max_FloatT), clone(max_DoubleT), clone(max_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par_x[16] = {
            Nan[type],
            Nan[type],
            One[type],

            Inf[type],
            Inf[type],
            One[type],

            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),
            clone(Almost_Inf[type]),

            convertString_Unifloat(Four, type),
            convertString_Unifloat(Four, type),
            convertString_Unifloat(Four, type),

            createZero_Unifloat(type),
            createZero_Unifloat(type),

            clone(Almost_Zero[type]),
            clone(Almost_Zero[type]),
        };
          Unifloat* par_n[16] = {
            Nan[type],
            One[type],
            Nan[type],

            One[type],
            Inf[type],
            Inf[type],

            convertInteger_Unifloat(2,type),
            createZero_Unifloat(type),
            convertInteger_Unifloat(-2,type),

            convertInteger_Unifloat(16, type),
            convertString_Unifloat(create_CString("5.55555"), type),
            convertInteger_Unifloat(-6, type),

            One[type],
            Inf[type],

            convertInteger_Unifloat(2,type),
            convertInteger_Unifloat(-2,type),
        };

        for(i = 0; i<16; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                scalb_spec(context, changeSign_Unifloat(round_Unifloat(par_x[i],
                    leng_num[type]), sign),changeSign_Unifloat(round_Unifloat(par_n[i], leng_num[type]), sign),
                    requestErrorCode());
            }
    }
    return true;
}

scenario bool scalbln_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(max_FloatT), clone(max_DoubleT), clone(max_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par_x[12] = { Nan[type], Inf[type],
                clone(Almost_Inf[type]), clone(Almost_Inf[type]),
                clone(Almost_Inf[type]), clone(Almost_Inf[type]),
                createZero_Unifloat(type), One[type],
                clone(Almost_Zero[type]), clone(Almost_Zero[type]),
                One[type],
                One[type]
        };
          LongT par_n[12] = { 1, 2,
                              3, -3,
                              4, -4,
                              5, 0,
                              1, -1,
                              SUT_LONG_MAX,
                              SUT_LONG_MIN
        };
        par_x[4]->exp = 1; par_x[5]->exp = 1;
        for(i = 0; i<12; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                scalbln_spec(context, changeSign_Unifloat(round_Unifloat(par_x[i],
                    leng_num[type]), sign), par_n[i] * sign, requestErrorCode());
            }
    }
    return true;
}

scenario bool scalbn_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Almost_Inf[3] = { clone(max_FloatT), clone(max_DoubleT), clone(max_LongDoubleT)};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par_x[12] = { Nan[type], Inf[type],
                clone(Almost_Inf[type]), clone(Almost_Inf[type]),
                clone(Almost_Inf[type]), clone(Almost_Inf[type]),
                createZero_Unifloat(type), One[type],
                clone(Almost_Zero[type]), clone(Almost_Zero[type]),
                One[type],
                One[type]
        };
          IntT par_n[12] = { 1, 2,
                              3, -3,
                              4, -4,
                              5, 0,
                              1, -1,
                              SUT_INT_MAX,
                              SUT_INT_MIN
        };
        par_x[4]->exp = 1; par_x[5]->exp = 1;
        for(i = 0; i<12; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                scalbn_spec(context, changeSign_Unifloat(round_Unifloat(par_x[i],
                    leng_num[type]), sign), par_n[i] * sign, requestErrorCode());
            }
    }
    return true;
}

scenario bool significand_scen()
{
    int leng_num[3] = {digMant_FloatT, digMant_DoubleT, digMant_LongDoubleT};
    Unifloat* Nan[3] = {clone(nan_FloatT), clone(nan_DoubleT), clone(nan_LongDoubleT)};
    Unifloat* One[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    Unifloat* Inf[3] = {clone(infinity_FloatT), clone(infinity_DoubleT), clone(infinity_LongDoubleT)};
    Unifloat* Almost_Zero[3] = {createOne_Unifloat(UniFloatT),
                        createOne_Unifloat(UniDoubleT),
                        createOne_Unifloat(UniLongDoubleT)};
    int type, i, sign;
    Almost_Zero[0]->exp = 1 - digMant_FloatT + minExp_FloatT;
    Almost_Zero[1]->exp = 1 - digMant_DoubleT + minExp_DoubleT;
    Almost_Zero[2]->exp = 1 - digMant_LongDoubleT + minExp_LongDoubleT;
    // support for subnormal values
    if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32 || TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64){
        if(sizeof_LongDoubleT == 16){
            Almost_Zero[2]->exp += digMant_LongDoubleT / 2;
        }
    }
    for(type = 0; type < 3; type++)
    {
          Unifloat* par[7] = {
            Inf[type],
            Nan[type],
            One[type],
            createZero_Unifloat(type),
            clone(Almost_Zero[type]),
            convertInteger_Unifloat(123, type),
            convertString_Unifloat(create_CString("0.0123456"), type)
        };
        for(i = 0; i<7; i++)
            for(sign = 1; sign>-2; sign = sign - 2)
            {
                significand_spec(context, changeSign_Unifloat(
                    round_Unifloat(par[i], leng_num[type]), sign));
            }
    }
    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm util_float_scenario =
{
    .init = init_util_float,
    .finish = finish_util_float,
    .actions = {
                    __finite_finite_isinf_isnan_scen,
                    frexp_ilogb_logb_scen,
                    ldexp_scen,
                    __fpclassify_scen,
                    nextafter_scen,
                    nexttoward_scen,
                    scalb_scen,
                    scalbln_scen,
                    scalbn_scen,
                    significand_scen,
                    __signbit_scen,
                    NULL
                }
};

bool main_util_float(int argc, char** argv)
{
    util_float_scenario(argc,argv);
    return true;
}

#include "util/float/tests/float_scenario.seh"
#include "math/math/math_data.seh"

#ifdef UTIL_FLOAT_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "util/float/float_media.seh"
#include "math/math/math_data.seh"


/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initMath();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initUtilFloatSubsystem();
}

#ifdef WIN32

int main(int argc, char** argv)
{
    clock_t start, finish;
    double duration;

    initTestSystem();

    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");


    start = clock();

    main_util_float(argc,argv);


    finish = clock();
    duration = (double) (finish - start) / CLOCKS_PER_SEC;

    verbose( "%2.3f seconds\n", duration );



    //  unloadSUT();
    return 0;
}

#else

int main(int argc, char** argv)
{
    initTestSystem();
    loadSUT();

    // Set up tracer
    setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");
    main_util_float(argc,argv);

    //  unloadSUT();
    return 0;
}

#endif

#endif



