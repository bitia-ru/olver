/*
 * Copyright __(c)__ 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "util/getopt/getopt_model.seh"

#pragma SEC subsystem getopt "util.getopt"



/*
   The group of functions 'util.getopt' consists of:
       getopt [2]
       getopt_long [2]
       getopt_long_only [2]
       getsubopt [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    getopt -- parse command line options

SYNOPSIS

    #include <unistd.h>

    int getopt(int argc, char * const argv[], const char * optstring);

    extern char *optarg; extern int optind, opterr, optopt;

DESCRIPTION

    The getopt() function shall parse command line arguments as described in ISO
    POSIX (2003), with the following exceptions, where LSB and POSIX
    specifications vary. LSB systems shall implement the modified behaviors
    described below.

    Argument Ordering

    The getopt() function can process command line arguments referenced by argv
    in one of three ways:

    PERMUTE
        the order of arguments in argv is altered so that all options (and their
        arguments) are moved in front of all of the operands. This is the
        default behavior.

        Note: This behavior has undefined results if argv is not modifiable.
        This is to support historic behavior predating the use of const and ISO
        C (1999). The function prototype was aligned with ISO POSIX (2003)
        despite the fact that it modifies argv, and the library maintainers are
        unwilling to change this.

    REQUIRE_ORDER
        The arguments in argv are processed in exactly the order given, and
        option processing stops when the first non-option argument is reached,
        or when the element of argv is "--". This ordering can be enforced
        either by setting the environment variable POSIXLY_CORRECT, or by
        setting the first character of optstring to '+'.

    RETURN_IN_ORDER
        The order of arguments is not altered, and all arguments are processed.
        Non-option arguments (operands) are handled as if they were the argument
        to an option with the value 1 ('\001'). This ordering is selected by
        setting the first character of optstring to '-';

    Option Characteristics

    LSB specifies that:

    * an element of argv that starts with "-" (and is not exactly "-" or "--")
      is an option element.

    * characters of an option element, aside from the initial "-", are option
      characters.

    POSIX specifies that:

    * applications using getopt() shall obey the following syntax guidelines:

        * option name is a single alphanumeric character from the portable
          character set

        * option is preceded by the '-' delimiter character

        * options without option-arguments should be accepted when grouped
          behind one '-' delimiter

        * each option and option-argument is a separate argument

        * option-arguments are not optional

        * all options should precede operands on the command line

        * the argument "--" is accepted as a delimiter indicating the end of
          options and the consideration of subsequent arguments, if any, as
          operands

    * historical implementations of getopt() support other characters as options
      as an allowed extension, but applications that use extensions are not
      maximally portable.

    * support for multi-byte option characters is only possible when such
      characters can be represented as type int.

    * applications that call any utility with a first operand starting with '-'
      should usually specify "--" to mark the end of the options. Standard
      utilities that do not support this guideline indicate that fact in the
      OPTIONS section of the utility description.

    Extensions

    LSB specifies that:

    * if a character is followed by two colons, the option takes an optional
      argument; if there is text in the current argv element, it is returned in
      optarg, otherwise optarg is set to 0.

    * if optstring contains W followed by a semi-colon (;), then -W foo is
      treated as the long option --foo.

      Note: See getopt_long() for a description of long options.

    * The first character of optstring shall modify the behavior of getopt() as
      follows:

        * if the first character is '+', then REQUIRE_ORDER processing shall be
          in effect (see above)

        * if the first character is '-', then RETURN_IN_ORDER processing shall
          be in effect (see above)

        * if the first character is ':', then getopt() shall return ':' instead
          of '?' to indicate a missing option argument, and shall not print any
          diagnostic message to stderr.

    POSIX specifies that:

    * the -W option is reserved for implementation extensions.

    Return Values

    LSB specifies the following additional getopt() return values:

    * '\001' is returned if RETURN_IN_ORDER argument ordering is in effect, and
      the next argument is an operand, not an option. The argument is available
      in optarg.

    Any other return value has the same meaning as for POSIX.

    POSIX specifies the following getopt() return values:

    * the next option character is returned, if found successfully.

    * ':' is returned if a parameter is missing for one of the options and the
      first character of optstring is ':'.

    * '?' is returned if an unknown option character not in optstring is
      encountered, or if getopt() detects a missing argument and the first
      character of optstring is not ':'.

    * -1 is returned for the end of the option list.

    Environment Variables

    LSB specifies that:

    * if the variable POSIXLY_CORRECT is set, option processing stops as soon as
      a non-option argument is encountered.

    * the variable _[PID]_GNU_nonoption_argv_flags_ (where [PID] is the process
      ID for the current process), contains a space separated list of arguments
      that should not be treated as arguments even though they appear to be so.

      Rationale: This was used by bash 2.0 to communicate to GNU libc which
      arguments resulted from wildcard expansion and so should not be considered
      as options. This behavior was removed in bash version 2.01, but the
      support remains in GNU libc.

      This behavior is DEPRECATED in this version of the LSB; future revisions
      of this specification may not include this requirement.
*/
/*
Linux Standard Base Core Specification 3.0
Copyright __(c)__ 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright __(c)__ 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getopt, optarg, opterr, optind, optopt - command option parsing

SYNOPSIS

    #include <unistd.h>

    int getopt(int argc, char * const argv[], const char *optstring);

    extern char *optarg;

    extern int optind, opterr, optopt;

DESCRIPTION

    The getopt() function is a command-line parser that shall follow Utility
    Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in the Base Definitions volume
    of IEEE Std  1003.1-2001, Section 12.2, Utility Syntax Guidelines.

    The parameters argc and argv are the argument count and argument array as
    passed to main() (see exec() ). The argument optstring is a string of
    recognized option characters; if a character is followed by a colon, the
    option takes an argument. All option characters allowed by Utility Syntax
    Guideline 3 are allowed in optstring. The implementation may accept other
    characters as an extension.

    The variable optind is the index of the next element of the argv[] vector
    to be processed. It shall be initialized to 1 by the system, and getopt()
    shall update it when it finishes with each element of argv[]. When an
    element of argv[] contains multiple option characters, it is unspecified
    how getopt() determines which options have already been processed.

    The getopt() function shall return the next option character (if one is
    found) from argv that matches a character in optstring, if there is one
    that matches. If the option takes an argument, getopt() shall set the
    variable optarg to point to the option-argument as follows:

    If the option was the last character in the string pointed to by an element
    of argv, then optarg shall contain the next element of argv, and optind
    shall be incremented by 2. If the resulting value of optind is greater than
    argc, this indicates a missing option-argument, and getopt() shall return
    an error indication.

    Otherwise, optarg shall point to the string following the option character
    in that element of argv, and optind shall be incremented by 1.

    If, when getopt() is called:

        argv[optind] is a null pointer*
        *argv[optind] is not the character -
        argv[optind] points to the string "-"

    getopt() shall return -1 without changing optind.

    If:
        argv[optind] points to the string "--"

    getopt() shall return -1 after incrementing optind.

    If getopt() encounters an option character that is not contained in
    optstring, it shall return the question-mark ( '?' ) character. If it
    detects a missing option-argument, it shall return the colon character
    ( ':' ) if the first character of optstring was a colon, or a question-mark
    character ( '?' ) otherwise. In either case, getopt() shall set the
    variable optopt to the option character that caused the error. If the
    application has not set the variable opterr to 0 and the first character of
    optstring is not a colon, getopt() shall also print a diagnostic message to
    stderr in the format specified for the getopts utility.

    The getopt() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

RETURN VALUE

    The getopt() function shall return the next option character specified on
    the command line.

    A colon ( ':' ) shall be returned if getopt() detects a missing argument
    and the first character of optstring was a colon ( ':' ).

    A question mark ( '?' ) shall be returned if getopt() encounters an option
    character not in optstring or detects a missing argument and the first
    character of optstring was not a colon ( ':' ).

    Otherwise, getopt() shall return -1 when all command line options are
    parsed.

ERRORS

    No errors are defined.
*/

specification
IntT getopt_spec( CallContext context, IntT argc, List* argv,
                                                        CString* optstring)
{
    ProcessState* ps=getProcessState_CallContext(context);
    GetoptRet* getopt_pre=clone(ps->getOpt);

    if(getopt_pre==NULL)
        getopt_pre=create_emptyGetoptRet();

    pre
    {
        return true;
    }
    post
    {
        GetoptRet* getopt_post;
        CString* item;

        DUMP("post: getopt_pre==$(obj)\n", getopt_pre);

        ps=getProcessState_CallContext(context);

        if(ps==NULL)
            return false;
        if(ps->getOpt==NULL)
            return false;

        getopt_post=clone(ps->getOpt);

        DUMP("ret==%c, dash_dash==%d\n", getopt_spec,
            getopt_post->found_dashdash);

        //In fact LSB doesn't support all this POSIX Guidelines:)
        /*
         * The getopt() function is a command-line parser that shall
         * follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10
         * in the Base Definitions volume of IEEE Std  1003.1-2001,
         * Section 12.2, Utility Syntax Guidelines.
         */
        REQ("getopt.01", "", TODO_REQ());

        /*
         * The parameters argc and argv are the argument count and
         * argument array as passed to main() (see exec() ).
         */
        REQ("getopt.02", "", TODO_REQ());

        /*
         * The argument optstring is a string of recognized option
         * characters; if a character is followed by a colon, the
         * option takes an argument.
         */
        REQ("getopt.03", "", TODO_REQ());

        /*
         * All option characters allowed by Utility Syntax Guideline 3
         * are allowed in optstring. The implementation may accept
         * other characters as an extension.
         */
        REQ("getopt.04", "", TODO_REQ());

        /*
         * The variable optind is the index of the next element of
         * the argv[] vector to be processed. It shall be initialized
         * to 1 by the system, and getopt() shall update it when it
         * finishes with each element of argv[].
         */
        REQ("getopt.05", "", TODO_REQ());

        /*
         * When an element of argv[] contains multiple option
         * characters, it is unspecified how getopt() determines
         * which options have already been processed.
         */
        REQ("getopt.06", "", TODO_REQ());

        /*
         * The getopt() function shall return the next option
         * character (if one is found) from argv that matches
         * a character in optstring, if there is one that matches.
         */
        REQ("getopt.07", "", TODO_REQ());

        /*
         * The getopt() function need not be reentrant. A function
         * that is not required to be reentrant is not required
         * to be thread-safe.
         */
        REQ("getopt.15", "", TODO_REQ());

        /*
         * The getopt() function shall return the next option
         * character specified on the command line.
         */
        REQ("getopt.16", "", TODO_REQ());
        DUMP("getopt_post==$(obj), argc==%d\n", getopt_post, argc);


        if( getopt_pre->found_dashdash
            &&
            (   get_Map(ps->environ, create_CString("POSIXLY_CORRECT"))!=NULL
                ||
                charAt_CString(optstring, 0)=='+')  )
        {
            REQ("", "Implicit condition: after finding \"--\" getopt shall"
                "only iterate optind, returning -1", getopt_spec==-1);

            return true;
        }

        if(getopt_pre->optind==argc - ps->getOpt->permuted_elements)
        {
            /*
             * Otherwise, getopt() shall return -1 when all command
             * line options are parsed.
             */
            REQ("getopt.19",
                "Otherwise, getopt() shall return -1",
                getopt_spec==-1);

            return true;
        }

        if(getopt_pre->optind<argc - ps->getOpt->permuted_elements)
        {
            item=(CString*)get_List(argv, getopt_pre->optind);

            if(item==NULL   || equals(item, create_CString("-"))
                            || charAt_CString(item, 0)!='-')
            {
                DUMP("09: getopt_spec==%d\n",
                    getopt_spec);

                DUMP("09: getopt_pre==$(obj)\n", getopt_pre);
                DUMP("09: getopt_post==$(obj)\n", getopt_post);
                /*
                 * If, when getopt() is called:
                 *
                 *      argv[optind] is a null pointer
                 *      *argv[optind] is not the character -
                 *      argv[optind] points to the string "-"
                 *
                 * getopt() shall return -1 without changing optind.
                 */
                REQ("getopt.09.child", "-1, without changing optind",
                getopt_spec==-1 && getopt_pre->optind==getopt_post->optind);

                return true;
            }

            if(equals(item, create_CString("--")))
            {
                /*
                 * If argv[optind] points to the string "--"
                 * getopt() shall return -1 after incrementing optind.
                 */
                REQ("getopt.10.child", "-1, with incrementing optind",
                getopt_spec==-1 && getopt_pre->optind==getopt_post->optind-1);

                return true;
            }

            if(getopt_11_pred(item, getopt_pre, optstring))
            {
                /*
                 * If getopt() encounters an option character that is
                 * not contained in optstring, it shall return the
                 * question-mark ( '?' ) character.
                 */
                /*
                 * A question mark ( '?' ) shall be returned if getopt()
                 *
                 * encounters an option character not in optstring
                 */
                REQ("getopt.11;getopt.18.01", "Unknown option",
                            getopt_spec==(IntT)'?');

                return true;
            }


            if(getopt_take_arg(item, getopt_pre, optstring))
            {
                IntT ind=1;

                if(getopt_pre->inner_index!=-1)
                    ind=getopt_pre->inner_index;

                if(length_CString(item)==ind+1)
                {
                DUMP("Last");
                /*
                 * If the option takes an argument, getopt() shall set the
                 * variable optarg to point to the option-argument as follows:
                 *
                 * If the option was the last character in the string pointed
                 * to by an element of argv, then optarg shall contain the
                 * next element of argv, and optind shall be incremented by 2.
                 */
                REQ("getopt.08.01",
                    "If the option was the last character in the string "
                    "pointed to by an element of argv, then optarg shall "
                    "contain the next element of argv, and optind shall be "
                    "incremented by 2",
                    getopt_08_01_check(getopt_pre, getopt_post, argv, ps));
                }
                else
                {
                /*
                 * If the option takes an argument, getopt() shall set the
                 * variable optarg to point to the option-argument as follows:
                 *
                 * Otherwise, optarg shall point to the string following the
                 * option character in that element of argv, and optind shall
                 * be incremented by 1.
                 */
                REQ("getopt.08.03",
                    "Otherwise, optarg shall point to the string following "
                    "the option character in that element of argv, and optind "
                    "shall be incremented by 1",
                    getopt_08_03_check(getopt_pre, getopt_post, argv));

                }
            }
        }

        if(getopt_post->optind>argc - ps->getOpt->permuted_elements)
        {
            /*
             * If the option takes an argument, getopt() shall set the
             * variable optarg to point to the option-argument as follows:
             *
             * If the resulting value of optind is greater than argc,
             * this indicates a missing option-argument, and getopt()
             * shall return an error indication.
             */
            REQ("getopt.08.02", "", TODO_REQ());

            /*
             * If it detects a missing option-argument, it shall
             * return the colon character ( ':' ) if the first
             * character of optstring was a colon, or a question-mark
             * character ( '?' ) otherwise.
             */
            REQ("getopt.12",
                "If it detects a missing option-argument",
                charAt_CString(optstring, 0)==':' ?
                        getopt_spec==(IntT)':' : getopt_spec==(IntT)'?');

            if(charAt_CString(optstring, 0)==':')
            {
                /*
                 * A colon ( ':' ) shall be returned if getopt() detects a
                 * missing argument and the first character of optstring
                 * was a colon ( ':' ).
                 */
                REQ("getopt.17",
                    "If detects a missing argument",
                    getopt_spec==(IntT)':');
            }
            else
            {
                /*
                 * A question mark ( '?' ) shall be returned if getopt()
                 *
                 * detects a missing argument and the first character of
                 * optstring was not a colon
                 * ( ':' ).
                 */
                REQ("getopt.18.02",
                    "If detects a missing argument",
                    getopt_spec==(IntT)'?');
            }

            /*
             * In either case, getopt() shall set the variable optopt
             * to the option character that caused the error.
             */
            REQ("getopt.13",
                "In either case, getopt() shall set the variable optopt to "
                "the option character that caused the error",
                getopt_13_check(getopt_pre, getopt_post, argv, optstring));

            /*
             * If the application has not set the variable opterr to 0
             * and the first character of optstring is not a colon,
             * getopt() shall also print a diagnostic message to stderr
             * in the format specified for the getopts utility.
             */
            REQ("getopt.14", "", TODO_REQ());

            return true;
        }

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * PERMUTE
         *
         * the order of arguments in argv is altered so that all options (and their
         * arguments) are moved in front of all of the operands. This is the default
         * behavior.
         */
        REQ("getopt.30.01.01", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * REQUIRE_ORDER
         *
         * The arguments in argv are processed in exactly the order given
         */
        REQ("getopt.30.02.01", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * REQUIRE_ORDER
         *
         * option processing stops when the first non-option argument is reached
         */
        REQ("getopt.30.02.02", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * REQUIRE_ORDER
         *
         * or when the element of argv is "--"
         */
        REQ("getopt.30.02.03", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * REQUIRE_ORDER
         *
         * This ordering can be enforced
         *
         * either by setting the environment variable POSIXLY_CORRECT
         */
        REQ("getopt.30.02.04.01", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * REQUIRE_ORDER
         *
         * This ordering can be enforced
         *
         * or by setting the first character of optstring to '+'
         */
        REQ("getopt.30.02.04.02", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * RETURN_IN_ORDER
         *
         * The order of arguments is not altered
         */
        REQ("getopt.30.03.01", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * RETURN_IN_ORDER
         *
         * all arguments are processed
         */
        REQ("getopt.30.03.02", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * RETURN_IN_ORDER
         *
         * Non-option arguments (operands) are handled as if they were the argument to an
         * option with the value 1 ('\001').
         */
        REQ("getopt.30.03.03", "", TODO_REQ());

        /*
         * The getopt() function can process command line arguments referenced by argv in
         * one of three ways:
         *
         * RETURN_IN_ORDER
         *
         * This ordering is selected by setting the first character of optstring to '-';
         */
        REQ("getopt.30.03.04", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * an element of argv that starts with "-" (and is not exactly "-" or "--") is an
         * option element.
         */
        REQ("getopt.31.01", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * characters of an option element, aside from the initial "-", are option
         * characters.
         */
        REQ("getopt.31.02", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * option name is a single alphanumeric character from the portable character set
         */
        REQ("getopt.32.01.01", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * option is preceded by the '-' delimiter character
         */
        REQ("getopt.32.01.02", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * options without option-arguments should be accepted when grouped behind one '-'
         * delimiter
         */
        REQ("getopt.32.01.03", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * each option and option-argument is a separate argument
         */
        REQ("getopt.32.01.04", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * option-arguments are not optional
         */
        REQ("getopt.32.01.05", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * all options should precede operands on the command line
         */
        REQ("getopt.32.01.06", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications using getopt() shall obey the following syntax guidelines:
         *
         * the argument "--" is accepted as a delimiter indicating the end of options and
         * the consideration of subsequent arguments, if any, as operands
         */
        REQ("getopt.32.01.07", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * historical implementations of getopt() support other characters as options as
         * an allowed extension, but applications that use extensions are not maximally
         * portable.
         */
        REQ("getopt.32.02", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * support for multi-byte option characters is only possible when such characters
         * can be represented as type int.
         */
        REQ("getopt.32.03", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * applications that call any utility with a first operand starting with '-'
         * should usually specify "--" to mark the end of the options. Standard utilities
         * that do not support this guideline indicate that fact in the OPTIONS section of
         * the utility description.
         */
        REQ("getopt.32.04", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * if a character is followed by two colons, the option takes an optional
         * argument; if there is text in the current argv element, it is returned in
         * optarg, otherwise optarg is set to 0.
         */
        REQ("getopt.33.01", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * if optstring contains W followed by a semi-colon (;), then -W foo is treated as
         * the long option --foo.
         */
        REQ("getopt.33.02", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * The first character of optstring shall modify the behavior of getopt() as
         * follows:
         *
         * if the first character is '+', then REQUIRE_ORDER processing shall be in
         * effect (see above)
         */
        REQ("getopt.33.03.01", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * The first character of optstring shall modify the behavior of getopt() as
         * follows:
         *
         * if the first character is '-', then RETURN_IN_ORDER processing shall be in
         * effect (see above)
         */
        REQ("getopt.33.03.02", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * The first character of optstring shall modify the behavior of getopt() as
         * follows:
         *
         * if the first character is ':', then getopt() shall return ':' instead of '?' to
         * indicate a missing option argument, and shall not print any diagnostic message
         * to stderr.
         */
        REQ("getopt.33.03.03", "", TODO_REQ());

        /*
         * POSIX specifies that:
         *
         * the -W option is reserved for implementation extensions.
         */
        REQ("getopt.34.01", "", TODO_REQ());

        /*
         * LSB specifies the following additional getopt() return values:
         *
         * '\001' is returned if RETURN_IN_ORDER argument ordering is in effect, and the
         * next argument is an operand, not an option. The argument is available in optarg.
         */
        REQ("getopt.35.01", "", TODO_REQ());

        /*
         * POSIX specifies the following getopt() return values:
         *
         * the next option character is returned, if found successfully.
         */
        REQ("getopt.36.01", "", TODO_REQ());

        /*
         * POSIX specifies the following getopt() return values:
         *
         * ':' is returned if a parameter is missing for one of the options and the first
         * character of optstring is ':'.
         */
        REQ("getopt.36.02", "", TODO_REQ());

        /*
         * POSIX specifies the following getopt() return values:
         *
         * '?' is returned if an unknown option character not in optstring is encountered,
         * or if getopt() detects a missing argument and the first character of optstring
         * is not ':'.
         */
        REQ("getopt.36.03", "", TODO_REQ());

        /*
         * POSIX specifies the following getopt() return values:
         *
         * -1 is returned for the end of the option list.
         */
        REQ("getopt.36.04", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * if the variable POSIXLY_CORRECT is set, option processing stops as soon as a
         * non-option argument is encountered.
         */
        REQ("getopt.37.01", "", TODO_REQ());

        /*
         * LSB specifies that:
         *
         * the variable _[PID]_GNU_nonoption_argv_flags_ (where [PID] is the process ID
         * for the current process), contains a space separated list of arguments that
         * should not be treated as arguments even though they appear to be so.
         */
        REQ("getopt.37.02", "", TODO_REQ());

        return true;
    }
}

void OnGetopt( CallContext context, IntT argc, List* argv,
                CString* optstring, IntT getopt_spec, GetoptRet* getopt_post)
{
    ProcessState* ps=getProcessState_CallContext(context);
    IntT ind=ps->getOpt->inner_index;
    IntT dd=0;

    DUMP("pre: dash-dash==%d\n", ps->getOpt->found_dashdash);

    if(ps->getOpt->optind!=getopt_post->optind)
    {
        ps->getOpt->inner_index=-1;
    }
    else
    {
        if(ind==-1)
            ps->getOpt->inner_index=2;
        else
            ps->getOpt->inner_index=ind+1;
    }

    if(getopt_post->optind<size_List(argv) - ps->getOpt->permuted_elements)
    if( equals(
            (CString*)get_List(argv, getopt_post->optind),
            create_CString("--")
            ))
            ps->getOpt->found_dashdash=1;

    ps->getOpt->optarg=clone(getopt_post->optarg);
    ps->getOpt->opterr=getopt_post->opterr;
    ps->getOpt->optind=getopt_post->optind;
    ps->getOpt->optopt=getopt_post->optopt;

    DUMP("ps->getOpt==$(obj)\n", ps->getOpt);

    DUMP("post: dash-dash==%d\n", ps->getOpt->found_dashdash);

    if( charAt_CString(optstring, 0)!='+' && charAt_CString(optstring, 0)!='-'
        &&
        get_Map(ps->environ, create_CString("POSIXLY_CORRECT"))==NULL)
    {
        //PERMUTE: we need permute argv so that all options
        //(and their arguments) are moved in front of all of the operands
        CString* tmp;
        IntT i=0, curr=1;

        while(curr<size_List(argv)-i)
        {
            tmp=clone((CString*)get_List(argv, curr));

            if(charAt_CString(tmp, 0)=='-')
            {
                if(length_CString(tmp)==2)
                {
                    ind=indexOfChar_CString(optstring, charAt_CString(tmp, 1));
                    if(ind!=-1 && length_CString(optstring)>ind+1)
                    {
                        if(charAt_CString(optstring, ind+1)==':')
                            curr+=2;
                        else//Option doesn't take an arg
                            curr++;
                    }
                    else//incorrect option, or option doesn't take an arg
                        curr++;

                }
                else//may be multiple option, maybe incorrect option...
                    curr++;
            }
            else
            {
                remove_List(argv, curr);
                append_List(argv, tmp);
                curr++;
                i++;
            }
        }

        ps->getOpt->permuted_elements=i;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright __(c)__ 2004, 2005 Free Standards Group

  getopt_long

NAME

    getopt_long -- parse command line options

SYNOPSIS

    #define _GNU_SOURCE
    #include <getopt.h>

    int getopt_long(int argc, char * const argv[], const char * opstring,
                        const struct option * longopts, int * longindex);

DESCRIPTION

    getopt_long() works like getopt() except that it also accepts long options,
    started out by two dashes. Long option names may be abbreviated if the
    abbreviation is unique or is an exact match for some defined option. A long
    option may take a parameter, of the form --arg=param or --arg param.

    longopts is a pointer to the first element of an array of struct option
    declared in getopt.h as:

    struct option {
             const char *name;
             int has_arg;
             int *flag;
             int val;
    };

    The fields in this structure have the following meaning:

    name

        The name of the long option.

    has_arg

        One of:

        no_argument (or 0) if the option does not take an argument,
        required_argument (or 1) if the option requires an argument, or
        optional_argument (or 2) if the option takes an optional argument.

    flag

        specifies how results are returned for a long option. If flag is NULL,
        then getopt_long() shall return val. (For example, the calling program
        may set val to the equivalent short option character.) Otherwise,
        getopt_long() returns 0, and flag shall point to a variable which shall
        be set to val if the option is found, but left unchanged if the option
        is not found.

    val

        The value to return, or to load into the variable pointed to by flag.

RETURN VALUE

    getopt_long() returns the option character if a short option was found
    successfully, or ":" if there was a missing parameter for one of the
    options, or "?" for an unknown option character, or -1 for the end of
    the option list.

    For a long option, getopt_long() returns val if flag is NULL, and 0
    otherwise. Error and -1 returns are the same as for getopt(), plus "?"
    for an ambiguous match or an extraneous parameter.
*/
specification typedef struct Option Option = {};

//This specification refers to: getopt, getopt_long
specification
IntT getopt_long_spec( CallContext context, IntT argc, List* argv,
                    CString* optstring, List* longopts, IntT* longindex)
{
    ProcessState* ps=getProcessState_CallContext(context);
    GetoptRet* getopt_pre=clone(ps->getOpt);

    if(getopt_pre==NULL)
        getopt_pre=create_emptyGetoptRet();

    pre
    {
        return true;
    }
    post
    {
        GetoptRet* getopt_post;
        CString* item;
        IntT variant;

        DUMP("post: getopt_pre==$(obj)\n", getopt_pre);

        ps=getProcessState_CallContext(context);

        if(ps==NULL)
            return false;
        if(ps->getOpt==NULL)
            return false;

        getopt_post=clone(ps->getOpt);

        DUMP("ret==%c, dash_dash==%d\n", getopt_long_spec,
            getopt_post->found_dashdash);

        //In fact LSB doesn't support all this POSIX Guidelines:)
        /*
         * The getopt() function is a command-line parser that shall
         * follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10
         * in the Base Definitions volume of IEEE Std  1003.1-2001,
         * Section 12.2, Utility Syntax Guidelines.
         */
        REQ("getopt.01", "", TODO_REQ());

        /*
         * The parameters argc and argv are the argument count and
         * argument array as passed to main() (see exec() ).
         */
        REQ("getopt.02", "", TODO_REQ());

        /*
         * The argument optstring is a string of recognized option
         * characters; if a character is followed by a colon, the
         * option takes an argument.
         */
        REQ("getopt.03", "", TODO_REQ());

        /*
         * All option characters allowed by Utility Syntax Guideline 3
         * are allowed in optstring. The implementation may accept
         * other characters as an extension.
         */
        REQ("getopt.04", "", TODO_REQ());

        /*
         * The variable optind is the index of the next element of
         * the argv[] vector to be processed. It shall be initialized
         * to 1 by the system, and getopt() shall update it when it
         * finishes with each element of argv[].
         */
        REQ("getopt.05", "", TODO_REQ());

        /*
         * When an element of argv[] contains multiple option
         * characters, it is unspecified how getopt() determines
         * which options have already been processed.
         */
        REQ("getopt.06", "", TODO_REQ());

        /*
         * The getopt() function shall return the next option
         * character (if one is found) from argv that matches
         * a character in optstring, if there is one that matches.
         */
        REQ("getopt.07", "", TODO_REQ());

        /*
         * The getopt() function need not be reentrant. A function
         * that is not required to be reentrant is not required
         * to be thread-safe.
         */
        REQ("getopt.15", "", TODO_REQ());

        /*
         * The getopt() function shall return the next option
         * character specified on the command line.
         */
        REQ("getopt.16", "", TODO_REQ());
        DUMP("getopt_post==$(obj), argc==%d\n", getopt_post, argc);

        {
            /*
             * getopt_long() works like getopt() except that it also
             * accepts long options, started out by two dashes.
             */
            REQ("getopt_long.01", "", TODO_REQ());

            /*
             * Long option names may be abbreviated if the abbreviation
             * is unique or is an exact match for some defined option.
             */
            REQ("getopt_long.02", "", TODO_REQ());

            /*
             * A long option may take a parameter, of the form
             * --arg=param or --arg param.
             */
            REQ("getopt_long.03", "", TODO_REQ());

            /*
             * longopts is a pointer to the first element of an array
             * of struct option declared in getopt.h as:
             *
             * struct option
             * {
             *      const char *name;
             *      int has_arg; int *flag; int val;
             * };
             */
            REQ("getopt_long.04", "", TODO_REQ());

            /*
             * The fields in this structure have the following meaning:
             *
             * name
             *
             *      The name of the long option.
             *
             * has_arg
             *
             * One of:
             *      no_argument (or 0) if the option does not take an argument,
             *
             *      required_argument (or 1) if the option requires an
             *                                                    argument.or
             *      optional_argument (or 2) if the option takes an optional
             *                                 argument.
             *
             * flag
             *
             *      specifies how results are returned for a long option.
             *      If flag is NULL, then getopt_long() shall return val.
             *      (For example, the calling program may set val to the
             *      equivalent short option character.) Otherwise,
             *      getopt_long() returns 0, and flag shall point to a variable
             *      which shall be set to val if the option is found, but left
             *      unchanged if the option is not found.
             *
             * val
             *
             *      The value to return, or to load into the variable pointed
             *      to by flag.
             */
            REQ("getopt_long.05;getopt_long.05.01", "", TODO_REQ());

            /*
             * getopt_long() returns the option character if a short
             * option was found successfully,
             */
            REQ("getopt_long.06", "", TODO_REQ());

            /*
             * or ":" if there was a missing parameter for one of the options,
             */
            REQ("getopt_long.07", "", TODO_REQ());

            /*
             * or "?" for an unknown option character,
             */
            REQ("getopt_long.08", "", TODO_REQ());

            /*
             * or -1 for the end of the option list.
             */
            REQ("getopt_long.09", "", TODO_REQ());

            /*
             * For a long option, getopt_long() returns val if flag is NULL,
             */
            REQ("getopt_long.10", "", TODO_REQ());

            /*
             * and 0 otherwise.
             */
            REQ("getopt_long.11", "", TODO_REQ());

            /*
             * Error and -1 returns are the same as for getopt(),
             * plus "?" for an ambiguous match or an extraneous parameter.
             */
            REQ("getopt_long.12", "", TODO_REQ());

        }

        if( getopt_pre->found_dashdash
            &&
            (   get_Map(ps->environ, create_CString("POSIXLY_CORRECT"))!=NULL
                ||
                charAt_CString(optstring, 0)=='+')  )
        {
            REQ("", "Implicit condition: after finding \"--\" getopt shall"
                "only iterate optind, returning -1", getopt_long_spec==-1);

            return true;
        }

        if(getopt_pre->optind==argc - ps->getOpt->permuted_elements)
        {
            /*
             * Otherwise, getopt() shall return -1 when all command
             * line options are parsed.
             */
            REQ("getopt.19",
                "Otherwise, getopt() shall return -1",
                getopt_long_spec==-1);

            return true;
        }

        if(getopt_pre->optind<argc - ps->getOpt->permuted_elements)
        {
            item=(CString*)get_List(argv, getopt_pre->optind);

            if(item==NULL   || equals(item, create_CString("-"))
                            || charAt_CString(item, 0)!='-')
            {
                DUMP("09: getopt_long_spec==%d\n",
                    getopt_long_spec);

                DUMP("09: getopt_pre==$(obj)\n", getopt_pre);
                DUMP("09: getopt_post==$(obj)\n", getopt_post);
                /*
                 * If, when getopt() is called:
                 *
                 *      argv[optind] is a null pointer
                 *      *argv[optind] is not the character -
                 *      argv[optind] points to the string "-"
                 *
                 * getopt() shall return -1 without changing optind.
                 */
                REQ("getopt.09.child", "-1, without changing optind",
                getopt_long_spec==-1
                && getopt_pre->optind==getopt_post->optind);

                return true;
            }

            if(equals(item, create_CString("--")))
            {
                /*
                 * If argv[optind] points to the string "--"
                 * getopt() shall return -1 after incrementing optind.
                 */
                REQ("getopt.10.child", "-1, with incrementing optind",
                    getopt_long_spec==-1
                    && getopt_pre->optind==getopt_post->optind-1);

                return true;
            }

            if(getopt_long_11_pred(item, getopt_pre, optstring, longopts))
            {
                /*
                 * If getopt() encounters an option character that is
                 * not contained in optstring, it shall return the
                 * question-mark ( '?' ) character.
                 */
                /*
                 * A question mark ( '?' ) shall be returned if getopt()
                 *
                 * encounters an option character not in optstring
                 */
                REQ("getopt.11;getopt.18.01", "Unknown option",
                            getopt_long_spec==(IntT)'?');

                return true;
            }


            if(getopt_long_take_arg(item, getopt_pre, optstring, longopts,
                                                    argv, &variant, ps))
            {
                if(variant==-1)//simple option
                {
                    IntT ind=1;

                    if(getopt_pre->inner_index!=-1)
                        ind=getopt_pre->inner_index;

                    if(length_CString(item)==ind+1)
                    {
                    DUMP("Last");
                    /*
                     * If the option takes an argument, getopt() shall set the
                     * variable optarg to point to the option-argument as
                     * follows:
                     *
                     * If the option was the last character in the string
                     * pointed to by an element of argv, then optarg shall
                     * contain the next element of argv, and optind shall be
                     * incremented by 2.
                     */
                    REQ("getopt.08.01",
                        "If the option was the last character in the string "
                        "pointed to by an element of argv, then optarg shall "
                        "contain the next element of argv, and optind shall "
                        "be incremented by 2",
                        getopt_08_01_check(getopt_pre, getopt_post, argv, ps));
                    }
                    else
                    {
                    /*
                     * If the option takes an argument, getopt() shall set the
                     * variable optarg to point to the option-argument as
                     * follows:
                     *
                     * Otherwise, optarg shall point to the string following
                     * the option character in that element of argv, and optind
                     * shall be incremented by 1.
                     */
                    REQ("getopt.08.03",
                        "Otherwise, optarg shall point to the string "
                        "following the option character in that element of "
                        "argv, and optind shall be incremented by 1",
                        getopt_08_03_check(getopt_pre, getopt_post, argv));

                    }
                }
                else//long option
                {

                }
            }
        }

        if(getopt_post->optind>argc - ps->getOpt->permuted_elements)
        {
            /*
             * If the option takes an argument, getopt() shall set the
             * variable optarg to point to the option-argument as follows:
             *
             * If the resulting value of optind is greater than argc,
             * this indicates a missing option-argument, and getopt()
             * shall return an error indication.
             */
            REQ("getopt.08.02", "", TODO_REQ());

            /*
             * If it detects a missing option-argument, it shall
             * return the colon character ( ':' ) if the first
             * character of optstring was a colon, or a question-mark
             * character ( '?' ) otherwise.
             */
            REQ("getopt.12",
                "If it detects a missing option-argument",
                charAt_CString(optstring, 0)==':' ?
                        getopt_long_spec==(IntT)':'
                        : getopt_long_spec==(IntT)'?');

            if(charAt_CString(optstring, 0)==':')
            {
                /*
                 * A colon ( ':' ) shall be returned if getopt() detects a
                 * missing argument and the first character of optstring
                 * was a colon ( ':' ).
                 */
                REQ("getopt.17",
                    "If detects a missing argument",
                    getopt_long_spec==(IntT)':');
            }
            else
            {
                /*
                 * A question mark ( '?' ) shall be returned if getopt()
                 *
                 * detects a missing argument and the first character of
                 * optstring was not a colon
                 * ( ':' ).
                 */
                REQ("getopt.18.02",
                    "If detects a missing argument",
                    getopt_long_spec==(IntT)'?');
            }

            /*
             * In either case, getopt() shall set the variable optopt
             * to the option character that caused the error.
             */
            REQ("getopt.13",
                "In either case, getopt() shall set the variable optopt to "
                "the option character that caused the error",
                getopt_13_check(getopt_pre, getopt_post, argv, optstring));

            /*
             * If the application has not set the variable opterr to 0
             * and the first character of optstring is not a colon,
             * getopt() shall also print a diagnostic message to stderr
             * in the format specified for the getopts utility.
             */
            REQ("getopt.14", "", TODO_REQ());

            return true;
        }

        return true;
    }
}

void OnGetoptLong( CallContext context, IntT argc, List* argv,
                   CString* optstring, List* longopts,
                   IntT* longindex, IntT getopt_spec, GetoptRet* getopt_post)
{
    ProcessState* ps=getProcessState_CallContext(context);
    IntT ind=ps->getOpt->inner_index;
    IntT dd=0;

    DUMP("pre: dash-dash==%d\n", ps->getOpt->found_dashdash);

    if(ps->getOpt->optind!=getopt_post->optind)
    {
        ps->getOpt->inner_index=-1;
    }
    else
    {
        if(ind==-1)
            ps->getOpt->inner_index=2;
        else
            ps->getOpt->inner_index=ind+1;
    }

    if(getopt_post->optind<size_List(argv) - ps->getOpt->permuted_elements)
    if( equals(
            (CString*)get_List(argv, getopt_post->optind),
            create_CString("--")
            ))
            ps->getOpt->found_dashdash=1;

    ps->getOpt->optarg=clone(getopt_post->optarg);
    ps->getOpt->opterr=getopt_post->opterr;
    ps->getOpt->optind=getopt_post->optind;
    ps->getOpt->optopt=getopt_post->optopt;

    DUMP("ps->getOpt==$(obj)\n", ps->getOpt);

    DUMP("post: dash-dash==%d\n", ps->getOpt->found_dashdash);

    if( charAt_CString(optstring, 0)!='+' && charAt_CString(optstring, 0)!='-'
        &&
        get_Map(ps->environ, create_CString("POSIXLY_CORRECT"))==NULL)
    {
        //PERMUTE: we need permute argv so that all options
        //(and their arguments) are moved in front of all of the operands
        CString* tmp;
        Option* opt;
        IntT i=0, curr=1;

        while(curr<size_List(argv)-i)
        {
            tmp=clone((CString*)get_List(argv, curr));

            if(charAt_CString(tmp, 0)=='-')
            {
                if(length_CString(tmp)==2)
                {
                    ind=indexOfChar_CString(optstring, charAt_CString(tmp, 1));
                    if(ind!=-1 && length_CString(optstring)>ind+1)
                    {
                        if(charAt_CString(optstring, ind+1)==':')
                            curr+=2;
                        else//Option doesn't take an arg
                            curr++;
                    }
                    else//incorrect option, or option doesn't take an arg
                        curr++;

                }
                else
                {
                    if(charAt_CString(tmp, 1)!='-')
                        curr++;//may be multiple option, maybe incorrect option
                    else
                    {
                        //longopt
                        tmp=clone(substring_CString(tmp, 2,
                            indexOfChar_CString(tmp, '=')!=-1
                            &&
                            indexOfChar_CString(tmp, '=') < length_CString(tmp)
                            ?
                            indexOfChar_CString(tmp, '=')
                            :
                            length_CString(tmp)));

                        DUMP("tmp==$(obj)\n", tmp);
                        for(dd=0;dd<size_List(longopts);dd++)
                        {
                            opt=clone((Option*)get_List(longopts, dd));
                            if(equals(opt->name, tmp))
                            {
                                if(     opt->has_arg==0
                                    ||  opt->has_arg==2
                                        &&
                                        curr+i+1==size_List(argv)
                                    ||  opt->has_arg==1
                                        &&
                                        indexOfChar_CString(
                                            (CString*)
                                            get_List(argv, curr), '=')
                                            !=
                                            -1)
                                    curr++;
                                else
                                    curr+=2;

                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                remove_List(argv, curr);
                append_List(argv, tmp);
                curr++;
                i++;
            }
        }

        ps->getOpt->permuted_elements=i;
    }

    DUMP("argv==$(obj)\n", argv);
}


/*
Linux Standard Base Core Specification 3.1
Copyright __(c)__ 2004, 2005 Free Standards Group

  getopt_long_only

NAME

    getopt_long_only -- parse command line options

SYNOPSIS


    #define _GNU_SOURCE
    #include <getopt.h>

    int getopt_long_only(int argc, char * const argv[], const char * optstring,
        const struct option * longopts, int * longindex);

DESCRIPTION

    getopt_long_only() is like getopt_long(), but "-" as well as "--" can
    indicate a long option. If an option that starts with "-" (not "--")
    doesn't match a long option, but does match a short option, it is parsed
    as a short option instead.

    Note: The getopt_long_only() function is intended only for supporting
    certain programs whose command line syntax was designed before the
    Utility Syntax Guidelines of ISO POSIX (2003) were developed.
    New programs should generally call getopt_long() instead, which
    provides the --option syntax for long options, which is preferred by
    GNU and consistent with ISO POSIX (2003).

RETURN VALUE

    getopt_long_only() returns the option character if the option was found
    successfully, or ":" if there was a missing parameter for one of the
    options, or "?" for an unknown option character, or -1 for the end of
    the option list.

    getopt_long_only() also returns the option character when a short
    option is recognized. For a long option, they return val if flag is NULL,
    and 0 otherwise. Error and -1 returns are the same as for getopt(),
    plus "?" for an ambiguous match or an extraneous parameter.
*/

specification
IntT getopt_long_only_spec( CallContext context, IntT argc, List* argv,
                    CString* optstring, List* longopts, IntT* longindex)
{
    ProcessState* ps=getProcessState_CallContext(context);
    GetoptRet* getopt_pre=clone(ps->getOpt);

    if(getopt_pre==NULL)
        getopt_pre=create_emptyGetoptRet();

    pre
    {
        return true;
    }
    post
    {
        GetoptRet* getopt_post;
        CString* item;
        IntT variant;

        DUMP("post: getopt_pre==$(obj)\n", getopt_pre);

        ps=getProcessState_CallContext(context);

        if(ps==NULL)
            return false;
        if(ps->getOpt==NULL)
            return false;

        getopt_post=clone(ps->getOpt);

        DUMP("ret==%c, dash_dash==%d\n", getopt_long_only_spec,
            getopt_post->found_dashdash);

        //In fact LSB doesn't support all this POSIX Guidelines:)
        /*
         * The getopt() function is a command-line parser that shall
         * follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10
         * in the Base Definitions volume of IEEE Std  1003.1-2001,
         * Section 12.2, Utility Syntax Guidelines.
         */
        REQ("getopt.01", "", TODO_REQ());

        /*
         * The parameters argc and argv are the argument count and
         * argument array as passed to main() (see exec() ).
         */
        REQ("getopt.02", "", TODO_REQ());

        /*
         * The argument optstring is a string of recognized option
         * characters; if a character is followed by a colon, the
         * option takes an argument.
         */
        REQ("getopt.03", "", TODO_REQ());

        /*
         * All option characters allowed by Utility Syntax Guideline 3
         * are allowed in optstring. The implementation may accept
         * other characters as an extension.
         */
        REQ("getopt.04", "", TODO_REQ());

        /*
         * The variable optind is the index of the next element of
         * the argv[] vector to be processed. It shall be initialized
         * to 1 by the system, and getopt() shall update it when it
         * finishes with each element of argv[].
         */
        REQ("getopt.05", "", TODO_REQ());

        /*
         * When an element of argv[] contains multiple option
         * characters, it is unspecified how getopt() determines
         * which options have already been processed.
         */
        REQ("getopt.06", "", TODO_REQ());

        /*
         * The getopt() function shall return the next option
         * character (if one is found) from argv that matches
         * a character in optstring, if there is one that matches.
         */
        REQ("getopt.07", "", TODO_REQ());

        /*
         * The getopt() function need not be reentrant. A function
         * that is not required to be reentrant is not required
         * to be thread-safe.
         */
        REQ("getopt.15", "", TODO_REQ());

        /*
         * The getopt() function shall return the next option
         * character specified on the command line.
         */
        REQ("getopt.16", "", TODO_REQ());
        DUMP("getopt_post==$(obj), argc==%d\n", getopt_post, argc);

        {
            /*
             * getopt_long() works like getopt() except that it also
             * accepts long options, started out by two dashes.
             */
            REQ("getopt_long.01", "", TODO_REQ());

            /*
             * Long option names may be abbreviated if the abbreviation
             * is unique or is an exact match for some defined option.
             */
            REQ("getopt_long.02", "", TODO_REQ());

            /*
             * A long option may take a parameter, of the form
             * --arg=param or --arg param.
             */
            REQ("getopt_long.03", "", TODO_REQ());

            /*
             * longopts is a pointer to the first element of an array
             * of struct option declared in getopt.h as:
             *
             * struct option
             * {
             *      const char *name;
             *      int has_arg; int *flag; int val;
             * };
             */
            REQ("getopt_long.04", "", TODO_REQ());

            /*
             * The fields in this structure have the following meaning:
             *
             * name
             *
             *      The name of the long option.
             *
             * has_arg
             *
             * One of:
             *      no_argument (or 0) if the option does not take an argument,
             *
             *      required_argument (or 1) if the option requires an argument
             *
             *      optional_argument (or 2) if the option takes an optional
             *                                 argument.
             *
             * flag
             *
             *      specifies how results are returned for a long option.
             *      If flag is NULL, then getopt_long() shall return val.
             *      (For example, the calling program may set val to the
             *      equivalent short option character.) Otherwise,
             *      getopt_long() returns 0, and flag shall point to a variable
             *      which shall be set to val if the option is found, but left
             *      unchanged if the option is not found.
             *
             * val
             *
             *      The value to return, or to load into the variable pointed
             *      to by flag.
             */
            REQ("getopt_long.05", "", TODO_REQ());

            /*
             * getopt_long() returns the option character if a short
             * option was found successfully,
             */
            REQ("getopt_long.06", "", TODO_REQ());

            /*
             * or ":" if there was a missing parameter for one of the options,
             */
            REQ("getopt_long.07", "", TODO_REQ());

            /*
             * or "?" for an unknown option character,
             */
            REQ("getopt_long.08", "", TODO_REQ());

            /*
             * or -1 for the end of the option list.
             */
            REQ("getopt_long.09", "", TODO_REQ());

            /*
             * For a long option, getopt_long() returns val if flag is NULL,
             */
            REQ("getopt_long.10", "", TODO_REQ());

            /*
             * and 0 otherwise.
             */
            REQ("getopt_long.11", "", TODO_REQ());

            /*
             * Error and -1 returns are the same as for getopt(),
             * plus "?" for an ambiguous match or an extraneous parameter.
             */
            REQ("getopt_long.12", "", TODO_REQ());

        }
        {
            /*
             * getopt_long_only() is like getopt_long(), but "-"
             * as well as "--" can indicate a long option.
             */
            REQ("getopt_long_only.01", "", TODO_REQ());

            /*
             * If an option that starts with "-" (not "--") doesn't
             * match a long option, but does match a short option,
             * it is parsed as a short option instead.
             */
            REQ("getopt_long_only.02", "", TODO_REQ());

            /*
             * getopt_long_only() returns the option character if
             * the option was found successfully,
             */
            REQ("getopt_long_only.03", "", TODO_REQ());

            /*
             * or ":" if there was a missing parameter for one
             * of the options,
             */
            REQ("getopt_long_only.04", "", TODO_REQ());

            /*
             * or "?" for an unknown option character,
             */
            REQ("getopt_long_only.05", "", TODO_REQ());

            /*
             * or -1 for the end of the option list.
             */
            REQ("getopt_long_only.06", "", TODO_REQ());

            /*
             * getopt_long_only() also returns the option character
             * when a short option is recognized.
             */
            REQ("getopt_long_only.07", "", TODO_REQ());

            /*
             * For a long option, they return val if flag is NULL,
             */
            REQ("getopt_long_only.08", "", TODO_REQ());

            /*
             * and 0 otherwise
             */
            REQ("getopt_long_only.09", "", TODO_REQ());

            /*
             * Error and -1 returns are the same as for getopt(),
             * plus "?" for an ambiguous match or an extraneous parameter.
             */
            REQ("getopt_long_only.10", "", TODO_REQ());

        }

        if( getopt_pre->found_dashdash
            &&
            (   get_Map(ps->environ, create_CString("POSIXLY_CORRECT"))!=NULL
                ||
                charAt_CString(optstring, 0)=='+')  )
        {
            REQ("", "Implicit condition: after finding \"--\" getopt shall"
            "only iterate optind, returning -1", getopt_long_only_spec==-1);

            return true;
        }

        if(getopt_pre->optind==argc - ps->getOpt->permuted_elements)
        {
            /*
             * Otherwise, getopt() shall return -1 when all command
             * line options are parsed.
             */
            REQ("getopt.19",
                "Otherwise, getopt() shall return -1",
                getopt_long_only_spec==-1);

            return true;
        }

        if(getopt_pre->optind<argc - ps->getOpt->permuted_elements)
        {
            item=(CString*)get_List(argv, getopt_pre->optind);

            if(item==NULL   || equals(item, create_CString("-"))
                            || charAt_CString(item, 0)!='-')
            {
                DUMP("09: getopt_long_spec==%d\n",
                    getopt_long_spec);

                DUMP("09: getopt_pre==$(obj)\n", getopt_pre);
                DUMP("09: getopt_post==$(obj)\n", getopt_post);
                /*
                 * If, when getopt() is called:
                 *
                 *      argv[optind] is a null pointer
                 *      *argv[optind] is not the character -
                 *      argv[optind] points to the string "-"
                 *
                 * getopt() shall return -1 without changing optind.
                 */
                REQ("getopt.09.child", "-1, without changing optind",
                    getopt_long_only_spec==-1
                    && getopt_pre->optind==getopt_post->optind);

                return true;
            }

            if(equals(item, create_CString("--")))
            {
                /*
                 * If argv[optind] points to the string "--"
                 * getopt() shall return -1 after incrementing optind.
                 */
                REQ("getopt.10.child", "-1, with incrementing optind",
                    getopt_long_only_spec==-1
                    && getopt_pre->optind==getopt_post->optind-1);

                return true;
            }

            if(getopt_long_only_11_pred(item, getopt_pre, optstring, longopts))
            {
                /*
                 * If getopt() encounters an option character that is
                 * not contained in optstring, it shall return the
                 * question-mark ( '?' ) character.
                 */
                /*
                 * A question mark ( '?' ) shall be returned if getopt()
                 *
                 * encounters an option character not in optstring
                 */
                REQ("getopt.11;getopt.18.01", "Unknown option",
                            getopt_long_only_spec==(IntT)'?');

                return true;
            }


            if(getopt_long_only_take_arg(item, getopt_pre, optstring, longopts,
                                                argv, &variant, ps))
            {
                if(variant==-1)//simple option
                {
                    IntT ind=1;

                    if(getopt_pre->inner_index!=-1)
                        ind=getopt_pre->inner_index;

                    if(length_CString(item)==ind+1)
                    {
                    DUMP("Last");
                    /*
                     * If the option takes an argument, getopt() shall set the
                     * variable optarg to point to the option-argument as
                     * follows:
                     *
                     * If the option was the last character in the string
                     * pointed to by an element of argv, then optarg shall
                     * contain the next element of argv, and optind shall be
                     * incremented by 2.
                     */
                    REQ("getopt.08.01",
                        "If the option was the last character in the string "
                        "pointed to by an element of argv, then optarg shall "
                        "contain the next element of argv, and optind shall "
                        "be incremented by 2",
                        getopt_08_01_check(getopt_pre, getopt_post, argv, ps));
                    }
                    else
                    {
                    /*
                     * If the option takes an argument, getopt() shall set the
                     * variable optarg to point to the option-argument as
                     * follows:
                     *
                     * Otherwise, optarg shall point to the string following
                     * the option character in that element of argv, and optind
                     * shall be incremented by 1.
                     */
                    REQ("getopt.08.03",
                        "Otherwise, optarg shall point to the string "
                        "following the option character in that element of "
                        "argv, and optind shall be incremented by 1",
                        getopt_08_03_check(getopt_pre, getopt_post, argv));

                    }
                }
                else//long option
                {

                }
            }
        }

        if(getopt_post->optind>argc - ps->getOpt->permuted_elements)
        {
            /*
             * If the option takes an argument, getopt() shall set the
             * variable optarg to point to the option-argument as follows:
             *
             * If the resulting value of optind is greater than argc,
             * this indicates a missing option-argument, and getopt()
             * shall return an error indication.
             */
            REQ("getopt.08.02", "", TODO_REQ());

            /*
             * If it detects a missing option-argument, it shall
             * return the colon character ( ':' ) if the first
             * character of optstring was a colon, or a question-mark
             * character ( '?' ) otherwise.
             */
            REQ("getopt.12",
                "If it detects a missing option-argument",
                charAt_CString(optstring, 0)==':' ?
                        getopt_long_only_spec==(IntT)':'
                        : getopt_long_only_spec==(IntT)'?');

            if(charAt_CString(optstring, 0)==':')
            {
                /*
                 * A colon ( ':' ) shall be returned if getopt() detects a
                 * missing argument and the first character of optstring
                 * was a colon ( ':' ).
                 */
                REQ("getopt.17",
                    "If detects a missing argument",
                    getopt_long_only_spec==(IntT)':');
            }
            else
            {
                /*
                 * A question mark ( '?' ) shall be returned if getopt()
                 *
                 * detects a missing argument and the first character of
                 * optstring was not a colon
                 * ( ':' ).
                 */
                REQ("getopt.18.02",
                    "If detects a missing argument",
                    getopt_long_only_spec==(IntT)'?');
            }

            /*
             * In either case, getopt() shall set the variable optopt
             * to the option character that caused the error.
             */
            REQ("getopt.13",
                "In either case, getopt() shall set the variable optopt to "
                "the option character that caused the error",
                getopt_13_check(getopt_pre, getopt_post, argv, optstring));

            /*
             * If the application has not set the variable opterr to 0
             * and the first character of optstring is not a colon,
             * getopt() shall also print a diagnostic message to stderr
             * in the format specified for the getopts utility.
             */
            REQ("getopt.14", "", TODO_REQ());

            return true;
        }

        return true;
    }

}

void OnGetoptLongOnly( CallContext context, IntT argc, List* argv,
                   CString* optstring, List* longopts,
                   IntT* longindex, IntT getopt_spec, GetoptRet* getopt_post)
{
    ProcessState* ps=getProcessState_CallContext(context);
    IntT ind=ps->getOpt->inner_index;
    IntT dd=0;

    DUMP("pre: dash-dash==%d\n", ps->getOpt->found_dashdash);

    if(ps->getOpt->optind!=getopt_post->optind)
    {
        ps->getOpt->inner_index=-1;
    }
    else
    {
        if(ind==-1)
            ps->getOpt->inner_index=2;
        else
            ps->getOpt->inner_index=ind+1;
    }

    if(getopt_post->optind<size_List(argv) - ps->getOpt->permuted_elements)
    if( equals(
            (CString*)get_List(argv, getopt_post->optind),
            create_CString("--")
            ))
            ps->getOpt->found_dashdash=1;

    ps->getOpt->optarg=clone(getopt_post->optarg);
    ps->getOpt->opterr=getopt_post->opterr;
    ps->getOpt->optind=getopt_post->optind;
    ps->getOpt->optopt=getopt_post->optopt;

    DUMP("ps->getOpt==$(obj)\n", ps->getOpt);

    DUMP("post: dash-dash==%d\n", ps->getOpt->found_dashdash);

    if( charAt_CString(optstring, 0)!='+' && charAt_CString(optstring, 0)!='-'
        &&
        get_Map(ps->environ, create_CString("POSIXLY_CORRECT"))==NULL)
    {
        //PERMUTE: we need permute argv so that all options
        //(and their arguments) are moved in front of all of the operands
        CString* tmp;
        Option* opt;
        IntT i=0, curr=1;

        while(curr<size_List(argv)-i)
        {
            tmp=clone((CString*)get_List(argv, curr));

            if(charAt_CString(tmp, 0)=='-')
            {
                if(length_CString(tmp)==2)
                {
                    ind=indexOfChar_CString(optstring, charAt_CString(tmp, 1));
                    if(ind!=-1 && length_CString(optstring)>ind+1)
                    {
                        if(charAt_CString(optstring, ind+1)==':')
                            curr+=2;
                        else//Option doesn't take an arg
                            curr++;
                    }
                    else//incorrect option, or option doesn't take an arg
                        curr++;

                }
                else
                {
                    if(charAt_CString(tmp, 1)!='-')
                    {
                        //longopt
                        tmp=clone(substring_CString(tmp, 1,
                            indexOfChar_CString(tmp, '=')!=-1
                            &&
                            indexOfChar_CString(tmp, '=') < length_CString(tmp)
                            ?
                            indexOfChar_CString(tmp, '=')
                            :
                            length_CString(tmp)));

                        DUMP("tmp==$(obj)\n", tmp);
                        for(dd=0;dd<size_List(longopts);dd++)
                        {
                            opt=clone((Option*)get_List(longopts, dd));
                            if(equals(opt->name, tmp))
                            {
                                if(     opt->has_arg==0
                                    ||  opt->has_arg==2
                                        &&
                                        curr+i+1==size_List(argv)
                                    ||  opt->has_arg==1
                                        &&
                                        indexOfChar_CString(
                                        (CString*)
                                        get_List(argv, curr), '=')
                                        !=
                                        -1)
                                    curr++;
                                else
                                    curr+=2;

                                break;
                            }
                        }

                        if(dd!=size_List(longopts))
                        //may be multiple option, maybe incorrect option
                            curr++;
                    }
                    else
                    {
                        //longopt
                        tmp=clone(substring_CString(tmp, 2,
                            indexOfChar_CString(tmp, '=')!=-1
                            &&
                            indexOfChar_CString(tmp, '=') < length_CString(tmp)
                            ?
                            indexOfChar_CString(tmp, '=')
                            :
                            length_CString(tmp)));

                        DUMP("tmp==$(obj)\n", tmp);
                        for(dd=0;dd<size_List(longopts);dd++)
                        {
                            opt=clone((Option*)get_List(longopts, dd));
                            if(equals(opt->name, tmp))
                            {
                                if(     opt->has_arg==0
                                    ||  opt->has_arg==2
                                        &&
                                        curr+i+1==size_List(argv)
                                    ||  opt->has_arg==1
                                        &&
                                        indexOfChar_CString(
                                        (CString*)
                                        get_List(argv, curr), '=')
                                        !=
                                        -1)
                                    curr++;
                                else
                                    curr+=2;

                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                remove_List(argv, curr);
                append_List(argv, tmp);
                curr++;
                i++;
            }
        }

        ps->getOpt->permuted_elements=i;
    }

    DUMP("argv==$(obj)\n", argv);
}

/*
Linux Standard Base Core Specification 3.0
Copyright __(c)__ 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright __(c)__ 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getsubopt - parse suboption arguments from a string

SYNOPSIS

    [XSI] #include <stdlib.h>

    int getsubopt(char **optionp, char * const *keylistp, char **valuep);

DESCRIPTION

    The getsubopt() function shall parse suboption arguments in a flag argument.
    Such options often result from the use of getopt().

    The getsubopt() argument optionp is a pointer to a pointer to the option
    argument string. The suboption arguments shall be separated by commas and
    each may consist of either a single token, or a token-value pair separated
    by an equal sign.

    The keylistp argument shall be a pointer to a vector of strings. The end of
    the vector is identified by a null pointer. Each entry in the vector is one
    of the possible tokens that might be found in *optionp. Since commas
    delimit suboption arguments in optionp, they should not appear in any of
    the strings pointed to by keylistp. Similarly, because an equal sign
    separates a token from its value, the application should not include an
    equal sign in any of the strings pointed to by keylistp.

    The valuep argument is the address of a value string pointer.

    If a comma appears in optionp, it shall be interpreted as a suboption
    separator. After commas have been processed, if there are one or more equal
    signs in a suboption string, the first equal sign in any suboption string
    shall be interpreted as a separator between a token and a value. Subsequent
    equal signs in a suboption string shall be interpreted as part of the value.

    If the string at *optionp contains only one suboption argument
    (equivalently, no commas), getsubopt() shall update *optionp to point to
    the null character at the end of the string. Otherwise, it shall isolate
    the suboption argument by replacing the comma separator with a null
    character, and shall update * optionp to point to the start of the next
    suboption argument. If the suboption argument has an associated value
    (equivalently, contains an equal sign), getsubopt() shall update *valuep to
    point to the value's first character. Otherwise, it shall set *valuep to a
    null pointer. The calling application may use this information to determine
    whether the presence or absence of a value for the suboption is an error.

    Additionally, when getsubopt() fails to match the suboption argument with a
    token in the keylistp array, the calling application should decide if this
    is an error, or if the unrecognized option should be processed in another
    way.

RETURN VALUE

    The getsubopt() function shall return the index of the matched token
    string, or -1 if no token strings were matched.

ERRORS

    No errors are defined.
*/

specification
IntT getsubopt_spec( CallContext context, StringTPtr* optionp, List* keylistp,
                        StringTPtr *valuep)
{
    StringTPtr optionp_pre=*optionp;
    CString* optionp_pre_str=readCString_VoidTPtr(optionp_pre);

    pre
    {
        /*
         * Since commas delimit suboption arguments in optionp, they
         * should not appear in any of the strings pointed to by keylistp.
         */
        /*
         * Similarly, because an equal sign separates a token from
         * its value, the application should not include an equal
         * sign in any of the strings pointed to by keylistp.
         */
        REQ("getsubopt.07;getsubopt.08",
            "No commas and equal signs in keylistp",
            NoCommasAndEqualSigns(keylistp));

        return true;
    }
    post
    {
        CString* tmp;
        CString* optionp_str=readCString_VoidTPtr(*optionp);
        IntT offset=indexOfChar_CString(optionp_pre_str, ','), offset2=-1, i;
        MemoryBlock* mb=getMemoryBlock(*optionp);
        CByteArray* arr=readCByteArray_MemoryBlock(mb);
        IntT validArg;

        /*
         * The getsubopt() function shall parse suboption arguments in a
         * flag argument.
         */
        REQ("getsubopt.01", "", TODO_REQ());

        /*
         * The getsubopt() argument optionp is a pointer to a pointer
         * to the option argument string.
         */
        REQ("getsubopt.02", "", TODO_REQ());

        /*
         * The suboption arguments shall be separated by commas and
         * each may consist of either a single token, or a token-value
         * pair separated by an equal sign.
         */
        REQ("getsubopt.03", "", TODO_REQ());

        /*
         * The keylistp argument shall be a pointer to a vector of strings.
         */
        REQ("getsubopt.04", "", TODO_REQ());

        /*
         * The end of the vector is identified by a null pointer.
         */
        REQ("getsubopt.05", "", TODO_REQ());

        /*
         * Each entry in the vector is one of the possible tokens
         * that might be found in * optionp.
         */
        REQ("getsubopt.06", "", TODO_REQ());


        /*
         * The valuep argument is the address of a value
         * string pointer.
         */
        REQ("getsubopt.09", "", TODO_REQ());

        /*
         * If a comma appears in optionp, it shall be interpreted as
         * a suboption separator.
         */
        REQ("getsubopt.10", "", TODO_REQ());

        /*
         * After commas have been processed, if there are one or
         * more equal signs in a suboption string, the first equal
         * sign in any suboption string shall be interpreted as a
         * separator between a token and a value.
         */
        REQ("getsubopt.11", "", TODO_REQ());

        /*
         * Subsequent equal signs in a suboption string shall be
         * interpreted as part of the value.
         */
        REQ("getsubopt.12", "", TODO_REQ());

        validArg=argumentValid(optionp_pre_str, keylistp);

        if(offset==-1)
        {
            DUMP("optionp->address==%d\n", (IntT)optionp->address);
            DUMP("optionp_pre.address==%d\n", (IntT)optionp_pre.address);
            DUMP("length_CString(optionp_pre_str)==%d\n",
                    (IntT)length_CString(optionp_pre_str));

            /*
             * If the string at *optionp contains only one suboption
             * argument (equivalently, no commas), getsubopt() shall
             * update *optionp to point to the null character
             * at the end of the string.
             */
            REQ("getsubopt.13",
                "If the string at *optionp contains only one suboption arg",
                optionp->address ==
                    optionp_pre.address + length_CString(optionp_pre_str));

            offset2=indexOfChar_CString(optionp_pre_str, '=');

            if(offset2!=-1)
            {
                DUMP("Case1: %d, validarg==%d\n",
                    getPosixGetoptValuepChangingInterpretation()
                    ==POSIX_GETSUBOPT_VALUEP_POSIX, validArg);
                if(getPosixGetoptValuepChangingInterpretation()
                    ==POSIX_GETSUBOPT_VALUEP_POSIX || validArg!=-1)
                {
                    DUMP("valuep->address==%d\n", (IntT)valuep->address);
                    DUMP("optionp_pre.address==%d\n",
                        (IntT)optionp_pre.address);
                    DUMP("offset2==%d\n", (IntT)offset2);
                    /*
                     * If the suboption argument has an associated value
                     * (equivalently, contains an equal sign), getsubopt()
                     * shall update *valuep to point to the value's first
                     * character.
                     */
                    REQ("getsubopt.15",
                        "If the suboption argument has an associated value "
                        "(equivalently, contains an equal sign), getsubopt() "
                        "shall update *valuep to point to the value's first  "
                        "character",
                        valuep->address ==
                        optionp_pre.address + offset2+1);
                }
                else
                {
                    REQ("", "Implementation behavior",
                        valuep->address == optionp_pre.address);
                }
            }
            else
            {
                if(getPosixGetoptValuepChangingInterpretation()
                    ==POSIX_GETSUBOPT_VALUEP_POSIX || validArg!=-1)
                {
                    DUMP("valuep==%d\n", valuep->address);
                    /*
                     * Otherwise, it shall set *valuep to a null pointer.
                     */
                    REQ("getsubopt.16",
                        "Otherwise, it shall set *valuep to a null pointer",
                        isNULL_VoidTPtr(*valuep));
                }
                else
                {
                    REQ("", "Implementation behavior",
                        valuep->address == optionp_pre.address);
                }
            }
        }
        else
        {
            DUMP("optionp->address==%d\n", (IntT)optionp->address);
            DUMP("optionp_pre.address==%d\n", (IntT)optionp_pre.address);
            DUMP("length_CString(optionp_pre_str)==%d\n",
                (IntT)length_CString(optionp_pre_str));
            DUMP("mb->address.address==%d\n", (IntT)mb->address.address);
            DUMP("byteAt_CByteArray(arr, optionp_pre.address + offset -"
                " mb->address.address)==%d\n",
                byteAt_CByteArray(arr, optionp_pre.address + offset -
                        mb->address.address));
            /*
             * Otherwise, it shall isolate the suboption argument by
             * replacing the comma separator with a null character,
             * and shall update *optionp to point to the
             * start of the next suboption argument.
             */
            REQ("getsubopt.14",
                "Otherwise, it shall isolate the suboption argument",
                optionp->address ==
                    optionp_pre.address + offset+1
                && byteAt_CByteArray(arr, optionp_pre.address + offset -
                                mb->address.address)==0);

            if(indexOfChar_CString(optionp_pre_str, '=')<offset)
            {
                offset2=indexOfChar_CString(optionp_pre_str, '=');

                if(getPosixGetoptValuepChangingInterpretation()
                    ==POSIX_GETSUBOPT_VALUEP_POSIX || validArg!=-1)
                {
                    DUMP("valuep->address==%d\n", (IntT)valuep->address);
                    DUMP("optionp_pre.address==%d\n",
                        (IntT)optionp_pre.address);
                    DUMP("offset2==%d\n", (IntT)offset2);
                    /*
                     * If the suboption argument has an associated value
                     * (equivalently, contains an equal sign), getsubopt()
                     * shall update *valuep to point to the value's first
                     * character.
                     */
                    REQ("getsubopt.15",
                        "If the suboption argument has an associated value "
                        "(equivalently, contains an equal sign), getsubopt() "
                        "shall update *valuep to point to the value's first "
                        "character.",
                        valuep->address ==
                        optionp_pre.address + offset2+1);
                }
                else
                {
                    REQ("", "Implementation behavior",
                        valuep->address == optionp_pre.address);
                }
            }
            else
            {
                if(getPosixGetoptValuepChangingInterpretation()
                    ==POSIX_GETSUBOPT_VALUEP_POSIX || validArg!=-1)
                {
                    DUMP("valuep==%d\n", valuep->address);
                    /*
                     * Otherwise, it shall set *valuep to a null pointer.
                     */
                    REQ("getsubopt.16",
                        "Otherwise, it shall set *valuep to a null pointer. ",
                        isNULL_VoidTPtr(*valuep));
                }
                else
                {
                    REQ("", "Implementation behavior",
                        valuep->address == optionp_pre.address);
                }
            }

        }

        /*
         * The calling application may use this information to
         * determine whether the presence or absence of a value
         * for the suboption is an error.
         */
        REQ("getsubopt.17", "", TODO_REQ());

        /*
         * Additionally, when getsubopt() fails to match the
         * suboption argument with a token in the keylistp array,
         * the calling application should decide if this is
         * an error, or if the unrecognized option should be
         * processed in another way.
         */
        REQ("getsubopt.18", "", TODO_REQ());

        /*
         * The getsubopt() function shall return the index of
         * the matched token string,
         */
        /*
         * or -1 if no token strings were matched.
         */
        REQ("getsubopt.19;getsubopt.20",
            "Shall return index of matched token string "
            "or -1 if no token strings were matched",
            getsubopt_spec==validArg);

        return true;
    }
}



/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
IntT argumentValid(CString* optionp_pre_str, List* keylistp)
{
    IntT    offset=indexOfChar_CString(optionp_pre_str, ','),
            offset2=indexOfChar_CString(optionp_pre_str, '='), i;
    CString* tmp=clone(optionp_pre_str);

    if(offset2>offset && offset!=-1)
        offset2=-1;

    offset= offset==-1 ? length_CString(optionp_pre_str) : offset;
    offset2= offset2==-1 ? length_CString(optionp_pre_str) : offset2;

    tmp=substring_CString(tmp, 0,
        offset < offset2 ? offset : offset2);

    DUMP("Option==$(obj), offset==%d, offset2==%d\n", tmp, offset, offset2);
    for(i=0;i<size_List(keylistp);i++)
        if(equals((CString*)get_List(keylistp, i), tmp))
            break;

    return i==size_List(keylistp) ? -1 : i;
}
Option* create_Option( CString *name, IntT has_arg, IntT flag, bool flag_null,
                      IntT val)
{
    return create(&type_Option, name, has_arg, flag, flag_null, val);
}

bool getopt_11_pred(CString* item, GetoptRet* getopt_pre, CString* optstring)
{
    if(getopt_pre->inner_index==-1)
        return indexOfChar_CString(optstring, charAt_CString(item, 1))==-1;

    return indexOfChar_CString(optstring,
                charAt_CString(item, getopt_pre->inner_index))==-1;
}
bool getopt_take_arg(CString* item, GetoptRet* getopt_pre, CString* optstring)
{
    IntT ind;
    IntT i2=1;

    if(getopt_pre->inner_index!=-1)
        i2=getopt_pre->inner_index;

    ind=indexOfChar_CString(optstring, charAt_CString(item, i2));

    if(ind!=-1 && length_CString(optstring)>ind+1)
        return charAt_CString(optstring, ind+1)==':';

    return false;
}
bool getopt_08_03_check(GetoptRet* getopt_pre, GetoptRet* getopt_post,
                        List* argv)
{
    CString* tmp;
    IntT ind=1;

    DUMP("\n08.03:\ngetopt_pre==$(obj)\ngetopt_post==$(obj)\nargv==$(obj)\n\n",
        getopt_pre, getopt_post, argv);
    if(getopt_pre->inner_index!=-1)
        ind=getopt_pre->inner_index;

    tmp=(CString*)get_List(argv, getopt_pre->optind);
    tmp=substring_CString(tmp, ind+1, length_CString(tmp));

    return  equals(getopt_post->optarg, tmp)
            &&
            getopt_pre->optind+1==getopt_post->optind;
}
bool getopt_08_01_check(GetoptRet* getopt_pre, GetoptRet* getopt_post,
                        List* argv, ProcessState* ps)
{
    DUMP("\n08.01:\ngetopt_pre==$(obj)\ngetopt_post==$(obj)\nargv==$(obj)\n\n",
        getopt_pre, getopt_post, argv);
    if(getopt_pre->optind+2 > size_List(argv))
        return true;

    if(getopt_pre->optind+2!=getopt_post->optind)
        return false;

    if(getopt_pre->optind+1<size_List(argv)-ps->getOpt->permuted_elements)
    {
        return  equals(getopt_post->optarg,
            (CString*)get_List(argv, getopt_pre->optind+1));
    }

    return true;
}
bool getopt_13_check(GetoptRet* getopt_pre, GetoptRet* getopt_post, List* argv,
                     CString* optstring)
{
    CharT opt;
    IntT ind=1;

    if(getopt_pre->inner_index!=-1)
        ind=getopt_pre->inner_index;

    opt=charAt_CString((CString*)get_List(argv, getopt_pre->optind), ind);

    if( (ind = indexOfChar_CString( optstring,  opt )) !=-1)
        if(ind<length_CString(optstring)-1
            && charAt_CString(optstring, ind+1)==':')
            return getopt_post->optopt==opt;

    return true;
}
bool getopt_long_11_pred(CString* item, GetoptRet* getopt_pre,
                         CString* optstring, List* longopts)
{
    if(     charAt_CString(item, 0)=='-'
        &&  charAt_CString(item, 1)=='-')
    {
        CString* tmp=substring_CString(item, 2,
            indexOfChar_CString(item, '=')==-1 ?
                    length_CString(item) : indexOfChar_CString(item, '='));
        IntT i;
        Option* opt;

        DUMP("Long option...tmp==$(obj)\n", tmp);

        for(i=0;i<size_List(longopts);i++)
        {
            opt=(Option*)get_List(longopts, i);
            if(equals(opt->name, tmp))
                return false;
        }

        return true;
    }

    if(getopt_pre->inner_index==-1)
        return indexOfChar_CString(optstring, charAt_CString(item, 1))==-1;

    return indexOfChar_CString(optstring,
                charAt_CString(item, getopt_pre->inner_index))==-1;
}
bool getopt_long_only_11_pred(CString* item, GetoptRet* getopt_pre,
                         CString* optstring, List* longopts)
{
    CString* tmp=substring_CString(item, charAt_CString(item, 1)=='-' ? 2 : 1,
        indexOfChar_CString(item, '=')==-1 ?
                length_CString(item) : indexOfChar_CString(item, '='));
    IntT i;
    Option* opt;

    DUMP("Long option...tmp==$(obj)\n", tmp);

    for(i=0;i<size_List(longopts);i++)
    {
        opt=(Option*)get_List(longopts, i);
        if(equals(opt->name, tmp))
            return false;
    }

    if(charAt_CString(item, 1)=='-')
        //It seems to be a long option, but isn't contained in longopts
        return true;

    if(getopt_pre->inner_index==-1)
        return indexOfChar_CString(optstring, charAt_CString(item, 1))==-1;

    return indexOfChar_CString(optstring,
                charAt_CString(item, getopt_pre->inner_index))==-1;
}
bool getopt_long_take_arg(CString* item, GetoptRet* getopt_pre,
                CString* optstring, List* longopts, List* argv, IntT* variant,
                ProcessState* ps)
{
    IntT ind;
    IntT i2=1;

    *variant=-1;

    if( charAt_CString(item, 0)=='-'
        &&
        charAt_CString(item, 1)=='-')
    {
        CString* tmp=substring_CString(item, 2,
            indexOfChar_CString(item, '=')==-1 ?
                    length_CString(item) : indexOfChar_CString(item, '='));
        IntT i;
        Option* opt;

        *variant=-2;
        for(i=0;i<size_List(longopts);i++)
        {
            opt=(Option*)get_List(longopts, i);
            if(equals(opt->name, tmp))
            {
                *variant=opt->has_arg;
                /*if(opt->has_arg==0)
                    return false;
                *variant=1;
                if(opt->has_arg==1)
                    return true;
                *variant=2;
                if(getopt_pre->optind+1>=size_List(argv) -
                            ps->getOpt->permuted_elements)
                    return false;
                *variant=3;
                return  charAt_CString((CString*)get_List(argv,
                            getopt_pre->optind+1), 0)!='-';*/
                return *variant!=0;
            }
        }

        return false;
    }

    if(getopt_pre->inner_index!=-1)
        i2=getopt_pre->inner_index;

    ind=indexOfChar_CString(optstring, charAt_CString(item, i2));

    if(ind!=-1 && length_CString(optstring)>ind+1)
        return charAt_CString(optstring, ind+1)==':';

    return false;
}
bool getopt_long_only_take_arg(CString* item, GetoptRet* getopt_pre,
              CString* optstring, List* longopts, List* argv, IntT* variant,
              ProcessState* ps)
{
    IntT ind;
    IntT i2=1;

    *variant=-1;

    {
        CString* tmp=substring_CString(item,
            charAt_CString(item, 1)=='-' ? 2 : 1,
            indexOfChar_CString(item, '=')==-1 ?
                    length_CString(item) : indexOfChar_CString(item, '='));
        IntT i;
        Option* opt;

        *variant=-2;
        for(i=0;i<size_List(longopts);i++)
        {
            opt=(Option*)get_List(longopts, i);
            if(equals(opt->name, tmp))
            {
                *variant=opt->has_arg+(charAt_CString(item, 1)!='-' ? 10 : 0);
                /*if(opt->has_arg==0)
                    return false;
                *variant=1;
                if(opt->has_arg==1)
                    return true;
                *variant=2;
                if(getopt_pre->optind+1>=size_List(argv) -
                ps->getOpt->permuted_elements)
                    return false;
                *variant=3;
                return  charAt_CString((CString*)get_List(argv,
                getopt_pre->optind+1), 0)!='-';*/
                return *variant!=0;
            }
        }

        return false;
    }

    if(getopt_pre->inner_index!=-1)
        i2=getopt_pre->inner_index;

    ind=indexOfChar_CString(optstring, charAt_CString(item, i2));

    if(ind!=-1 && length_CString(optstring)>ind+1)
        return charAt_CString(optstring, ind+1)==':';

    return false;
}

bool NoCommasAndEqualSigns(List* keylistp)
{
    IntT i;
    CString* comma=create_CString(",");
    CString* equal_sign=create_CString("=");
    CString* tmp;

    for(i=0;i<size_List(keylistp);i++)
    {
        tmp=(CString*)get_List(keylistp, i);
        if(equals(tmp, comma) || equals(tmp, equal_sign))
            return false;
    }

    return true;
}
