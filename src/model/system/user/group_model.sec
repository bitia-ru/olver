/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */




#include "system/user/group_config.h"
#include "system/user/group_model.seh"
#include "atl/integer.h"

#pragma SEC subsystem user "system.user"

/*
   The group of functions 'system.user.group' consists of:
       endgrent [1]
       getgrent [1]
       getgrgid [1]
       getgrgid_r [1]
       getgrnam [1]
       getgrnam_r [1]
       getgrouplist [2]
       setgrent [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.


NAME

    endgrent, getgrent, setgrent - group database entry functions

SYNOPSIS

    #include <grp.h>
    void endgrent(void);
    struct group *getgrent(void);
    void setgrent(void);


DESCRIPTION

    The getgrent() function shall return a pointer to a structure containing
    the broken-out fields of an entry in the group database. When first called,
    getgrent() shall return a pointer to a group structure containing the first
    entry in the group database. Thereafter, it shall return a pointer to a
    group structure containing the next group structure in the group database,
    so successive calls may be used to search the entire database.

    An implementation that provides extended security controls may impose
    further implementation-defined restrictions on accessing the group
    database. In particular, the system may deny the existence of some or all
    of the group database entries associated with groups other than those
    groups associated with the caller and may omit users other than the caller
    from the list of members of groups in database entries that are returned.

    The setgrent() function shall rewind the group database to allow repeated
    searches.

    The endgrent() function may be called to close the group database when
    processing is complete.

    These functions need not be reentrant. A function that is not required to
    be reentrant is not required to be thread-safe.

RETURN VALUE

    When first called, getgrent() shall return a pointer to the first group
    structure in the group database. Upon subsequent calls it shall return the
    next group structure in the group database. The getgrent() function shall
    return a null pointer on end-of-file or an error and errno may be set to
    indicate the error.

    The return value may point to a static area which is overwritten by a
    subsequent call to getgrgid(), getgrnam(), or getgrent().

ERRORS

    The getgrent() function may fail if:

    [EINTR]
        A signal was caught during the operation.

    [EIO]
        An I/O error has occurred.

    [EMFILE]
        {OPEN_MAX} file descriptors are currently open in the calling process.

    [ENFILE]
        The maximum allowable number of files is currently open in the system.
*/

specification
void endgrent_spec( CallContext context, ErrorCode* errno, CancelStatus status)
{
  SystemState* curState=NULL;
  Set*  groupsSet=NULL;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
      /* [Consistency of test suite] */
      REQ("", "Set with user groups shall not be NULL",groupsSet!=NULL);

      *errno=SUT_EOK;

      return true;
  }
  coverage C
  {
      if(curState->isGroupsSetValid==true)
      {
          return { RedCalls, "Reduandant calls of endgrent" };
      }
      else /* if(curState->isGroupsSetValid==false) */
      {
          return { OkCalls, "Not reduandant calls of endgrent" };
      }
  }
  CANCELPOINT_COVERAGE(context)
  post
  {
    CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

    /*
    * The endgrent() function may be called to close the group database when
    * processing is complete.
    */
    IMPLEMENT_REQ("endgrent.01");


    if (*errno == SUT_EOK)
    {
        /* [Implicit postcondition] */
        REQ("", "Set shall be valid", isValidGroupsSet(groupsSet));
    }

    return true;
  }
}

specification
UsersGroup* getgrent_spec(CallContext context, ErrorCode* errno,
                          CancelStatus status)
{
  SystemState* curState=NULL;
  Set*  groupsSet=NULL;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
      /* [Consistency of test suite] */
      REQ("", "Set with user groups shall not be NULL", groupsSet!=NULL);

      *errno=SUT_EOK;

      return true;
  }
  coverage C
  {
      if(curState->isGroupsSetValid==true)
      {
          return { FirstCalls, "First calls of getgrent" };
      }
      else /* if(curState->isGroupsSetValid==false) */
      {
          return { SuccessiveCalls, "Successive calls of getgrent" };
      }
  }
  CANCELPOINT_COVERAGE(context)
  post
  {
    CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

    /*
    * The getgrent() function shall return a null pointer on
    * end-of-file or an error and errno may be set to indicate the error.
    */
    ERROR_BEGIN(POSIX_GETGRENT, "getgrent.04", *errno != SUT_EOK, *errno)
    /*
     * The getgrent() function may fail if:
     *
     * [EINTR]
     *
     * A signal was caught during the operation.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRENT, EINTR, "getgrent.05.01",
        "Can not test signals")

    /*
     * The getgrent() function may fail if:
     *
     * [EIO]
     *
     * An I/O error has occurred.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRENT, EIO,"getgrent.05.02",
        "Can not reach this condition")

    /*
     * The getgrent() function may fail if:
     *
     * [EMFILE]
     *
     * {OPEN_MAX} file descriptors are currently open in the calling process.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRENT, EMFILE,"getgrent.05.03",
        "Can not reach this condition")

    /*
     * The getgrent() function may fail if:
     *
     * [ENFILE]
     *
     * The maximum allowable number of files is currently open in the system.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRENT, ENFILE,"getgrent.05.04",
        "Can not reach this condition")

    ERROR_END()


    if(getgrent_spec != NULL)
    {
        /* [Implicit postcondition] */
        REQ("", "Set shall be valid", isValidGroupsSet(groupsSet));
    }
    else
    {

        /*
            Linux Standard Base Core Specification 3.1
            Copyright (c) 2004, 2005 Free Standards Group

            21.2. User & Group Names

            User    Group    Comments

            root    root    Administrative user with all appropriate privileges
            bin        bin        Legacy User ID/Group ID[a]
            daemon    daemon    Legacy User ID/Group ID[b]

            Notes:
                a. The bin User ID/Group ID is included for compatibility with
                legacy applications. New applications should no longer use the
                bin User ID/Group ID.
                b. The daemon User ID/Group ID was used as an unprivileged User
                ID/Group ID for daemons to execute under in order to limit
                their access to the system. Generally daemons should now run
                under individual User ID/Group IDs in order to further
                partition daemons from one another.
        */
        REQ("", "Required groups: root, bin, daemon shall exist",
            isRequiredGroupsExist(groupsSet));
    }
    return true;
  }
}



specification
void setgrent_spec( CallContext context, ErrorCode* errno, CancelStatus status)
{
  SystemState* curState=NULL;
  Set*  groupsSet=NULL;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
    /* [Consistency of test suite] */
    REQ("", "Set with user groups shall not be NULL",groupsSet!=NULL);

    *errno=SUT_EOK;

    return true;
  }
  coverage C
  {
      if(curState->isGroupsSetValid==true)
      {
          return { RedCalls, "Reduandant calls of setgrent" };
      }
      else /* if(curState->isGroupsSetValid==false) */
      {
          return { OkCalls, "Not reduandant calls of setgrent" };
      }
  }
  CANCELPOINT_COVERAGE(context)
  post
  {
    CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

    if (*errno == SUT_EOK)
    {
        if(curState->isGroupsSetValid==false)
        {
            /*
            * The setgrent() function shall rewind the group database to allow
            * repeated searches.
            */
            REQ("setgrent.01", "Set shall be zero size",
              size_Set(groupsSet)==0);
        }
    }
    return true;
  }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getgrgid, getgrgid_r - get group database entry for a group ID

SYNOPSIS

    #include <grp.h>
    struct group *getgrgid(gid_t gid);
    int getgrgid_r(gid_t gid, struct group *grp, char *buffer,
       size_t bufsize, struct group **result);


DESCRIPTION

    The getgrgid() function shall search the group database for an entry with
    a matching gid.

    The getgrgid() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

    The getgrgid_r() function shall update the group structure pointed to by
    grp and store a pointer to that structure at the location pointed to by
    result. The structure shall contain an entry from the group database with
    a matching gid. Storage referenced by the group structure is allocated from
    the memory provided with the buffer parameter, which is bufsize bytes in
    size. The maximum size needed for this buffer can be determined with the
    {_SC_GETGR_R_SIZE_MAX} sysconf() parameter. A NULL pointer shall be
    returned at the location pointed to by result on error or if the requested
    entry is not found.

RETURN VALUE

    Upon successful completion, getgrgid() shall return a pointer to a struct
    group with the structure defined in <grp.h> with a matching entry if one
    is found. The getgrgid() function shall return a null pointer if either the
    requested entry was not found, or an error occurred. On error, errno shall
    be set to indicate the error.

    The return value may point to a static area which is overwritten by a
    subsequent call to getgrent(), getgrgid(), or getgrnam().

    If successful, the getgrgid_r() function shall return zero; otherwise, an
    error number shall be returned to indicate the error.

ERRORS

    The getgrgid() and getgrgid_r() functions may fail if:

        [EIO]
            An I/O error has occurred.

        [EINTR]
            A signal was caught during getgrgid().

        [EMFILE]
            {OPEN_MAX} file descriptors are currently open in the calling
            process.

        [ENFILE]
            The maximum allowable number of files is currently open in the
            system.

        The getgrgid_r() function may fail if:

        [ERANGE]
            Insufficient storage was supplied via buffer and bufsize to contain
            the data to be referenced by the resulting group structure.

*/

specification
UsersGroup* getgrgid_spec(CallContext context, GidT gid, ErrorCode* errno,
                          CancelStatus status)
{
  SystemState* curState=NULL;
  Set*         groupsSet=NULL;
  UsersGroup*   res;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
    /* [Consistency of test suite] */
    REQ("", "Set with user groups shall not be NULL", groupsSet!=NULL);

    if(curState->isGroupsSetFilled)
         res=getgrgid_model(groupsSet, gid);

    *errno=SUT_EOK;

    return true;
  }
  coverage C
  {
      if(curState->isGroupsSetFilled==true)
      {
          if(res!=NULL)
            return { SetFilledConatains,
                "Set with user groups was filled and contains item" };
          else
            return { SetFilledNotConatains,
                "Set with user groups was filled and does not contain item" };
      }
      else /* if(curState->isGroupsSetFilled==false) */
      {
          return { SetNotFilled, "Set with users info was not filled" };
      }
  }
  CANCELPOINT_COVERAGE(context)
  post
  {
    CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

    /*
    * or an error occurred.
    */
    ERROR_BEGIN(POSIX_GETGRGID, "getgrgid.04.02", *errno!=SUT_EOK, *errno)
    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [EIO]
    *
    * An I/O error has occurred.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID, EIO,"getgrgid.10.01",
        "Can not reach this condition")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [EINTR]
    *
    * A signal was caught during getgrgid().
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID, EINTR,"getgrgid.10.02",
        "Can not reach this condition")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [EMFILE]
    *
    * {OPEN_MAX} file descriptors are currently open in the calling process.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID, EMFILE,"getgrgid.10.03",
        "Can not reach this condition")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [ENFILE]
    *
    * The maximum allowable number of files is currently open in the system.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID, ENFILE,"getgrgid.10.04",
        "Can not reach this condition")

    ERROR_END()

    if(curState->isGroupsSetFilled)
    {
          /*
          * The getgrgid() function shall search the group database for an
          * entry with a matching gid.
          */
          IMPLEMENT_REQ("getgrgid.01");

          if(res==NULL)
          {
              /* The getgrgid() function shall return a null pointer if
                 either the requested entry was not found */
              REQ("getgrgid.04.01", "getgrgid shall return NULL",
                getgrgid_spec==res);
          }
          else
          {
              /*  Upon successful completion, getgrgid() shall return a
                  pointer to a struct group with the structure defined in
                  <grp.h> with a matching entry if one is found.  */
              REQ("getgrgid.03", "getgrgid shall return valid value",
                  equals(res, getgrgid_spec));
          }
    }
    return true;
  }
}

UsersGroup* getgrgid_model(Set* groupsSet, GidT dest)
{
    int i=0;
    for(i=0;i<size_Set(groupsSet);i++)
    {
         UsersGroup* gr=get_Set(groupsSet, i);
         if(gr->gr_gid==dest)
                    return gr;
    }
    return NULL;
}

specification
GetGrxxxFunctionResult*  getgrgid_r_spec(CallContext context,
                                         GidT gid,
                                         UsersGroupTPtr grp, SizeT bufsize,
                                         UsersGroupTPtr* result,
                                         ErrorCode* errno, CancelStatus status)
{
  SystemState* curState=NULL;
  Set*         groupsSet=NULL;
  UsersGroup*   res;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
    /* [Consistency of test suite] */
    REQ("", "Set with user groups shall not be NULL",groupsSet!=NULL);

    /* [Implicit precondition] */
    REQ("", "grp is not NULL", !isNULL_VoidTPtr(grp));

    /* [Implicit precondition] */
    REQ("", "Pointer to pointer to result is not NULL", result!=NULL);

    /* [Implicit precondition] */
    REQ("", "Memory pointed to by grp is available in the context",
        isValidPointer(context, grp));

    if(curState->isGroupsSetFilled)
         res=getgrgid_model(groupsSet, gid);

    *errno=SUT_EOK;

    return true;
  }
  coverage C
  {
      if(curState->isGroupsSetFilled==true)
      {
          if(res!=NULL)
            return { SetFilledConatains,
                "Set with users info was filled and contains item" };
          else
            return { SetFilledNotConatains,
                "Set with users info was filled and does not contain item" };
      }
      else /* if(curState->isGroupsSetFilled==false) */
      {
          return { SetNotFilled, "Set with users info was not filled" };
      }
  }
  coverage C_bufsize
  {
    LongT maxSize = getSystemConfigurationValue(context,
                                                SUT_SC_GETGR_R_SIZE_MAX);

    if(bufsize<maxSize)
    {
        return { BuffSmall, "Buffer size less than SC_GETGR_R_SIZE_MAX" };
    } else if (bufsize==maxSize) {
        return { BuffEqual, "Buffer size equals to SC_GETGR_R_SIZE_MAX" };
    } else {
        return { BuffMore, "Buffer size more than SC_GETGR_R_SIZE_MAX" };
    }
  }

  CANCELPOINT_COVERAGE(context)
  post
  {
    CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

    if (getgrgid_r_spec->errno!=0)
    {
      /*
      * On error, errno shall be set to
      * indicate the error.
      */
      REQ("getgrgid.04.03", "getgrgid_r shall return error number",
        getgrgid_r_spec->errno==*errno);

      /*
      * or an error occurred.
      */
      REQ("getgrgid.04.02", "Pointer to result shall be NULL",
        isNULL_VoidTPtr(*result));
    }

    /*
     * otherwise, an error number shall be returned to indicate the
     * error.
     */
    ERROR_BEGIN(POSIX_GETGRGID_R, "getgrgid_r.06.02",
      getgrgid_r_spec->errno!=0, getgrgid_r_spec->errno)

    /*
    * The getgrgid_r() function may fail if:
    *
    * [ERANGE]
    *
    * [TSF]
    * Insufficient storage was supplied via buffer and bufsize to contain
    * the data to be referenced by the resulting
    * group structure.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID_R, ERANGE,"getgrgid_r.07.01",
        "Can not check this condition")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [EIO]
    *
    * An I/O error has occurred.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID_R, EIO,"getgrgid.10.01",
        "Can not check this case")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [EINTR]
    *
    * A signal was caught during getgrgid().
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID_R, EINTR,"getgrgid.10.02",
        "Can not check this case")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [EMFILE]
    *
    * {OPEN_MAX} file descriptors are currently open in the calling process.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID_R, EMFILE,"getgrgid.10.03",
        "Can not check this case")

    /*
    * The getgrgid() and getgrgid_r() functions may fail if:
    *
    * [ENFILE]
    *
    * The maximum allowable number of files is currently open in the system.
    *
    */
    ERROR_UNCHECKABLE(POSIX_GETGRGID_R, ENFILE,"getgrgid.10.04",
        "Can not check this case")

    ERROR_END()

    /*
    * If successful, the getgrgid_r() function shall return zero;
    */
    REQ("getgrgid_r.06.01", "Function shall return zero",
        getgrgid_r_spec->errno==0);

    /*
    * Storage referenced by the group structure is allocated from the
    * memory provided with the buffer parameter, which
    * is bufsize bytes in size.
    */
    REQ("getgrgid_r.03", "", TODO_REQ());

    if(curState->isGroupsSetFilled)
    {
          if(res==NULL)
          {
              /* A NULL pointer shall be returned at the location pointed
                 to by result on error or if the requested entry is not
                 found.  */
              REQ("getgrgid_r.05", "Pointer to result shall be NULL",
                  isNULL_VoidTPtr(*result));

          }
          else
          {
              /*
              * The getgrgid_r() function shall update the group structure
              * pointed to by grp and store a pointer to that structure at
              * the location pointed to by result. The structure shall
              * contain an entry from the group database with a matching
              * gid.
              */
              REQ("getgrgid_r.02",
                  "result shall contain pointer to group structure",
                  equals_VoidTPtr(*result, grp));

              /* The getgrgid_r() function shall update the group structure
                 pointed to by grp */
              REQ("", "Updated structure shall be valid",
                  isEqualUserGroupsStructures(
                  context,
                  getgrgid_r_spec->grp, res
                  ));
          }
    }
    return true;
  }
}




/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    getgrnam, getgrnam_r - search group database for a name

SYNOPSIS

    #include <grp.h>
    struct group *getgrnam(const char *name);
    int getgrnam_r(const char *name, struct group *grp, char *buffer,
        size_t bufsize, struct group **result);

DESCRIPTION

    The getgrnam() function shall search the group database for an entry with a
    matching name.

    The getgrnam() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

    The getgrnam_r() function shall update the group structure pointed to by
    grp and store a pointer to that structure at the location pointed to by
    result. The structure shall contain an entry from the group database with a
    matching gid or name. Storage referenced by the group structure is
    allocated from the memory provided with the buffer parameter, which is
    bufsize bytes in size. The maximum size needed for this buffer can be
    determined with the {_SC_GETGR_R_SIZE_MAX} sysconf() parameter. A NULL
    pointer is returned at the location pointed to by result on error or if the
    requested entry is not found.

RETURN VALUE

    The getgrnam() function shall return a pointer to a struct group with the
    structure defined in <grp.h> with a matching entry if one is found. The
    getgrnam() function shall return a null pointer if either the requested
    entry was not found, or an error occurred. On error, errno shall be set to
    indicate the error.

    The return value may point to a static area which is overwritten by a
    subsequent call to getgrent(), getgrgid(), or getgrnam().

    If successful, the getgrnam_r() function shall return zero; otherwise, an
    error number shall be returned to indicate the error.

ERRORS

    The getgrnam() and getgrnam_r() functions may fail if:

    [EIO]
    An I/O error has occurred.

    [EINTR]
    A signal was caught during getgrnam().

    [EMFILE]
    {OPEN_MAX} file descriptors are currently open in the calling process.

    [ENFILE]
    The maximum allowable number of files is currently open in the system.

    The getgrnam_r() function may fail if:

    [ERANGE]
    Insufficient storage was supplied via buffer and bufsize to contain the
    data to be referenced by the resulting group structure.
*/

specification
UsersGroup* getgrnam_spec(CallContext context, CString* dest, ErrorCode* errno,
                          CancelStatus status)
{
  SystemState* curState=NULL;
  Set*         groupsSet=NULL;
  UsersGroup*  res;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
    /* [Consistency of test suite] */
    REQ("", "Set with user groups shall not be NULL", groupsSet!=NULL);

    if(curState->isGroupsSetFilled)
         res=getgrnam_model(groupsSet, dest);

    *errno=SUT_EOK;

    return true;
  }
  coverage C
  {
      if(curState->isGroupsSetFilled==true)
      {
          if(res!=NULL)
            return { SetFilledConatains,
                "Set with groups info was filled and contains item" };
          else
            return { SetFilledNotConatains,
                "Set with groups info was filled and does not contain item" };
      }
      else /* if(curState->isGroupsSetFilled==false) */
      {
          return { SetNotFilled, "Set with groups info was not filled" };
      }
  }
  CANCELPOINT_COVERAGE(context)
  post
  {
     CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

     /*
     * The getgrnam() function shall search the group database for an entry
     * with a matching name.
     */
     IMPLEMENT_REQ("getgrnam.01");

    /*
    * . On error, errno shall be set to
    * indicate the error.
    */
    ERROR_BEGIN(POSIX_GETGRNAM, "getgrnam.04", *errno!=SUT_EOK, *errno)
    /*
     * The getgrnam() and getgrnam_r() functions may fail if:
     *
     * [EIO]
     *
     * An I/O error has occurred.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRNAM, EIO,"getgrnam.10.01",
        "Can not check this case")

    /*
     * The getgrnam() and getgrnam_r() functions may fail if:
     *
     * [EINTR]
     *
     * A signal was caught during getgrnam().
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRNAM, EINTR,"getgrnam.10.02",
        "Can not check this case")

    /*
     * The getgrnam() and getgrnam_r() functions may fail if:
     *
     * [EMFILE]
     *
     * {OPEN_MAX} file descriptors are currently open in the calling process.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRNAM, EMFILE,"getgrnam.10.03",
        "Can not check this case")

    /*
     * The getgrnam() and getgrnam_r() functions may fail if:
     *
     * [ENFILE]
     *
     * The maximum allowable number of files is currently open in the system.
     *
     */
    ERROR_UNCHECKABLE(POSIX_GETGRNAM, ENFILE,"getgrnam.10.04",
        "Can not check this case")

    ERROR_END()
    if(curState->isGroupsSetFilled)
    {
      if(res==NULL)
      {
         /*
          * The getgrnam() function shall
          * return a null pointer if either the requested entry was not found
          * or an error occured
          */
          REQ("getgrnam.03", "getgrnam shall return NULL",
              getgrnam_spec==res);
      }
      else
      {
         /*
          * The getgrnam() function shall return a pointer to a struct group
          * with the structure defined in <grp.h> with a matching entry if
          * one is found.
          */
         REQ("getgrnam.02", "getgrnam shall return valid value",
              equals(res, getgrnam_spec));
      }
    }
    return true;
  }
}

UsersGroup* getgrnam_model(Set* groupsSet, CString*  destStr)
{
    int i=0;
    for(i=0;i<size_Set(groupsSet);i++)
    {
         UsersGroup* gr=get_Set(groupsSet, i);
         if(equals(gr->gr_name, destStr))
                    return gr;
    }
    return NULL;
}

specification
GetGrxxxFunctionResult* getgrnam_r_spec(CallContext context,
                                         CString* name,
                                         UsersGroupTPtr grp, SizeT bufsize,
                                         UsersGroupTPtr* result,
                                         ErrorCode* errno, CancelStatus status)
{
  SystemState* curState=NULL;
  Set*         groupsSet=NULL;
  UsersGroup*  res;

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
    /* [Consistency of test suite] */
    REQ("", "Set with groups entries shall not be NULL", groupsSet!=NULL);

    /* [Implicit precondition] */
    REQ("", "grp shall be  not NULL", !isNULL_VoidTPtr(grp));

    /* [Implicit precondition] */
    REQ("", "Pointer to pointer to result shall be not NULL", result!=NULL);

    /* [Implicit precondition] */
    REQ("", "Memory pointed to by grp is available in the context",
        isValidPointer(context, grp));

    if(curState->isGroupsSetFilled)
         res=getgrnam_model(groupsSet, name);

    *errno=SUT_EOK;

    return true;
  }
  coverage C
  {
      if(curState->isGroupsSetFilled==true)
      {
          if(res!=NULL)
            return { SetFilledConatains,
                "Set with groups info was filled and contains item" };
          else
            return { SetFilledNotConatains,
                "Set with groups info was filled and does not contain item" };
      }
      else /* if(curState->isGroupsSetFilled==false) */
      {
          return { SetNotFilled, "Set with groups info was not filled" };
      }
  }
  coverage C_bufsize
  {
    LongT maxSize =
        getSystemConfigurationValue(context,SUT_SC_GETGR_R_SIZE_MAX);

    if(bufsize<maxSize)
    {
        return { BuffSmall, "Buffer size less than SC_GETGR_R_SIZE_MAX" };
    } else if (bufsize==maxSize) {
        return { BuffEqual, "Buffer size equals to SC_GETGR_R_SIZE_MAX" };
    } else {
        return { BuffMore, "Buffer size more than SC_GETGR_R_SIZE_MAX" };
    }
  }
  CANCELPOINT_COVERAGE(context)
  post
  {
      CANCELLATION_POINT_MAY_OCCUR_REQ(context, status)

      /*
      * Storage referenced by the group structure is allocated from the memory
      * provided with the
      * buffer parameter, which is bufsize bytes in size.
      */
      REQ("getgrnam_r.03", "", TODO_REQ());


        if (getgrnam_r_spec->errno!=0)
        {
            /*
            * otherwise, an error number shall be returned to indicate the
            * error.
            */
            REQ("getgrnam_r.06.02", "getgrnam_r shall return error number",
                getgrnam_r_spec->errno==*errno);
            /*
            * A NULL pointer is returned at the
            * location pointed to by result on error
            */
            REQ("getgrnam_r.05.01", "Pointer to result shall be NULL",
                isNULL_VoidTPtr(*result));
        }

      /*
      * otherwise, an error number shall be returned to indicate the
      * error.
      */
      ERROR_BEGIN(POSIX_GETGRNAM_R, "getgrnam_r.06.02",
          getgrnam_r_spec->errno!=0, getgrnam_r_spec->errno )
      /*
      * The getgrnam() and getgrnam_r() functions may fail if:
      *
      * [EIO]
      *
      * An I/O error has occurred.
      *
      */
      ERROR_UNCHECKABLE(POSIX_GETGRNAM_R, EIO,"getgrnam_r.10.01",
        "Can not check this case")

      /*
      * The getgrnam() and getgrnam_r() functions may fail if:
      *
      * [EINTR]
      *
      * A signal was caught during getgrnam().
      *
      */
      ERROR_UNCHECKABLE(POSIX_GETGRNAM_R, EINTR,"getgrnam_r.10.02",
        "Can not check this case")

      /*
      * The getgrnam() and getgrnam_r() functions may fail if:
      *
      * [EMFILE]
      *
      * {OPEN_MAX} file descriptors are currently open in the calling process.
      *
      */
      ERROR_UNCHECKABLE(POSIX_GETGRNAM_R, EMFILE,"getgrnam_r.10.03",
        "Can not check this case")

      /*
      * The getgrnam() and getgrnam_r() functions may fail if:
      *
      * [ENFILE]
      *
      * The maximum allowable number of files is currently open in the system.
      *
      */
      ERROR_UNCHECKABLE(POSIX_GETGRNAM_R, ENFILE,"getgrnam_r.10.04",
        "Can not check this case")

      /*
      * The getgrnam_r() function may fail if:
      *
      * [ERANGE]
      *
      * [TSF]
      * Insufficient storage was supplied via buffer and bufsize to contain
      * the data to be referenced by the resulting
      * group structure.
      *
      */
      ERROR_UNCHECKABLE(POSIX_GETGRNAM_R, ERANGE,"getgrnam_r.11.01",
        "Can not check this case")

      ERROR_END()

      /*
       * If successful, the getgrnam_r() function shall return zero;
       */
      REQ("getgrnam_r.06.01", "getgrnam_r shall return zero",
        getgrnam_r_spec->errno==0);

      if(curState->isGroupsSetFilled)
        {
              if(res==NULL)
              {
                    /*
                    * or if the requested entry is not found.
                    */
                    REQ("getgrnam_r.05.02", "Pointer to result shall be NULL",
                        isNULL_VoidTPtr(*result));
              }
              else
              {
                 /* The getgrnam_r() function shall update the group structure
                    pointed to by grp and store a pointer to that structure at
                    the location pointed to by result. */
                  REQ("getgrnam_r.01",
                      "result shall contain pointer to passwd structure",
                      equals_VoidTPtr(*result, grp));

                  /*  The structure shall contain an entry from the group
                      database with a matching gid or name. */
                  REQ("getgrnam_r.02", "Updated structure shall be valid",
                      isEqualUserGroupsStructures(
                         context,
                         getgrnam_r_spec->grp, res)
                      );
              }
        }
    return true;
  }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    getgrouplist -- get network group entry

SYNOPSIS

    #include <grp.h>
    int getgrouplist(const char * user, gid_t group, gid_t * groups,
        int * ngroups);

DESCRIPTION

    The getgrouplist() function shall fill in the array groups with the
    supplementary groups for the user specified by user. On entry, ngroups
    shall refer to an integer containing the maximum number of gid_t members
    in the groups array. The group group shall also be included. On success,
    the value referred to by ngroups shall be updated to contain the number of
    gid_t objects copied.

RETURN VALUE

    On success, if there was sufficient room to copy all the supplementatry
    group identifiers to the array identified by groups, getgrouplist() shall
    return the number of gid_t objects copied, and the value referenced by
    ngroups shall be updated. If there was not sufficient room to copy all the
    supplementary group identifiers, grouplist() shall return -1, and update
    the value referenced by ngroups to the number actually copied.

    If user does not refer to a valid user on the system, getgrouplist() shall
    return 0, and set the value referenced by ngroups to 0.

ERRORS

    None defined.
*/

specification
IntT getgrouplist_spec(CallContext context, CString* user, GidT group,
                       Set* groups, IntT* ngroups)
{
  SystemState* curState=NULL;
  Set*  groupsSet=NULL;
  bool userExists=false;
  IntT numUsGroups=0;
  bool enoughSpace=false;
  IntT maxGroups=*ngroups;
  Set* userGids=create_Set(&type_Integer);

  curState=getSystemState( context.system );
  if(curState!=NULL)
      groupsSet=curState->groups;

  pre
  {
    /* [Consistency of test suite] */
    REQ("", "Set with user groups shall not be NULL",groupsSet!=NULL);

    if(curState->isGroupsSetFilled)
    {
        userExists=isUserExists(groupsSet, user);
        numUsGroups=getNumUserGroups(groupsSet, user, group, userGids);
        enoughSpace=(numUsGroups<=maxGroups);
    }

    return true;
  }
  coverage C
  {
      if(curState->isGroupsSetFilled)
      {
          if(userExists)
          {
              if(enoughSpace)
              {
                    return {userExistsFilledOK,
                      "User exists and there was sufficient room to copy"};

              }
              else
              {
                    return {userExistsFilled,
                      "User exists and there was not sufficient room to copy"};

              }

          }
          else /* if(!userExists) */
          {
              return {notUserExistsFilled,
                "Set is filled and user does not exist in the system"};
          }
      }
      else /* if(!curState->isGroupsSetFilled) */
      {
              return {notFilled, "Set with user groups is not filled"};
      }
  }
  post
  {

      /*
      * On entry,
      * ngroups shall refer to an integer
      * containing the maximum number of gid_t
      * members in the groups array.
      */
      REQ_UNCHECKABLE("getgrouplist.02",
          "There is no need to check this initial conditions");

      /*
      * The group group shall also be included.
      */
      REQ_UNCHECKABLE("getgrouplist.03",
          "There is no need to check this initial conditions");

      if ( curState->isGroupsSetFilled && ! curState->isGroupsSetHighSecured ) {
            if(!userExists)
            {
                /*
                * If user does not refer to a valid
                * user on the system, getgrouplist() shall
                * return 0,
                */
                REQ("getgrouplist.07.01", "getgrouplist shall return 0",
                    getgrouplist_spec==0);

                /*
                * and set the value referenced by
                * ngroups to 0.
                */
                REQ("getgrouplist.07.02",
                    "getgrouplist shall set ngroups to 0", *ngroups==0);
            }
            else
            {
                if(enoughSpace)
                {
                    /*
                    * On success, if there was sufficient room to copy all the
                    * supplementatry group identifiers to the array
                    * identified by groups,
                    * getgrouplist() shall return the number of
                    * gid_t objects copied,
                    */
                    REQ("getgrouplist.05.01",
                        "Function shall return valid number of groups copied",
                        getgrouplist_spec==numUsGroups);
                    /*
                    * On success, the value referred to by ngroups shall be
                    * updated to contain the number of gid_t
                    * objects copied.
                    */
                    REQ("getgrouplist.04",
                        "ngroups shall be valid in this case",
                         *ngroups==numUsGroups);
                    /*
                    * and the value referenced by
                    * ngroups shall be updated.
                    */
                    REQ("getgrouplist.05.02",
                        "ngroups shall be valid in this case",
                        *ngroups==numUsGroups);
                    /*
                    * The getgrouplist() function shall
                    * fill in the array groups with
                    * the supplementary groups for the user specified
                    * by user.
                    */
                    REQ("getgrouplist.01",
                        "Returned array shall be valid and fully equal",
                        isEqualSets(userGids, groups, true));
                }
                else
                {
                    /*
                    * If there was not sufficient room to copy all the
                    * supplementary group identifiers, grouplist() shall
                    * return -1
                    */
                    REQ("getgrouplist.06.01", "getgrouplist shall return -1",
                        getgrouplist_spec==-1);

                    /*
                    * and update the value referenced
                    * by ngroups to the number actually copied.
                    */
                    REQ("getgrouplist.06.02", "ngroups shall be valid",
                        *ngroups<=maxGroups);

                    REQ("","Returned array shall be valid",
                           isEqualSets(userGids, groups, false));

                }

            }
      }

      return true;
  }
}

/********************************************************************/
/**                       Group Types                              **/
/********************************************************************/

specification typedef struct GetGrxxxFunctionResult
        GetGrxxxFunctionResult={};

GetGrxxxFunctionResult * create_GetGrxxxFunctionResult(
    IntT        errno,
    UsersGroup* grp
)
{
    return create(&type_GetGrxxxFunctionResult,
        errno,
        grp);
}

typedef struct OptionalUser
{
    char* name;
    bool  inCorrespondingGroup;
    bool  exists;
} OptionalUser;


OptionalUser optionalUsers[]={
    {"root", false, false},
    {"bin", false, false},
    {"adm", false, false},
    {"lp", false, false},
    {"sync", false, false},
    {"shutdown", false, false},
    {"halt", false, false},
    {"mail", false, false},
    {"news", false, false},
    {"uucp", false, false},
    {"man", false, false},
    {"nobody", false, false},
    {NULL, false, false}
};

OptionalUser operatorUs={"operator", false, false};

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

void clearOptionalUsers()
{
    int i=0;
    while(optionalUsers[i].name!=NULL)
    {
        optionalUsers[i].inCorrespondingGroup=false;
        optionalUsers[i].exists=false;
        i++;
    }
    operatorUs.inCorrespondingGroup=false;
    operatorUs.exists=false;
}



bool goOptionalUsers()
{
    int i=0;
    while(optionalUsers[i].name!=NULL)
    {
        if(optionalUsers[i].exists && !optionalUsers[i].inCorrespondingGroup)
            return false;
        i++;
    }

    if(operatorUs.exists && !operatorUs.inCorrespondingGroup)
        return false;

    return true;
}

bool CheckOptionalUsers(Set* groupsSet)
{
    List* usList;
    UsersGroup* gr;
    int i=0, j=0;

    clearOptionalUsers();

    for(j=0;j<size_Set(groupsSet);j++)
    {
        gr=get_Set(groupsSet, j);
        usList=gr->gr_mem;
        i=0;
        // traceFormattedUserInfo("group : $(obj), members : $(obj)", gr->gr_name, gr->gr_mem);
        while(optionalUsers[i].name!=NULL)
        {
            if(contains_List(usList, create_CString(optionalUsers[i].name)))
            {
                optionalUsers[i].exists=true;
                if(equals(gr->gr_name, create_CString(optionalUsers[i].name)))
                {
                    optionalUsers[i].inCorrespondingGroup=true;
                }
                else
                {
                    traceExtraFormattedProperty( "violation", "'%s' should in '%s' instead of '%s'",
                                                              optionalUsers[i].name,
                                                              optionalUsers[i].name,
                                                              gr->gr_name
                                               );
                }

            }
            i++;
        }

        if(contains_List(usList, create_CString("operator")))
        {
            operatorUs.exists=true;
            if(equals(gr->gr_name, create_CString("root")))
            {
                operatorUs.inCorrespondingGroup=true;
            }
            else
            {
                traceExtraFormattedProperty( "violation", "'operator' should in 'root' instead of '%s'",
                                                          gr->gr_name
                                           );
            }
        }
    }
    return goOptionalUsers();
}

bool isValidGroupsSet(Set* groupsSet)
{
    int i=0, j=0;
    for(i=0;i<size_Set(groupsSet);i++)
    {
        for(j=0;j<size_Set(groupsSet);j++)
        {
            if(i!=j)
            {
                UsersGroup* p1=get_Set(groupsSet, i);
                UsersGroup* p2=get_Set(groupsSet, j);
                if(equals(p1->gr_name, p2->gr_name) || p1->gr_gid==p2->gr_gid)
                    return false;
            }
        }
    }
    return true;
}


bool isRequiredGroupExist(Set* groupsSet, CString* name)
{
    int i=0;

    for(i=0;i<size_Set(groupsSet);i++)
    {
         UsersGroup* ps=get_Set(groupsSet, i);
         if(equals(ps->gr_name, name))
                    return true;
    }
    return false;
}


bool isRequiredGroupsExist(Set* set)
{
    CString* root=create_CString("root");
    CString* bin=create_CString("bin");
    CString* daemon=create_CString("daemon");

    return (
        isRequiredGroupExist(set, root)
        &&
        isRequiredGroupExist(set, bin)
        &&
        isRequiredGroupExist(set, daemon));
}



bool isUserExists(Set* groupsSet, CString* user)
{
    int i=0, j=0;
    UsersGroup* gr;
    List*       members;
    CString*    curUser;

    for(i=0;i<size_Set(groupsSet);i++)
    {
      gr=get_Set(groupsSet, i);
      members=gr->gr_mem;
      for(j=0;j<size_List(members);j++)
      {
          curUser=get_List(members, j);
          if(equals(curUser, user))
              return true;
      }
    }

    return false;
}


IntT getNumUserGroups(Set* groupsSet, CString* user, GidT group, Set* userGids)
{
    int i=0, j=0;
    UsersGroup* gr;
    List*       members;
    CString*    curUser;
    IntT        result=1;

    clear_Set(userGids);
    add_Set(userGids, create_Integer(group));

    for(i=0;i<size_Set(groupsSet);i++)
    {
      gr=get_Set(groupsSet, i);
      members=gr->gr_mem;
      for(j=0;j<size_List(members);j++)
      {
          curUser=get_List(members, j);
          if(equals(curUser, user) && gr->gr_gid!=group)
          {
              result++;
              add_Set(userGids, create_Integer(gr->gr_gid));
              break;
          }
      }
    }

    return result;
}


bool isEqualSets(Set* userGids, Set* groups, bool fullCompare)
{
    int i=0;
    if(fullCompare)
    {
        return equals(userGids, groups);
    }

    return containsAll_Set(userGids, groups);
}

bool isEqualUserGroupsStructures(CallContext context, UsersGroup* grpp1,
                                 UsersGroup* grpp2)
{
    if(!equals(grpp1->gr_name, grpp2->gr_name))
        return false;

    if(grpp1->gr_gid != grpp2->gr_gid)
        return false;

    if(!equals(grpp1->gr_mem, grpp2->gr_mem))
        return false;

    return true;
}


