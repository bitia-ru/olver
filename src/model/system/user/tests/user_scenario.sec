/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "system/user/system_user_config.h"
#include "system/user/user_config.h"
#include "system/user/tests/user_scenario.seh"
#include "util/string/wstr_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "system/user/user_model.seh"
#include "atl/integer.h"
#include "process/meta/user_model.seh"
#include "system/sysconf/sysconf_model.seh"


/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/
#define NUM_THREADS 3
#define SMALL_BUF_SIZE 3
static const int maxSize = 30000;
static const int numItems = 10;

static char* names[]={"root", "notfound", "daemon", "ftp", "bad", "games"};
static int numNames=sizeof(names)/sizeof(char*);
static int curName=0;

static int uids[]={12, 38, 380, 37, 32, 1000};
static int numUids=sizeof(uids)/sizeof(int);
static int curUid=0;

static LongT maxBuffSize;

static bool byPassError=false;

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/

static CallContext context;


static StringTPtr name;
static VoidTPtr buffer;
static VoidTPtr structBuffer;


static CallContext contexts[NUM_THREADS+20];
static VoidTPtr structBuffers[NUM_THREADS];
static PasswdTPtr results[NUM_THREADS];


specification typedef struct PwentTestState PwentTestState = {};
specification typedef struct NamUidTestState NamUidTestState = {};

PwentTestState *create_PwentTestState(
    int sizeSet,
    bool isSetValid
)
{
    return create(&type_PwentTestState, sizeSet, isSetValid);
}

NamUidTestState *create_NamUidTestState(
    bool isSetFilled,
    int  nameIndex,
    int  uidIndex
)
{
    return create(&type_NamUidTestState, isSetFilled, nameIndex, uidIndex);
}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

static void init_sysconf_data(CallContext context)
{
    sysconf_spec(context, SUT_SC_GETPW_R_SIZE_MAX, requestErrorCode());
    sysconf_spec(context, SUT_SC_OPEN_MAX, requestErrorCode());
}

static bool init_system_user_scenario(int argc, char** argv)
{
    context = getContext();

    structBuffer = allocateMemoryBlock(context, maxSize);
    if (isNULL_VoidTPtr(structBuffer))
        return false;

    return true;
}

static void finish_system_user_scenario(void)
{
    deallocateMemoryBlock(context, structBuffer);
}

static bool init_user_cancel_scenario(int argc, char** argv)
{
    int i=0;

    context = getContext();

    structBuffer = allocateMemoryBlock(context, maxSize);
    if (isNULL_VoidTPtr(structBuffer))
        return false;


    return true;
}

static void finish_user_cancel_scenario(void)
{
    deallocateMemoryBlock(context, structBuffer);
}

static bool init_additional_scenario(int argc, char** argv)
{
    int i=0;
    for(i=0;i<NUM_THREADS;i+=3)
    {
        createProcess();

        if(i!=0)
        {
            createProcess();
        }
        createThread();
    }
    if(!getContexts(NUM_THREADS, contexts))
        return false;

    for(i=0;i<NUM_THREADS;i++)
    {
        structBuffers[i] = allocateMemoryBlock(contexts[i], maxSize);
        results[i]=generateVirtualPointer(contexts[i]);
        if (isNULL_VoidTPtr(structBuffers[i]))
            return false;
    }

    return true;
}

static void finish_additional_scenario(void)
{
    int i;
    for(i=0;i<NUM_THREADS;i++)
    {
        deallocateMemoryBlock(contexts[i], structBuffers[i]);
    }
}


/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/


Object* getSystemUserState(void)
{
    ProcessState* curState=NULL;
    Set*  usersSet=NULL;
    int sz;

    curState=getProcessState_CallContext( context );
    if(curState!=NULL)
        usersSet=curState->users;

    sz=size_Set(usersSet);
    if(sz > numItems)
        sz= numItems;

    if(usersSet!=NULL)
        return create_PwentTestState( sz, curState->isDatabaseClosed);

    return NULL;

}

Object* getSystemUserState2(void)
{
    ProcessState* curState=NULL;
    Set*  usersSet=NULL;

    curState=getProcessState_CallContext( context );
    if(curState!=NULL)
        usersSet=curState->users;

    if(usersSet!=NULL)
        return create_NamUidTestState(curState->isSetFilled, curName, curUid);

    return NULL;

}


/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/


scenario
bool getpwent_scen()
{
    ProcessState* curState=NULL;
    Set*  usersSet=NULL;
    int sz;

    init_sysconf_data(context);

    curState=getProcessState_CallContext( context );
    if(curState!=NULL)
        usersSet=curState->users;

    if(usersSet==NULL)
        return false;

    sz=size_Set(usersSet);

    iterate(int i=0; i<1; i++;)
    {
        getpwent_spec(context, requestErrorCode(), cancel_status);
    }
    return true;
}



scenario
bool setpwent_scen()
{
    setpwent_spec(context, requestErrorCode());

    return true;
}

scenario
bool endpwent_scen()
{
    endpwent_spec(context, requestErrorCode(), cancel_status);

    return true;
}


scenario
bool getp_and_r_scen()
{
    PasswdTPtr result;

    init_sysconf_data(context);


    getpwnam_spec(context, create_CString(names[curName]), requestErrorCode(), cancel_status);

    getpwnam_r_spec(context, create_CString(names[curName]),  structBuffer,
        1, &result, requestErrorCode(), cancel_status);

    getpwnam_r_spec(context, create_CString(names[curName]),  structBuffer,
        getSystemConfigurationValue(context, SUT_SC_GETPW_R_SIZE_MAX), &result, requestErrorCode(), cancel_status);

    getpwnam_r_spec(context, create_CString(names[curName]),  structBuffer,
        maxSize, &result, requestErrorCode(), cancel_status);


    curName++;
    if(curName >= numNames)
        curName=0;

    getpwuid_spec(context, uids[curUid], requestErrorCode(), cancel_status);

    getpwuid_r_spec(context, uids[curUid],  structBuffer,  maxSize, &result,
        requestErrorCode(), cancel_status);

    getpwuid_r_spec(context, uids[curUid],  structBuffer,  1, &result,
        requestErrorCode(), cancel_status);

    getpwuid_r_spec(context, uids[curUid],  structBuffer,  getSystemConfigurationValue(context, SUT_SC_GETPW_R_SIZE_MAX), &result,
        requestErrorCode(), cancel_status);


    curUid++;
    if(curUid >= numUids)
        curUid=0;


    return true;
}

scenario
bool getpwent_filled_scen()
{
    ProcessState* curState=NULL;
    Set*  usersSet=NULL;

    curState=getProcessState_CallContext( context );

    if(!curState)
    {
        return false;
    }
    if(curState->isSetFilled==false)
    {
        if(byPassError)
            endpwent_spec(context, requestErrorCode(), cancel_status);

        while(getpwent_spec(context, requestErrorCode(), cancel_status)!=NULL)
        {
        }
    }
    else
    {
        endpwent_spec(context, requestErrorCode(), cancel_status);
        getpwent_spec(context, requestErrorCode(), cancel_status);
    }
    return true;
}


scenario
bool additional_scen()
{
    int i=0;

    REQ("", "Agent should have permissions to call setuid(0)",
        setuid_spec(contexts[0], 0, requestErrorCode())==0 );
    REQ("", "Agent should have permissions to call setgid(0)",
        setgid_spec(contexts[0], 0, requestErrorCode())==0 );

    iterate (int k=0; k<NUM_THREADS; k+=3;)
    {
        init_sysconf_data(contexts[k]);
        init_sysconf_data(contexts[k+1]);
        init_sysconf_data(contexts[k+2]);

        for(i=0; i< numNames-1 && i < numUids-1; i++)
        {
            getpwnam_r_spec(contexts[k], create_CString(names[i]),
                structBuffers[k],  maxSize, &results[k],
                requestErrorCode(), cancel_status);

            getpwuid_r_spec(contexts[k], uids[i],  structBuffers[k],  maxSize,
                &results[k], requestErrorCode(), cancel_status);
            getpwuid_r_spec(contexts[k+1], uids[i+1],  structBuffers[k+1],
                maxSize, &results[k+1], requestErrorCode(), cancel_status);
            getpwuid_r_spec(contexts[k+2], uids[i],  structBuffers[k+2],
                maxSize, &results[k+2], requestErrorCode(), cancel_status);

            getpwnam_r_spec(contexts[k], create_CString(names[i+1]),
                structBuffers[k],  maxSize, &results[k],
                requestErrorCode(), cancel_status);
            getpwnam_r_spec(contexts[k+2], create_CString(names[i]),
                structBuffers[k+2],  maxSize, &results[k+2],
                requestErrorCode(), cancel_status);
            getpwnam_r_spec(contexts[k+1], create_CString(names[i+1]),
                structBuffers[k+1],  maxSize, &results[k+1],
                requestErrorCode(), cancel_status);
        }

        getpwuid_r_spec(contexts[k], uids[i],  structBuffers[k],
            SMALL_BUF_SIZE, &results[k], requestErrorCode(), cancel_status);
        getpwnam_r_spec(contexts[k+1], create_CString(names[i]),
            structBuffers[k+1],  SMALL_BUF_SIZE , &results[k+1],
            requestErrorCode(), cancel_status);
        getpwuid_r_spec(contexts[k+2], uids[i],  structBuffers[k+2],
            SMALL_BUF_SIZE, &results[k+2], requestErrorCode(), cancel_status);
        getpwnam_r_spec(contexts[k], create_CString(names[i]),
            structBuffers[k],  SMALL_BUF_SIZE , &results[k],
            requestErrorCode(), cancel_status);

        getpwuid_r_spec(contexts[k], uids[i],  structBuffers[k],  maxBuffSize,
            &results[k], requestErrorCode(), cancel_status);
        getpwnam_r_spec(contexts[k+1], create_CString(names[i]),
            structBuffers[k+1],  maxBuffSize , &results[k+1],
            requestErrorCode(), cancel_status);
        getpwuid_r_spec(contexts[k+2], uids[i],  structBuffers[k+2],
            maxBuffSize, &results[k+2], requestErrorCode(), cancel_status);
        getpwnam_r_spec(contexts[k], create_CString(names[i]),
            structBuffers[k],  maxBuffSize , &results[k],
            requestErrorCode(), cancel_status);

    }
    return true;
}

scenario
bool user_cancel_scen()
{
    PasswdTPtr result;
    ThreadId curTh=createThread();
    IntT i;


    pthread_setcancelstate_spec(curTh, SUT_PTHREAD_CANCEL_DISABLE);
    pthread_cancel_spec(context, curTh);

    for (i=0;i<10;i++)
    {
        getpwent_spec(curTh, requestErrorCode(), cancel_status);
        endpwent_spec(curTh, requestErrorCode(), cancel_status);
    }

    for (i=0;i<10;i++)
    {
        getpwnam_spec(curTh, create_CString("name"), requestErrorCode(),
            cancel_status);
        getpwuid_spec(curTh, 100, requestErrorCode(), cancel_status);

        getpwnam_r_spec(curTh, create_CString("name"),  structBuffer,
            1, &result, requestErrorCode(), cancel_status);
        getpwuid_r_spec(curTh, 100,  structBuffer,  1, &result,
            requestErrorCode(), cancel_status);
    }
}


scenario
bool user_cancel_scen2()
{
    PasswdTPtr result;
    ThreadId curTh;
    IntT i=0;

    for (i=0;i<10;i++)
    {
        if(!USER_FUNCTIONS_HALT_AFTER_CANCEL)
        {
            curTh=createThread();
            pthread_cancel_spec(context, curTh);
            endpwent_spec(curTh, requestErrorCode(), cancel_status);

            curTh=createThread();
            pthread_cancel_spec(context, curTh);
            getpwent_spec(curTh, requestErrorCode(), cancel_status);

            curTh=createThread();
            pthread_cancel_spec(context, curTh);
            getpwnam_spec(curTh, create_CString("name"), requestErrorCode(),
                cancel_status);

            curTh=createThread();
            pthread_cancel_spec(context, curTh);
            getpwuid_spec(curTh, 100, requestErrorCode(), cancel_status);
        }

        curTh=createThread();
        pthread_cancel_spec(context, curTh);
        getpwnam_r_spec(curTh, create_CString("name"),  structBuffer,
            1, &result, requestErrorCode(), cancel_status);



        curTh=createThread();
        pthread_cancel_spec(context, curTh);
        getpwuid_r_spec(curTh, 100,  structBuffer,  1, &result,
            requestErrorCode(), cancel_status);

    }

}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm system_user_user_scenario =
{
    .init = init_system_user_scenario,
        .finish = finish_system_user_scenario,
        .actions = {
            getpwent_scen,
            setpwent_scen,
            endpwent_scen,
            NULL
    },
    .getState=getSystemUserState
};


scenario dfsm system_user_user_2_scenario =
{
    .init = init_system_user_scenario,
        .finish = finish_system_user_scenario,
        .actions = {
            getp_and_r_scen,
            getpwent_filled_scen,
            NULL
    },
    .getState=getSystemUserState2
};


scenario dfsm system_user_user_additional_scenario =
{
    .init = init_additional_scenario,
        .finish = finish_additional_scenario,
        .actions = {
            additional_scen,
            NULL
    },
};


scenario dfsm system_user_user_cancel_scenario =
{
    .init = init_user_cancel_scenario,
        .finish = finish_user_cancel_scenario,
        .actions = {
        user_cancel_scen2,
        user_cancel_scen,
        NULL
    },
};

#ifdef SYSTEM_USER_LOCAL_MAIN

#include "common/init.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "common/control_center.seh"
#include "config/system_config.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_media.seh"
#include "pthread/mutex/mutexattr_media.seh"
#include "pthread/mutex/mutex_media.seh"
#include "util/search/hash_media.seh"

#include "process/meta/user_media.seh"
#include "system/sysconf/sysconf_media.seh"


#include "system/user/user_media.seh"

/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();
    initProcessMetaUserSubsystem();
    initSystemSysconfSubsystem();

    initSystemUserSubsystem();
    initPthreadPthreadSubsystem();
}

bool main_system_user_user( int argc, char** argv )
{
    addTraceToFile("trace.xml");
//    if(!USER_FUNCTIONS_HALT_AFTER_CANCEL)
//    {
       system_user_user_additional_scenario(argc,argv);
//    }

    system_user_user_cancel_scenario(argc, argv);
    byPassError=true;
    system_user_user_scenario(argc,argv);
    system_user_user_2_scenario(argc,argv);
    byPassError=false;


    byPassError=true;
    system_user_user_scenario(argc,argv);

    return true;
}

//static AssertionExit system_assertion_handler;

//void myAssertionExit(const char * format, va_list arg_list)
//{
//    system_assertion_handler( format, arg_list );  // Put breakpoint here
//}

int main(int argc, char** argv)
{
    //
    initTestSystem();
    loadSUT();
//    system_assertion_handler = atAssertion( myAssertionExit );

    // Set up tracer
    //setTraceEncoding("windows-1251");

    // Run test scenario
    main_system_user_user(argc,argv);

    //  unloadSUT();
    return 0;
}
#endif
