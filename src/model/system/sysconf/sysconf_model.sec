/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */


#include "system/sysconf/sysconf_model.seh"
#include "config/system_config.seh"
#include "common/cbytearray.seh"
#include "config/interpretation.seh"
#include "system/sysconf/sysconf_config.h"

#include "local_lim.h"

#pragma SEC subsystem sysconf "system.sysconf"

/*
   The group of functions 'system.sysconf' consists of:
       __getpagesize [2]
       __sysconf [2]
       confstr [1]
       fpathconf [1]
       getpagesize [4]
       pathconf [2]
       sysconf [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    sysconf - get configurable system variables

SYNOPSIS

    #include <unistd.h>

    long sysconf(int name);

DESCRIPTION

    The sysconf() function provides a method for the application to determine
    the current value of a configurable system limit or option ( variable).
    The implementation shall support all of the variables listed in the
    following table and may support others.

    The name argument represents the system variable to be queried. The
    following table lists the minimal set of system variables from <limits.h>
    or <unistd.h> that can be returned by sysconf(), and the symbolic
    constants defined in <unistd.h> that are the corresponding values used for
    name.

Variable    Value of Name

{AIO_LISTIO_MAX}        _SC_AIO_LISTIO_MAX
{AIO_MAX}               _SC_AIO_MAX
{AIO_PRIO_DELTA_MAX}    _SC_AIO_PRIO_DELTA_MAX
{ARG_MAX}               _SC_ARG_MAX
{ATEXIT_MAX}            _SC_ATEXIT_MAX
{BC_BASE_MAX}           _SC_BC_BASE_MAX
{BC_DIM_MAX}            _SC_BC_DIM_MAX
{BC_SCALE_MAX}          _SC_BC_SCALE_MAX
{BC_STRING_MAX}         _SC_BC_STRING_MAX
{CHILD_MAX}             _SC_CHILD_MAX
Clock ticks/second      _SC_CLK_TCK
{COLL_WEIGHTS_MAX}      _SC_COLL_WEIGHTS_MAX
{DELAYTIMER_MAX}        _SC_DELAYTIMER_MAX
{EXPR_NEST_MAX}         _SC_EXPR_NEST_MAX
{HOST_NAME_MAX}         _SC_HOST_NAME_MAX
{IOV_MAX}               _SC_IOV_MAX
{LINE_MAX}              _SC_LINE_MAX
{LOGIN_NAME_MAX}        _SC_LOGIN_NAME_MAX
{NGROUPS_MAX}           _SC_NGROUPS_MAX
Maximum size of getgrgid_r() and    _SC_GETGR_R_SIZE_MAX
getgrnam_r() data buffers

Maximum size of getpwuid_r() and    _SC_GETPW_R_SIZE_MAX
getpwnam_r() data buffers
{MQ_OPEN_MAX}           _SC_MQ_OPEN_MAX
{MQ_PRIO_MAX}           _SC_MQ_PRIO_MAX
{OPEN_MAX}              _SC_OPEN_MAX
_POSIX_ADVISORY_INFO    _SC_ADVISORY_INFO
_POSIX_BARRIERS         _SC_BARRIERS
_POSIX_ASYNCHRONOUS_IO  _SC_ASYNCHRONOUS_IO
_POSIX_CLOCK_SELECTION  _SC_CLOCK_SELECTION
_POSIX_CPUTIME          _SC_CPUTIME
_POSIX_FSYNC            _SC_FSYNC
_POSIX_IPV6             _SC_IPV6
_POSIX_JOB_CONTROL      _SC_JOB_CONTROL
_POSIX_MAPPED_FILES     _SC_MAPPED_FILES
_POSIX_MEMLOCK          _SC_MEMLOCK
_POSIX_MEMLOCK_RANGE    _SC_MEMLOCK_RANGE
_POSIX_MEMORY_PROTECTION    _SC_MEMORY_PROTECTION
_POSIX_MESSAGE_PASSING  _SC_MESSAGE_PASSING
_POSIX_MONOTONIC_CLOCK  _SC_MONOTONIC_CLOCK
_POSIX_PRIORITIZED_IO   _SC_PRIORITIZED_IO
_POSIX_PRIORITY_SCHEDULING  _SC_PRIORITY_SCHEDULING
_POSIX_RAW_SOCKETS      _SC_RAW_SOCKETS
_POSIX_READER_WRITER_LOCKS  _SC_READER_WRITER_LOCKS
_POSIX_REALTIME_SIGNALS _SC_REALTIME_SIGNALS
_POSIX_REGEXP           _SC_REGEXP
_POSIX_SAVED_IDS        _SC_SAVED_IDS
_POSIX_SEMAPHORES       _SC_SEMAPHORES
_POSIX_SHARED_MEMORY_OBJECTS    _SC_SHARED_MEMORY_OBJECTS
_POSIX_SHELL            _SC_SHELL
_POSIX_SPAWN            _SC_SPAWN
_POSIX_SPIN_LOCKS       _SC_SPIN_LOCKS
_POSIX_SPORADIC_SERVER  _SC_SPORADIC_SERVER
_POSIX_SS_REPL_MAX      _SC_SS_REPL_MAX
_POSIX_SYNCHRONIZED_IO  _SC_SYNCHRONIZED_IO
_POSIX_THREAD_ATTR_STACKADDR    _SC_THREAD_ATTR_STACKADDR
_POSIX_THREAD_ATTR_STACKSIZE    _SC_THREAD_ATTR_STACKSIZE
_POSIX_THREAD_CPUTIME   _SC_THREAD_CPUTIME
_POSIX_THREAD_PRIO_INHERIT  _SC_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT  _SC_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING   _SC_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_PROCESS_SHARED    _SC_THREAD_PROCESS_SHARED
_POSIX_THREAD_SAFE_FUNCTIONS    _SC_THREAD_SAFE_FUNCTIONS
_POSIX_THREAD_SPORADIC_SERVER   _SC_THREAD_SPORADIC_SERVER
_POSIX_THREADS          _SC_THREADS
_POSIX_TIMEOUTS         _SC_TIMEOUTS
_POSIX_TIMERS           _SC_TIMERS
_POSIX_TRACE            _SC_TRACE
_POSIX_TRACE_EVENT_FILTER   _SC_TRACE_EVENT_FILTER
_POSIX_TRACE_EVENT_NAME_MAX _SC_TRACE_EVENT_NAME_MAX
_POSIX_TRACE_INHERIT    _SC_TRACE_INHERIT
_POSIX_TRACE_LOG        _SC_TRACE_LOG
_POSIX_TRACE_NAME_MAX   _SC_TRACE_NAME_MAX
_POSIX_TRACE_SYS_MAX    _SC_TRACE_SYS_MAX
_POSIX_TRACE_USER_EVENT_MAX _SC_TRACE_USER_EVENT_MAX
_POSIX_TYPED_MEMORY_OBJECTS _SC_TYPED_MEMORY_OBJECTS
_POSIX_VERSION          _SC_VERSION
_POSIX_V6_ILP32_OFF32   _SC_V6_ILP32_OFF32
_POSIX_V6_ILP32_OFFBIG  _SC_V6_ILP32_OFFBIG
_POSIX_V6_LP64_OFF64    _SC_V6_LP64_OFF64
_POSIX_V6_LPBIG_OFFBIG  _SC_V6_LPBIG_OFFBIG
_POSIX2_C_BIND          _SC_2_C_BIND
_POSIX2_C_DEV           _SC_2_C_DEV
_POSIX2_CHAR_TERM       _SC_2_CHAR_TERM
_POSIX2_FORT_DEV        _SC_2_FORT_DEV
_POSIX2_FORT_RUN        _SC_2_FORT_RUN
_POSIX2_LOCALEDEF       _SC_2_LOCALEDEF
_POSIX2_PBS             _SC_2_PBS
_POSIX2_PBS_ACCOUNTING  _SC_2_PBS_ACCOUNTING
_POSIX2_PBS_CHECKPOINT  _SC_2_PBS_CHECKPOINT
_POSIX2_PBS_LOCATE      _SC_2_PBS_LOCATE
_POSIX2_PBS_MESSAGE     _SC_2_PBS_MESSAGE
_POSIX2_PBS_TRACK       _SC_2_PBS_TRACK
_POSIX2_SW_DEV          _SC_2_SW_DEV
_POSIX2_UPE             _SC_2_UPE
_POSIX2_VERSION         _SC_2_VERSION
{PAGE_SIZE}             _SC_PAGE_SIZE
{PAGESIZE}              _SC_PAGESIZE
{PTHREAD_DESTRUCTOR_ITERATIONS} _SC_THREAD_DESTRUCTOR_ITERATIONS
{PTHREAD_KEYS_MAX}      _SC_THREAD_KEYS_MAX
{PTHREAD_STACK_MIN}     _SC_THREAD_STACK_MIN
{PTHREAD_THREADS_MAX}   _SC_THREAD_THREADS_MAX
{RE_DUP_MAX}            _SC_RE_DUP_MAX
{RTSIG_MAX}             _SC_RTSIG_MAX
{SEM_NSEMS_MAX}         _SC_SEM_NSEMS_MAX
{SEM_VALUE_MAX}         _SC_SEM_VALUE_MAX
{SIGQUEUE_MAX}          _SC_SIGQUEUE_MAX
{STREAM_MAX}            _SC_STREAM_MAX
{SYMLOOP_MAX}           _SC_SYMLOOP_MAX
{TIMER_MAX}             _SC_TIMER_MAX
{TTY_NAME_MAX}          _SC_TTY_NAME_MAX
{TZNAME_MAX}            _SC_TZNAME_MAX
_XBS5_ILP32_OFF32 (LEGACY)  _SC_XBS5_ILP32_OFF32 (LEGACY)
_XBS5_ILP32_OFFBIG (LEGACY) _SC_XBS5_ILP32_OFFBIG (LEGACY)
_XBS5_LP64_OFF64 (LEGACY)   _SC_XBS5_LP64_OFF64 (LEGACY)
_XBS5_LPBIG_OFFBIG (LEGACY) _SC_XBS5_LPBIG_OFFBIG (LEGACY)
_XOPEN_CRYPT            _SC_XOPEN_CRYPT
_XOPEN_ENH_I18N         _SC_XOPEN_ENH_I18N
_XOPEN_LEGACY           _SC_XOPEN_LEGACY
_XOPEN_REALTIME         _SC_XOPEN_REALTIME
_XOPEN_REALTIME_THREADS _SC_XOPEN_REALTIME_THREADS
_XOPEN_SHM              _SC_XOPEN_SHM
_XOPEN_STREAMS          _SC_XOPEN_STREAMS
_XOPEN_UNIX             _SC_XOPEN_UNIX
_XOPEN_VERSION          _SC_XOPEN_VERSION

RETURN VALUE

    If name is an invalid value, sysconf() shall return -1 and set errno to
    indicate the error. If the variable corresponding to name has no limit,
    sysconf() shall return -1 without changing the value of errno. Note that
    indefinite limits do not imply infinite limits; see <limits.h>.

    Otherwise, sysconf() shall return the current variable value on the system.
    The value returned shall not be more restrictive than the corresponding
    value described to the application when it was compiled with the
    implementation's <limits.h> or <unistd.h>. The value shall not change
    during the lifetime of the calling process, except that
    sysconf(_SC_OPEN_MAX) may return different values before and after a call
    to setrlimit() which changes the RLIMIT_NOFILE soft limit.

    If the variable corresponding to name is dependent on an unsupported
    option, the results are unspecified.

ERRORS

    The sysconf() function shall fail if:
    [EINVAL]
        The value of the name argument is invalid.
*/

/* [ Specification is in the file sysconf_spec.seh ] */

/***/        #include "sysconf_spec.seh"          /***/


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __sysconf -- get configuration information at runtime

SYNOPSIS

    #include <unistd.h>

    long __sysconf(int name);

DESCRIPTION

    __sysconf() gets configuration information at runtime.

    __sysconf() is weak alias to sysconf().

    __sysconf() has the same specification as sysconf().

    __sysconf() is not in the source standard; it is only in the binary standard.

*/


#define sysconf_spec __sysconf_spec
/* [__sysconf_spec has EQUIVALENT SPECIFICATION: sysconf_spec] */

/* [ Specification in the file sysconf_spec.seh ] */
/***/       #include "sysconf_spec.seh"        /***/


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    confstr - get configurable variables

SYNOPSIS

    #include <unistd.h>

    size_t confstr(int name, char *buf, size_t len);

DESCRIPTION

    The confstr() function shall return configuration-defined string values.
    Its use and purpose are similar to sysconf(), but it is used where string
    values rather than numeric values are returned.

    The name argument represents the system variable to be queried. The
    implementation shall support the following name values, defined in
    <unistd.h>. It may support others:


    _CS_PATH
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LIBS
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS
    _CS_POSIX_V6_LP64_OFF64_CFLAGS
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS
    _CS_POSIX_V6_LP64_OFF64_LIBS
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS
    [XSI]
    _CS_XBS5_ILP32_OFF32_CFLAGS (LEGACY)
    _CS_XBS5_ILP32_OFF32_LDFLAGS (LEGACY)
    _CS_XBS5_ILP32_OFF32_LIBS (LEGACY)
    _CS_XBS5_ILP32_OFF32_LINTFLAGS (LEGACY)
    _CS_XBS5_ILP32_OFFBIG_CFLAGS (LEGACY)
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS (LEGACY)
    _CS_XBS5_ILP32_OFFBIG_LIBS (LEGACY)
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS (LEGACY)
    _CS_XBS5_LP64_OFF64_CFLAGS (LEGACY)
    _CS_XBS5_LP64_OFF64_LDFLAGS (LEGACY)
    _CS_XBS5_LP64_OFF64_LIBS (LEGACY)
    _CS_XBS5_LP64_OFF64_LINTFLAGS (LEGACY)
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS (LEGACY)
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS (LEGACY)
    _CS_XBS5_LPBIG_OFFBIG_LIBS (LEGACY)
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS (LEGACY)


    If len is not 0, and if name has a configuration-defined value, confstr()
    shall copy that value into the len-byte buffer pointed to by buf. If the
    string to be returned is longer than len bytes, including the terminating
    null, then confstr() shall truncate the string to len-1 bytes and
    null-terminate the result. The application can detect that the string was
    truncated by comparing the value returned by confstr() with len.

    If len is 0 and buf is a null pointer, then confstr() shall still return
    the integer value as defined below, but shall not return a string. If len
    is 0 but buf is not a null pointer, the result is unspecified.

    If the implementation supports the POSIX shell option, the string stored
    in buf after a call to:

        confstr(_CS_PATH, buf, sizeof(buf))


    can be used as a value of the PATH environment variable that accesses all
    of the standard utilities of IEEE Std 1003.1-2001, if the return value is
    less than or equal to sizeof( buf).

RETURN VALUE

    If name has a configuration-defined value, confstr() shall return the size
    of buffer that would be needed to hold the entire configuration-defined
    value including the terminating null. If this return value is greater than
    len, the string returned in buf is truncated.

    If name is invalid, confstr() shall return 0 and set errno to indicate the
    error.

    If name does not have a configuration-defined value, confstr() shall return
    0 and leave errno unchanged.

ERRORS

    The confstr() function shall fail if:

    [EINVAL]
        The value of the name argument is invalid.
*/

/* [Errno is assumed to be in/out parameter] */
specification
SizeT confstr_spec( CallContext context, IntT name, StringTPtr buf, SizeT len, ErrorCode * errno )
{
    CString * str_post;
    CByteArray * cba_post;
    CSData * val;
    SizeT wlen;
    CByteArray* atsign_block;

    pre
    {
        /* [Len is assumed to be not negative] */
        REQ("","len is assumed to be not negative", len>=0);

        /*  If len is 0 but buf is not a null pointer, the result is unspecified. */
        REQ("app.confstr.07","If len is 0 but buf is not a null pointer, the result is unspecified",
            !(len == 0 && !isNULL_VoidTPtr(buf))
            );

        /* [Consistency of test suite] */
        if(!isNULL_VoidTPtr(buf))
        {
            REQ("","Memory pointed to by buf is available in the context",
                isValidPointer(context, buf)
                );

            REQ("","Memory pointed to by buf is at least len bytes", sizeWMemoryAvailable(buf) >= len*sizeof_CharT);
        }


        if(!isNULL_VoidTPtr(buf))
        {
            /* [Saving the memory block for further comparing] */
            wlen = len * sizeof_CharT;
            atsign_block = readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(buf), buf,wlen);
        }
        else
        {
            /* [The case len!=0 & buf==NULL is not specified] */
            REQ("","The case len!=0 & buf==NULL isn't specified", len==0);
        }

        return true;
    }
    coverage C
    {

        val = get_Map(cs_name_map, create_IntTObj(name));

        if(val != NULL)
        {
            if(len==0 && isNULL_VoidTPtr(buf))
            {
                return { RequestLength, "Len==0, buf==NULL name is valid" };
            }

            if(val->str_size<=len)
            {
                return { Enough, "Buf is enough"};
            }
            else
            {
                return { NotEnough, "Buf is not enough, string shall be truncated"};
            }
        }
        else
        {
            if(len==0 && isNULL_VoidTPtr(buf))
            {
                return { RequestLengthInvName, "Len==0, buf==NULL, name is probably invalid" };
            }
            else
            {
                return { InvName, "Invalid name" };
            }
        }
    }
    post
    {
        if(!isNULL_VoidTPtr(buf))
        {
            /* [Other memory shall not be changed] */
            wlen = len * sizeof_CharT;
            REQ("","Other memory shall not be changed",
                equals( readCByteArray_MemoryBlockExceptFor(getTopMemoryBlock(buf), buf, wlen), atsign_block )
                );
        }

        val = get_Map(cs_name_map, create_IntTObj(name));

        /* If name is invalid, confstr() shall return 0
         * and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_CONFSTR, "confstr.10", confstr_spec == 0 && *errno != SUT_EOK, *errno )
            /*
             * The confstr() function shall fail if:
             * [EINVAL]
             *     The value of the name argument is invalid.
             */

            /* [LSB: 18.1.1. Special Requirements]
             * A value of -1 shall be an invalid "_CS_..." value for confstr().
             */

            ERROR_SHALL3(POSIX_CONFSTR, EINVAL,"confstr.12",
                         ((name == -1)?True_Bool3: Unknown_Bool3)
                        )

            /*
             * The confstr() function shall fail if:
             * [EINVAL]
             *      The value of the name argument is invalid.
             */
            /* {confstr.01}
             * The implementation shall support the following
             * name values, defined in <unistd.h>.
             */
            {
            ERROR_SHALL3( POSIX_CONFSTR, EINVAL,
                          ( val != NULL && val->req_id != NULL ? (char *)toCharArray_CString( val->req_id )
                                                               : "confstr.12.01;confstr.01"
                          ),
                          ( val != NULL && val->req_support ? False_Bool3 : Unknown_Bool3 )
            )
            }

        ERROR_END()

        if(confstr_spec == 0)
        {
            if( *errno == *@errno )
            {
                /* If len is 0 and buf is a null pointer, then
                 * confstr() shall still return the integer value as defined below,
                 * but shall not return a string.
                 */
                REQ("confstr.06","..shall still return the integer value..",
                    !(len==0 && isNULL_VoidTPtr(buf))
                   );

                /* If name does not have a configuration-defined
                 * value, confstr() shall return 0 and leave errno unchanged.
                 */
                REQ("confstr.11","If name does not have a configuration-defined, shall return 0 and leave errno unchanged",
                     true
                   );
                return true;
            }
        }
        else
        {   /* confstr_spec != 0 */

            /* [Negative result is illegal] */
            REQ("","Negative result is illegal", confstr_spec>0);


            if(!isNULL_VoidTPtr(buf))
            {
                /* [Reading result] */
                cba_post = readCByteArray_VoidTPtr( buf, len );
                str_post = readCString_VoidTPtr(buf);

                if( confstr_spec <= len )
                {   /* [String shall not be truncated] */

                    /* The application can detect that the string
                     * was truncated by comparing the value returned by confstr() with len.
                     */
                    REQ("app.confstr.05","String shall not be truncated",confstr_spec == length_CString(str_post)+1);
                }
                else
                {  /* [confstr_spec > len, string is truncated] */

                    /* If the string to be returned is longer than len bytes, including
                     * the terminating null, then confstr() shall truncate the string to
                     * len-1 bytes and null-terminate the result.
                     */
                    REQ("confstr.04","shall null-terminate the result", byteAt_CByteArray(cba_post,len-1) == 0)
                    REQ("confstr.04","shall truncate the string to len-1 bytes",
                        length_CString(str_post) == len-1
                       );

                    /* [compare with saved string] */
                    if(val != NULL)
                    {
                        if(val->str_size > 0 && val->str != NULL )
                        {
                            REQ("confstr.04","confstr() shall truncate the string to len-1 bytes",
                                equals(str_post,substring_CString(val->str,0,len-1))
                               );
                         }
                    }
                }
            }
            else
            {   /* [buf == NULL] */

                /* If len is 0 and buf is a null pointer, then
                 * confstr() shall still return the integer value as defined
                 * below, but shall not return a string.
                 */
                REQ("confstr.06","If len is 0 and buf is a null pointer",
                     len == 0
                   );
            }
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

  fpathconf, pathconf - get configurable pathname variables

SYNOPSIS

  #include <unistd.h>

  long fpathconf(int fildes, int name);
  long pathconf(const char *path, int name);

DESCRIPTION

  The fpathconf() and pathconf() functions shall determine the current value of
  a configurable limit or option (variable) that is associated with a file or
  directory.

  For pathconf(), the path argument points to the pathname of a file or
  directory.

  For fpathconf(), the fildes argument is an open file descriptor.

  The name argument represents the variable to be queried relative to that file
  or directory. Implementations shall support all of the variables listed in
  the following table and may support others. The variables in the following
  table come from <limits.h> or <unistd.h> and the symbolic constants, defined
  in <unistd.h>, are the corresponding values used for name.

Variable                    Value of name           Requirements

{FILESIZEBITS}              _PC_FILESIZEBITS        3,4
{LINK_MAX}                  _PC_LINK_MAX            1
{MAX_CANON}                 _PC_MAX_CANON           2
{MAX_INPUT}                 _PC_MAX_INPUT           2
{NAME_MAX}                  _PC_NAME_MAX            3,4
{PATH_MAX}                  _PC_PATH_MAX            4,5
{PIPE_BUF}                  _PC_PIPE_BUF            6
{POSIX2_SYMLINKS}           _PC_2_SYMLINKS          4
{POSIX_ALLOC_SIZE_MIN}      _PC_ALLOC_SIZE_MIN      10
{POSIX_REC_INCR_XFER_SIZE}  _PC_REC_INCR_XFER_SIZE  10
{POSIX_REC_MAX_XFER_SIZE}   _PC_REC_MAX_XFER_SIZE   10
{POSIX_REC_MIN_XFER_SIZE}   _PC_REC_MIN_XFER_SIZE   10
{POSIX_REC_XFER_ALIGN}      _PC_REC_XFER_ALIGN      10
{SYMLINK_MAX}               _PC_SYMLINK_MAX         4,9
_POSIX_CHOWN_RESTRICTED     _PC_CHOWN_RESTRICTED    7
_POSIX_NO_TRUNC             _PC_NO_TRUNC            3,4
_POSIX_VDISABLE             _PC_VDISABLE            2
_POSIX_ASYNC_IO             _PC_ASYNC_IO            8
_POSIX_PRIO_IO              _PC_PRIO_IO             8
_POSIX_SYNC_IO              _PC_SYNC_IO             8

Requirements

1.  If path or fildes refers to a directory, the value returned shall apply
    to the directory itself.
2.  If path or fildes does not refer to a terminal file, it is unspecified
    whether an implementation supports an association of the variable name with
    the specified file.
3.  If path or fildes refers to a directory, the value returned shall apply to
    filenames within the directory.
4.  If path or fildes does not refer to a directory, it is unspecified whether
    an implementation supports an association of the variable name with the
    specified file.
5.  If path or fildes refers to a directory, the value returned shall be the
    maximum length of a relative pathname when the specified directory is the
    working directory.
6.  If path refers to a FIFO, or fildes refers to a pipe or FIFO, the value
    returned shall apply to the referenced object. If path or fildes refers to
    a directory, the value returned shall apply to any FIFO that exists or can
    be created within the directory. If path or fildes refers to any other
    type of file, it is unspecified whether an implementation supports an
    association of the variable name with the specified file.
7.  If path or fildes refers to a directory, the value returned shall apply to
    any files, other than directories, that exist or can be created within the
    directory.
8.  If path or fildes refers to a directory, it is unspecified whether an
    implementation supports an association of the variable name with the
    specified file.
9.  If path or fildes refers to a directory, the value returned shall be the
    maximum length of the string that a symbolic link in that directory can
    contain.
10. If path or fildes des does not refer to a regular file, it is unspecified
    whether an implementation supports an association of the variable name with
    the specified file. If an implementation supports such an association for
    other than a regular file, the value returned is unspecified.

RETURN VALUE

    If name is an invalid value, both pathconf() and fpathconf() shall return
    -1 and set errno to indicate the error.

    If the variable corresponding to name has no limit for the path or file
    descriptor, both pathconf() and fpathconf() shall return -1 without
    changing errno. If the implementation needs to use path to determine the
    value of name and the implementation does not support the association of
    name with the file specified by path, or if the process did not have
    appropriate privileges to query the file specified by path, or path does
    not exist, pathconf() shall return -1 and set errno to indicate the error.

    If the implementation needs to use fildes to determine the value of name
    and the implementation does not support the association of name with the
    file specified by fildes, or if fildes is an invalid file descriptor,
    fpathconf() shall return -1 and set errno to indicate the error.

    Otherwise, pathconf() or fpathconf() shall return the current variable
    value for the file or directory without changing errno. The value returned
    shall not be more restrictive than the corresponding value available to
    the application when it was compiled with the implementation's <limits.h>
    or <unistd.h>.

    If the variable corresponding to name is dependent on an unsupported
    option, the results are unspecified.

ERRORS

    The pathconf() function shall fail if:

    [EINVAL]
        The value of name is not valid.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path argument.

    The pathconf() function may fail if:

    [EACCES]
        Search permission is denied for a component of the path prefix.
    [EINVAL]
        The implementation does not support an association of the variable name
        with the specified file.
    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path argument.
    [ENAMETOOLONG]
        The length of the path argument exceeds {PATH_MAX} or a pathname
        component is longer than {NAME_MAX}.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOENT]
        A component of path does not name an existing file or path is an empty
        string.
    [ENOTDIR]
        A component of the path prefix is not a directory.

    The fpathconf() function shall fail if:

    [EINVAL]
        The value of name is not valid.

    The fpathconf() function may fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [EINVAL]
        The implementation does not support an association of the variable name with the specified file.
*/

/* [Errno is assumed to be in/out parameter] */
specification
LongT pathconf_spec( CallContext context, CString * path, IntT name, ErrorCode * errno)
{
    pre
    {
         /*
         * If the variable corresponding to name is dependent on an unsupported option,
         * the results are unspecified.
         */
        REQ("app.fpathconf.07", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        PCData * pc_data;

        /* [LSB 18.1.1. Special Requirements]
         * A value of -1 shall be an invalid "_PC_..." value for pathconf()
         */
        if(name == -1)
        {
            REQ("pathconf.addntl_bhvr.01","A value of -1 shall be an invalid _PC_... value for pathconf()",
                pathconf_spec == -1 && *errno != *@errno );

            return true;
        }

        ERROR_BEGIN(POSIX_PATHCONF, "pathconf.04", (pathconf_spec==-1)&&(*errno!=SUT_EOK), *errno)
        /*
         * The pathconf() function shall fail if:
         * [EINVAL]
         *      The value of name is not valid.
         */
            ERROR_SHALL(POSIX_PATHCONF, EINVAL, "pathconf.08.01", TODO_ERR(EINVAL))

        /*
         * The pathconf() function shall fail if:
         * [ELOOP]
         *      A loop exists in symbolic links encountered during resolution of the path
         * argument.
         */
            ERROR_SHALL(POSIX_PATHCONF, ELOOP, "pathconf.08.02", TODO_ERR(ELOOP))

        /*
         * The pathconf() function may fail if:
         * [EACCES]
         *      Search permission is denied for a component of the path prefix.
         */
            ERROR_MAY(POSIX_PATHCONF, EACCES, "pathconf.09.01", TODO_ERR(EACCES))

        /*
         * The pathconf() function may fail if:
         * [EINVAL]
         *      The implementation does not support an association of the variable name with
         * the specified file.
         */
            ERROR_MAY(POSIX_PATHCONF, EINVAL, "pathconf.09.02", TODO_ERR(EINVAL))

        /*
         * The pathconf() function may fail if:
         * [ELOOP]
         *      More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
         * the path argument.
         */
            ERROR_MAY(POSIX_PATHCONF, ELOOP, "pathconf.09.03", TODO_ERR(ELOOP))

        /*
         * The pathconf() function may fail if:
         * [ENAMETOOLONG]
         *      The length of the path argument exceeds {PATH_MAX} or a pathname component is
         * longer than {NAME_MAX}.
         */
            ERROR_MAY(POSIX_PATHCONF, ENAMETOOLONG, "pathconf.09.04", TODO_ERR(ENAMETOOLONG))

        /*
         * The pathconf() function may fail if:
         * [ENAMETOOLONG]
         *      As a result of encountering a symbolic link in resolution of the path argument,
         * the length of the substituted pathname string exceeded {PATH_MAX}.
         */
            ERROR_MAY(POSIX_PATHCONF, ENAMETOOLONG, "pathconf.09.05", TODO_ERR(ENAMETOOLONG))

        /*
         * The pathconf() function may fail if:
         * [ENOENT]
         *      A component of path does not name an existing file or path is an empty string.
         */
            ERROR_MAY(POSIX_PATHCONF, ENOENT, "pathconf.09.06", TODO_ERR(ENOENT))

        /*
         * The pathconf() function may fail if:
         * [ENOTDIR]
         *      A component of the path prefix is not a directory.
         */
            ERROR_MAY(POSIX_PATHCONF, ENOTDIR, "pathconf.09.07", TODO_ERR(ENOTDIR))

        ERROR_END()


        // successful branch

        /* Otherwise, pathconf() or fpathconf() shall return the current
         * variable value for the file or directory without changing errno.
         */
        REQ("pathconf.04.03;fpathconf.04.03","Shall not change errno",*errno == *@errno);

        /* {pathconf.02} Implementations shall support all of the variables listed
         * in the following table and may support others.
         */
        // todo: throw IDs: .->pc_name_req_id

        pc_data = get_Map(pc_map,create_IntTObj(name));
        if(pc_data != NULL)
        {
            /* The value returned shall not be more restrictive than the
             * corresponding value available to the application when it was
             * compiled with the implementation's <limits.h> or <unistd.h>.
             */
            // todo: throw IDs: "pathconf.06" (shall not be more restrictive)
            //                  .->pc_lim_req_id
            switch(pc_data->pc_cmp_type)
            {
            case CMPT_MIN:
                REQ("",
                    "Minimum acceptable value",
                    (pathconf_spec>=pc_data->pc_lim)||(pathconf_spec==-1)
                   );
                break;
            case CMPT_EQORM1:
                REQ("",
                    "Equals or -1",
                    (pathconf_spec==pc_data->pc_lim) || (pathconf_spec==-1)
                   );
                break;
            case CMPT_EQUALS:
                REQ("",
                    "Equals",
                    pathconf_spec==pc_data->pc_lim
                   );
                break;
            case CMPT_NO:
                /* [no restrictions on the returned value] */
                break;
            case CMPT_UNKN:
                 /* [not specified value] */
                 /* and may support others. */
                REQ("pathconf.12;   ","may support others",true);
                break;
            default:
                 traceUserInfo("Unhandled CmpT");
                 return false;
            }

            /* Requirements 1..10 */
            // todo: throw IDs: .->pc_req_id
            if(pc_data->pc_reqs | PC_REQ1)
            {
                /* If path or fildes refers to a directory, the value returned shall
                 * apply to the directory itself.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ2)
            {
                /*  If path or fildes does not refer to a terminal file, it is unspecified
                 * whether an implementation supports an association of the variable name
                 * with the specified file.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ3)
            {
                /* If path or fildes refers to a directory, the value returned shall
                 * apply to filenames within the directory.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ4)
            {
                /*  If path or fildes does not refer to a directory, it is unspecified
                 * whether an implementation supports an association of the variable
                 * name with the specified file.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ5)
            {
                /* If path or fildes refers to a directory, the value returned shall be the
                 * maximum length of a relative pathname when the specified directory is
                 * the working directory.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ6)
            {
                /* If path refers to a FIFO, or fildes refers to a pipe or FIFO, the value
                 * returned shall apply to the referenced object. If path or fildes refers
                 * to a directory, the value returned shall apply to any FIFO that exists
                 * or can be created within the directory. If path or fildes refers to any
                 * other type of file, it is unspecified whether an implementation supports
                 * an association of the variable name with the specified file.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ7)
            {
                /* If path or fildes refers to a directory, the value returned shall apply
                 * to any files, other than directories, that exist or can be created within
                 * the directory.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ8)
            {
                /* If path or fildes refers to a directory, it is unspecified whether an
                 * implementation supports an association of the variable name with the
                 * specified file.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ9)
            {
                /* If path or fildes refers to a directory, the value returned shall be
                 * the maximum length of the string that a symbolic link in that directory
                 * can contain.
                 */
                TODO_REQ();
            }
            if(pc_data->pc_reqs | PC_REQ10)
            {
                /* If path or fildes des does not refer to a regular file, it is unspecified
                 * whether an implementation supports an association of the variable name with
                 * the specified file. If an implementation supports such an association for
                 * other than a regular file, the value returned is unspecified.
                 */
                TODO_REQ();
            }

        }

        return true;
    }
}

specification
LongT fpathconf_spec( CallContext context, FileDescId fildes, IntT name, ErrorCode * errno  )
{
  pre
  {
    return true;
  }
  coverage C
  {
    return { TheOnlyBranch, "The only branch" };
  }
  post
  {
    return true;
  }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    getpagesize - get the current page size (LEGACY)

SYNOPSIS

    #include <unistd.h>

    int getpagesize(void);

DESCRIPTION

    The getpagesize() function returns the current page size.

    The getpagesize() function is equivalent to sysconf(_SC_PAGE_SIZE) and
    sysconf(_SC_PAGESIZE).

    This interface need not be reentrant.

RETURN VALUE

    The getpagesize() function returns the current page size.

ERRORS

    No errors are defined.

EXAMPLES

    None.

APPLICATION USAGE

    The value returned by getpagesize() need not be the minimum value that
    malloc() can allocate. Moreover, the application cannot assume that an
    object of this size can be allocated with malloc().

    This interface, returning an int, may have problems representing
    appropriate values in the future. Applications should use the sysconf()
    function instead.
*/

/* The getpagesize() function is equivalent to sysconf(_SC_PAGE_SIZE) and
 * sysconf(_SC_PAGESIZE).
 */

/* __getpagesize -- alias for getpagesize */
/* START EQUIVALENT SPECIFICATION: __getpagesize */

specification
IntT getpagesize_spec( CallContext context, ErrorCode * errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        LongT Res;
        SCData * data = getSCData(SUT_SC_PAGE_SIZE);

        /* If name is an invalid value, sysconf() shall
         * return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_SYSCONF, "getpagesize.sysconf.02", getpagesize_spec == -1 && *errno != *@errno , *errno)

            /*[ According to sysconf() specification, getpagesize_spec() shall
             * never return EINVAL, because _SC_PAGE_SIZE name shall be supported ]
             */

            ERROR_NEVER(POSIX_SYSCONF, EINVAL,"getpagesize.sysconf.01.95")
        ERROR_END()

        /* The getpagesize() function is equivalent to
         * sysconf(_SC_PAGE_SIZE) and sysconf(_SC_PAGESIZE)
         */
        Res = getSystemConfigurationValue(context, SUT_SC_PAGE_SIZE);
        if( Res != SC_VALUE_UNKNOWN)
        {
            REQ("getpagesize.12",
                "The getpagesize() function is equivalent to sysconf(_SC_PAGE_SIZE) and sysconf(_SC_PAGESIZE)",
                getpagesize_spec == Res );
        }
        Res = getSystemConfigurationValue(context, SUT_SC_PAGESIZE);
        if( Res != SC_VALUE_UNKNOWN)
        {
            REQ("getpagesize.12",
                "The getpagesize() function is equivalent to sysconf(_SC_PAGE_SIZE) and sysconf(_SC_PAGESIZE)",
                getpagesize_spec == Res );
        }

        return true;
    }
}
/* END EQUIVALENT SPECIFICATION: __getpagesize */

/* REFERENCES: __getpagesize() refers the getpagesize() */
/* __getpagesize() has the same specification as getpagesize() */
specification
IntT __getpagesize_spec( CallContext context, ErrorCode * errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        LongT Res;
        SCData * data = getSCData(SUT_SC_PAGE_SIZE);

        /* If name is an invalid value, sysconf() shall
         * return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_SYSCONF, "__getpagesize.sysconf.02", __getpagesize_spec == -1 && *errno != *@errno , *errno)

            /*[ According to sysconf() specification, getpagesize_spec() shall
             * never return EINVAL, because _SC_PAGE_SIZE name shall be supported ]
             */

            ERROR_NEVER(POSIX_SYSCONF, EINVAL,"__getpagesize.sysconf.01.95")
        ERROR_END()

        /* __getpagesize -- alias for getpagesize
        /* The getpagesize() function is equivalent to
         * sysconf(_SC_PAGE_SIZE) and sysconf(_SC_PAGESIZE)
         */
        Res = getSystemConfigurationValue(context, SUT_SC_PAGE_SIZE);
        if( Res != SC_VALUE_UNKNOWN)
        {
            REQ("getpagesize.12",
                "The __getpagesize() function is equivalent to sysconf(_SC_PAGE_SIZE) and sysconf(_SC_PAGESIZE)",
                __getpagesize_spec == Res );
        }
        Res = getSystemConfigurationValue(context, SUT_SC_PAGESIZE);
        if( Res != SC_VALUE_UNKNOWN)
        {
            REQ("getpagesize.12",
                "The __getpagesize() function is equivalent to sysconf(_SC_PAGE_SIZE) and sysconf(_SC_PAGESIZE)",
                __getpagesize_spec == Res );
        }

        return true;
    }
}

/********************************************************************/
/**                             Data                               **/
/********************************************************************/

Map * sc_map; // name -m-> SCData;
specification typedef struct SCData SCData = {};


Map * cs_name_map;
specification typedef struct CSData CSData = {};

Map * pc_map;
specification typedef struct PCData PCData = {};

PCData * create_PCData(CString * pc_name_req_id, LongT pc_lim, CmpT pc_cmp_type,
                       CString * pc_lim_req_id, IntT pc_reqs, CString * pc_req_id)
{
    return (PCData *)create_Object(&type_PCData, pc_name_req_id, pc_lim, pc_cmp_type, pc_lim_req_id, pc_reqs, pc_req_id);
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool POSIX_OPTION(CallContext context, Posix_Option opt)
{
    switch(opt)
    {
    case ADV:
        return (getSystemConfigurationValue(context,SUT_SC_ADVISORY_INFO)>0);
        break;
    case AIO:
        return (getSystemConfigurationValue(context,SUT_SC_ASYNCHRONOUS_IO)>0);
        break;
    case BAR:
        return (getSystemConfigurationValue(context,SUT_SC_BARRIERS)>0);
        break;
    case CS:
        return (getSystemConfigurationValue(context,SUT_SC_CLOCK_SELECTION)>0);
        break;
    case CPT:
        return (getSystemConfigurationValue(context,SUT_SC_CPUTIME)>0);
        break;
    case MSG_:
        return (getSystemConfigurationValue(context,SUT_SC_MESSAGE_PASSING)>0);
        break;
    case MON:
        return (getSystemConfigurationValue(context,SUT_SC_MONOTONIC_CLOCK)>0);
        break;
    case PIO:
        return (getSystemConfigurationValue(context,SUT_SC_PRIORITIZED_IO)>0);
        break;
    case THR:
        return (getSystemConfigurationValue(context,SUT_SC_READER_WRITER_LOCKS)>0);
        break;
    case SPN:
        return (getSystemConfigurationValue(context,SUT_SC_SPAWN)>0);
        break;
    case SPI:
        return (getSystemConfigurationValue(context,SUT_SC_SPIN_LOCKS)>0);
        break;
    case SS:
        return (getSystemConfigurationValue(context,SUT_SC_SPORADIC_SERVER)>0);
        break;
    case SIO:
        return (getSystemConfigurationValue(context,SUT_SC_SYNCHRONIZED_IO)>0);
        break;
    case TCT:
        return (getSystemConfigurationValue(context,SUT_SC_THREAD_CPUTIME)>0);
        break;
    case TPI:
        return (getSystemConfigurationValue(context,SUT_SC_THREAD_PRIO_INHERIT)>0);
        break;
    case TPP:
        return (getSystemConfigurationValue(context,SUT_SC_THREAD_PRIO_PROTECT)>0);
        break;
    case TPS:
        return (getSystemConfigurationValue(context,SUT_SC_THREAD_PRIORITY_SCHEDULING)>0);
        break;
    case TSP:
        return (getSystemConfigurationValue(context,SUT_SC_THREAD_SPORADIC_SERVER)>0);
        break;
    case TMO:
        return (getSystemConfigurationValue(context,SUT_SC_TIMEOUTS)>0);
        break;
    case TRC:
        return (getSystemConfigurationValue(context,SUT_SC_TRACE)>0);
        break;
    case TEF:
        return (getSystemConfigurationValue(context,SUT_SC_TRACE_EVENT_FILTER)>0);
        break;
    case TRI:
        return (getSystemConfigurationValue(context,SUT_SC_TRACE_INHERIT)>0);
        break;
    case TRL:
        return (getSystemConfigurationValue(context,SUT_SC_TRACE_LOG)>0);
        break;
    case TYM:
        return (getSystemConfigurationValue(context,SUT_SC_TYPED_MEMORY_OBJECTS)>0);
        break;
    case CD:
        return (getSystemConfigurationValue(context,SUT_SC_2_C_DEV)>0);
        break;
    case FD:
        return (getSystemConfigurationValue(context,SUT_SC_2_FORT_DEV)>0);
        break;
    case FR:
        return (getSystemConfigurationValue(context,SUT_SC_2_FORT_RUN)>0);
        break;
    case UP:
        return (getSystemConfigurationValue(context,SUT_SC_2_UPE)>0);
        break;
    case XSI:
        return (getSystemConfigurationValue(context,SUT_SC_XOPEN_UNIX)>0);
        break;
    case RS:
    case IP6:
    case BE:
        return false;
        break;
    case SEM:
    case SHM:
    case TMR:
    case FSC:
    case MF:
    case ML:
    case MR:
    case MPR:
    case THR_:
    case PS:
    case RTS:
    case TSA:
    case TSS:
    case TSH:
    case TSF:
        return true;
        break;
    default:;
    }

    return false;
}

CSData * create_CSData( IntT req_support, CString * req_id, SizeT str_size, CString * str )
{
    return create(&type_CSData, req_support, req_id, str_size, str);
}

SCData * create_SCData(CString * req_id, LongT sc_lim, CmpT cmp_type, CString * lim_id)
{
    return create(&type_SCData, req_id, sc_lim, cmp_type, lim_id);
}

SCData * getSCData(IntT name)
{
    return (SCData *)get_Map(sc_map,create_IntTObj(name));
}



bool init_sc()
{
    sc_map = create_Map(&type_IntTObj,&type_SCData);

#define PUT_SC_MAP(name,reqname_id,sc_lim,cmp_type,limit_id) \
    put_Map(sc_map,create_IntTObj(name),  \
            create_SCData(create_CString(reqname_id), sc_lim, cmp_type, create_CString(limit_id)) \
           )


    PUT_SC_MAP(SUT_SC_AIO_LISTIO_MAX,   "sysconf.01.01",    SUT_POSIX_AIO_LISTIO_MAX,   CMPT_MIN,   "limits.1;limits.60");
    PUT_SC_MAP(SUT_SC_AIO_MAX,  "sysconf.01.02",    SUT_POSIX_AIO_MAX,  CMPT_MIN,   "limits.2;limits.61");
    PUT_SC_MAP(SUT_SC_AIO_PRIO_DELTA_MAX,   "sysconf.01.03",    0,  CMPT_MIN,   "limits.3");
    PUT_SC_MAP(SUT_SC_ARG_MAX,  "sysconf.01.04",    SUT_POSIX_ARG_MAX,  CMPT_MIN,   "limits.4;limits.62");
    PUT_SC_MAP(SUT_SC_ATEXIT_MAX,   "sysconf.01.05",    32, CMPT_MIN,   "limits.5");
    PUT_SC_MAP(SUT_SC_BC_BASE_MAX,  "sysconf.01.06",    SUT_POSIX2_BC_BASE_MAX, CMPT_MIN,   "limits.49;limits.98");
    PUT_SC_MAP(SUT_SC_BC_DIM_MAX,   "sysconf.01.07",    SUT_POSIX2_BC_DIM_MAX,  CMPT_MIN,   "limits.50;limits.99");
    PUT_SC_MAP(SUT_SC_BC_SCALE_MAX, "sysconf.01.08",    SUT_POSIX2_BC_SCALE_MAX,    CMPT_MIN,   "limits.51;limits.100");
    PUT_SC_MAP(SUT_SC_BC_STRING_MAX,    "sysconf.01.09",    SUT_POSIX2_BC_STRING_MAX,   CMPT_MIN,   "limits.52;limits.101");
    PUT_SC_MAP(SUT_SC_CHILD_MAX,    "sysconf.01.10",    SUT_POSIX_CHILD_MAX,    CMPT_MIN,   "limits.6;limits.63");
    PUT_SC_MAP(SUT_SC_CLK_TCK,  "sysconf.01.11",    0,  CMPT_MIN,   "implicit");
    PUT_SC_MAP(SUT_SC_COLL_WEIGHTS_MAX, "sysconf.01.12",    SUT_POSIX2_COLL_WEIGHTS_MAX,    CMPT_MIN,   "limits.54;limits.103");
    PUT_SC_MAP(SUT_SC_DELAYTIMER_MAX,   "sysconf.01.13",    SUT_POSIX_DELAYTIMER_MAX,   CMPT_MIN,   "limits.7;limits.64");
    PUT_SC_MAP(SUT_SC_EXPR_NEST_MAX,    "sysconf.01.14",    SUT_POSIX2_EXPR_NEST_MAX,   CMPT_MIN,   "limits.55;limits.104");
// fails
    if(POSIX_SYSCONF_ANOTHER_MIN_VALUE_HOST_NAME_MAX > 0)
        PUT_SC_MAP(SUT_SC_HOST_NAME_MAX,    "sysconf.01.15",    POSIX_SYSCONF_ANOTHER_MIN_VALUE_HOST_NAME_MAX,  CMPT_MIN,   "no_id(bug)");
    else
        PUT_SC_MAP(SUT_SC_HOST_NAME_MAX,    "sysconf.01.15",    SUT_POSIX_HOST_NAME_MAX ,   CMPT_MIN,   "limits.8;limits.65");
    PUT_SC_MAP(SUT_SC_IOV_MAX,  "sysconf.01.16",    SUT_XOPEN_IOV_MAX,  CMPT_MIN,   "limits.9;limits.107");
    PUT_SC_MAP(SUT_SC_LINE_MAX, "sysconf.01.17",    SUT_POSIX2_LINE_MAX,    CMPT_MIN,   "limits.56;limits.105");
    PUT_SC_MAP(SUT_SC_LOGIN_NAME_MAX,   "sysconf.01.18",    SUT_POSIX_LOGIN_NAME_MAX,   CMPT_MIN,   "limits.10;limits.67");
    PUT_SC_MAP(SUT_SC_NGROUPS_MAX,  "sysconf.01.19",    SUT_POSIX_NGROUPS_MAX,  CMPT_MIN,   "limits.57;limits.73");
    PUT_SC_MAP(SUT_SC_GETGR_R_SIZE_MAX, "sysconf.01.20",    0,  CMPT_MIN,   "implicit");
    PUT_SC_MAP(SUT_SC_GETPW_R_SIZE_MAX, "sysconf.01.21",    0,  CMPT_MIN,   "implicit");
    PUT_SC_MAP(SUT_SC_MQ_OPEN_MAX,  "sysconf.01.22",    SUT_POSIX_MQ_OPEN_MAX,  CMPT_MIN,   "limits.11;limits.70");
    PUT_SC_MAP(SUT_SC_MQ_PRIO_MAX,  "sysconf.01.23",    SUT_POSIX_MQ_PRIO_MAX,  CMPT_MIN,   "limits.12;limits.71");
    PUT_SC_MAP(SUT_SC_OPEN_MAX, "sysconf.01.24",    SUT_POSIX_OPEN_MAX, CMPT_MIN,   "limits.13;limits.74");
    PUT_SC_MAP(SUT_SC_ADVISORY_INFO,    "sysconf.01.25",    200112L,    CMPT_EQORM1,    "unistd.01");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_BARRIERS, "sysconf.01.26",    200112L,    CMPT_EQORM1,    "unistd.03");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_ASYNCHRONOUS_IO,  "sysconf.01.27",    200112L,    CMPT_EQORM1,    "unistd.02");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_CLOCK_SELECTION,  "sysconf.01.28",    200112L,    CMPT_EQORM1,    "unistd.05");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_CPUTIME,  "sysconf.01.29",    200112L,    CMPT_EQORM1,    "unistd.06");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_FSYNC,    "sysconf.01.30",    200112L,    CMPT_EQUALS,    "unistd.07");   /* [FSC] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_JOB_CONTROL,  "sysconf.01.32",    1,  CMPT_MIN,   "unistd.09");
    PUT_SC_MAP(SUT_SC_MAPPED_FILES, "sysconf.01.33",    200112L,    CMPT_EQUALS,    "unistd.10");   /* [MF] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_MEMLOCK,  "sysconf.01.34",    200112L,    CMPT_EQUALS,    "unistd.11");   /* [ML] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_MEMLOCK_RANGE,    "sysconf.01.35",    200112L,    CMPT_EQUALS,    "unistd.12");   /* [MR] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_MEMORY_PROTECTION,    "sysconf.01.36",    200112L,    CMPT_EQUALS,    "unistd.13");   /* [MPR] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_MESSAGE_PASSING,  "sysconf.01.37",    200112L,    CMPT_EQORM1,    "unistd.14");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_MONOTONIC_CLOCK,  "sysconf.01.38",    200112L,    CMPT_EQORM1,    "unistd.15");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_PRIORITIZED_IO,   "sysconf.01.39",    200112L,    CMPT_EQORM1,    "unistd.17");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_PRIORITY_SCHEDULING,  "sysconf.01.40",    200112L,    CMPT_EQUALS,    "unistd.18");   /* [PS] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_READER_WRITER_LOCKS,  "sysconf.01.42",    200112L,    CMPT_EQORM1,    "unistd.20");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_REALTIME_SIGNALS, "sysconf.01.43",    200112L,    CMPT_EQUALS,    "unistd.21");   /* [RTS] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_REGEXP,   "sysconf.01.44",    1,  CMPT_MIN,   "unistd.22");
    PUT_SC_MAP(SUT_SC_SAVED_IDS,    "sysconf.01.45",    1,  CMPT_MIN,   "unistd.23");
    PUT_SC_MAP(SUT_SC_SEMAPHORES,   "sysconf.01.46",    200112L,    CMPT_EQUALS,    "unistd.24");   /* [SEM] */ /* LSB (unistd.h) */
    PUT_SC_MAP(SUT_SC_SHARED_MEMORY_OBJECTS,    "sysconf.01.47",    200112L,    CMPT_EQUALS,    "unistd.25");   /* [SHM] */ /* LSB (unistd.h) */
    PUT_SC_MAP(SUT_SC_SHELL,    "sysconf.01.48",    1,  CMPT_MIN,   "unistd.26");
    PUT_SC_MAP(SUT_SC_SPAWN,    "sysconf.01.49",    200112L,    CMPT_EQORM1,    "unistd.27");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_SPIN_LOCKS,   "sysconf.01.50",    200112L,    CMPT_EQORM1,    "unistd.28");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_SPORADIC_SERVER,  "sysconf.01.51",    200112L,    CMPT_EQORM1,    "unistd.29");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_SYNCHRONIZED_IO,  "sysconf.01.53",    200112L,    CMPT_EQORM1,    "unistd.30");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_THREAD_ATTR_STACKADDR,    "sysconf.01.54",    200112L,    CMPT_EQUALS,    "unistd.31");   /* [TSA] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_THREAD_ATTR_STACKSIZE,    "sysconf.01.55",    200112L,    CMPT_EQUALS,    "unistd.32");   /* [TSS] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_THREAD_CPUTIME,   "sysconf.01.56",    200112L,    CMPT_EQORM1,    "unistd.33");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_THREAD_PRIO_INHERIT,  "sysconf.01.57",    200112L,    CMPT_EQORM1,    "unistd.34");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_THREAD_PRIO_PROTECT,  "sysconf.01.58",    200112L,    CMPT_EQORM1,    "unistd.35");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_THREAD_PRIORITY_SCHEDULING,   "sysconf.01.59",    200112L,    CMPT_EQORM1,    "unistd.36");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_THREAD_PROCESS_SHARED,    "sysconf.01.60",    200112L,    CMPT_EQUALS,    "unistd.37");   /* [TSH] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_THREAD_SAFE_FUNCTIONS,    "sysconf.01.61",    200112L,    CMPT_EQUALS,    "unistd.38");   /* [TSF] */ /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_THREAD_SPORADIC_SERVER,   "sysconf.01.62",    200112L,    CMPT_EQORM1,    "unistd.39");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_THREADS,  "sysconf.01.63",    200112L,    CMPT_EQUALS,    "unistd.40");   /* LSB 18.1 */
    PUT_SC_MAP(SUT_SC_TIMEOUTS, "sysconf.01.64",    200112L,    CMPT_EQORM1,    "unistd.41");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_TIMERS,   "sysconf.01.65",    200112L,    CMPT_EQUALS,    "unistd.42");   /* LSB (unistd.h) */
    PUT_SC_MAP(SUT_SC_TRACE,    "sysconf.01.66",    200112L,    CMPT_EQORM1,    "unistd.43");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_TRACE_EVENT_FILTER,   "sysconf.01.67",    200112L,    CMPT_EQORM1,    "unistd.44");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_TRACE_INHERIT,    "sysconf.01.69",    200112L,    CMPT_EQORM1,    "unistd.45");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_TRACE_LOG,    "sysconf.01.70",    200112L,    CMPT_EQORM1,    "unistd.46");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_TYPED_MEMORY_OBJECTS, "sysconf.01.74",    200112L,    CMPT_EQORM1,    "unistd.47");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_VERSION,  "sysconf.01.75",    200112L,    CMPT_EQUALS,    "unistd.83");
    PUT_SC_MAP(SUT_SC_V6_ILP32_OFF32,   "sysconf.01.76",    -1, CMPT_MIN,   "unistd.63");
    PUT_SC_MAP(SUT_SC_V6_ILP32_OFFBIG,  "sysconf.01.77",    -1, CMPT_MIN,   "unistd.64");
    PUT_SC_MAP(SUT_SC_V6_LP64_OFF64,    "sysconf.01.78",    -1, CMPT_MIN,   "unistd.65");
    PUT_SC_MAP(SUT_SC_V6_LPBIG_OFFBIG,  "sysconf.01.79",    -1, CMPT_MIN,   "unistd.66");
    PUT_SC_MAP(SUT_SC_2_C_BIND, "sysconf.01.80",    200112L,    CMPT_EQUALS,    "unistd.49");
    PUT_SC_MAP(SUT_SC_2_C_DEV,  "sysconf.01.81",    200112L,    CMPT_EQORM1,    "unistd.50");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_CHAR_TERM,  "sysconf.01.82",    -1, CMPT_MIN,   "unistd.51");
    PUT_SC_MAP(SUT_SC_2_FORT_DEV,   "sysconf.01.83",    200112L,    CMPT_EQORM1,    "unistd.52");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_FORT_RUN,   "sysconf.01.84",    200112L,    CMPT_EQORM1,    "unistd.53");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_LOCALEDEF,  "sysconf.01.85",    200112L,    CMPT_EQORM1,    "unistd.54");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_PBS_ACCOUNTING, "sysconf.01.87",    200112L,    CMPT_EQORM1,    "unistd.56");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_PBS_CHECKPOINT, "sysconf.01.88",    200112L,    CMPT_EQORM1,    "unistd.57");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_PBS_LOCATE, "sysconf.01.89",    200112L,    CMPT_EQORM1,    "unistd.58");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_PBS_MESSAGE,    "sysconf.01.90",    200112L,    CMPT_EQORM1,    "unistd.59");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_PBS_TRACK,  "sysconf.01.91",    200112L,    CMPT_EQORM1,    "unistd.60");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_SW_DEV, "sysconf.01.92",    200112L,    CMPT_EQORM1,    "unistd.61");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_UPE,    "sysconf.01.93",    200112L,    CMPT_EQORM1,    "unistd.62");   /*[EQUALS OR -1]*/
    PUT_SC_MAP(SUT_SC_2_VERSION,    "sysconf.01.94",    200112L,    CMPT_EQUALS,    "unistd.84");
    PUT_SC_MAP(SUT_SC_PAGE_SIZE,    "sysconf.01.95",    1,  CMPT_MIN,   "limits.15;unistd.85"); /* Equivalent PAGESIZE */
    PUT_SC_MAP(SUT_SC_PAGESIZE, "sysconf.01.96",    1,  CMPT_MIN,   "limits.14;unistd.85");
    PUT_SC_MAP(SUT_SC_THREAD_DESTRUCTOR_ITERATIONS, "sysconf.01.97",    SUT_POSIX_THREAD_DESTRUCTOR_ITERATIONS, CMPT_MIN,   "limits.16;limits.87");
    PUT_SC_MAP(SUT_SC_THREAD_KEYS_MAX,  "sysconf.01.98",    SUT_POSIX_THREAD_KEYS_MAX,  CMPT_MIN,   "limits.17;limits.88");
    PUT_SC_MAP(SUT_SC_THREAD_STACK_MIN, "sysconf.01.99",    0,  CMPT_MIN,   "limits.18");
    PUT_SC_MAP(SUT_SC_THREAD_THREADS_MAX,   "sysconf.01.100",   SUT_POSIX_THREAD_THREADS_MAX,   CMPT_MIN,   "limits.19;limits.89");
    PUT_SC_MAP(SUT_SC_RE_DUP_MAX,   "sysconf.01.101",   SUT_POSIX2_RE_DUP_MAX,  CMPT_MIN,   "limits.58;limits.106");
    PUT_SC_MAP(SUT_SC_RTSIG_MAX,    "sysconf.01.102",   SUT_POSIX_RTSIG_MAX,    CMPT_MIN,   "limits.21;limits.78");
    PUT_SC_MAP(SUT_SC_SEM_NSEMS_MAX,    "sysconf.01.103",   SUT_POSIX_SEM_NSEMS_MAX,    CMPT_MIN,   "limits.22;limits.79");
    PUT_SC_MAP(SUT_SC_SEM_VALUE_MAX,    "sysconf.01.104",   SUT_POSIX_SEM_VALUE_MAX,    CMPT_MIN,   "limits.23;limits.80");
    // fails
    //PUT_SC_MAP(SUT_SC_SIGQUEUE_MAX,   "sysconf.01.105",   SUT_POSIX_SIGQUEUE_MAX, CMPT_MIN,   "limits.24;limits.81");
    PUT_SC_MAP(SUT_SC_STREAM_MAX,   "sysconf.01.106",   SUT_POSIX_STREAM_MAX,   CMPT_MIN,   "limits.26;limits.83");
    PUT_SC_MAP(SUT_SC_SYMLOOP_MAX,  "sysconf.01.107",   SUT_POSIX_SYMLOOP_MAX,  CMPT_MIN,   "limits.27;limits.86");
    PUT_SC_MAP(SUT_SC_TIMER_MAX,    "sysconf.01.108",   SUT_POSIX_TIMER_MAX,    CMPT_MIN,   "limits.28;limits.90");
    PUT_SC_MAP(SUT_SC_TTY_NAME_MAX, "sysconf.01.109",   SUT_POSIX_TTY_NAME_MAX, CMPT_MIN,   "limits.33;limits.95");
    PUT_SC_MAP(SUT_SC_TZNAME_MAX,   "sysconf.01.110",   SUT_POSIX_TZNAME_MAX,   CMPT_MIN,   "limits.34;limits.96");
    PUT_SC_MAP(SUT_SC_XBS5_ILP32_OFF32, "sysconf.01.111",   -1, CMPT_MIN,   "unistd.67");
    PUT_SC_MAP(SUT_SC_XBS5_ILP32_OFFBIG,    "sysconf.01.112",   -1, CMPT_MIN,   "unistd.68");
    PUT_SC_MAP(SUT_SC_XBS5_LP64_OFF64,  "sysconf.01.113",   -1, CMPT_MIN,   "unistd.69");
    PUT_SC_MAP(SUT_SC_XBS5_LPBIG_OFFBIG,    "sysconf.01.114",   -1, CMPT_MIN,   "unistd.70");
    PUT_SC_MAP(SUT_SC_XOPEN_CRYPT,  "sysconf.01.115",   -1, CMPT_MIN,   "unistd.71");
    PUT_SC_MAP(SUT_SC_XOPEN_ENH_I18N,   "sysconf.01.116",   -1, CMPT_MIN,   "unistd.72");
    PUT_SC_MAP(SUT_SC_XOPEN_LEGACY, "sysconf.01.117",   -1, CMPT_MIN,   "unistd.73");
    PUT_SC_MAP(SUT_SC_XOPEN_REALTIME,   "sysconf.01.118",   -1, CMPT_MIN,   "unistd.74");
    PUT_SC_MAP(SUT_SC_XOPEN_REALTIME_THREADS,   "sysconf.01.119",   -1, CMPT_MIN,   "unistd.75");
    PUT_SC_MAP(SUT_SC_XOPEN_SHM,    "sysconf.01.120",   -1, CMPT_MIN,   "unistd.76");
    PUT_SC_MAP(SUT_SC_XOPEN_UNIX,   "sysconf.01.122",   -1, CMPT_MIN,   "unistd.78");
    PUT_SC_MAP(SUT_SC_XOPEN_VERSION,    "sysconf.01.123",   -1, CMPT_MIN,   "unistd.82");

    /* [following names are defined in POSIX, but not defined in LSB] */
    //PUT_SC_MAP(SUT_SC_XOPEN_STREAMS,  "sysconf.01.121",   -1, CMPT_MIN,   "unistd.77");
    //PUT_SC_MAP(SUT_SC_2_PBS,  "sysconf.01.86",    200112L,    CMPT_EQORM1,    "unistd.55");   /*[EQUALS OR -1]*/
    //PUT_SC_MAP(SUT_SC_TRACE_EVENT_NAME_MAX,   "sysconf.01.68",    SUT_POSIX_TRACE_EVENT_NAME_MAX, CMPT_MIN,   "");
    //PUT_SC_MAP(SUT_SC_SS_REPL_MAX,    "sysconf.01.52",    SUT_POSIX_SS_REPL_MAX,  CMPT_MIN,   "");
    //PUT_SC_MAP(SUT_SC_IPV6,   "sysconf.01.31",    200112L,    CMPT_EQORM1,    "unistd.08");   /*[EQUALS OR -1]*/
    //PUT_SC_MAP(SUT_SC_RAW_SOCKETS,    "sysconf.01.41",    200112L,    CMPT_EQORM1,    "unistd.19");   /*[EQUALS OR -1]*/
    //PUT_SC_MAP(SUT_SC_TRACE_NAME_MAX, "sysconf.01.71",    SUT_POSIX_TRACE_NAME_MAX,   CMPT_MIN,   "");
    //PUT_SC_MAP(SUT_SC_TRACE_SYS_MAX,  "sysconf.01.72",    SUT_POSIX_TRACE_SYS_MAX,    CMPT_MIN,   "");
    //PUT_SC_MAP(SUT_SC_TRACE_USER_EVENT_MAX,   "sysconf.01.73",    SUT_POSIX_TRACE_USER_EVENT_MAX, CMPT_MIN,   "");

    return true;
}

bool init_cs()
{
    cs_name_map = create_Map(&type_IntTObj,&type_CSData);

    #define PUT_CS_MAP_REQUIRED(name, req_id) \
            put_Map(cs_name_map, create_IntTObj(name), create_CSData(1,create_CString(req_id),0,NULL));

    PUT_CS_MAP_REQUIRED(SUT_CS_PATH, "confstr.01.01");
    PUT_CS_MAP_REQUIRED(SUT_CS_PATH,"confstr.01.01");
    PUT_CS_MAP_REQUIRED(SUT_CS_V6_WIDTH_RESTRICTED_ENVS,"confstr.01.14");

    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFF32_CFLAGS,"confstr.01.02");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFF32_LDFLAGS,"confstr.01.03");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFF32_LIBS,"confstr.01.04");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,"confstr.01.05");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,"confstr.01.06");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFFBIG_LIBS,"confstr.01.07");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LP64_OFF64_CFLAGS,"confstr.01.08");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LP64_OFF64_LDFLAGS,"confstr.01.09");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LP64_OFF64_LIBS,"confstr.01.10");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,"confstr.01.11");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,"confstr.01.12");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LPBIG_OFFBIG_LIBS,"confstr.01.13");

    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFF32_CFLAGS,"confstr.01.15");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFF32_LDFLAGS,"confstr.01.16");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFF32_LIBS,"confstr.01.17");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFF32_LINTFLAGS,"confstr.01.18");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFFBIG_CFLAGS,"confstr.01.19");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFFBIG_LDFLAGS,"confstr.01.20");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFFBIG_LIBS,"confstr.01.21");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_ILP32_OFFBIG_LINTFLAGS,"confstr.01.22");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LP64_OFF64_CFLAGS,"confstr.01.23");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LP64_OFF64_LDFLAGS,"confstr.01.24");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LP64_OFF64_LIBS,"confstr.01.25");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LP64_OFF64_LINTFLAGS,"confstr.01.26");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LPBIG_OFFBIG_CFLAGS,"confstr.01.27");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LPBIG_OFFBIG_LDFLAGS,"confstr.01.28");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LPBIG_OFFBIG_LIBS,"confstr.01.29");
    PUT_CS_MAP_REQUIRED(SUT_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,"confstr.01.30");

    /*[following names are defined in POSIX but not defined in LSB]*/
    PUT_CS_MAP_REQUIRED(SUT_CS_GNU_LIBC_VERSION,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_GNU_LIBPTHREAD_VERSION,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS_CFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS_LDFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS_LIBS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS_LINTFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS64_CFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS64_LDFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS64_LIBS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_LFS64_LINTFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LP64_OFF64_LINTFLAGS,"");
    PUT_CS_MAP_REQUIRED(SUT_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,"");

    return true;
}


bool init_pc()
{
    pc_map = create_Map(&type_IntTObj,&type_PCData);

#define PUT_PC_MAP(name,name_req,lim,cmpt,lim_req_id,reqs,req_id) \
put_Map(pc_map, create_IntTObj(name), create_PCData(create_CString(name_req), lim, cmpt, create_CString(lim_req_id), reqs, create_CString(req_id)))

    PUT_PC_MAP(SUT_PC_FILESIZEBITS,"pathconf.02.01;fpathconf.02.01",32,CMPT_MIN,
        "", PC_REQ3 | PC_REQ4,
        "pathconf.03.03.01;fpathconf.03.03.01;pathconf.03.04.01;fpathconf.03.04.01");

    PUT_PC_MAP(SUT_PC_LINK_MAX,"pathconf.02.02;fpathconf.02.02", 8, CMPT_MIN,
        "", PC_REQ1, "pathconf.03.01.01;fpathconf.03.01.01");

    PUT_PC_MAP(SUT_PC_MAX_CANON,"pathconf.02.03;fpathconf.02.03", 255, CMPT_MIN,
        "",PC_REQ2,"pathconf.03.02.01;fpathconf.03.02.01");

    PUT_PC_MAP(SUT_PC_MAX_INPUT,"pathconf.02.04;fpathconf.02.04", 255, CMPT_MIN,
        "",PC_REQ2,"pathconf.03.02.02;fpathconf.03.02.02");

    PUT_PC_MAP(SUT_PC_NAME_MAX,"pathconf.02.05;fpathconf.02.05", 255, CMPT_MIN,
        "",PC_REQ3 | PC_REQ4,
        "pathconf.03.03.02;fpathconf.03.03.02;pathconf.03.04.02;fpathconf.03.04.02"); /* XSI: Minimum Acceptable Value: _XOPEN_NAME_MAX */

    PUT_PC_MAP(SUT_PC_PATH_MAX,"pathconf.02.06;fpathconf.02.06", 4096, CMPT_MIN,
        "",PC_REQ4 | PC_REQ5,
        "pathconf.03.04.04;fpathconf.03.04.04;pathconf.03.05.04;fpathconf.03.05.04"); /* [LSB: limits.h] */

    PUT_PC_MAP(SUT_PC_PIPE_BUF,"pathconf.02.07;fpathconf.02.07", 512, CMPT_MIN,
        "", PC_REQ6, "pathconf.03.06.01;fpathconf.03.06.01");

    PUT_PC_MAP(SUT_PC_2_SYMLINKS,"pathconf.02.08;fpathconf.02.08", -1, CMPT_MIN,
        "",PC_REQ4,"pathconf.03.04.05;fpathconf.03.04.05");

    PUT_PC_MAP(SUT_PC_ALLOC_SIZE_MIN,"pathconf.02.09;fpathconf.02.09", -1, CMPT_MIN,
        "",PC_REQ10,"pathconf.03.10.01;fpathconf.03.10.01"); /* Restrictions are not specified */

    PUT_PC_MAP(SUT_PC_REC_INCR_XFER_SIZE,"pathconf.02.10;fpathconf.02.10", -1, CMPT_MIN,
        "", PC_REQ10, "pathconf.03.10.02;fpathconf.03.10.02"); /* Restrictions are not specified */

    PUT_PC_MAP(SUT_PC_REC_MIN_XFER_SIZE,"pathconf.02.12;fpathconf.02.12", -1, CMPT_MIN,
        "",PC_REQ10,"pathconf.03.10.04;fpathconf.03.10.04"); /* Restrictions are not specified */

    PUT_PC_MAP(SUT_PC_REC_XFER_ALIGN,"pathconf.02.13;fpathconf.02.13", -1, CMPT_MIN,
        "",PC_REQ10,"pathconf.03.10.05;fpathconf.03.10.05"); /* Restrictions are not specified */

    PUT_PC_MAP(SUT_PC_CHOWN_RESTRICTED,"pathconf.02.15;fpathconf.02.15", -1, CMPT_NO,
        "",PC_REQ7,"pathconf.03.07.01;fpathconf.03.07.01");

    PUT_PC_MAP(SUT_PC_NO_TRUNC,"pathconf.02.16;fpathconf.02.16", 1, CMPT_NO,
        "",PC_REQ3 | PC_REQ4,
        "pathconf.03.03.03;fpathconf.03.03.03;pathconf.03.04.03;fpathconf.03.04.03");

    PUT_PC_MAP(SUT_PC_VDISABLE,"pathconf.02.17;fpathconf.02.17", '\0', CMPT_NO,
        "",PC_REQ2,"pathconf.03.02.03;fpathconf.03.02.03");

    PUT_PC_MAP(SUT_PC_ASYNC_IO,"pathconf.02.18;fpathconf.02.18", -1, CMPT_NO,
        "",PC_REQ8,"pathconf.03.08.01;fpathconf.03.08.01");

    PUT_PC_MAP(SUT_PC_PRIO_IO,"pathconf.02.19;fpathconf.02.19",  -1, CMPT_NO,
        "",PC_REQ8,"pathconf.03.08.02;fpathconf.03.08.02");

    PUT_PC_MAP(SUT_PC_SYNC_IO,"pathconf.02.20;fpathconf.02.20",  -1, CMPT_NO,
        "",PC_REQ8,"pathconf.03.08.03;fpathconf.03.08.03");


    /* [Following names do not exist in LSB, but exist in Posix] */
    PUT_PC_MAP(SUT_PC_SYMLINK_MAX,"pathconf.02.14;fpathconf.02.14", 255, CMPT_MIN,
        "",PC_REQ4 | PC_REQ9,
        "pathconf.03.04.06;fpathconf.03.04.06;pathconf.03.09.01;fpathconf.03.09.01");

    PUT_PC_MAP(SUT_PC_REC_MAX_XFER_SIZE,"pathconf.02.11;fpathconf.02.11", -1, CMPT_MIN,
        "", PC_REQ10, "pathconf.03.10.03;fpathconf.03.10.03"); /* Restrictions are not specified */

    return true;
}
