/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef ERRM_SCENARIO_SEH
#define ERRM_SCENARIO_SEH
#endif


#ifdef ERRM_LOCAL_MAIN

#include "common/common_model.seh"
#include "data/errno_model.seh"

/*
* If this constant is set to 1, then current implementation of undefined() 
* may support additional errors not included in the list described in the
* IEEE Std 1003.1, 2004 Edition.
*/
int FUNC1_HAS_EXTRA_ERROR_CODES=0;

/*
* If this constant is set to 1, the current implementation of undefined() 
* may generate error code of EINVAL/EAGAIN under circumstances other than those 
* described in the IEEE Std 1003.1, 2004 Edition.
*/
int FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=0;
int FUNC1_HAS_EXTRA_CONDITION_ON_EAGAIN=0;

/*
 * If this constant is set to 1, the function pthread_key_delete() ensures
 * that the error EINVAL will be found and correctly handled.
 */
int FUNC1_FAILS_WITH_EINVAL=1;
/********************************************************************/
/**                     Test System Initialization                 **/
/********************************************************************/
bool func_s1(IntT errno, bool p1)
{
    ERROR_BEGIN(FUNC1, "", errno != SUT_EOK,  errno )
        ERROR_SHALL(FUNC1, EINVAL, "", p1);
    ERROR_END()

    return true;
}

bool func_s2(IntT errno, bool p1, bool p2)
{
    ERROR_BEGIN(FUNC1, "", errno != SUT_EOK,  errno )
        ERROR_SHALL(FUNC1, EINVAL, "", p1);
        ERROR_SHALL(FUNC1, EAGAIN, "", p2);
    ERROR_END()

    return true;
}

#define test0(t,err) { bool __res = func_##t##0(err); printf("func_"#t"0("#err") = %i ",__res);printf(__res?"Ok":"Wrong");printf("\n"); res &= __res;}
#define test0not(t,err) { bool __res = func_##t##0(err); printf("func_"#t"0("#err") = %i ",__res);printf(__res?"Wrong":"Ok");printf("\n"); res &= !__res;}
#define test1(t,err, p1) { bool __res = func_##t##1(err,p1); printf("func_"#t"1("#err","#p1") = %i ",__res);printf(__res?"Ok":"Wrong");printf("\n"); res &= __res;}
#define test1not(t,err, p1) { bool __res = func_##t##1(err,p1); printf("func_"#t"1("#err","#p1") = %i ",__res);printf(__res?"Wrong":"Ok");printf("\n"); res &= !__res;}
#define test2(t,err, p1, p2) { bool __res = func_##t##2(err,p1,p2); printf("func_"#t"2("#err","#p1","#p2") = %i ",__res);printf(__res?"Ok":"Wrong");printf("\n"); res &= __res;}
#define test2not(t,err, p1, p2) { bool __res = func_##t##2(err,p1,p2); printf("func_"#t"2("#err","#p1","#p2") = %i ",__res);printf(__res?"Wrong":"Ok");printf("\n"); res &= !__res;}

#define eval(s) printf(#s"\n");s

bool shall_errm(int argc, char** argv)
{
    bool res = true;

   eval(FUNC1_HAS_EXTRA_ERROR_CODES=0);
   eval(FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=0);

    test1(s,SUT_EINVAL, true);  
    test1not(s,SUT_EINVAL, false);

    test1not(s,SUT_EPERM, true);   
    test1not(s,SUT_EPERM, false);   

    test2(s,SUT_EINVAL, true, true);
    test2(s,SUT_EINVAL, true, false);
    test2not(s,SUT_EINVAL, false, true);
    test2not(s,SUT_EINVAL, false, false);

    test2(s,SUT_EAGAIN, true, true);
    test2(s,SUT_EAGAIN, false, true);
    test2not(s,SUT_EAGAIN, true, false);
    test2not(s,SUT_EAGAIN, false, false);

    test2not(s,SUT_EPERM, true, true);
    test2not(s,SUT_EPERM, true, false);
    test2not(s,SUT_EPERM, false, true);
    test2not(s,SUT_EPERM, false, false);

    test2not(s,SUT_EOK, true, true);
    test2not(s,SUT_EOK, true, false);
    test2not(s,SUT_EOK, false, true);
    test2(s,SUT_EOK, false, false);
   
   eval(FUNC1_HAS_EXTRA_ERROR_CODES=1);
   eval(FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=0);

    test1(s,SUT_EINVAL, true);  
    test1not(s,SUT_EINVAL, false);

    test1(s,SUT_EPERM, true);   
    test1(s,SUT_EPERM, false);   

    test2(s,SUT_EINVAL, true, true);
    test2(s,SUT_EINVAL, true, false);
    test2not(s,SUT_EINVAL, false, true);
    test2not(s,SUT_EINVAL, false, false);

    test2(s,SUT_EAGAIN, true, true);
    test2(s,SUT_EAGAIN, false, true);
    test2not(s,SUT_EAGAIN, true, false);
    test2not(s,SUT_EAGAIN, false, false);

    test2(s,SUT_EPERM, true, true);
    test2(s,SUT_EPERM, true, false);
    test2(s,SUT_EPERM, false, true);
    test2(s,SUT_EPERM, false, false);

   eval(FUNC1_HAS_EXTRA_ERROR_CODES=0);
   eval(FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=1);

    test1(s,SUT_EINVAL, true);  
    test1(s,SUT_EINVAL, false);

    test1not(s,SUT_EPERM, true);   
    test1not(s,SUT_EPERM, false);   

    test2(s,SUT_EINVAL, true, true);
    test2(s,SUT_EINVAL, true, false);
    test2(s,SUT_EINVAL, false, true);
    test2(s,SUT_EINVAL, false, false);

    test2(s,SUT_EAGAIN, true, true);
    test2(s,SUT_EAGAIN, false, true);
    test2not(s,SUT_EAGAIN, true, false);
    test2not(s,SUT_EAGAIN, false, false);

    test2not(s,SUT_EPERM, true, true);
    test2not(s,SUT_EPERM, true, false);
    test2not(s,SUT_EPERM, false, true);
    test2not(s,SUT_EPERM, false, false);

    test2not(s,SUT_EOK, true, true);
    test2not(s,SUT_EOK, true, false);
    test2not(s,SUT_EOK, false, true);
    test2(s,SUT_EOK, false, false);

   eval(FUNC1_HAS_EXTRA_ERROR_CODES=1);
   eval(FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=1);

    test1(s,SUT_EINVAL, true);  
    test1(s,SUT_EINVAL, false);

    test1(s,SUT_EPERM, true);   
    test1(s,SUT_EPERM, false);   

    test2(s,SUT_EINVAL, true, true);
    test2(s,SUT_EINVAL, true, false);
    test2(s,SUT_EINVAL, false, true);
    test2(s,SUT_EINVAL, false, false);

    test2(s,SUT_EAGAIN, true, true);
    test2(s,SUT_EAGAIN, false, true);
    test2not(s,SUT_EAGAIN, true, false);
    test2not(s,SUT_EAGAIN, false, false);

    test2(s,SUT_EPERM, true, true);
    test2(s,SUT_EPERM, true, false);
    test2(s,SUT_EPERM, false, true);
    test2(s,SUT_EPERM, false, false);

    return res;
}

/*********************************************************/

bool func_n0(IntT errno)
{
    ERROR_BEGIN(FUNC1, "", errno != SUT_EOK,  errno )
        ERROR_NEVER(FUNC1, EINVAL, "");
    ERROR_END()
        
    return true;
}

bool never_errm(int argc, char** argv)
{
    bool res = true;
    
    eval(FUNC1_HAS_EXTRA_ERROR_CODES=0);

    test0not(n,SUT_EINVAL);
    test0not(n,SUT_EAGAIN);

    eval(FUNC1_HAS_EXTRA_ERROR_CODES=1);

    test0not(n,SUT_EINVAL);
    test0(n,SUT_EAGAIN);  

    test0(n, SUT_EOK);
    return res;
}

/*********************************************************/

bool func_m1(IntT errno, bool p1)
{
    ERROR_BEGIN(FUNC1, "", errno != SUT_EOK,  errno )
        ERROR_MAY(FUNC1, EINVAL, "", p1);
    ERROR_END()

    return true;
}

bool may_errm(int argc, char** argv)
{
    bool res = true;
    
    eval(FUNC1_HAS_EXTRA_ERROR_CODES=0);
    eval(FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=0);
    eval(FUNC1_FAILS_WITH_EINVAL=1);

    test1(m,SUT_EINVAL,true);
    test1not(m,SUT_EINVAL,false);
    test1not(m,SUT_EAGAIN,true);
    test1not(m,SUT_EAGAIN,false);

    test1not(m,SUT_EOK,true);
    test1(m,SUT_EOK,false);

    eval(FUNC1_HAS_EXTRA_ERROR_CODES=0);
    eval(FUNC1_FAILS_WITH_EINVAL=0);

    test1(m,SUT_EINVAL,true);
    test1not(m,SUT_EINVAL,false);
    test1not(m,SUT_EAGAIN,true);
    test1not(m,SUT_EAGAIN,false);

    test1(m,SUT_EOK,true);
    test1(m,SUT_EOK,false);

    eval(FUNC1_HAS_EXTRA_ERROR_CODES=1);
    eval(FUNC1_FAILS_WITH_EINVAL=1);

    test1(m,SUT_EINVAL,true);
    test1not(m,SUT_EINVAL,false);
    test1(m,SUT_EAGAIN,true);
    test1(m,SUT_EAGAIN,false);

    eval(FUNC1_HAS_EXTRA_ERROR_CODES=1);
    eval(FUNC1_FAILS_WITH_EINVAL=0);

    test1(m,SUT_EINVAL,true);
    test1not(m,SUT_EINVAL,false);
    test1(m,SUT_EAGAIN,true);
    test1(m,SUT_EAGAIN,false);

    return res;
}

bool func_mm1(IntT errno, bool p1)
{
    ERROR_BEGIN(FUNC1, "", errno != SUT_EOK,  errno )
        ERROR_MAY(FUNC1, EINVAL, "", p1);
        ERROR_UNCHECKABLE(FUNC1, EAGAIN, "", "because");
    ERROR_END()
        
    return true;
}

// this test checks difference for FAILS_WITH_EINVAL
bool may_errm2(int argc, char** argv)
{
    bool res = true;
    
    eval(FUNC1_HAS_EXTRA_ERROR_CODES=0);
    eval(FUNC1_HAS_EXTRA_CONDITION_ON_EINVAL=0);
    eval(FUNC1_FAILS_WITH_EINVAL=1);

    test1not(mm,SUT_EAGAIN,true);
    test1(mm,SUT_EAGAIN,false);

    test1not(mm,SUT_EOK,true);
    test1(mm,SUT_EOK,false);

    eval(FUNC1_FAILS_WITH_EINVAL=0);

    test1(mm,SUT_EAGAIN,true);
    test1(mm,SUT_EAGAIN,false);

    test1(mm,SUT_EOK,true);
    test1(mm,SUT_EOK,false);

    return res;
}

int main(int argc, char** argv)
{
    bool res = true;
    /* Run test scenario */
    res &= shall_errm(argc,argv);
    res &= never_errm(argc,argv);
    res &= may_errm(argc,argv);
    res &= may_errm2(argc,argv);

    VERBOSE("\ntotal: ");VERBOSE(res?"Ok":"Wrong");VERBOSE("\n");

    //todo: UNCHECKABLE, MAY_EXT, MAY3, SHALL3

    return 0;
}
#endif
