/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef SOCKET_NETDB_MODEL_SEH
#define SOCKET_NETDB_MODEL_SEH

#include "common/common_model.seh"

#include "socket/socket/socket_model.seh"

/*
specification typedef struct SockaddrT
{
    bool        unknown; // true while it is not known
    SaFamilyT   family;
    Object      *addr; // either InetAddrT or Inet6AddrT
} SockaddrT;

*/

/********************************************************************/
/**                      Defines                                   **/
/********************************************************************/

#define SUT_EAI_BADFLAGS    -1
#define SUT_EAI_MEMORY      -10
#define SUT_EAI_SYSTEM      -11
#define SUT_EAI_OVERFLOW    -12 // is absent in LSB
#define SUT_EAI_NONAME      -2
#define SUT_EAI_AGAIN       -3
#define SUT_EAI_FAIL        -4
#define SUT_EAI_NODATA      -5
#define SUT_EAI_FAMILY      -6
#define SUT_EAI_SOCKTYPE    -7
#define SUT_EAI_SERVICE     -8
#define SUT_EAI_ADDRFAMILY  -9

#define SUT_NETDB_INTERNAL  -1
#define SUT_NETDB_SUCCESS   0
#define SUT_HOST_NOT_FOUND  1
#define SUT_IPPORT_RESERVED 1024
#define SUT_NI_MAXHOST      1025
#define SUT_TRY_AGAIN       2
#define SUT_NO_RECOVERY     3
#define SUT_NI_MAXSERV      32
#define SUT_NO_DATA         4
#define SUT_NO_ADDRESS  SUT_NO_DATA


#define SUT_AI_PASSIVE          0x0001
#define SUT_AI_CANONNAME        0x0002
#define SUT_AI_NUMERICHOST      0x0004
#define SUT_AI_V4MAPPED         0x0008 // is absent in LSB
#define SUT_AI_ALL              0x0016 // is absent in LSB
#define SUT_AI_ADDRCONFIG       0x0032 // is absent in LSB


#define SUT_NI_NUMERICHOST  1
#define SUT_NI_DGRAM        16
#define SUT_NI_NUMERICSERV  2
#define SUT_NI_NOFQDN       4
#define SUT_NI_NAMEREQD     8

#if (__BYTE_ORDER == __LITTLE_ENDIAN)
	#define NETORDER_INADDR_LOOPBACK 0x0100007f
#else
	#define NETORDER_INADDR_LOOPBACK 0x7f000001
#endif

#define NETORDER_INADDR_ANY 0

// Interpretation

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

/********************************************************************/
/**                      NetDB Types                               **/
/********************************************************************/

/* // LSB: 13.4.23. netdb.h
struct servent {
    char *s_name;
    char **s_aliases;
    int s_port;
    char *s_proto;
};
*/
specification typedef struct ServentT
{
    CString * s_name;
    VoidTPtr s_aliases;
    IntT s_port; // in host byte order here
    CString * s_proto;
}ServentT;

ServentT * create_emptyServentT(void);

/* // LSB: 13.4.23. netdb.h
struct protoent {
    char *p_name;
    char **p_aliases;
    int p_proto;
};
*/
specification typedef struct ProtoentT
{
    CString * p_name;
    VoidTPtr p_aliases;
    IntT p_proto;
}ProtoentT;

ProtoentT * create_emptyProtoentT(void);

// typedef unsigned int socklen_t;
typedef UIntT sut_socklen_t;

typedef VoidTPtr AddrInfoTPtr;

/* // LSB: 13.4.23. netdb.h
struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
};
*/
specification typedef struct AddrInfoT
{
    AddrInfoTPtr addr;
    IntT ai_flags;
    IntT ai_family;
    IntT ai_socktype;
    IntT ai_protocol;
    sut_socklen_t ai_addrlen;
    SockaddrT * ai_addr;
    CString * ai_canonname;
    AddrInfoTPtr ai_next;
}AddrInfoT;

AddrInfoT * create_NullAddrInfoT();
/*[ create_emptyAddrInfoT() and create_AddrInfoT() are in netdb_media ]*/


/* // LSB: 13.4.23. netdb.h
struct hostent {
    char *h_name;
    char **h_aliases;
    int h_addrtype;
    int h_length;
    char **h_addr_list;
};
*/
specification typedef struct HostentT
{
    CString * h_name;
    VoidTPtr h_aliases;
    IntT h_addrtype;
    IntT h_length;
    StringTPtr h_addr_list;
}HostentT;

HostentT * create_emptyHostentT(void);

// 0 - empty; 1 - start filling; 2 - filled
#define NETDB_FILLING 1
#define NETDB_FILLED  2

specification typedef struct NetdbProcessData
{
    VoidTPtr h_errno_ptr;
    int serv_db_pos;
    int serv_db_filling;
    int proto_db_pos;
    int proto_db_filling;
    int proto_db_state;
}NetdbProcessData;

bool init_netdb(void);

bool reset_serv_db(void);

extern Map * netdb_data; // ProcessIdObj -> NetdbProcessData;

NetdbProcessData * get_netdb_data(CallContext context);
NetdbProcessData * create_emptyNetdbProcessData(void);

IntT read_h_errno(CallContext context);

ServentT * getservent_byPos(CallContext context, int pos);
ProtoentT * getprotoent_byPos(CallContext context, int pos);

extern List * serv_db; // ServentT
extern List * proto_db; // ServentT

bool checkServiceAndPortPair( CString * service, IntT port );

ServentT * findserv_model(CallContext context, CString *name, IntT port, CString *proto, int * pos);
ProtoentT * findproto_model(CallContext context, CString *name, IntT proto);
void traceAddrInfoT(CallContext context,AddrInfoT * res_ai);
bool is_addr_numeric(CString * addr);
bool AND_ai_check(CallContext context, AddrInfoT * ai, bool(*check)(AddrInfoT * ai, Object * par1), Object * par1 );
bool check_ai_protocol(AddrInfoT * ai, Object * par1);
bool check_ai_ip(AddrInfoT * ai, Object * par1);
bool check_ai_family(AddrInfoT * ai, Object * par1);
bool check_ai_addrlen(AddrInfoT * ai, Object * par1);
bool check_ai_socktype(AddrInfoT * ai, Object * par1);
bool is_serv_numeric(CString * addr);
bool is_in6addr_loopback(SockaddrT * addr);
CString * numerichost(SockaddrT * sa);
CString * numericserv(SockaddrT * sa, sut_socklen_t servicelen);
/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** endservent_spec **/
specification
void endservent_spec( CallContext context);

void onEndservent(CallContext context);

/** getservbyname_spec **/
specification
ServentT * getservbyname_spec( CallContext context, CString *name, CString *proto );

void onGetservbyname( CallContext context, CString *name, CString *proto, ServentT * getservbyname_spec );

/** getservbyport_spec **/
specification
ServentT * getservbyport_spec( CallContext context, IntT port, CString * proto );

void onGetservbyport( CallContext context, IntT port, CString * proto, ServentT * getservbyport_spec );

/** getservent_spec **/
specification
ServentT * getservent_spec( CallContext context);

void onGetservent( CallContext context, ServentT * getservent_spec);

/** setservent_spec **/
specification
void setservent_spec( CallContext context, IntT stayopen);

void onSetservent( CallContext context, IntT stayopen);


/****/


/** endprotoent_spec **/
specification
void endprotoent_spec( CallContext context);

void onEndprotoent( CallContext context);

/** getprotobyname_spec **/
specification
ProtoentT * getprotobyname_spec( CallContext context, CString * name);

void onGetprotobyname( CallContext context, CString * name, ProtoentT * getprotobyname_spec);

/** getprotobynumber_spec **/
specification
ProtoentT * getprotobynumber_spec( CallContext context, IntT proto );

void onGetprotobynumber( CallContext context, IntT proto, ProtoentT * getprotobynumber_spec );

/** getprotoent_spec **/
specification
ProtoentT * getprotoent_spec( CallContext context );

void onGetprotoent( CallContext context, ProtoentT * getprotoent_spec );

/** setprotoent_spec **/
specification
void setprotoent_spec( CallContext context, IntT stayopen);

void onSetprotoent( CallContext context, IntT stayopen);


/****/


/** freeaddrinfo_spec **/
specification
void freeaddrinfo_spec( CallContext context, AddrInfoTPtr ai_ptr );

void onFreeaddrinfo( CallContext context, AddrInfoTPtr ai_ptr);

/** getaddrinfo_spec **/
specification
IntT getaddrinfo_spec( CallContext context, CString * nodename,
                       CString * servname, AddrInfoT * hints, VoidTPtrObj * res );

void onGetaddrinfo( CallContext context, CString * nodename,
                   CString * servname, AddrInfoT * hints, VoidTPtrObj * res, IntT getaddrinfo_spec );

/****/


/** getnameinfo_spec **/
specification
IntT getnameinfo_spec( CallContext context, SockaddrT * sa,
                       CString * node, sut_socklen_t nodelen,
                       CString * service, sut_socklen_t servicelen,
                       IntT flags );

void onGetnameinfo( CallContext context, SockaddrT * sa,
                    CString * node, sut_socklen_t nodelen,
                    CString * service, sut_socklen_t servicelen,
                    IntT flags, IntT getnameinfo_spec );
/****/


/** gethostbyaddr_spec **/
specification
HostentT * gethostbyaddr_spec( CallContext context, VoidTPtr addr, sut_socklen_t len, IntT type );

void onGethostbyaddr( CallContext context, VoidTPtr addr, sut_socklen_t len,
                      IntT type, HostentT * gethostbyaddr_spec
                     );

/** gethostbyname_spec **/
specification
HostentT * gethostbyname_spec( CallContext context, CString * name );

void onGethostbyname( CallContext context, CString * name, HostentT * gethostbyname_spec );


/****/


/** gai_strerror_spec **/
specification
CString * gai_strerror_spec( CallContext context, IntT ecode );

/** __h_errno_location_spec **/
specification
VoidTPtr __h_errno_location_spec( CallContext context);

void onHErrnoLocation(CallContext context, VoidTPtr res);

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

#endif

