/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "io/file/file_config.h"
#include "socket/socket/socket_config.h"
#include "socket/socket/socket_model.seh"
#include "process/process/process_model.seh"
#include "system/system/system_model.seh"
#include "fs/dir/dir_model.seh"
#include "socket/netdata/netdata_model.seh"

#pragma SEC subsystem socket "socket.socket"


/*
   The group of functions 'socket.socket' consists of:
       accept [2]
       bind [2]
       bindresvport [1]
       connect [2]
       getpeername [2]
       getsockname [2]
       getsockopt [2]
       listen [2]
       recv [2]
       recvfrom [2]
       recvmsg [2]
       send [2]
       sendmsg [2]
       sendto [2]
       setsockopt [1]
       shutdown [2]
       sockatmark [2]
       socket [2]
       socketpair [2]

      (*)read_socket
      (*)write_socket
      (*)readv_socket
      (*)writev_socket
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    accept - accept a new connection on a socket

SYNOPSIS

    #include <sys/socket.h>
    int accept(int socket, struct sockaddr *restrict address,
        socklen_t *restrict address_len);

DESCRIPTION

    The accept() function shall extract the first connection on the queue of
    pending connections, create a new socket with the same socket type protocol
    and address family as the specified socket, and allocate a new file
    descriptor for that socket.

    The accept() function takes the following arguments:

        socket
        Specifies a socket that was created with socket(), has been bound to an
        address with bind(), and has issued a successful call to listen().

        address
        Either a null pointer, or a pointer to a sockaddr structure where the
        address of the connecting socket shall be returned.

        address_len
        Points to a socklen_t structure which on input specifies the length of
        the supplied sockaddr structure, and on output specifies the length of
        the stored address.

    If address is not a null pointer, the address of the peer for the accepted
    connection shall be stored in the sockaddr structure pointed to by address,
    and the length of this address shall be stored in the object pointed to by
    address_len.

    If the actual length of the address is greater than the length of the
    supplied sockaddr structure, the stored address shall be truncated.

    If the protocol permits connections by unbound clients, and the peer is not
    bound, then the value stored in the object pointed to by address is
    unspecified.

    If the listen queue is empty of connection requests and O_NONBLOCK is not
    set on the file descriptor for the socket, accept() shall block until a
    connection is present. If the listen() queue is empty of connection
    requests and O_NONBLOCK is set on the file descriptor for the socket,
    accept() shall fail and set errno to [EAGAIN] or [EWOULDBLOCK].

    The accepted socket cannot itself accept more connections. The original
    socket remains open and can accept more connections.

RETURN VALUE

    Upon successful completion, accept() shall return the non-negative file
    descriptor of the accepted socket. Otherwise, -1 shall be returned and
    errno set to indicate the error.

ERRORS

    The accept() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        O_NONBLOCK is set for the socket file descriptor and no connections are
        present to be accepted.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNABORTED]
        A connection has been aborted.

        [EINTR]
        The accept() function was interrupted by a signal that was caught
        before a valid connection arrived.

        [EINVAL]
        The socket is not accepting connections.

        [EMFILE]
        {OPEN_MAX} file descriptors are currently open in the calling process.

        [ENFILE]
        The maximum number of file descriptors in the system are already open.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The socket type of the specified socket does not support accepting
        connections.

    The accept() function may fail if:

        [ENOBUFS]
        No buffer space is available.

        [ENOMEM]
        There was insufficient memory available to complete the operation.

        [EPROTO]
        [XSR]  A protocol error has occurred; for example, the STREAMS protocol
        stack has not been initialized.
*/

specification
void accept_spec( CallContext context, FileDescId socket)
{
    pre
    {
        /*
        * If the protocol permits connections by unbound clients, and the peer is not
        * bound, then the value stored in the object pointed to by address is unspecified.
        */
        REQ("app.accept.05", "", TODO_REQ());

        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct AcceptCall AcceptCall = {};


void onAccept( CallContext context, FileDescId socket)
{
    startBlockedCall(context, create_AcceptCall(socket));
}


void accept_model(CallContext context, FileDescId sock, AcceptReturnType* accept_ret_val)
{
    SocketFileDescriptor* orig=getDescriptor_FileDescId(sock);
    SocketFileDescriptor* sdesc;
    SocketFileDescriptor* peer_addr=NULL;
    FileDescIdObj* client_conn = NULL;

    if (size_List(orig->waitingAccept)!=0)
    {
        /*
        * The accept() function shall extract the first connection on the queue of
        * pending connections,
        */
        IMPLEMENT_REQ("accept.01.01");
        client_conn = get_List(orig->waitingAccept, 0);
        peer_addr=getDescriptor_FileDescId(*client_conn);
    }

    /*
    * create a new socket with the same socket type protocol and address family as
    * the specified socket,
    */
    IMPLEMENT_REQ("accept.01.02");
    sdesc = create_SocketDescriptor(orig->domain, orig->type, orig->protocol);

    /*
    * and allocate a new file descriptor for that socket.
    */
    IMPLEMENT_REQ("accept.01.03");
    register_SocketDesriptor(accept_ret_val->funcRes, sdesc);
    sdesc = getDescriptor_FileDescId(accept_ret_val->funcRes);
    sdesc->peer_addr = clone(accept_ret_val->acceptedAddr);

    if (peer_addr!=NULL)
    {
        peer_addr->addr   = sdesc->peer_addr;
        sdesc->pairId     = *client_conn;
        peer_addr->pairId = *client_conn;
        remove_List(orig->waitingAccept, indexOf_List(orig->waitingAccept, client_conn));
    }
    else
    {
        setBadVerdict("Peer shall not be NULL");
    }

    orig->lastAccepted = accept_ret_val->funcRes;
}


void onAcceptReturn( CallContext context, AcceptReturnType* accept_ret_val)
{
    AcceptCall* blocked_call=finishBlockedCall(context);

    if (accept_ret_val->funcRes.filedesc!=-1)
    {
        accept_model(context, blocked_call->socket, accept_ret_val);
    }
}


specification typedef struct AcceptReturnType AcceptReturnType = {};


reaction AcceptReturnType* accept_return(void)
{
    post
    {
        CallContext    context=accept_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        AcceptCall*    accCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId     socket =accCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(accCall->socket);

        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_ACCEPT, "accept.10.02",  accept_return->funcRes.filedesc == -1, *(accept_return->errno))

        /*
         * The accept() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] O_NONBLOCK is set for the socket file descriptor
         * and no connections are present to be accepted.
         */
        /*
         * If the listen() queue is empty of connection requests and O_NONBLOCK is set on
         * the file descriptor for the socket, accept() shall fail and set errno to
         * [EAGAIN] or [EWOULDBLOCK].
         */
        ERROR_SHALL3(POSIX_ACCEPT, EAGAIN, "accept.11.01;accept.07", isO_NONBLOCKset(socket))

        ERROR_SHALL3(POSIX_ACCEPT, EWOULDBLOCK, "accept.11.01;accept.07", isO_NONBLOCKset(socket))

        /*
        * The accept() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_ACCEPT, EBADF, "accept.11.02", getFileDescriptor(socket)==NULL)

        /*
        * The accept() function shall fail if:
        *
        * [ECONNABORTED] A connection has been aborted.
        */
        ERROR_SHALL(POSIX_ACCEPT, ECONNABORTED, "accept.11.03", TODO_ERR(ECONNABORTED) )

        /*
        * The accept() function shall fail if:
        *
        * [EINTR] The accept() function was interrupted by a signal that was caught
        * before a valid connection arrived.
        */
        ERROR_SHALL(POSIX_ACCEPT, EINTR, "accept.11.04", TODO_ERR(EINTR) )

        /*
        * The accept() function shall fail if:
        *
        * [EINVAL] The socket is not accepting connections.
        */
        ERROR_SHALL(POSIX_ACCEPT, EINVAL, "accept.11.05", desc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            desc->listening==false)

        /*
        * The accept() function shall fail if:
        *
        * [EMFILE] {OPEN_MAX} file descriptors are currently open in the calling
        * process.
        */
        ERROR_SHALL3(POSIX_ACCEPT, EMFILE, "accept.11.06", isOpenFileDescNumberExceedMax(context))

        /*
        * The accept() function shall fail if:
        *
        * [ENFILE] The maximum number of file descriptors in the system are already
        * open.
        */
        ERROR_UNCHECKABLE(POSIX_ACCEPT, ENFILE, "accept.11.07", "Can not check ENFILE error")

        /*
        * The accept() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_ACCEPT, ENOTSOCK, "accept.11.08", getFileDescriptor(socket)!=NULL &&
            getFileKind_FileDescId(socket)!=Socket)

        /*
        * The accept() function shall fail if:
        *
        * [EOPNOTSUPP] The socket type of the specified socket does not support
        * accepting connections.
        */
        ERROR_SHALL(POSIX_ACCEPT, EOPNOTSUPP, "accept.11.09", desc!=NULL && getFileKind_FileDescId(socket)==Socket
            && (desc->type==SUT_SOCK_DGRAM || desc->type==SUT_SOCK_RAW))

        /*
        * The accept() function may fail if:
        *
        * [ENOBUFS] No buffer space is available.
        */
        ERROR_UNCHECKABLE(POSIX_ACCEPT, ENOBUFS, "accept.12.01", "Can not check if buffer space is available")

        /*
        * The accept() function may fail if:
        *
        * [ENOMEM] There was insufficient memory available to complete the operation.
        */
        ERROR_UNCHECKABLE(POSIX_ACCEPT, ENOMEM, "accept.12.02", "Can not check insufficient memory case")

        /*
        * The accept() function may fail if:
        *
        * [EPROTO] [XSR] A protocol error has occurred; for example, the STREAMS
        * protocol stack has not been initialized.
        */
        ERROR_MAY(POSIX_ACCEPT, EPROTO, "accept.12.03", TODO_ERR(EPROTO))

        ERROR_END()

       /*
        * Upon successful completion, accept() shall return the non-negative file
        * descriptor of the accepted socket.
        */
        REQ("accept.10.01", "Non negative integer shall be returned", accept_return->funcRes.filedesc >= 0);

        /*
        * The accepted socket cannot itself accept more connections.
        */
        REQ("accept.08", "", TODO_REQ());

        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    bind - bind a name to a socket

SYNOPSIS

    #include <sys/socket.h>
    int bind(int socket, const struct sockaddr *address,
        socklen_t address_len);

DESCRIPTION

    The bind() function shall assign a local socket address address to a socket
    identified by descriptor socket that has no local socket address assigned.
    Sockets created with the socket() function are initially unnamed; they are
    identified only by their address family.

    The bind() function takes the following arguments:

    socket
        Specifies the file descriptor of the socket to be bound.
    address
        Points to a sockaddr structure containing the address to be bound to
        the socket. The length and format of the address depend on the address
        family of the socket.
    address_len
        Specifies the length of the sockaddr structure pointed to by the
        address argument.

    The socket specified by socket may require the process to have appropriate
    privileges to use the bind() function.

RETURN VALUE

    Upon successful completion, bind() shall return 0; otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The bind() function shall fail if:

        [EADDRINUSE]
        The specified address is already in use.

        [EADDRNOTAVAIL]
        The specified address is not available from the local machine.

        [EAFNOSUPPORT]
        The specified address is not a valid address for the address family of
        the specified socket.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [EINVAL]
        The socket is already bound to an address, and the protocol does not
        support binding to a new address; or the socket has been shut down.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The socket type of the specified socket does not support binding to an
        address.

    If the address family of the socket is AF_UNIX, then bind() shall fail if:

        [EACCES]
        A component of the path prefix denies search permission, or the
        requested name requires writing in a directory with a mode that denies
        write permission.

        [EDESTADDRREQ] or [EISDIR]
        The address argument is a null pointer.

        [EIO]
        An I/O error occurred.

        [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        pathname in address.

        [ENAMETOOLONG]
        A component of a pathname exceeded {NAME_MAX} characters, or an entire
        pathname exceeded {PATH_MAX} characters.

        [ENOENT]
        A component of the pathname does not name an existing file or the
        pathname is an empty string.

        [ENOTDIR]
        A component of the path prefix of the pathname in address is not a
        directory.

        [EROFS]
        The name would reside on a read-only file system.

    The bind() function may fail if:

        [EACCES]
        The specified address is protected and the current user does not have
        permission to bind to it.

        [EINVAL]
        The address_len argument is not a valid length for the address family.

        [EISCONN]
        The socket is already connected.

        [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the pathname in address.

        [ENAMETOOLONG]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.

        [ENOBUFS]
        Insufficient resources were available to complete the call.
*/


specification
IntT bind_spec( CallContext context, FileDescId socket, SockaddrT* address, ErrorCode* errno)
{
    SocketFileDescriptor* oldDesc;
    pre
    {
        if (address!=NULL)
        {
            oldDesc = getFileDescriptor_Sockaddr(context, address, false);
        }
        return true;
    }
    post
    {
        SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
        Bool3 isELOOP;
        CString *absPath;
        CString *path;

        if (address!=NULL)
        {
            if (address->family==SUT_AF_UNIX)
            {
                absPath = resolvePath_Ext(context, getFileSystem(context), getUnixSocket_path(address), &isELOOP);
                path=getUnixSocket_path(address);
            }
            else
            {
                absPath = create_CString("");
                path = create_CString("");
            }
        }

        /*
        * otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_BIND, "bind.05.02", bind_spec==-1, *errno)

        /*
         * The bind() function shall fail if:
         *
         * [EADDRINUSE] The specified address is already in use.
         */
        ERROR_SHALL(POSIX_BIND, EADDRINUSE, "bind.06.01", address!=NULL && oldDesc!=NULL)

        /*
         * The bind() function shall fail if:
         *
         * [EADDRNOTAVAIL] The specified address is not available from the local machine.
         */
        ERROR_SHALL(POSIX_BIND, EADDRNOTAVAIL, "bind.06.02", TODO_ERR(EADDRNOTAVAIL) )

        /*
         * The bind() function shall fail if:
         *
         * [EAFNOSUPPORT] The specified address is not a valid address for the address
         * family of the specified socket.
         */
        ERROR_SHALL(POSIX_BIND, EAFNOSUPPORT, "bind.06.03", TODO_ERR(EAFNOSUPPORT) )

        /*
         * The bind() function shall fail if:
         *
         * [EBADF] The socket argument is not a valid file descriptor.
         */
        ERROR_SHALL(POSIX_BIND, EBADF, "bind.06.04", desc==NULL)

        /*
         * The bind() function shall fail if:
         *
         * [EINVAL] The socket is already bound to an address, and the protocol does not
         * support binding to a new address; or the socket has been shut down.
         */
        ERROR_SHALL(POSIX_BIND, EINVAL, "bind.06.05", TODO_ERR(EINVAL) )

        /*
         * The bind() function shall fail if:
         *
         * [ENOTSOCK] The socket argument does not refer to a socket.
         */
         ERROR_SHALL(POSIX_BIND, ENOTSOCK, "bind.06.06", getFileDescriptor(socket)!=NULL &&
            getFileKind_FileDescId(socket) != Socket)

        /*
         * The bind() function shall fail if:
         *
         * [EOPNOTSUPP] The socket type of the specified socket does not support binding
         * to an address.
         */
        ERROR_SHALL(POSIX_BIND, EOPNOTSUPP, "bind.06.07", TODO_ERR(EOPNOTSUPP) )

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [EACCES] A component of the path prefix denies search permission, or the
         * requested name requires writing in a directory with a mode that denies write
         * permission.
         */
         ERROR_SHALL3(POSIX_BIND, EACCES, "bind.07.01", and_Bool3(address->family==SUT_AF_UNIX,
            isEACCES_dir_mkrm(context, getFileSystem(context), absPath)))

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [EDESTADDRREQ] or [EISDIR] The address argument is a null pointer.
         */
        ERROR_SHALL(POSIX_BIND, EDESTADDRREQ, "bind.07.02", address==NULL)

        ERROR_SHALL(POSIX_BIND, EISDIR, "bind.07.02", address==NULL)

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [EIO] An I/O error occurred.
         */
        ERROR_UNCHECKABLE(POSIX_BIND, EIO, "bind.07.03", "Can not check IO errors")

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [ELOOP] A loop exists in symbolic links encountered during resolution of the
         * pathname in address.
         */
        ERROR_SHALL3(POSIX_BIND, ELOOP, "bind.07.04", and_Bool3(address->family==SUT_AF_UNIX, isELOOP))

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [ENAMETOOLONG] A component of a pathname exceeded {NAME_MAX} characters, or
         * an entire pathname exceeded {PATH_MAX} characters.
         */
         ERROR_SHALL3(POSIX_BIND, ENAMETOOLONG, "bind.07.05", and_Bool3(address->family==SUT_AF_UNIX,
            isENAMETOOLONG(context, path)))

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [ENOENT] A component of the pathname does not name an existing file or the
         * pathname is an empty string.
         */
         ERROR_SHALL3(POSIX_BIND, ENOENT, "bind.07.06", and_Bool3(address->family==SUT_AF_UNIX,
            isENOENT_dir(context, getFileSystem(context), getParentDir_Path(absPath))))

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [ENOTDIR] A component of the path prefix of the pathname in address is not a
         * directory.
         */
         ERROR_SHALL3(POSIX_BIND, ENOTDIR, "bind.07.07", and_Bool3(address->family==SUT_AF_UNIX,
            isENOTDIR_dir(context, getFileSystem(context), getParentDir_Path(absPath))))

        /*
         * If the address family of the socket is AF_UNIX, then bind() shall fail if:
         *
         * [EROFS] The name would reside on a read-only file system.
         */
        ERROR_SHALL(POSIX_BIND, EROFS, "bind.07.08", TODO_ERR(EROFS) )

        /*
         * The bind() function may fail if:
         *
         * [EACCES] The specified address is protected and the current user does not
         * have permission to bind to it.
         */
        ERROR_MAY(POSIX_BIND, EACCES, "bind.08.01", TODO_ERR(EACCES))

        /*
         * The bind() function may fail if:
         *
         * [EINVAL] The address_len argument is not a valid length for the address
         * family.
         */
        ERROR_UNCHECKABLE(POSIX_BIND, EINVAL, "bind.08.02", "Invalid length is not allowed in agent")

        /*
         * The bind() function may fail if:
         *
         * [EISCONN] The socket is already connected.
         */
        ERROR_MAY(POSIX_BIND, EISCONN, "bind.08.03", desc!=NULL && getFileKind_FileDescId(socket) == Socket &&
            desc->peer_addr!=NULL)

        /*
         * The bind() function may fail if:
         *
         * [ELOOP] More than {SYMLOOP_MAX} symbolic links were encountered during
         * resolution of the pathname in address.
         */
        ERROR_MAY3(POSIX_BIND, ELOOP, "bind.08.04", and_Bool3(address->family==SUT_AF_UNIX, isELOOP))

        /*
         * The bind() function may fail if:
         *
         * [ENAMETOOLONG] Pathname resolution of a symbolic link produced an
         * intermediate result whose length exceeds {PATH_MAX}.
         */
        ERROR_MAY3(POSIX_BIND, ENAMETOOLONG, "bind.08.05", and_Bool3(address->family==SUT_AF_UNIX, isENAMETOOLONG(context, absPath)))

        /*
         * The bind() function may fail if:
         *
         * [ENOBUFS] Insufficient resources were available to complete the call.
         */
        ERROR_UNCHECKABLE(POSIX_BIND, ENOBUFS, "bind.08.06", "Can not check insufficient resources case")

        ERROR_END()

        /*
         * Upon successful completion, bind() shall return 0;
         */
        REQ("bind.05.01", "Function shall return 0", bind_spec==0);


        /*
         * The bind() function shall assign a local socket address address to a socket
         * identified by descriptor socket that has no local socket address assigned.
         */
        REQ("?bind.01", "Address shall be valid", equals(desc->addr, address));

        /*
         * The socket specified by socket may require the process to have appropriate
         * privileges to use the bind() function.
         */
        REQ("bind.04", "", TODO_REQ());

        return true;
    }
}


void onBind( CallContext context, FileDescId socket, SockaddrT* address, IntT bind_spec)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);

    if (bind_spec!=-1)
    {
        desc->addr=clone(address);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group


NAME

    bindresvport -- bind socket to privileged IP port

SYNOPSIS

    #include <sys/types.h>
    #include <rpc/rpc.h>

    int bindresvport(int sd, struct sockaddr_in * sin);

DESCRIPTION

    If the process has appropriate privilege, the bindresvport() function shall
    bind a socket to a privileged IP port.

RETURN VALUE

    On success, 0 is returned. On error, -1 is returned and the global variable
    errno is set appropriately.

ERRORS

    [EPERM]
    The process did not have appropriate privilege.

    [EPFNOSUPPORT]
    Address of sin did not match address family of sd .
*/
specification
IntT bindresvport_spec( CallContext context, FileDescId sd, SockaddrT* addr, ErrorCode* errno)
{
    pre
    {
        /* [Implicit precondition] */
        REQ("", "Address shall be AF_INET type", addr!=NULL && addr->family == SUT_AF_INET);

        return true;
    }
    post
    {
        SocketFileDescriptor* fdesc=getDescriptor_FileDescId(sd);


        /*
        * On error, -1 is returned and the global variable errno is set appropriately.
        */
        ERROR_BEGIN(LSB_BINDRESVPORT, "bindresvport.02.02", bindresvport_spec==-1, *errno)

        /*
        * [EPERM]
        * The process did not have appropriate privilege.
        */
        ERROR_SHALL(LSB_BINDRESVPORT, EPERM, "bindresvport.03.01", TODO_ERR(EPERM) )

        /*
        * [EPFNOSUPPORT]
        * Address of sin did not match address family of sd .
        */
        ERROR_SHALL(LSB_BINDRESVPORT, EPFNOSUPPORT, "bindresvport.03.02", fdesc!=NULL && fdesc->domain != addr->family)

        ERROR_END()

        /*
        * On success, 0 is returned.
        */
        REQ("bindresvport.02.01", "Function shall return 0", bindresvport_spec==0);

        if (fdesc!=NULL)
        {
            /*
            * If the process has appropriate privilege, the bindresvport() function shall
            * bind a socket to a privileged IP port.
            */
            REQ("?bindresvport.01", "Socket shall be correctly bound", equals(fdesc->addr, addr));
        }

        return true;
    }
}


void onBindrescvport( CallContext context, FileDescId sd, SockaddrT* addr, IntT bindresvport_spec)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(sd);

    if (bindresvport_spec!=-1 && fdesc!=NULL)
    {
        fdesc->addr=clone(addr);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    connect - connect a socket

SYNOPSIS

    #include <sys/socket.h>
    int connect(int socket, const struct sockaddr *address,
           socklen_t address_len);

DESCRIPTION

    The connect() function shall attempt to make a connection on a socket.
    The function takes the following arguments:

    socket
        Specifies the file descriptor associated with the socket.
    address
        Points to a sockaddr structure containing the peer address. The length
        and format of the address depend on the address family of the socket.
    address_len
        Specifies the length of the sockaddr structure pointed to by the
        address argument.

    If the socket has not already been bound to a local address, connect()
    shall bind it to an address which, unless the socket's address family is
    AF_UNIX, is an unused local address.

    If the initiating socket is not connection-mode, then connect() shall set
    the socket's peer address, and no connection is made. For SOCK_DGRAM
    sockets, the peer address identifies where all datagrams are sent on
    subsequent send() functions, and limits the remote sender for subsequent
    recv() functions. If address is a null address for the protocol, the
    socket's peer address shall be reset.

    If the initiating socket is connection-mode, then connect() shall attempt
    to establish a connection to the address specified by the address argument.
    If the connection cannot be established immediately and O_NONBLOCK is not
    set for the file descriptor for the socket, connect() shall block for up to
    an unspecified timeout interval until the connection is established. If the
    timeout interval expires before the connection is established, connect()
    shall fail and the connection attempt shall be aborted. If connect() is
    interrupted by a signal that is caught while blocked waiting to establish a
    connection, connect() shall fail and set errno to [EINTR], but the
    connection request shall not be aborted, and the connection shall be
    established asynchronously.

    If the connection cannot be established immediately and O_NONBLOCK is set
    for the file descriptor for the socket, connect() shall fail and set errno
    to [EINPROGRESS], but the connection request shall not be aborted, and the
    connection shall be established asynchronously. Subsequent calls to
    connect() for the same socket, before the connection is established, shall
    fail and set errno to [EALREADY].

    When the connection has been established asynchronously, select() and
    poll() shall indicate that the file descriptor for the socket is ready for
    writing.

    The socket in use may require the process to have appropriate privileges to
    use the connect() function.

RETURN VALUE

    Upon successful completion, connect() shall return 0; otherwise, -1 shall
    be returned and errno set to indicate the error.

ERRORS

    The connect() function shall fail if:

        [EADDRNOTAVAIL]
        The specified address is not available from the local machine.

        [EAFNOSUPPORT]
        The specified address is not a valid address for the address family of the
        specified socket.

        [EALREADY]
        A connection request is already in progress for the specified socket.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNREFUSED]
        The target address was not listening for connections or refused the
        connection request.

        [EINPROGRESS]
        O_NONBLOCK is set for the file descriptor for the socket and the connection
        cannot be immediately established; the connection shall be established
        asynchronously.

        [EINTR]
        The attempt to establish a connection was interrupted by delivery of a
        signal that was caught; the connection shall be established asynchronously.

        [EISCONN]
        The specified socket is connection-mode and is already connected.

        [ENETUNREACH]
        No route to the network is present.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EPROTOTYPE]
        The specified address has a different type than the socket bound to the
        specified peer address.

        [ETIMEDOUT]
        The attempt to connect timed out before a connection was made.

    If the address family of the socket is AF_UNIX, then connect() shall fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        pathname in address.

        [ENAMETOOLONG]
        A component of a pathname exceeded {NAME_MAX} characters, or an entire
        pathname exceeded {PATH_MAX} characters.

        [ENOENT]
        A component of the pathname does not name an existing file or the pathname
        is an empty string.

        [ENOTDIR]
        A component of the path prefix of the pathname in address is not a
        directory.

    The connect() function may fail if:

        [EACCES]
        Search permission is denied for a component of the path prefix; or write
        access to the named socket is denied.

        [EADDRINUSE]
        Attempt to establish a connection that uses addresses that are already in
        use.

        [ECONNRESET]
        Remote host reset the connection request.

        [EHOSTUNREACH]
        The destination host cannot be reached (probably because the host is down
        or a remote router cannot reach it).

        [EINVAL]
        The address_len argument is not a valid length for the address family; or
        invalid address family in the sockaddr structure.

        [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during resolution
        of the pathname in address.

        [ENAMETOOLONG]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.

        [ENETDOWN]
        The local network interface used to reach the destination is down.

        [ENOBUFS]
        No buffer space is available.

        [EOPNOTSUPP]
        The socket is listening and cannot be connected.
*/


specification
void connect_spec( CallContext context, FileDescId socket, SockaddrT* address)
{
    pre
    {
        return true;
    }
    post
    {
        return true;
    }
}



specification typedef struct ConnectCall ConnectCall = {};


void onConnect( CallContext context, FileDescId socket, SockaddrT* address)
{
    SocketFileDescriptor* sdesc=getDescriptor_FileDescId(socket);
    SockaddrT* oldAddress=sdesc->peer_addr;

    startBlockedCall(context, create_ConnectCall(socket, address, oldAddress));
}


void connect_model(CallContext context, FileDescId socket, SockaddrT* address, ConnectReturnType*  connect_return_value)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
    SocketFileDescriptor* servAddr=getFileDescriptor_Sockaddr(context, address, false);

    if (connect_return_value->functionResult!=-1)
    {
        if (desc->domain!=SUT_PF_UNIX && desc->addr == NULL)
        {
            /*
             * If the socket has not already been bound to a local address, connect() shall
             * bind it to an address which, unless the socket's address family is AF_UNIX, is
             * an unused local address.
             */
            IMPLEMENT_REQ("connect.03");

            desc->addr = NULL; // This address is set in accept_return reaction
        }

        if (address==NULL)
        {
            /*
             * If address is a null address for the protocol, the socket's peer address shall
             * be reset.
             */
            IMPLEMENT_REQ("connect.06");
            desc->peer_addr=NULL;
        }
        else
        {


            if (desc->type==SUT_SOCK_STREAM)
            {
                /*
                 * If the initiating socket is connection-mode, then connect() shall attempt to
                 * establish a connection to the address specified by the address argument.
                 */
                IMPLEMENT_REQ("connect.07");

                desc->peer_addr = clone(connect_return_value->peerAddr);
                if (servAddr!=NULL)
                {
                    append_List(servAddr->waitingAccept, create_FileDescIdObj(socket));
                }
                else
                {
                    setBadVerdict("Wrong sequence, no server to connect found");
                }
            }
            else if (desc->type==SUT_SOCK_DGRAM)
            {
                /*
                 * If the initiating socket is not connection-mode, then connect() shall set the
                 * socket's peer address, and no connection is made.
                 */
                IMPLEMENT_REQ("connect.04");

                desc->peer_addr = clone(address);

            }
            else
            {
                setBadVerdict("Other types are not implemented yet");
            }
        }
    }
    else
    {
        desc->connectRequested=true;
    }
}


void onConnectReturn( CallContext context, ConnectReturnType* connect_return_value, ErrorCode* errno)
{
    ConnectCall* blocked_call=finishBlockedCall(context);

    if (connect_return_value->functionResult!=-1 ||
        (connect_return_value->functionResult==-1 && *errno == SUT_EINPROGRESS))
    {
        connect_model(context, blocked_call->socket, blocked_call->address, connect_return_value);
    }
}


specification typedef struct ConnectReturnType ConnectReturnType= {};


reaction ConnectReturnType* connect_return(void)
{
    post
    {
        CallContext    context=connect_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        ConnectCall*   connCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId     socket = connCall->socket;
        SockaddrT*     destAddr = connCall->address;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
        Bool3 isELOOP;
        CString *absPath;
        CString *path;
        SocketFileDescriptor* destDescriptor = getFileDescriptor_Sockaddr(context, destAddr, false);

        if (destAddr->family==SUT_AF_UNIX)
        {
            absPath = resolvePath_Ext(context, getFileSystem(context), getUnixSocket_path(destAddr), &isELOOP);
            path=getUnixSocket_path(destAddr);
        }
        else
        {
            absPath = create_CString("");
            path = create_CString("");
        }


        /*
         * otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_CONNECT, "connect.15.02", connect_return->functionResult==-1, *(connect_return->errno) )

        /*
         * The connect() function shall fail if:
         *
         * [EADDRNOTAVAIL] The specified address is not available from the local machine.
         */
        ERROR_SHALL(POSIX_CONNECT, EADDRNOTAVAIL, "connect.16.01", TODO_ERR(EADDRNOTAVAIL))

        /*
         * The connect() function shall fail if:
         *
         * [EAFNOSUPPORT] The specified address is not a valid address for the address
         * family of the specified socket.
         */
        ERROR_SHALL(POSIX_CONNECT, EAFNOSUPPORT, "connect.16.02", TODO_ERR(EAFNOSUPPORT) )

        /*
         * The connect() function shall fail if:
         *
         * [EALREADY] A connection request is already in progress for the specified
         * socket.
         */
        /*
         * Subsequent calls to connect() for the same socket, before the connection is
         * established, shall fail and set errno to [EALREADY].
         */
        ERROR_SHALL(POSIX_CONNECT, EALREADY, "connect.16.03;connect.12", desc!=NULL && getFileKind_FileDescId(socket) == Socket && desc->peer_addr==NULL &&
           (desc->type == SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET) && desc->connectRequested == true)

        /*
         * The connect() function shall fail if:
         *
         * [EBADF] The socket argument is not a valid file descriptor.
         */
        ERROR_SHALL(POSIX_CONNECT, EBADF, "connect.16.04", desc == NULL)

        /*
         * The connect() function shall fail if:
         *
         * [ECONNREFUSED] The target address was not listening for connections or
         * refused the connection request.
         */
        ERROR_SHALL3(POSIX_CONNECT, ECONNREFUSED, "connect.16.05", isTargetNotListeningOrRefused(destDescriptor))

        /*
         * The connect() function shall fail if:
         *
         * [EINPROGRESS] O_NONBLOCK is set for the file descriptor for the socket and
         * the connection cannot be immediately established; the connection shall be
         * established asynchronously.
         */
        /*
         * If the connection cannot be established immediately and O_NONBLOCK is set for
         * the file descriptor for the socket, connect() shall fail and set errno to
         * [EINPROGRESS],
         */
        ERROR_SHALL3(POSIX_CONNECT, EINPROGRESS, "connect.16.06;connect.11.01", isO_NONBLOCKset(socket))

        /*
         * The connect() function shall fail if:
         *
         * [EINTR] The attempt to establish a connection was interrupted by delivery of
         * a signal that was caught; the connection shall be established asynchronously.
         */

        /*
         * If connect() is interrupted by a signal that is caught while blocked waiting to
         * establish a connection, connect() shall fail and set errno to [EINTR],
         */
        ERROR_SHALL(POSIX_CONNECT, EINTR, "connect.16.07;connect.10.01", TODO_ERR(EINTR) )

        /*
         * The connect() function shall fail if:
         *
         * [EISCONN] The specified socket is connection-mode and is already connected.
         */
        ERROR_SHALL(POSIX_CONNECT, EISCONN, "connect.16.08", desc!=NULL && getFileKind_FileDescId(socket) == Socket && connCall->peer_addr!=NULL &&
            (desc->type == SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET))

        /*
         * The connect() function shall fail if:
         *
         * [ENETUNREACH] No route to the network is present.
         */
        ERROR_UNCHECKABLE(POSIX_CONNECT, ENETUNREACH, "connect.16.09", "Can not check routing in the network")

        /*
         * The connect() function shall fail if:
         *
         * [ENOTSOCK] The socket argument does not refer to a socket.
         */
        ERROR_SHALL(POSIX_CONNECT, ENOTSOCK, "connect.16.10", getFileDescriptor(socket)!=NULL &&
            getFileKind_FileDescId(socket) != Socket)

        /*
         * The connect() function shall fail if:
         *
         * [EPROTOTYPE] The specified address has a different type than the socket bound
         * to the specified peer address.
         */
        ERROR_SHALL(POSIX_CONNECT, EPROTOTYPE, "connect.16.11",
            destDescriptor!=NULL && destDescriptor->domain != destAddr->family)

        /*
         * The connect() function shall fail if:
         *
         * [ETIMEDOUT] The attempt to connect timed out before a connection was made.
         */
        /*
         * If the timeout interval expires before the connection is established, connect()
         * shall fail and the connection attempt shall be aborted.
         */
        ERROR_SHALL(POSIX_CONNECT, ETIMEDOUT, "connect.16.12;connect.09", TODO_ERR(ETIMEDOUT) )

        /*
         * If the address family of the socket is AF_UNIX, then connect() shall fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        ERROR_UNCHECKABLE(POSIX_CONNECT, EIO, "connect.17.01", "Can not check IO errors")

        /*
         * If the address family of the socket is AF_UNIX, then connect() shall fail if:
         *
         * [ELOOP] A loop exists in symbolic links encountered during resolution of the
         * pathname in address.
         */
        ERROR_SHALL3(POSIX_CONNECT, ELOOP, "connect.17.02", and_Bool3(destAddr->family==SUT_AF_UNIX, isELOOP))

        /*
         * If the address family of the socket is AF_UNIX, then connect() shall fail if:
         *
         * [ENAMETOOLONG] A component of a pathname exceeded {NAME_MAX} characters, or
         * an entire pathname exceeded {PATH_MAX} characters.
         */
        ERROR_SHALL3(POSIX_CONNECT, ENAMETOOLONG, "connect.17.03", and_Bool3(destAddr->family==SUT_AF_UNIX,
            isENAMETOOLONG(context, path)))

        /*
         * If the address family of the socket is AF_UNIX, then connect() shall fail if:
         *
         * [ENOENT] A component of the pathname does not name an existing file or the
         * pathname is an empty string.
         */
        ERROR_SHALL3(POSIX_CONNECT, ENOENT, "connect.17.04", and_Bool3(destAddr->family==SUT_AF_UNIX,
            isENOENT_dir(context, getFileSystem(context), getParentDir_Path(absPath))))

        /*
         * If the address family of the socket is AF_UNIX, then connect() shall fail if:
         *
         * [ENOTDIR] A component of the path prefix of the pathname in address is not a
         * directory.
         */
        ERROR_SHALL3(POSIX_CONNECT, ENOTDIR, "connect.17.05", and_Bool3(destAddr->family==SUT_AF_UNIX,
            isENOTDIR_dir(context, getFileSystem(context), getParentDir_Path(absPath))))

        /*
         * The connect() function may fail if:
         *
         * [EACCES] Search permission is denied for a component of the path prefix; or
         * write access to the named socket is denied.
         */
        ERROR_MAY3(POSIX_CONNECT, EACCES, "connect.18.01", and_Bool3(destAddr->family==SUT_AF_UNIX,
            isEACCES_dir_mkrm(context, getFileSystem(context), absPath)))

        /*
         * The connect() function may fail if:
         *
         * [EADDRINUSE] Attempt to establish a connection that uses addresses that are
         * already in use.
         */
        ERROR_MAY(POSIX_CONNECT, EADDRINUSE, "connect.18.02", TODO_ERR(EADDRINUSE))

        /*
         * The connect() function may fail if:
         *
         * [ECONNRESET] Remote host reset the connection request.
         */
        ERROR_MAY(POSIX_CONNECT, ECONNRESET, "connect.18.03", TODO_ERR(ECONNRESET))

        /*
         * The connect() function may fail if:
         *
         * [EHOSTUNREACH] The destination host cannot be reached (probably because the
         * host is down or a remote router cannot reach it).
         */
        ERROR_UNCHECKABLE(POSIX_CONNECT, EHOSTUNREACH, "connect.18.04", "Can not check if host can be reached")

        /*
         * The connect() function may fail if:
         *
         * [EINVAL] The address_len argument is not a valid length for the address
         * family; or invalid address family in the sockaddr structure.
         */
         ERROR_MAY(POSIX_CONNECT, EINVAL, "connect.18.05",  destAddr->family != SUT_AF_UNSPEC &&
            destAddr->family != SUT_AF_UNIX && destAddr->family != SUT_AF_INET6 && destAddr->family != SUT_AF_INET)

        /*
         * The connect() function may fail if:
         *
         * [ELOOP] More than {SYMLOOP_MAX} symbolic links were encountered during
         * resolution of the pathname in address.
         */
        ERROR_MAY3(POSIX_CONNECT, ELOOP, "connect.18.06", and_Bool3(destAddr->family==SUT_AF_UNIX, isELOOP))

        /*
         * The connect() function may fail if:
         *
         * [ENAMETOOLONG] Pathname resolution of a symbolic link produced an
         * intermediate result whose length exceeds {PATH_MAX}.
         */
        ERROR_MAY3(POSIX_CONNECT, ENAMETOOLONG, "connect.18.07", and_Bool3(destAddr->family==SUT_AF_UNIX, isENAMETOOLONG(context, absPath)))

        /*
         * The connect() function may fail if:
         *
         * [ENETDOWN] The local network interface used to reach the destination is down.
         */
        ERROR_UNCHECKABLE(POSIX_CONNECT, ENETDOWN, "connect.18.08", "Can not determine when network is down")

        /*
         * The connect() function may fail if:
         *
         * [ENOBUFS] No buffer space is available.
         */
        ERROR_UNCHECKABLE(POSIX_CONNECT, ENOBUFS, "connect.18.09", "Can not check lack of memory case")

        /*
         * The connect() function may fail if:
         *
         * [EOPNOTSUPP] The socket is listening and cannot be connected.
         */
        ERROR_MAY(POSIX_CONNECT, EOPNOTSUPP, "connect.18.10", desc!=NULL && getFileKind_FileDescId(socket) == Socket && desc->listening == true)

        ERROR_END()

        /*
         * Upon successful completion, connect() shall return 0;
         */
        REQ("connect.15.01", "Function shall return 0",  connect_return->functionResult == 0);


        /*
         * For SOCK_DGRAM sockets, the peer address identifies where all datagrams are
         * sent on subsequent send() functions, and limits the remote sender for
         * subsequent recv() functions.
         */
        REQ("connect.05", "", TODO_REQ());

        /*
         * but the connection request shall not be aborted, and the connection shall be
         * established asynchronously.
         */
        REQ("connect.10.02;connect.11.02", "", TODO_REQ());


        /*
         * When the connection has been established asynchronously, select() and poll()
         * shall indicate that the file descriptor for the socket is ready for writing.
         */
        REQ("connect.13", "", TODO_REQ());

        /*
         * The socket in use may require the process to have appropriate privileges to use
         * the connect() function.
         */
        REQ("connect.14", "", TODO_REQ());


        return true;
    }

}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getpeername - get the name of the peer socket

SYNOPSIS

    #include <sys/socket.h>
    int getpeername(int socket, struct sockaddr *restrict address,
        socklen_t *restrict address_len);

DESCRIPTION

    The getpeername() function shall retrieve the peer address of the specified
    socket, store this address in the sockaddr structure pointed to by the
    address argument, and store the length of this address in the object
    pointed to by the address_len argument.

    If the actual length of the address is greater than the length of the
    supplied sockaddr structure, the stored address shall be truncated.

    If the protocol permits connections by unbound clients, and the peer is not
    bound, then the value stored in the object pointed to by address is
    unspecified.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The getpeername() function shall fail if:

        [EBADF]
        The socket argument is not a valid file descriptor.

        [EINVAL]
        The socket has been shut down.

        [ENOTCONN]
        The socket is not connected or otherwise has not had the peer
        pre-specified.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The operation is not supported for the socket protocol.

    The getpeername() function may fail if:

        [ENOBUFS]
        Insufficient resources were available in the system to complete the
        call.
*/

specification typedef struct GetPeerNameReturnType GetPeerNameReturnType = {};

specification
GetPeerNameReturnType* getpeername_spec( CallContext context, FileDescId socket, ErrorCode* errno)
{
    SocketFileDescriptor* fdesc= getDescriptor_FileDescId(socket);

    pre
    {
        /*
        * If the protocol permits connections by unbound clients, and the peer is not
        * bound, then the value stored in the object pointed to by address is unspecified.
        */
        REQ("app.getpeername.03", "", TODO_REQ());

        return true;
    }
    post
    {
        /*
        * Otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_GETPEERNAME, "getpeername.04.02", getpeername_spec->funcRes==-1, *errno)

        /*
        * The getpeername() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_GETPEERNAME, EBADF, "getpeername.05.01",getFileDescriptor(socket)==NULL)

        /*
        * The getpeername() function shall fail if:
        *
        * [EINVAL] The socket has been shut down.
        */
        ERROR_MAY(POSIX_GETPEERNAME, EINVAL, "getpeername.05.02", fdesc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            fdesc->shutdown!=SUT_NO_SHUT)

        /*
        * The getpeername() function shall fail if:
        *
        * [ENOTCONN] The socket is not connected or otherwise has not had the peer pre-
        * specified.
        */
        ERROR_SHALL(POSIX_GETPEERNAME, ENOTCONN, "getpeername.05.03", TODO_ERR(ENOTCONN))

        /*
        * The getpeername() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_GETPEERNAME, ENOTSOCK, "getpeername.05.04", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
        * The getpeername() function shall fail if:
        *
        * [EOPNOTSUPP] The operation is not supported for the socket protocol.
        */
        ERROR_SHALL(POSIX_GETPEERNAME, EOPNOTSUPP, "getpeername.05.05", TODO_ERR(EOPNOTSUPP) )

        /*
        * The getpeername() function may fail if:
        *
        * [ENOBUFS] Insufficient resources were available in the system to complete the
        * call.
        */
        ERROR_UNCHECKABLE(POSIX_GETPEERNAME, ENOBUFS, "getpeername.06.01", "Can not check insufficient resources case")

        ERROR_END()

        /*
        * Upon successful completion, 0 shall be returned.
        */
        REQ("getpeername.04.01", "Function shall return 0", getpeername_spec->funcRes==0);


        if (fdesc->peer_addr!=NULL)
        {
            /*
            * The getpeername() function shall retrieve the peer address of the specified
            * socket,
            */
            REQ("getpeername.01.01", "Peer address shall be valid", equals_SockaddrT(fdesc->peer_addr, getpeername_spec->address));
        }

        /*
        * If the actual length of the address is greater than the length of the supplied
        * sockaddr structure, the stored address shall be truncated.
        */
        REQ("getpeername.02", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getsockname - get the socket name

SYNOPSIS

    #include <sys/socket.h>
    int getsockname(int socket, struct sockaddr *restrict address,
        socklen_t *restrict address_len);

DESCRIPTION

    The getsockname() function shall retrieve the locally-bound name of the
    specified socket, store this address in the sockaddr structure pointed to
    by the address argument, and store the length of this address in the object
    pointed to by the address_len argument.

    If the actual length of the address is greater than the length of the
    supplied sockaddr structure, the stored address shall be truncated.

    If the socket has not been bound to a local name, the value stored in the
    object pointed to by address is unspecified.

RETURN VALUE

    Upon successful completion, 0 shall be returned,the address argument shall
    point to the address of the socket, and the address_len argument shall
    point to the length of the address. Otherwise, -1 shall be returned and
    errno set to indicate the error.

ERRORS

    The getsockname() function shall fail if:

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The operation is not supported for this socket's protocol.

    The getsockname() function may fail if:

        [EINVAL]
        The socket has been shut down.

        [ENOBUFS]
        Insufficient resources were available in the system to complete the function.
*/

specification typedef struct GetSockNameReturnType GetSockNameReturnType = {};

specification
GetSockNameReturnType* getsockname_spec( CallContext context, FileDescId socket, ErrorCode* errno)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);
    pre
    {
        return true;
    }
    post
    {

        /*
        * Otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_GETSOCKNAME, "getsockname.04.02", getsockname_spec->funcRes==-1, *errno)

        /*
        * The getsockname() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_GETSOCKNAME, EBADF, "getsockname.05.01", getFileDescriptor(socket)==NULL)

        /*
        * The getsockname() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_GETSOCKNAME, ENOTSOCK, "getsockname.05.02", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
        * The getsockname() function shall fail if:
        *
        * [EOPNOTSUPP] The operation is not supported for this socket's protocol.
        */
        ERROR_SHALL(POSIX_GETSOCKNAME, EOPNOTSUPP, "getsockname.05.03", TODO_ERR(EOPNOTSUPP) )

        /*
        * The getsockname() function may fail if:
        *
        * [EINVAL] The socket has been shut down.
        */
        ERROR_MAY(POSIX_GETSOCKNAME, EINVAL, "getsockname.06.01",  fdesc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            fdesc->shutdown!=SUT_NO_SHUT)

        /*
        * The getsockname() function may fail if:
        *
        * [ENOBUFS] Insufficient resources were available in the system to complete the
        * function.
        */
        ERROR_UNCHECKABLE(POSIX_GETSOCKNAME, ENOBUFS, "getsockname.06.02", "Can not check insufficient resources case")

        ERROR_END()


        /*
        * Upon successful completion,
        *
        * 0 shall be returned,
        */
        REQ("getsockname.04.01.01", "Function shall return zero", getsockname_spec->funcRes==0);

        if (fdesc->addr!=NULL)
        {
            /*
            * The getsockname() function shall retrieve the locally-bound name of the
            * specified socket, store this address in the sockaddr structure pointed to by
            * the address argument,
            */
            REQ("getsockname.01.01", "Correct address shall be returned",
                equals_SockaddrT(fdesc->addr, getsockname_spec->address));
        }

        return true;
    }
}

void onGetSockName( CallContext context, FileDescId socket, GetSockNameReturnType* getsockname_res)
{
    if (getsockname_res->funcRes!=-1)
    {
        SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);
        if (fdesc!=NULL && fdesc->addr==NULL)
        {
            fdesc->addr = clone(getsockname_res->address);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    getsockopt -- get socket options

SYNOPSIS

    #include <sys/socket.h> #include <netinet/ip.h>

    int getsockopt(int socket, int level, int option_name, void * restrict
    option_value, socklen_t * restrict option_len);

DESCRIPTION

    The getsockopt() function shall behave as specified in ISO POSIX (2003), with
    the following extensions.

    IP Protocol Level Options

    If the level parameter is IPPROTO_IP, the following values shall be supported
    for option_name (see RFC 791:Internet Protocol for further details):

    IP_OPTIONS Get the Internet Protocol options sent with every packet from this
    socket. The option_value shall point to a memory buffer in which the options
    shall be placed; on entry option_len shall point to an integer value indicating
    the maximum size of the memory buffer, in bytes. On successful return, the
    value referenced by option_len shall be updated to the size of data copied to
    the buffer. For IPv4, the maximum length of options is 40 bytes.

    IP_TTL Get the current unicast Internet Protocol Time To Live value used when
    sending packets with this socket. The option_value shall point to a buffer
    large enough to hold the time to live value (at least 1 byte), and option_len
    shall point to an integer value holding the maximum size of that buffer. On
    successful return, the value referenced by option_len shall be updated to
    contain the number of bytes copied into the buffer, which shall be no larger
    than the initial value, and option_value shall point to an integer containing
    the time to live value.

    IP_TOS Get the Internet Protocol type of service indicator used when sending
    packets with this socket. The option_value shall point to a buffer large enough
    to hold the type of service indicator (at least 1 byte), and option_len shall
    point to an integer value holding the maximum size of that buffer. On
    successful return, the value referenced by option_len shall be updated to
    contain the number of bytes copied into the buffer, which shall be no larger
    than the initial value, and option_value shall point to an integer containing
    the time to live value.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getsockopt - get the socket options

SYNOPSIS

    #include <sys/socket.h>
    int getsockopt(int socket, int level, int option_name,
        void *restrict option_value, socklen_t *restrict option_len);

DESCRIPTION

    The getsockopt() function manipulates options associated with a socket.

    The getsockopt() function shall retrieve the value for the option specified
    by the option_name argument for the socket specified by the socket
    argument. If the size of the option value is greater than option_len, the
    value stored in the object pointed to by the option_value argument shall be
    silently truncated. Otherwise, the object pointed to by the option_len
    argument shall be modified to indicate the actual length of the value.

    The level argument specifies the protocol level at which the option
    resides. To retrieve options at the socket level, specify the level
    argument as SOL_SOCKET. To retrieve options at other levels, supply the
    appropriate level identifier for the protocol controlling the option. For
    example, to indicate that an option is interpreted by the TCP (Transmission
    Control Protocol), set level to IPPROTO_TCP as defined in the
    <netinet/in.h> header.

    The socket in use may require the process to have appropriate privileges to
    use the getsockopt() function.

    The option_name argument specifies a single option to be retrieved. It can
    be one of the following values defined in <sys/socket.h>:

        SO_DEBUG
        Reports whether debugging information is being recorded. This option
        shall store an int value. This is a Boolean option.

        SO_ACCEPTCONN
        Reports whether socket listening is enabled. This option shall store an
        int value. This is a Boolean option.

        SO_BROADCAST
        Reports whether transmission of broadcast messages is supported, if
        this is supported by the protocol. This option shall store an int
        value. This is a Boolean option.

        SO_REUSEADDR
        Reports whether the rules used in validating addresses supplied to
        bind() should allow reuse of local addresses, if this is supported by
        the protocol. This option shall store an int value. This is a Boolean
        option.

        SO_KEEPALIVE
        Reports whether connections are kept active with periodic transmission
        of messages, if this is supported by the protocol.
        If the connected socket fails to respond to these messages, the
        connection shall be broken and threads writing to that socket shall be
        notified with a SIGPIPE signal.This option shall store an int value.
        This is a Boolean option.

        SO_LINGER
        Reports whether the socket lingers on close() if data is present.If
        SO_LINGER is set, the system shall block the calling thread during
        close() until it can transmit the data or until the end of the interval
        indicated by the l_linger member, whichever comes first.If SO_LINGER is
        not specified, and close() is issued, the system handles the call in a
        way that allows the calling thread to continue as quickly as possible.
        This option shall store a linger structure.

        SO_OOBINLINE
        Reports whether the socket leaves received out-of-band data (data
        marked urgent) inline. This option shall store an int value. This is a
        Boolean option.

        SO_SNDBUF
        Reports send buffer size information. This option shall store an int
        value.

        SO_RCVBUF
        Reports receive buffer size information. This option shall store an int
        value.

        SO_ERROR
        Reports information about error status and clears it. This option shall
        store an int value.

        SO_TYPE
        Reports the socket type. This option shall store an int value. Socket
        types are described in Socket Types.

        SO_DONTROUTE
        Reports whether outgoing messages bypass the standard routing
        facilities. The destination shall be on a directly-connected network,
        and messages are directed to the appropriate network interface
        according to the destination address. The effect, if any, of this
        option depends on what protocol is in use. This option shall store an
        int value. This is a Boolean option.

        SO_RCVLOWAT
        Reports the minimum number of bytes to process for socket input
        operations. The default value for SO_RCVLOWAT is 1. If SO_RCVLOWAT is
        set to a larger value, blocking receive calls normally wait until they
        have received the smaller of the low water mark value or the requested
        amount. (They may return less than the low water mark if an error
        occurs, a signal is caught, or the type of data next in the receive
        queue is different from that returned; for example, out-of-band data.)
        This option shall store an int value. Note that not all implementations
        allow this option to be retrieved.

        SO_RCVTIMEO
        Reports the timeout value for input operations. This option shall store
        a timeval structure with the number of seconds and microseconds
        specifying the limit on how long to wait for an input operation to
        complete. If a receive operation has blocked for this much time without
        receiving additional data, it shall return with a partial count or
        errno set to [EAGAIN] or [EWOULDBLOCK] if no data was received. The
        default for this option is zero, which indicates that a receive
        operation shall not time out. Note that not all implementations allow
        this option to be retrieved.

        SO_SNDLOWAT
        Reports the minimum number of bytes to process for socket output
        operations. Non-blocking output operations shall process no data if
        flow control does not allow the smaller of the send low water mark
        value or the entire request to be processed. This option shall store
        an int value. Note that not all implementations allow this option to
        be retrieved.

        SO_SNDTIMEO
        Reports the timeout value specifying the amount of time that an output
        function blocks because flow control prevents data from being sent. If
        a send operation has blocked for this time, it shall return with a
        partial count or with errno set to [EAGAIN] or [EWOULDBLOCK] if no data
        was sent. The default for this option is zero, which indicates that a
        send operation shall not time out. The option shall store a timeval
        structure. Note that not all implementations allow this option to be
        retrieved.

    For Boolean options, a zero value indicates that the option is disabled and
    a non-zero value indicates that the option is enabled.

RETURN VALUE

    Upon successful completion, getsockopt() shall return 0; otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS

    The getsockopt() function shall fail if:

        [EBADF]
        The socket argument is not a valid file descriptor.

        [EINVAL]
        The specified option is invalid at the specified socket level.

        [ENOPROTOOPT]
        The option is not supported by the protocol.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

    The getsockopt() function may fail if:

        [EACCES]
        The calling process does not have the appropriate privileges.

        [EINVAL]
        The socket has been shut down.

        [ENOBUFS]
        Insufficient resources are available in the system to complete the
        function.
*/


specification typedef struct  GetSockOptReturnType GetSockOptReturnType = {};

specification
GetSockOptReturnType* getsockopt_spec( CallContext context, FileDescId socket, IntT level, IntT option_name, ErrorCode* errno)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);

    pre
    {
        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * The option_value shall point to a memory buffer in which the options shall be
         * placed
         */
        REQ("app.getsockopt.30.01.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * on entry option_len shall point to an integer value indicating the maximum size
         * of the memory buffer, in bytes
         */
        REQ("app.getsockopt.30.01.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * The option_value shall point to a buffer large enough to hold the time to live
         * value (at least 1 byte)
         */
        REQ("app.getsockopt.30.02.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * option_len shall point to an integer value holding the maximum size of that
         * buffer
         */
        REQ("app.getsockopt.30.02.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * The option_value shall point to a buffer large enough to hold the type of
         * service indicator (at least 1 byte)
         */
        REQ("app.getsockopt.30.03.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * option_len shall point to an integer value holding the maximum size of that
         * buffer
         */
        REQ("app.getsockopt.30.03.02", "", TODO_REQ());

        return true;
    }
    post
    {
        /*
         * otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_GETSOCKOPT, "getsockopt.09.02", getsockopt_spec->funcRes==-1, *errno)

        /*
        * The getsockopt() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_GETSOCKOPT, EBADF, "getsockopt.10.01", getFileDescriptor(socket)==NULL)

        /*
        * The getsockopt() function shall fail if:
        *
        * [EINVAL] The specified option is invalid at the specified socket level.
        */
        ERROR_SHALL3(POSIX_GETSOCKOPT, EINVAL, "getsockopt.10.02", isSocketOptionValid(level, socket, option_name))

        /*
        * The getsockopt() function shall fail if:
        *
        * [ENOPROTOOPT] The option is not supported by the protocol.
        */
        ERROR_SHALL(POSIX_GETSOCKOPT, ENOPROTOOPT, "getsockopt.10.03", TODO_ERR(ENOPROTOOPT) )

        /*
        * The getsockopt() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_GETSOCKOPT, ENOTSOCK, "getsockopt.10.04", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
        * The getsockopt() function may fail if:
        *
        * [EACCES] The calling process does not have the appropriate privileges.
        */
        ERROR_MAY(POSIX_GETSOCKOPT, EACCES, "getsockopt.11.01", TODO_ERR(EACCES))

        /*
        * The getsockopt() function may fail if:
        *
        * [EINVAL] The socket has been shut down.
        */
        ERROR_MAY(POSIX_GETSOCKOPT, EINVAL, "getsockopt.11.02", fdesc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            fdesc->shutdown != SUT_NO_SHUT)

        /*
        * The getsockopt() function may fail if:
        *
        * [ENOBUFS] Insufficient resources are available in the system to complete the
        * function.
        */
        ERROR_UNCHECKABLE(POSIX_GETSOCKOPT, ENOBUFS, "getsockopt.11.03", "Can not check insufficient resources case")

        ERROR_END()

        /*
         * Upon successful completion, getsockopt() shall return 0;
         */
        REQ("getsockopt.09.01", "Function shall return zero", getsockopt_spec->funcRes==0);

        {

            SocketOptionValue* val=get_Map(fdesc->socketOptions, create_IntTObj(option_name));

            if ((val->isInt && val->value!=-1) || (val->isLing && val->ling_val->l_linger!=-1 && val->ling_val->l_onoff!=-1)
                || (!val->isInt && !val->isLing))
            {

                if (!val->isInt && !val->isLing)
                {
                    val->time_val->usec = getsockopt_spec->val->time_val->usec;
                }


                /*
                 * The getsockopt() function shall retrieve the value for the option specified by
                 * the option_name argument for the socket specified by the socket argument.
                 */
                REQ("getsockopt.02", "Returned value shall be valid", equals(getsockopt_spec->val, val));
            }
        }

        /*
         * The socket in use may require the process to have appropriate privileges to use
         * the getsockopt() function.
         */
        REQ("getsockopt.06", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_KEEPALIVE
         *
         * If the connected socket fails to respond to these messages, the connection
         * shall be broken and threads writing to that socket shall be notified with a
         * SIGPIPE signal.
         */
        REQ("getsockopt.07.05.02", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_LINGER
         *
         * If SO_LINGER is set, the system shall block the calling thread during close()
         * until it can transmit the data or until the end of the interval indicated by
         * the l_linger member, whichever comes first.
         */
        REQ("getsockopt.07.06.02", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_LINGER
         *
         * If SO_LINGER is not specified, and close() is issued, the system handles the
         * call in a way that allows the calling thread to continue as quickly as possible.
         */
        REQ("getsockopt.07.06.03", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_DONTROUTE
         *
         * The destination shall be on a directly-connected network, and messages are
         * directed to the appropriate network interface according to the destination
         * address.
         */
        REQ("getsockopt.07.12.02", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_DONTROUTE
         *
         * The effect, if any, of this option depends on what protocol is in use.
         */
        REQ("getsockopt.07.12.03", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_RCVLOWAT
         *
         * If SO_RCVLOWAT is set to a larger value, blocking receive calls normally wait
         * until they have received the smaller of the low water mark value or the
         * requested amount.
         */
        REQ("getsockopt.07.13.03", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_RCVLOWAT
         *
         * They may return less than the low water mark if an error occurs, a signal is
         * caught, or the type of data next in the receive queue is different from that
         * returned;
         */
        REQ("getsockopt.07.13.04", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_RCVLOWAT
         *
         * Note that not all implementations allow this option to be retrieved.
         */
        REQ("getsockopt.07.13.06", "", TODO_REQ());

        /*
         * If a receive operation has blocked for this much time without receiving
         * additional data, it shall return with a partial count
         */
        REQ("getsockopt.07.14.03.01", "", TODO_REQ());

        /*
         * or errno set to [EAGAIN] or [EWOULDBLOCK] if no data was received.
         */
        REQ("getsockopt.07.14.03.02", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_RCVTIMEO
         *
         * Note that not all implementations allow this option to be retrieved.
         */
        REQ("getsockopt.07.14.05", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_SNDLOWAT
         *
         * Non-blocking output operations shall process no data if flow control does not
         * allow the smaller of the send low water mark value or the entire request to be
         * processed.
         */
        REQ("getsockopt.07.15.02", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_SNDLOWAT
         *
         * Note that not all implementations allow this option to be retrieved.
         */
        REQ("getsockopt.07.15.04", "", TODO_REQ());

        /*
         * If a send operation has blocked for this time, it shall return with a partial
         * count
         */
        REQ("getsockopt.07.16.02.01", "", TODO_REQ());

        /*
         * or with errno set to [EAGAIN] or [EWOULDBLOCK] if no data was sent.
         */
        REQ("getsockopt.07.16.02.02", "", TODO_REQ());

        /*
         * The option_name argument specifies a single option to be retrieved. It can be
         * one of the following values defined in <sys/socket.h>:
         *
         * SO_SNDTIMEO
         *
         * Note that not all implementations allow this option to be retrieved.
         */
        REQ("getsockopt.07.16.05", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * Get the Internet Protocol options sent with every packet from this socket.
         */
        REQ("getsockopt.30.01.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * On successful return, the value referenced by option_len shall be updated to
         * the size of data copied to the buffer. For IPv4, the maximum length of options
         * is 40 bytes.
         */
        REQ("getsockopt.30.01.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * Get the current unicast Internet Protocol Time To Live value used when sending
         * packets with this socket.
         */
        REQ("getsockopt.30.02.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * On successful return, the value referenced by option_len shall be updated to
         * contain the number of bytes copied into the buffer, which shall be no larger
         * than the initial value
         */
        REQ("getsockopt.30.02.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * option_value shall point to an integer containing the time to live value
         */
        REQ("getsockopt.30.02.03", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * Get the Internet Protocol type of service indicator used when sending packets
         * with this socket.
         */
        REQ("getsockopt.30.03.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * On successful return, the value referenced by option_len shall be updated to
         * contain the number of bytes copied into the buffer, which shall be no larger
         * than the initial value
         */
        REQ("getsockopt.30.03.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * option_value shall point to an integer containing the time to live value
         */
        REQ("getsockopt.30.03.03", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    listen - listen for socket connections and limit the queue of incoming
        connections

SYNOPSIS

    #include <sys/socket.h>
    int listen(int socket, int backlog);

DESCRIPTION

    The listen() function shall mark a connection-mode socket, specified by
    the socket argument, as accepting connections.

    The backlog argument provides a hint to the implementation which the
    implementation shall use to limit the number of outstanding connections in
    the socket's listen queue. Implementations may impose a limit on backlog
    and silently reduce the specified value. Normally, a larger backlog
    argument value shall result in a larger or equal length of the listen
    queue.Implementations shall support values of backlog up to SOMAXCONN,
    defined in <sys/socket.h>.

    The implementation may include incomplete connections in its listen queue.
    The limits on the number of incomplete connections and completed
    connections queued may be different.

    The implementation may have an upper limit on the length of the listen
    queue-either global or per accepting socket. If backlog exceeds this limit,
    the length of the listen queue is set to the limit.

    If listen() is called with a backlog argument value that is less than 0,
    the function behaves as if it had been called with a backlog argument value
    of 0.

    A backlog argument of 0 may allow the socket to accept connections, in
    which case the length of the listen queue may be set to an
    implementation-defined minimum value.

    The socket in use may require the process to have appropriate privileges to
    use the listen() function.

RETURN VALUE

    Upon successful completions, listen() shall return 0; otherwise, -1 shall
    be returned and errno set to indicate the error.

ERRORS

    The listen() function shall fail if:

        [EBADF]
        The socket argument is not a valid file descriptor.

        [EDESTADDRREQ]
        The socket is not bound to a local address, and the protocol does not
        support listening on an unbound socket.

        [EINVAL]
        The socket is already connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The socket protocol does not support listen().

    The listen() function may fail if:

        [EACCES]
        The calling process does not have the appropriate privileges.

        [EINVAL]
        The socket has been shut down.

        [ENOBUFS]
        Insufficient resources are available in the system to complete the
        call.
*/

specification
IntT listen_spec( CallContext context, FileDescId socket, IntT backlog, ErrorCode* errno)
{
    SocketFileDescriptor* desc=NULL;

    pre
    {
        if (getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)==Socket)
        {
            desc = getDescriptor_FileDescId(socket);
        }

        return true;
    }
    post
    {

        /*
        * otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_LISTEN, "listen.12.02", listen_spec==-1, *errno)

        /*
        * The listen() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_LISTEN, EBADF, "listen.13.01", getFileDescriptor(socket)==NULL)

        /*
        * The listen() function shall fail if:
        *
        * [EDESTADDRREQ] The socket is not bound to a local address, and the protocol
        * does not support listening on an unbound socket.
        */
        ERROR_SHALL3(POSIX_LISTEN, EDESTADDRREQ, "listen.13.02", (desc!=NULL && desc->addr != NULL) ? False_Bool3 : Unknown_Bool3)

        /*
        * The listen() function shall fail if:
        *
        * [EINVAL] The socket is already connected.
        */
        ERROR_SHALL(POSIX_LISTEN, EINVAL, "listen.13.03", desc!=NULL && getFileKind_FileDescId(socket)==Socket && desc->peer_addr!=NULL)

        /*
        * The listen() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_LISTEN, ENOTSOCK, "listen.13.04", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
        * The listen() function shall fail if:
        *
        * [EOPNOTSUPP] The socket protocol does not support listen().
        */
        ERROR_SHALL(POSIX_LISTEN, EOPNOTSUPP, "listen.13.05", TODO_ERR(EOPNOTSUPP) )

        /*
        * The listen() function may fail if:
        *
        * [EACCES] The calling process does not have the appropriate privileges.
        */
        ERROR_MAY(POSIX_LISTEN, EACCES, "listen.14.01", TODO_ERR(EACCES))

        /*
        * The listen() function may fail if:
        *
        * [EINVAL] The socket has been shut down.
        */
        ERROR_MAY(POSIX_LISTEN, EINVAL, "listen.14.02",  desc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            desc->shutdown!=SUT_NO_SHUT)

        /*
        * The listen() function may fail if:
        *
        * [ENOBUFS] Insufficient resources are available in the system to complete the
        * call.
        */
        ERROR_UNCHECKABLE(POSIX_LISTEN, ENOBUFS, "listen.14.03", "Can not check insufficient resources case")

        ERROR_END()

        /*
        * Upon successful completions, listen() shall return 0;
        */
        REQ("listen.12.01", "Function shall return zero", listen_spec==0);


        /*
        * The listen() function shall mark a connection-mode socket, specified by the
        * socket argument, as accepting connections.
        */
        REQ("?listen.01", "Socket shall be marked as listening", desc->listening == true);

        /*
        * Implementations may impose a limit on backlog and silently reduce the specified
        * value.
        */
        REQ("listen.03", "", TODO_REQ());

        /*
        * Normally, a larger backlog argument value shall result in a larger or equal
        * length of the listen queue.
        */
        REQ("listen.04", "", TODO_REQ());

        if (backlog<=SUT_SOMAXCONN && backlog > 0)
        {
            /*
            * Implementations shall support values of backlog up to SOMAXCONN, defined in <
            * sys/socket.h>.
            */
            REQ("?listen.05", "Socket backlog value shall be valid", desc->backlog == backlog);
        }

        /*
        * The implementation may include incomplete connections in its listen queue. The
        * limits on the number of incomplete connections and completed connections queued
        * may be different.
        */
        REQ("listen.06", "", TODO_REQ());

        /*
        * The implementation may have an upper limit on the length of the listen queue-
        * either global or per accepting socket.
        */
        REQ("listen.07", "", TODO_REQ());

        /*
        * If backlog exceeds this limit, the length of the listen queue is set to the
        * limit.
        */
        REQ("listen.08", "", TODO_REQ());

        /*
        * If listen() is called with a backlog argument value that is less than 0, the
        * function behaves as if it had been called with a backlog argument value of 0.
        */
        REQ("listen.09", "", TODO_REQ());

        /*
        * A backlog argument of 0 may allow the socket to accept connections, in which
        * case the length of the listen queue may be set to an implementation-defined
        * minimum value.
        */
        REQ("listen.10", "", TODO_REQ());

        /*
        * The socket in use may require the process to have appropriate privileges to use
        * the listen() function.
        */
        REQ("listen.11", "", TODO_REQ());


        return true;
    }
}

void onListen( CallContext context, FileDescId socket, IntT backlog, IntT listen_spec)
{
    if (listen_spec!=-1)
    {
        SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
        desc->listening=true;
        if (backlog <= SUT_SOMAXCONN && backlog > 0)
        {
            desc->backlog=backlog;
        }
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    recv - receive a message from a connected socket

SYNOPSIS

    #include <sys/socket.h>
    ssize_t recv(int socket, void *buffer, size_t length, int flags);

DESCRIPTION

    The recv() function shall receive a message from a connection-mode or
    connectionless-mode socket. It is normally used with connected sockets
    because it does not permit the application to retrieve the source address
    of received data.

    The recv() function takes the following arguments:

        socket
        Specifies the socket file descriptor.

        buffer
        Points to a buffer where the message should be stored.

        length
        Specifies the length in bytes of the buffer pointed to by the buffer
        argument.

        flags
        Specifies the type of message reception. Values of this argument are
        formed by logically OR'ing zero or more of the following values:

            MSG_PEEK
            Peeks at an incoming message. The data is treated as unread and
            the next recv() or similar function shall still return this data.

            MSG_OOB
            Requests out-of-band data. The significance and semantics of
            out-of-band data are protocol-specific.

            MSG_WAITALL
            On SOCK_STREAM sockets this requests that the function block until
            the full amount of data can be returned. The function may return
            the smaller amount of data if the socket is a message-based socket,
            if a signal is caught, if the connection is terminated, if MSG_PEEK
            was specified, or if an error is pending for the socket.

    The recv() function shall return the length of the message written to the
    buffer pointed to by the buffer argument. For message-based sockets, such
    as SOCK_DGRAM and SOCK_SEQPACKET, the entire message shall be read in a
    single operation. If a message is too long to fit in the supplied buffer,
    and MSG_PEEK is not set in the flags argument, the excess bytes shall be
    discarded. For stream-based sockets, such as SOCK_STREAM, message
    boundaries shall be ignored. In this case, data shall be returned to the
    user as soon as it becomes available, and no data shall be discarded.

    If the MSG_WAITALL flag is not set, data shall be returned only up to the
    end of the first message.

    If no messages are available at the socket and O_NONBLOCK is not set on the
    socket's file descriptor, recv() shall block until a message arrives. If no
    messages are available at the socket and O_NONBLOCK is set on the socket's
    file descriptor, recv() shall fail and set errno to [EAGAIN] or
    [EWOULDBLOCK].

RETURN VALUE

    Upon successful completion, recv() shall return the length of the message
    in bytes. If no messages are available to be received and the peer has
    performed an orderly shutdown, recv() shall return 0. Otherwise, -1 shall
    be returned and errno set to indicate the error.

ERRORS

    The recv() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        The socket's file descriptor is marked O_NONBLOCK and no data is
        waiting to be received; or MSG_OOB is set and no out-of-band data is
        available and either the socket's file descriptor is marked O_NONBLOCK
        or the socket does not support blocking to await out-of-band data.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNRESET]
        A connection was forcibly closed by a peer.

        [EINTR]
        The recv() function was interrupted by a signal that was caught, before
        any data was available.

        [EINVAL]
        The MSG_OOB flag is set and no out-of-band data is available.

        [ENOTCONN]
        A receive is attempted on a connection-mode socket that is not
        connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The specified flags are not supported for this socket type or protocol.

        [ETIMEDOUT]
        The connection timed out during connection establishment, or due to a
        transmission timeout on active connection.

    The recv() function may fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.
*/


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    recvfrom - receive a message from a socket

SYNOPSIS

    #include <sys/socket.h>
    ssize_t recvfrom(int socket, void *restrict buffer, size_t length,
        int flags, struct sockaddr *restrict address,
        socklen_t *restrict address_len);

DESCRIPTION

    The recvfrom() function shall receive a message from a connection-mode or
    connectionless-mode socket. It is normally used with connectionless-mode
    sockets because it permits the application to retrieve the source address
    of received data.

    The recvfrom() function takes the following arguments:

        socket
        Specifies the socket file descriptor.

        buffer
        Points to the buffer where the message should be stored.

        length
        Specifies the length in bytes of the buffer pointed to by the buffer argument.

        flags
        Specifies the type of message reception. Values of this argument are
        formed by logically OR'ing zero or more of the following values:

            MSG_PEEK
            Peeks at an incoming message. The data is treated as unread and the
            next recvfrom() or similar function shall still return this data.

            MSG_OOB
            Requests out-of-band data. The significance and semantics of
            out-of-band data are protocol-specific.

            MSG_WAITALL
            On SOCK_STREAM sockets this requests that the function block until
            the full amount of data can be returned. The function may return
            the smaller amount of data if the socket is a message-based socket,
            if a signal is caught, if the connection is terminated, if MSG_PEEK
            was specified, or if an error is pending for the socket.

        address
        A null pointer, or points to a sockaddr structure in which the
        sending address is to be stored. The length and format of the
        address depend on the address family of the socket.

        address_len
        Specifies the length of the sockaddr structure pointed to by the
        address argument.

    The recvfrom() function shall return the length of the message written to
    the buffer pointed to by the buffer argument. For message-based sockets,
    such as [RS]   SOCK_RAW,  SOCK_DGRAM, and SOCK_SEQPACKET, the entire
    message shall be read in a single operation. If a message is too long to
    fit in the supplied buffer, and MSG_PEEK is not set in the flags argument,
    the excess bytes shall be discarded. For stream-based sockets, such as
    SOCK_STREAM, message boundaries shall be ignored. In this case, data shall
    be returned to the user as soon as it becomes available, and no data shall
    be discarded.

    If the MSG_WAITALL flag is not set, data shall be returned only up to the
    end of the first message.

    Not all protocols provide the source address for messages. If the address
    argument is not a null pointer and the protocol provides the source address
    of messages, the source address of the received message shall be stored in
    the sockaddr structure pointed to by the address argument, and the length
    of this address shall be stored in the object pointed to by the address_len
    argument.

    If the actual length of the address is greater than the length of the
    supplied sockaddr structure, the stored address shall be truncated.

    If the address argument is not a null pointer and the protocol does not
    provide the source address of messages, the value stored in the object
    pointed to by address is unspecified.

    If no messages are available at the socket and O_NONBLOCK is not set on
    the socket's file descriptor, recvfrom() shall block until a message
    arrives.If no messages are available at the socket and O_NONBLOCK is set on
    the socket's file descriptor, recvfrom() shall fail and set errno to
    [EAGAIN] or [EWOULDBLOCK].

RETURN VALUE

    Upon successful completion, recvfrom() shall return the length of the
    message in bytes. If no messages are available to be received and the peer
    has performed an orderly shutdown, recvfrom() shall return 0. Otherwise,
    the function shall return -1 and set errno to indicate the error.

ERRORS

    The recvfrom() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        The socket's file descriptor is marked O_NONBLOCK and no data is
        waiting to be received; or MSG_OOB is set and no out-of-band data is
        available and either the socket's file descriptor is marked O_NONBLOCK
        or the socket does not support blocking to await out-of-band data.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNRESET]
        A connection was forcibly closed by a peer.

        [EINTR]
        A signal interrupted recvfrom() before any data was available.

        [EINVAL]
        The MSG_OOB flag is set and no out-of-band data is available.

        [ENOTCONN]
        A receive is attempted on a connection-mode socket that is not
        connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The specified flags are not supported for this socket type.

        [ETIMEDOUT]
        The connection timed out during connection establishment, or due to a
        transmission timeout on active connection.

    The recvfrom() function may fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.
*/

specification typedef struct RecvReturnType RecvReturnType = {};

//This specification refers to: recv, recvfrom
specification
void recv_spec( CallContext context, FileDescId socket, SizeT length, bool peek, bool oob, bool waitall, bool from)
{
    pre
    {
        if (from)
        {
            /*
            * If the address argument is not a null pointer and the protocol does not provide
            * the source address of messages, the value stored in the object pointed to by
            * address is unspecified.
            */
            REQ("app.recvfrom.13", "", TODO_REQ());
        }

        return true;
    }
    post
    {
        return true;
    }
}

specification typedef struct RecvCall RecvCall = {};

void onRecv( CallContext context, FileDescId socket, SizeT length, bool peek, bool oob, bool waitall, bool from)
{
    CByteArray* oldData=NULL;
    SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);

    if (desc!=NULL && getFileKind_FileDescId(socket)==Socket)
    {
        oldData = clone(desc->data);
    }

    startBlockedCall(context, create_RecvCall(socket, length, peek, oob, waitall, from, oldData));
}

void recv_model(CallContext context,  FileDescId socket, CByteArray** notModifiedData, List** notUDPModifiedData, bool peek, SizeT retVal,  CByteArray* returnedData)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);

    if (desc->type==SUT_SOCK_STREAM)
    {
        *notModifiedData=clone(desc->data);
    }
    else if (desc->type==SUT_SOCK_DGRAM)
    {
        *notUDPModifiedData = clone(desc->udpData);
    }
    else
    {
        setBadVerdict("Specification for other protocols not implemented yet");
        return;
    }

    if (peek==false)
    {
        if (desc->type==SUT_SOCK_STREAM)
        {
            if (size_CByteArray(desc->data)>=retVal)
            {
                /*
                 * For stream-based sockets, such as SOCK_STREAM, message boundaries shall be
                 * ignored. In this case, data shall be returned to the user as soon as it becomes
                 * available, and no data shall be discarded.
                 */
                /*
                 * For stream-based sockets, such as SOCK_STREAM, message boundaries shall be
                 * ignored. In this case, data shall be returned to the user as soon as it becomes
                 * available, and no data shall be discarded.
                 */
                IMPLEMENT_REQ("recv.07;recvfrom.07");

                desc->data=right_CByteArray(desc->data, retVal);
            }
            else
            {
                setBadVerdict("Not enough data to receive");
            }
        }
        else if (desc->type==SUT_SOCK_DGRAM)
        {
            IntT ind= findCByteArrayInList(desc->udpData, returnedData, retVal);

            if (ind!=-1)
            {
                /*
                 * For message-based sockets, such as SOCK_DGRAM and SOCK_SEQPACKET, the entire
                 * message shall be read in a single operation.
                 */
                /*
                 * For message-based sockets, such as [RS]  SOCK_RAW, SOCK_DGRAM, and
                 * SOCK_SEQPACKET, the entire message shall be read in a single operation.
                 */
                IMPLEMENT_REQ("recv.05;recvfrom.05");


                /*
                 * If a message is too long to fit in the supplied buffer, and MSG_PEEK is not set
                 * in the flags argument, the excess bytes shall be discarded.
                 */
                /*
                 * If a message is too long to fit in the supplied buffer, and MSG_PEEK is not set
                 * in the flags argument, the excess bytes shall be discarded.
                 */
                IMPLEMENT_REQ("recv.06;recvfrom.06");

                remove_List(desc->udpData, ind);
            }
            else
            {
                setBadVerdict("Message shall be found");
            }
        }
        else
        {
            setBadVerdict("Specification for other protocols not implemented yet");
        }
    }
}

void onRecvReturn( CallContext context, RecvReturnType* recv_ret_val)
{
    RecvCall* blocked_call=finishBlockedCall(context);
    if (recv_ret_val->retVal!=-1)
    {
        recv_model(context,  blocked_call->socket, &recv_ret_val->notModifiedData, &recv_ret_val->notUDPModifiedData, blocked_call->peek, recv_ret_val->retVal,  recv_ret_val->returnedData);
    }
}

reaction RecvReturnType* recv_return(void)
{
    post
    {
        CallContext    context=recv_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        RecvCall*      recvCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId     socket =recvCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
        CByteArray*     oldData=recvCall->oldData;
        bool from = recvCall->from;

        if (!from){ FILTER("recv");}
        else{ FILTER("recvfrom"); }

        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        /*
         * Otherwise, the function shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_RECV, "recv.11.02;recvfrom.16.02", recv_return->retVal == -1, *(recv_return->errno))

        /*
        * The recv() function shall fail if:
        *
        * [EAGAIN] or [EWOULDBLOCK] The socket's file descriptor is marked O_NONBLOCK
        * and no data is waiting to be received; or MSG_OOB is set and no out-of-band
        * data is available and either the socket's file descriptor is marked O_NONBLOCK
        * or the socket does not support blocking to await out-of-band data.
        */
        /*
         * If no messages are available at the socket and O_NONBLOCK is set on the socket'
         * s file descriptor, recv() shall fail and set errno to [EAGAIN] or [EWOULDBLOCK].
         */
        /*
        * The recvfrom() function shall fail if:
        *
        * [EAGAIN] or [EWOULDBLOCK] The socket's file descriptor is marked O_NONBLOCK
        * and no data is waiting to be received; or MSG_OOB is set and no out-of-band
        * data is available and either the socket's file descriptor is marked O_NONBLOCK
        * or the socket does not support blocking to await out-of-band data.
        */
        /*
         * If no messages are available at the socket and O_NONBLOCK is set on the socket'
         * s file descriptor, recvfrom() shall fail and set errno to [EAGAIN] or
         * [EWOULDBLOCK].
         */
        ERROR_SHALL3(POSIX_RECV, EAGAIN, "recv.12.01;recv.09.02;recvfrom.17.01;recvfrom.14.02", isO_NONBLOCKset(socket))

        ERROR_SHALL3(POSIX_RECV, EWOULDBLOCK, "recv.12.01;recv.09.02;recvfrom.17.01;recvfrom.14.02", isO_NONBLOCKset(socket))

        /*
        * The recv() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_RECV, EBADF, "recv.12.02;recvfrom.17.02", getFileDescriptor(socket)==NULL)

        /*
        * The recv() function shall fail if:
        *
        * [ECONNRESET] A connection was forcibly closed by a peer.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [ECONNRESET] A connection was forcibly closed by a peer.
        */
        ERROR_SHALL(POSIX_RECV, ECONNRESET, "recv.12.03;recvfrom.17.03", TODO_ERR(ECONNRESET) )

        /*
        * The recv() function shall fail if:
        *
        * [EINTR] The recv() function was interrupted by a signal that was caught,
        * before any data was available.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [EINTR] A signal interrupted recvfrom() before any data was available.
        */
        ERROR_SHALL(POSIX_RECV, EINTR, "recv.12.04;recvfrom.17.04", TODO_ERR(EINTR) )

        /*
        * The recv() function shall fail if:
        *
        * [EINVAL] The MSG_OOB flag is set and no out-of-band data is available.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [EINVAL] The MSG_OOB flag is set and no out-of-band data is available.
        */
        ERROR_SHALL(POSIX_RECV, EINVAL, "recv.12.05;recvfrom.17.05", TODO_ERR(EINVAL) )

        /*
        * The recv() function shall fail if:
        *
        * [ENOTCONN] A receive is attempted on a connection-mode socket that is not
        * connected.
        */
        /*
         * It is normally used with connected sockets because it does not permit the
         * application to retrieve the source address of received data.
         */
        /*
        * The recvfrom() function shall fail if:
        *
        * [ENOTCONN] A receive is attempted on a connection-mode socket that is not
        * connected.
        */
        ERROR_SHALL(POSIX_RECV, ENOTCONN, "recv.12.06;recv.02;recvfrom.17.06", desc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            (desc->type==SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET) && desc->peer_addr == NULL)

        /*
        * The recv() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_RECV, ENOTSOCK, "recv.12.07;recvfrom.17.07", getFileDescriptor(socket)!=NULL &&
            getFileKind_FileDescId(socket)!=Socket)

        /*
        * The recv() function shall fail if:
        *
        * [EOPNOTSUPP] The specified flags are not supported for this socket type or
        * protocol.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [EOPNOTSUPP] The specified flags are not supported for this socket type.
        */
        ERROR_SHALL(POSIX_RECV, EOPNOTSUPP, "recv.12.08;recvfrom.17.08", TODO_ERR(EOPNOTSUPP) )

        /*
        * The recv() function shall fail if:
        *
        * [ETIMEDOUT] The connection timed out during connection establishment, or due
        * to a transmission timeout on active connection.
        */
        /*
        * The recvfrom() function shall fail if:
        *
        * [ETIMEDOUT] The connection timed out during connection establishment, or due
        * to a transmission timeout on active connection.
        */
        ERROR_SHALL(POSIX_RECV, ETIMEDOUT, "recv.12.09;recvfrom.17.09", TODO_ERR(ETIMEDOUT) )

        /*
        * The recv() function may fail if:
        *
        * [EIO] An I/O error occurred while reading from or writing to the file system.
        */
        /*
        * The recvfrom() function may fail if:
        *
        * [EIO] An I/O error occurred while reading from or writing to the file system.
        */
        ERROR_UNCHECKABLE(POSIX_RECV, EIO, "recv.13.01;recvfrom.18.01", "Can not check IO errors")

        /*
        * The recv() function may fail if:
        *
        * [ENOBUFS] Insufficient resources were available in the system to perform the
        * operation.
        */
        /*
        * The recvfrom() function may fail if:
        *
        * [ENOBUFS] Insufficient resources were available in the system to perform the
        * operation.
        */
        ERROR_UNCHECKABLE(POSIX_RECV, ENOBUFS, "recv.13.02;recvfrom.18.02", "Can not check insufficient resources case")

        /*
        * The recv() function may fail if:
        *
        * [ENOMEM] Insufficient memory was available to fulfill the request.
        */
        /*
        * The recvfrom() function may fail if:
        *
        * [ENOMEM] Insufficient memory was available to fulfill the request.
        */
        ERROR_UNCHECKABLE(POSIX_RECV, ENOMEM, "recv.13.03;recvfrom.18.03", "Can not check insufficient memory case")

        ERROR_END()

        if (from)
        {
            if (desc->peer_addr!=NULL && recv_return->addr->addr!=NULL)
            {
                /*
                 * If the address argument is not a null pointer and the protocol provides the
                 * source address of messages,
                 *
                 * the source address of the received message shall be stored in the sockaddr
                 * structure pointed to by the address argument,
                 */
                REQ("recvfrom.10.01", "Source address shall be valid", equals_SockaddrT(desc->peer_addr, recv_return->addr));
            }
        }


        if (desc->type==SUT_SOCK_STREAM)
        {
            SocketFileDescriptor* peer = getFileDescriptor_Peer(context, socket, desc);

            /*
             * The recv() function shall receive a message from a connection-mode or
             * connectionless-mode socket.
             */
            /*
             * The recvfrom() function shall receive a message from a connection-mode or
             * connectionless-mode socket.
             */
            REQ("recv.01;recvfrom.01", "TCP read data shall be valid", compare_CByteArrays(recv_return->returnedData, recv_return->notModifiedData, recv_return->retVal));

            if (size_CByteArray(recv_return->notModifiedData)==0 && peer!=NULL && peer->shutdown!=SUT_NO_SHUT)
            {
                 /*
                 * If no messages are available to be received and the peer has performed an
                 * orderly shutdown, recv() shall return 0.
                 */
                /*
                 * If no messages are available to be received and the peer has performed an
                 * orderly shutdown, recvfrom() shall return 0.
                 */
                REQ("recv.11.01;recvfrom.16.01", "Function shall return 0", recv_return->retVal==0);
            }

        }
        else if (desc->type==SUT_SOCK_DGRAM)
        {
            /*
             * The recv() function shall receive a message from a connection-mode or
             * connectionless-mode socket.
             */
            /*
             * The recvfrom() function shall receive a message from a connection-mode or
             * connectionless-mode socket.
             */
            REQ("recv.01;recvfrom.01", "UDP read data shall be valid", findCByteArrayInList(recv_return->notUDPModifiedData, recv_return->returnedData, recv_return->retVal)!=-1);

            if (size_List(recv_return->notUDPModifiedData)==0 && from)
            {
                SocketFileDescriptor* peer = getFileDescriptor_Sockaddr(context, recv_return->addr, false);

                if (peer->shutdown!=SUT_NO_SHUT)
                {
                     /*
                     * If no messages are available to be received and the peer has performed an
                     * orderly shutdown, recv() shall return 0.
                     */
                    /*
                     * If no messages are available to be received and the peer has performed an
                     * orderly shutdown, recvfrom() shall return 0.
                     */
                    REQ("recv.11.01;recvfrom.16.01", "Function shall return 0", recv_return->retVal==0);
                }
            }

        }
        else
        {
            REQ("", "Specification for other protocols not implemented yet", false);
        }

        if (recvCall->peek && recvCall->oldData != NULL)
        {
            /*
             * The recv() function takes the following arguments:
             *
             * flags Specifies the type of message reception. Values of this argument are
             * formed by logically OR'ing zero or more of the following values:
             *
             * MSG_PEEK Peeks at an incoming message. The data is treated as unread and the
             * next recv() or similar function shall still return this data.
             */
            /*
             * The recvfrom() function takes the following arguments:
             *
             * flags Specifies the type of message reception. Values of this argument are
             * formed by logically OR'ing zero or more of the following values:
             *
             * MSG_PEEK Peeks at an incoming message. The data is treated as unread and the
             * next recvfrom() or similar function shall still return this data.
             */
            REQ("?recv.03.04.01;recvfrom.03.04.01", "Data buffer shall be unchanged", compare_CByteArrays(recvCall->oldData, desc->data, size_CByteArray(recvCall->oldData)));
        }

        /*
         * The recv() function takes the following arguments:
         *
         * flags Specifies the type of message reception. Values of this argument are
         * formed by logically OR'ing zero or more of the following values:
         *
         * MSG_WAITALL
         *
         * The function may return the smaller amount of data if the socket is a message-
         * based socket, if a signal is caught, if the connection is terminated, if
         * MSG_PEEK was specified, or if an error is pending for the socket.
         */
        /*
         * The recvfrom() function takes the following arguments:
         *
         * flags Specifies the type of message reception. Values of this argument are
         * formed by logically OR'ing zero or more of the following values:
         *
         * MSG_WAITALL
         *
         * On SOCK_STREAM sockets this requests that the function block until the full
         * amount of data can be returned.
         */
        REQ("recv.03.04.03.02;recvfrom.03.04.03.01", "", TODO_REQ());

        /*
         * The recv() function shall return the length of the message written to the
         * buffer pointed to by the buffer argument.
         */
        /*
         * Upon successful completion, recv() shall return the length of the message in
         * bytes.
         */
        /*
         * The recvfrom() function shall return the length of the message written to the
         * buffer pointed to by the buffer argument.
         */
        /*
         * Upon successful completion, recvfrom() shall return the length of the message
         * in bytes.
         */
        REQ("?recv.04;recv.10;recvfrom.04;recvfrom.15", "Valid length shall be returned",
            size_CByteArray(recv_return->returnedData)==recv_return->retVal);


        /*
         * If the MSG_WAITALL flag is not set, data shall be returned only up to the end
         * of the first message.
         */
        REQ("recv.08", "", TODO_REQ());

        /*
         * The recvfrom() function takes the following arguments:
         *
         * flags Specifies the type of message reception. Values of this argument are
         * formed by logically OR'ing zero or more of the following values:
         *
         * MSG_WAITALL
         *
         * The function may return the smaller amount of data if the socket is a message-
         * based socket, if a signal is caught, if the connection is terminated, if
         * MSG_PEEK was specified, or if an error is pending for the socket.
         */
        REQ("recvfrom.03.04.03.02", "", TODO_REQ());

        /*
         * If the MSG_WAITALL flag is not set, data shall be returned only up to the end
         * of the first message.
         */
        REQ("recvfrom.08", "", TODO_REQ());

        /*
         * Not all protocols provide the source address for messages.
         */
        REQ("recvfrom.09", "", TODO_REQ());


        /*
         * If the actual length of the address is greater than the length of the supplied
         * sockaddr structure, the stored address shall be truncated.
         */
        REQ("recvfrom.11", "", TODO_REQ());

        return true;
    }

    FILTER_CLEAN;
}


/*
specification
void recvfrom_spec( CallContext context, FileDescId)
{
  pre
  {
    return true;
  }
  coverage C
  {
    return { TheOnlyBranch, "The only branch" };
  }
  post
  {
    return true;
  }
}
*/


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    recvmsg - receive a message from a socket

SYNOPSIS

    #include <sys/socket.h>
    ssize_t recvmsg(int socket, struct msghdr *message, int flags);

DESCRIPTION

    The recvmsg() function shall receive a message from a connection-mode or
    connectionless-mode socket. It is normally used with connectionless-mode
    sockets because it permits the application to retrieve the source address
    of received data.

    The recvmsg() function takes the following arguments:

        socket
        Specifies the socket file descriptor.

        message
        Points to a msghdr structure, containing both the buffer to store the
        source address and the buffers for the incoming message. The length and
        format of the address depend on the address family of the socket. The
        msg_flags member is ignored on input, but may contain meaningful values
        on output.

        flags
        Specifies the type of message reception. Values of this argument are
        formed by logically OR'ing zero or more of the following values:

            MSG_OOB
            Requests out-of-band data. The significance and semantics of
            out-of-band data are protocol-specific.

            MSG_PEEK
            Peeks at the incoming message.

            MSG_WAITALL
            On SOCK_STREAM sockets this requests that the function block until
            the full amount of data can be returned. The function may return
            the smaller amount of data if the socket is a message-based socket,
            if a signal is caught, if the connection is terminated, if MSG_PEEK
            was specified, or if an error is pending for the socket.

    The recvmsg() function shall receive messages from unconnected or connected
    sockets and shall return the length of the message.

    The recvmsg() function shall return the total length of the message. For
    message-based sockets, such as SOCK_DGRAM and SOCK_SEQPACKET, the entire
    message shall be read in a single operation. If a message is too long to
    fit in the supplied buffers, and MSG_PEEK is not set in the flags argument,
    the excess bytes shall be discarded, and MSG_TRUNC shall be set in the
    msg_flags member of the msghdr structure. For stream-based sockets, such as
    SOCK_STREAM, message boundaries shall be ignored. In this case, data shall
    be returned to the user as soon as it becomes available, and no data shall
    be discarded.

    If the MSG_WAITALL flag is not set, data shall be returned only up to the
    end of the first message.

    If no messages are available at the socket and O_NONBLOCK is not set on the
    socket's file descriptor, recvmsg() shall block until a message arrives. If
    no messages are available at the socket and O_NONBLOCK is set on the
    socket's file descriptor, the recvmsg() function shall fail and set errno
    to [EAGAIN] or [EWOULDBLOCK].

    In the msghdr structure, the msg_name and msg_namelen members specify the
    source address if the socket is unconnected. If the socket is connected,
    the msg_name and msg_namelen members shall be ignored. The msg_name member
    may be a null pointer if no names are desired or required. The msg_iov and
    msg_iovlen fields are used to specify where the received data shall be
    stored. msg_iov points to an array of iovec structures; msg_iovlen shall be
    set to the dimension of this array. In each iovec structure, the iov_base
    field specifies a storage area and the iov_len field gives its size in
    bytes. Each storage area indicated by msg_iov is filled with received data
    in turn until all of the received data is stored or all of the areas have
    been filled.

    Upon successful completion, the msg_flags member of the message header
    shall be the bitwise-inclusive OR of all of the following flags that
    indicate conditions detected for the received message:

        MSG_EOR
        End-of-record was received (if supported by the protocol).

        MSG_OOB
        Out-of-band data was received.

        MSG_TRUNC
        Normal data was truncated.

        MSG_CTRUNC
        Control data was truncated.

RETURN VALUE

    Upon successful completion, recvmsg() shall return the length of the
    message in bytes. If no messages are available to be received and the peer
    has performed an orderly shutdown, recvmsg() shall return 0. Otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS

    The recvmsg() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        The socket's file descriptor is marked O_NONBLOCK and no data is
        waiting to be received; or MSG_OOB is set and no out-of-band data is
        available and either the socket's file descriptor is marked O_NONBLOCK
        or the socket does not support blocking to await out-of-band data.

        [EBADF]
        The socket argument is not a valid open file descriptor.

        [ECONNRESET]
        A connection was forcibly closed by a peer.

        [EINTR]
        This function was interrupted by a signal before any data was
        available.

        [EINVAL]
        The sum of the iov_len values overflows a ssize_t, or the MSG_OOB flag
        is set and no out-of-band data is available.

        [EMSGSIZE]
        The msg_iovlen member of the msghdr structure pointed to by message is
        less than or equal to 0, or is greater than {IOV_MAX}.

        [ENOTCONN]
        A receive is attempted on a connection-mode socket that is not
        connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The specified flags are not supported for this socket type.

        [ETIMEDOUT]
        The connection timed out during connection establishment, or due to a
        transmission timeout on active connection.

    The recvmsg() function may fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.
*/
specification
void recvmsg_spec( CallContext context, FileDescId socket, SocketMsgHdr* msg,  bool peek, bool oob, bool waitall)
{
    pre
    {
        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct RecvmsgCall RecvmsgCall = {};


void onRecvMsg( CallContext context, FileDescId socket, SocketMsgHdr* msg,  bool peek, bool oob, bool waitall)
{
    startBlockedCall(context, create_RecvmsgCall(socket, msg, peek, oob, waitall));
}

specification typedef struct RecvmsgReturnType RecvmsgReturnType = {};


SocketMsgHdr* recvmsg_model( CallContext context, RecvmsgReturnType* recv_ret_val, RecvmsgCall* blocked_call)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(blocked_call->socket);

    recv_ret_val->notModifiedSentMessages=clone(desc->sentMessages);

    if (size_List(desc->sentMessages)==0)
    {
        setBadVerdict("Size of the sent messages list shall not be NULL");
        return NULL;
    }

    if (blocked_call->peek==false)
    {
        if (desc->type==SUT_SOCK_STREAM)
        {
            remove_List(desc->sentMessages, 0);
        }
        else if (desc->type==SUT_SOCK_DGRAM)
        {
            IntT ml = findMessageInList(desc->sentMessages, recv_ret_val->msg);

            if (ml==-1)
            {
                setBadVerdict("Message shall be found");
                return NULL;
            }
            remove_List(desc->sentMessages, ml);

        }
        else
        {
            setBadVerdict("Specification for other protocols not implemented yet");
        }
    }

    return NULL;
}


void onRecvMsgReturn( CallContext context, RecvmsgReturnType* recvmsg_ret_val)
{
    RecvmsgCall* blocked_call=finishBlockedCall(context);
    if (recvmsg_ret_val->retVal!=-1)
    {
        recvmsg_model(context, recvmsg_ret_val, blocked_call);
    }
}




reaction RecvmsgReturnType* recvmsg_return(void)
{
    post
    {
        CallContext    context=recvmsg_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        RecvmsgCall*   recvmsgCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId     socket =recvmsgCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
        SocketMsgHdr*  sourceMsg=recvmsgCall->msg;
        SocketMsgHdr*  recievedMsg=recvmsg_return->msg;


        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_RECVMSG, "recvmsg.20.02", recvmsg_return->retVal==-1, *(recvmsg_return->errno))

        /*
         * The recvmsg() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The socket's file descriptor is marked O_NONBLOCK
         * and no data is waiting to be received; or MSG_OOB is set and no out-of-band
         * data is available and either the socket's file descriptor is marked O_NONBLOCK
         * or the socket does not support blocking to await out-of-band data.
         */
        /*
         * If no messages are available at the socket and O_NONBLOCK is set on the socket'
         * s file descriptor, the recvmsg() function shall fail and set errno to [EAGAIN]
         * or [EWOULDBLOCK].
         */
        ERROR_SHALL3(POSIX_RECVMSG, EAGAIN, "recvmsg.21.01;recvmsg.10.02", isO_NONBLOCKset(socket))

        ERROR_SHALL3(POSIX_RECVMSG, EWOULDBLOCK, "recvmsg.21.01;recvmsg.10.02", isO_NONBLOCKset(socket))

        /*
         * The recvmsg() function shall fail if:
         *
         * [EBADF] The socket argument is not a valid open file descriptor.
         */
        ERROR_SHALL(POSIX_RECVMSG, EBADF, "recvmsg.21.02", getFileDescriptor(socket)==NULL)

        /*
         * The recvmsg() function shall fail if:
         *
         * [ECONNRESET] A connection was forcibly closed by a peer.
         */
        ERROR_SHALL(POSIX_RECVMSG, ECONNRESET, "recvmsg.21.03", TODO_ERR(ECONNRESET) )

        /*
         * The recvmsg() function shall fail if:
         *
         * [EINTR] This function was interrupted by a signal before any data was
         * available.
         */
        ERROR_SHALL(POSIX_RECVMSG, EINTR, "recvmsg.21.04", TODO_ERR(EINTR) )

        /*
         * The recvmsg() function shall fail if:
         *
         * [EINVAL] The sum of the iov_len values overflows a ssize_t, or the MSG_OOB
         * flag is set and no out-of-band data is available.
         */
         ERROR_SHALL3(POSIX_RECVMSG, EINVAL, "recvmsg.21.05", sumIOVecMembers(sourceMsg->msg_iov)>(SSizeT)max_SSizeT ? True_Bool3 : Unknown_Bool3)

        /*
         * The recvmsg() function shall fail if:
         *
         * [EMSGSIZE] The msg_iovlen member of the msghdr structure pointed to by
         * message is less than or equal to 0, or is greater than {IOV_MAX}.
         */
         ERROR_SHALL(POSIX_RECVMSG, EMSGSIZE, "recvmsg.21.06",
             getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_UNKNOWN
             &&
             getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_NO_LIMIT
             &&
             size_List(sourceMsg->msg_iov) > getSystemConfigurationValue(context, SUT_SC_IOV_MAX))

        /*
         * The recvmsg() function shall fail if:
         *
         * [ENOTCONN] A receive is attempted on a connection-mode socket that is not
         * connected.
         */
         ERROR_SHALL(POSIX_RECVMSG, ENOTCONN, "recvmsg.21.07",desc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            (desc->type==SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET) && desc->peer_addr == NULL)

        /*
         * The recvmsg() function shall fail if:
         *
         * [ENOTSOCK] The socket argument does not refer to a socket.
         */
        ERROR_SHALL(POSIX_RECVMSG, ENOTSOCK, "recvmsg.21.08", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
         * The recvmsg() function shall fail if:
         *
         * [EOPNOTSUPP] The specified flags are not supported for this socket type.
         */
        ERROR_SHALL(POSIX_RECVMSG, EOPNOTSUPP, "recvmsg.21.09", TODO_ERR(EOPNOTSUPP))

        /*
         * The recvmsg() function shall fail if:
         *
         * [ETIMEDOUT] The connection timed out during connection establishment, or due
         * to a transmission timeout on active connection.
         */
        ERROR_SHALL(POSIX_RECVMSG, ETIMEDOUT, "recvmsg.21.10", TODO_ERR(ETIMEDOUT))

        /*
         * The recvmsg() function may fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        ERROR_UNCHECKABLE(POSIX_RECVMSG, EIO, "recvmsg.22.01", "Can not check IO errors")

        /*
         * The recvmsg() function may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_RECVMSG, ENOBUFS, "recvmsg.22.02", "Can not check insufficient resources case")

        /*
         * The recvmsg() function may fail if:
         *
         * [ENOMEM] Insufficient memory was available to fulfill the request.
         */
        ERROR_UNCHECKABLE(POSIX_RECVMSG, ENOMEM, "recvmsg.22.03", "Can not check insufficient memory case")

        ERROR_END()


        {
            SocketMsgHdr* sentMess;
            SocketMsgHdr* recvMess=recvmsg_return->msg;


            if (desc->type==SUT_SOCK_STREAM)
            {
                sentMess=get_List(recvmsg_return->notModifiedSentMessages, 0);
            }
            else if (desc->type==SUT_SOCK_DGRAM)
            {
                IntT ind=findMessageInList(recvmsg_return->notModifiedSentMessages, recvMess);

                 /*
                 * For message-based sockets, such as SOCK_DGRAM and SOCK_SEQPACKET, the entire
                 * message shall be read in a single operation.
                 */
                REQ("recvmsg.06", "Recieved data shall be valid", ind!=-1);

                sentMess = get_List(recvmsg_return->notModifiedSentMessages, ind);

                if (sumIOVecMembers(sentMess->msg_iov) > recvmsg_return->msgDataLength && recvmsgCall->peek==false)
                {
                     /*
                     * Upon successful completion, the msg_flags member of the message header shall be
                     * the bitwise-inclusive OR of all of the following flags that indicate conditions
                     * detected for the received message:
                     *
                     * MSG_TRUNC Normal data was truncated.
                     */
                    /*
                     * If a message is too long to fit in the supplied buffers, and MSG_PEEK is not
                     * set in the flags argument, the excess bytes shall be discarded, and MSG_TRUNC
                     * shall be set in the msg_flags member of the msghdr structure.
                     */
                    REQ("recvmsg.18.03;recvmsg.07", "Flag MSG_TRUNC shall be set", (recvMess->msg_flags & SUT_MSG_TRUNC) != 0);
                }

                if (size_CByteArray(sentMess->msg_control->data)>size_CByteArray(recvMess->msg_control->data))
                {
                    /*
                     * Upon successful completion, the msg_flags member of the message header shall be
                     * the bitwise-inclusive OR of all of the following flags that indicate conditions
                     * detected for the received message:
                     *
                     * MSG_CTRUNC Control data was truncated.
                     */
                   REQ("recvmsg.18.04", "Flag MSG_CTRUNC shall be set", (recvMess->msg_flags & SUT_MSG_CTRUNC) != 0);
               }

            }
            else
            {
                REQ("", "Other protocols not yet implemented in specification", false);
            }

             /*
             * The msg_iov and msg_iovlen fields are used to specify where the received data
             * shall be stored.
             */
             /*
             * msg_iov points to an array of iovec structures; msg_iovlen shall be set to the
             * dimension of this array.
             */
            /*
             * In each iovec structure, the iov_base field specifies a storage area and the
             * iov_len field gives its size in bytes.
             */
            /*
             * Each storage area indicated by msg_iov is filled with received data in turn
             * until all of the received data is stored or all of the areas have been filled.
             */
            /*
             * The recvmsg() function shall receive a message from a connection-mode or
             * connectionless-mode socket.
             */
            /*
             * For stream-based sockets, such as SOCK_STREAM, message boundaries shall be
             * ignored. In this case, data shall be returned to the user as soon as it becomes
             * available, and no data shall be discarded.
             */
            REQ("recvmsg.14;recvmsg.15;recvmsg.16;recvmsg.17;recvmsg.01;recvmsg.08", "Data returned shall be valid",
                compareListsIOvec(sentMess->msg_iov, recvMess->msg_iov, recvmsg_return->msgDataLength));

            /*
             * The recvmsg() function shall receive messages from unconnected or connected
             * sockets and shall return the length of the message.
             */
            REQ("recvmsg.04", "Control data returned shall be valid",
                sentMess->msg_control->cmsg_level == recvMess->msg_control->cmsg_level
                && sentMess->msg_control->cmsg_type == recvMess->msg_control->cmsg_type
                && compare_CByteArrays(sentMess->msg_control->data, recvMess->msg_control->data,
                size_CByteArray(recvMess->msg_control->data)));


       }

        /*
         * The recvmsg() function takes the following arguments:
         *
         * flags Specifies the type of message reception. Values of this argument are
         * formed by logically OR'ing zero or more of the following values:
         *
         * MSG_WAITALL
         *
         * On SOCK_STREAM sockets this requests that the function block until the full
         * amount of data can be returned.
         */
        REQ("recvmsg.03.03.03.01", "", TODO_REQ());

        /*
         * The recvmsg() function takes the following arguments:
         *
         * flags Specifies the type of message reception. Values of this argument are
         * formed by logically OR'ing zero or more of the following values:
         *
         * MSG_WAITALL
         *
         * The function may return the smaller amount of data if the socket is a message-
         * based socket, if a signal is caught, if the connection is terminated, if
         * MSG_PEEK was specified, or if an error is pending for the socket.
         */
        REQ("recvmsg.03.03.03.02", "", TODO_REQ());

        /*
         * If the MSG_WAITALL flag is not set, data shall be returned only up to the end
         * of the first message.
         */
        REQ("recvmsg.09", "", TODO_REQ());

        /*
         * Upon successful completion, the msg_flags member of the message header shall be
         * the bitwise-inclusive OR of all of the following flags that indicate conditions
         * detected for the received message:
         *
         * MSG_EOR End-of-record was received (if supported by the protocol).
         */
        REQ("recvmsg.18.01", "", TODO_REQ());

        /*
         * Upon successful completion, the msg_flags member of the message header shall be
         * the bitwise-inclusive OR of all of the following flags that indicate conditions
         * detected for the received message:
         *
         * MSG_OOB Out-of-band data was received.
         */
        REQ("recvmsg.18.02", "", TODO_REQ());

        /*
         * In the msghdr structure, the msg_name and msg_namelen members specify the
         * source address if the socket is unconnected.
         */
        REQ("recvmsg.11", "", TODO_REQ());


        /*
         * If no messages are available to be received and the peer has performed an
         * orderly shutdown, recvmsg() shall return 0.
         */
        REQ("recvmsg.20.01", "", TODO_REQ());


        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    send - send a message on a socket

SYNOPSIS

    #include <sys/socket.h>
    ssize_t send(int socket, const void *buffer, size_t length, int flags);


DESCRIPTION

    The send() function shall initiate transmission of a message from the
    specified socket to its peer. The send() function shall send a message only
    when the socket is connected (including when the peer of a connectionless
    socket has been set via connect()).

    The send() function takes the following arguments:

        socket
        Specifies the socket file descriptor.

        buffer
        Points to the buffer containing the message to send.

        length
        Specifies the length of the message in bytes.

        flags
        Specifies the type of message transmission. Values of this argument are
        formed by logically OR'ing zero or more of the following flags:

            MSG_EOR
            Terminates a record (if supported by the protocol).
            MSG_OOB
            Sends out-of-band data on sockets that support out-of-band
            communications. The significance and semantics of out-of-band data
            are protocol-specific.

    The length of the message to be sent is specified by the length argument.
    If the message is too long to pass through the underlying protocol, send()
    shall fail and no data shall be transmitted.

    Successful completion of a call to send() does not guarantee delivery of
    the message. A return value of -1 indicates only locally-detected errors.

    If space is not available at the sending socket to hold the message to be
    transmitted, and the socket file descriptor does not have O_NONBLOCK set,
    send() shall block until space is available. If space is not available at
    the sending socket to hold the message to be transmitted, and the socket
    file descriptor does have O_NONBLOCK set, send() shall fail. The select()
    and poll() functions can be used to determine when it is possible to send
    more data.

    The socket in use may require the process to have appropriate privileges to
    use the send() function.

RETURN VALUE

    Upon successful completion, send() shall return the number of bytes sent.
    Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

    The send() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        The socket's file descriptor is marked O_NONBLOCK and the requested
        operation would block.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNRESET]
        A connection was forcibly closed by a peer.

        [EDESTADDRREQ]
        The socket is not connection-mode and no peer address is set.

        [EINTR]
        A signal interrupted send() before any data was transmitted.

        [EMSGSIZE]
        The message is too large to be sent all at once, as the socket
        requires.

        [ENOTCONN]
        The socket is not connected or otherwise has not had the peer
        pre-specified.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The socket argument is associated with a socket that does not support
        one or more of the values set in flags.

        [EPIPE]
        The socket is shut down for writing, or the socket is connection-mode
        and is no longer connected. In the latter case, and if the socket is
        of type SOCK_STREAM, the SIGPIPE signal is generated to the calling
        thread.

    The send() function may fail if:

        [EACCES]
        The calling process does not have the appropriate privileges.

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ENETDOWN]
        The local network interface used to reach the destination is down.

        [ENETUNREACH]
        No route to the network is present.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.
*/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sendto - send a message on a socket

SYNOPSIS

    #include <sys/socket.h>
    ssize_t sendto(int socket, const void *message, size_t length,
           int flags, const struct sockaddr *dest_addr,
           socklen_t dest_len);

DESCRIPTION

    The sendto() function shall send a message through a connection-mode or
    connectionless-mode socket. If the socket is connectionless-mode, the
    message shall be sent to the address specified by dest_addr. If the socket
    is connection-mode, dest_addr shall be ignored.

    The sendto() function takes the following arguments:

        socket
        Specifies the socket file descriptor.

        message
        Points to a buffer containing the message to be sent.

        length
        Specifies the size of the message in bytes.

        flags
        Specifies the type of message transmission. Values of this argument are
        formed by logically OR'ing zero or more of the following flags:

            MSG_EOR
            Terminates a record (if supported by the protocol).

            MSG_OOB
            Sends out-of-band data on sockets that support out-of-band data.
            The significance and semantics of out-of-band data are
            protocol-specific.

        dest_addr
        Points to a sockaddr structure containing the destination address. The
        length and format of the address depend on the address family of the
        socket.

        dest_len
        Specifies the length of the sockaddr structure pointed to by the
        dest_addr argument.

    If the socket protocol supports broadcast and the specified address is a
    broadcast address for the socket protocol, sendto() shall fail if the
    SO_BROADCAST option is not set for the socket.

    The dest_addr argument specifies the address of the target. The length
    argument specifies the length of the message.

    Successful completion of a call to sendto() does not guarantee delivery of
    the message. A return value of -1 indicates only locally-detected errors.

    If space is not available at the sending socket to hold the message to be
    transmitted and the socket file descriptor does not have O_NONBLOCK set,
    sendto() shall block until space is available. If space is not available
    at the sending socket to hold the message to be transmitted and the socket
    file descriptor does have O_NONBLOCK set, sendto() shall fail.

    The socket in use may require the process to have appropriate privileges
    to use the sendto() function.

RETURN VALUE

    Upon successful completion, sendto() shall return the number of bytes sent.
    Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

    The sendto() function shall fail if:

        [EAFNOSUPPORT]
        Addresses in the specified address family cannot be used with this
        socket.

        [EAGAIN] or [EWOULDBLOCK]
        The socket's file descriptor is marked O_NONBLOCK and the requested
        operation would block.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNRESET]
        A connection was forcibly closed by a peer.

        [EINTR]
        A signal interrupted sendto() before any data was transmitted.

        [EMSGSIZE]
        The message is too large to be sent all at once, as the socket
        requires.

        [ENOTCONN]
        The socket is connection-mode but is not connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The socket argument is associated with a socket that does not support
        one or more of the values set in flags.

        [EPIPE]
        The socket is shut down for writing, or the socket is connection-mode
        and is no longer connected. In the latter case, and if the socket is of
        type SOCK_STREAM, the SIGPIPE signal is generated to the calling
        thread.

    If the address family of the socket is AF_UNIX, then sendto() shall fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        pathname in the socket address.

        [ENAMETOOLONG]
        A component of a pathname exceeded {NAME_MAX} characters, or an entire
        pathname exceeded {PATH_MAX} characters.

        [ENOENT]
        A component of the pathname does not name an existing file or the
        pathname is an empty string.

        [ENOTDIR]
        A component of the path prefix of the pathname in the socket address is
        not a directory.

    The sendto() function may fail if:

        [EACCES]
        Search permission is denied for a component of the path prefix; or
        write access to the named socket is denied.

        [EDESTADDRREQ]
        The socket is not connection-mode and does not have its peer address
        set, and no destination address was specified.

        [EHOSTUNREACH]
        The destination host cannot be reached (probably because the host is
        down or a remote router cannot reach it).

        [EINVAL]
        The dest_len argument is not a valid length for the address family.

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [EISCONN]
        A destination address was specified and the socket is already
        connected. This error may or may not be returned for connection mode
        sockets.

        [ENETDOWN]
        The local network interface used to reach the destination is down.

        [ENETUNREACH]
        No route to the network is present.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.

    If the address family of the socket is AF_UNIX, then sendto() may fail if:

        [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the pathname in the socket address.

        [ENAMETOOLONG]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.
*/

//This specification refers to: send, sendto
specification
void send_spec( CallContext context, FileDescId socket, CByteArray* data, bool MSG_EOR_FLAG, bool MSG_OOB_FLAG, SockaddrT* dest_addr)
{
    pre
    {
        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct SendCall SendCall = {};


void onSend( CallContext context, FileDescId socket, CByteArray* data, bool MSG_EOR_FLAG, bool MSG_OOB_FLAG, SockaddrT* dest_addr)
{
    startBlockedCall(context, create_SendCall(socket, data, MSG_EOR_FLAG, MSG_OOB_FLAG, dest_addr));
}



void send_model( CallContext context, FileDescId socket, CByteArray* data, SizeT funcRes, SockaddrT* dest_addr)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);
    if (desc->type==SUT_SOCK_STREAM)
    {
        SocketFileDescriptor* peer_addr = getFileDescriptor_Peer(context, socket, desc);
        CByteArray* returnedArray;

        /*
         * Upon successful completion, send() shall return the number of bytes sent.
         */
        /*
         * Upon successful completion, sendto() shall return the number of bytes sent.
         */
        IMPLEMENT_REQ("send.12.01;sendto.11.01");

        returnedArray = left_CByteArray(data, funcRes);

        /*
         * If the socket is connection-mode, dest_addr shall be ignored.
         */
        IMPLEMENT_REQ("sendto.02.02");

        if (peer_addr!=NULL)
        {
            peer_addr->data = concat_CByteArray(peer_addr->data, returnedArray);
        }
        else
        {
            setBadVerdict("Peer shall not be NULL");
        }
    }
    else if(desc->type==SUT_SOCK_DGRAM)
    {

        if (dest_addr!=NULL)
        {
            SocketFileDescriptor* peer_udp=getFileDescriptor_Sockaddr(context, dest_addr, false);

             /*
             * If the socket is connectionless-mode, the message shall be sent to the address
             * specified by dest_addr.
             */
            IMPLEMENT_REQ("sendto.02.01");

            if (peer_udp==NULL)
            {
                setBadVerdict("Peer shall not be NULL in UDP for sendto()");
                return;
            }

            append_List(peer_udp->udpData, clone(data));
        }
        else if (desc->peer_addr!=NULL)
        {
            SocketFileDescriptor* peer_udp=getFileDescriptor_Sockaddr(context, desc->peer_addr, false);

            if (peer_udp==NULL)
            {
                setBadVerdict("Peer shall not be NULL in UDP for send()");
                return;
            }

            append_List(peer_udp->udpData, clone(data));
        }
        else
        {
            setBadVerdict("Can not find peer socket of send operation");
        }
    }
    else
    {
        setBadVerdict("Protocol not yet implemented in specification");
    }
}


void onSendReturn( CallContext context, SendReturnType* send_ret_val)
{
    SendCall* blocked_call=finishBlockedCall(context);

    if (send_ret_val->funcRes!=-1)
    {
        send_model(context, blocked_call->socket, blocked_call->data, send_ret_val->funcRes, blocked_call->dest_addr);

    }

}


specification typedef struct SendReturnType SendReturnType = {};


reaction SendReturnType* send_return(void)
{
    post
    {
        CallContext    context=send_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        SendCall*      sendCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId     socket = sendCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(sendCall->socket);
        Bool3 isELOOP;
        CString *absPath;
        CString *path;
        SockaddrT* dest_addr=sendCall->dest_addr;
        IntT destFamily=SUT_AF_UNSPEC;
        SocketFileDescriptor* destDescriptor;

        if (dest_addr!=NULL)
        {
            FILTER("sendto");
            destDescriptor = getFileDescriptor_Sockaddr(context, dest_addr, false);
            destFamily=dest_addr->family;
            if (dest_addr->family==SUT_AF_UNIX)
            {
                absPath = resolvePath_Ext(context, getFileSystem(context), getUnixSocket_path(dest_addr), &isELOOP);
                path=getUnixSocket_path(dest_addr);
            }
            else
            {
                absPath = create_CString("");
                path = create_CString("");
            }
        }
        else
        {
            FILTER("send");
        }

        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        /*
         * A return value of -1 indicates only locally-detected errors.
         */
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        /*
         * A return value of -1 indicates only locally-detected errors.
         */
        ERROR_BEGIN(POSIX_SEND, "send.12.02;send.07;sendto.11.02;sendto.07.02", send_return->funcRes==-1, *(send_return->errno))

        /*
         * The send() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The socket's file descriptor is marked O_NONBLOCK
         * and the requested operation would block.
         */
        /*
         * If space is not available at the sending socket to hold the message to be
         * transmitted, and the socket file descriptor does have O_NONBLOCK set, send()
         * shall fail.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The socket's file descriptor is marked O_NONBLOCK
         * and the requested operation would block.
         */
        /*
         * If space is not available at the sending socket to hold the message to be
         * transmitted and the socket file descriptor does have O_NONBLOCK set, sendto()
         * shall fail.
         */
        ERROR_SHALL3(POSIX_SEND, EAGAIN, "send.13.01;send.09;sendto.12.02;sendto.09", isO_NONBLOCKset(socket))

        ERROR_SHALL3(POSIX_SEND, EWOULDBLOCK, "send.13.01;send.09;sendto.12.02;sendto.09", isO_NONBLOCKset(socket))

        /*
         * The send() function shall fail if:
         *
         * [EBADF] The socket argument is not a valid file descriptor.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [EBADF] The socket argument is not a valid file descriptor.
         */
        ERROR_SHALL(POSIX_SEND, EBADF, "send.13.02;sendto.12.03", getFileDescriptor(socket)==NULL)

        /*
         * The send() function shall fail if:
         *
         * [ECONNRESET] A connection was forcibly closed by a peer.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [ECONNRESET] A connection was forcibly closed by a peer.
         */
        ERROR_SHALL(POSIX_SEND, ECONNRESET, "send.13.03;sendto.12.04", TODO_ERR(ECONNRESET) )

        /*
         * The send() function shall fail if:
         *
         * [EDESTADDRREQ] The socket is not connection-mode and no peer address is set.
         */
        /*
         * The sendto() function may fail if:
         *
         * [EDESTADDRREQ] The socket is not connection-mode and does not have its peer
         * address set, and no destination address was specified.
         */
        ERROR_SHALL(POSIX_SEND, EDESTADDRREQ, "send.13.04", desc!=NULL && getFileKind_FileDescId(socket)==Socket
            && (desc->type == SUT_SOCK_DGRAM || desc->type == SUT_SOCK_RAW) && desc->peer_addr==NULL && sendCall->dest_addr==NULL)

        /*
         * The send() function shall fail if:
         *
         * [EINTR] A signal interrupted send() before any data was transmitted.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [EINTR] A signal interrupted sendto() before any data was transmitted.
         */
        ERROR_SHALL(POSIX_SEND, EINTR, "send.13.05;sendto.12.05", TODO_ERR(EINTR) )

        /*
         * The send() function shall fail if:
         *
         * [EMSGSIZE] The message is too large to be sent all at once, as the socket
         * requires.
         */
        /*
         * If the message is too long to pass through the underlying protocol, send()
         * shall fail and no data shall be transmitted.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [EMSGSIZE] The message is too large to be sent all at once, as the socket
         * requires.
         */
        ERROR_SHALL(POSIX_SEND, EMSGSIZE, "send.13.06;send.05;sendto.12.06", TODO_ERR(EMSGSIZE) )

        /*
         * The send() function shall fail if:
         *
         * [ENOTCONN] The socket is not connected or otherwise has not had the peer pre-
         * specified.
         */
        /*
         * The send() function shall send a message only when the socket is connected
         * (including when the peer of a connectionless socket has been set via connect()).
         */
        /*
         * The sendto() function shall fail if:
         *
         * [ENOTCONN] The socket is connection-mode but is not connected.
         */
         ERROR_SHALL(POSIX_SEND, ENOTCONN, "send.13.07;send.02;sendto.12.07", desc!=NULL && getFileKind_FileDescId(socket)==Socket
            && (desc->type == SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET) && desc->peer_addr==NULL)

        /*
         * The send() function shall fail if:
         *
         * [ENOTSOCK] The socket argument does not refer to a socket.
         */

        /*
         * The sendto() function shall fail if:
         *
         * [ENOTSOCK] The socket argument does not refer to a socket.
         */
        ERROR_SHALL(POSIX_SEND, ENOTSOCK, "send.13.08;sendto.12.08", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
         * The send() function shall fail if:
         *
         * [EOPNOTSUPP] The socket argument is associated with a socket that does not
         * support one or more of the values set in flags.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [EOPNOTSUPP] The socket argument is associated with a socket that does not
         * support one or more of the values set in flags.
         */
        ERROR_SHALL(POSIX_SEND, EOPNOTSUPP, "send.13.09;sendto.12.09", TODO_ERR(EOPNOTSUPP) )

        /*
         * The send() function shall fail if:
         *
         * [EPIPE] The socket is shut down for writing, or the socket is connection-mode
         * and is no longer connected. In the latter case, and if the socket is of type
         * SOCK_STREAM, the SIGPIPE signal is generated to the calling thread.
         */
        /*
         * The sendto() function shall fail if:
         *
         * [EPIPE] The socket is shut down for writing, or the socket is connection-mode
         * and is no longer connected. In the latter case, and if the socket is of type
         * SOCK_STREAM, the SIGPIPE signal is generated to the calling thread.
         */
        ERROR_SHALL(POSIX_SEND, EPIPE, "send.13.10;sendto.12.10", TODO_ERR(EPIPE) )

        /*
         * The send() function may fail if:
         *
         * [EACCES] The calling process does not have the appropriate privileges.
         */
        /*
         * The sendto() function may fail if:
         *
         * [EACCES] Search permission is denied for a component of the path prefix; or
         * write access to the named socket is denied.
         */
        ERROR_MAY(POSIX_SEND, EACCES, "send.14.01;sendto.14.01", TODO_ERR(EACCES))

        /*
         * The send() function may fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        /*
         * The sendto() function may fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        ERROR_UNCHECKABLE(POSIX_SEND, EIO, "send.14.02;sendto.14.05", "Can not check IO errors")

        /*
         * The send() function may fail if:
         *
         * [ENETDOWN] The local network interface used to reach the destination is down.
         */
        /*
         * The sendto() function may fail if:
         *
         * [ENETDOWN] The local network interface used to reach the destination is down.
         */
        ERROR_UNCHECKABLE(POSIX_SEND, ENETDOWN, "send.14.03;sendto.14.07", "Can not check if network is down")

        /*
         * The send() function may fail if:
         *
         * [ENETUNREACH] No route to the network is present.
         */
        /*
         * The sendto() function may fail if:
         *
         * [ENETUNREACH] No route to the network is present.
         */
        ERROR_UNCHECKABLE(POSIX_SEND, ENETUNREACH, "send.14.04;sendto.14.08", "Do not know details about network routing")

        /*
         * The send() function may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        /*
         * The sendto() function may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_SEND, ENOBUFS, "send.14.05;sendto.14.09", "Can not check insufficient resources case")



        /*
         * The sendto() function shall fail if:
         *
         * [EAFNOSUPPORT] Addresses in the specified address family cannot be used with
         * this socket.
         */
        ERROR_SHALL(POSIX_SENDTO, EAFNOSUPPORT, "sendto.12.01", TODO_ERR(EAFNOSUPPORT) )


        /*
         * If the address family of the socket is AF_UNIX, then sendto() shall fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        ERROR_UNCHECKABLE(POSIX_SENDTO, EIO, "sendto.13.01", "Can not check IO errors")


        /*
         * If the address family of the socket is AF_UNIX, then sendto() shall fail if:
         *
         * [ELOOP] A loop exists in symbolic links encountered during resolution of the
         * pathname in the socket address.
         */
        ERROR_SHALL3(POSIX_SENDTO, ELOOP, "sendto.13.02", and_Bool3(dest_addr!=NULL, and_Bool3(destFamily==SUT_AF_UNIX,
            isELOOP)))

        /*
         * If the address family of the socket is AF_UNIX, then sendto() shall fail if:
         *
         * [ENAMETOOLONG] A component of a pathname exceeded {NAME_MAX} characters, or
         * an entire pathname exceeded {PATH_MAX} characters.
         */
        ERROR_SHALL3(POSIX_SENDTO, ENAMETOOLONG, "sendto.13.03", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENAMETOOLONG(context, absPath))))

        /*
         * If the address family of the socket is AF_UNIX, then sendto() shall fail if:
         *
         * [ENOENT] A component of the pathname does not name an existing file or the
         * pathname is an empty string.
         */
         ERROR_SHALL3(POSIX_SENDTO, ENOENT, "sendto.13.04",  and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENOENT_dir(context, getFileSystem(context), getParentDir_Path(absPath)))))

        /*
         * If the address family of the socket is AF_UNIX, then sendto() shall fail if:
         *
         * [ENOTDIR] A component of the path prefix of the pathname in the socket
         * address is not a directory.
         */
         ERROR_SHALL3(POSIX_SENDTO, ENOTDIR, "sendto.13.05", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENOTDIR_dir(context, getFileSystem(context), getParentDir_Path(absPath)))))

        /*
         * The sendto() function may fail if:
         *
         * [EHOSTUNREACH] The destination host cannot be reached (probably because the
         * host is down or a remote router cannot reach it).
         */
        ERROR_UNCHECKABLE(POSIX_SENDTO, EHOSTUNREACH, "sendto.14.03", "Can not check if host can be reached")

        /*
         * The sendto() function may fail if:
         *
         * [EINVAL] The dest_len argument is not a valid length for the address family.
         */
        ERROR_UNCHECKABLE(POSIX_SENDTO, EINVAL, "sendto.14.04", "This is not allowed in agent")


        /*
         * The sendto() function may fail if:
         *
         * [EISCONN] A destination address was specified and the socket is already
         * connected. This error may or may not be returned for connection mode sockets.
         */
         ERROR_MAY(POSIX_SENDTO, EISCONN, "sendto.14.06", dest_addr!=NULL && desc!=NULL && getFileKind_FileDescId(socket) == Socket && desc->peer_addr!=NULL &&
            (desc->type == SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET))

        /*
         * The sendto() function may fail if:
         *
         * [ENOMEM] Insufficient memory was available to fulfill the request.
         */
        ERROR_UNCHECKABLE(POSIX_SENDTO, ENOMEM, "sendto.14.10", "Can not check insufficient memory case")

        /*
         * If the address family of the socket is AF_UNIX, then sendto() may fail if:
         *
         * [ELOOP] More than {SYMLOOP_MAX} symbolic links were encountered during
         * resolution of the pathname in the socket address.
         */
         ERROR_MAY3(POSIX_SENDTO, ELOOP, "sendto.15.01", and_Bool3(dest_addr!=NULL, and_Bool3(destFamily==SUT_AF_UNIX,
            isELOOP)))

        /*
         * If the address family of the socket is AF_UNIX, then sendto() may fail if:
         *
         * [ENAMETOOLONG] Pathname resolution of a symbolic link produced an
         * intermediate result whose length exceeds {PATH_MAX}.
         */
        ERROR_MAY3(POSIX_SENDTO, ENAMETOOLONG, "sendto.15.02", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENAMETOOLONG(context, absPath))))


        ERROR_END()

        /*
         * Successful completion of a call to send() does not guarantee delivery of the
         * message.
         */
        /*
         * Successful completion of a call to sendto() does not guarantee delivery of the
         * message.
         */
        REQ("send.06;sendto.07.01", "", TODO_REQ());

        /*
         * The select() and poll() functions can be used to determine when it is possible
         * to send more data.
         */
        REQ("send.10", "", TODO_REQ());

        /*
         * The socket in use may require the process to have appropriate privileges to use
         * the send() function.
         */
        /*
         * The socket in use may require the process to have appropriate privileges to use
         * the sendto() function.
         */
        REQ("send.11;sendto.10", "", TODO_REQ());


        /*
         * If the socket protocol supports broadcast and the specified address is a
         * broadcast address for the socket protocol, sendto() shall fail if the
         * SO_BROADCAST option is not set for the socket.
         */
        REQ("sendto.04", "", TODO_REQ());


        return true;
    }
    FILTER_CLEAN;
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sendmsg - send a message on a socket using a message structure

SYNOPSIS

    #include <sys/socket.h>
    ssize_t sendmsg(int socket, const struct msghdr *message, int flags);

DESCRIPTION

    The sendmsg() function shall send a message through a connection-mode or
    connectionless-mode socket.If the socket is connectionless-mode, the
    message shall be sent to the address specified by msghdr. If the socket is
    connection-mode, the destination address in msghdr shall be ignored.

    The sendmsg() function takes the following arguments:

        socket
        Specifies the socket file descriptor.

        message
        Points to a msghdr structure, containing both the destination address
        and the buffers for the outgoing message. The length and format of the
        address depend on the address family of the socket. The msg_flags
        member is ignored.

        flags
        Specifies the type of message transmission. The application may specify
        0 or the following flag:

            MSG_EOR
            Terminates a record (if supported by the protocol).

            MSG_OOB
            Sends out-of-band data on sockets that support out-of-bound data.
            The significance and semantics of out-of-band data are
            protocol-specific.

    The msg_iov and msg_iovlen fields of message specify zero or more buffers
    containing the data to be sent.msg_iov points to an array of iovec
    structures; msg_iovlen shall be set to the dimension of this array.In each
    iovec structure, the iov_base field specifies a storage area and the
    iov_len field gives its size in bytes. Some of these sizes can be zero.The
    data from each storage area indicated by msg_iov is sent in turn.

    Successful completion of a call to sendmsg() does not guarantee delivery of
    the message. A return value of -1 indicates only locally-detected errors.

    If space is not available at the sending socket to hold the message to be
    transmitted and the socket file descriptor does not have O_NONBLOCK set,
    the sendmsg() function shall block until space is available.If space is not
    available at the sending socket to hold the message to be transmitted and
    the socket file descriptor does have O_NONBLOCK set, the sendmsg() function
    shall fail.

    If the socket protocol supports broadcast and the specified address is a
    broadcast address for the socket protocol, sendmsg() shall fail if the
    SO_BROADCAST option is not set for the socket.

    The socket in use may require the process to have appropriate privileges to
    use the sendmsg() function.

RETURN VALUE

    Upon successful completion, sendmsg() shall return the number of bytes
    sent. Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

    The sendmsg() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        The socket's file descriptor is marked O_NONBLOCK and the requested
        operation would block.

        [EAFNOSUPPORT]
        Addresses in the specified address family cannot be used with this
        socket.

        [EBADF]
        The socket argument is not a valid file descriptor.

        [ECONNRESET]
        A connection was forcibly closed by a peer.

        [EINTR]
        A signal interrupted sendmsg() before any data was transmitted.

        [EINVAL]
        The sum of the iov_len values overflows an ssize_t.

        [EMSGSIZE]
        The message is too large to be sent all at once (as the socket
        requires), or the msg_iovlen member of the msghdr structure pointed to
        by message is less than or equal to 0 or is greater than {IOV_MAX}.

        [ENOTCONN]
        The socket is connection-mode but is not connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

        [EOPNOTSUPP]
        The socket argument is associated with a socket that does not support
        one or more of the values set in flags.

        [EPIPE]
        The socket is shut down for writing, or the socket is connection-mode
        and is no longer connected. In the latter case, and if the socket is of
        type SOCK_STREAM, the SIGPIPE signal is generated to the calling
        thread.

    If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        pathname in the socket address.

        [ENAMETOOLONG]
        A component of a pathname exceeded {NAME_MAX} characters, or an entire
        pathname exceeded {PATH_MAX} characters.

        [ENOENT]
        A component of the pathname does not name an existing file or the path
        name is an empty string.

        [ENOTDIR]
        A component of the path prefix of the pathname in the socket address is
        not a directory.

    The sendmsg() function may fail if:

        [EACCES]
        Search permission is denied for a component of the path prefix; or
        write access to the named socket is denied.

        [EDESTADDRREQ]
        The socket is not connection-mode and does not have its peer address
        set, and no destination address was specified.

        [EHOSTUNREACH]
        The destination host cannot be reached (probably because the host is
        down or a remote router cannot reach it).

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

        [EISCONN]
        A destination address was specified and the socket is already
        connected.

        [ENETDOWN]
        The local network interface used to reach the destination is down.

        [ENETUNREACH]
        No route to the network is present.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.

    If the address family of the socket is AF_UNIX, then sendmsg() may fail if:

        [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the pathname in the socket address.

        [ENAMETOOLONG]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.
*/

specification
void sendmsg_spec(CallContext context, FileDescId socket, SocketMsgHdr* msg,
                  bool flag_MSG_EOR, bool flag_MSG_OOB, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct SendMsgCall SendMsgCall = {};

void onSendMsg( CallContext context, FileDescId socket, SocketMsgHdr* msg,
                  bool flag_MSG_EOR, bool flag_MSG_OOB)
{
    startBlockedCall(context, create_SendMsgCall(socket, msg, flag_MSG_EOR, flag_MSG_OOB));
}



specification typedef struct SendMsgReturnType SendMsgReturnType = {};


void sendmsg_model( CallContext context, SendMsgReturnType* sendmsg_ret_val, SendMsgCall* blocked_call)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(blocked_call->socket);
    SocketMsgHdr* msg = blocked_call->msg;
    SSizeT sendSize=sendmsg_ret_val->funcRes;
    SSizeT sumLen, i;
    CByteArray* data;
    SocketFileDescriptor* peer_addr;
    CByteArray* udpSendData=NULL;

	if(desc==NULL)
	{
        setBadVerdict("File descriptor shall not be NULL");
        return;
	}

    if (desc->type!=SUT_SOCK_STREAM && desc->type!=SUT_SOCK_DGRAM)
    {
        setBadVerdict("Protocol not yet implemented in specification");
    }

    if (desc->type==SUT_SOCK_STREAM)
    {
         /*
         * If the socket is connection-mode, the destination address in msghdr shall be
         * ignored.
         */
        IMPLEMENT_REQ("sendmsg.02.02");

        peer_addr = getFileDescriptor_Peer(context, blocked_call->socket, desc);
    }
    else
    {
        /*
         * If the socket is connectionless-mode, the message shall be sent to the address
         * specified by msghdr.
         */
        IMPLEMENT_REQ("sendmsg.02.01");

        peer_addr=getFileDescriptor_Sockaddr(context, msg->msg_name, false);

        if(peer_addr==NULL && !equals(create_FileDescIdObj(desc->socketPair_Buddy), create_FileDescIdObj(WrongFileDescId)))
        {
        	peer_addr=getDescriptor_FileDescId(desc->socketPair_Buddy);
        }
    }

    if (peer_addr!=NULL)
    {
        /*
         * The msg_iov and msg_iovlen fields of message specify zero or more buffers
         * containing the data to be sent.
         */
        IMPLEMENT_REQ("sendmsg.04");

        /*
         * Upon successful completion, sendmsg() shall return the number of bytes sent.
         */
        IMPLEMENT_REQ("sendmsg.14.01");

        /*
         * Some of these sizes can be zero.
         */
        IMPLEMENT_REQ("sendmsg.07");

        /*
         * The data from each storage area indicated by msg_iov is sent in turn.
         */
        IMPLEMENT_REQ("sendmsg.08");

        append_List(peer_addr->sentMessages, clone(msg));
    }
    else
    {
        setBadVerdict("Peer shall not be NULL");
    }
}


void onSendMsgReturn( CallContext context, SendMsgReturnType* sendmsg_ret_val)
{
    SendMsgCall* blocked_call=finishBlockedCall(context);

    if (sendmsg_ret_val->funcRes!=-1)
    {
        sendmsg_model(context, sendmsg_ret_val, blocked_call);
    }
}




reaction SendMsgReturnType* sendmsg_return(void)
{
    post
    {
        CallContext             context=sendmsg_return->context;
        ProcessState*           ps=getProcessState_CallContext(context);
        SendMsgCall*            sendmsgCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId              socket = sendmsgCall->socket;
        SocketFileDescriptor*   desc=getDescriptor_FileDescId(socket);
        SocketMsgHdr*           msg = sendmsgCall->msg;

        Bool3                   isELOOP;
        CString *               absPath;
        CString *               path;
        SockaddrT*              dest_addr=msg->msg_name;
        IntT                    destFamily=SUT_AF_UNSPEC;
        SocketFileDescriptor*   destDescriptor;

        if (dest_addr!=NULL && desc!=NULL && desc->protocol != SUT_IPPROTO_TCP)
        {
            destDescriptor = getFileDescriptor_Sockaddr(context, dest_addr, false);
            destFamily=dest_addr->family;
            if (dest_addr->family==SUT_AF_UNIX)
            {
                absPath = resolvePath_Ext(context, getFileSystem(context), getUnixSocket_path(dest_addr), &isELOOP);
                path=getUnixSocket_path(dest_addr);
            }
            else
            {
                absPath = create_CString("");
                path = create_CString("");
            }
        }


        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        /*
         * A return value of -1 indicates only locally-detected errors.
         */
        ERROR_BEGIN(POSIX_SENDMSG, "sendmsg.14.02;sendmsg.10", sendmsg_return->funcRes==-1, *(sendmsg_return->errno) )

        /*
         * The sendmsg() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The socket's file descriptor is marked O_NONBLOCK
         * and the requested operation would block.
         */
        /*
         * If space is not available at the sending socket to hold the message to be
         * transmitted and the socket file descriptor does have O_NONBLOCK set, the
         * sendmsg() function shall fail.
         */
        ERROR_SHALL3(POSIX_SENDMSG, EAGAIN, "sendmsg.15.01;sendmsg.11.02", isO_NONBLOCKset(socket))

        ERROR_SHALL3(POSIX_SENDMSG, EWOULDBLOCK, "sendmsg.15.01;sendmsg.11.02", isO_NONBLOCKset(socket))

        /*
         * The sendmsg() function shall fail if:
         *
         * [EAFNOSUPPORT] Addresses in the specified address family cannot be used with
         * this socket.
         */
        ERROR_SHALL(POSIX_SENDMSG, EAFNOSUPPORT, "sendmsg.15.02", TODO_ERR(EAFNOSUPPORT) )

        /*
         * The sendmsg() function shall fail if:
         *
         * [EBADF] The socket argument is not a valid file descriptor.
         */
        ERROR_SHALL(POSIX_SENDMSG, EBADF, "sendmsg.15.03", getFileDescriptor(socket)==NULL)

        /*
         * The sendmsg() function shall fail if:
         *
         * [ECONNRESET] A connection was forcibly closed by a peer.
         */
        ERROR_SHALL(POSIX_SENDMSG, ECONNRESET, "sendmsg.15.04", TODO_ERR(ECONNRESET) )

        /*
         * The sendmsg() function shall fail if:
         *
         * [EINTR] A signal interrupted sendmsg() before any data was transmitted.
         */
        ERROR_SHALL(POSIX_SENDMSG, EINTR, "sendmsg.15.05", TODO_ERR(EINTR) )

        /*
         * The sendmsg() function shall fail if:
         *
         * [EINVAL] The sum of the iov_len values overflows an ssize_t.
         */
        ERROR_SHALL(POSIX_SENDMSG, EINVAL, "sendmsg.15.06", sumIOVecMembers(msg->msg_iov)>(SSizeT)max_SSizeT)

        /*
         * The sendmsg() function shall fail if:
         *
         * [EMSGSIZE] The message is too large to be sent all at once (as the socket
         * requires), or the msg_iovlen member of the msghdr structure pointed to by
         * message is less than or equal to 0 or is greater than {IOV_MAX}.
         */
        ERROR_SHALL3(POSIX_SENDMSG, EMSGSIZE, "sendmsg.15.07", isEMSGSIZE(context, msg))

        /*
         * The sendmsg() function shall fail if:
         *
         * [ENOTCONN] The socket is connection-mode but is not connected.
         */
         ERROR_SHALL(POSIX_SENDMSG, ENOTCONN, "sendmsg.15.08", desc!=NULL && getFileKind_FileDescId(socket)==Socket
            && (desc->type == SUT_SOCK_STREAM || desc->type == SUT_SOCK_SEQPACKET) && desc->peer_addr==NULL)

        /*
         * The sendmsg() function shall fail if:
         *
         * [ENOTSOCK] The socket argument does not refer to a socket.
         */
        ERROR_SHALL(POSIX_SENDMSG, ENOTSOCK, "sendmsg.15.09", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
         * The sendmsg() function shall fail if:
         *
         * [EOPNOTSUPP] The socket argument is associated with a socket that does not
         * support one or more of the values set in flags.
         */
        ERROR_SHALL(POSIX_SENDMSG, EOPNOTSUPP, "sendmsg.15.10", TODO_ERR(EOPNOTSUPP) )

        /*
         * The sendmsg() function shall fail if:
         *
         * [EPIPE] The socket is shut down for writing, or the socket is connection-mode
         * and is no longer connected. In the latter case, and if the socket is of type
         * SOCK_STREAM, the SIGPIPE signal is generated to the calling thread.
         */
        ERROR_SHALL(POSIX_SENDMSG, EPIPE, "sendmsg.15.11", TODO_ERR(EPIPE) )

        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        ERROR_UNCHECKABLE(POSIX_SENDMSG, EIO, "sendmsg.16.01", "Can not check IO errors")

        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:
         *
         * [ELOOP] A loop exists in symbolic links encountered during resolution of the
         * pathname in the socket address.
         */
         ERROR_SHALL3(POSIX_SENDMSG, ELOOP, "sendmsg.16.02", and_Bool3(dest_addr!=NULL, and_Bool3(destFamily==SUT_AF_UNIX,
            isELOOP)))

        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:
         *
         * [ENAMETOOLONG] A component of a pathname exceeded {NAME_MAX} characters, or
         * an entire pathname exceeded {PATH_MAX} characters.
         */
         ERROR_SHALL3(POSIX_SENDMSG, ENAMETOOLONG, "sendmsg.16.03", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENAMETOOLONG(context, absPath))))

        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:
         *
         * [ENOENT] A component of the pathname does not name an existing file or the
         * path name is an empty string.
         */
         ERROR_SHALL3(POSIX_SENDMSG, ENOENT, "sendmsg.16.04", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENOENT_dir(context, getFileSystem(context), getParentDir_Path(absPath)))))


        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:
         *
         * [ENOTDIR] A component of the path prefix of the pathname in the socket
         * address is not a directory.
         */
         ERROR_SHALL3(POSIX_SENDMSG, ENOTDIR, "sendmsg.16.05", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENOTDIR_dir(context, getFileSystem(context), getParentDir_Path(absPath)))))

        /*
         * The sendmsg() function may fail if:
         *
         * [EACCES] Search permission is denied for a component of the path prefix; or
         * write access to the named socket is denied.
         */
         ERROR_MAY3(POSIX_SENDMSG, EACCES, "sendmsg.17.01",  and_Bool3(destFamily==SUT_AF_UNIX,
            isEACCES_dir_mkrm(context, getFileSystem(context), absPath)))

        /*
         * The sendmsg() function may fail if:
         *
         * [EDESTADDRREQ] The socket is not connection-mode and does not have its peer
         * address set, and no destination address was specified.
         */
         ERROR_MAY(POSIX_SENDMSG, EDESTADDRREQ, "sendmsg.17.02", desc!=NULL && getFileKind_FileDescId(socket)==Socket
            && (desc->type == SUT_SOCK_DGRAM || desc->type == SUT_SOCK_RAW) &&
            equals(create_FileDescIdObj(desc->socketPair_Buddy), create_FileDescIdObj(WrongFileDescId))
            && desc->peer_addr==NULL && msg->msg_name ==NULL)


        /*
         * The sendmsg() function may fail if:
         *
         * [EHOSTUNREACH] The destination host cannot be reached (probably because the
         * host is down or a remote router cannot reach it).
         */
        ERROR_MAY(POSIX_SENDMSG, EHOSTUNREACH, "sendmsg.17.03", TODO_ERR(EHOSTUNREACH))

        /*
         * The sendmsg() function may fail if:
         *
         * [EIO] An I/O error occurred while reading from or writing to the file system.
         */
        ERROR_UNCHECKABLE(POSIX_SENDMSG, EIO, "sendmsg.17.04", "Can not check IO errors")

        /*
         * The sendmsg() function may fail if:
         *
         * [EISCONN] A destination address was specified and the socket is already
         * connected.
         */
        ERROR_MAY(POSIX_SENDMSG, EISCONN, "sendmsg.17.05", desc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            desc->peer_addr!=NULL && msg->msg_name!=NULL)

        /*
         * The sendmsg() function may fail if:
         *
         * [ENETDOWN] The local network interface used to reach the destination is down.
         */
        ERROR_MAY(POSIX_SENDMSG, ENETDOWN, "sendmsg.17.06", TODO_ERR(ENETDOWN))

        /*
         * The sendmsg() function may fail if:
         *
         * [ENETUNREACH] No route to the network is present.
         */
        ERROR_MAY(POSIX_SENDMSG, ENETUNREACH, "sendmsg.17.07", TODO_ERR(ENETUNREACH))

        /*
         * The sendmsg() function may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_SENDMSG, ENOBUFS, "sendmsg.17.08", "Can not check insufficient resources case")

        /*
         * The sendmsg() function may fail if:
         *
         * [ENOMEM] Insufficient memory was available to fulfill the request.
         */
        ERROR_UNCHECKABLE(POSIX_SENDMSG, ENOMEM, "sendmsg.17.09", "Can not check insufficient memory case")

        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() may fail if:
         *
         * [ELOOP] More than {SYMLOOP_MAX} symbolic links were encountered during
         * resolution of the pathname in the socket address.
         */
         ERROR_MAY3(POSIX_SENDMSG, ELOOP, "sendmsg.18.01", and_Bool3(dest_addr!=NULL, and_Bool3(destFamily==SUT_AF_UNIX,
            isELOOP)))

        /*
         * If the address family of the socket is AF_UNIX, then sendmsg() may fail if:
         *
         * [ENAMETOOLONG] Pathname resolution of a symbolic link produced an
         * intermediate result whose length exceeds {PATH_MAX}.
         */
         ERROR_MAY3(POSIX_SENDMSG, ENAMETOOLONG, "sendmsg.18.02", and_Bool3(dest_addr!=NULL,
            and_Bool3(destFamily==SUT_AF_UNIX, isENAMETOOLONG(context, absPath))))

        ERROR_END()

        /*
         * Successful completion of a call to sendmsg() does not guarantee delivery of the
         * message.
         */
        REQ("sendmsg.09", "", TODO_REQ());


        /*
         * If space is not available at the sending socket to hold the message to be
         * transmitted and the socket file descriptor does not have O_NONBLOCK set, the
         * sendmsg() function shall block until space is available.
         */
        REQ("sendmsg.11.01", "", TODO_REQ());


        /*
         * If the socket protocol supports broadcast and the specified address is a
         * broadcast address for the socket protocol, sendmsg() shall fail if the
         * SO_BROADCAST option is not set for the socket.
         */
        REQ("sendmsg.12", "", TODO_REQ());

        /*
         * The socket in use may require the process to have appropriate privileges to use
         * the sendmsg() function.
         */
        REQ("sendmsg.13", "", TODO_REQ());



        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    setsockopt -- set socket options

SYNOPSIS

    #include <sys/socket.h> #include <netinet/ip.h>

    int setsockopt(int socket, int level, int option_name, const void *
    option_value, socklen_t option_len);

DESCRIPTION

    The setsockopt() function shall behave as specified in ISO POSIX (2003), with
    the following extensions.

    IP Protocol Level Options

    If the level parameter is IPPROTO_IP, the following values shall be supported
    for option_name (see RFC 791:Internet Protocol for further details):

    IP_OPTIONS Set the Internet Protocol options sent with every packet from this
    socket. The option_value shall point to a memory buffer containing the options
    and option_len shall contain the size in bytes of that buffer. For IPv4, the
    maximum length of options is 40 bytes.

    IP_TOS Set the Type of Service flags to use when sending packets with this
    socket. The option_value shall point to a value containing the type of service
    value. The least significant two bits of the value shall contain the new Type
    of Service indicator. Use of other bits in the value is unspecified. The
    option_len parameter shall hold the size, in bytes, of the buffer referred to
    by option_value.

    IP_TTL Set the current unicast Internet Protocol Time To Live value used when
    sending packets with this socket. The option_value shall point to a value
    containing the time to live value, which shall be between 1 and 255. The
    option_len parameter shall hold the size, in bytes, of the buffer referred to
    by option_value.

    IP_MULTICAST_TTL Sets the Time To Live value of outgoing multicast packets for
    this socket. optval shall point to an integer which contains the new TTL value.
    If the new TTL value is -1, the implementation should use an unspecified
    default TTL value. If the new TTL value is out of the range of acceptable
    values (0-255), setsockopt() shall return -1 and set errno to indicate the
    error.

    IP_MULTICAST_LOOP Sets a boolean flag indicating whether multicast packets
    originating locally should be looped back to the local sockets. optval shall
    point to an integer which contains the new flag value.

    IP_ADD_MEMBERSHIP Join a multicast group. optval shall point to a ip_mreq
    structure. Before calling, the caller should fill in the imr_multiaddr field
    with the multicast group address and the imr_address field with the address of
    the local interface. If imr_address is set to INADDR_ANY, then an appropriate
    interface is chosen by the system.

    IP_DROP_MEMBERSHIP Leave a multicast group. optval shall point to a ip_mreq
    structure containing the same values as were used with IP_ADD_MEMBERSHIP.

    IP_MULTICAST_IF Set the local device for a multicast socket. optval shall point
    to a ip_mreq structure initialized in the same manner as with IP_ADD_MEMBERSHIP.

    The ip_mreq structure contains two struct in_addr fields: imr_multiaddr and
    imr_address.

RETURN VALUE

    On success, 0 is returned. On error, -1 is returned and the global variable
    errno is set appropriately.

ERRORS

    As defined in ISO POSIX (2003).
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    setsockopt - set the socket options

SYNOPSIS

    #include <sys/socket.h>
    int setsockopt(int socket, int level, int option_name,
        const void *option_value, socklen_t option_len);

DESCRIPTION

    The setsockopt() function shall set the option specified by the option_name
    argument, at the protocol level specified by the level argument, to the
    value pointed to by the option_value argument for the socket associated
    with the file descriptor specified by the socket argument.

    The level argument specifies the protocol level at which the option
    resides. To set options at the socket level, specify the level argument as
    SOL_SOCKET. To set options at other levels, supply the appropriate level
    identifier for the protocol controlling the option. For example, to
    indicate that an option is interpreted by the TCP (Transport Control
    Protocol), set level to IPPROTO_TCP as defined in the <netinet/in.h>
    header.

    The option_name argument specifies a single option to set. The option_name
    argument and any specified options are passed uninterpreted to the
    appropriate protocol module for interpretations. The <sys/socket.h> header
    defines the socket-level options. The options are as follows:

    SO_DEBUG
    Turns on recording of debugging information. This option enables or
    disables debugging in the underlying protocol modules. This option takes
    an int value. This is a Boolean option.

    SO_BROADCAST
    Permits sending of broadcast messages, if this is supported by the
    protocol. This option takes an int value. This is a Boolean option.

    SO_REUSEADDR
    Specifies that the rules used in validating addresses supplied to bind()
    should allow reuse of local addresses, if this is supported by the
    protocol. This option takes an int value. This is a Boolean option.

    SO_KEEPALIVE
    Keeps connections active by enabling the periodic transmission of messages,
    if this is supported by the protocol.This option takes an int value.
    If the connected socket fails to respond to these messages, the connection
    is broken and threads writing to that socket are notified with a SIGPIPE
    signal. This is a Boolean option.

    SO_LINGER
    Lingers on a close() if data is present. This option controls the action
    taken when unsent messages queue on a socket and close() is performed. If
    SO_LINGER is set, the system shall block the calling thread during close()
    until it can transmit the data or until the time expires. If SO_LINGER is
    not specified, and close() is issued, the system handles the call in a way
    that allows the calling thread to continue as quickly as possible. This
    option takes a linger structure, as defined in the <sys/socket.h> header,
    to specify the state of the option and linger interval.

    SO_OOBINLINE
    Leaves received out-of-band data (data marked urgent) inline. This option
    takes an int value. This is a Boolean option.

    SO_SNDBUF
    Sets send buffer size. This option takes an int value.

    SO_RCVBUF
    Sets receive buffer size. This option takes an int value.

    SO_DONTROUTE
    Requests that outgoing messages bypass the standard routing facilities.
    The destination shall be on a directly-connected network, and messages are
    directed to the appropriate network interface according to the destination
    address. The effect, if any, of this option depends on what protocol is in
    use. This option takes an int value. This is a Boolean option.

    SO_RCVLOWAT
    Sets the minimum number of bytes to process for socket input operations.
    The default value for SO_RCVLOWAT is 1. If SO_RCVLOWAT is set to a larger
    value, blocking receive calls normally wait until they have received the
    smaller of the low water mark value or the requested amount. (They may
    return less than the low water mark if an error occurs, a signal is caught,
    or the type of data next in the receive queue is different from that
    returned; for example, out-of-band data.) This option takes an int value.
    Note that not all implementations allow this option to be set.

    SO_RCVTIMEO
    Sets the timeout value that specifies the maximum amount of time an input
    function waits until it completes. It accepts a timeval structure with the
    number of seconds and microseconds specifying the limit on how long to wait
    for an input operation to complete. If a receive operation has blocked for
    this much time without receiving additional data, it shall return with a
    partial count or errno set to [EAGAIN] or [EWOULDBLOCK] if no data is
    received. The default for this option is zero, which indicates that a
    receive operation shall not time out. This option takes a timeval
    structure. Note that not all implementations allow this option to be set.

    SO_SNDLOWAT
    Sets the minimum number of bytes to process for socket output operations.
    Non-blocking output operations shall process no data if flow control does
    not allow the smaller of the send low water mark value or the entire
    request to be processed. This option takes an int value. Note that not all
    implementations allow this option to be set.

    SO_SNDTIMEO
    Sets the timeout value specifying the amount of time that an output
    function blocks because flow control prevents data from being sent. If a
    send operation has blocked for this time, it shall return with a partial
    count or with errno set to [EAGAIN] or [EWOULDBLOCK] if no data is sent.
    The default for this option is zero, which indicates that a send operation
    shall not time out. This option stores a timeval structure. Note that not
    all implementations allow this option to be set.

    For Boolean options, 0 indicates that the option is disabled and 1
    indicates that the option is enabled.

    Options at other protocol levels vary in format and name.

RETURN VALUE

    Upon successful completion, setsockopt() shall return 0. Otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS
    The setsockopt() function shall fail if:

        [EBADF]
        The socket argument is not a valid file descriptor.

        [EDOM]
        The send and receive timeout values are too big to fit into the timeout
        fields in the socket structure.

        [EINVAL]
        The specified option is invalid at the specified socket level or the
        socket has been shut down.

        [EISCONN]
        The socket is already connected, and a specified option cannot be set
        while the socket is connected.

        [ENOPROTOOPT]
        The option is not supported by the protocol.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

    The setsockopt() function may fail if:

        [ENOMEM]
        There was insufficient memory available for the operation to complete.

        [ENOBUFS]
        Insufficient resources are available in the system to complete the
        call.
*/

specification typedef struct SocketLinger SocketLinger = {};

specification typedef struct SocketOptionValue SocketOptionValue = {};

specification
IntT setsockopt_spec( CallContext context, FileDescId socket, IntT level, SocketOption option, SocketOptionValue* value, ErrorCode* errno)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);
    pre
    {
        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * The option_value shall point to a memory buffer containing the options
         */
        REQ("app.setsockopt.30.01.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * option_len shall contain the size in bytes of that buffer
         */
        REQ("app.setsockopt.30.01.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * For IPv4, the maximum length of options is 40 bytes.
         */
        REQ("app.setsockopt.30.01.03", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * The option_value shall point to a value containing the type of service value.
         */
        REQ("app.setsockopt.30.02.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * The least significant two bits of the value shall contain the new Type of
         * Service indicator.
         */
        REQ("app.setsockopt.30.02.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * The option_len parameter shall hold the size, in bytes, of the buffer referred
         * to by option_value.
         */
        REQ("app.setsockopt.30.02.03", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * The option_value shall point to a value containing the time to live value
         */
        REQ("app.setsockopt.30.03.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * which shall be between 1 and 255
         */
        REQ("app.setsockopt.30.03.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * The option_len parameter shall hold the size, in bytes, of the buffer referred
         * to by option_value.
         */
        REQ("app.setsockopt.30.03.03", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_TTL
         *
         * optval shall point to an integer which contains the new TTL value.
         */
        REQ("app.setsockopt.30.04.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_LOOP
         *
         * optval shall point to an integer which contains the new flag value.
         */
        REQ("app.setsockopt.30.05.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_ADD_MEMBERSHIP
         *
         * optval shall point to a ip_mreq structure.
         */
        REQ("app.setsockopt.30.06.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_ADD_MEMBERSHIP
         *
         * Before calling, the caller should fill in the imr_multiaddr field with the
         * multicast group address and the imr_address field with the address of the local
         * interface.
         */
        REQ("app.setsockopt.30.06.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_DROP_MEMBERSHIP
         *
         * optval shall point to a ip_mreq structure containing the same values as were
         * used with IP_ADD_MEMBERSHIP.
         */
        REQ("app.setsockopt.30.07.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_IF
         *
         * optval shall point to a ip_mreq structure initialized in the same manner as
         * with IP_ADD_MEMBERSHIP.
         */
        REQ("app.setsockopt.30.08.01", "", TODO_REQ());

        return true;
    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_SETSOCKOPT, "setsockopt.10.02", setsockopt_spec==-1, *errno)

        /*
        * The setsockopt() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_SETSOCKOPT, EBADF, "setsockopt.11.01", getFileDescriptor(socket)==NULL)

        /*
        * The setsockopt() function shall fail if:
        *
        * [EDOM] The send and receive timeout values are too big to fit into the
        * timeout fields in the socket structure.
        */
        ERROR_SHALL(POSIX_SETSOCKOPT, EDOM, "setsockopt.11.02", TODO_ERR(EDOM) )

        /*
        * The setsockopt() function shall fail if:
        *
        * [EINVAL] The specified option is invalid at the specified socket level or the
        * socket has been shut down.
        */
        ERROR_SHALL3(POSIX_SETSOCKOPT, EINVAL, "setsockopt.11.03", isSocketOptionValid(level, socket, option))

        /*
        * The setsockopt() function shall fail if:
        *
        * [EISCONN] The socket is already connected, and a specified option cannot be
        * set while the socket is connected.
        */
        ERROR_SHALL(POSIX_SETSOCKOPT, EISCONN, "setsockopt.11.04", fdesc!=NULL && getFileKind_FileDescId(socket)==Socket &&
            fdesc->peer_addr!=NULL)

        /*
        * The setsockopt() function shall fail if:
        *
        * [ENOPROTOOPT] The option is not supported by the protocol.
        */
        ERROR_SHALL(POSIX_SETSOCKOPT, ENOPROTOOPT, "setsockopt.11.05", TODO_ERR(ENOPROTOOPT) )

        /*
        * The setsockopt() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_SETSOCKOPT, ENOTSOCK, "setsockopt.11.06", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
        * The setsockopt() function may fail if:
        *
        * [ENOMEM] There was insufficient memory available for the operation to
        * complete.
        */
        ERROR_UNCHECKABLE(POSIX_SETSOCKOPT, ENOMEM, "setsockopt.12.01", "Can not check insufficient memory case")

        /*
        * The setsockopt() function may fail if:
        *
        * [ENOBUFS] Insufficient resources are available in the system to complete the
        * call.
        */
        ERROR_UNCHECKABLE(POSIX_SETSOCKOPT, ENOBUFS, "setsockopt.12.02", "Can not check insufficient resources case")

        ERROR_END()

        /*
         * Upon successful completion, setsockopt() shall return 0.
         */
        REQ("setsockopt.10.01", "Function shall return zero", setsockopt_spec==0);

        /*
         * The setsockopt() function shall set the option specified by the option_name
         * argument, at the protocol level specified by the level argument, to the value
         * pointed to by the option_value argument for the socket associated with the file
         * descriptor specified by the socket argument.
         */
        REQ("setsockopt.01", "", TODO_REQ());

        /*
         * The option_name argument and any specified options are passed uninterpreted to
         * the appropriate protocol module for interpretations.
         */
        REQ("setsockopt.06", "", TODO_REQ());

        /*
         * If the connected socket fails to respond to these messages, the connection is
         * broken and threads writing to that socket are notified with a SIGPIPE signal.
         */
        REQ("setsockopt.07.05.01", "", TODO_REQ());

        /*
         * SO_DONTROUTE
         *
         * The destination shall be on a directly-connected network, and messages are
         * directed to the appropriate network interface according to the destination
         * address.
         */
        REQ("setsockopt.07.10.02", "", TODO_REQ());

        /*
         * SO_DONTROUTE
         *
         * The effect, if any, of this option depends on what protocol is in use.
         */
        REQ("setsockopt.07.10.03", "", TODO_REQ());

        /*
         * SO_RCVLOWAT
         *
         * If SO_RCVLOWAT is set to a larger value, blocking receive calls normally wait
         * until they have received the smaller of the low water mark value or the
         * requested amount.
         */
        REQ("setsockopt.07.11.03", "", TODO_REQ());

        /*
         * SO_RCVLOWAT
         *
         * They may return less than the low water mark if an error occurs, a signal is
         * caught, or the type of data next in the receive queue is different from that
         * returned;
         */
        REQ("setsockopt.07.11.04", "", TODO_REQ());

        /*
         * SO_RCVLOWAT
         *
         * Note that not all implementations allow this option to be set.
         */
        REQ("setsockopt.07.11.06", "", TODO_REQ());

        /*
         * If a receive operation has blocked for this much time without receiving
         * additional data, it shall return with a partial count
         */
        REQ("setsockopt.07.12.03.01", "", TODO_REQ());

        /*
         * or errno set to [EAGAIN] or [EWOULDBLOCK] if no data is received.
         */
        REQ("setsockopt.07.12.03.02", "", TODO_REQ());

        /*
         * SO_RCVTIMEO
         *
         * Note that not all implementations allow this option to be set.
         */
        REQ("setsockopt.07.12.06", "", TODO_REQ());

        /*
         * SO_SNDLOWAT
         *
         * Non-blocking output operations shall process no data if flow control does not
         * allow the smaller of the send low water mark value or the entire request to be
         * processed.
         */
        REQ("setsockopt.07.13.02", "", TODO_REQ());

        /*
         * SO_SNDLOWAT
         *
         * Note that not all implementations allow this option to be set.
         */
        REQ("setsockopt.07.13.04", "", TODO_REQ());

        /*
         * SO_SNDTIMEO
         *
         * If a send operation has blocked for this time, it shall return with a partial
         * count
         */
        REQ("setsockopt.07.14.02", "", TODO_REQ());

        /*
         * SO_SNDTIMEO
         *
         * or with errno set to [EAGAIN] or [EWOULDBLOCK] if no data is sent.
         */
        REQ("setsockopt.07.14.03", "", TODO_REQ());

        /*
         * SO_SNDTIMEO
         *
         * Note that not all implementations allow this option to be set.
         */
        REQ("setsockopt.07.14.06", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_OPTIONS
         *
         * Set the Internet Protocol options sent with every packet from this socket.
         */
        REQ("setsockopt.30.01.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TOS
         *
         * Set the Type of Service flags to use when sending packets with this socket.
         */
        REQ("setsockopt.30.02.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_TTL
         *
         * Set the current unicast Internet Protocol Time To Live value used when sending
         * packets with this socket.
         */
        REQ("setsockopt.30.03.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_TTL
         *
         * Sets the Time To Live value of outgoing multicast packets for this socket.
         */
        REQ("setsockopt.30.04.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_TTL
         *
         * If the new TTL value is -1, the implementation should use an unspecified
         * default TTL value.
         */
        REQ("setsockopt.30.04.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_TTL
         *
         * If the new TTL value is out of the range of acceptable values (0-255),
         * setsockopt() shall return -1 and set errno to indicate the error.
         */
        REQ("setsockopt.30.04.03", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_LOOP
         *
         * Sets a boolean flag indicating whether multicast packets originating locally
         * should be looped back to the local sockets.
         */
        REQ("setsockopt.30.05.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_ADD_MEMBERSHIP
         *
         * Join a multicast group.
         */
        REQ("setsockopt.30.06.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_ADD_MEMBERSHIP
         *
         * If imr_address is set to INADDR_ANY, then an appropriate interface is chosen by
         * the system.
         */
        REQ("setsockopt.30.06.02", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_DROP_MEMBERSHIP
         *
         * Leave a multicast group.
         */
        REQ("setsockopt.30.07.01", "", TODO_REQ());

        /*
         * If the level parameter is IPPROTO_IP, the following values shall be supported
         * for option_name (see RFC 791:Internet Protocol for further details):
         *
         * IP_MULTICAST_IF
         *
         * Set the local device for a multicast socket.
         */
        REQ("setsockopt.30.08.01", "", TODO_REQ());

        return true;
    }
}


void onSetsockopt( CallContext context, FileDescId socket, IntT level, SocketOption option, SocketOptionValue* value, IntT setsockopt_spec)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);

    if (setsockopt_spec!=-1 && level==SUT_SOL_SOCKET)
    {
        if (option==SUT_SO_SNDBUF || option==SUT_SO_RCVBUF)
        {
            SocketOptionValue* put_value=clone(value);
            put_value->value = put_value->value*2;
            put_Map(fdesc->socketOptions, create_IntTObj(option), put_value);
        }
        else
        {
            put_Map(fdesc->socketOptions, create_IntTObj(option), clone(value));
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    shutdown - shut down socket send and receive operations

SYNOPSIS

    #include <sys/socket.h>
    int shutdown(int socket, int how);

DESCRIPTION

    The shutdown() function shall cause all or part of a full-duplex connection
    on the socket associated with the file descriptor socket to be shut down.

    The shutdown() function takes the following arguments:

        socket
        Specifies the file descriptor of the socket.

        how
        Specifies the type of shutdown. The values are as follows:

            SHUT_RD
            Disables further receive operations.

            SHUT_WR
            Disables further send operations.

            SHUT_RDWR
            Disables further send and receive operations.

    The shutdown() function disables subsequent send and/or receive operations
    on a socket, depending on the value of the how argument.

RETURN VALUE

    Upon successful completion, shutdown() shall return 0; otherwise, -1 shall
    be returned and errno set to indicate the error.

ERRORS

    The shutdown() function shall fail if:

        [EBADF]
        The socket argument is not a valid file descriptor.

        [EINVAL]
        The how argument is invalid.

        [ENOTCONN]
        The socket is not connected.

        [ENOTSOCK]
        The socket argument does not refer to a socket.

    The shutdown() function may fail if:

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.
*/
specification
IntT shutdown_spec( CallContext context, FileDescId socket, ShutdownType how, ErrorCode* errno)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);
    pre
    {
        return true;
    }
    post
    {
        /*
        * otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_SHUTDOWN, "shutdown.04.02", shutdown_spec==-1, *errno)

        /*
        * The shutdown() function shall fail if:
        *
        * [EBADF] The socket argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_SHUTDOWN, EBADF, "shutdown.05.01", getFileDescriptor(socket)==NULL)

        /*
        * The shutdown() function shall fail if:
        *
        * [EINVAL] The how argument is invalid.
        */
        ERROR_SHALL(POSIX_SHUTDOWN, EINVAL, "shutdown.05.02", how!=SUT_SHUT_RD && how!=SUT_SHUT_RDWR && how!=SUT_SHUT_WR)

        /*
        * The shutdown() function shall fail if:
        *
        * [ENOTCONN] The socket is not connected.
        */
        ERROR_SHALL(POSIX_SHUTDOWN, ENOTCONN, "shutdown.05.03", fdesc!=NULL && getFileKind_FileDescId(socket)==Socket
            && fdesc->peer_addr==NULL)

        /*
        * The shutdown() function shall fail if:
        *
        * [ENOTSOCK] The socket argument does not refer to a socket.
        */
        ERROR_SHALL(POSIX_SHUTDOWN, ENOTSOCK, "shutdown.05.04", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)!=Socket)

        /*
        * The shutdown() function may fail if:
        *
        * [ENOBUFS] Insufficient resources were available in the system to perform the
        * operation.
        */
        ERROR_UNCHECKABLE(POSIX_SHUTDOWN, ENOBUFS, "shutdown.06.01", "Can not check insufficient resources case")

        ERROR_END()

        /*
        * Upon successful completion, shutdown() shall return 0;
        */
        REQ("shutdown.04.01", "Function shall return zero", shutdown_spec==0);


        return true;
    }
}

void onShutdown(CallContext context, FileDescId socket, ShutdownType how, IntT shutdown_spec)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);

    if (shutdown_spec!=-1)
    {
        fdesc->shutdown=how;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sockatmark - determine whether a socket is at the out-of-band mark

SYNOPSIS

    #include <sys/socket.h>
    int sockatmark(int s);

DESCRIPTION

    The sockatmark() function shall determine whether the socket specified by
    the descriptor s is at the out-of-band data mark (see the System Interfaces
    volume of IEEE Std 1003.1-2001, Section 2.10.12, Socket Out-of-Band State).
    If the protocol for the socket supports out-of-band data by marking the
    stream with an out-of-band data mark, the sockatmark() function shall
    return 1 when all data preceding the mark has been read and the out-of-band
    data mark is the first element in the receive queue. The sockatmark()
    function shall not remove the mark from the stream.

RETURN VALUE

    Upon successful completion, the sockatmark() function shall return a value
    indicating whether the socket is at an out-of-band data mark. If the
    protocol has marked the data stream and all data preceding the mark has
    been read, the return value shall be 1; if there is no mark, or if data
    precedes the mark in the receive queue, the sockatmark() function shall
    return 0. Otherwise, it shall return a value of -1 and set errno to
    indicate the error.

ERRORS

    The sockatmark() function shall fail if:

        [EBADF]
        The s argument is not a valid file descriptor.
        [ENOTTY]
        The s argument does not specify a descriptor for a socket.
*/
specification
IntT sockatmark_spec( CallContext context, FileDescId s, ErrorCode* errno)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(s);

    pre
    {
        return true;
    }
    post
    {
        /*
        * Otherwise, it shall return a value of -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SOCKATMARK, "sockatmark.05.03", sockatmark_spec==-1, *errno)

        /*
        * The sockatmark() function shall fail if:
        *
        * [EBADF] The s argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_SOCKATMARK, EBADF, "sockatmark.06.01", fdesc==NULL)

        /*
        * The sockatmark() function shall fail if:
        *
        * [ENOTTY] The s argument does not specify a descriptor for a socket.
        */
        ERROR_SHALL(POSIX_SOCKATMARK, ENOTTY, "sockatmark.06.02", getFileDescriptor(s)!=NULL
            && getFileKind_FileDescId(s)!=Socket)

        ERROR_END()


        /*
        * The sockatmark() function shall determine whether the socket specified by the
        * descriptor s is at the out-of-band data mark
        */
        REQ("sockatmark.01", "", TODO_REQ());

        /*
        * If the protocol for the socket supports out-of-band data by marking the stream
        * with an out-of-band data mark, the sockatmark() function shall return 1 when
        * all data preceding the mark has been read and the out-of-band data mark is the
        * first element in the receive queue.
        */
        REQ("sockatmark.02", "", TODO_REQ());

        /*
        * The sockatmark() function shall not remove the mark from the stream.
        */
        REQ("sockatmark.03", "", TODO_REQ());

        /*
        * Upon successful completion, the sockatmark() function shall return a value
        * indicating whether the socket is at an out-of-band data mark.
        */
        REQ("sockatmark.04", "", TODO_REQ());

        /*
        * If the protocol has marked the data stream and all data preceding the mark has
        * been read, the return value shall be 1;
        */
        REQ("sockatmark.05.01", "", TODO_REQ());

        /*
        * if there is no mark, or if data precedes the mark in the receive queue, the
        * sockatmark() function shall return 0.
        */
        REQ("sockatmark.05.02", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    socket - create an endpoint for communication

SYNOPSIS

    #include <sys/socket.h>
    int socket(int domain, int type, int protocol);

DESCRIPTION

    The socket() function shall create an unbound socket in a communications
    domain, and return a file descriptor that can be used in later function
    calls that operate on sockets.

    The socket() function takes the following arguments:

    domain
        Specifies the communications domain in which a socket is to be created.
    type
        Specifies the type of socket to be created.
    protocol
        Specifies a particular protocol to be used with the socket. Specifying
        a protocol of 0 causes socket() to use an unspecified default protocol
        appropriate for the requested socket type.

    The domain argument specifies the address family used in the communications
    domain. The address families supported by the system are
    implementation-defined.

    Symbolic constants that can be used for the domain argument are defined in
    the <sys/socket.h> header.

    The type argument specifies the socket type, which determines the semantics
    of communication over the socket. The following socket types are defined;
    implementations may specify additional socket types:

    SOCK_STREAM
        Provides sequenced, reliable, bidirectional, connection-mode byte
        streams, and may provide a transmission mechanism for out-of-band data.
    SOCK_DGRAM
        Provides datagrams, which are connectionless-mode, unreliable messages
        of fixed maximum length.
    SOCK_SEQPACKET
        Provides sequenced, reliable, bidirectional, connection-mode
        transmission paths for records. A record can be sent using one or more
        output operations and received using one or more input operations, but
        a single operation never transfers part of more than one record. Record
        boundaries are visible to the receiver via the MSG_EOR flag.

    If the protocol argument is non-zero, it shall specify a protocol that is
    supported by the address family. If the protocol argument is zero, the
    default protocol for this address family and type shall be used. The
    protocols supported by the system are implementation-defined.

    The process may need to have appropriate privileges to use the socket()
    function or to create some sockets.

RETURN VALUE

    Upon successful completion, socket() shall return a non-negative integer,
    the socket file descriptor. Otherwise, a value of -1 shall be returned and
    errno set to indicate the error.

ERRORS

    The socket() function shall fail if:

        [EAFNOSUPPORT]
        The implementation does not support the specified address family.

        [EMFILE]
        No more file descriptors are available for this process.

        [ENFILE]
        No more file descriptors are available for the system.

        [EPROTONOSUPPORT]
        The protocol is not supported by the address family, or the protocol is
        not supported by the implementation.

        [EPROTOTYPE]
        The socket type is not supported by the protocol.

    The socket() function may fail if:

        [EACCES]
        The process does not have appropriate privileges.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.
*/

Bool3 isProtocolNotSupported(IntT protocol)
{
    /*
            PROTOCOL NUMBERS

        (last updated 28 March 2006)

        In the Internet Protocol version 4 (IPv4) [RFC791] there is a field,
        called "Protocol", to identify the next level protocol.  This is an 8
        bit field.  In Internet Protocol version 6 (IPv6) [RFC1883] this field
        is called the "Next Header" field.

        Assigned Internet Protocol Numbers

        Decimal    Keyword     Protocol                         References
        -------    -------     --------                         ----------
             0     HOPOPT      IPv6 Hop-by-Hop Option            [RFC1883]
             1     ICMP        Internet Control Message           [RFC792]
             2     IGMP        Internet Group Management         [RFC1112]
             3     GGP         Gateway-to-Gateway                 [RFC823]
             4     IP          IP in IP (encapsulation)          [RFC2003]
             5     ST          Stream                    [RFC1190,RFC1819]
             6     TCP         Transmission Control               [RFC793]
             7     CBT         CBT                             [Ballardie]
             8     EGP         Exterior Gateway Protocol     [RFC888,DLM1]
             9     IGP         any private interior gateway         [IANA]
                               (used by Cisco for their IGRP)
            10     BBN-RCC-MON BBN RCC Monitoring                    [SGC]
            11     NVP-II      Network Voice Protocol         [RFC741,SC3]
            12     PUP         PUP                             [PUP,XEROX]
            13     ARGUS       ARGUS                                [RWS4]
            14     EMCON       EMCON                                 [BN7]
            15     XNET        Cross Net Debugger            [IEN158,JFH2]
            16     CHAOS       Chaos                                 [NC3]
            17     UDP         User Datagram                  [RFC768,JBP]
            18     MUX         Multiplexing                    [IEN90,JBP]
            19     DCN-MEAS    DCN Measurement Subsystems           [DLM1]
            20     HMP         Host Monitoring                [RFC869,RH6]
            21     PRM         Packet Radio Measurement              [ZSU]
            22     XNS-IDP     XEROX NS IDP               [ETHERNET,XEROX]
            23     TRUNK-1     Trunk-1                              [BWB6]
            24     TRUNK-2     Trunk-2                              [BWB6]
            25     LEAF-1      Leaf-1                               [BWB6]
            26     LEAF-2      Leaf-2                               [BWB6]
            27     RDP         Reliable Data Protocol         [RFC908,RH6]
            28     IRTP        Internet Reliable Transaction  [RFC938,TXM]
            29     ISO-TP4     ISO Transport Protocol Class 4 [RFC905,RC77]
            30     NETBLT      Bulk Data Transfer Protocol    [RFC969,DDC1]
            31     MFE-NSP     MFE Network Services Protocol  [MFENET,BCH2]
            32     MERIT-INP   MERIT Internodal Protocol             [HWB]
            33     DCCP        Datagram Congestion Control Protocol  [RFC-ietf-dccp-spec-11.txt]
            34     3PC         Third Party Connect Protocol         [SAF3]
            35     IDPR        Inter-Domain Policy Routing Protocol [MXS1]
            36     XTP         XTP                                   [GXC]
            37     DDP         Datagram Delivery Protocol            [WXC]
            38     IDPR-CMTP   IDPR Control Message Transport Proto [MXS1]
            39     TP++        TP++ Transport Protocol               [DXF]
            40     IL          IL Transport Protocol            [Presotto]
            41     IPv6        Ipv6                              [Deering]
            42     SDRP        Source Demand Routing Protocol       [DXE1]
            43     IPv6-Route  Routing Header for IPv6           [Deering]
            44     IPv6-Frag   Fragment Header for IPv6          [Deering]
            45     IDRP        Inter-Domain Routing Protocol   [Sue Hares]
            46     RSVP        Reservation Protocol           [Bob Braden]
            47     GRE         General Routing Encapsulation     [Tony Li]
            48     MHRP        Mobile Host Routing Protocol[David Johnson]
            49     BNA         BNA                          [Gary Salamon]
            50     ESP         Encap Security Payload            [RFC2406]
            51     AH          Authentication Header             [RFC2402]
            52     I-NLSP      Integrated Net Layer Security  TUBA [GLENN]
            53     SWIPE       IP with Encryption                    [JI6]
            54     NARP        NBMA Address Resolution Protocol  [RFC1735]
            55     MOBILE      IP Mobility                       [Perkins]
            56     TLSP        Transport Layer Security Protocol   [Oberg]
                               using Kryptonet key management
            57     SKIP        SKIP                              [Markson]
            58     IPv6-ICMP   ICMP for IPv6                     [RFC1883]
            59     IPv6-NoNxt  No Next Header for IPv6           [RFC1883]
            60     IPv6-Opts   Destination Options for IPv6      [RFC1883]
            61                 any host internal protocol           [IANA]
            62     CFTP        CFTP                            [CFTP,HCF2]
            63                 any local network                    [IANA]
            64     SAT-EXPAK   SATNET and Backroom EXPAK             [SHB]
            65     KRYPTOLAN   Kryptolan                            [PXL1]
            66     RVD         MIT Remote Virtual Disk Protocol      [MBG]
            67     IPPC        Internet Pluribus Packet Core         [SHB]
            68                 any distributed file system          [IANA]
            69     SAT-MON     SATNET Monitoring                     [SHB]
            70     VISA        VISA Protocol                        [GXT1]
            71     IPCV        Internet Packet Core Utility          [SHB]
            72     CPNX        Computer Protocol Network Executive  [DXM2]
            73     CPHB        Computer Protocol Heart Beat         [DXM2]
            74     WSN         Wang Span Network                     [VXD]
            75     PVP         Packet Video Protocol                 [SC3]
            76     BR-SAT-MON  Backroom SATNET Monitoring            [SHB]
            77     SUN-ND      SUN ND PROTOCOL-Temporary             [WM3]
            78     WB-MON      WIDEBAND Monitoring                   [SHB]
            79     WB-EXPAK    WIDEBAND EXPAK                        [SHB]
            80     ISO-IP      ISO Internet Protocol                 [MTR]
            81     VMTP        VMTP                                 [DRC3]
            82     SECURE-VMTP SECURE-VMTP                          [DRC3]
            83     VINES       VINES                                 [BXH]
            84     TTP         TTP                                   [JXS]
            85     NSFNET-IGP  NSFNET-IGP                            [HWB]
            86     DGP         Dissimilar Gateway Protocol     [DGP,ML109]
            87     TCF         TCF                                  [GAL5]
            88     EIGRP       EIGRP                           [CISCO,GXS]
            89     OSPFIGP     OSPFIGP                      [RFC1583,JTM4]
            90     Sprite-RPC  Sprite RPC Protocol            [SPRITE,BXW]
            91     LARP        Locus Address Resolution Protocol     [BXH]
            92     MTP         Multicast Transport Protocol          [SXA]
            93     AX.25       AX.25 Frames                         [BK29]
            94     IPIP        IP-within-IP Encapsulation Protocol   [JI6]
            95     MICP        Mobile Internetworking Control Pro.   [JI6]
            96     SCC-SP      Semaphore Communications Sec. Pro.    [HXH]
            97     ETHERIP     Ethernet-within-IP Encapsulation  [RFC3378]
            98     ENCAP       Encapsulation Header         [RFC1241,RXB3]
            99                 any private encryption scheme        [IANA]
           100     GMTP        GMTP                                 [RXB5]
           101     IFMP        Ipsilon Flow Management Protocol   [Hinden]
           102     PNNI        PNNI over IP                       [Callon]
           103     PIM         Protocol Independent Multicast  [Farinacci]
           104     ARIS        ARIS                              [Feldman]
           105     SCPS           SCPS                                [Durst]
           106        QNX           QNX                                [Hunter]
           107       A/N           Active Networks                    [Braden]
           108       IPComp      IP Payload Compression Protocol   [RFC2393]
           109       SNP           Sitara Networks Protocol          [Sridhar]
           110       Compaq-Peer Compaq Peer Protocol                [Volpe]
           111       IPX-in-IP   IPX in IP                             [Lee]
           112     VRRP          Virtual Router Redundancy Protocol [RFC3768]
           113     PGM         PGM Reliable Transport Protocol  [Speakman]
           114                 any 0-hop protocol                   [IANA]
           115       L2TP        Layer Two Tunneling Protocol        [Aboba]
           116     DDX           D-II Data Exchange (DDX)           [Worley]
           117       IATP      Interactive Agent Transfer Protocol  [Murphy]
           118     STP         Schedule Transfer Protocol            [JMP]
           119     SRP           SpectraLink Radio Protocol       [Hamilton]
           120     UTI      UTI                                 [Lothberg]
           121     SMP      Simple Message Protocol               [Ekblad]
           122       SM       SM                                 [Crowcroft]
           123       PTP      Performance Transparency Protocol      [Welzl]
           124     ISIS over IPv4                             [Przygienda]
           125     FIRE                                        [Partridge]
           126       CRTP     Combat Radio Transport Protocol      [Sautter]
           127       CRUDP    Combat Radio User Datagram           [Sautter]
           128     SSCOPMCE                                        [Waber]
           129     IPLT                                         [Hollbach]
           130     SPS    Secure Packet Shield                  [McIntosh]
           131     PIPE   Private IP Encapsulation within IP       [Petri]
           132     SCTP   Stream Control Transmission Protocol   [Stewart]
           133     FC     Fibre Channel                        [Rajagopal]
           134     RSVP-E2E-IGNORE                               [RFC3175]
           135     Mobility Header                               [RFC3775]
           136     UDPLite                                       [RFC3828]
           137     MPLS-in-IP                                    [RFC4023]
           138-252 Unassigned                                       [IANA]
           253     Use for experimentation and testing           [RFC3692]
           254     Use for experimentation and testing           [RFC3692]
           255                 Reserved                             [IANA]
    */
    if (protocol>=138 && protocol<=252)
    {
        return True_Bool3;
    }

    return Unknown_Bool3;
}

specification
FileDescId socket_spec( CallContext context, SocketDomain  domain, SocketType type, SocketProtocol protocol, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * Otherwise, a value of -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_SOCKET, "socket.07.02", socket_spec.filedesc == -1, *errno)

        /*
        * The socket() function shall fail if:
        *
        * [EAFNOSUPPORT] The implementation does not support the specified address
        * family.
        */
        ERROR_SHALL(POSIX_SOCKET, EAFNOSUPPORT, "socket.08.01", TODO_ERR(EAFNOSUPPORT) )

        /*
        * The socket() function shall fail if:
        *
        * [EMFILE] No more file descriptors are available for this process.
        */
        ERROR_SHALL3(POSIX_SOCKET, EMFILE, "socket.08.02", @isOpenFileDescNumberExceedMax(context))

        /*
        * The socket() function shall fail if:
        *
        * [ENFILE] No more file descriptors are available for the system.
        */
        ERROR_UNCHECKABLE(POSIX_SOCKET, ENFILE, "socket.08.03", "ENFILE couldn't be checked")

        /*
        * The socket() function shall fail if:
        *
        * [EPROTONOSUPPORT] The protocol is not supported by the address family, or the
        * protocol is not supported by the implementation.
        */
        ERROR_SHALL3(POSIX_SOCKET, EPROTONOSUPPORT, "socket.08.04", isProtocolNotSupported(protocol))

        /*
        * The socket() function shall fail if:
        *
        * [EPROTOTYPE] The socket type is not supported by the protocol.
        */
        ERROR_SHALL(POSIX_SOCKET, EPROTOTYPE, "socket.08.05", TODO_ERR(EPROTOTYPE) )

        /*
        * The socket() function may fail if:
        *
        * [EACCES] The process does not have appropriate privileges.
        */
        /*
         * The process may need to have appropriate privileges to use the socket()
         * function or to create some sockets.
         */
        ERROR_MAY(POSIX_SOCKET, EACCES, "socket.09.01;socket.06", TODO_ERR(EACCES))

        /*
        * The socket() function may fail if:
        *
        * [ENOBUFS] Insufficient resources were available in the system to perform the
        * operation.
        */
        ERROR_UNCHECKABLE(POSIX_SOCKET, ENOBUFS, "socket.09.02", "Can not check insufficient resourses case")

        /*
        * The socket() function may fail if:
        *
        * [ENOMEM] Insufficient memory was available to fulfill the request.
        */
        ERROR_UNCHECKABLE(POSIX_SOCKET, ENOMEM, "socket.09.03", "Can not check insufficient memory case")

        ERROR_END()


        /*
         * and return a file descriptor that can be used in later function calls that
         * operate on sockets.
         */
        /*
         * Upon successful completion, socket() shall return a non-negative integer, the
         * socket file descriptor.
         */
        REQ("socket.01.02;socket.07.01", "Non negative integer shall be returned", socket_spec.filedesc >=0);

        /*
         * The type argument specifies the socket type, which determines the semantics of
         * communication over the socket. The following socket types are defined;
         * implementations may specify additional socket types:
         *
         * SOCK_SEQPACKET
         *
         * A record can be sent using one or more output operations and received using one
         * or more input operations, but a single operation never transfers part of more
         * than one record.
         */
        REQ("socket.04.03.02", "", TODO_REQ());

        /*
         * The type argument specifies the socket type, which determines the semantics of
         * communication over the socket. The following socket types are defined;
         * implementations may specify additional socket types:
         *
         * SOCK_SEQPACKET
         *
         * Record boundaries are visible to the receiver via the MSG_EOR flag.
         */
        REQ("socket.04.03.03", "", TODO_REQ());

        {
            SocketFileDescriptor* desc=getDescriptor_FileDescId(socket_spec);

            /*
            * Sockets created with the socket() function are initially unnamed; they are
            * identified only by their address family.
            */
            REQ("bind.02", "Socket shall be unnamed", desc!=NULL && desc->addr == NULL);
        }

        /*
         * The address families supported by the system are implementation-defined.
         */
        /*
         * The protocols supported by the system are implementation-defined.
         */
        /*
         * If the protocol argument is non-zero, it shall specify a protocol that is
         * supported by the address family.
         */
        REQ_UNCHECKABLE("socket.03.02;socket.05.03;socket.05.01", "This is implementation-defined information");


        return true;
    }
}


void onSocket( CallContext context, SocketDomain  domain, SocketType type, SocketProtocol protocol, FileDescId socket_spec)
{

    if (socket_spec.filedesc != -1)
    {
        SocketFileDescriptor* sdesc = create_SocketDescriptor(domain, type, protocol);
        register_SocketDesriptor(socket_spec, sdesc);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    socketpair - create a pair of connected sockets

SYNOPSIS

    #include <sys/socket.h>
    int socketpair(int domain, int type, int protocol,
        int socket_vector[2]);

DESCRIPTION

    The socketpair() function shall create an unbound pair of connected sockets
    in a specified domain, of a specified type, under the protocol optionally
    specified by the protocol argument. The two sockets shall be identical. The
    file descriptors used in referencing the created sockets shall be returned
    in socket_vector[0] and socket_vector[1].

    The socketpair() function takes the following arguments:

        domain
        Specifies the communications domain in which the sockets are to be
        created.

        type
        Specifies the type of sockets to be created.

        protocol
        Specifies a particular protocol to be used with the sockets. Specifying
        a protocol of 0 causes socketpair() to use an unspecified default
        protocol appropriate for the requested socket type.

        socket_vector
        Specifies a 2-integer array to hold the file descriptors of the created
        socket pair.

    The type argument specifies the socket type, which determines the semantics
    of communications over the socket. The following socket types are defined;
    implementations may specify additional socket types:

        SOCK_STREAM
        Provides sequenced, reliable, bidirectional, connection-mode byte
        streams, and may provide a transmission mechanism for out-of-band data.

        SOCK_DGRAM
        Provides datagrams, which are connectionless-mode, unreliable messages
        of fixed maximum length.

        SOCK_SEQPACKET
        Provides sequenced, reliable, bidirectional, connection-mode
        transmission paths for records. A record can be sent using one or more
        output operations and received using one or more input operations, but
        a single operation never transfers part of more than one record. Record
        boundaries are visible to the receiver via the MSG_EOR flag.

    If the protocol argument is non-zero, it shall specify a protocol that is
    supported by the address family. If the protocol argument is zero, the
    default protocol for this address family and type shall be used. The
    protocols supported by the system are implementation-defined.

    The process may need to have appropriate privileges to use the socketpair()
    function or to create some sockets.

RETURN VALUE

    Upon successful completion, this function shall return 0; otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS

    The socketpair() function shall fail if:

        [EAFNOSUPPORT]
        The implementation does not support the specified address family.

        [EMFILE]
        No more file descriptors are available for this process.

        [ENFILE]
        No more file descriptors are available for the system.

        [EOPNOTSUPP]
        The specified protocol does not permit creation of socket pairs.

        [EPROTONOSUPPORT]
        The protocol is not supported by the address family, or the protocol is
        not supported by the implementation.

        [EPROTOTYPE]
        The socket type is not supported by the protocol.

    The socketpair() function may fail if:

        [EACCES]
        The process does not have appropriate privileges.

        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

        [ENOMEM]
        Insufficient memory was available to fulfill the request.
*/

specification typedef  struct SocketPairReturnType SocketPairReturnType = {};


specification
SocketPairReturnType* socketpair_spec( CallContext context,  SocketDomain  domain, SocketType type, SocketProtocol protocol, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_SOCKETPAIR, "socketpair.08.02", socketpair_spec->funcRes==-1, *errno)

        /*
         * The socketpair() function shall fail if:
         *
         * [EAFNOSUPPORT] The implementation does not support the specified address
         * family.
         */
        ERROR_SHALL(POSIX_SOCKETPAIR, EAFNOSUPPORT, "socketpair.09.01", TODO_ERR(EAFNOSUPPORT) )

        /*
         * The socketpair() function shall fail if:
         *
         * [EMFILE] No more file descriptors are available for this process.
         */
        ERROR_SHALL3(POSIX_SOCKETPAIR, EMFILE, "socketpair.09.02", @isOpenFileDescNumberExceedMax(context) )

        /*
         * The socketpair() function shall fail if:
         *
         * [ENFILE] No more file descriptors are available for the system.
         */
        ERROR_UNCHECKABLE(POSIX_SOCKETPAIR, ENFILE, "socketpair.09.03", "Can not check ENFILE error")

        /*
         * The socketpair() function shall fail if:
         *
         * [EOPNOTSUPP] The specified protocol does not permit creation of socket pairs.
         */
        ERROR_SHALL(POSIX_SOCKETPAIR, EOPNOTSUPP, "socketpair.09.04", TODO_ERR(EOPNOTSUPP) )

        /*
         * The socketpair() function shall fail if:
         *
         * [EPROTONOSUPPORT] The protocol is not supported by the address family, or the
         * protocol is not supported by the implementation.
         */
        /*
         * If the protocol argument is non-zero, it shall specify a protocol that is
         * supported by the address family.
         */
        ERROR_SHALL3(POSIX_SOCKETPAIR, EPROTONOSUPPORT, "socketpair.09.05;socketpair.06.01", isProtocolNotSupported(protocol))

        /*
         * The socketpair() function shall fail if:
         *
         * [EPROTOTYPE] The socket type is not supported by the protocol.
         */
        ERROR_SHALL(POSIX_SOCKETPAIR, EPROTOTYPE, "socketpair.09.06", TODO_ERR(EPROTOTYPE) )

        /*
         * The socketpair() function may fail if:
         *
         * [EACCES] The process does not have appropriate privileges.
         */
        ERROR_MAY(POSIX_SOCKETPAIR, EACCES, "socketpair.10.01", TODO_ERR(EACCES))

        /*
         * The socketpair() function may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_SOCKETPAIR, ENOBUFS, "socketpair.10.02", "Can not check insufficient resources case")

        /*
         * The socketpair() function may fail if:
         *
         * [ENOMEM] Insufficient memory was available to fulfill the request.
         */
        ERROR_UNCHECKABLE(POSIX_SOCKETPAIR, ENOMEM, "socketpair.10.03", "Can not check insufficient memory case")

        ERROR_END()

        /*
         * Upon successful completion, this function shall return 0;
         */
        REQ("socketpair.08.01", "Function shall return 0", socketpair_spec->funcRes==0);

        {
            SocketFileDescriptor* sdesc1=getDescriptor_FileDescId(socketpair_spec->sock1);
            SocketFileDescriptor* sdesc2=getDescriptor_FileDescId(socketpair_spec->sock2);

            /*
             * The socketpair() function shall create an unbound pair of connected sockets in
             * a specified domain, of a specified type, under the protocol optionally
             * specified by the protocol argument.
             */
            REQ("?socketpair.01", "Sockets shall be valid", sdesc1->addr == NULL && sdesc2->addr == NULL &&
                sdesc1->type==type && sdesc1->protocol==protocol && sdesc1->domain==domain &&
                sdesc2->type==type && sdesc2->protocol==protocol && sdesc2->domain==domain);

            /*
            * The two sockets shall be identical.
            */
            REQ("app.socketpair.02", "The two sockets shall be identical", TODO_REQ());
        }

        /*
         * The type argument specifies the socket type, which determines the semantics of
         * communications over the socket. The following socket types are defined;
         * implementations may specify additional socket types:
         *
         * SOCK_SEQPACKET
         *
         * A record can be sent using one or more output operations and received using one
         * or more input operations, but a single operation never transfers part of more
         * than one record.
         */
        REQ("socketpair.05.03.02", "", TODO_REQ());

        /*
         * The type argument specifies the socket type, which determines the semantics of
         * communications over the socket. The following socket types are defined;
         * implementations may specify additional socket types:
         *
         * SOCK_SEQPACKET
         *
         * Record boundaries are visible to the receiver via the MSG_EOR flag.
         */
        REQ("socketpair.05.03.03", "", TODO_REQ());

        /*
         * The protocols supported by the system are implementation-defined.
         */
        REQ("socketpair.06.03", "", TODO_REQ());

        /*
         * The process may need to have appropriate privileges to use the socketpair()
         * function or to create some sockets.
         */
        REQ("socketpair.07", "", TODO_REQ());

        return true;
    }
}

void onSocketpair( CallContext context,  SocketDomain  domain, SocketType type, SocketProtocol protocol, SocketPairReturnType* socketpair_spec)
{
    if (socketpair_spec->funcRes!=-1)
    {
        SocketFileDescriptor* sdesc = create_SocketDescriptor(domain, type, protocol);

        if (type==SUT_SOCK_STREAM)
        {
            sdesc->pairId=socketpair_spec->sock1;
            sdesc->peer_addr= create_SockaddrT_Unspec();

            register_SocketDesriptor(socketpair_spec->sock1, sdesc);
            register_SocketDesriptor(socketpair_spec->sock2, sdesc);
        }
        else if (type==SUT_SOCK_DGRAM)
        {
   	        SocketFileDescriptor* sdesc1 = create_SocketDescriptor(domain, type, protocol);
	        SocketFileDescriptor* sdesc2 = create_SocketDescriptor(domain, type, protocol);
	        sdesc1->socketPair_Buddy=socketpair_spec->sock2;
	        sdesc2->socketPair_Buddy=socketpair_spec->sock1;

            register_SocketDesriptor(socketpair_spec->sock1, sdesc1);
            register_SocketDesriptor(socketpair_spec->sock2, sdesc2);
        }
        else
        {
            setBadVerdict("Other socket types are not supported in specification");
        }
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    pwrite, write - write on a file

SYNOPSIS

    #include <unistd.h>
    [XSI]  ssize_t pwrite(int fildes, const void *buf, size_t nbyte,
           off_t offset);
    ssize_t write(int fildes, const void *buf, size_t nbyte);

DESCRIPTION

    The write() function shall attempt to write nbyte bytes from the buffer
    pointed to by buf to the file associated with the open file descriptor,
    fildes.

    Before any action described below is taken, and if nbyte is zero and the
    file is a regular file, the write() function may detect and return errors
    as described below. In the absence of errors, or if error detection is not
    performed, the write() function shall return zero and have no other
    results. If nbyte is zero and the file is not a regular file, the results
    are unspecified.

    On a regular file or other file capable of seeking, the actual writing of
    data shall proceed from the position in the file indicated by the file
    offset associated with fildes. Before successful return from write(), the
    file offset shall be incremented by the number of bytes actually written.
    On a regular file, if this incremented file offset is greater than the
    length of the file, the length of the file shall be set to this file
    offset.

    On a file not capable of seeking, writing shall always take place starting
    at the current position. The value of a file offset associated with such a
    device is undefined.

    If the O_APPEND flag of the file status flags is set, the file offset shall
    be set to the end of the file prior to each writeand no intervening file
    modification operation shall occur between changing the file offset and the
    write operation.

    If a write() requests that more bytes be written than there is room for
    (for example, [XSI]   the process' file size limit or  the physical end of
    a medium), only as many bytes as there is room for shall be written. For
    example, suppose there is space for 20 bytes more in a file before reaching
    a limit. A write of 512 bytes will return 20. The next write of a non-zero
    number of bytes would give a failure return (except as noted below).

    [XSI]  If the request would cause the file size to exceed the soft file
    size limit for the process and there is no room for any bytes to be
    written, the request shall fail and the implementation shall generate the
    SIGXFSZ signal for the thread.

    If write() is interrupted by a signal before it writes any data, it shall
    return -1 with errno set to [EINTR].

    If write() is interrupted by a signal after it successfully writes some
    data, it shall return the number of bytes written.

    If the value of nbyte is greater than {SSIZE_MAX}, the result is
    implementation-defined.

    After a write() to a regular file has successfully returned:

    Any successful read() from each byte position in the file that was modified
    by that write shall return the data specified by the write() for that
    position until such byte positions are again modified.

    Any subsequent successful write() to the same byte position in the file
    shall overwrite that file data.

    Write requests to a pipe or FIFO shall be handled in the same way as a
    regular file with the following exceptions:

        There is no file offset associated with a pipe, hence each write request
        shall append to the end of the pipe.

        Write requests of {PIPE_BUF} bytes or less shall not be interleaved
        with data from other processes doing writes on the same pipe. Writes
        of greater than {PIPE_BUF} bytes may have data interleaved, on
        arbitrary boundaries, with writes by other processes, whether or not
        the O_NONBLOCK flag of the file status flags is set.

        If the O_NONBLOCK flag is clear, a write request may cause the thread
        to block, but on normal completion it shall return nbyte.

        If the O_NONBLOCK flag is set, write() requests shall be handled
        differently, in the following ways:

        The write() function shall not block the thread.

        A write request for {PIPE_BUF} or fewer bytes shall have the following
        effect: if there is sufficient space available in the pipe, write()
        shall transfer all the data and return the number of bytes requested.
        Otherwise, write() shall transfer no data and return -1 with errno set
        to [EAGAIN].

        A write request for more than {PIPE_BUF} bytes shall cause one of the
        following:

            When at least one byte can be written, transfer what it can and
            return the number of bytes written. When all data previously
            written to the pipe is read, it shall transfer at least {PIPE_BUF}
            bytes.

            When no data can be written, transfer no data, and return -1 with
            errno set to [EAGAIN].

    When attempting to write to a file descriptor (other than a pipe or FIFO)
    that supports non-blocking writes and cannot accept the data immediately:

        If the O_NONBLOCK flag is clear, write() shall block the calling thread
        until the data can be accepted.

        If the O_NONBLOCK flag is set, write() shall not block the thread. If
        some data can be written without blocking the thread, write() shall
        write what it can and return the number of bytes written. Otherwise, it
        shall return -1 and set errno to [EAGAIN].

    Upon successful completion, where nbyte is greater than 0, write() shall
    mark for update the st_ctime and st_mtime fields of the file, and if the
    file is a regular file, the S_ISUID and S_ISGID bits of the file mode may
    be cleared.

    For regular files, no data transfer shall occur past the offset maximum
    established in the open file description associated with fildes.

    If fildes refers to a socket, write() shall be equivalent to send() with no
    flags set.

    [SIO]  If the O_DSYNC bit has been set, write I/O operations on the file
    descriptor shall complete as defined by synchronized I/O data integrity
    completion.

    If the O_SYNC bit has been set, write I/O operations on the file descriptor
    shall complete as defined by synchronized I/O file integrity completion.

    [SHM]  If fildes refers to a shared memory object, the result of the
    write() function is unspecified.

    [TYM] If fildes refers to a typed memory object, the result of the write()
    function is unspecified.

    [XSR] If fildes refers to a STREAM, the operation of write() shall be
    determined by the values of the minimum and maximum nbyte range (packet
    size) accepted by the STREAM. These values are determined by the topmost
    STREAM module. If nbyte falls within the packet size range, nbyte bytes
    shall be written. If nbyte does not fall within the range and the minimum
    packet size value is 0, write() shall break the buffer into maximum packet
    size segments prior to sending the data downstream (the last segment may
    contain less than the maximum packet size).If nbyte does not fall within
    the range and the minimum value is non-zero, write() shall fail with errno
    set to [ERANGE]. Writing a zero-length buffer ( nbyte is 0) to a STREAMS
    device sends 0 bytes with 0 returned. However, writing a zero-length buffer
    to a STREAMS-based pipe or FIFO sends no message and 0 is returned. The
    process may issue I_SWROPT ioctl() to enable zero-length messages to be
    sent across the pipe or FIFO.

    When writing to a STREAM, data messages are created with a priority band of
    0. When writing to a STREAM that is not a pipe or FIFO:

        If O_NONBLOCK is clear, and the STREAM cannot accept data (the STREAM
        write queue is full due to internal flow control conditions), write()
        shall block until data can be accepted.

        If O_NONBLOCK is set and the STREAM cannot accept data, write() shall
        return -1 and set errno to [EAGAIN].

        If O_NONBLOCK is set and part of the buffer has been written while a
        condition in which the STREAM cannot accept additional data occurs,
        write() shall terminate and return the number of bytes written.

    In addition, write() shall fail if the STREAM head has processed an
    asynchronous error before the call. In this case, the value of errno does
    not reflect the result of write(), but reflects the prior error.

    [XSI]  The pwrite() function shall be equivalent to write(), except that it
    writes into a given position without changing the file pointer. The first
    three arguments to pwrite() are the same as write() with the addition of a
    fourth argument offset for the desired position inside the file.

RETURN VALUE

    Upon successful completion, write() [XSI]   and pwrite()  shall return the
    number of bytes actually written to the file associated with fildes. This
    number shall never be greater than nbyte. Otherwise, -1 shall be returned
    and errno set to indicate the error.

ERRORS

    The write() and [XSI]  pwrite()  functions shall fail if:

        [EAGAIN]
        The O_NONBLOCK flag is set for the file descriptor and the thread would
        be delayed in the write() operation.
        [EBADF]
        The fildes argument is not a valid file descriptor open for writing.
        [EFBIG]
        An attempt was made to write a file that exceeds the
        implementation-defined maximum file size [XSI]   or the process' file
        size limit,   and there was no room for any bytes to be written.
        [EFBIG]
        The file is a regular file, nbyte is greater than 0, and the starting
        position is greater than or equal to the offset maximum established in
        the open file description associated with fildes.
        [EINTR]
        The write operation was terminated due to the receipt of a signal, and
        no data was transferred.
        [EIO]
        The process is a member of a background process group attempting to
        write to its controlling terminal, TOSTOP is set, the process is
        neither ignoring nor blocking SIGTTOU, and the process group of the
        process is orphaned. This error may also be returned under
        implementation-defined conditions.
        [ENOSPC]
        There was no free space remaining on the device containing the file.
        [EPIPE]
        An attempt is made to write to a pipe or FIFO that is not open for
        reading by any process, or that only has one end open. A SIGPIPE signal
        shall also be sent to the thread.
        [ERANGE]
        [XSR]  The transfer request size was outside the range supported by the
        STREAMS file associated with fildes.

    The write() function shall fail if:

        [EAGAIN] or [EWOULDBLOCK]
        The file descriptor is for a socket, is marked O_NONBLOCK, and write
        would block.
        [ECONNRESET]
        A write was attempted on a socket that is not connected.
        [EPIPE]
        A write was attempted on a socket that is shut down for writing, or is
        no longer connected. In the latter case, if the socket is of type
        SOCK_STREAM, a SIGPIPE signal shall also be sent to the thread.

    The write() and [XSI]  pwrite()  functions may fail if:

        [EINVAL]
        [XSR]  The STREAM or multiplexer referenced by fildes is linked
        (directly or indirectly) downstream from a multiplexer.
         [EIO]
        A physical I/O error has occurred.
        [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.
        [ENXIO]
        A request was made of a nonexistent device, or the request was outside
        the capabilities of the device.
        [ENXIO]
        [XSR]  A hangup occurred on the STREAM being written to.
        [XSR]  A write to a STREAMS file may fail if an error message has been
        received at the STREAM head. In this case, errno is set to the value
        included in the error message.

    The write() function may fail if:

        [EACCES]
        A write was attempted on a socket and the calling process does not have
        appropriate privileges.

        [ENETDOWN]
        A write was attempted on a socket and the local network interface used
        to reach the destination is down.

        [ENETUNREACH]
        A write was attempted on a socket and no route to the network is present.

    [XSI]  The pwrite() function shall fail and the file pointer remain
    unchanged if:

        [EINVAL]
        [XSI]  The offset argument is invalid. The value is negative.

        [ESPIPE]
        [XSI]  fildes is associated with a pipe or FIFO.


*/

specification
void write_socket_spec(CallContext context, FileDescId socket, VoidTPtr buf, SizeT nbyte)
{
    File* file=getFile_FileDescId(socket);

    pre
    {
        if (file!=NULL)
        {
            /*
             * [Function works with sockets only]
             *
             */
            REQ("", "Function works with sockets only", file->kind==Socket);
        }

        /*
        * If nbyte is zero and the file is not a regular file, the results are
        * unspecified.
        */
        REQ("app.write.03", "Data shall not be empty", nbyte!=0);

        /*
        * If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-
        * defined.
        */
        REQ("app.write.13",  "The value of nbyte shall be less than {SSIZE_MAX}",
            nbyte <= (SizeT)max_SSizeT);


        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct WriteSocketCall WriteSocketCall = {};

void onWriteSocket( CallContext context, FileDescId socket, VoidTPtr buf, SizeT nbyte)
{
    startBlockedCall(context, create_WriteSocketCall(socket, buf, nbyte));
}


void write_socket_model( CallContext context, WriteSocketReturnType* write_ret_val, WriteSocketCall* blocked_call)
{
    CByteArray* data = readCByteArray_VoidTPtr(blocked_call->buf, write_ret_val->funcRes);

    /*
     * Upon successful completion, write() [XSI]  and pwrite() shall return the
     * number of bytes actually written to the file associated with fildes.
     */
    /*
     * If some data can be written without blocking the thread, write() shall write
     * what it can and return the number of bytes written.
     */
    /*
     * If write() is interrupted by a signal after it successfully writes some data,
     * it shall return the number of bytes written.
     */
    IMPLEMENT_REQ("write.40.01;write.20.02.02;write.12");

    send_model(context, blocked_call->socket, data, write_ret_val->funcRes, NULL);

}

void onWriteSocketReturn( CallContext context, WriteSocketReturnType* write_ret_val)
{
    WriteSocketCall* blocked_call=finishBlockedCall(context);

    if (write_ret_val->funcRes!=-1)
    {
        write_socket_model(context, write_ret_val, blocked_call);
    }
}

specification typedef struct WriteSocketReturnType WriteSocketReturnType = {};

reaction WriteSocketReturnType* write_socket_return(void)
{
    post
    {
        CallContext           context=write_socket_return->context;
        ProcessState*         ps=getProcessState_CallContext(context);
        WriteSocketCall*      wrCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId            socket = wrCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(wrCall->socket);


        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_WRITE, "write.40.03", write_socket_return->funcRes==-1, *(write_socket_return->errno))

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EAGAIN] The O_NONBLOCK flag is set for the file descriptor and the thread
         * would be delayed in the write() operation.
         */
        /*
         * The write() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is for a socket, is marked
         * O_NONBLOCK, and write would block.
         */
        /*
         * Otherwise, it shall return -1 and set errno to [EAGAIN].
         */
        ERROR_SHALL3(POSIX_WRITE, EAGAIN, "write.41.01;write.42.01;write.20.02.03", isO_NONBLOCKset(socket) )

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EBADF] The fildes argument is not a valid file descriptor open for writing.
         */
        ERROR_SHALL(POSIX_WRITE, EBADF, "write.41.02", getFileDescriptor(socket)==NULL)


        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EINTR] The write operation was terminated due to the receipt of a signal,
         * and no data was transferred.
         */
        /*
         * If write() is interrupted by a signal before it writes any data, it shall
         * return -1 with errno set to [EINTR].
         */
        ERROR_SHALL(POSIX_WRITE, EINTR, "write.41.05;write.11", TODO_ERR(EINTR) )

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EIO] The process is a member of a background process group attempting to
         * write to its controlling terminal, TOSTOP is set, the process is neither
         * ignoring nor blocking SIGTTOU, and the process group of the process is orphaned.
         * This error may also be returned under implementation-defined conditions.
         */
        ERROR_SHALL(POSIX_WRITE, EIO, "write.41.06", TODO_ERR(EIO) )

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [ENOSPC] There was no free space remaining on the device containing the file.
         */
        ERROR_SHALL(POSIX_WRITE, ENOSPC, "write.41.07", TODO_ERR(ENOSPC) )


        /*
         * The write() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is for a socket, is marked
         * O_NONBLOCK, and write would block.
         */
        ERROR_SHALL3(POSIX_WRITE, EWOULDBLOCK, "write.42.01", isO_NONBLOCKset(socket) )

        /*
         * The write() function shall fail if:
         *
         * [ECONNRESET] A write was attempted on a socket that is not connected.
         */
        ERROR_SHALL(POSIX_WRITE, ECONNRESET, "write.42.02", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)==Socket &&
            getSocketFileDescriptor_peer_addr(desc)==NULL)

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [EIO] A physical I/O error has occurred.
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, EIO, "write.43.02", "Can not check IO errors")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENOBUFS, "write.43.03", "Can not check insufficient resources case")

        /*
         * The write() function may fail if:
         *
         * [EACCES] A write was attempted on a socket and the calling process does not
         * have appropriate privileges.
         */
        ERROR_MAY(POSIX_WRITE, EACCES, "write.44.01", TODO_ERR(EACCES))

        /*
         * The write() function may fail if:
         *
         * [ENETDOWN] A write was attempted on a socket and the local network interface
         * used to reach the destination is down.
         */
        ERROR_MAY(POSIX_WRITE, ENETDOWN, "write.44.02", TODO_ERR(ENETDOWN))

        /*
         * The write() function may fail if:
         *
         * [ENETUNREACH] A write was attempted on a socket and no route to the network
         * is present.
         */
        ERROR_MAY(POSIX_WRITE, ENETUNREACH, "write.44.03", TODO_ERR(ENETUNREACH))

        ERROR_END()


        /*
         * If a write() requests that more bytes be written than there is room for (for
         * example, [XSI]  the process' file size limit or the physical end of a
         * medium), only as many bytes as there is room for shall be written.
         */
        REQ("write.09", "", TODO_REQ());

        /*
         * If the request would cause the file size to exceed the soft file size limit for
         * the process and there is no room for any bytes to be written, the request shall
         * fail and the implementation shall generate the SIGXFSZ signal for the thread.
         */
        REQ("write.10", "", TODO_REQ());

        /*
         * This number shall never be greater than nbyte.
         */
        REQ("write.40.02", "Returned value shall not be greater than nbyte", write_socket_return->funcRes<=wrCall->nbyte);

        if (getBlockMode_FileDescId(socket)==Blocking)
        {

            /*
             * When attempting to write to a file descriptor (other than a pipe or FIFO) that
             * supports non-blocking writes and cannot accept the data immediately:
             *
             * If the O_NONBLOCK flag is clear, write() shall block the calling thread until
             * the data can be accepted.
             */
            /*
             * If the O_NONBLOCK flag is clear, a write request may cause the thread to block,
             * but on normal completion it shall return nbyte.
             */
            REQ("write.20.01;write.18", "Function shall return nbyte", write_socket_return->funcRes==wrCall->nbyte);
        }

        /*
         * If the O_NONBLOCK flag is set, write() shall not block the thread.
         */
        REQ("write.20.02.01", "", TODO_REQ());


        /*
         * Upon successful completion, where nbyte is greater than 0, write() shall mark
         * for update the st_ctime and st_mtime fields of the file,
         */
        REQ("write.22.01", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    pread, read - read from a file

SYNOPSIS

    #include <unistd.h>
    ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
    ssize_t read(int fildes, void *buf, size_t nbyte);

DESCRIPTION

    The read() function shall attempt to read nbyte bytes from the file
    associated with the open file descriptor, fildes, into the buffer pointed
    to by buf. The behavior of multiple concurrent reads on the same pipe,
    FIFO, or terminal device is unspecified.

    Before any action described below is taken, and if nbyte is zero, the
    read() function may detect and return errors as described below. In the
    absence of errors, or if error detection is not performed, the read()
    function shall return zero and have no other results.

    On files that support seeking (for example, a regular file), the read()
    shall start at a position in the file given by the file offset associated
    with fildes. The file offset shall be incremented by the number of bytes
    actually read.

    Files that do not support seeking-for example, terminals-always read from
    the current position. The value of a file offset associated with such a
    file is undefined.

    No data transfer shall occur past the current end-of-file. If the starting
    position is at or after the end-of-file, 0 shall be returned. If the file
    refers to a device special file, the result of subsequent read() requests
    is implementation-defined.

    If the value of nbyte is greater than {SSIZE_MAX}, the result is
    implementation-defined.

    When attempting to read from an empty pipe or FIFO:

        * If no process has the pipe open for writing, read() shall return 0
          to indicate end-of-file.
        * If some process has the pipe open for writing and O_NONBLOCK is set,
          read() shall return -1 and set errno to [EAGAIN].
        * If some process has the pipe open for writing and O_NONBLOCK is
          clear, read() shall block the calling thread until some data is
          written or the pipe is closed by all processes that had the pipe open
          for writing.

    When attempting to read a file (other than a pipe or FIFO) that supports
    non-blocking reads and has no data currently available:

        * If O_NONBLOCK is set, read() shall return -1 and set errno to
          [EAGAIN].
        * If O_NONBLOCK is clear, read() shall block the calling thread until
          some data becomes available.
        * The use of the O_NONBLOCK flag has no effect if there is some data
           available.

    The read() function reads data previously written to a file . If any
    portion of a regular file prior to the end-of-file has not been written,
    read() shall return bytes with value 0. For example, lseek() allows the
    file offset to be set beyond the end of existing data in the file. If data
    is later written at this point, subsequent reads in the gap between the
    previous end of data and the newly written data shall return bytes with
    value 0 until data is written into the gap.

    Upon successful completion, where nbyte is greater than 0, read() shall
    mark for update the st_atime field of the file, and shall return the number
    of bytes read. This number shall never be greater than nbyte. The value
    returned may be less than nbyte if the number of bytes left in the file is
    less than nbyte, if the read() request was interrupted by a signal, or if
    the file is a pipe or FIFO or special file and has fewer than nbyte bytes
    immediately available for reading. For example, a read() from a file
    associated with a terminal may return one typed line of data.

    If a read() is interrupted by a signal before it reads any data, it shall
    return -1 with errno set to [EINTR].

    If a read() is interrupted by a signal after it has successfully read some
    data, it shall return the number of bytes read.

    For regular files, no data transfer shall occur past the offset maximum
    established in the open file description associated with fildes.

    If fildes refers to a socket, read() shall be equivalent to recv() with
    no flags set.

    If the O_DSYNC and O_RSYNC bits have been set, read
    I/O operations on the file descriptor shall complete as defined by
    synchronized I/O data integrity completion. If the O_SYNC and O_RSYNC bits
    have been set, read I/O operations on the file descriptor shall complete as
    defined by synchronized I/O file integrity completion.

    If fildes refers to a shared memory object, the result
    of the read() function is unspecified.

    If fildes refers to a typed memory object, the result of the read()
    function is unspecified.

    A read() from a STREAMS file can read data in three different modes:
    byte-stream mode, message-nondiscard mode, and message-discard mode. The
    default shall be byte-stream mode. This can be changed using the I_SRDOPT
    ioctl() request, and can be tested with I_GRDOPT ioctl(). In byte-stream
    mode, read() shall retrieve data from the STREAM until as many bytes as
    were requested are transferred, or until there is no more data to be
    retrieved. Byte-stream mode ignores message boundaries.

    In STREAMS message-nondiscard mode, read() shall retrieve data until as
    many bytes as were requested are transferred, or until a message boundary
    is reached. If read() does not retrieve all the data in a message, the
    remaining data shall be left on the STREAM, and can be retrieved by the
    next read() call. Message-discard mode also retrieves data until as many
    bytes as were requested are transferred, or a message boundary is reached.
    However, unread data remaining in a message after the read() returns shall
    be discarded, and shall not be available for a subsequent read(), getmsg(),
    or getpmsg() call.

    How read() handles zero-byte STREAMS messages is determined by the current
    read mode setting. In byte-stream mode, read() shall accept data until it
    has read nbyte bytes, or until there is no more data to read, or until a
    zero-byte message block is encountered. The read() function shall then
    return the number of bytes read, and place the zero-byte message back on
    the STREAM to be retrieved by the next read(), getmsg(), or getpmsg(). In
    message-nondiscard mode or message-discard mode, a zero-byte message shall
    return 0 and the message shall be removed from the STREAM. When a zero-byte
    message is read as the first message on a STREAM, the message shall be
    removed from the STREAM and 0 shall be returned, regardless of the read
    mode.

    A read() from a STREAMS file shall return the data in the message at the
    front of the STREAM head read queue, regardless of the priority band of
    the message.

    By default, STREAMs are in control-normal mode, in which a read() from a
    STREAMS file can only process messages that contain a data part but do not
    contain a control part. The read() shall fail if a message containing a
    control part is encountered at the STREAM head. This default action can be
    changed by placing the STREAM in either control-data mode or
    control-discard mode with the I_SRDOPT ioctl() command. In control-data
    mode, read() shall convert any control part to data and pass it to the
    application before passing any data part originally present in the same
    message. In control-discard mode, read() shall discard message control
    parts but return to the process any data part in the message.

    In addition, read() shall fail if the STREAM head had processed an
    asynchronous error before the call. In this case, the value of errno shall
    not reflect the result of read(), but reflect the prior error. If a hangup
    occurs on the STREAM being read, read() shall continue to operate normally
    until the STREAM head read queue is empty. Thereafter, it shall return 0.

    The pread() function shall be equivalent to read(), except that it shall
    read from a given position in the file without changing the file pointer.
    The first three arguments to pread() are the same as read() with the
    addition of a fourth argument offset for the desired position inside the
    file. An attempt to perform a pread() on a file that is incapable of
    seeking shall result in an error.

RETURN VALUE

    Upon successful completion, read() and pread() shall return a non-negative
    integer indicating the number of bytes actually read. Otherwise,
    the functions shall return -1 and set errno to indicate the error.

ERRORS

    The read() and pread()functions shall fail if:

    [EAGAIN]
        The O_NONBLOCK flag is set for the file descriptor and the thread would
        be delayed.

    [EBADF]
        The fildes argument is not a valid file descriptor open for reading.

    [EBADMSG]
        The file is a STREAM file that is set to
        control-normal mode and the message waiting to be read includes a
        control part.

    [EINTR]
        The read operation was terminated due to the receipt of a signal, and
        no data was transferred.

    [EINVAL]
        The STREAM or multiplexer referenced by fildes is linked (directly or
        indirectly) downstream from a multiplexer.

    [EIO]
        The process is a member of a background process attempting to read from
        its controlling terminal, the process is ignoring or blocking the
        SIGTTIN signal, or the process group is orphaned. This error may also
        be generated for implementation-defined reasons.

    [EISDIR]
        The fildes argument refers to a directory and the implementation does
        not allow the directory to be read using read() or pread(). The
        readdir() function should be used instead.

    [EOVERFLOW]
        The file is a regular file, nbyte is greater than 0, the starting
        position is before the end-of-file, and the starting position is
        greater than or equal to the offset maximum established in the open
        file description associated with fildes.

    The read() function shall fail if:

    [EAGAIN] or [EWOULDBLOCK]
        The file descriptor is for a socket, is marked O_NONBLOCK, and no data
        is waiting to be received.

    [ECONNRESET]
        A read was attempted on a socket and the connection was forcibly
        closed by its peer.

    [ENOTCONN]
        A read was attempted on a socket that is not connected.

    [ETIMEDOUT]
        A read was attempted on a socket and a transmission timeout occurred.

    The read() and pread() functions may fail if:

    [EIO]
        A physical I/O error has occurred.

    [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

    [ENOMEM]
        Insufficient memory was available to fulfill the request.

    [ENXIO]
        A request was made of a nonexistent device, or the request was outside
        the capabilities of the device.

    The pread() function shall fail, and the file pointer shall remain
    unchanged, if:

    [EINVAL]
        The offset argument is invalid. The value is negative.

    [EOVERFLOW]
        The file is a regular file and an attempt was made to read at or beyond
        the offset maximum associated with the file.

    [ENXIO]
        A request was outside the capabilities of the device.

    [ESPIPE]
        A fildes is associated with a pipe or FIFO.
*/

specification
void read_socket_spec(CallContext context, FileDescId socket, SizeT nbyte)
{
    File* file=getFile_FileDescId(socket);

    pre
    {
        if (file!=NULL)
        {
            /*
             * [Function works with sockets only]
             *
             */
            REQ("", "Function works with sockets only", file->kind==Socket);
        }

        /*
        * If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-
        * defined.
        */
        REQ("app.read.51", "The value of nbyte shall be less than {SSIZE_MAX}",
            nbyte <= (SizeT)max_SSizeT);


        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct ReadSocketCall ReadSocketCall = {};

void onReadSocket( CallContext context, FileDescId socket,  SizeT nbyte)
{
    startBlockedCall(context, create_ReadSocketCall(socket, NULL_VoidTPtr, nbyte));
}



void read_socket_model( CallContext context, ReadSocketReturnType* read_ret_val, ReadSocketCall* blocked_call)
{
    recv_model(context,  blocked_call->socket, &read_ret_val->notModifiedData, &read_ret_val->notUDPModifiedData,
        false, read_ret_val->funcRes,  read_ret_val->returnedData);

}

void onReadSocketReturn( CallContext context, ReadSocketReturnType* read_ret_val)
{
    ReadSocketCall* blocked_call=finishBlockedCall(context);

    if (read_ret_val->funcRes!=-1)
    {
        read_socket_model(context, read_ret_val, blocked_call);
    }
}

specification typedef struct ReadSocketReturnType ReadSocketReturnType = {};

reaction ReadSocketReturnType* read_socket_return(void)
{
    post
    {
        CallContext           context=read_socket_return->context;
        ProcessState*         ps=getProcessState_CallContext(context);
        ReadSocketCall*       rCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId            socket = rCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(rCall->socket);

        /*
         * Otherwise, the functions shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_READ, "read.41.02", read_socket_return->funcRes==-1, *(read_socket_return->errno))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EAGAIN] The O_NONBLOCK flag is set for the file descriptor and the thread
         * would be delayed.
         */
        /*
         * The read() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is for a socket, is marked
         * O_NONBLOCK, and no data is waiting to be received.
         */
        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
         */
        ERROR_SHALL3(POSIX_READ, EAGAIN, "read.42.01;read.43.01;read.10.01", isO_NONBLOCKset(socket))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EBADF] The fildes argument is not a valid file descriptor open for reading.
         */
        ERROR_SHALL(POSIX_READ, EBADF, "read.42.02", getFileDescriptor(socket)==NULL)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EINTR] The read operation was terminated due to the receipt of a signal, and
         * no data was transferred.
         */
        /*
         * If a read() is interrupted by a signal before it reads any data, it shall
         * return -1 with errno set to [EINTR].
         */
        ERROR_SHALL(POSIX_READ, EINTR, "read.42.04;read.15", TODO_ERR(EINTR) )

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EIO] The process is a member of a background process attempting to read from
         * its controlling terminal, the process is ignoring or blocking the SIGTTIN
         * signal, or the process group is orphaned. This error may also be generated for
         * implementation-defined reasons.
         */
        ERROR_SHALL(POSIX_READ, EIO, "read.42.06", TODO_ERR(EIO) )

        /*
         * The read() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is for a socket, is marked
         * O_NONBLOCK, and no data is waiting to be received.
         */
        ERROR_SHALL3(POSIX_READ, EWOULDBLOCK, "read.43.01", isO_NONBLOCKset(socket))

        /*
         * The read() function shall fail if:
         *
         * [ECONNRESET] A read was attempted on a socket and the connection was forcibly
         * closed by its peer.
         */
        ERROR_SHALL(POSIX_READ, ECONNRESET, "read.43.02", TODO_ERR(ECONNRESET) )

        /*
         * The read() function shall fail if:
         *
         * [ENOTCONN] A read was attempted on a socket that is not connected.
         */
         ERROR_SHALL(POSIX_READ, ENOTCONN, "read.43.03", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)==Socket &&
            getSocketFileDescriptor_peer_addr(desc)==NULL)

        /*
         * The read() function shall fail if:
         *
         * [ETIMEDOUT] A read was attempted on a socket and a transmission timeout
         * occurred.
         */
        ERROR_SHALL(POSIX_READ, ETIMEDOUT, "read.43.04", TODO_ERR(ETIMEDOUT) )

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [EIO] A physical I/O error has occurred.
         */
        ERROR_UNCHECKABLE(POSIX_READ, EIO, "read.44.01", "Can not check IO errors")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENOBUFS, "read.44.02", "Can not check insufficient resources case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOMEM] Insufficient memory was available to fulfill the request.
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENOMEM, "read.44.03", "Can not check insufficient memory case")

        ERROR_END()


        /*
         * Upon successful completion, read() [XSI]  and pread() shall return a non-
         * negative integer indicating the number of bytes actually read.
         */
        REQ("read.41.01", "Function shall return non negative value", read_socket_return->funcRes>=0);

        /*
         * and shall return the number of bytes read. This number shall never be greater
         * than nbyte.
         */
        REQ("read.13.02", "Returned value shall be less than nbyte", read_socket_return->funcRes<=rCall->nbyte);

        if (desc->type==SUT_SOCK_STREAM)
        {
            SocketFileDescriptor* peer = getFileDescriptor_Peer(context, socket, desc);

            /*
             * The read() function shall attempt to read nbyte bytes from the file associated
             * with the open file descriptor, fildes, into the buffer pointed to by buf.
             */
            /*
             * The read() function reads data previously written to a file.
             */
            REQ("read.01;read.52", "TCP read data shall be valid",
                compare_CByteArrays(read_socket_return->returnedData, read_socket_return->notModifiedData,
                read_socket_return->funcRes));

        }
        else if (desc->type==SUT_SOCK_DGRAM)
        {
            /*
             * The read() function shall attempt to read nbyte bytes from the file associated
             * with the open file descriptor, fildes, into the buffer pointed to by buf.
             */
            /*
             * The read() function reads data previously written to a file.
             */
            REQ("read.01;read.52", "UDP read data shall be valid", findCByteArrayInList(read_socket_return->notUDPModifiedData,
                read_socket_return->returnedData, read_socket_return->funcRes)!=-1);
        }
        else
        {
            REQ("", "Specification for other protocols not implemented yet", false);
        }

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * The use of the O_NONBLOCK flag has no effect if there is some data available.
         */
        REQ("read.10.03", "", TODO_REQ());

        /*
         * Upon successful completion, where nbyte is greater than 0, read() shall mark
         * for update the st_atime field of the file
         */
        REQ("read.13.01", "", TODO_REQ());


        /*
         * The value returned may be less than nbyte
         *
         * if the number of bytes left in the file is less than nbyte,
         */
        REQ("read.14.01", "", TODO_REQ());

        /*
         * The value returned may be less than nbyte
         *
         * if the read() request was interrupted by a signal,
         */
        REQ("read.14.02", "", TODO_REQ());

        /*
         * If a read() is interrupted by a signal after it has successfully read some
         * data, it shall return the number of bytes read.
         */
        REQ("read.16", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    writev - write a vector

SYNOPSIS

    [XSI]  #include <sys/uio.h>
    ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);

DESCRIPTION

    The writev() function shall be equivalent to write(), except as described
    below.The writev() function shall gather output data from the iovcnt
    buffers specified by the members of the iov array: iov[0], iov[1], ...,
    iov[iovcnt-1]. The iovcnt argument is valid if greater than 0 and less than
    or equal to {IOV_MAX}, as defined in <limits.h>.

    Each iovec entry specifies the base address and length of an area in memory
    from which data should be written. The writev() function shall always write
    a complete area before proceeding to the next.

    If fildes refers to a regular file and all of the iov_len members in the
    array pointed to by iov are 0, writev() shall return 0 and have no other
    effect. For other file types, the behavior is unspecified.

    If the sum of the iov_len values is greater than {SSIZE_MAX}, the operation
    shall fail and no data shall be transferred.

RETURN VALUE

    Upon successful completion, writev() shall return the number of bytes
    actually written. Otherwise, it shall return a value of -1, the
    file-pointer shall remain unchanged, and errno shall be set to indicate an
    error.

ERRORS

    Refer to write().

    In addition, the writev() function shall fail if:

        [EINVAL]
        The sum of the iov_len values in the iov array would overflow an
        ssize_t.

    The writev() function may fail and set errno to:

        [EINVAL]
        The iovcnt argument was less than or equal to 0, or greater than
        {IOV_MAX}.
*/

specification
void writev_socket_spec(CallContext context,  FileDescId  socket, List *iov)
{
    File* file=getFile_FileDescId(socket);

    pre
    {
        if (file!=NULL)
        {
            /*
             * [Function works with sockets only]
             *
             */
            REQ("", "Function works with sockets only", file->kind==Socket);
        }

        /*
        * For other file types, the behavior is unspecified.
        */
        REQ("app.writev.05", "Data length shall be non zero", sumIOVecMembers(iov)!=0);

        return true;
    }
    post
    {
        return true;
    }
}


specification typedef struct WritevSocketCall WritevSocketCall = {};

void onWritevSocket( CallContext context, FileDescId socket,  List* iov)
{
    startBlockedCall(context, create_WritevSocketCall(socket, iov));
}


void writev_socket_model( CallContext context, WritevSocketReturnType* writev_ret_val, WritevSocketCall* blocked_call)
{
    SocketFileDescriptor* desc=getDescriptor_FileDescId(blocked_call->socket);
    List* iov=blocked_call->iov;

    /*
    * Upon successful completion, writev() shall return the number of bytes actually
    * written.
    */
    /*
     * If write() is interrupted by a signal after it successfully writes some data,
     * it shall return the number of bytes written.
     */
    /*
     * If some data can be written without blocking the thread, write() shall write
     * what it can and return the number of bytes written.
     */
    IMPLEMENT_REQ("writev.07.01;writev.pwrite.12;writev.pwrite.20.02.02");


    /*
    * The writev() function shall gather output data from the iovcnt buffers
    * specified by the members of the iov array: iov[0], iov[1], ..., iov[iovcnt-1].
    *
    */
    IMPLEMENT_REQ("writev.01");

    /*
    * Each iovec entry specifies the base address and length of an area in memory
    * from which data should be written. The writev() function shall always write a
    * complete area before proceeding to the next.
    */
    IMPLEMENT_REQ("writev.03");

    send_model(context, blocked_call->socket, concatAllDataInIOvecList(iov, writev_ret_val->funcRes), writev_ret_val->funcRes, NULL);

}



void onWritevSocketReturn( CallContext context, WritevSocketReturnType* writev_ret_val)
{
    WritevSocketCall* blocked_call=finishBlockedCall(context);

    if (writev_ret_val->funcRes!=-1)
    {
        writev_socket_model(context, writev_ret_val, blocked_call);
    }
}

specification typedef struct WritevSocketReturnType WritevSocketReturnType = {};

reaction WritevSocketReturnType* writev_socket_return(void)
{
    post
    {
        CallContext           context=writev_socket_return->context;
        ProcessState*         ps=getProcessState_CallContext(context);
        WritevSocketCall*     wCall= findBlockedCall(@getBlockedCalls(), context);
        FileDescId            socket = wCall->socket;
        SocketFileDescriptor* desc=getDescriptor_FileDescId(wCall->socket);
        List* iov=wCall->iov;

        /*
        * Otherwise, it shall return a value of -1,
        */
        /*
        * and errno shall be set to indicate an error.
        */
        ERROR_BEGIN(POSIX_WRITEV, "writev.07.02;writev.07.04", writev_socket_return->funcRes==-1, *(writev_socket_return->errno))

        /*
        * In addition, the writev() function shall fail if:
        *
        * [EINVAL] The sum of the iov_len values in the iov array would overflow an
        * ssize_t.
        */
        /*
        * If the sum of the iov_len values is greater than {SSIZE_MAX}, the operation
        * shall fail and no data shall be transferred.
        */
        ERROR_SHALL(POSIX_WRITEV, EINVAL, "writev.08.01;writev.06", sumIOVecMembers(iov)>(SSizeT)max_SSizeT)

        /*
        * The writev() function may fail and set errno to:
        *
        * [EINVAL] The iovcnt argument was less than or equal to 0, or greater than {
        * IOV_MAX}.
        */
        /*
        * The iovcnt argument is valid if greater than 0 and less than or equal to {
        * IOV_MAX}, as defined in <limits.h>.
        */
        ERROR_MAY(POSIX_WRITEV, EINVAL, "writev.09.01;writev.02", size_List(iov)==0 ||
            (getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_UNKNOWN
            &&
            getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_NO_LIMIT
            &&
            size_List(iov) > getSystemConfigurationValue(context, SUT_SC_IOV_MAX)))


        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EAGAIN] The O_NONBLOCK flag is set for the file descriptor and the thread
         * would be delayed in the write() operation.
         */
        /*
         * The write() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is for a socket, is marked
         * O_NONBLOCK, and write would block.
         */
        /*
         * Otherwise, write() shall transfer no data and return -1 with errno set to
         * [EAGAIN].
         */
        /*
         * Otherwise, it shall return -1 and set errno to [EAGAIN].
         */
        /*
         * If the O_NONBLOCK flag is set, write() shall not block the thread.
         */
        ERROR_SHALL3(POSIX_WRITEV, EAGAIN, "writev.pwrite.41.01;writev.42.01;writev.pwrite.19.02.02;writev.pwrite.20.02.03;writev.pwrite.20.02.01",
            isO_NONBLOCKset(socket))

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EBADF] The fildes argument is not a valid file descriptor open for writing.
         */
        ERROR_SHALL(POSIX_WRITEV, EBADF, "writev.pwrite.41.02", getFileDescriptor(socket)==NULL)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EFBIG] An attempt was made to write a file that exceeds the implementation-
         * defined maximum file size [XSI]  or the process' file size limit,
         * and there was no room for any bytes to be written.
         */
        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EFBIG] The file is a regular file, nbyte is greater than 0, and the starting
         * position is greater than or equal to the offset maximum established in the open
         * file description associated with fildes.
         */
        ERROR_SHALL(POSIX_WRITEV, EFBIG, "writev.pwrite.41.03;writev.pwrite.41.04",
                       TODO_ERR(EFBIG)
                    )

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EINTR] The write operation was terminated due to the receipt of a signal,
         * and no data was transferred.
         */
        /*
         * If write() is interrupted by a signal before it writes any data, it shall
         * return -1 with errno set to [EINTR].
         */
        ERROR_SHALL(POSIX_WRITEV, EINTR, "writev.pwrite.41.05;writev.pwrite.11", TODO_ERR(EINTR) )

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EIO] The process is a member of a background process group attempting to
         * write to its controlling terminal, TOSTOP is set, the process is neither
         * ignoring nor blocking SIGTTOU, and the process group of the process is orphaned.
         * This error may also be returned under implementation-defined conditions.
         */
        ERROR_SHALL(POSIX_WRITEV, EIO, "writev.pwrite.41.06", TODO_ERR(EIO) )

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [ENOSPC] There was no free space remaining on the device containing the file.
         */
        ERROR_SHALL(POSIX_WRITEV, ENOSPC, "writev.pwrite.41.07", TODO_ERR(ENOSPC) )


        /*
         * The write() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is for a socket, is marked
         * O_NONBLOCK, and write would block.
         */
        ERROR_SHALL3(POSIX_WRITEV, EWOULDBLOCK, "writev.42.01", isO_NONBLOCKset(socket))

        /*
         * The write() function shall fail if:
         *
         * [ECONNRESET] A write was attempted on a socket that is not connected.
         */
         ERROR_SHALL(POSIX_WRITEV, ECONNRESET, "writev.42.02", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)==Socket &&
            getSocketFileDescriptor_peer_addr(desc)==NULL)

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [EIO] A physical I/O error has occurred.
         */
        ERROR_UNCHECKABLE(POSIX_WRITEV, EIO, "writev.pwrite.43.02", "Can not check IO errors")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_WRITEV, ENOBUFS, "writev.pwrite.43.03", "Can not check insufficient resources case")

        /*
         * The write() function may fail if:
         *
         * [EACCES] A write was attempted on a socket and the calling process does not
         * have appropriate privileges.
         */
        ERROR_MAY(POSIX_WRITEV, EACCES, "writev.44.01", TODO_ERR(EACCES))

        /*
         * The write() function may fail if:
         *
         * [ENETDOWN] A write was attempted on a socket and the local network interface
         * used to reach the destination is down.
         */
        ERROR_MAY(POSIX_WRITEV, ENETDOWN, "writev.44.02", TODO_ERR(ENETDOWN))

        /*
         * The write() function may fail if:
         *
         * [ENETUNREACH] A write was attempted on a socket and no route to the network
         * is present.
         */
        ERROR_MAY(POSIX_WRITEV, ENETUNREACH, "writev.44.03", TODO_ERR(ENETUNREACH))

        ERROR_END()


        /*
        * This number shall never be greater than nbyte.
        *
        */
        REQ("write.40.02", "Function shall return number not greater than number of bytes to write",
            writev_socket_return->funcRes<=sumIOVecMembers(iov));


        if (getBlockMode_FileDescId(socket)==Blocking)
        {
            /*
             * If the O_NONBLOCK flag is clear, a write request may cause the thread to block,
             * but on normal completion it shall return nbyte.
             */
            REQ("writev.pwrite.18", "Function shall return nbyte", writev_socket_return->funcRes==sumIOVecMembers(iov));
        }

        /*
         * If a write() requests that more bytes be written than there is room for (for
         * example, [XSI]  the process' file size limit or the physical end of a
         * medium), only as many bytes as there is room for shall be written.
         */
        REQ("writev.pwrite.09", "", TODO_REQ());

        /*
         * If the request would cause the file size to exceed the soft file size limit for
         * the process and there is no room for any bytes to be written, the request shall
         * fail and the implementation shall generate the SIGXFSZ signal for the thread.
         */
        REQ("writev.pwrite.10", "", TODO_REQ());


        /*
         * Upon successful completion, where nbyte is greater than 0, write() shall mark
         * for update the st_ctime and st_mtime fields of the file,
         */
        REQ("writev.pwrite.22.01", "", TODO_REQ());


        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    readv - read a vector

SYNOPSIS

    [XSI]  #include <sys/uio.h>
    ssize_t readv(int fildes, const struct iovec *iov, int iovcnt);

DESCRIPTION

    The readv() function shall be equivalent to read(), except as described
    below. The readv() function shall place the input data into the iovcnt
    buffers specified by the members of the iov array: iov[0], iov[1], ...,
    iov[ iovcnt-1]. The iovcnt argument is valid if greater than 0 and less
    than or equal to {IOV_MAX}.

    Each iovec entry specifies the base address and length of an area in
    memory where data should be placed. The readv() function shall always fill
    an area completely before proceeding to the next.

    Upon successful completion, readv() shall mark for update the st_atime
    field of the file.

RETURN VALUE

    Refer to read().

ERRORS

    Refer to read().

    In addition, the readv() function shall fail if:

        [EINVAL]
        The sum of the iov_len values in the iov array overflowed an ssize_t.

    The readv() function may fail if:

        [EINVAL]
        The iovcnt argument was less than or equal to 0, or greater than {IOV_MAX}.

*/

specification
void readv_socket_spec(CallContext context, FileDescId socket, List* iov)
{
    File* file=getFile_FileDescId(socket);

    pre
    {
       if (file!=NULL)
        {
            /*
             * [Function works with sockets only]
             *
             */
            REQ("", "Function works with sockets only", file->kind==Socket);
        }



        return true;
    }
    post
    {
        return true;
    }
}

specification typedef struct ReadvSocketCall ReadvSocketCall = {};


void onReadvSocket( CallContext context, FileDescId socket,  List* iov)
{
    startBlockedCall(context, create_ReadvSocketCall(socket, iov));
}

specification typedef struct ReadvSocketReturnType ReadvSocketReturnType = {};

void readv_socket_model( CallContext context, ReadvSocketReturnType* readv_ret_val, ReadvSocketCall* blocked_call)
{
    recv_model(context,  blocked_call->socket, &readv_ret_val->notModifiedData, &readv_ret_val->notUDPModifiedData, false,
        readv_ret_val->funcRes,  concatAllDataInIOvecList(blocked_call->iov, readv_ret_val->funcRes));
}

void onReadvSocketReturn( CallContext context, ReadvSocketReturnType* readv_ret_val)
{
    ReadvSocketCall* blocked_call=finishBlockedCall(context);

    if (readv_ret_val->funcRes!=-1)
    {
        readv_socket_model(context, readv_ret_val, blocked_call);
    }
}

reaction ReadvSocketReturnType* readv_socket_return(void)
{
    post
    {
        CallContext           context = readv_socket_return->context;
        ProcessState*         ps      = getProcessState_CallContext(context);
        ReadvSocketCall*      rCall   = findBlockedCall(@getBlockedCalls(), context);
        FileDescId            socket  = rCall->socket;
        SocketFileDescriptor* desc    = getDescriptor_FileDescId(rCall->socket);
        List*                 iov     = rCall->iov;

        /*
         * Otherwise, the functions shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_READV, "readv.pread.41.02", readv_socket_return->funcRes==-1, *(readv_socket_return->errno))

        /*
        * In addition, the readv() function shall fail if:
        *
        * [EINVAL] The sum of the iov_len values in the iov array overflowed an ssize_t.
        */
        ERROR_SHALL(POSIX_READV, EINVAL, "readv.06.01", sumIOVecMembers(iov)>(SSizeT)max_SSizeT)

        /*
        * The readv() function may fail if:
        *
        * [EINVAL] The iovcnt argument was less than or equal to 0, or greater than {
        * IOV_MAX}.
        */
        /*
        * The iovcnt argument is valid if greater than 0 and less than or equal to {
        * IOV_MAX}.
        */
        ERROR_MAY(POSIX_READV, EINVAL, "readv.07.01;app.readv.02", size_List(iov)==0 ||
            (getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_UNKNOWN
            &&
            getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_NO_LIMIT
            &&
            size_List(iov) > getSystemConfigurationValue(context, SUT_SC_IOV_MAX)))


        /*
         *
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EAGAIN] The O_NONBLOCK flag is
         * set for the file descriptor and the thread would be delayed.
         */
        /*
         * The read() function shall
         * fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is
         * for a socket, is marked O_NONBLOCK, and no data is waiting to be received.
         */
        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
         */
        ERROR_SHALL3(POSIX_READV, EAGAIN, "readv.pread.42.01;readv.45.01;readv.pread.10.01",isO_NONBLOCKset(socket))

        /*
         *
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EBADF] The fildes argument is not a valid file descriptor open for reading.
         */
        ERROR_SHALL(POSIX_READV, EBADF, "readv.pread.42.02", getFileDescriptor(socket)==NULL)


        /*
         *
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EINTR] The read operation was terminated due to the receipt of a signal, and
         * no data was transferred.
         */
        /*
         * If a read() is interrupted by a signal before it reads any data, it shall
         * return -1 with errno set to [EINTR].
         */
        ERROR_SHALL(POSIX_READV, EINTR, "readv.pread.42.04;readv.pread.15", TODO_ERR(EINTR) )

        /*
         *
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EIO] The process is a member of a background process attempting to read from
         * its controlling terminal, the process is ignoring or blocking the SIGTTIN
         * signal, or the process group is orphaned. This error may also be generated for
         * implementation-defined reasons.
         */
        ERROR_SHALL(POSIX_READV, EIO, "readv.pread.42.06", TODO_ERR(EIO) )


        /*
         * The read() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK] The file descriptor is
         * for a socket, is marked O_NONBLOCK, and no data is waiting to be received.
         */
        ERROR_SHALL3(POSIX_READV, EWOULDBLOCK, "readv.45.01", isO_NONBLOCKset(socket))

        /*
         * The read() function shall fail if:
         *
         * [ECONNRESET] A read was attempted on a socket and the connection was forcibly
         * closed by its peer.
         */
        ERROR_SHALL(POSIX_READV, ECONNRESET, "readv.45.02", TODO_ERR(ECONNRESET) )

        /*
         * The read() function shall fail if:
         *
         * [ENOTCONN] A read was attempted on a socket that is not connected.
         */
         ERROR_SHALL(POSIX_READV, ENOTCONN, "readv.45.03", getFileDescriptor(socket)!=NULL && getFileKind_FileDescId(socket)==Socket &&
            getSocketFileDescriptor_peer_addr(desc)==NULL)

        /*
         * The read() function shall fail if:
         *
         * [ETIMEDOUT] A read was attempted on a socket and a transmission timeout
         * occurred.
         */
        ERROR_SHALL(POSIX_READV, ETIMEDOUT, "readv.45.04", TODO_ERR(ETIMEDOUT) )

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [EIO] A physical I/O error has
         * occurred.
         */
        ERROR_UNCHECKABLE(POSIX_READV, EIO, "readv.pread.44.01", "Can not check IO errors")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOBUFS] Insufficient resources were available in the system to perform the
         * operation.
         */
        ERROR_UNCHECKABLE(POSIX_READV, ENOBUFS, "readv.pread.44.02", "Can not check insufficient resources case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOMEM] Insufficient memory was available to fulfill the request.
         */
        ERROR_UNCHECKABLE(POSIX_READV, ENOMEM, "readv.pread.44.03", "Can not check insufficient memory case")

        ERROR_END()


        /*
         * Upon successful completion, read() [XSI]  and pread() shall return a non-
         * negative integer indicating the number of bytes actually read.
         *
         */
        REQ("readv.pread.41.01", "Return value shall be non negative", readv_socket_return->funcRes >=0);

         /*
         * and shall return the number of bytes read. This number shall never be greater
         * than nbyte.
         */
        /*
         * If a read() is interrupted by a signal after it has successfully read some
         * data, it shall return the number of bytes read.
         */
        REQ("readv.pread.13.02;readv.pread.16", "Number of bytes read shall never be greater than number of bytes requested",
            readv_socket_return->funcRes<=sumIOVecMembers(iov));


        if (desc->type==SUT_SOCK_STREAM)
        {
            SocketFileDescriptor* peer = getFileDescriptor_Peer(context, socket, desc);
            IntT i;
            SizeT sumLen=0;

            for (i=0;i<size_List(iov);i++)
            {
                IOvec* curVec=get_List(iov, i);
                SizeT  curLen;
                CByteArray* curData;


                if (sumLen>=readv_socket_return->funcRes)
                {
                    break;
                }

                if (sumLen+curVec->iov_len<=readv_socket_return->funcRes)
                {
                    curLen=curVec->iov_len;
                }
                else
                {
                    curLen=readv_socket_return->funcRes-sumLen;
                }

                curData = readCByteArray_VoidTPtr(curVec->iov_base, curLen);


                /*
                * The readv() function shall place the input data into the iovcnt buffers
                * specified by the members of the iov array: iov[0], iov[1], ..., iov[ iovcnt-1].
                *
                */
                /*
                * Each iovec entry specifies the base address and length of an area in memory
                * where data should be placed.
                *
                */
                /*
                * The readv() function shall always fill an area completely before proceeding
                * to the next.
                *
                */
                /*
                * The read() function reads data previously written to a file.
                *
                */
                REQ("readv.01;readv.03;readv.04;readv.pread.52", "TCP read data shall be valid",
                    compare_CByteArrays_Offset(curData, readv_socket_return->notModifiedData,
                    curLen, sumLen));

                sumLen+=curVec->iov_len;
            }

        }
        else if (desc->type==SUT_SOCK_DGRAM)
        {

            /*
            * The readv() function shall place the input data into the iovcnt buffers
            * specified by the members of the iov array: iov[0], iov[1], ..., iov[ iovcnt-1].
            *
            */
            /*
            * Each iovec entry specifies the base address and length of an area in memory
            * where data should be placed.
            *
            */
            /*
            * The readv() function shall always fill an area completely before proceeding
            * to the next.
            *
            */
            /*
            * The read() function reads data previously written to a file.
            *
            */
            REQ("readv.01;readv.03;readv.04;readv.pread.52", "UDP read data shall be valid",
                findCByteArrayInList(readv_socket_return->notUDPModifiedData,
                concatAllDataInIOvecList(iov, readv_socket_return->funcRes), readv_socket_return->funcRes)!=-1);
        }
        else
        {
            REQ("", "Specification for other protocols not implemented yet", false);
        }


        /*
        * Upon successful completion, readv() shall mark for update the st_atime field of
        * the file.
        */
        REQ("readv.05", "", TODO_REQ());

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * The use of the O_NONBLOCK flag has no effect if there is some data available.
         */
        REQ("readv.pread.10.03", "", TODO_REQ());


        /*
         * The value returned may be less than nbyte
         *
         * if the number of bytes left in the file is less than nbyte,
         */
        REQ("readv.pread.14.01", "", TODO_REQ());

        /*
         * The value returned may be less than nbyte
         *
         * if the read() request was interrupted by a signal,
         */
        REQ("readv.pread.14.02", "", TODO_REQ());



        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    sockio -- socket ioctl commands

SYNOPSIS

    #include <sys/ioctl.h>
    #include <sys/socket.h>
    #include <net/if.h>
    #include <netinet/in.h>

    int ioctl(int sockfd, int request, void * argp);


DESCRIPTION

    Socket ioctl() commands are a subset of the ioctl() calls, which can
    perform a variety of functions on sockets. sockfd shall be an open file
    descriptor referring to a socket (see the socket() or accept() functions).

    Socket ioctl() commands apply to the underlying network interfaces, and
    affect the entire system, not just the file descriptor used to issue the
    ioctl().

    The following values for request are accepted:


    SIOCGIFCONF (Deprecated)

        Get the interface configuration list for the system.
        Note: The SIOCGIFCONF interface is superceded by the if_nameindex()
        family of functions (see ISO POSIX (2003)). A future version of this
        specification may withdraw this value for request. argp shall point to
        a ifconf structure, as described in <net/if.h>. Before calling, the
        caller shall set the ifc_ifcu.ifcu_req field to point to an array of
        ifreq structures, and set ifc_len to the size in bytes of this
        allocated array. Upon return, ifc_len will contain the size in bytes of
        the array which was actually used.If it is the same as the length upon
        calling, the caller should assume that the array was too small and try
        again with a larger array.
        On success, SIOCGIFCONF shall return a nonnegative value.
        Rationale: Historical UNIX systems disagree on the meaning of the return value.

    SIOCGIFFLAGS

        Get the interface flags for the indicated interface.argp shall point to
        a ifreq structure. Before calling, the caller should fill in the
        ifr_name field with the interface name, and upon return, the
        ifr_ifru.ifru_flags field is set with the interface flags.

    SIOCGIFADDR

        Get the interface address for the given interface.argp shall point to a
        ifreq structure. Before calling, the caller should fill in the ifr_name
        field with the interface name, and upon return, the ifr_ifru.ifru_addr
        field is set with the interface address.

    SIOCGIFBRDADDR

        Get the interface broadcast address for the given interface.argp shall
        point to a ifreq structure. Before calling, the caller should fill in
        the ifr_name field with the interface name, and upon return, the
        ifr_ifru.ifru_broadcast field is set with the interface broadcast
        address.

    SIOCGIFNETMASK

        Get the network mask for the given interface.argp shall point to a
        ifreq structure. Before calling, the caller should fill in the ifr_name
        field with the interface name, and upon return, the
        ifr_ifru.ifru_netmask field is set with the network mask.

    SIOCGIFMTU

        Get the Maximum Transmission Unit (MTU) size for the given
        interface.argp shall point to a ifreq structure. Before calling, the
        caller should fill in the ifr_name field with the interface name, and
        upon return, the ifr_ifru.ifru_mtu field is set with the MTU.

    FIONREAD

        Get the amount of queued unread data in the receive buffer.argp shall
        point to an integer where the result is to be placed.

    Note: Some implementations may also support the use of FIONREAD on other
    types of file descriptor. However, the LSB only specifies its behavior for
    a socket related file descriptor.


RETURN VALUE

    On success, if request is SIOCGIFCONF, a non-negative integer shall be
    returned.If request is not SIOCGIFCONF, on success 0 is returned.On error,
    -1 is returned and the global variable errno is set appropriately.

ERRORS

    [EBADF]
    sockfd is not a valid descriptor.

    [EFAULT]
    argp references an inaccessible memory area.

    [ENOTTY]
    The specified request does not apply to the kind of object that the
    descriptor sockfd references.

    [EINVAL]
    Either request or argp is invalid.

    [ENOTCONN]
    The operation is only defined on a connected socket, but the socket wasn't
    connected.

*/

specification typedef struct IfReqT IfReqT = {};
specification typedef struct IfConfT IfConfT = {};

specification typedef struct SockIoReturnType SockIoReturnType = {};


specification
SockIoReturnType* sockio_spec(CallContext context, FileDescId socket, IntT request, IfConfT* argp, ErrorCode* errno)
{

    pre
    {
        return true;
    }
    post
    {
        SocketFileDescriptor* desc=getDescriptor_FileDescId(socket);

        /*
         * On error, -1 is returned and the global variable errno is set appropriately.
         */
        ERROR_BEGIN(LSB_SOCKIO, "sockio.05.03", sockio_spec->funcRes==-1, *errno)

        /*
        * [EBADF] sockfd is not a valid descriptor.
        */
        ERROR_SHALL(LSB_SOCKIO, EBADF, "sockio.06.01", desc==NULL)

        /*
        * [EFAULT] argp references an inaccessible memory area.
        */
        ERROR_UNCHECKABLE(LSB_SOCKIO, EFAULT, "sockio.06.02", "This area is always valid according to model")

        /*
        * [ENOTTY] The specified request does not apply to the kind of object that the
        * descriptor sockfd references.
        */
        ERROR_SHALL(LSB_SOCKIO, ENOTTY, "sockio.06.03", TODO_ERR(ENOTTY) )

        /*
        * [EINVAL] Either request or argp is invalid.
        */
        ERROR_SHALL(LSB_SOCKIO, EINVAL, "sockio.06.04", request!=SUT_SIOCGIFCONF &&
            request!=SUT_SIOCGIFFLAGS && request != SUT_SIOCGIFADDR    && request!= SUT_SIOCGIFNETMASK    &&
            request != SUT_SIOCGIFBRDADDR && request != SUT_SIOCGIFMTU && request != SUT_FIONREAD)

        /*
        * [ENOTCONN] The operation is only defined on a connected socket, but the socket
        * wasn't connected.
        */
        ERROR_SHALL(LSB_SOCKIO, ENOTCONN, "sockio.06.05", desc!=NULL && getFileKind_FileDescId(socket)==Socket &&
        desc->peer_addr == NULL)

        ERROR_END()

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFCONF (Deprecated)
         *
         * Get the interface configuration list for the system.
         */
        REQ("sockio.04.01.01", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFCONF (Deprecated)
         *
         * Upon return, ifc_len will contain the size in bytes of the array which was
         * actually used.
         */
        REQ("sockio.04.01.04", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFCONF (Deprecated)
         *
         * If it is the same as the length upon calling, the caller should assume that the
         * array was too small and try again with a larger array.
         */
        REQ("sockio.04.01.05", "", TODO_REQ());

        if (request==SUT_SIOCGIFCONF)
        {
            /*
             * The following values for request are accepted:
             *
             * SIOCGIFCONF (Deprecated)
             *
             * On success, SIOCGIFCONF shall return a nonnegative value.
             */
            /*
             * On success, if request is SIOCGIFCONF, a non-negative integer shall be returned.
             */
            REQ("sockio.04.01.06;sockio.05.01", "Function shall return non negative value", sockio_spec->funcRes >= 0);
        }

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFFLAGS
         *
         * Get the interface flags for the indicated interface.
         */
        REQ("sockio.04.02.01", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFFLAGS
         *
         * and upon return, the ifr_ifru.ifru_flags field is set with the interface flags.
         */
        REQ("sockio.04.02.04", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFADDR
         *
         * Get the interface address for the given interface.
         */
        REQ("sockio.04.03.01", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFADDR
         *
         * and upon return, the ifr_ifru.ifru_addr field is set with the interface address.
         */
        REQ("sockio.04.03.04", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFBRDADDR
         *
         * Get the interface broadcast address for the given interface.
         */
        REQ("sockio.04.04.01", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFBRDADDR
         *
         * and upon return, the ifr_ifru.ifru_broadcast field is set with the interface
         * broadcast address.
         */
        REQ("sockio.04.04.04", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFNETMASK
         *
         * Get the network mask for the given interface.
         */
        REQ("sockio.04.05.01", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFNETMASK
         *
         * and upon return, the ifr_ifru.ifru_netmask field is set with the network mask.
         */
        REQ("sockio.04.05.04", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFMTU
         *
         * Get the Maximum Transmission Unit (MTU) size for the given interface.
         */
        REQ("sockio.04.06.01", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * SIOCGIFMTU
         *
         * and upon return, the ifr_ifru.ifru_mtu field is set with the MTU.
         */
        REQ("sockio.04.06.04", "", TODO_REQ());

        /*
         * The following values for request are accepted:
         *
         * FIONREAD
         *
         * Get the amount of queued unread data in the receive buffer.
         */
        REQ("sockio.04.07.01", "", TODO_REQ());

        if (request!=SUT_SIOCGIFCONF)
        {
            /*
             * If request is not SIOCGIFCONF, on success 0 is returned.
             */
            REQ("sockio.05.02", "Function shall return zero", sockio_spec->funcRes==0);
        }




        return true;
    }
}

/********************************************************************/
/**                         Construction                           **/
/********************************************************************/

ConnectCall * create_ConnectCall(
    FileDescId socket,
    SockaddrT* address,
    SockaddrT* peer_addr
)
{
    return create(&type_ConnectCall,
        socket,
        address,
        peer_addr
        );
}

ConnectReturnType * create_ConnectReturnType(
    CallContext context,
    IntT functionResult,
    ErrorCode* errno,
    SockaddrT* peerAddr
)
{
    return create(&type_ConnectReturnType,
        context,
        functionResult,
        errno,
        peerAddr);
}

AcceptCall * create_AcceptCall(
    FileDescId socket
)
{
    return create(&type_AcceptCall,
        socket);
}

AcceptReturnType * create_AcceptReturnType(
    CallContext context,
    SockaddrT*  acceptedAddr,
    FileDescId  funcRes,
    ErrorCode*  errno
)
{
    return create(&type_AcceptReturnType,
        context,
        acceptedAddr,
        funcRes,
        errno);
}

SendCall * create_SendCall(
    FileDescId socket,
    CByteArray* data,
    bool MSG_EOR_FLAG,
    bool MSG_OOB_FLAG,
    SockaddrT* dest_addr
)
{
    return create(&type_SendCall,
        socket,
        data,
        MSG_EOR_FLAG,
        MSG_OOB_FLAG,
        dest_addr
        );
}

SendReturnType * create_SendReturnType(
    CallContext context,
    SSizeT  funcRes,
    ErrorCode*  errno
)
{
    return create(&type_SendReturnType,
        context,
        funcRes,
        errno);
}

RecvCall * create_RecvCall(
    FileDescId socket,
    SizeT length,
    bool peek,
    bool oob,
    bool waitall,
    bool from,
    CByteArray* oldData
)
{
    return create(&type_RecvCall,
        socket,
        length,
        peek,
        oob,
        waitall,
        from,
        oldData
        );

}

RecvmsgCall * create_RecvmsgCall(
    FileDescId socket,
    SocketMsgHdr* msg,
    bool peek,
    bool oob,
    bool waitall
)
{
    return create(&type_RecvmsgCall,
        socket,
        msg,
        peek,
        oob,
        waitall
        );

}

RecvReturnType * create_RecvReturnType(
    CallContext context,
    SSizeT      retVal,
    CByteArray* returnedData,
    SockaddrT*  addr,
    ErrorCode*  errno,
    CByteArray* notModifiedData,
    List*       notUDPModifiedData
)
{
    return create(&type_RecvReturnType,
        context,
        retVal,
        returnedData,
        addr,
        errno,
        notModifiedData,
        notUDPModifiedData
        );

}

RecvmsgReturnType * create_RecvmsgReturnType(
    CallContext context,
    SSizeT      retVal,
    ErrorCode*  errno,
    SocketMsgHdr* msg,
    SSizeT      msgDataLength,
    List*       notModifiedSentMessages
)
{
    return create(&type_RecvmsgReturnType,
        context,
        retVal,
        errno,
        msg,
        msgDataLength,
        notModifiedSentMessages
        );

}

GetPeerNameReturnType * create_GetPeerNameReturnType(
    IntT funcRes,
    SockaddrT* address
)
{
    return create(&type_GetPeerNameReturnType,
        funcRes,
        address);
}

GetSockNameReturnType * create_GetSockNameReturnType(
    IntT funcRes,
    SockaddrT* address
)
{
    return create(&type_GetSockNameReturnType,
        funcRes,
        address);
}

SocketPairReturnType * create_SocketPairReturnType(
    IntT funcRes,
    FileDescId sock1,
    FileDescId sock2
)
{
    return create(&type_SocketPairReturnType,
        funcRes,
        sock1,
        sock2);
}

GetSockOptReturnType * create_GetSockOptReturnType(
    IntT funcRes,
    SocketOptionValue* val
)
{
    return create(&type_GetSockOptReturnType,
        funcRes,
        val);
}

SendMsgCall * create_SendMsgCall(
    FileDescId socket,
    SocketMsgHdr* msg,
    bool flag_MSG_EOR,
    bool flag_MSG_OOB
)
{
    return create(&type_SendMsgCall,
        socket,
        msg,
        flag_MSG_EOR,
        flag_MSG_OOB
        );

}

SendMsgReturnType * create_SendMsgReturnType(
    CallContext context,
    SSizeT  funcRes,
    ErrorCode*  errno
)
{
    return create(&type_SendMsgReturnType,
        context,
        funcRes,
        errno);
}

WriteSocketCall * create_WriteSocketCall(
    FileDescId socket,
    VoidTPtr buf,
    SizeT nbyte
)
{
    return create(&type_WriteSocketCall,
        socket,
        buf,
        nbyte);
}

WriteSocketReturnType * create_WriteSocketReturnType(
    CallContext context,
    SSizeT  funcRes,
    ErrorCode*  errno
)
{
    return create(&type_WriteSocketReturnType,
        context,
        funcRes,
        errno);
}

ReadSocketCall * create_ReadSocketCall(
    FileDescId socket,
    VoidTPtr   buf,
    SizeT      nbyte
)
{
    return create(&type_ReadSocketCall,
        socket,
        buf,
        nbyte);
}

ReadSocketReturnType * create_ReadSocketReturnType(
    CallContext context,
    SSizeT      funcRes,
    ErrorCode*  errno,
    CByteArray* notModifiedData,
    List*       notUDPModifiedData,
    CByteArray* returnedData
)
{
    return create(&type_ReadSocketReturnType,
        context,
        funcRes,
        errno,
        notModifiedData,
        notUDPModifiedData,
        returnedData);

}

WritevSocketCall * create_WritevSocketCall(
    FileDescId socket,
    List* iov
)
{
    return create(&type_WritevSocketCall,
        socket,
        iov);
}

WritevSocketReturnType * create_WritevSocketReturnType(
    CallContext context,
    SSizeT  funcRes,
    ErrorCode*  errno
)
{
    return create(&type_WritevSocketReturnType,
        context,
        funcRes,
        errno);
}

ReadvSocketCall * create_ReadvSocketCall(
    FileDescId socket,
    List* iov
)
{
    return create(&type_ReadvSocketCall,
        socket,
        iov);
}

ReadvSocketReturnType * create_ReadvSocketReturnType(
    CallContext context,
    SSizeT  funcRes,
    ErrorCode*  errno,
    CByteArray* notModifiedData,
    List*       notUDPModifiedData
)
{
    return create(&type_ReadvSocketReturnType,
        context,
        funcRes,
        errno,
        notModifiedData,
        notUDPModifiedData
        );

}


IfReqT* create_IfReqT(CString* ifr_name)
{
    IfReqT* res = create(&type_IfReqT, create_CByteArray((ByteT*)toCharArray_CString(ifr_name), SUT_IF_NAMESIZE), NULL);

    return res;

}

IfConfT* create_IfConfT()
{
    return create(&type_IfConfT, create_List(&type_IfReqT));
}

SockIoReturnType* create_SockIoReturnType(IntT funcRes,
                                          IfConfT* argpRes,
                                          IntT FIONREADRes
                                          )
{
    return create(&type_SockIoReturnType, funcRes, argpRes, FIONREADRes);
}

IfReqT* create_IfReqT_Full(CByteArray* ifrn_name, CByteArray* ifru_data)
{
    return create(&type_IfReqT, ifrn_name, ifru_data);
}

/********************************************************************/
/**                      SocketMsgHdr Type                         **/
/********************************************************************/

specification typedef struct SocketMsgHdr SocketMsgHdr = {};

SocketMsgHdr* create_SocketMsgHdr(SockaddrT* msg_name, List* msg_iov, IntT msg_control_level, IntT msg_control_type, CByteArray* msg_control_data, UIntT  msg_flags)
{
    return create(&type_SocketMsgHdr, msg_name, msg_iov, create_CmsgHdrData(msg_control_level, msg_control_type,
        msg_control_data), msg_flags);

}

specification typedef struct CmsgHdrData CmsgHdrData = {};

CmsgHdrData* create_CmsgHdrData(IntT  cmsg_level, IntT  cmsg_type, CByteArray* data)
{
    return create(&type_CmsgHdrData, cmsg_level, cmsg_type, data);
}


/********************************************************************/
/**                      SockaddrT Functions                       **/
/********************************************************************/
specification typedef struct SockaddrT SockaddrT = {};

SockaddrT * create_SockaddrT(
    SaFamilyT   family,
    Object      *addr
)
{
    return create(&type_SockaddrT,
        family,
        addr);
}

SaFamilyT getSockaddr_Family(SockaddrT* addr)
{
    return addr->family;
}

void      setSockaddr_Family(SockaddrT* addr, SaFamilyT val)
{
    addr->family = val;
}

SockaddrT *   create_SockaddrT_Unspec()
{
    return create(&type_SockaddrT, SUT_AF_UNSPEC, NULL);
}

bool equals_SockaddrT(SockaddrT* s1, SockaddrT* s2)
{
    if (s1==NULL && s2!=NULL)
    {
        return false;
    }

    if (s1!=NULL && s2==NULL)
    {
        return false;
    }

    if (s1==NULL && s2==NULL)
    {
        return true;
    }


    if (s1->family!=s2->family)
    {
        return false;
    }
    if (s1->family==SUT_AF_INET)
    {
        InetAddrT* addr1=(InetAddrT*)s1->addr;
        InetAddrT* addr2=(InetAddrT*)s2->addr;

        return equals(addr1, addr2);
    }
    else if (s1->family==SUT_AF_INET6)
    {
        Inet6AddrT* addr1=(Inet6AddrT*)s1->addr;
        Inet6AddrT* addr2=(Inet6AddrT*)s2->addr;

        return equals(addr1, addr2);
    }
    else if (s1->family==SUT_AF_UNIX)
    {
        UnixAddrT* addr1=(UnixAddrT*)s1->addr;
        UnixAddrT* addr2=(UnixAddrT*)s2->addr;

        return equals(addr1, addr2);
    }

    return true;
}


/********************************************************************/
/**                      InetAddrT Functions                       **/
/********************************************************************/

specification typedef struct InetAddrT InetAddrT = {};

InetAddrT * create_InetAddrT(
    UShortT       sin_port,
    UInt32T       sin_addr
)
{
    return create(&type_InetAddrT, sin_port, sin_addr);
}

SockaddrT *create_SockaddrT_Inet(UShortT sin_port, UInt32T sin_addr)
{
    InetAddrT*  addr = create_InetAddrT(sin_port, sin_addr);
    SockaddrT * res = create_SockaddrT( SUT_AF_INET, addr);

    return res;
}


UShortT       getInetSocket_sin_port(SockaddrT* addr)
{
    InetAddrT* inaddr;
    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET, "Addres family shall be AF_INET");

    inaddr = addr->addr;

    return inaddr->sin_port;
}

void          setInetSocket_sin_port(SockaddrT* addr, UShortT val)
{
    InetAddrT* inaddr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET, "Addres family shall be AF_INET");

    inaddr = addr->addr;

    inaddr->sin_port = val;
}

UInt32T       getInetSocket_sin_addr(SockaddrT* addr)
{
    InetAddrT* inaddr;
    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET, "Addres family shall be AF_INET");

    inaddr = addr->addr;

    return inaddr->sin_addr;
}

void          setInetSocket_sin_addr(SockaddrT* addr, UInt32T val)
{
    InetAddrT* inaddr;
    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET, "Addres family shall be AF_INET");

    inaddr = addr->addr;

    inaddr->sin_addr = val;
}


/********************************************************************/
/**                      Inet6AddrT Functions                       **/
/********************************************************************/
static String* to_string_Inet6AddrT_( struct Inet6AddrT *obj )
{
    String * res;
    int i;

    res = format_String("port:0x%x; ", ntohs_model(obj->sin6_port));
    res = concat_String(res, format_String("flowinfo:0x%x; ", obj->sin6_flowinfo) );
    res = concat_String(res, format_String("csope_id:0x%x; ", obj->sin6_scope_id) );
    res = concat_String(res, create_String("addr: ") );

    for(i=0;i<INET6_ADDRESSLEN;i++)
        res = concat_String(res, format_String("%.2x ", obj->u6_addr8[i]) );

    return res;
}


specification typedef struct Inet6AddrT Inet6AddrT = {
    .to_string = (ToString)to_string_Inet6AddrT_
};


Inet6AddrT * create_Inet6AddrT(
    UInt16T         sin6_port,
    UInt32T         sin6_flowinfo,
    UInt8T          u6_addr8[INET6_ADDRESSLEN],
    UInt32T         sin6_scope_id
)
{
    return create(&type_Inet6AddrT,
        sin6_port,
        sin6_flowinfo,
        u6_addr8,
        sin6_scope_id
        );

}

SockaddrT *create_SockaddrT_Inet6(UInt16T sin6_port, UInt32T sin6_flowinfo,
                                  UInt8T u6_addr8[], UInt32T sin6_scope_id)
{
    Inet6AddrT*  addr = create_Inet6AddrT( sin6_port, sin6_flowinfo, u6_addr8, sin6_scope_id);
    SockaddrT *  res = create_SockaddrT( SUT_AF_INET6, addr);

    return res;
}


UInt16T       getInet6Socket_sin6_port(SockaddrT* addr)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    return in6addr->sin6_port;
}


void          setInet6Socket_sin6_port(SockaddrT* addr, UInt16T val)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    in6addr->sin6_port = val;
}

UInt32T       getInet6Socket_sin6_flowinfo(SockaddrT* addr)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    return in6addr->sin6_flowinfo;
}

void          setInet6Socket_sin6_flowinfo(SockaddrT* addr, UInt32T val)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    in6addr->sin6_flowinfo = val;
}

UInt8T*       getInet6Socket_u6_addr8(SockaddrT* addr)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    return in6addr->u6_addr8;
}

void          setInet6Socket_u6_addr8(SockaddrT* addr, UInt8T val[])
{
    Inet6AddrT* in6addr;
    IntT i;
    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    for (i=0;i<INET6_ADDRESSLEN;i++)
    {
        in6addr->u6_addr8[i] = val[i];
    }
}

UInt32T       getInet6Socket_sin6_scope_id(SockaddrT* addr)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    return in6addr->sin6_scope_id;

}

void          setInet6Socket_sin6_scope_id(SockaddrT* addr, UInt32T val)
{
    Inet6AddrT* in6addr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_INET6, "Addres family shall be AF_INET6");

    in6addr = addr->addr;

    in6addr->sin6_scope_id = val;
}


/********************************************************************/
/**                      UnixAddrT Functions                       **/
/********************************************************************/

specification typedef struct UnixAddrT UnixAddrT = {};

SockaddrT *create_SockaddrT_Unix(CString* path)
{
    UnixAddrT* addr;
    if (length_CString(path)>MAX_UNIX_ADDRESS_SIZE)
    {
        return NULL;
    }
    addr = create(&type_UnixAddrT, path);

    return create(&type_SockaddrT, SUT_AF_UNIX, addr);
}

CString*      getUnixSocket_path(SockaddrT* addr)
{
    UnixAddrT* unAddr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_UNIX, "Addres family shall be AF_UNIX");

    unAddr = addr->addr;

    return unAddr->path;
}

void          setUnixSocket_path(SockaddrT* addr, CString* val)
{
    UnixAddrT* unAddr;

    assertion(addr != NULL, "Socket address shall be not NULL");
    assertion(addr->family == SUT_AF_UNIX, "Addres family shall be AF_UNIX");

    unAddr = addr->addr;

    unAddr->path = val;
}



/********************************************************************/
/**                      SocketFileDescriptor Functions            **/
/********************************************************************/
specification typedef struct SocketFileDescriptor  SocketFileDescriptor = {};


SocketOptionValue* create_SocketOptionValue_Int(IntT val)
{
    return create(&type_SocketOptionValue, val, NULL, NULL, true, false);
}

SocketOptionValue* create_SocketOptionValue_Linger(IntT l_onoff, IntT l_linger)
{
    return create(&type_SocketOptionValue, -1, create(&type_SocketLinger, l_onoff, l_linger), NULL, false, true);
}

SocketOptionValue* create_SocketOptionValue_Time(TimeT sec, LongT usec)
{
    return create(&type_SocketOptionValue, -1, NULL, create_TimeValTObj(sec, usec), false, false);
}


SocketFileDescriptor* create_SocketDescriptor(SocketDomain  domain, SocketType type, SocketProtocol protocol)
{
    Map* options=create_Map(&type_IntTObj, &type_SocketOptionValue);

    put_Map(options, create_IntTObj(SUT_SO_DEBUG), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_OOBINLINE), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_LINGER), create_SocketOptionValue_Linger(-1, -1));
    put_Map(options, create_IntTObj(SUT_SO_REUSEADDR), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_DONTROUTE), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_BROADCAST), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_SNDBUF), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_RCVBUF), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_KEEPALIVE), create_SocketOptionValue_Int(-1));

    put_Map(options, create_IntTObj(SUT_SO_RCVLOWAT), create_SocketOptionValue_Int(0));
    put_Map(options, create_IntTObj(SUT_SO_SNDLOWAT), create_SocketOptionValue_Int(-1));
    put_Map(options, create_IntTObj(SUT_SO_RCVTIMEO), create_SocketOptionValue_Time(0, 0));
    put_Map(options, create_IntTObj(SUT_SO_SNDTIMEO), create_SocketOptionValue_Time(0, 0));


    return create(&type_SocketFileDescriptor, NULL, NULL, domain, type, protocol, create_CByteArray(NULL, 0), false, false, -1, create_FileDescId(0, 0, 0), create_List(&type_FileDescIdObj), WrongFileDescId, SUT_NO_SHUT, options, create_List(&type_CByteArray), create_List(&type_SocketMsgHdr), WrongFileDescId);
}


FileDescriptor*  create_DefaultSocketFileDescriptor(FileDescId  sock_id, SocketFileDescriptor* desc )
{

    return create_FileDescriptor(
        sock_id,
        WrongFileId,
        NULL,
        ReadWrite,
        Blocking,
        Socket,
        false,
        -1,
        false,
        false,
        desc
        );
}


FileDescriptor*  register_SocketDesriptor(FileDescId  sock_id, SocketFileDescriptor* desc )
{
    ProcessState* process;
    FileDescriptor* res;

    process = getProcessState_FileDescId( sock_id );
    if (process == NULL)
        return NULL;
    res = create_DefaultSocketFileDescriptor( sock_id, desc);
    put_Map( process->file_descriptors, create_FileDescIdObj(sock_id), res );
    return res;

}


SockaddrT*    getSocketFileDescriptor_addr(SocketFileDescriptor* desc)
{
    return desc->addr;
}


void          setSocketFileDescriptor_addr(SocketFileDescriptor* desc, SockaddrT* val)
{
    desc->addr = val;
}

SockaddrT*    getSocketFileDescriptor_peer_addr(SocketFileDescriptor* desc)
{
    return desc->peer_addr;
}

void          setSocketFileDescriptor_peer_addr(SocketFileDescriptor* desc, SockaddrT* val)
{
    desc->peer_addr = val;
}

SocketDomain  getSocketFileDescriptor_domain(SocketFileDescriptor* desc)
{
    return desc->domain;
}

void          setSocketFileDescriptor_domain(SocketFileDescriptor* desc, SocketDomain val)
{
    desc->domain = val;
}

SocketType    getSocketFileDescriptor_type(SocketFileDescriptor* desc)
{
    return desc->type;
}

void          setSocketFileDescriptor_type(SocketFileDescriptor* desc, SocketType val)
{
    desc->type=val;
}

SocketProtocol getSocketFileDescriptor_protocol(SocketFileDescriptor* desc)
{
    return desc->protocol;
}

void           setSocketFileDescriptor_protocol(SocketFileDescriptor* desc, SocketProtocol val)
{
    desc->protocol = val;
}

CByteArray*    getSocketFileDescriptor_data(SocketFileDescriptor* desc)
{
    return desc->data;
}

void           setSocketFileDescriptor_data(SocketFileDescriptor* desc, CByteArray* val)
{
    desc->data = val;
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

void sockaddr_formatter(TSStream *stream, SockaddrT* addr)
{
    VERIFY_TYPE(sockaddr_formatter, &type_SockaddrT, addr);

    writeTypeHeaderTSStream(stream, "sockaddr");

    if(addr == NULL)
    {
        writeInt_TSStream(stream, -1);
    }
    else
    {
        writeInt_TSStream(stream, addr->family);

        if (getSockaddr_Family(addr) == SUT_AF_INET)
        {
            writeUShort_TSStream(stream, getInetSocket_sin_port(addr));
            writeUInt32_TSStream(stream, getInetSocket_sin_addr(addr));
        }
        else if (getSockaddr_Family(addr) == SUT_AF_INET6)
        {
            IntT i=0;
            UInt8T* arr = getInet6Socket_u6_addr8(addr);

            writeUInt16_TSStream(stream, getInet6Socket_sin6_port(addr));
            writeUInt32_TSStream(stream, getInet6Socket_sin6_flowinfo(addr));

            writeInt_TSStream(stream, INET6_ADDRESSLEN);
            for (i=0;i<INET6_ADDRESSLEN;i++)
            {
                writeUInt16_TSStream(stream, arr[i]);
            }

            writeUInt32_TSStream(stream, getInet6Socket_sin6_scope_id(addr));
        }
        else if (getSockaddr_Family(addr) == SUT_AF_UNIX)
        {
            writeCString_TSStream(stream, getUnixSocket_path(addr));
        }
    }
}

void sockoptionval_formatter(TSStream *stream, SocketOptionValue* value)
{
    VERIFY_TYPE(sockoptionval_formatter, &type_SocketOptionValue, value);

    writeTypeHeaderTSStream(stream, "sockoptionval");

    if (value->isInt)
    {
        writeInt_TSStream(stream, 0);
        writeInt_TSStream(stream, value->value);
    }
    else if (value->isLing)
    {
        writeInt_TSStream(stream, 1);
        writeInt_TSStream(stream, value->ling_val->l_onoff);
        writeInt_TSStream(stream, value->ling_val->l_linger);
    }
    else
    {
        writeInt_TSStream(stream, 2);
        writeLong_TSStream(stream, value->time_val->sec);
        writeLong_TSStream(stream, value->time_val->usec);
    }
}


void socketmsg_formatter(TSStream *stream, SocketMsgHdr* value)
{
    IntT i;


    VERIFY_TYPE(socketmsg_formatter, &type_SocketMsgHdr, value);

    writeTypeHeaderTSStream(stream, "socketmsg");

    sockaddr_formatter(stream, value->msg_name);

    writeInt_TSStream(stream, size_List(value->msg_iov));

    for (i=0;i<size_List(value->msg_iov);i++)
    {
        IOvec* curElement=(IOvec*)get_List(value->msg_iov, i);
        writePointer_TSStream(stream, curElement->iov_base);
        writeSize_TSStream(stream, curElement->iov_len);
    }

    writeInt_TSStream(stream, value->msg_control->cmsg_level);
    writeInt_TSStream(stream, value->msg_control->cmsg_type);
    writeCByteArray_TSStream(stream, value->msg_control->data);
    writeUInt_TSStream(stream, value->msg_flags);
}


SockaddrT* readSockaddr_TSStream(TSStream* stream)
{
    IntT socket_family=readInt_TSStream(stream);

    if(socket_family == -1)
    {
        return NULL;
    }
    else
    if (socket_family==SUT_AF_INET)
    {
        UShortT   sin_port = readUShort_TSStream(stream);
        UInt32T   sin_addr = readUInt32_TSStream(stream);

        return create_SockaddrT_Inet(sin_port, sin_addr);
    }
    else if (socket_family==SUT_AF_INET6)
    {
        UInt16T         sin6_port = readUInt16_TSStream(stream);
        UInt32T         sin6_flowinfo = readUInt32_TSStream(stream);
        UInt32T         sin6_scope_id = readUInt32_TSStream(stream);
        UInt8T          u6_addr8[INET6_ADDRESSLEN];
        IntT i;

        for(i=0;i<INET6_ADDRESSLEN;i++)
        {
            u6_addr8[i]=readUInt16_TSStream(stream);
        }

        return create_SockaddrT_Inet6(sin6_port, sin6_flowinfo, u6_addr8, sin6_scope_id);
    }
    else if (socket_family==SUT_AF_UNIX)
    {
        CString* path = readCString_TSStream(stream);

        return create_SockaddrT_Unix(path);
    }
    else
    {
        return create_SockaddrT_Unspec();
    }
}

SocketOptionValue* readSocketOption_TSStream(TSStream* stream)
{
    bool isInt = readInt_TSStream(stream);
    bool isLing = readInt_TSStream(stream);

    if (isInt)
    {
        IntT val=readInt_TSStream(stream);

        return create_SocketOptionValue_Int(val);
    }
    else if (isLing)
    {
        IntT l_onoff = readInt_TSStream(stream);
        IntT l_linger = readInt_TSStream(stream);

        return create_SocketOptionValue_Linger(l_onoff, l_linger);
    }
    else
    {
        TimeT sec = readLong_TSStream(stream);
        LongT usec = readLong_TSStream(stream);

        return create_SocketOptionValue_Time(sec, usec);
    }
}

SocketMsgHdr* readSocketMsgHdr_TSStream(CallContext context, TSStream* stream)
{
    SockaddrT* msg_name;
    SizeT msg_iov_size;
    List* msg_iov;
    IntT msg_control_level;
    IntT msg_control_type;
    CByteArray* msg_control_data;
    UIntT  msg_flags;
    int i=0;

    msg_name = readSockaddr_TSStream(stream);
    msg_iov_size = readSize_TSStream(stream);

    msg_iov=create_List(&type_IOvec);

    for (i=0;i<msg_iov_size;i++)
    {
        VoidTPtr curPtr=readPointer_TSStream(context, stream);
        SizeT   sz=readSize_TSStream(stream);
        append_List(msg_iov, create_IOvec(curPtr, sz));
    }
    msg_control_level = readInt_TSStream(stream);
    msg_control_type =  readInt_TSStream(stream);
    msg_control_data = readCByteArray_TSStream(stream);

    msg_flags = readUInt_TSStream(stream);

    return create_SocketMsgHdr(msg_name, msg_iov, msg_control_level, msg_control_type, msg_control_data, msg_flags);

}

Bool3 isSocketOptionValid(IntT level, FileDescId socket, SocketOption option)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);

    if (level!=SUT_SOL_SOCKET)
    {
        return Unknown_Bool3;
    }

    if (fdesc->shutdown!=SUT_NO_SHUT)
    {
        return True_Bool3;
    }

    if (option!= SUT_SO_DEBUG &&
        option!= SUT_SO_OOBINLINE &&
        option!= SUT_SO_LINGER &&
        option!= SUT_SO_REUSEADDR &&
        option!= SUT_SO_DONTROUTE &&
        option!= SUT_SO_BROADCAST &&
        option!= SUT_SO_SNDBUF &&
        option!= SUT_SO_RCVBUF &&
        option!= SUT_SO_KEEPALIVE &&
        option!= SUT_SO_RCVLOWAT     &&
        option!= SUT_SO_SNDLOWAT    &&
        option!= SUT_SO_RCVTIMEO    &&
        option!= SUT_SO_SNDTIMEO)
    {
        return True_Bool3;
    }

    return False_Bool3;

}

// forward declaration
IntT findMessageInList(List* lst, SocketMsgHdr* mess);

bool compare_CByteArrays_Offset(CByteArray* cur_array, CByteArray* orig_array, SizeT len, SizeT offset)
{
    SizeT i=0;
    for (i=0;i < len && i+offset < size_CByteArray(orig_array) && i < size_CByteArray(cur_array);i++)
    {
        if (byteAt_CByteArray(cur_array, i) != byteAt_CByteArray(orig_array, i+offset))
        {
            return false;
        }
    }

    return true;
}


CByteArray* concatAllDataInIOvecList(List* iov, SizeT readLen)
{
    CByteArray* res=NULL;
    SizeT i;
    SizeT sumLen=0;

    for (i=0;i<size_List(iov);i++)
    {
        IOvec* curVec=get_List(iov, i);
        SizeT  curLen;
        CByteArray* curData;

        if (sumLen>=readLen)
        {
            break;
        }

        if (sumLen+curVec->iov_len<=readLen)
        {
            curLen=curVec->iov_len;
        }
        else
        {
            curLen=readLen-sumLen;
        }

        curData = readCByteArray_VoidTPtr(curVec->iov_base, curLen);

        if (res == NULL)
        {
            res = curData;
        }
        else
        {
            res = concat_CByteArray(res, curData);
        }
    }

    return res;
}


Bool3 isEMSGSIZE(CallContext context,  SocketMsgHdr* msg)
{
    if(getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_UNKNOWN
        &&
        getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_NO_LIMIT
        &&
        size_List(msg->msg_iov) > getSystemConfigurationValue(context, SUT_SC_IOV_MAX))
    {
        return True_Bool3;
    }

    if (size_List(msg->msg_iov)==0)
    {
        return True_Bool3;
    }

    return Unknown_Bool3;

}


ByteT getByteListIOvec(List* iov, SizeT offset, IntT* found)
{
    IntT i;
    SizeT sum=0;

    *found=true;

    for (i=0;i<size_List(iov);i++)
    {
        IOvec* curVec=get_List(iov, i);

        sum = sum + curVec->iov_len;

        if (sum>offset)
        {
            CByteArray* ba=readCByteArray_VoidTPtr(curVec->iov_base, curVec->iov_len);

            return byteAt_CByteArray(ba, offset - (sum - curVec->iov_len));
        }

    }

    *found=false;

    return 0;

}


bool compareListsIOvec(List* iov1, List* iov2, SizeT data_length)
{
    SizeT i=0;
    IntT found1, found2;

    for (i=0;i<data_length;i++)
    {
        ByteT b1 = getByteListIOvec(iov1, i, &found1);
        ByteT b2 = getByteListIOvec(iov2, i, &found2);

        if (!found1 || !found2 || b1!=b2)
        {
            return false;
        }
    }

    return true;

}


IntT findMessageInList(List* lst, SocketMsgHdr* mess)
{
    IntT i=0;

    for (i=0;i<size_List(lst);i++)
    {
        SocketMsgHdr* curMess = get_List(lst, i);

        if (compareListsIOvec(curMess->msg_iov, mess->msg_iov, sumIOVecMembers(mess->msg_iov))
            && compare_CByteArrays(curMess->msg_control->data, mess->msg_control->data, size_CByteArray(mess->msg_control->data)))
        {
            return i;
        }
    }

    return -1;
}


IntT findCByteArrayInList(List* notUDPModifiedData, CByteArray* returnedData, IntT length)
{
    IntT i=0;

    for (i=0;i<size_List(notUDPModifiedData);i++)
    {
        CByteArray* curArr=get_List(notUDPModifiedData, i);
        if (compare_CByteArrays(curArr, returnedData, length))
        {
            return i;
        }
    }
    return -1;

}


SocketFileDescriptor* getFileDescriptor_Sockaddr(CallContext context, SockaddrT* addr, bool peer)
{
    SystemState* sysState=getSystemState_CallContext(context);
    IntT i=0, j=0;

    for (i=0;i<size_Map(sysState->processes);i++)
    {
        ProcessIdObj* curId=key_Map(sysState->processes, i);
        ProcessState* ps=get_Map(sysState->processes, curId);
        for (j=0;j<size_Map(ps->file_descriptors);j++)
        {
            FileDescIdObj*  curDescId=key_Map(ps->file_descriptors, j);
            FileDescriptor* fdesc = get_Map(ps->file_descriptors, curDescId);
            if (getFileKind_FileDescId(*curDescId)==Socket)
            {
                SocketFileDescriptor* sdesc=getDescriptor_FileDescId(*curDescId);
                if (!peer)
                {
                    if (sdesc->addr!=NULL && equals(sdesc->addr, addr))
                    {
                        return sdesc;
                    }
                }
                else
                {
                    if (sdesc->peer_addr!=NULL && equals(sdesc->peer_addr, addr))
                    {
                        return sdesc;
                    }

                }
            }
        }
    }

    return NULL;
}


SocketFileDescriptor* getFileDescriptor_Peer(CallContext context, FileDescId sock, SocketFileDescriptor* desc)
{
    SystemState* sysState=getSystemState_CallContext(context);
    IntT i=0, j=0;

    for (i=0;i<size_Map(sysState->processes);i++)
    {
        ProcessIdObj* curId=key_Map(sysState->processes, i);
        ProcessState* ps=get_Map(sysState->processes, curId);
        for (j=0;j<size_Map(ps->file_descriptors);j++)
        {
            FileDescIdObj*  curDescId=key_Map(ps->file_descriptors, j);
            FileDescriptor* fdesc = get_Map(ps->file_descriptors, curDescId);
            if (getFileKind_FileDescId(*curDescId)==Socket)
            {
                SocketFileDescriptor* sdesc=getDescriptor_FileDescId(*curDescId);
                if (equals(create_FileDescIdObj(sdesc->pairId), create_FileDescIdObj(desc->pairId)) &&
                    !equals(create_FileDescIdObj(desc->pairId), create_FileDescIdObj(WrongFileDescId)) &&
                    !equals(create_FileDescIdObj(sock), create_FileDescIdObj(fdesc->file_desc_id)))
                {
                    return sdesc;
                }
            }
        }
    }

    return NULL;
}


Bool3 isTargetNotListeningOrRefused(SocketFileDescriptor* destDescriptor)
{
    if (destDescriptor == NULL)
    {
        return Unknown_Bool3;
    }

    if (destDescriptor->type==SUT_SOCK_STREAM && !destDescriptor->listening)
    {
        return True_Bool3;
    }

    return Unknown_Bool3;
}
/*

void sockaddr_formatter(TSStream *stream, SockaddrT* addr)
{
    VERIFY_TYPE(sockaddr_formatter, &type_SockaddrT, addr);

    writeTypeHeaderTSStream(stream, "sockaddr");

    if(addr == NULL)
    {
        writeInt_TSStream(stream, -1);
    }
    else
    {
        writeInt_TSStream(stream, addr->family);

        if (getSockaddr_Family(addr) == SUT_AF_INET)
        {
            writeUShort_TSStream(stream, getInetSocket_sin_port(addr));
            writeUInt32_TSStream(stream, getInetSocket_sin_addr(addr));
        }
        else if (getSockaddr_Family(addr) == SUT_AF_INET6)
        {
            IntT i=0;
            UInt8T* arr = getInet6Socket_u6_addr8(addr);

            writeUInt16_TSStream(stream, getInet6Socket_sin6_port(addr));
            writeUInt32_TSStream(stream, getInet6Socket_sin6_flowinfo(addr));

            writeInt_TSStream(stream, INET6_ADDRESSLEN);
            for (i=0;i<INET6_ADDRESSLEN;i++)
            {
                writeUInt16_TSStream(stream, arr[i]);
            }

            writeUInt32_TSStream(stream, getInet6Socket_sin6_scope_id(addr));
        }
        else if (getSockaddr_Family(addr) == SUT_AF_UNIX)
        {
            writeCString_TSStream(stream, getUnixSocket_path(addr));
        }
    }
}


void sockoptionval_formatter(TSStream *stream, SocketOptionValue* value)
{
    VERIFY_TYPE(sockoptionval_formatter, &type_SocketOptionValue, value);

    writeTypeHeaderTSStream(stream, "sockoptionval");

    if (value->isInt)
    {
        writeInt_TSStream(stream, 0);
        writeInt_TSStream(stream, value->value);
    }
    else if (value->isLing)
    {
        writeInt_TSStream(stream, 1);
        writeInt_TSStream(stream, value->ling_val->l_onoff);
        writeInt_TSStream(stream, value->ling_val->l_linger);
    }
    else
    {
        writeInt_TSStream(stream, 2);
        writeLong_TSStream(stream, value->time_val->sec);
        writeLong_TSStream(stream, value->time_val->usec);
    }
}


void socketmsg_formatter(TSStream *stream, SocketMsgHdr* value)
{
    IntT i;


    VERIFY_TYPE(socketmsg_formatter, &type_SocketMsgHdr, value);

    writeTypeHeaderTSStream(stream, "socketmsg");

    sockaddr_formatter(stream, value->msg_name);

    writeInt_TSStream(stream, size_List(value->msg_iov));

    for (i=0;i<size_List(value->msg_iov);i++)
    {
        IOvec* curElement=(IOvec*)get_List(value->msg_iov, i);
        writePointer_TSStream(stream, curElement->iov_base);
        writeSize_TSStream(stream, curElement->iov_len);
    }

    writeInt_TSStream(stream, value->msg_control->cmsg_level);
    writeInt_TSStream(stream, value->msg_control->cmsg_type);
    writeCByteArray_TSStream(stream, value->msg_control->data);
    writeUInt_TSStream(stream, value->msg_flags);
}


SockaddrT* readSockaddr_TSStream(TSStream* stream)
{
    IntT socket_family=readInt_TSStream(stream);

    if(socket_family == -1)
    {
        return NULL;
    }
    else
    if (socket_family==SUT_AF_INET)
    {
        UShortT   sin_port = readUShort_TSStream(stream);
        UInt32T   sin_addr = readUInt32_TSStream(stream);

        return create_SockaddrT_Inet(sin_port, sin_addr);
    }
    else if (socket_family==SUT_AF_INET6)
    {
        UInt16T         sin6_port = readUInt16_TSStream(stream);
        UInt32T         sin6_flowinfo = readUInt32_TSStream(stream);
        UInt32T         sin6_scope_id = readUInt32_TSStream(stream);
        UInt8T          u6_addr8[INET6_ADDRESSLEN];
        IntT i;

        for(i=0;i<INET6_ADDRESSLEN;i++)
        {
            u6_addr8[i]=readUInt16_TSStream(stream);
        }

        return create_SockaddrT_Inet6(sin6_port, sin6_flowinfo, u6_addr8, sin6_scope_id);
    }
    else if (socket_family==SUT_AF_UNIX)
    {
        CString* path = readCString_TSStream(stream);

        return create_SockaddrT_Unix(path);
    }
    else
    {
        return create_SockaddrT_Unspec();
    }
}


SocketOptionValue* readSocketOption_TSStream(TSStream* stream)
{
    bool isInt = readInt_TSStream(stream);
    bool isLing = readInt_TSStream(stream);

    if (isInt)
    {
        IntT val=readInt_TSStream(stream);

        return create_SocketOptionValue_Int(val);
    }
    else if (isLing)
    {
        IntT l_onoff = readInt_TSStream(stream);
        IntT l_linger = readInt_TSStream(stream);

        return create_SocketOptionValue_Linger(l_onoff, l_linger);
    }
    else
    {
        TimeT sec = readLong_TSStream(stream);
        LongT usec = readLong_TSStream(stream);

        return create_SocketOptionValue_Time(sec, usec);
    }
}


SocketMsgHdr* readSocketMsgHdr_TSStream(CallContext context, TSStream* stream)
{
    SockaddrT* msg_name;
    SizeT msg_iov_size;
    List* msg_iov;
    IntT msg_control_level;
    IntT msg_control_type;
    CByteArray* msg_control_data;
    UIntT  msg_flags;
    int i=0;

    msg_name = readSockaddr_TSStream(stream);
    msg_iov_size = readSize_TSStream(stream);

    msg_iov=create_List(&type_IOvec);

    for (i=0;i<msg_iov_size;i++)
    {
        VoidTPtr curPtr=readPointer_TSStream(context, stream);
        SizeT   sz=readSize_TSStream(stream);
        append_List(msg_iov, create(&type_IOvec, curPtr, sz));
    }
    msg_control_level = readInt_TSStream(stream);
    msg_control_type =  readInt_TSStream(stream);
    msg_control_data = readCByteArray_TSStream(stream);

    msg_flags = readUInt_TSStream(stream);

    return create_SocketMsgHdr(msg_name, msg_iov, msg_control_level, msg_control_type, msg_control_data, msg_flags);

}


Bool3 isSocketOptionValid(IntT level, FileDescId socket, SocketOption option)
{
    SocketFileDescriptor* fdesc=getDescriptor_FileDescId(socket);

    if (level!=SUT_SOL_SOCKET)
    {
        return Unknown_Bool3;
    }

    if (fdesc->shutdown!=SUT_NO_SHUT)
    {
        return True_Bool3;
    }

    if (option!= SUT_SO_DEBUG &&
        option!= SUT_SO_OOBINLINE &&
        option!= SUT_SO_LINGER &&
        option!= SUT_SO_REUSEADDR &&
        option!= SUT_SO_DONTROUTE &&
        option!= SUT_SO_BROADCAST &&
        option!= SUT_SO_SNDBUF &&
        option!= SUT_SO_RCVBUF &&
        option!= SUT_SO_KEEPALIVE &&
        option!= SUT_SO_RCVLOWAT     &&
        option!= SUT_SO_SNDLOWAT    &&
        option!= SUT_SO_RCVTIMEO    &&
        option!= SUT_SO_SNDTIMEO)
    {
        return True_Bool3;
    }

    return False_Bool3;

}



*/
