/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "locale/nlcat/nlcat_model.seh"

#include "io/file/file_model.seh"


#pragma SEC subsystem nlcat "locale.nlcat"

/* TODO: markup NLSPATH */

/*
   The group of functions 'locale.nlcat' consists of:
       catclose [2]
       catgets [2]
       catopen [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6
    IEEE Std 1003.1, 2004 Edition
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    catclose - close a message catalog descriptor

    SYNOPSIS

    [XSI] #include <nl_types.h>

    int catclose(nl_catd catd);

    DESCRIPTION

    The catclose() function shall close the message catalog identified by catd. If
    a file descriptor is used to implement the type nl_catd, that file descriptor
    shall be closed.

    RETURN VALUE

    Upon successful completion, catclose() shall return 0; otherwise, -1 shall be
    returned, and errno set to indicate the error.

    ERRORS

    The catclose() function may fail if:

    [EBADF] The catalog descriptor is not valid.

    [EINTR] The catclose() function was interrupted by a signal.
*/

specification
IntT catclose_spec(CallContext context, nl_catd catd, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_CATCLOSE, "catclose.05", catclose_spec != 0 && *errno, *errno)

            /*
             * The catclose() function may fail if:
             *
             * [EBADF] The catalog descriptor is not valid.
             */
            ERROR_UNCHECKABLE(POSIX_CATCLOSE, EBADF, "catclose.05.01", "implementation-defined")

            /*
             * The catclose() function may fail if:
             *
             * [EINTR] The catclose() function was interrupted by a signal.
             */
            ERROR_UNCHECKABLE(POSIX_CATCLOSE, EINTR, "catclose.05.02", "difficult")

        ERROR_END()

        if(catclose_spec != 0)
            /*
             * otherwise, -1 shall be returned, and errno {MAY?} set to indicate the error.
             */
            REQ("catclose.04", "shall return -1 and set errno", TODO_REQ() /* *errno != 0 */);

        /*
         * Upon successful completion, catclose() shall return 0;
         */
        REQ("catclose.03", "shall return 0", TODO_REQ());


        return true;
    }
}

void onCatClose(CallContext context, nl_catd catd, IntT res)
{
    if(res == 0) unregisterObjectInMemory(catd);
}

/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6
    IEEE Std 1003.1, 2004 Edition
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    catgets - read a program message

    SYNOPSIS

    [XSI] #include <nl_types.h>

    char *catgets(nl_catd catd, int set_id, int msg_id, const char *s);

    DESCRIPTION

    The catgets() function shall attempt to read message msg_id, in set set_id,
    from the message catalog identified by catd. The catd argument is a message
    catalog descriptor returned from an earlier call to catopen(). The s argument
    points to a default message string which shall be returned by catgets() if it
    cannot retrieve the identified message.

    The catgets() function need not be reentrant. A function that is not required
    to be reentrant is not required to be thread-safe.

    RETURN VALUE

    If the identified message is retrieved successfully, catgets() shall return a
    pointer to an internal buffer area containing the null-terminated message
    string. If the call is unsuccessful for any reason, s shall be returned and
    errno may be set to indicate the error.

    ERRORS

    The catgets() function may fail if:

    [EBADF] The catd argument is not a valid message catalog descriptor open for
    reading.

    [EBADMSG] The message identified by set_id and msg_id in the specified message
    catalog did not satisfy implementation-defined security criteria.

    [EINTR] The read operation was terminated due to the receipt of a signal, and
    no data was transferred.

    [EINVAL] The message catalog identified by catd is corrupted.

    [ENOMSG] The message identified by set_id and msg_id is not in the message
    catalog.
*/

specification
CString* catgets_spec(CallContext context, nl_catd catd, IntT set_id, IntT msg_id, CString* s, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_CATGETS, "catgets.05", *errno, *errno)

            /*
             * The catgets() function may fail if:
             *
             * [EBADF] The catd argument is not a valid message catalog descriptor open for
             * reading.
             */
            ERROR_UNCHECKABLE(POSIX_CATGETS, EBADF, "catgets.05.01", "implementation-defined")

            /*
             * The catgets() function may fail if:
             *
             * [EBADMSG] The message identified by set_id and msg_id in the specified message
             * catalog did not satisfy implementation-defined security criteria.
             */
            ERROR_UNCHECKABLE(POSIX_CATGETS, EBADMSG, "catgets.05.02", "implementation-defined")

            /*
             * The catgets() function may fail if:
             *
             * [EINTR] The read operation was terminated due to the receipt of a signal, and
             * no data was transferred.
             */
            ERROR_UNCHECKABLE(POSIX_CATGETS, EINTR, "catgets.05.03", "difficult")

            /*
             * The catgets() function may fail if:
             *
             * [EINVAL] The message catalog identified by catd is corrupted.
             */
            ERROR_MAY(POSIX_CATGETS, EINVAL, "catgets.05.04", TODO_ERR(EINVAL))

            /*
             * The catgets() function may fail if:
             *
             * [ENOMSG] The message identified by set_id and msg_id is not in the message
             * catalog.
             */
            ERROR_MAY(POSIX_CATGETS, ENOMSG, "catgets.05.05", TODO_ERR(ENOMSG)) // base1

        ERROR_END()

        if(@getCatMessage(catd, set_id, msg_id) != NULL)
            REQ("", "stability of results", compare(@getCatMessage(catd, set_id, msg_id), catgets_spec) == 0);

        /*
         * If the identified message is retrieved successfully, catgets() shall return a
         * pointer to an internal buffer area containing the null-terminated message
         * string.
         */
        REQ("catgets.03", "shall successfully complete", *errno == 0);

        return true;
    }
}

void onCatGets(CallContext context, nl_catd catd, IntT set_id, IntT msg_id, CString* s, CString* res)
{
    if(s != res)
    {
        IntTObj* set_idObj = create_IntTObj(set_id);
        IntTObj* msg_idObj = create_IntTObj(msg_id);
        CatObject* catObj = getObjectInMemory(catd);

        assertion(catObj != 0, "onCatGets: internal error, object not found");

        if(!containsKey_Map(catObj->mapSet, set_idObj))
            put_Map(catObj->mapSet, set_idObj, create_Map(&type_IntTObj, &type_CString));

        put_Map(get_Map(catObj->mapSet, set_idObj), msg_idObj, res);
    }
}

/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6
    IEEE Std 1003.1, 2004 Edition
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

    NAME

    catopen - open a message catalog

    SYNOPSIS

    [XSI] #include <nl_types.h>

    nl_catd catopen(const char *name, int oflag);

    DESCRIPTION

    The catopen() function shall open a message catalog and return a message
    catalog descriptor. The name argument specifies the name of the message catalog
    to be opened. If name contains a '/', then name specifies a complete name for
    the message catalog. Otherwise, the environment variable NLSPATH is used with
    name substituted for the %N conversion specification (see the Base Definitions
    volume of IEEE Std 1003.1-2001, Chapter 8, Environment Variables). If NLSPATH
    exists in the environment when the process starts, then if the process has
    appropriate privileges, the behavior of catopen() is undefined. If NLSPATH does
    not exist in the environment, or if a message catalog cannot be found in any of
    the components specified by NLSPATH , then an implementation-defined default
    path shall be used. This default may be affected by the setting of LC_MESSAGES
    if the value of oflag is NL_CAT_LOCALE, or the LANG environment variable if
    oflag is 0 .

    A message catalog descriptor shall remain valid in a process until that process
    closes it, or a successful call to one of the exec functions. A change in the
    setting of the LC_MESSAGES category may invalidate existing open catalogs.

    If a file descriptor is used to implement message catalog descriptors, the
    FD_CLOEXEC flag shall be set; see <fcntl.h>.

    If the value of the oflag argument is 0, the LANG environment variable is used
    to locate the catalog without regard to the LC_MESSAGES category. If the oflag
    argument is NL_CAT_LOCALE, the LC_MESSAGES category is used to locate the
    message catalog (see the Base Definitions volume of IEEE Std 1003.1-2001,
    Section 8.2, Internationalization Variables).

    RETURN VALUE

    Upon successful completion, catopen() shall return a message catalog descriptor
    for use on subsequent calls to catgets() and catclose(). Otherwise, catopen()
    shall return ( nl_catd) -1 and set errno to indicate the error.

    ERRORS

    The catopen() function may fail if:

    [EACCES] Search permission is denied for the component of the path prefix of
    the message catalog or read permission is denied for the message catalog.

    [EMFILE] {OPEN_MAX} file descriptors are currently open in the calling process.

    [ENAMETOOLONG] The length of a pathname of the message catalog exceeds
    {PATH_MAX} or a pathname component is longer than {NAME_MAX}.

    [ENAMETOOLONG] Pathname resolution of a symbolic link produced an intermediate
    result whose length exceeds {PATH_MAX}.

    [ENFILE] Too many files are currently open in the system.

    [ENOENT] The message catalog does not exist or the name argument points to an
    empty string.

    [ENOMEM] Insufficient storage space is available.

    [ENOTDIR] A component of the path prefix of the message catalog is not a
    directory.
*/

specification
nl_catd catopen_spec(CallContext context, CString* Name, IntT oflag, ErrorCode* errno)
{
    pre
    {
        /*
         * If NLSPATH exists in the environment when the process starts, then if the
         * process has appropriate privileges, the behavior of catopen() is undefined.
         */
        REQ("app.catopen.03", "", TODO_REQ());

        return true;
    }
    post
    {
        ERROR_BEGIN(POSIX_CATOPEN, "catopen.10", isInvalid_VoidTPtr(catopen_spec) && *errno, *errno)

            /*
             * The catopen() function may fail if:
             *
             * [EACCES] Search permission is denied for the component of the path prefix of
             * the message catalog or read permission is denied for the message catalog.
             */
            ERROR_MAY(POSIX_CATOPEN, EACCES, "catopen.10.01", TODO_ERR(EACCES))// uncheckable?

            /*
             * The catopen() function may fail if:
             *
             * [EMFILE] {OPEN_MAX} file descriptors are currently open in the calling process.
             */
            ERROR_MAY3(POSIX_CATOPEN, EMFILE, "catopen.10.02", isOpenFileDescNumberExceedMax(context))

            /*
             * The catopen() function may fail if:
             *
             * [ENAMETOOLONG] The length of a pathname of the message catalog exceeds
             * {PATH_MAX} or a pathname component is longer than {NAME_MAX}.
             */
            ERROR_MAY3(POSIX_CATOPEN, ENAMETOOLONG, "catopen.10.03", isENAMETOOLONG(context, Name))

            /*
             * The catopen() function may fail if:
             *
             * [ENAMETOOLONG] Pathname resolution of a symbolic link produced an intermediate
             * result whose length exceeds {PATH_MAX}.
             */
            ERROR_MAY3(POSIX_CATOPEN, ENAMETOOLONG, "catopen.10.04", isENAMETOOLONG(context, Name))

            /*
             * The catopen() function may fail if:
             *
             * [ENFILE] Too many files are currently open in the system.
             */
            ERROR_UNCHECKABLE(POSIX_CATOPEN, ENFILE, "catopen.10.05", "ENFILE could not be checked")

            /*
             * The catopen() function may fail if:
             *
             * [ENOENT] The message catalog does not exist or the name argument points to an
             * empty string.
             */
            ERROR_MAY(POSIX_CATOPEN, ENOENT, "catopen.10.06", TODO_ERR(ENOENT))

            /*
             * The catopen() function may fail if:
             *
             * [ENOMEM] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_CATOPEN, ENOMEM, "catopen.10.07", TODO_ERR(ENOMEM))

            /*
             * The catopen() function may fail if:
             *
             * [ENOTDIR] A component of the path prefix of the message catalog is not a
             * directory.
             */
            /* TODO: need detailed analyse */
            ERROR_MAY(POSIX_CATOPEN, ENOTDIR, "catopen.10.08", TODO_ERR(ENOTDIR))

        ERROR_END()

        /*
         * A message catalog descriptor shall remain valid in a process until that process
         * closes it, or a successful call to one of the exec functions.
         */
        REQ("catopen.05", "", TODO_REQ());

        /*
         * A change in the setting of the LC_MESSAGES category may invalidate existing
         * open catalogs.
         */
        REQ("catopen.06", "", TODO_REQ());

        /*
         * If a file descriptor is used to implement message catalog descriptors, the
         * FD_CLOEXEC flag shall be set; see <fcntl.h>.
         */
        REQ("catopen.07", "", TODO_REQ());

        if(!isInvalid_VoidTPtr(catopen_spec))
        /*
         * Upon successful completion, catopen() shall return a message catalog descriptor
         * for use on subsequent calls to catgets() and catclose().
         */
        REQ("?catopen.08", "shall return a message catalog", getObjectInMemory(catopen_spec) != NULL);


        return true;
    }
}

void onCatOpen(CallContext context, CString* Name, IntT oflag, nl_catd res)
{
    if(!isInvalid_VoidTPtr(res))
    {
        if(getObjectInMemory(res) != NULL)
        {
            /* TODO: (base1) need analyse this event */
        }

        registerObjectInMemory(res, 0,
            create_CatObject( Name, oflag, create_Map(&type_IntTObj, &type_Map)));
    }
}

/********************************************************************/
/**                         Object In Memory                       **/
/********************************************************************/
specification typedef struct CatObject CatObject = { };

CatObject * create_CatObject(
    CString* strName,
    int oflag,
    Map* mapSet
)
{
    return create(&type_CatObject,
        strName,
        oflag,
        mapSet);
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

CString* getCatMessage(nl_catd catd, IntT set_id, IntT msg_id)
{
    CatObject* catObj;
    Map* mapSet;

    if(isInvalid_VoidTPtr(catd)) return NULL;

    catObj = getObjectInMemory(catd);
    mapSet = get_Map(catObj->mapSet, create_IntTObj(set_id));

    return catObj == NULL || mapSet == NULL ? NULL :
        get_Map(mapSet, create_IntTObj(msg_id));
}
