/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "process/process/process_model.seh"
#include "locale/messages/messages_model.seh"
#include "locale/locale/locale_model.seh"

#pragma SEC subsystem messages "locale.messages"

/*
   The group of functions 'locale.messages' consists of:
       perror [1]
       strerror [2]
       strerror_r [1]
 */


/********************************************************************/
/**                         Model State API                        **/
/********************************************************************/

specification typedef CString* PCString = {};

PCString * create_PCString(CString * str)
{
    return create(&type_PCString, str);
}

PCString* getStdErr(CallContext context)
{
    PCString* StdErr = create_PCString( _CS(""));

    registerProcessStaticData(context, _CS("stderr"), StdErr);

    return getProcessStaticData(context, _CS("stderr"));
}

specification typedef struct LocaleMessagesSt LocaleMessages = {};

LocaleMessages* create_LocaleMessages(void)
{
    return create(&type_LocaleMessages, NULL, create_Map(&type_IntTObj, &type_CString));
}

LocaleMessages* getState_LocaleMessages(CallContext context)
{
    registerProcessStaticData(context, _CS("locale.messages"),
        create_LocaleMessages());

    return getProcessStaticData(context, _CS("locale.messages"));
}

void put_LocaleMessages(CallContext context, IntT errnum, CString* msg)
{
    CString* currentLocale = getLocale_Locale(context, SUT_LC_MESSAGES);
    LocaleMessages* st = getState_LocaleMessages(context);
    
    if(st->localeName == NULL || !equals(st->localeName, currentLocale))
    {
        st->localeName = currentLocale;
        clear_Map(st->msgMap);
    }

    put_Map(st->msgMap, create_IntTObj(errnum), msg);
}

CString* get_LocaleMessages(CallContext context, IntT errnum)
{
    CString* currentLocale = getLocale_Locale(context, SUT_LC_MESSAGES);
    LocaleMessages* st = getState_LocaleMessages(context);

    if(st->localeName == NULL || !equals(st->localeName, currentLocale))
        return NULL;
    
    return get_Map(st->msgMap, create_IntTObj(errnum));
}


/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    perror - write error messages to standard error

SYNOPSIS

    #include <stdio.h>

    void perror(const char *s);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. The perror() function shall map the error number accessed
    through the symbol errno to a language-dependent error message, which shall be
    written to the standard error stream as follows:

    * First (if s is not a null pointer and the character pointed to by s is not
    the null byte), the string pointed to by s followed by a colon and a <space&
    gt;.

    * Then an error message string followed by a <newline>.

    The contents of the error message strings shall be the same as those returned
    by strerror() with argument errno.

    [CX] The perror() function shall mark the file associated with the standard
    error stream as having been written (st_ctime, st_mtime marked for update) at
    some time between its successful completion and exit(), abort(), or the
    completion of fflush() or fclose() on stderr.

    The perror() function shall not change the orientation of the standard error
    stream.

RETURN VALUE

    {perror.05} The perror() function shall not return a value.

ERRORS

    No errors are defined.
*/

specification
void perror_spec(CallContext context, CString* s, ErrorCode* errno)
{
    pre
    {
        REQ("", "errno NOT NULL", errno != NULL);

        return true;
    }

    coverage C_String
    {
        if(s == NULL)
            return { NullS, "s is zero-size string" };
        /* else */
            return { NotNullS, "s is not zero-size string" };
    }

    post
    {
        CString* StdErr = *getStdErr(context);
        CString *corrMsg, *subStdErr;

        if(s != NULL && length_CString(s) > 0)
        {
            corrMsg = concat_CString(s, _CS(": "));
            subStdErr = substring_CString(StdErr, 0, length_CString(corrMsg));
            /*
             * which shall be written to the standard error stream as follows:
             *
             * First (if s is not a null pointer and the character pointed to by s is not the
             * null byte), the string pointed to by s followed by a colon and a <space>.
             */
            REQ("perror.02.01", "shall write \"msg: \"", compare(corrMsg, subStdErr) == 0);
        }

        /*
         * which shall be written to the standard error stream as follows:
         *
         * Then an error message string followed by a <newline>.
         * The contents of the error message strings shall be the same as those returned
         * by strerror() with argument errno.
         */
        REQ("perror.02.02", "string followed by a <newline>",
            charAt_CString(StdErr, length_CString(StdErr)-1) == '\n');

        /*
         * [CX] The perror() function shall mark the file associated with the standard
         * error stream as having been written (st_ctime, st_mtime marked for update) at
         * some time between its successful completion and exit(), abort(), or the
         * completion of fflush() or fclose() on stderr.
         */
        REQ("perror.03", "", TODO_REQ());

        /*
         * The perror() function shall not change the orientation of the standard error
         * stream.
         */
        REQ("perror.04", "", TODO_REQ());

        return true;
    }
}

void onPerror(CallContext context, CString* s, ErrorCode* errno)
{
    SizeT prev = 2;
    CString* StdErr = *getStdErr(context);
    CString* eMsg;
    
    if(s != NULL) prev += length_CString(s);
    
    eMsg = substring_CString(StdErr, prev, length_CString(StdErr)-2);
    
    if(isEINVALstrerror(*errno) == False_Bool3 &&
        get_LocaleMessages(context, *errno) == NULL)
    {
        put_LocaleMessages(context, *errno, eMsg);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strerror, strerror_r - get error message string

SYNOPSIS

    #include <string.h>

    char *strerror(int errnum);

    [TSF] int strerror_r(int errnum, char *strerrbuf, size_t buflen);

DESCRIPTION

    For strerror(): [CX] The functionality described on this reference page is
    aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The strerror() function shall map the error number in errnum to a locale-
    dependent error message string and shall return a pointer to it. Typically, the
    values for errnum come from errno, but strerror() shall map any value of type
    int to a message.

    {app.strerror.03} The string pointed to shall not be modified by the
    application, {strerror.04} but may be overwritten by a subsequent call to
    strerror() [CX] or perror().

    [CX] The contents of the error message strings returned by strerror() should be
    determined by the setting of the LC_MESSAGES category in the current locale.

    The implementation shall behave as if no function defined in this volume of
    IEEE Std 1003.1-2001 calls strerror().

    [CX] The strerror() function shall not change the setting of errno if
    successful.

    Since no return value is reserved to indicate an error, an application wishing
    to check for error situations should set errno to 0, then call strerror(), then
    check errno.

    The strerror() function need not be reentrant. A function that is not required
    to be reentrant is not required to be thread-safe.

    [TSF] The strerror_r() function shall map the error number in errnum to a
    locale-dependent error message string and shall return the string in the buffer
    pointed to by strerrbuf, with length buflen.

RETURN VALUE

    Upon successful completion, strerror() shall return a pointer to the generated
    message string. On error errno may be set, {strerror.11} but no return value is
    reserved to indicate an error.

    [TSF] Upon successful completion, strerror_r() shall return 0. Otherwise, an
    error number shall be returned to indicate the error.

ERRORS

    These functions may fail if:

    [EINVAL] The value of errnum is not a valid error number.

    The strerror_r() function may fail if:

    [ERANGE] [TSF] Insufficient storage was supplied via strerrbuf and buflen to
    contain the generated message string.
*/

specification
CString* strerror_spec(CallContext context, IntT errnum, ErrorCode* errno)
{
    Bool3 errnumInvalid = isEINVALstrerror(errnum);
    
    pre
    {
        return true;
    }
    
    coverage Errnum
    {
        if(errnumInvalid == False_Bool3)
            return { Valid_Errnum, "Valid errnum value" };
        else if(errnumInvalid == True_Bool3)
            return { Invalid_Errnum, "Invalid errnum value" };
        /* else */
            return { Unknown_Errnum, "Unknown errnum value" };
    }

    post
    {
        CString* trueResult = get_LocaleMessages(context, errnum);
        
        ERROR_BEGIN(POSIX_STRERROR, "strerror.12", *errno != 0, *errno)

            /*
             * These functions may fail if:
             *
             * [EINVAL] The value of errnum is not a valid error number.
             */
            ERROR_MAY3(POSIX_STRERROR, EINVAL, "strerror.12.01", errnumInvalid)

        ERROR_END()
        
        /*
         * strerror() shall map any value of type int to a message.
         */
        REQ("strerror.02", "shall always return a string", strerror_spec != NULL);
        
        if(errno != 0) return true;
        
        if(errnumInvalid == False_Bool3)
        {
            if(trueResult != NULL)
            {
                /*
                 * Upon successful completion, strerror() shall return a pointer to the generated 
                 * message string.
                 */
                /*
                 * [CX] The contents of the error message strings returned by strerror() should be 
                 * determined by the setting of the LC_MESSAGES category in the current locale.
                 */
                REQ("strerror.05;strerror.10", "shall return the generated string",
                    compare(strerror_spec, trueResult) == 0);
            }
        }

        /*
         * [CX] The strerror() function shall not change the setting of errno if 
         * successful.
         */
        REQ("strerror.07", "", TODO_REQ());
        
        /*
         * The implementation shall behave as if no function defined in this volume of 
         * IEEE Std 1003.1-2001 calls strerror().
         */
        /*
         * This is requirement for all functions from IEEE Std 1003.1-2001
         */
        REQ("strerror.06", "", TODO_REQ());

        return true;
    }
}

void onStrError(CallContext context, IntT errnum, ErrorCode* errno, CString* res)
{
    if(*errno != 0 || res == NULL) return;
    
    if(isEINVALstrerror(errnum) == False_Bool3 &&
        get_LocaleMessages(context, errnum) == NULL)
    {
        put_LocaleMessages(context, errnum, res);
    }
}

specification
CString* strerror_r_spec (
                          CallContext context,
                          IntT        errnum,
                          CString**   strerrbuf,
                          SizeT       buflen,
                          ErrorCode*  errno
                         )
{
    Bool3 errnumInvalid = isEINVALstrerror(errnum);
    
    pre
    {
        return true;
    }
    
    coverage Errnum
    {
        if(errnumInvalid == False_Bool3)
            return { Valid_Errnum, "Valid errnum value" };
        else if(errnumInvalid == True_Bool3)
            return { Invalid_Errnum, "Invalid errnum value" };
        /* else */
            return { Unknown_Errnum, "Unknown errnum value" };
    }

    post
    {
        Bool3 bERANGE = False_Bool3;
        CString* trueResult = get_LocaleMessages(context, errnum);
        
        if(trueResult != NULL)
        {
            bERANGE = length_CString(trueResult) > buflen;
        }
        
        ERROR_BEGIN(POSIX_STRERROR_R, "strerror_r.05", *errno != 0, *errno)

            /*
             * These functions may fail if:
             *
             * [EINVAL] The value of errnum is not a valid error number.
             */
            ERROR_MAY3(POSIX_STRERROR_R, EINVAL, "strerror_r.05.01", errnumInvalid)

            /*
             * These functions may fail if:
             *
             * [ERANGE] [TSF] Insufficient storage was supplied via strerrbuf and buflen to 
             * contain the generated message string.
             */
            ERROR_MAY3(POSIX_STRERROR_R, ERANGE, "strerror_r.05.02", bERANGE)

        ERROR_END()
        
        /*
         * strerror() shall map any value of type int to a message.
         */
        REQ("strerror_r.01", "shall always return a string", strerror_r_spec != NULL);
        
        if(errno != 0) return true;
        
        if(errnumInvalid == False_Bool3)
        {
            if(trueResult != NULL)
            {
                /*
                 * The strerror_r() function shall return a pointer to the string corresponding to 
                 * errno.
                 */
                /*
                 * [TSF] The strerror_r() function shall map the error number in errnum to a 
                 * locale-dependent error message string and shall return the string in the buffer 
                 * pointed to by strerrbuf, with length buflen.
                 */
                REQ("lsb.strerror_r.02;strerror_r.02", "shall return the generated string",
                    compare(strerror_r_spec, trueResult) == 0);
            }
        }
        
        /*
         * The strerror_r() shall behave as specified in ISO POSIX (2003), except as 
         * described below.
         */
        REQ("lsb.strerror_r.01", "", true);
        
        /*
         * Otherwise, strerror_r() shall return the string corresponding to "Unknown error" 
         * .
         */
        REQ("lsb.strerror_r.04", "", TODO_REQ());
        
        return true;
    }
}

void onStrErrorR(CallContext context, IntT errnum, CString** strerrbuf,
    SizeT buflen, ErrorCode* errno, CString* res)
{
    if(*errno != 0 || res == NULL) return;
    
    if(isEINVALstrerror(errnum) == False_Bool3 &&
        get_LocaleMessages(context, errnum) == NULL)
    {
        put_LocaleMessages(context, errnum, res);
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

Bool3 isEINVALstrerror(IntT errnum)
{
    if(errnum >= 0 && errnum < 126) return False_Bool3;

    return Unknown_Bool3;
}

