/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#define NEWREQ

#include "process/process/process_model.seh"
#include "locale/messages/messages_model.seh"

#pragma SEC subsystem messages "locale.messages"

/*
   The group of functions 'locale.messages' consists of:
       perror [1]
       strerror [2]
       strerror_r [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    perror - write error messages to standard error

SYNOPSIS

    #include <stdio.h>

    void perror(const char *s);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. The perror() function shall map the error number accessed
    through the symbol errno to a language-dependent error message, which shall be
    written to the standard error stream as follows:

    * First (if s is not a null pointer and the character pointed to by s is not
    the null byte), the string pointed to by s followed by a colon and a <space&
    gt;.

    * Then an error message string followed by a <newline>.

    The contents of the error message strings shall be the same as those returned
    by strerror() with argument errno.

    [CX] The perror() function shall mark the file associated with the standard
    error stream as having been written (st_ctime, st_mtime marked for update) at
    some time between its successful completion and exit(), abort(), or the
    completion of fflush() or fclose() on stderr.

    The perror() function shall not change the orientation of the standard error
    stream.

RETURN VALUE

    {perror.05} The perror() function shall not return a value.

ERRORS

    No errors are defined.
*/

specification
void perror_spec(CallContext context, CString* s, ErrorCode* errno)
{
    pre
    {
        REQ("", "errno NOT NULL", errno != NULL);

        return true;
    }

    coverage C_String
    {
        if(s == NULL)
            return { NullS, "s is zero-size string" };
        /* else */
            return { NotNullS, "s is not zero-size string" };
    }

    post
    {
        CString* StdErr = *getStdErr(context);
        CString *corrMsg, *subStdErr;

        if(s != NULL && length_CString(s) > 0)
        {
            corrMsg = concat_CString(s, _CS(": "));
            subStdErr = substring_CString(StdErr, 0, length_CString(corrMsg));
            /*
             * which shall be written to the standard error stream as follows:
             *
             * First (if s is not a null pointer and the character pointed to by s is not the
             * null byte), the string pointed to by s followed by a colon and a <space>.
             */
            REQ("perror.02.01", "shall write \"msg: \"", compare(corrMsg, subStdErr) == 0);
        }

        /*
         * which shall be written to the standard error stream as follows:
         *
         * Then an error message string followed by a <newline>.
         * The contents of the error message strings shall be the same as those returned
         * by strerror() with argument errno.
         */
        REQ("perror.02.02", "string followed by a <newline>",
            charAt_CString(StdErr, length_CString(StdErr)-1) == '\n');

        /*
         * [CX] The perror() function shall mark the file associated with the standard
         * error stream as having been written (st_ctime, st_mtime marked for update) at
         * some time between its successful completion and exit(), abort(), or the
         * completion of fflush() or fclose() on stderr.
         */
        REQ("perror.03", "", TODO_REQ());

        /*
         * The perror() function shall not change the orientation of the standard error
         * stream.
         */
        REQ("perror.04", "", TODO_REQ());


        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strerror, strerror_r - get error message string

SYNOPSIS

    #include <string.h>

    char *strerror(int errnum);

    [TSF] int strerror_r(int errnum, char *strerrbuf, size_t buflen);

DESCRIPTION

    For strerror(): [CX] The functionality described on this reference page is
    aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The strerror() function shall map the error number in errnum to a locale-
    dependent error message string and shall return a pointer to it. Typically, the
    values for errnum come from errno, but strerror() shall map any value of type
    int to a message.

    {app.strerror.03} The string pointed to shall not be modified by the
    application, {strerror.04} but may be overwritten by a subsequent call to
    strerror() [CX] or perror().

    [CX] The contents of the error message strings returned by strerror() should be
    determined by the setting of the LC_MESSAGES category in the current locale.

    The implementation shall behave as if no function defined in this volume of
    IEEE Std 1003.1-2001 calls strerror().

    [CX] The strerror() function shall not change the setting of errno if
    successful.

    Since no return value is reserved to indicate an error, an application wishing
    to check for error situations should set errno to 0, then call strerror(), then
    check errno.

    The strerror() function need not be reentrant. A function that is not required
    to be reentrant is not required to be thread-safe.

    [TSF] The strerror_r() function shall map the error number in errnum to a
    locale-dependent error message string and shall return the string in the buffer
    pointed to by strerrbuf, with length buflen.

RETURN VALUE

    Upon successful completion, strerror() shall return a pointer to the generated
    message string. On error errno may be set, {strerror.11} but no return value is
    reserved to indicate an error.

    [TSF] Upon successful completion, strerror_r() shall return 0. Otherwise, an
    error number shall be returned to indicate the error.

ERRORS

    These functions may fail if:

    [EINVAL] The value of errnum is not a valid error number.

    The strerror_r() function may fail if:

    [ERANGE] [TSF] Insufficient storage was supplied via strerrbuf and buflen to
    contain the generated message string.
*/

//This specification refers to: strerror_r, strerror
specification
CString* strerror_spec(CallContext context, IntT errnum, CString** strerrbuf,
    SizeT buflen, ErrorCode* errno)
{
    pre
    {
        if(strerrbuf != NULL)
        {
            FILTER("strerror_r");
            FILTER("lsb.strerror_r");
        }
        else
        {
            FILTER("strerror");
        }

        return true;
    }

    coverage Func
    {
        if(strerrbuf != NULL)
            return { STRERROR_R_FUNC, "strerror_r is called" };
        /* else */
            return { STRERROR_FUNC, "strerror is called" };
    }

    post
    {
#ifdef NewCTesK
        if( Func == Func.STRERROR_FUNC )
#else
        if(coverage(Func) == STRERROR_FUNC)
#endif // NewCTesK
        {
            ERROR_BEGIN(POSIX_STRERROR, "strerror.12", *errno, *errno)

                /*
                 * These functions may fail if:
                 *
                 * [EINVAL] The value of errnum is not a valid error number.
                 */
                ERROR_MAY3(POSIX_STRERROR, EINVAL, "strerror.12.01", isEINVALstrerror(errnum))

            ERROR_END()
        }
        else
        {
            ERROR_BEGIN(POSIX_STRERROR_R, "strerror_r.04", *errno, *errno)

                /*
                 * These functions may fail if:
                 *
                 * [EINVAL] The value of errnum is not a valid error number.
                 */
                ERROR_MAY3(POSIX_STRERROR_R, EINVAL, "strerror_r.04.01", isEINVALstrerror(errnum))

                /*
                 * These functions may fail if:
                 *
                 * [ERANGE] [TSF] Insufficient storage was supplied via strerrbuf and buflen to
                 * contain the generated message string.
                 */
                ERROR_MAY(POSIX_STRERROR_R, ERANGE, "strerror_r.04.02", TODO_ERR(ERANGE))

            ERROR_END()
        }

        if(*errno != 0 || (strerrbuf && compare(strerror_spec, _CS("Unknown error")) == 0))
        {
            return true;
        }

        if(isEINVALstrerror(errnum) == False_Bool3
            || (strerrbuf && compare(strerror_spec, _CS("Unknown error")) != 0))
        {
            /*
             * The strerror() function shall map the error number in errnum to a locale-
             * dependent error message string and shall return a pointer to it.
             */
            /*
             * Upon successful completion, strerror() shall return a pointer to the generated
             * message string.
             */
            /*
             * The strerror_r() function shall return a pointer to the string corresponding to
             * errno.
             */
            /*
             * On success, strerror_r() shall return a pointer to the generated message string
             * (determined by the setting of the LC_MESSAGES category in the current locale).
             */
            REQ("strerror.01;strerror.10;lsb.strerror_r.02", "shall return a string",
                strerror_spec != NULL && length_CString(strerror_spec));

            /*
             * [CX] The contents of the error message strings returned by strerror() should be
             * determined by the setting of the LC_MESSAGES category in the current locale.
             */
            REQ("strerror.05", "", TODO_REQ());


            if(strerrbuf && strerror_spec != NULL)
            {
                CString* buf = buflen < length_CString(strerror_spec) ?
                    substring_CString(strerror_spec, 0, buflen) : strerror_spec;



                /*
                 * [TSF] The strerror_r() function shall map the error number in errnum to a
                 * locale-dependent error message string and shall return the string in the buffer
                 * pointed to by strerrbuf, with length buflen.
                 */
                REQ("strerror_r.01", "shall map the error number", compare(buf, *strerrbuf) == 0);


           }

        }


        return true;
    }

    FILTER_CLEAN;
}

void onStrError(CallContext context, IntT errnum, CString** strerrbuf,
    SizeT buflen, ErrorCode* errno, CString* res)
{
    if(errno == NULL) return;// ignore strerror_r

    if(*errno == SUT_EOK)
    {
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

specification typedef CString* PCString = {};

PCString * create_PCString(CString * str)
{
    return create(&type_PCString, str);
}

PCString* getStdErr(CallContext context)
{
    PCString* StdErr = create_PCString( _CS(""));

    registerProcessStaticData(context, _CS("stderr"), StdErr);

    return getProcessStaticData(context, _CS("stderr"));
}

Bool3 isEINVALstrerror(IntT errnum)
{
    if(errnum >= 0 && errnum < 126) return False_Bool3;

    return Unknown_Bool3;
}

