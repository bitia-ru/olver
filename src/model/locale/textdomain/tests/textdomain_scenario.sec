/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "locale/locale/locale_model.seh"

#include "locale/textdomain/tests/textdomain_scenario.seh"
#include "locale/textdomain/textdomain_model.seh"

#define textdomain_verbose_result \
    if(res != NULL) ("\tString: %s\n", toCharArray_CString(res))

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context;

char* domainPaths[] = 
{
    NULL,
    "",// will set in init_locale_textdomain_scenario()
    "" // will set in init_locale_textdomain_scenario()
};

const int domainPathsNum = sizeof(domainPaths)/sizeof(domainPaths[0]);

char* domainNames[] =
{
    NULL,
    "testdomain",
    "anotherdomain"
};

char* domainUndefNames[] =
{
    NULL,
    "",
    "undefined_domain"
};

const int domainNamesNum = sizeof(domainNames)/sizeof(domainNames[0]);
const int domainUndefNamesNum = sizeof(domainUndefNames)/sizeof(domainUndefNames[0]);

char* domainTexts[] =
{
    "",
    "Test text",
    "0123456789!@#$%^",
    "asdfgsad",
    "%d window"
};

char* domainPluralTexts[] =
{
    "",
    "Test text",
    "%d window"
};

const int domainTextsNum = sizeof(domainTexts)/sizeof(domainTexts[0]);

ULongT domainPluralForms[] =
{
    0,
    1,
    2,
    4,
    5,
    7,
    10,
    100,
    101,
    102,
    104,
    105,
    107,
    110
};

const int domainPluralFormsNum = sizeof(domainPluralForms)/sizeof(domainPluralForms[0]);

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/
static bool init_locale_textdomain_scenario(int argc, char** argv)
{
    CString* path1;
    CString* path2;

    // Init test scenario data
    context = getContext();
    initReqFilters();
    
    // Initializations of textdomain model state...
    init_TextDomain(context);
    
    path1 = getRelativeTestDataPathCh("locale.textdomain/Path1");
    path2 = getRelativeTestDataPathCh("locale.textdomain/Path2");
    
    domainPaths[1] = malloc(length_CString(path1));
    domainPaths[2] = malloc(length_CString(path2));
    
    strcpy(domainPaths[1], (char*)path1->data);
    strcpy(domainPaths[2], (char*)path2->data);
    
    INIT_SCENARIO_ACTION(setlocale_spec(context, SUT_LC_ALL, _CS("Olver_Locale")) != NULL);

    return true;
}

static void finish_locale_textdomain_scenario(void)
{
    TEST_SCENARIO_VERDICT_VERBOSE(locale_textdomain_scenario);
}


/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

/* Full OLVER Edition Source Start */

scenario
bool locale_textdomain_modeltest_scen()
{
    bool bRes;
    CString* domName;
    CString* text;
    Map* domMap;
    int i;
    
    domName = getCurrent_Domain(context);
    REQ("", "domName initialy = \"messages\"", safeCompare_CString(domName, _CS("messages")) == 0);
    
    bRes = setCurrent_Domain(context, _CS("MyDomain"));
    REQ("", "setCurrent_Domain shall set the domain name, even if it is undefined", bRes);
    
    domMap = getMap_Domain(context);
    REQ("", "domMap initialy is not a clear Map", domMap != NULL && isEmpty_Map(domMap));
    
    bRes = get_Domain(context, _CS("MyDomain")) == NULL;
    REQ("", "get_Domain shall return NULL for undefined domain names", bRes);
    
    bRes = put_Domain(context, _CS("MyDomain"), create_Domain());
    REQ("", "put_Domain shall put domain for a new domain name", bRes);
    
    bRes = put_Domain(context, _CS("MyDomain"), create_Domain()) == false;
    REQ("", "put_Domain shall not put domain for an old domain name", bRes);
    
    bRes = setCurrent_Domain(context, _CS("MyDomain"));
    REQ("", "setCurrent_Domain shall set the domain name, that is known", bRes);
    
    domName = getCurrent_Domain(context);
    REQ("", "domName shall be updated", domName != NULL && compare(domName, _CS("MyDomain")) == 0);


    // [get,put]Text_Domain() tests:
    text = getText_Domain(context, _CS("UndefinedDomain"), _CS("TestMsg"), SUT_LC_MONETARY);
    REQ("", "getText_Domain shall return NULL if domain name is unknown", text == NULL);
    
    text = getText_Domain(context, _CS("MyDomain"), _CS("TestMsg"), SUT_LC_MONETARY);
    REQ("", "getText_Domain shall return NULL if msg wasn't found", text == NULL);
    
    bRes = putText_Domain(context, _CS("UndefinedDomain"), _CS("TestMsg"), SUT_LC_MONETARY, _CS("abc"));
    REQ("", "putText_Domain shall return false if domain name is unknown", bRes == false);
    
    bRes = putText_Domain(context, _CS("MyDomain"), _CS("TestMsg"), SUT_LC_MONETARY, _CS("abc"));
    REQ("", "putText_Domain shall return true if domain name is known", bRes);
    
    text = getText_Domain(context, _CS("MyDomain"), _CS("TestMsg"), SUT_LC_CTYPE);
    REQ("", "getText_Domain shall use the specified category", text == NULL);
    
    text = getText_Domain(context, _CS("MyDomain"), _CS("TestMsg"), SUT_LC_MONETARY);
    REQ("", "getText_Domain shall return an appropriate text if msg was found",
        text != NULL && compare(text, _CS("abc")) == 0);

    bRes = putText_Domain(context, _CS("MyDomain"), _CS("TestMsg"), SUT_LC_MONETARY, _CS("cab"));
    text = getText_Domain(context, _CS("MyDomain"), _CS("TestMsg"), SUT_LC_MONETARY);
    REQ("", "putText_Domain shall alter an appropriate text if msg was found",
        bRes && text != NULL && compare(text, _CS("cab")) == 0);

    // [nget,nput]Text_Domain() tests:
    for(i = 0; i < 5; i++)
    {
        text = ngetText_Domain(context, _CS("UndefinedDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i);
        REQ("", "ngetText_Domain shall return NULL if domain name is unknown", text == NULL);

        text = ngetText_Domain(context, _CS("MyDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i);
        REQ("", "ngetText_Domain shall return NULL if msg wasn't found", text == NULL);
        
        bRes = nputText_Domain(context, _CS("UndefinedDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i, _CS("abc"));
        REQ("", "nputText_Domain shall return false if domain name is unknown", bRes == false);
    
        bRes = nputText_Domain(context, _CS("MyDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i,
            format_CString("abc%d", i));
        REQ("", "nputText_Domain shall return true if domain name is known", bRes);
        
        text = ngetText_Domain(context, _CS("MyDomain"), _CS("TestMsgs"), SUT_LC_CTYPE, i);
        REQ("", "ngetText_Domain shall use the specified category", text == NULL);
        
        text = ngetText_Domain(context, _CS("MyDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i);
        REQ("", "ngetText_Domain shall return an appropriate text if msg was found",
            text != NULL && compare(text, format_CString("abc%d", i)) == 0);
        
        bRes = nputText_Domain(context, _CS("MyDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i,
            format_CString("cab%d", i));
        text = ngetText_Domain(context, _CS("MyDomain"), _CS("TestMsgs"), SUT_LC_MONETARY, i);
        REQ("", "nputText_Domain shall alter an appropriate text if msg was found",
            bRes && text != NULL && compare(text, format_CString("cab%d", i)) == 0);
    }

    return true;
}

/* Full OLVER Edition Source End */

scenario
bool textdomain_single_scen(void)
{
    int k, m;

    iterate(int i = 0; i < domainPathsNum; i++; )
    {
        iterate(int j = 0; j < domainNamesNum; j++; )
        {
            for(m = 0; m < 2; m++)
            {
                bind_textdomain_codeset_spec(context, _CS(domainNames[j]), _CS("UTF-8"), requestErrorCode());
                textdomain_spec(context, _CS(domainNames[j]), requestErrorCode());

                for(k = 0; k < domainTextsNum; k++)
                {
                    gettext_spec   (
                                    context,
                                    _CS(domainTexts[k]),
                                    requestErrorCode()
                                   );

                    dgettext_spec  (
                                    context,
                                    _CS(domainNames[j]),
                                    _CS(domainTexts[k]),
                                    requestErrorCode()
                                   );

                    dcgettext_spec (
                                    context,
                                    _CS(domainNames[j]),
                                    _CS(domainTexts[k]),
                                    SUT_LC_MESSAGES,
                                    requestErrorCode()
                                   );
                }
                
                bindtextdomain_spec(context, _CS(domainNames[j]), _CS(domainPaths[i]), requestErrorCode());
            }
        }
    }

    return true;
}

scenario
bool textdomain_single_undef_scen()
{
    int k;

    iterate(int j = 0; j < domainUndefNamesNum; j++; ) 
    {
        for(k = 0; k < domainTextsNum; k++) 
        {
            bind_textdomain_codeset_spec(context, _CS(domainUndefNames[j]), _CS("ascii"), requestErrorCode());
            textdomain_spec(context, _CS(domainUndefNames[j]), requestErrorCode());
            
            gettext_spec   (
                            context, 
                            _CS(domainTexts[k]), 
                            requestErrorCode() 
                           ); 

            dgettext_spec  ( 
                            context, 
                            _CS(domainUndefNames[j]), 
                            _CS(domainTexts[k]), 
                            requestErrorCode() 
                           ); 
            
            dcgettext_spec ( 
                            context, 
                            _CS(domainUndefNames[j]), 
                            _CS(domainTexts[k]), 
                            SUT_LC_MESSAGES, 
                            requestErrorCode() 
                           ); 
        }
    }

    return true;
}

scenario
bool textdomain_plural_scen(void)
{
    int k, l, m;

    iterate(int i = 0; i < domainPathsNum; i++; )
    {
        iterate(int j = 0; j < domainNamesNum; j++; )
        {
            for(m = 0; m < 2; m++)
            {
                bind_textdomain_codeset_spec(context, _CS(domainNames[j]), _CS("ascii"), requestErrorCode());
                textdomain_spec(context, _CS(domainNames[j]), requestErrorCode());

                for(k = 0; k < domainTextsNum; k++)
                {
                    for(l = 0; l < domainPluralFormsNum; l++)
                    {
                        ngettext_spec   (
                                         context,
                                         _CS(domainTexts[k]),
                                         _CS(domainPluralTexts[k]),
                                         domainPluralForms[l],
                                         requestErrorCode()
                                        );
                                    
                        dngettext_spec  (
                                         context,
                                         _CS(domainNames[j]),
                                         _CS(domainTexts[k]),
                                         _CS(domainPluralTexts[k]),
                                         domainPluralForms[l],
                                         requestErrorCode()
                                        );

                        dcngettext_spec (
                                         context,
                                         _CS(domainNames[j]),
                                         _CS(domainTexts[k]),
                                         _CS(domainPluralTexts[k]),
                                         domainPluralForms[l],
                                         SUT_LC_MESSAGES,
                                         requestErrorCode()
                                        );
                    }
                }
                
                bindtextdomain_spec(context, _CS(domainNames[j]), _CS(domainPaths[i]), requestErrorCode());
            }
        }
    }

    return true;
}

scenario
bool textdomain_plural_undef_scen()
{
    int k, l;

    iterate(int j = 0; j < domainUndefNamesNum; j++; ) 
    {
        for(k = 0; k < domainTextsNum; k++) 
        {
            for(l = 0; l < domainPluralFormsNum; l++) 
            {
                bind_textdomain_codeset_spec(context, _CS(domainUndefNames[j]), _CS("ascii"), requestErrorCode());
                textdomain_spec(context, _CS(domainUndefNames[j]), requestErrorCode());

                ngettext_spec   (
                                 context,  
                                 _CS(domainTexts[k]),  
                                 _CS(domainPluralTexts[k]),   
                                 domainPluralForms[l],  
                                 requestErrorCode()  
                                );  
                                    
                dngettext_spec  (  
                                 context,  
                                 _CS(domainUndefNames[j]),  
                                 _CS(domainTexts[k]),  
                                 _CS(domainPluralTexts[k]),  
                                 domainPluralForms[l],  
                                 requestErrorCode()  
                                );  

                dcngettext_spec (  
                                 context,  
                                 _CS(domainUndefNames[j]),  
                                 _CS(domainTexts[k]),  
                                 _CS(domainPluralTexts[k]),  
                                 domainPluralForms[l],  
                                 SUT_LC_MESSAGES,  
                                 requestErrorCode()  
                                );  
            }
        }
    }

    return true;
}


/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
scenario dfsm locale_textdomain_scenario =
{
    .init = init_locale_textdomain_scenario,
    .finish = finish_locale_textdomain_scenario,
    .actions = {
                /* Full OLVER Edition Source Start */
                //locale_textdomain_modeltest_scen,
                /* Full OLVER Edition Source End */
                textdomain_single_scen,
                textdomain_single_undef_scen,
                textdomain_plural_scen,
                textdomain_plural_undef_scen,
                NULL
               }
};

bool main_locale_textdomain(int argc, char** argv)
{
    locale_textdomain_scenario(argc,argv);

    return true;
}
