/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "config/interpretation.seh"
#include "locale/collate/collate_config.h"
#include "locale/collate/collate_model.seh"

#pragma SEC subsystem collate "locale.collate"


/*
   The group of functions 'locale.collate' consists of:
       strcoll [2]
       strxfrm [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strcoll - string comparison using collating information

SYNOPSIS

    #include <string.h>

    int strcoll(const char *s1, const char *s2);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO
    C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
    the ISO C standard.

    The strcoll() function shall compare the string pointed to by s1 to the
    string pointed to by s2, both interpreted as appropriate to the LC_COLLATE
    category of the current locale.

    The strcoll() function shall not change the setting of errno if successful.

    Since no return value is reserved to indicate an error, an application
    wishing to check for error situations should set errno to 0, then call
    strcoll(), then check errno.

RETURN VALUE

    Upon successful completion, strcoll() shall return an integer greater than,
    equal to, or less than 0, according to whether the string pointed to by s1
    is greater than, equal to, or less than the string pointed to by s2 when
    both are interpreted as appropriate to the current locale. On error,
    strcoll() may set errno, but no return value is reserved to indicate an
    error.

ERRORS

    The strcoll() function may fail if:

    [EINVAL]

        The s1 or s2 arguments contain characters outside the domain of the
        collating sequence.

*/

specification
IntT strcoll_spec(CallContext context, CString* s1, CString* s2, ErrorCode* errno)
{
    pre
    {
        if(!POSIX_STRCOLL_FAILS_WITH_EINVAL)
        {
            /* [Implicit precondition.] */
            REQ("", "s1 should contain characters inside the domain of the collating sequence", TODO_REQ());
            REQ("", "s2 should contain characters inside the domain of the collating sequence", TODO_REQ());
        }

        /*
         * Since no return value is reserved to indicate an error, an application wishing
         * to check for error situations should set errno to 0, then call strcoll(),
         * then check errno.
         */
        /* [This is performed in the agent.] */
        IMPLEMENT_REQ("app.strcoll.03");

        return true;
    }
    post
    {
        /*
         * The strcoll() function shall not change the setting of errno if successful.
         */
        IMPLEMENT_REQ("strcoll.02");

        /*
         * On error, strcoll() may set errno, but no return value is reserved to
         * indicate an error.
         */
        IMPLEMENT_REQ("strcoll.04");

        ERROR_BEGIN(POSIX_STRCOLL, "strcoll.05", *errno != 0, *errno)
            /*
             * The strcoll() function may fail if:
             *
             * [EINVAL]
             *
             * The s1 or s2 arguments contain characters outside the domain of the
             * collating sequence.
             */
            ERROR_MAY(POSIX_STRCOLL, EINVAL, "strcoll.05.01", TODO_ERR(EINVAL))

        ERROR_END()

        /*
         * The strcoll() function shall compare the string pointed to by s1 to the string
         * pointed to by s2, both interpreted as appropriate to the LC_COLLATE category
         * of the current locale.
         *
         * Upon successful completion, strcoll() shall return an integer greater than,
         * equal to, or less than 0, according to whether the string pointed to by s1 is
         * greater than, equal to, or less than the string pointed to by s2 when both are
         * interpreted as appropriate to the current locale.
         */
        REQ("strcoll.01.01", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    strxfrm - string transformation

SYNOPSIS

    #include <string.h>

    size_t strxfrm(char *restrict s1, const char *restrict s2, size_t n);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO
    C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to
    the ISO C standard.

    The strxfrm() function shall transform the string pointed to by s2 and place
    the resulting string into the array pointed to by s1. The transformation is
    such that if strcmp() is applied to two transformed strings, it shall return
    a value greater than, equal to, or less than 0, corresponding to the result
    of strcoll() applied to the same two original strings. No more than n bytes
    are placed into the resulting array pointed to by s1, including the
    terminating null byte. If n is 0, s1 is permitted to be a null pointer. If
    copying takes place between objects that overlap, the behavior is undefined.

    The strxfrm() function shall not change the setting of errno if successful.

    Since no return value is reserved to indicate an error, an application
    wishing to check for error situations should set errno to 0, then call
    strxfrm(), then check errno.

RETURN VALUE

    Upon successful completion, strxfrm() shall return the length of the
    transformed string (not including the terminating null byte). If the value
    returned is n or more, the contents of the array pointed to by s1 are
    unspecified.

    On error, strxfrm() may set errno but no return value is reserved to
    indicate an error.

ERRORS

    The strxfrm() function may fail if:

    [EINVAL]

        The string pointed to by the s2 argument contains characters outside the
        domain of the collating sequence.

*/

specification
SizeT strxfrm_spec(CallContext context, CString* s1, CString* s2, SizeT n, ErrorCode* errno)
{
    pre
    {
        if (n != 0)
        {
            /*
             * If n is 0, s1 is permitted to be a null pointer.
             */
            /* [Implicitly: else s1 cannot be null.] */
            REQ("app.strxfrm.03", "s1 should not be NULL", s1 != NULL);
        }

        if(!POSIX_STRXFRM_FAILS_WITH_EINVAL)
        {
            /* [Implicit precondition.] */
            REQ("", "s2 should contain characters inside the domain of the collating sequence", TODO_REQ());
        }

        /*
         * If copying takes place between objects that overlap, the behavior is undefined.
         */
        IMPLEMENT_REQ("app.strxfrm.04");

        /*
         * Since no return value is reserved to indicate an error, an application wishing
         * to check for error situations should set errno to 0, then call strxfrm(),
         * then check errno.
         */
        /* [This is performed in the agent.] */
        IMPLEMENT_REQ("app.strxfrm.06");

        return true;
    }
    post
    {
        /*
         * The strxfrm() function shall not change the setting of errno if successful.
         */
        IMPLEMENT_REQ("strxfrm.05");

        /*
         * On error, strxfrm() may set errno but no return value is reserved to
         * indicate an error.
         */
        IMPLEMENT_REQ("strxfrm.09");

        ERROR_BEGIN(POSIX_STRXFRM, "strxfrm.10", *errno != 0, *errno)
            /*
             * The strxfrm() function may fail if:
             *
             * [EINVAL]
             *
             * The string pointed to by the s2 argument contains characters outside the
             * domain of the collating sequence.
             */
            ERROR_MAY(POSIX_STRXFRM, EINVAL, "strxfrm.10.01", TODO_ERR(EINVAL))

        ERROR_END()

        /*
         * No more than n bytes are placed into the resulting array pointed to by s1,
         * including the terminating null byte.
         */
        /* [Checked in the agent.] */
        IMPLEMENT_REQ("strxfrm.02");

        if (strxfrm_spec < n)
        {
            /*
             * Upon successful completion, strxfrm() shall return the length of the
             * transformed string (not including the terminating null byte).
             */
            REQ("strxfrm.07", "strxfrm should return the length of the transformed string",
                strxfrm_spec == length_CString(s1)
               );
        }

        return true;
    }
}


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

