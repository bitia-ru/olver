/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef FS_GLOB_MODEL_SEH
#define FS_GLOB_MODEL_SEH

#include "common/common_model.seh"

/*****************************************************************************/
/**                            Defines                                      **/
/*****************************************************************************/
#define GLOB_COVERAGE(glob, covid, covstr)                                    \
{                                                                             \
    if(glob == NULL)                                                          \
    {                                                                         \
        return { covid##_GlobIsNull,                                          \
            covstr ", glob is NULL" };                                        \
    }                                                                         \
    else if(glob->offs == 0 && glob->pathc == 0)                              \
    {                                                                         \
        return { covid##_OffsetIsZero_CountIsZero,                            \
            covstr ", offset is zero, count is zero" };                       \
    }                                                                         \
    else if(glob->offs == 0 && glob->pathc != 0)                              \
    {                                                                         \
        return { covid##_OffsetIsZero_CountIsNotZero,                         \
            covstr ", offset is zero, count is not zero" };                   \
    }                                                                         \
    else if(glob->offs != 0 && glob->pathc == 0)                              \
    {                                                                         \
        return { covid##_OffsetIsNotZero_CountIsZero,                         \
            covstr ", offset is not zero, count is zero" };                   \
    }                                                                         \
    else if(glob->offs != 0 && glob->pathc == glob->offs)                     \
    {                                                                         \
        return { covid##_OffsetIsNotZero_CountIsEqualToOffset,                \
            covstr ", offset is not zero, count is equal to offset" };        \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        return { covid##_OffsetIsNotZero_CountIsNotEqualToOffset,             \
            covstr ", offset is not zero, count is not equal to offset" };    \
    }                                                                         \
}                                                                             \

#define GLOB_PATTERN_COVERAGE(pattern, covid, covstr)                         \
{                                                                             \
    int i, j, size1, size2;                                                   \
    bool s, q, a, b;                                                          \
                                                                              \
    s = q = a = b = false;                                                    \
    size1 = size_List(pattern);                                               \
    for(i = 0; i < size1; i++)                                                \
    {                                                                         \
        GlobPatternItem *pattern_item = get_List(pattern, i);                 \
                                                                              \
        if(pattern_item->slash)                                               \
        {                                                                     \
            continue;                                                         \
        }                                                                     \
                                                                              \
        size2 = size_List(pattern_item->file_pattern);                        \
        for(j = 0; j < size2; j++)                                            \
        {                                                                     \
            GlobPrimaryPattern *primary_pattern =                             \
                get_List(pattern_item->file_pattern, j);                      \
                                                                              \
            switch(primary_pattern->type)                                     \
            {                                                                 \
            case GlobStringPattern:                                           \
                s = true;                                                     \
                break;                                                        \
            case GlobQuestionPattern:                                         \
                q = true;                                                     \
                break;                                                        \
            case GlobAsteriskPattern:                                         \
                a = true;                                                     \
                break;                                                        \
            case GlobBracketExpressionPattern:                                \
                b = true;                                                     \
                break;                                                        \
            }                                                                 \
        }                                                                     \
    }                                                                         \
                                                                              \
    switch((s ? 0x01 : 0x00) |                                                \
           (q ? 0x02 : 0x00) |                                                \
           (a ? 0x04 : 0x00) |                                                \
           (b ? 0x08 : 0x00))                                                 \
    {                                                                         \
        case  0:                                                              \
            return { covid##_Empty,                                           \
                covstr ", empty pattern" };                                   \
        case  1:                                                              \
            return { covid##_String,                                          \
                covstr ", string pattern" };                                  \
        case  2:                                                              \
            return { covid##_Question,                                        \
                covstr ", question pattern" };                                \
        case  3:                                                              \
            return { covid##_String_Question,                                 \
                covstr ", string and question patterns" };                    \
        case  4:                                                              \
            return { covid##_Asterisk,                                        \
                covstr ", asterisk pattern" };                                \
        case  5:                                                              \
            return { covid##_String_Asterisk,                                 \
                covstr ", string and asterisk patterns" };                    \
        case  6:                                                              \
            return { covid##_Question_Asterisk,                               \
                covstr ", question and asterisk patterns" };                  \
        case  7:                                                              \
            return { covid##_String_Question_Asterisk,                        \
                covstr ", string, question and asterisk patterns" };          \
        case  8:                                                              \
            return { covid##_Bracket,                                         \
                covstr ", bracket pattern" };                                 \
        case  9:                                                              \
            return { covid##_String_Bracket,                                  \
                covstr ", string and bracket patterns" };                     \
        case 10:                                                              \
            return { covid##_Question_Bracket,                                \
                covstr ", question and bracket patterns" };                   \
        case 11:                                                              \
            return { covid##_String_Question_Bracket,                         \
                covstr ", string, question and bracket patterns" };           \
        case 12:                                                              \
            return { covid##_Asterisk_Bracket,                                \
                covstr ", asterisk and bracket patterns" };                   \
        case 13:                                                              \
            return { covid##_String_Asterisk_Bracket,                         \
                covstr ", string, asterisk and bracket patterns" };           \
        case 14:                                                              \
            return { covid##_Question_Asterisk_Bracket,                       \
                covstr ", question, asterisk and bracket patterns" };         \
        case 15:                                                              \
            return { covid##_String_Question_Asterisk_Bracket,                \
                covstr ", string, question, asterisk and bracket patterns" }; \
    }                                                                         \
}

#define GLOB_ERRFUNC_COVERAGE(errfunc, covid, covstr)                         \
{                                                                             \
    if(errfunc == NULL)                                                       \
    {                                                                         \
        return { covid##_NullGlobErrorFunction,                               \
            covstr ", Null glob error function" };                            \
    }                                                                         \
    else if(errfunc->type == ZeroGlobErrorFunction)                           \
    {                                                                         \
        return { covid##_ZeroGlobErrorFunction,                               \
            covstr ", Zero glob error function" };                            \
    }                                                                         \
    else if(errfunc->type == OneGlobErrorFunction)                            \
    {                                                                         \
        return { covid##_OneGlobErrorFunction,                                \
            covstr ", One glob error function" };                             \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        return { covid##_ZeroOneGlobErrorFunction,                            \
            covstr ", Zero-one glob error function" };                        \
    }                                                                         \
}

/*****************************************************************************/
/**                               Glob Flags                                **/
/*****************************************************************************/

/*
 * This type represents flags used to control glob() and glob64().
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'glob.h'.
 */
typedef struct GlobFlags
{
    /* SUSv3 */
    bool err;           /* GLOB_ERR */
    bool mark;          /* GLOB_MARK */
    bool nosort;        /* GLOB_NOSORT */
    bool dooffs;        /* GLOB_DOOFFS */
    bool nocheck;       /* GLOB_NOCHECK */
    bool append;        /* GLOB_APPEND */
    bool noescape;      /* GLOB_NOESCAPE */
    /* LSB */
    bool period;        /* GLOB_PERIOD */
    bool magchar;       /* GLOB_MAGCHAR */
    bool altdirfunc;    /* GLOB_ALTDIRFUNC */
    bool brace;         /* GLOB_BRACE */
    bool nomagic;       /* GLOB_NOMAGIC */
    bool tilde;         /* GLOB_TILDE */
    bool onlydir;       /* GLOB_ONLYDIR */
    bool tilde_check;   /* GLOB_TILDE_CHECK */
} GlobFlags;

GlobFlags default_GlobFlags(void);

specification typedef GlobFlags GlobFlagsObj;

GlobFlagsObj* create_GlobFlagsObj(GlobFlags flags);

GlobFlagsObj* default_GlobFlagsObj(void);

/*****************************************************************************/
/**                            Glob Error Codes                             **/
/*****************************************************************************/

/*
 * This type represents error return values of glob() and glob64().
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'glob.h'.
 */
typedef enum GlobErrorCode
{
    SUT_GLOB_OK      =  0,
    SUT_GLOB_UNKNOWN = -1,
    SUT_GLOB_NOSPACE =  1,  /* GLOB_NOSPACE */
    SUT_GLOB_ABORTED =  2,  /* GLOB_ABORTED */
    SUT_GLOB_NOMATCH =  3,  /* GLOB_NOMATCH */
    SUT_GLOB_NOSYS     =  4   /* GLOB_NOSYS */
} GlobErrorCode;

/*****************************************************************************/
/**                              GlobT Type                                 **/
/*****************************************************************************/
typedef VoidTPtr GlobTPtr;

/*
 * This type represents glob_t type
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'glob.h'.
 */
specification typedef struct GlobT
{
    GlobTPtr address;
    SizeT pathc;
    SizeT offs;
    List *pathv;
    GlobFlags flags;

    // TODO:
    /*
    void (*gl_closedir) (void *);
    struct dirent *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
    */
} GlobT;

GlobT* create_GlobT
(
    GlobTPtr address,
    SizeT pathc,
    SizeT offs,
    List *pathv,
    GlobFlags flags
);

GlobT* default_GlobT(void);

GlobT* getGlobT(GlobTPtr address);

/*
 * Returns true, iff the lhs->pathv is the prefix of the rhs->pathv.
 */
bool isPrefix_GlobT(GlobT *lhs, GlobT *rhs);

/*****************************************************************************/
/**                             Glob64T Type                                **/
/*****************************************************************************/
typedef VoidTPtr Glob64TPtr;

/*
 * This type represents glob64_t type
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'glob.h'.
 */
specification typedef struct Glob64T
{
    Glob64TPtr address;
    SizeT pathc;
    SizeT offs;
    List *pathv;
    GlobFlags flags;

    // TODO:
    /*
    void (*gl_closedir) (void *);
    struct dirent64 *(*gl_readdir64) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
    */
} Glob64T;

Glob64T* create_Glob64T
(
    Glob64TPtr address,
    SizeT pathc,
    SizeT offs,
    List *pathv,
    GlobFlags flags
);

Glob64T* default_Glob64T(void);

Glob64T* getGlob64T(Glob64TPtr address);

/*
 * Returns true, iff the lhs->pathv is the prefix of the rhs->pathv.
 */
bool isPrefix_Glob64T(Glob64T *lhs, Glob64T *rhs);

/*****************************************************************************/
/**                           Glob Error Function                           **/
/*****************************************************************************/
typedef enum GlobErrorFunctionType
{
    ZeroGlobErrorFunction    = 0,
    OneGlobErrorFunction     = 1,
    ZeroOneGlobErrorFunction = 2
} GlobErrorFunctionType;

specification typedef struct GlobErrorFunctionCall
{
    CString *epath;
    ErrorCode *eerrno;
    IntT result;
} GlobErrorFunctionCall;

GlobErrorFunctionCall* create_GlobErrorFunctionCall
(
    CString *epath,
    ErrorCode *eerrno,
    IntT result
);

specification typedef struct GlobErrorFunction
{
    GlobErrorFunctionType type;
    IntT param;
    List *calls;
} GlobErrorFunction;

GlobErrorFunction* create_GlobErrorFunction(GlobErrorFunctionType type, IntT param);

GlobErrorFunction* default_GlobErrorFunction(void);

/*
 * Resets error function call history.
 */
void reset_GlobErrorFunction(GlobErrorFunction *errfunc);

/*
 * Returns true, iff the error function was called at least one time.
 */
Bool3 wasCalled_GlobErrorFunction(GlobErrorFunction *errfunc);

/*
 * Checks if the error function returned a non-zero value.
 */
Bool3 returnedNonZero_GlobErrorFunction(GlobErrorFunction *errfunc);

/*
 * Checks if the error function was called in proper cases.
 */
Bool3 checkCalls_GlobErrorFunction(CallContext context, GlobErrorFunction *errfunc);

/*****************************************************************************/
/**                         Glob Bracket Expression                         **/
/*****************************************************************************/
specification typedef struct GlobBracketExpression
{
    // TODO:
    int TODO;
} GlobBracketExpression;

GlobBracketExpression* create_GlobBracketExpression(void);

/*****************************************************************************/
/**                          Glob Primary Pattern                           **/
/*****************************************************************************/
typedef enum GlobPrimaryPatternType
{
    GlobStringPattern,
    GlobQuestionPattern,            /* ? */
    GlobAsteriskPattern,            /* * */
    GlobBracketExpressionPattern    /* [ */
} GlobPrimaryPatternType;

specification typedef struct GlobPrimaryPattern
{
    GlobPrimaryPatternType type;
    CString *word;
    GlobBracketExpression *bracket;
} GlobPrimaryPattern;

GlobPrimaryPattern* create_GlobPrimaryPattern
(
    GlobPrimaryPatternType type,
    CString *word,
    GlobBracketExpression* bracket
);

GlobPrimaryPattern* create_GlobStringPattern(CString *word);

GlobPrimaryPattern* create_GlobQuestionPattern(void);

GlobPrimaryPattern* create_GlobAsteriskPattern(void);

GlobPrimaryPattern* create_GlobBracketExpressionPattern(GlobBracketExpression *bracket);

/*****************************************************************************/
/**                           Glob File Pattern                             **/
/*****************************************************************************/

/* GlobPrimaryPattern-list */
typedef List GlobFilePattern;

GlobFilePattern* create_GlobFilePattern(void);

/*
 * Returns true iff, the pattern contains *, ? or [].
 */
bool containsPattern_GlobFilePattern(GlobFilePattern *file_pattern);

/*
 * Returns true iff, the name matches the pattern.
 */
bool doesNameMatch_GlobFilePattern(GlobFilePattern *file_pattern, CString *name);

/*
 * Returns true iff, each name in the list matches the pattern.
 */
bool doesNamesMatch_GlobFilePattern(GlobFilePattern *file_pattern, List *names);

/*****************************************************************************/
/**                           Glob Pattern Item                             **/
/*****************************************************************************/
specification typedef struct GlobPatternItem
{
    bool slash;
    GlobFilePattern *file_pattern;
} GlobPatternItem;

GlobPatternItem* create_GlobPatternItem(bool slash, GlobFilePattern *file_pattern);

GlobPatternItem* create_GlobSlashPatternItem(void);

GlobPatternItem* create_GlobFilePatternItem(GlobFilePattern *file);

/*****************************************************************************/
/**                             Glob Pattern                                **/
/*****************************************************************************/

/* GlobPatternItem-list */
typedef List GlobPattern;

GlobPattern* create_GlobPattern(void);

GlobPattern* parse_GlobPattern(CString *pattern, GlobFlags flags);

typedef enum FindErrorCode
{
    FIND_OK                = 0, /* Successful execution */
    FIND_UPTODATE_ERROR    = 1, /* Directories are not uptodate */
    FIND_PERMISSIONS_ERROR = 2  /* Permissions violation */
} FindErrorCode;

/*
 * Finds pathnames matching a pattern, returns search status.
 */
FindErrorCode find_GlobPattern
(
    CallContext context,
    GlobPattern *pattern,
    GlobFlags flags,
    GlobErrorFunction *errfunc,
    List *res
);


/*****************************************************************************/
/**                   Auxiliary Specification Functions                     **/
/*****************************************************************************/

/** setglob_spec **/
specification
void setglob_spec(CallContext context, GlobTPtr pglob, GlobT *glob);

/** setglob64_spec **/
specification
void setglob64_spec(CallContext context, Glob64TPtr pglob, Glob64T *glob64);

/*****************************************************************************/
/**                          Interface Functions                            **/
/*****************************************************************************/

/** glob_spec **/
specification
GlobErrorCode glob_spec(CallContext context, CString *pattern, GlobFlags flags,
                        GlobErrorFunction *errfunc, GlobTPtr pglob);

/** glob64_spec **/
specification
GlobErrorCode glob64_spec(CallContext context, CString *pattern, GlobFlags flags,
                          GlobErrorFunction *errfunc, Glob64TPtr pglob);

/** globfree_spec **/
specification
void globfree_spec(CallContext context, GlobTPtr pglob);

/** globfree64_spec **/
specification
void globfree64_spec(CallContext context, Glob64TPtr pglob);

/*****************************************************************************/
/**                            Helper Functions                             **/
/*****************************************************************************/

/*
 * Returns true, iff the list is sorted as defined by the current setting of
 * the LC_COLLATE category.
 */
bool isSorted_List(List *list);

#endif

