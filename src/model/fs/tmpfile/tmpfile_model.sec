/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "common/common_model.seh"
#include "process/process/process_common.seh"
#include "io/file/file_model.seh"
#include "fs/tmpfile/tmpfile_model.seh"
#include "fs/tmpfile/tmpfile_config.h"

#pragma SEC subsystem tmpfile "fs.tmpfile"

/*
   The group of functions 'fs.tmpfile' consists of:
       mkstemp [1]
       mkstemp64 [2]
       mktemp [1]
       tempnam [2]
       tmpfile [1]
       tmpfile64 [2]
       tmpnam [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    mkstemp - make a unique filename

SYNOPSIS

    [XSI]  #include <stdlib.h>
    int mkstemp(char *template);

DESCRIPTION

    The mkstemp() function shall replace the contents of the string pointed to
    by template by a unique filename, and return a file descriptor for the file
    open for reading and writing. The function thus prevents any possible race
    condition between testing whether the file exists and opening it for use.
    The string in template should look like a filename with six trailing 'X' s;
    mkstemp() replaces each 'X' with a character from the portable filename
    character set. The characters are chosen such that the resulting name does
    not duplicate the name of an existing file at the time of a call to
    mkstemp().

RETURN VALUE

    Upon successful completion, mkstemp() shall return an open file descriptor.
    Otherwise, -1 shall be returned if no suitable file could be created.

ERRORS

    No errors are defined.
*/

//This specification refers to: mkstemp, mkstemp64
specification
FileDescId mkstemp_spec( CallContext context, CString * templ, bool is64bits )
{
    if ( is64bits ) { FILTER( "mkstemp64" ); }
               else { FILTER( "mkstemp"   ); }

    pre
    {
        /*
         * [templ must be a string]
         */
        REQ( "", "templ must be a string", templ != NULL );

        /*
         * The string in template should look like a filename
         */
        REQ( "app.mkstemp.03.01", "", TODO_REQ() );

        /*
         * The string in template should look like a filename
         *
         * with six trailing 'X' s;
         */
        REQ( "app.mkstemp.03.02", "",
             T( length_CString( templ ) >= 6                                                                      ) &&
             T( equals( substringFrom_CString( templ, length_CString( templ ) - 6 ), create_CString( "XXXXXX" ) ) )
           );

        return true;
    }
    coverage C
    {
        return { MakeUniqueFilename, "Make a unique filename" };
    }
    post
    {
        if ( mkstemp_spec.filedesc == -1 )
        {
            /*
            * [Upon successful completion, mkstemp() shall return an open file descriptor.]
            * Otherwise, -1 shall be returned if no suitable file could be created.
            */
            REQ( "mkstemp.06.02;mkstemp64.mkstemp.06.02", "-1 shall be returned", true );
        }
        else
        {
            FileDescriptor * fileDescriptor = getFileDescriptor( mkstemp_spec );
            FileDescription * fileDescription;
            CString * prePrefix ;
            CString * postPrefix;

            /*
            * Upon successful completion, mkstemp() shall return an open file descriptor.
            */
            REQ( "mkstemp.06.01;mkstemp64.mkstemp.06.01", "shall return an open file descriptor", fileDescriptor != NULL );

            fileDescription = fileDescriptor->description;

            /*
            * and return a file descriptor for the file open for reading and writing.
            */
            REQ( "mkstemp.01.02;mkstemp64.mkstemp.01.02", "a file descriptor for the file open for reading and writing",
                                                          fileDescription->access_mode == ReadWrite
               );

            /*
            * The function thus prevents any possible race condition between testing whether
            * the file exists and opening it for use.
            */
            REQ( "mkstemp.02;mkstemp64.mkstemp.02", "", TODO_REQ() );

            /*
            * mkstemp() replaces each 'X' with a character from the portable filename
            * character set.
            */
            prePrefix  = substring_CString( @templ, 0, length_CString( @templ ) - 6 );
            postPrefix = substring_CString( templ , 0, length_CString( templ  ) - 6 );
            REQ( "mkstemp.04;mkstemp64.mkstemp.04", "mkstemp() replaces each 'X'", equals( prePrefix, postPrefix ) );

            /*
            * The characters are chosen such that the resulting name does not duplicate the
            * name of an existing file at the time of a call to mkstemp().
            */
            REQ( "mkstemp.05;mkstemp64.mkstemp.05", "", TODO_REQ() );

        }

        return true;
    }

    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    mktemp - make a unique filename (LEGACY)

SYNOPSIS

    [XSI]  #include <stdlib.h>
    char *mktemp(char *template);

DESCRIPTION

    The mktemp() function shall replace the contents of the string pointed to
    by template by a unique filename and return template. The application shall
    initialize template to be a filename with six trailing 'X' s;mktemp() shall
    replace each 'X' with a single byte character from the portable filename
    character set.

RETURN VALUE

    The mktemp() function shall return the pointer template. If a unique name
    cannot be created, template shall point to a null string.

ERRORS

    No errors are defined.
*/
specification
CString * mktemp_spec( CallContext context, CString * templ )
{
    pre
    {
        /*
         * [templ must be a string]
         */
        REQ( "", "templ must be a string", templ != NULL );

        /*
         * The application shall initialize template to be a filename
         */
        REQ( "app.mktemp.02.01", "", TODO_REQ() );

        /*
         * The application shall initialize template to be a filename
         *
         * with six trailing 'X' s;
         */
        REQ( "app.mktemp.02.02", "",
             T( length_CString( templ ) >= 6                                                                      ) &&
             T( equals( substringFrom_CString( templ, length_CString( templ ) - 6 ), create_CString( "XXXXXX" ) ) )
           );

        return true;
    }
    coverage C
    {
        return { MakeUniqueFilename, "Make a unique filename" };
    }
    post
    {
        if ( mktemp_spec == NULL )
        {
            /*
             * If a unique name cannot be created, template shall point to a null string.
             */
            REQ( "mktemp.04.02", "If a unique name cannot be created, template shall point to a null string", true );
        }
        else
        {
            CString * prePrefix ;
            CString * postPrefix;

            /*
             * The mktemp() function shall replace the contents of the string pointed to by
             * template by a unique filename
             */
            REQ( "mktemp.01.01", "", TODO_REQ() );

            /*
             * and return template.
             */
            REQ( "mktemp.01.02", "return template", equals( mktemp_spec, templ ) );

            /*
             * mktemp() shall replace each 'X' with a single byte character from the portable
             * filename character set.
             */
            prePrefix  = substring_CString( @templ, 0, length_CString( @templ ) - 6 );
            postPrefix = substring_CString( templ , 0, length_CString( templ  ) - 6 );
            REQ( "mktemp.03", "mktemp() shall replace each 'X'", equals( prePrefix, postPrefix ) );
        }

        /*
         * The mktemp() function shall return the pointer template.
         */
        REQ( "mktemp.04.01", "The mktemp() function shall return the pointer template", equals( mktemp_spec, templ ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    tempnam - create a name for a temporary file

SYNOPSIS

    [XSI]  #include <stdio.h>
    char *tempnam(const char *dir, const char *pfx);

DESCRIPTION

    The tempnam() function shall generate a pathname that may be used for a
    temporary file.

    The tempnam() function allows the user to control the choice of a
    directory. The dir argument points to the name of the directory in which
    the file is to be created.If dir is a null pointer or points to a string
    which is not a name for an appropriate directory, the path prefix defined
    as P_tmpdir in the <stdio.h> header shall be used. If that directory is not
    accessible, an implementation-defined directory may be used.

    Many applications prefer their temporary files to have certain initial
    letter sequences in their names.The pfx argument should be used for this.
    This argument may be a null pointer or point to a string of up to five
    bytes to be used as the beginning of the filename.

    Some implementations of tempnam() may use tmpnam() internally. On such
    implementations, if called more than {TMP_MAX} times in a single process,
    the behavior is implementation-defined.

RETURN VALUE

    Upon successful completion, tempnam() shall allocate space for a string,
    put the generated pathname in that space, and return a pointer to it. The
    pointer shall be suitable for use in a subsequent call to free().Otherwise,
    it shall return a null pointer and set errno to indicate the error.

ERRORS

    The tempnam() function shall fail if:

    [ENOMEM]
    Insufficient storage space is available.
*/
specification
CString * tempnam_spec( CallContext context, CString * dir, CString * pfx, ErrorCode * errno )
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * Otherwise, it shall return a null pointer and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_TEMPNAM, "tempnam.07.02", tempnam_spec==NULL, *errno)
            /*
             * The tempnam() function shall fail if:
             *
             * [ENOMEM] Insufficient storage space is available.
             */
            ERROR_SHALL(POSIX_TEMPNAM, ENOMEM, "tempnam.08.01", TODO_ERR(ENOMEM) )
        ERROR_END()

        /*
         * The tempnam() function allows the user to control the choice of a directory.
         */
        REQ( "tempnam.02", "The tempnam() function allows the user to control the choice of a directory", true );

        if ( dir != NULL ) {
            /*
             * The dir argument points to the name of the directory in which the file is to be
             * created.
             */
            REQ( "tempnam.03", "the directory in which the file is to be created",
                               startsWithC_String( tempnam_spec, dir )
               );
        } else {
            /*
             * If dir is a null pointer or points to a string which is not a name for an
             * appropriate directory, the path prefix defined as P_tmpdir in the <stdio.h&
             * gt; header shall be used.
             */
            REQ( "tempnam.04", "", TODO_REQ() );

            /*
             * If that directory is not accessible, an implementation-defined directory may be
             * used.
             */
            REQ( "tempnam.05", "", TODO_REQ() );
        }

        if ( pfx == NULL ) {
            /*
             * The pfx argument should be used for this.
             *
             * This argument may be a null pointer
             */
            REQ( "tempnam.06.01", "a null pointer", true );
        } else {
            CString * onlyName = substringFrom_CString( tempnam_spec, lastIndexOfCharC_String( tempnam_spec, '/' ) + 1 );
            CString * pfx5 = ( length_CString( pfx ) <= 5 ? pfx : substring_CString( pfx, 0, 5 ) );
            /*
             * The pfx argument should be used for this.
             *
             * a string of up to five bytes to be used as the beginning of the filename
             */
            REQ( "tempnam.06.02", "a string of up to five bytes to be used as the beginning of the filename",
                                  startsWithC_String( onlyName, pfx5 )
               );
        }

        /*
         * Some implementations of tempnam() may use tmpnam() internally. On such
         * implementations, if called more than {TMP_MAX} times in a single process, the
         * behavior is implementation-defined.
         */
        REQ( "tempnam.09", "", TODO_REQ() );

        /*
         * Upon successful completion, tempnam() shall allocate space for a string, put
         * the generated pathname in that space, and return a pointer to it.
         */
        REQ( "tempnam.07.01.01", "", TODO_REQ() );

        /*
         * The pointer shall be suitable for use in a subsequent call to free().
         */
        REQ( "tempnam.07.01.02", "", TODO_REQ() );


        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    tmpfile - create a temporary file

SYNOPSIS

    #include <stdio.h>
    FILE *tmpfile(void);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The tmpfile() function shall create a temporary file and open a
    corresponding stream. The file shall be automatically deleted when all
    references to the file are closed. The file is opened as in fopen() for
    update (w+).

    [CX]  In some implementations, a permanent file may be left behind if the
    process calling tmpfile() is killed while it is processing a call to
    tmpfile().

    An error message may be written to standard error if the stream cannot be
    opened.

RETURN VALUE

    Upon successful completion, tmpfile() shall return a pointer to the stream
    of the file that is created. Otherwise, it shall return a null pointer [CX]
    and set errno to indicate the error.

ERRORS

    The tmpfile() function shall fail if:

        [EINTR]
        [CX]  A signal was caught during tmpfile().

        [EMFILE]
        [CX]  {OPEN_MAX} file descriptors are currently open in the calling
        process.

        [ENFILE]
        [CX]  The maximum allowable number of files is currently open in the
        system.

        [ENOSPC]
        [CX]  The directory or file system which would contain the new file
        cannot be expanded.

        [EOVERFLOW]
        [CX]  The file is a regular file and the size of the file cannot be
        represented correctly in an object of type off_t.

    The tmpfile() function may fail if:

        [EMFILE]
        [CX]  {FOPEN_MAX} streams are currently open in the calling process.

        [ENOMEM]
        [CX]  Insufficient storage space is available.
*/

/** tmpfile_spec **/
//This specification refers to: tmpfile, tmpfile64
specification
FILETPtr tmpfile_spec( CallContext context, ErrorCode * errno, bool is64bits )
{
    if ( is64bits ) { FILTER( "tmpfile64" ); }
               else { FILTER( "tmpfile"   ); }

    pre
    {
        return true;
    }
    coverage C
    {
        return { CreateTemporaryFile, "Create a temporary file" };
    }
    post
    {
        StreamState * streamState = construct_StreamState( context, tmpfile_spec );

        /*
         * Otherwise, it shall return a null pointer [CX] and set errno to indicate the
         * error.
         */
        ERROR_BEGIN( POSIX_TMPFILE, "tmpfile.06.02;tmpfile64.tmpfile.06.02", isNULL_VoidTPtr( tmpfile_spec ), * errno )
            /*
             * The tmpfile() function shall fail if:
             *
             * [EINTR] [CX] A signal was caught during tmpfile().
             */
            ERROR_SHALL( POSIX_TMPFILE, EINTR, "tmpfile.07.01;tmpfile64.tmpfile.07.01", TODO_ERR( EINTR ) )

            /*
             * The tmpfile() function shall fail if:
             *
             * [EMFILE] [CX] {OPEN_MAX} file descriptors are currently open in the calling
             * process.
             */
            ERROR_SHALL( POSIX_TMPFILE, EMFILE, "tmpfile.07.02;tmpfile64.tmpfile.07.02", TODO_ERR( EMFILE ) )

            /*
             * The tmpfile() function shall fail if:
             *
             * [ENFILE] [CX] The maximum allowable number of files is currently open in the
             * system.
             */
            ERROR_SHALL( POSIX_TMPFILE, ENFILE, "tmpfile.07.03;tmpfile64.tmpfile.07.03", TODO_ERR( ENFILE ) )

            /*
             * The tmpfile() function shall fail if:
             *
             * [ENOSPC] [CX] The directory or file system which would contain the new file
             * cannot be expanded.
             */
            ERROR_SHALL( POSIX_TMPFILE, ENOSPC, "tmpfile.07.04;tmpfile64.tmpfile.07.04", TODO_ERR( ENOSPC ) )

            /*
             * The tmpfile() function shall fail if:
             *
             * [EOVERFLOW] [CX] The file is a regular file and the size of the file cannot be
             * represented correctly in an object of type off_t.
             */
            ERROR_SHALL( POSIX_TMPFILE, EOVERFLOW, "tmpfile.07.05;tmpfile64.tmpfile.07.05", TODO_ERR( EOVERFLOW ) )

            /*
             * The tmpfile() function may fail if:
             *
             * [EMFILE] [CX] {FOPEN_MAX} streams are currently open in the calling process.
             */
            ERROR_MAY( POSIX_TMPFILE, EMFILE, "tmpfile.08.01;tmpfile64.tmpfile.08.01", TODO_ERR( EMFILE ) )

            /*
             * The tmpfile() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY( POSIX_TMPFILE, ENOMEM, "tmpfile.08.02;tmpfile64.tmpfile.08.02", TODO_ERR( ENOMEM ) )
        ERROR_END()

        /*
         * The file shall be automatically deleted when all references to the file are
         * closed.
         */
        REQ( "tmpfile.02;tmpfile64.tmpfile.02", "", TODO_REQ() );

        /*
         * The file is opened as in fopen() for update (w+).
         */
        REQ( "tmpfile.03;tmpfile64.tmpfile.03", "The file is opened as in fopen() for update (w+)",
                                                streamState != NULL && size_StreamState( streamState ) == 0      &&
                                                                       isAllowReading_StreamState( streamState ) &&
                                                                       isAllowWriting_StreamState( streamState )
           );

        /*
         * In some implementations, a permanent file may be left behind if the process
         * calling tmpfile() is killed while it is processing a call to tmpfile().
         */
        REQ( "tmpfile.04;tmpfile64.tmpfile.04", "", TODO_REQ() );

        /*
         * An error message may be written to standard error if the stream cannot be
         * opened.
         */
        REQ( "tmpfile.05;tmpfile64.tmpfile.05", "", TODO_REQ() );

        /*
         * Upon successful completion, tmpfile() shall return a pointer to the stream of
         * the file that is created.
         */
        REQ( "tmpfile.06.01;tmpfile64.tmpfile.06.01", "return a pointer to the stream", streamState != NULL );

        return true;
    }

    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    tmpnam - create a name for a temporary file

SYNOPSIS

    #include <stdio.h>
    char *tmpnam(char *s);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The tmpnam() function shall generate a string that is a valid filename and
    that is not the same as the name of an existing file. The function is
    potentially capable of generating {TMP_MAX} different strings, but any or
    all of them may already be in use by existing files and thus not be
    suitable return values.

    The tmpnam() function generates a different string each time it is called
    from the same process, up to {TMP_MAX} times.If it is called more than
    {TMP_MAX} times, the behavior is implementation-defined.

    The implementation shall behave as if no function defined in this volume of
    IEEE Std 1003.1-2001, except tempnam(), calls tmpnam().

    [CX] If the application uses any of the functions guaranteed to be
    available if either _POSIX_THREAD_SAFE_FUNCTIONS or _POSIX_THREADS is
    defined, the application shall ensure that the tmpnam() function is called
    with a non-NULL parameter.

RETURN VALUE

    Upon successful completion, tmpnam() shall return a pointer to a string.If
    no suitable string can be generated, the tmpnam() function shall return a
    null pointer.

    If the argument s is a null pointer, tmpnam() shall leave its result in an
    internal static object and return a pointer to that object. Subsequent
    calls to tmpnam() may modify the same object. If the argument s is not a
    null pointer, it is presumed to point to an array of at least L_tmpnam
    chars; tmpnam() shall write its result in that array and shall return the
    argument as its value.

ERRORS

    No errors are defined.
*/
specification
CString * tmpnam_spec( CallContext context, IntT array_length )
{
    pre
    {
        /*
         * If the application uses any of the functions guaranteed to be available if
         * either _POSIX_THREAD_SAFE_FUNCTIONS or _POSIX_THREADS is defined, the
         * application shall ensure that the tmpnam() function is called with a non-NULL
         * parameter.
         */
        REQ( "app.tmpnam.05", "", TODO_REQ() );

        /*
         * If the argument s is not a null pointer, it is presumed to point to an array of
         * at least L_tmpnam chars;
         */
        REQ( "tmpnam.10.01", "", TODO_REQ() );

        return true;
    }
    coverage C
    {
        if ( array_length == -1 ) { return { UseStaticPlace, "tmpnam() leave its result in an internal static object" }; }
                             else { return { UseUserPlace  , "tmpnam() write its result in an user array"             }; }
    }
    post
    {
        /*
         * The function is potentially capable of generating {TMP_MAX} different strings,
         * but any or all of them may already be in use by existing files and thus not be
         * suitable return values.
         */
        REQ( "tmpnam.02", "", TODO_REQ() );

        /*
         * The tmpnam() function generates a different string each time it is called from
         * the same process, up to {TMP_MAX} times.
         */
        REQ( "tmpnam.03.01", "", TODO_REQ() );

        /*
         * If it is called more than {TMP_MAX} times, the behavior is implementation-
         * defined.
         */
        REQ( "tmpnam.03.02", "", true );

        /*
         * The implementation shall behave as if no function defined in this volume of
         * IEEE Std 1003.1-2001, except tempnam(), calls tmpnam().
         */
        REQ( "tmpnam.04", "", TODO_REQ() );

        if ( tmpnam_spec == NULL )
        {
            /*
             * If no suitable string can be generated, the tmpnam() function shall return a
             * null pointer.
             */
            REQ( "tmpnam.07", "no suitable string can be generated", true );
        }
        else
        {
            /*
             * Upon successful completion, tmpnam() shall return a pointer to a string
             */
            REQ( "tmpnam.06", "Upon successful completion, tmpnam() shall return a pointer to a string", true );

#ifdef NewCTesK
            if ( C == C.UseStaticPlace )
#else
            if ( coverage( C ) == UseStaticPlace )
#endif
            {
                /*
                 * If the argument s is a null pointer, tmpnam() shall leave its result in an
                 * internal static object and return a pointer to that object.
                 */
                REQ( "tmpnam.08", "", TODO_REQ() );

                /*
                 * Subsequent calls to tmpnam() may modify the same object.
                 */
                REQ("tmpnam.09", "", TODO_REQ());
            }
            else // coverage( C ) == UseUserPlace
            {
                /*
                 * tmpnam() shall write its result in that array and shall return the argument as
                 * its value.
                 */
                REQ( "tmpnam.10.02", "", TODO_REQ() );
            }
        }



        return true;
    }
}


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
