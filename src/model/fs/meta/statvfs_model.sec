/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "fs/meta/statvfs_model.seh"
#include "data/errno_model.seh"
#include "config/interpretation.seh"
#include "fs/meta/statvfs_config.h"
#include "io/file/file_model.seh"
#include "system/system/system_model.seh"
#include "fs/meta/meta_model.seh"

#pragma SEC subsystem statvfs "fs.meta"



/*
   The group of functions 'fs.meta.statvfs' consists of:
       fstatvfs [2]
       fstatvfs64 [2]
       statvfs [2]
       statvfs64 [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fstatvfs, statvfs - get file system information

SYNOPSIS

[XSI] #include <sys/statvfs.h>

    int fstatvfs(int fildes, struct statvfs *buf);

    int statvfs(const char *restrict path, struct statvfs *restrict buf);

DESCRIPTION

    The fstatvfs() function shall obtain information about the file system
    containing the file referenced by fildes.

    The statvfs() function shall obtain information about the file system
    containing the file named by path.

    For both functions, the buf argument is a pointer to a statvfs structure
    that shall be filled. Read, write, or execute permission of the named file
    is not required.

    The following flags can be returned in the f_flag member:

    ST_RDONLY

        Read-only file system.

    ST_NOSUID

        Setuid/setgid bits ignored by exec.

    It is unspecified whether all members of the statvfs structure have
    meaningful values on all file systems.

RETURN VALUE

    Upon successful completion, statvfs() shall return 0. Otherwise, it shall
    return -1 and set errno to indicate the error.

ERRORS

    The fstatvfs() and statvfs() functions shall fail if:

        [EIO]

            An I/O error occurred while reading the file system.

        [EINTR]

            A signal was caught during execution of the function.

        [EOVERFLOW]

            One of the values to be returned cannot be represented correctly in
            the structure pointed to by buf.

    The fstatvfs() function shall fail if:

        [EBADF]

            The fildes argument is not an open file descriptor.

    The statvfs() function shall fail if:

        [EACCES]

            Search permission is denied on a component of the path prefix.

        [ELOOP]

            A loop exists in symbolic links encountered during resolution of
            the path argument.

        [ENAMETOOLONG]

            The length of a pathname exceeds {PATH_MAX} or a pathname component
            is longer than {NAME_MAX}.

        [ENOENT]

            A component of path does not name an existing file or path is an
            empty string.

        [ENOTDIR]

            A component of the path prefix of path is not a directory.

    The statvfs() function may fail if:

        [ELOOP]

            More than {SYMLOOP_MAX} symbolic links were encountered during
            resolution of the path argument.

        [ENAMETOOLONG]

            Pathname resolution of a symbolic link produced an intermediate
            result whose length exceeds {PATH_MAX}.
*/

specification
IntT fstatvfs_spec(CallContext context, FileDescId fildes, MountPointStatus* buf, ErrorCode* errno)
{
    pre
    {
        /*
         * For both functions, the buf argument is a pointer to a statvfs structure
         */
        REQ("app.fstatvfs.08", "buf is a pointer to a statvfs", buf != NULL);

        return true;
    }
    post
    {

        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_FSTATVFS, "fstatvfs.04;fstatvfs.05;fstatvfs.06",
            fstatvfs_spec == -1, *errno)

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EIO]
         *
         * An I/O error occurred while reading the file system.
         */
            ERROR_UNCHECKABLE(POSIX_FSTATVFS, EIO, "fstatvfs.05.01", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during execution of the function.
         */
            ERROR_UNCHECKABLE(POSIX_FSTATVFS, EINTR, "fstatvfs.05.02", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly in the
         * structure pointed to by buf.
         */
            ERROR_SHALL3(POSIX_FSTATVFS, EOVERFLOW, "fstatvfs.05.03", TODO_ERR(EOVERFLOW))

        /*
         * The fstatvfs() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not an open file descriptor.
         */
            ERROR_SHALL3(POSIX_FSTATVFS, EBADF, "fstatvfs.06.01",
                shall_isEBADF_fstatvfs(context, fildes, errno))

        ERROR_END()

        if(*errno)
        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        REQ("fstatvfs.04", "shall return -1", fstatvfs_spec == -1);

        /*
         * Upon successful completion, statvfs() shall return 0.
         */
        REQ("fstatvfs.03", "Successful completion", fstatvfs_spec == 0 && *errno == SUT_EOK);

        /*
         * that shall be filled.
         */
        REQ("fstatvfs.10", "", TODO_REQ());

        /*
         * Read, write, or execute permission of the named file is not required.
         */
        REQ("fstatvfs.09", "", TODO_REQ());



        return true;
    }
}

#define shall_isEBADF_fstatvfs64 shall_isEBADF_fstatvfs

specification
IntT fstatvfs64_spec(CallContext context, FileDescId fildes, MountPointStatus* buf, ErrorCode* errno)
{
    pre
    {
        /*
         * For both functions, the buf argument is a pointer to a statvfs structure
         */
        REQ("app.fstatvfs64.fstatvfs.08", "buf is a pointer to a statvfs", buf != NULL);

        return true;
    }
    post
    {
        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_FSTATVFS64,
            "fstatvfs64.fstatvfs.04;fstatvfs64.fstatvfs.05;fstatvfs64.fstatvfs.06",
            fstatvfs64_spec == -1, *errno)
        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EIO]
         *
         * An I/O error occurred while reading the file system.
         */
            ERROR_UNCHECKABLE(POSIX_FSTATVFS64, EIO, "fstatvfs64.fstatvfs.05.01", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during execution of the function.
         */
            ERROR_UNCHECKABLE(POSIX_FSTATVFS64, EINTR, "fstatvfs64.fstatvfs.05.02", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly in the
         * structure pointed to by buf.
         */
            ERROR_SHALL3(POSIX_FSTATVFS64, EOVERFLOW, "fstatvfs64.fstatvfs.05.03", TODO_ERR(EOVERFLOW))

        /*
         * The fstatvfs() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not an open file descriptor.
         */
            ERROR_SHALL3(POSIX_FSTATVFS64, EBADF, "fstatvfs64.fstatvfs.06.01",
                shall_isEBADF_fstatvfs64(context, fildes, errno))

        ERROR_END()

        if(*errno)
        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        REQ("fstatvfs64.fstatvfs.04", "shall return -1", fstatvfs64_spec == -1);

        /*
         * Upon successful completion, statvfs() shall return 0.
         */
        REQ("fstatvfs64.fstatvfs.03", "Successful completion",
            fstatvfs64_spec == 0 && *errno == SUT_EOK);

        /*
         * that shall be filled.
         */
        REQ("fstatvfs64.fstatvfs.10", "", TODO_REQ());

        /*
         * Read, write, or execute permission of the named file is not required.
         */
        REQ("fstatvfs64.fstatvfs.09", "", TODO_REQ());



        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6

IEEE Std 1003.1, 2004 Edition

Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fstatvfs, statvfs - get file system information

SYNOPSIS

[XSI] #include <sys/statvfs.h>

    int fstatvfs(int fildes, struct statvfs *buf);

    int statvfs(const char *restrict path, struct statvfs *restrict buf);

DESCRIPTION

    The fstatvfs() function shall obtain information about the file system
    containing the file referenced by fildes.

    The statvfs() function shall obtain information about the file system
    containing the file named by path.

    For both functions, the buf argument is a pointer to a statvfs structure
    that shall be filled. Read, write, or execute permission of the named file
    is not required.

    The following flags can be returned in the f_flag member:

    ST_RDONLY

        Read-only file system.

    ST_NOSUID

        Setuid/setgid bits ignored by exec.

    It is unspecified whether all members of the statvfs structure have
    meaningful values on all file systems.

RETURN VALUE

    Upon successful completion, statvfs() shall return 0. Otherwise, it shall
    return -1 and set errno to indicate the error.

ERRORS

    The fstatvfs() and statvfs() functions shall fail if:

        [EIO]

            An I/O error occurred while reading the file system.

        [EINTR]

            A signal was caught during execution of the function.

        [EOVERFLOW]

            One of the values to be returned cannot be represented correctly in
            the structure pointed to by buf.

    The fstatvfs() function shall fail if:

        [EBADF]

            The fildes argument is not an open file descriptor.

    The statvfs() function shall fail if:

        [EACCES]

            Search permission is denied on a component of the path prefix.

        [ELOOP]

            A loop exists in symbolic links encountered during resolution of
            the path argument.

        [ENAMETOOLONG]

            The length of a pathname exceeds {PATH_MAX} or a pathname component
            is longer than {NAME_MAX}.

        [ENOENT]

            A component of path does not name an existing file or path is an
            empty string.

        [ENOTDIR]

            A component of the path prefix of path is not a directory.

    The statvfs() function may fail if:

        [ELOOP]

            More than {SYMLOOP_MAX} symbolic links were encountered during
            resolution of the path argument.

        [ENAMETOOLONG]

            Pathname resolution of a symbolic link produced an intermediate
            result whose length exceeds {PATH_MAX}.
*/

#define shall_isEOVERFLOW_statvfs shall_isEOVERFLOW_fstatvfs
#define shall_isEACCES_statvfs shall_isEACCES_xstat
#define shall_isENAMETOOLONG_statvfs shall_isENAMETOOLONG_xstat
#define shall_isENOENT_statvfs shall_isENOENT_xstat
#define shall_isENOTDIR_statvfs shall_isENOTDIR_xstat
#define may_isENAMETOOLONG_statvfs shall_isENAMETOOLONG_xstat

specification
IntT statvfs_spec(CallContext context, CString* path, MountPointStatus* buf, ErrorCode* errno)
{
    pre
    {
        /*
         * For both functions, the buf argument is a pointer to a statvfs structure
         */
        REQ("app.statvfs.08", "buf is a pointer to a statvfs", buf != NULL);

        REQ("", "path is a pointer to string", path != NULL);

        return true;
    }
    post
    {
        Bool3 eloop = False_Bool3;
        FileSystem* fs = getFileSystem(context);
        CString* resolved = resolvePath_Ext(context, fs, path, &eloop);

        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_STATVFS, "statvfs.04;statvfs.05;statvfs.06;statvfs.07",
            statvfs_spec == -1, *errno)
        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EIO]
         *
         * An I/O error occurred while reading the file system.
         */
            ERROR_UNCHECKABLE(POSIX_STATVFS, EIO, "statvfs.05.01", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during execution of the function.
         */
            ERROR_UNCHECKABLE(POSIX_STATVFS, EINTR, "statvfs.05.02", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly in the
         * structure pointed to by buf.
         */
            ERROR_SHALL3(POSIX_STATVFS, EOVERFLOW, "statvfs.05.03", TODO_ERR(EOVERFLOW))

        /*
         * The statvfs() function shall fail if:
         *
         * [EACCES]
         *
         * Search permission is denied on a component of the path prefix.
         */
            ERROR_SHALL3(POSIX_STATVFS, EACCES, "statvfs.06.01",
                shall_isEACCES_statvfs(context, fs, path))

        /*
         * The statvfs() function shall fail if:
         *
         * [ELOOP]
         *
         * A loop exists in symbolic links encountered during resolution of the path
         * argument.
         */
            ERROR_SHALL3(POSIX_STATVFS, ELOOP, "statvfs.06.02", eloop)

        /*
         * The statvfs() function shall fail if:
         *
         * [ENAMETOOLONG]
         *
         * The length of a pathname exceeds {PATH_MAX} or a pathname component is longer
         * than {NAME_MAX}.
         */
            ERROR_SHALL3(POSIX_STATVFS, ENAMETOOLONG, "statvfs.06.03",
                shall_isENAMETOOLONG_statvfs(context, path))

        /*
         * The statvfs() function shall fail if:
         *
         * [ENOENT]
         *
         * A component of path does not name an existing file or path is an empty string.
         */
            ERROR_SHALL3(POSIX_STATVFS, ENOENT, "statvfs.06.04",
                shall_isENOENT_statvfs(context, fs, resolved))

        /*
         * The statvfs() function shall fail if:
         *
         * [ENOTDIR]
         *
         * A component of the path prefix of path is not a directory.
         */
            ERROR_SHALL3(POSIX_STATVFS, ENOTDIR, "statvfs.06.05",
                shall_isENOTDIR_statvfs(context, fs, getParentDir_Path(resolved)))

        /*
         * The statvfs() function may fail if:
         *
         * [ELOOP]
         *
         * More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
         * the path argument.
         */
            ERROR_MAY3(POSIX_STATVFS, ELOOP, "statvfs.07.01", eloop)

        /*
         * The statvfs() function may fail if:
         *
         * [ENAMETOOLONG]
         *
         * Pathname resolution of a symbolic link produced an intermediate result whose
         * length exceeds {PATH_MAX}.
         */
            ERROR_MAY3(POSIX_STATVFS, ENAMETOOLONG, "statvfs.07.02",
                may_isENAMETOOLONG_statvfs(context, resolved))

        ERROR_END()

        if(*errno)
        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        REQ("statvfs.04", "shall return -1", statvfs_spec == -1);

        /*
         * Upon successful completion, statvfs() shall return 0.
         */
        REQ("statvfs.03", "Successful completion", statvfs_spec == 0 && *errno == SUT_EOK);

        /*
         * that shall be filled.
         */
        REQ("statvfs.10", "", TODO_REQ());

        /*
         * Read, write, or execute permission of the named file is not required.
         */
        REQ("statvfs.09", "", TODO_REQ());



        return true;
    }
}

#define shall_isEOVERFLOW_statvfs64  shall_isEOVERFLOW_statvfs
#define shall_isEACCES_statvfs64 shall_isEACCES_statvfs
#define shall_isENAMETOOLONG_statvfs64 shall_isENAMETOOLONG_statvfs
#define shall_isENOENT_statvfs64 shall_isENOENT_statvfs
#define shall_isENOTDIR_statvfs64 shall_isENOTDIR_statvfs
#define may_isENAMETOOLONG_statvfs64 may_isENAMETOOLONG_statvfs

specification
IntT statvfs64_spec(CallContext context, CString* path, MountPointStatus* buf, ErrorCode* errno)
{
    pre
    {
        /*
         * For both functions, the buf argument is a pointer to a statvfs structure
         */
        REQ("app.statvfs64.statvfs.08", "buf is a pointer to a statvfs", buf != NULL);

        REQ("", "path is a pointer to string", path != NULL);

        return true;
    }
    post
    {

        Bool3 eloop = False_Bool3;
        FileSystem* fs = getFileSystem(context);
        CString* resolved = resolvePath_Ext(context, fs, path, &eloop);

        DUMP("post");

        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_STATVFS64,
            "statvfs64.statvfs.04;statvfs64.statvfs.05;statvfs64.statvfs.06;statvfs64.statvfs.07",
            statvfs64_spec == -1, *errno)
        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EIO]
         *
         * An I/O error occurred while reading the file system.
         */
            ERROR_UNCHECKABLE(POSIX_STATVFS64, EIO, "statvfs64.statvfs.05.01", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during execution of the function.
         */
            ERROR_UNCHECKABLE(POSIX_STATVFS64, EINTR, "statvfs64.statvfs.05.02", "Difficult check")

        /*
         * The fstatvfs() and statvfs() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly in the
         * structure pointed to by buf.
         */
            ERROR_SHALL3(POSIX_STATVFS64, EOVERFLOW, "statvfs64.statvfs.05.03", TODO_ERR(EOVERFLOW))

        /*
         * The statvfs() function shall fail if:
         *
         * [EACCES]
         *
         * Search permission is denied on a component of the path prefix.
         */
            ERROR_SHALL3(POSIX_STATVFS64, EACCES, "statvfs64.statvfs.06.01",
                shall_isEACCES_statvfs64(context, fs, path))

        /*
         * The statvfs() function shall fail if:
         *
         * [ELOOP]
         *
         * A loop exists in symbolic links encountered during resolution of the path
         * argument.
         */
            ERROR_SHALL3(POSIX_STATVFS64, ELOOP, "statvfs64.statvfs.06.02", eloop)

        /*
         * The statvfs() function shall fail if:
         *
         * [ENAMETOOLONG]
         *
         * The length of a pathname exceeds {PATH_MAX} or a pathname component is longer
         * than {NAME_MAX}.
         */
            ERROR_SHALL3(POSIX_STATVFS64, ENAMETOOLONG, "statvfs64.statvfs.06.03",
                shall_isENAMETOOLONG_statvfs64(context, path))

        /*
         * The statvfs() function shall fail if:
         *
         * [ENOENT]
         *
         * A component of path does not name an existing file or path is an empty string.
         */
            ERROR_SHALL3(POSIX_STATVFS64, ENOENT, "statvfs64.statvfs.06.04",
                shall_isENOENT_statvfs64(context, fs, resolved))

        /*
         * The statvfs() function shall fail if:
         *
         * [ENOTDIR]
         *
         * A component of the path prefix of path is not a directory.
         */
            ERROR_SHALL3(POSIX_STATVFS64, ENOTDIR, "statvfs64.statvfs.06.05",
                shall_isENOTDIR_statvfs64(context, fs, getParentDir_Path(resolved)))

        /*
         * The statvfs() function may fail if:
         *
         * [ELOOP]
         *
         * More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
         * the path argument.
         */
            ERROR_MAY3(POSIX_STATVFS64, ELOOP, "statvfs64.statvfs.07.01", eloop)

        /*
         * The statvfs() function may fail if:
         *
         * [ENAMETOOLONG]
         *
         * Pathname resolution of a symbolic link produced an intermediate result whose
         * length exceeds {PATH_MAX}.
         */
            ERROR_MAY3(POSIX_STATVFS64, ENAMETOOLONG, "statvfs64.statvfs.07.02",
                may_isENAMETOOLONG_statvfs64(context, resolved))

        ERROR_END()

        if(*errno)
        /*
         * Otherwise, it shall return -1 and set errno to indicate the error.
         */
        REQ("statvfs64.statvfs.04", "shall return -1", statvfs64_spec == -1);

        /*
         * Upon successful completion, statvfs() shall return 0.
         */
        REQ("statvfs64.statvfs.03", "Successful completion", statvfs64_spec == 0 && *errno == SUT_EOK);

        /*
         * that shall be filled.
         */
        REQ("statvfs64.statvfs.10", "", TODO_REQ());

        /*
         * Read, write, or execute permission of the named file is not required.
         */
        REQ("statvfs64.statvfs.09", "", TODO_REQ());



        return true;
    }
}

/********************************************************************/
/**                       Specification Types                      **/
/********************************************************************/

specification typedef struct MountPointStatus MountPointStatus = {};

MountPointStatus* create_MountPointStatus(
    ULongT      bsize,      //  File system block size.
    ULongT      frsize,     //  Fundamental file system block size.
    FsBlkcntT   blocks,     //  Total number of blocks on file system in units
                            //      of f_frsize.
    FsBlkcntT   bfree,      //  Total number of free blocks.
    FsBlkcntT   bavail,     //  Number of free blocks available to
                            //      non-privileged process.
    FsFilcntT   files,      //  Total number of file serial numbers.
    FsFilcntT   ffree,      //  Total number of free file serial numbers.
    FsFilcntT   favail,     //  Number of file serial numbers available to
                            //      non-privileged process.
    ULLongT     fsid,     //  File system ID.
    Bool3       isReadOnly, //  Bit mask of f_flag values.
    Bool3       isNoSUID,   //  Bit mask of f_flag values.
    ULLongT     namemax  //  Maximum filename length.
                                          )
{
    return create(&type_MountPointStatus, bsize, frsize, blocks, bfree, bavail,
        files, ffree, favail, fsid, isReadOnly, isNoSUID, namemax);
}

MountPointStatus* create_emptyMountPointStatus()
{
    return create_MountPointStatus(0, 0, 0, 0, 0, 0, 0, 0, 0, Unknown_Bool3,
                                                Unknown_Bool3, 0);
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

Bool3 shall_isEBADF_fstatvfs(CallContext context, FileDescId fildes,
                                                            ErrorCode* errno)
{
    if(*errno == SUT_EBADF)
    {
        CString* path=getPath_FileDescId(fildes);

        return path == NULL ? Unknown_Bool3 : True_Bool3;
    }

    return Unknown_Bool3;
}
