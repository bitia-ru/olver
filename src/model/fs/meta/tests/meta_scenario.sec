/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "fs/meta/tests/meta_scenario.seh"
#include "io/file/file_model.seh"
#include "fs/fs/tests/fs_scenario.seh"

#define TS_DEBUG

#ifdef TS_DEBUG

#define WAIT 0
/********************************************************************/
/**                          Debug Functions                       **/
/********************************************************************/

static AssertionExit system_assertion_handler;

static void myAssertionExit(const char * format, va_list  arg_list)
{
    DUMPV(format, arg_list);
    getchar();
    system_assertion_handler(format, arg_list);
}

static void assert_init()
{
    system_assertion_handler = atAssertion(myAssertionExit);

}
#endif

/********************************************************************/
/**                Scenario variable definitions                   **/
/********************************************************************/
CallContext context;

static char * pathsChr[]={

    //Symlink paths...
    "/tester/test_system/Dir_Link_Deep/abs_dir_link/file2.c",

    "/tester/test_system/Dir_Link/file.c",

    "/tester/test_system",
    "/tester/test_system/Dir_Link/Dir_Link2",
    "/tester/test_system/Dir_Link/Dir_Link2/file2.c",

    "/tester/test_system/Link_Test/Link_Test2/abs_dir_link",
    "/tester/test_system/Dir_Link/Dir_Link2",

    "/tester/test_system/Dir_Link/Dir_Link2",
    "/tester/test_system/Dir_Link_Deep/abs_dir_link",
    "/tester/test_system/Link_Test/file.c",
    "/tester/test_system/Link_Test/abs_link",
    "/tester/test_system/Link_Test/rel_link",

    "/tester/test_system/Dir_Link/file.c",
    "/tester/test_system/Dir_Link/abs_link",
    "/tester/test_system/Dir_Link/rel_link",

    "/tester/test_system/Link_Test/Link_Test2/file2.c",
    "/tester/test_system/Link_Test/Link_Test2/abs_link2",
    "/tester/test_system/Link_Test/Link_Test2/rel_link2",

    "/tester/test_system/Link_Test/Dir_Link2/file2.c",
    "/tester/test_system/Link_Test/Dir_Link2/abs_link2",
    "/tester/test_system/Link_Test/Dir_Link2/rel_link2",

    "/tester/test_system/Dir_Link/Link_Test2/file2.c",
    "/tester/test_system/Dir_Link/Link_Test2/abs_link2",
    "/tester/test_system/Dir_Link/Link_Test2/rel_link2",

    "/tester/test_system/Dir_Link/Dir_Link2/file2.c",
    "/tester/test_system/Dir_Link/Dir_Link2/abs_link2",
    "/tester/test_system/Dir_Link/Dir_Link2/rel_link2"
};

static char * paths_testChr[]={
    "",
    "/tester"
};

static int paths_num=sizeof(pathsChr)/sizeof(char*);
static int paths_test_num=sizeof(paths_testChr)/sizeof(char*);

static CString * paths[sizeof(pathsChr)/sizeof(char*)];
static CString * paths_test[sizeof(paths_testChr)/sizeof(char*)];


/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/
static bool init_fs_meta_meta_scenario(int argc, char** argv)
{
    int i;
#ifdef TS_DEBUG
    assert_init();
#endif

    context=getContext();
    initPathSystemConfiguration();

    // make sure process has appropriate priviledges
    INIT_SCENARIO_ACTION( makeSureProcessHasAppropriatePrivileges(context) );

    // update the current working directory of the process
    INIT_SCENARIO_ACTION( updateProcessWorkDirectory(context) );

    // prepare test data dir
    INIT_SCENARIO_ACTION( createTestScenarioSandboxDir(context) );

    for(i=0;i<paths_num;i++)
    {
        paths[i] = getTestScenarioSandboxPathCh( pathsChr[i] );
    }

    for(i=0;i<paths_test_num;i++)
    {
        paths_test[i] = getTestScenarioSandboxPathCh( paths_testChr[i] );
    }

    return true;
}

static void finish_fs_meta_meta_scenario(void)
{
    removeTestScenarioSandboxDir(context);

    TEST_SCENARIO_VERDICT_VERBOSE(fs_meta_meta_scenario);
}

Object* getFsMetaMetaState(void)
{
    return create_Integer(0);
}

Map* saveFsMetaMetaModelState(void)
{
    return clone(systems);
}

void restoreFsMetaMetaModelState(Map* saved_state)
{
    systems = saved_state;
}

bool isFsMetaMetaModelStateStationary(void)
{
    return true;
}

scenario
bool fs_meta_meta_creat_scenario_scen()
{
    FilePermission* perm=create_FilePermission(true, true, true);
    FilePermissions* mode=create_FilePermissions(perm, perm, perm,
                            Unknown_Bool3,Unknown_Bool3,Unknown_Bool3);
    struct OpenFlags flags={ReadWrite, Nonblocking, false, true, false, false,
                                                                false, false};
    FileStatus* fstat=create_emptyFileStatus();

//    __lxstat_spec(context, getRelativeTextPathCh(""), fstat, requestErrorCode());
//    __lxstat_spec(context, getRelativeTextPathCh("/tester"), fstat,
//                                                        requestErrorCode());

    mkdir_spec(context, SANDBOX_FILE("/tester"),
                                                    mode, requestErrorCode());
    mkdir_spec(context, SANDBOX_FILE("/tester/test_system"),
                                                    mode, requestErrorCode());
    mkdir_spec(context, SANDBOX_FILE("/tester/test_system/Link_Test"),
                                                    mode, requestErrorCode());
    mkdir_spec(context, SANDBOX_FILE("/tester/test_system/Link_Test/Link_Test2"),
                                                   mode, requestErrorCode());

    open_spec(context, SANDBOX_FILE("/tester/test_system/Link_Test/file.c"),
                    flags, mode, requestErrorCode(), false);
    open_spec(context, SANDBOX_FILE("/tester/test_system/Link_Test/Link_Test2/file2.c"),
                    flags, mode, requestErrorCode(), false);

    symlink_spec(context, SANDBOX_FILE("/tester/test_system/Link_Test"),
                SANDBOX_FILE("/tester/test_system/Dir_Link"), requestErrorCode(), cancel_status);

    symlink_spec(context, SANDBOX_FILE("Link_Test2"),
        SANDBOX_FILE("/tester/test_system/Dir_Link/Dir_Link2"), requestErrorCode(), cancel_status);

    symlink_spec(context, SANDBOX_FILE("/tester/test_system/Dir_Link/Dir_Link2"),
            SANDBOX_FILE("/tester/test_system/Dir_Link_Deep"), requestErrorCode(), cancel_status);
    symlink_spec(context, SANDBOX_FILE("/tester/test_system/Link_Test/file.c"),
        SANDBOX_FILE("/tester/test_system/Link_Test/abs_link"), requestErrorCode(), cancel_status);
    symlink_spec(context, create_CString("file.c"),
        SANDBOX_FILE("/tester/test_system/Link_Test/rel_link"), requestErrorCode(), cancel_status);
    symlink_spec(context,
        SANDBOX_FILE("/tester/test_system/Link_Test/Link_Test2/file2.c"),
        SANDBOX_FILE("/tester/test_system/Link_Test/Link_Test2/abs_link2"),
        requestErrorCode(), cancel_status);
    symlink_spec(context, create_CString("file2.c"),
        SANDBOX_FILE("/tester/test_system/Link_Test/Link_Test2/rel_link2"),
        requestErrorCode(), cancel_status);

    symlink_spec(context, SANDBOX_FILE("/tester/test_system/Dir_Link/Dir_Link2"),
        SANDBOX_FILE("/tester/test_system/Dir_Link/Dir_Link2/abs_dir_link"),
        requestErrorCode(), cancel_status);

    return true;
}
scenario
bool fs_meta_meta_remove_scenario_scen()
{
    recursive_remove(context, SANDBOX_FILE("/tester/test_system"));

    return true;
}

scenario
bool fs_meta_meta_init_scenario_scen()
{
    CString* path;
    File* file;
    FileSystem* fs=getFileSystem(context);

    iterate(int i=0;i<paths_num;i++;)
    {
        path=paths[i];
        registerFileFileSystem_Ext2(context, fs, path);
        ts_sleep_msec(WAIT);
    }

    VERBOSE("*****************************END OF INIT******************");

    return true;
}

scenario
bool fs_meta__xstat_simple_scen()
{
    FileStatus* fs;
    CString* str;

    iterate(int i=0;i<paths_num;i++;)
    {
        str=paths[i];
        fs=create_emptyFileStatus();
        __xstat_spec(context, 3, str, fs, requestErrorCode());
        ts_sleep_msec(WAIT);
    }


    return true;
}
scenario
bool fs_meta__lxstat_simple_scen()
{
    FileStatus* fs;
    CString* str;

    iterate(int i=0;i<paths_num;i++;)
    {
        str=paths[i];
        fs=create_emptyFileStatus();
        __lxstat_spec(context, 3, str, fs, requestErrorCode());
        ts_sleep_msec(WAIT);
    }

    return true;
}

scenario
bool fs_meta__fxstat_simple_scen()
{
    FileStatus* fstat, *buff;
    CString* str, *resolved;
    struct OpenFlags fl={ReadOnly, Blocking, false, false, false, false,
                                                                false, false};
    FileDescId fildes;
    FileSystem* fs=getFileSystem(context);

    iterate(int i=0;i<paths_num;i++;)
    {
        str=paths[i];
        fstat=create_emptyFileStatus();
        buff=create_emptyFileStatus();
        if(__xstat_spec(context, 3, str, buff, requestErrorCode())!=-1)
        {
            /*FIXME: fildes=*/
            fildes = open_spec(context, str, fl, buff->permissions, requestErrorCode(), false);
            __fxstat_spec(context, 3, fildes, fstat, requestErrorCode());
        }
    }

    return true;
}

scenario
bool fs_meta__xstat64_simple_scen()
{
    FileStatus* fs;
    CString* str;

    iterate(int i=0;i<paths_num;i++;)
    {
        str=paths[i];
        fs=create_emptyFileStatus();
        __xstat64_spec(context, 3, str, fs, requestErrorCode());
        ts_sleep_msec(WAIT);
    }


    return true;
}
scenario
bool fs_meta__lxstat64_simple_scen()
{
    FileStatus* fs;
    CString* str;

    iterate(int i=0;i<paths_num;i++;)
    {
        str=paths[i];
        fs=create_emptyFileStatus();
        __lxstat64_spec(context, 3, str, fs, requestErrorCode());
        ts_sleep_msec(WAIT);
    }

    return true;
}

scenario
bool fs_meta__fxstat64_simple_scen()
{
    FileStatus* fstat, *buff;
    CString* str, *resolved;
    struct OpenFlags fl={ReadOnly, Blocking, false, false, false, false,
                                                                false, true};
    FileDescId fildes;
    FileSystem* fs=getFileSystem(context);

    iterate(int i=0;i<paths_num;i++;)
    {
        str=paths[i];
        fstat=create_emptyFileStatus();
        buff=create_emptyFileStatus();
        if(__xstat64_spec(context, 3, str, buff, requestErrorCode())!=-1)
        {
            /*FIXME: fildes=*/
            fildes = open_spec(context, str, fl, buff->permissions, requestErrorCode(), false);
            __fxstat64_spec(context, 3, fildes, fstat, requestErrorCode());
        }
    }

    return true;
}

scenario
bool fs_meta_utime_non_null_simple_scen()
{
    UTimBuf* times;
    CString* path;

    iterate(int i=0;i<paths_num;i++;)
    {
        path=paths[i];
        times=create_UTimBuf(12, 13);
        utime_spec(context, path, times, requestErrorCode());
//        if(FEDORA==1)
//            ts_sleep_msec(2000);
    }

    return true;
}

scenario
bool fs_meta_utime_null_simple_scen()
{
    CString* path;

    iterate(int i=0;i<paths_num;i++;)
    {
        path=paths[i];
        utime_spec(context, path, NULL, requestErrorCode());
//        if(FEDORA==1)
//            ts_sleep_msec(2000);
    }

    return true;
}

scenario
bool fs_meta_utimes_non_null_simple_scen()
{
    TimeVal* tmp1, *tmp2;
    List* times=create_List(&type_TimeVal);
    CString* path;

    iterate(int i=0;i<paths_num;i++;)
    {
        path=paths[i];
        tmp1=create_TimeVal(12, 500000);
        tmp2=create_TimeVal(100000, 500001);
        append_List(times, tmp1);
        append_List(times, tmp2);
        utimes_spec(context, path, times, requestErrorCode());
        clear_List(times);
//        if(FEDORA==1)
//            ts_sleep_msec(2000);
    }

    return true;
}

scenario
bool fs_meta_utimes_null_simple_scen()
{
    CString* path;

    iterate(int i=0;i<paths_num;i++;)
    {
        path=paths[i];
        utimes_spec(context, path, NULL, requestErrorCode());
//        if(FEDORA==1)
//            ts_sleep_msec(2000);
    }

    return true;
}
scenario dfsm fs_meta_meta_scenario =
{
    .init = init_fs_meta_meta_scenario,
    .finish = finish_fs_meta_meta_scenario,
    /*.getState = getFsMetaMetaState,
    .saveModelState = (PtrSaveModelState)saveFsMetaMetaModelState,
    .restoreModelState = (PtrRestoreModelState)restoreFsMetaMetaModelState,
    .isStationaryState =
               (PtrIsStationaryState)isFsMetaMetaModelStateStationary,*/
    .actions = {
                fs_meta_meta_creat_scenario_scen,
                fs_meta_meta_init_scenario_scen,
                fs_meta_utime_null_simple_scen,
                fs_meta__xstat_simple_scen,
                fs_meta__lxstat_simple_scen,
                fs_meta_utimes_non_null_simple_scen,
                fs_meta__fxstat_simple_scen,

                fs_meta__xstat64_simple_scen,
                fs_meta_utimes_null_simple_scen,
                fs_meta__lxstat64_simple_scen,
                fs_meta__fxstat64_simple_scen,
                fs_meta_utime_non_null_simple_scen,
                fs_meta_meta_remove_scenario_scen,
                NULL
               }
};


#ifdef FS_META_META_LOCAL_MAIN


void reinitTestSystem(void)
{
    reinitControlCenter();
    initCommonModel();
    initCommonMedia();
    initCommonScenarioState();

    initSystemConfiguration();
    initSystemModel();
    initProcessModel();
    initPThreadModel();

    initIoFileSubsystem();
    initFsFsSubsystem();
    initFsDirSubsystem();
    initFsSymlinkSubsystem();
    initProcessProcessSubsystem();

    initFsMetaSubsystem();
}


bool main_fs_meta_meta(int argc, char** argv)
{
    int ind =0;
    fs_meta_meta_scenario(argc, argv);

//    fs_meta_meta_scenario(argc, argv);
//    while(fs_meta_meta_scenario(argc, argv)) ind++;
//    verbose("***** INDEX:%d ************\n", ind++);

    return true;
}



int main(int argc, char** argv)
{
    initTestSystem();
    loadSUT();

    // Set up tracer
    //setTraceEncoding("windows-1251");

    // Run test scenario
    addTraceToFile("trace.xml");
    main_fs_meta_meta(argc, argv);

    //  unloadSUT();
    return 0;
}
#endif

