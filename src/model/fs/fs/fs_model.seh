/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef FS_MODEL_SEH
#define FS_MODEL_SEH

#include "common/common_model.seh"
#include "data/sys/types_model.seh"
#include "data/time_model.seh"

/********************************************************************/
/**                         File Permissions                       **/
/********************************************************************/
specification typedef struct FilePermission
{
  bool read;
  bool write;
  bool execute;
} FilePermission;

specification typedef struct FilePermissions
{
  FilePermission* owner;
  FilePermission* group;
  FilePermission* other;
  Bool3        set_uid;     // Set-user-ID on execution
  Bool3        set_gid;    // Set-group-ID on execution
  Bool3        set_vtx;     // On directories, restricted deletion flag
 } FilePermissions;

// TO DO:
// S_ISUID  Set-user-ID on execution. 
// S_ISGID  Set-group-ID on execution. 
// S_ISVTX [XSI]  On directories, restricted deletion flag.  
FilePermission* create_FilePermission( bool read, bool write, bool execute);
FilePermissions* create_FilePermissions( FilePermission* owner, FilePermission* group, FilePermission* other, Bool3 set_uid, Bool3 set_gid, Bool3 set_vtx );

FilePermission* create_FilePerm(const char *permstr);
FilePermissions* create_FilePermissions_String(const char *permstr);


/********************************************************************/
/**                           File Kind                            **/
/********************************************************************/
typedef enum FileKind
{
  UnknownFileKind = -1,
  RegularFile,
  BlockFile,
  CharacterFile,
  FIFOFile,
  DirectoryFile,
  SymbolicLinkFile,
  Socket,

  MessageQueue,
  SemaphoreFile,
  SharedMemoryObject,
  TypedMemoryObject
} FileKind;


specification typedef FileKind FileKindObj;
FileKindObj *create_FileKindObj(FileKind kind);

/********************************************************************/
/**                          File Status                           **/
/********************************************************************/
specification typedef struct FileStatus
{
  DevT             dev;         // Device ID of device containing file
  InoT             ino;         // File serial number (dev + ino should be unique)
  FileKind         kind;        // Type of file
  FilePermissions* permissions; // Permissions 
  NLinkT           nlink;       // Number of hard links to the file
  UidT             uid;         // User ID of file
  GidT             gid;         // Group ID of file
  DevT             rdev;         // Device ID (if file is character or block special)
  OffT             size; // For regular files, the file size in bytes. 
              // For symbolic links, the length in bytes of the 
              // pathname contained in the symbolic link.
              // For a shared memory object, the length in bytes.
              // For other file types, the use of this field is unspecified.
  TimeT        atime;       // Time of last access
  TimeT        mtime;       // Time of last data modification
  TimeT        ctime;       // Time of last status change  

  BlksizeT       blksize; // A file system-specific preferred I/O block size for this object. 
                 // In some file system types, this may vary from file to file.
  BlkcntT        blocks;  // Number of blocks allocated for this object
  
} FileStatus;


/********************************************************************/
/**                          Upward Link                           **/
/********************************************************************/
specification typedef struct UpwardLink
{
  FileId   directory;
  CString* filename;
} UpwardLink;

UpwardLink* create_UpwardLink( FileId directory, CString* filename );


/********************************************************************/
/**                             File                               **/
/********************************************************************/
specification typedef struct File
{
  FileId           fileid;
  // Parents
  Set*             parents;     // UpwardLink-set
  // File meta info
  FileKind         kind;        // Type of file
  DevTObj*         dev;         // Device ID of device containing file
  InoTObj*         ino;         // File serial number (dev + ino should be unique)
  FilePermissions* permissions; // Permissions

  NLinkTObj*       nlink;       // Number of hard links to the file

  UidTObj*         uid;         // User ID of file
  GidTObj*         gid;         // Group ID of file

  DevTObj*         rdev;         // Device ID (if file is character or block special)
  OffTObj*         size; // For regular files, the file size in bytes. 
                          // For symbolic links, the length in bytes of the 
                          // pathname contained in the symbolic link.
                          // For a shared memory object, the length in bytes.

                          // For other file types, the use of this field is unspecified.
  TimeTObj*    atime;       // Time of last access
  TimeTObj*    mtime;       // Time of last data modification
  TimeTObj*    ctime;       // Time of last status change

  BlksizeTObj*     blksize; // A file system-specific preferred I/O block size for this object. 
                            // In some file system types, this may vary from file to file.
  BlkcntTObj*      blocks;  // Number of blocks allocated for this object

  bool             atime_updated;    // atime update flag
  bool             mtime_updated;    // mtime update flag
  bool             ctime_updated;    // ctime update flag
  // File Data Descriptor
  Object*          descriptor;   
} File;

File* create_FileById( FileId fileid );

File* create_File(
  FileId           fileid,
  Set*             parents,
  FileKind         kind,
  DevTObj*         dev,
  InoTObj*         ino,
  FilePermissions* permissions,

  NLinkTObj*       nlink,

  UidTObj*         uid,
  GidTObj*         gid,

  DevTObj*         rdev,
  OffTObj*         size,
  TimeTObj*    atime,
  TimeTObj*    mtime,
  TimeTObj*    ctime,

  BlksizeTObj*     blksize,
  BlkcntTObj*      blocks,

  bool             atime_updated,
  bool             mtime_updated,
  bool             ctime_updated,
  Object*          descriptor
);

FilePermissions* getPermissions_File( File* file );
void setPermissions_File( File* file, FilePermissions* permissions );

UidTObj* getUserId_File( File* file );
void setUserId_File( File* file, UidTObj* uid );

UidTObj* getGroupId_File( File* file );
void setGroupId_File( File* file, GidTObj* gid );

int getUpwardLinksCount_File(File *file);
UpwardLink *getUpwardLinkAt_File(File *file, int index);

/********************************************************************/
/**                         Directory Entry                        **/
/********************************************************************/
/*
specification typedef struct DirectoryEntry
{
  CString* filename;
  FileId   fileid;
} DirectoryEntry;

DirectoryEntry* create_DirectoryEntry( CString* filename, FileId fileid );
*/

/********************************************************************/
/**                     Directory File Descriptor                  **/
/********************************************************************/
specification typedef struct DirectoryDescriptor
{
  Map* files;  // CString -m-> FileId
  bool uptodate;    // flag denotes, if Directory Descriptor synchronized with real directory
  bool modified;  // flag denotes, if Directory Descriptor file list was modified
} DirectoryDescriptor;

DirectoryDescriptor* create_DirectoryDescriptor(void);


/********************************************************************/
/** FileSearchResult                                               **/
/********************************************************************/
specification typedef struct FileSearchResult
{
    File *file;
    File *last;     // last component found in File System for path
    CString *rest_path;  // rest of path searched
} FileSearchResult;
FileSearchResult *create_FileSearchResult();


/********************************************************************/
/**                          File System                           **/
/********************************************************************/
specification typedef struct FileSystem
{
  // FileId of the root directory of the file system
  FileId     root;
  // Files
  Map*       files;  // FileId -m-> File
  // Internal Counter of FileId
  Identifier counter;
} FileSystem;


FileSystem* create_FileSystem(
    FileId     root,
    Map*       files,
    Identifier counter
    );
FileSystem* create_FileSystemBySystemId(SystemId systemid);
FileSystem* findFileSystem( Map* file_systems, CallContext context);
FileSystem* findFileSystem_SystemId( Map* file_systems, SystemId systemid );

File* registerFile( FileSystem* file_system, CString* path );
File* registerDirectory( FileSystem* file_system, CString* path );
void setDirectoryFile_File(FileSystem *file_system, File *new_directory);
File* registerFileInDir( FileSystem* file_system, File *directory, CString *filename);
File* registerSymLink( FileSystem *file_system, CString *path, CString *destination);
void setSymLink_File( FileSystem *file_system, File *file, CString *destination);
CString *resolveSymLink(FileSystem *file_system, CString *path);
CString *resolveAbsolutePath_Ext(CallContext context, FileSystem *fs, CString *path, Bool3 *eloop);
CString *resolvePath_Ext(CallContext context, FileSystem *fs, CString *path, Bool3 *eloop);
// the following function does not resolve last component of path. Thus, when applied to symlinks, 
// it resolves path to symlinks theirself.
CString *resolvePathSymLink_Ext(CallContext context, FileSystem *fs, CString *path, Bool3 *eloop);
File *getSymLink_File(CallContext context, FileSystem *fs, File *symlink, Bool3 *eloop);

File* registerFile_Kind( FileSystem *file_system, CString *path, FileKind kind);
void setKind_File(FileSystem *file_system, File *file, FileKind kind);

// check, whether file specified by path has following kind
Bool3 isFileKindOf_FileSystem(FileSystem *fs, CString *path, FileKind kind);


File* registerFile_FileStatus(FileSystem *file_system, CString *path, FileStatus *status);

File* getFile_FileId( FileId fileid );
File* getFile_FileId_Ext( FileSystem *file_system, FileId fileid );

File* getFile_Directory( File* directory, CString* filename );
File* getFile_Directory_Ext( FileSystem *file_system, File* directory, CString* filename);

File* getFile_FileSystem( FileSystem* file_system, CString* path );

FileSearchResult* getFile_FileSystem_Ext( FileSystem* file_system, CString *path);

void unregisterFile( FileSystem *file_system, File *file);

int getFileCount_Directory(File *file);
File* getFileAt_Directory(FileSystem *file_system, File *file, int index);
CString* getFileNameAt_Directory(FileSystem *file_system, File *file, int index);


Bool3 isEmpty_Directory(FileSystem *file_system, File *file);
Bool3 isOfKind_File(File *file, FileKind kind);

bool isModified_Directory(FileSystem *file_system, File *directory);
void setModified_Directory(FileSystem *file_system, File *directory, bool modified);

CString *getName_File( FileSystem *file_system, File *file );
CString *getPath_File( FileSystem *file_system, File *file );

File *getDirectory_FileSystem(FileSystem *file_system, CString *path);
bool isUptodate_Directory(File *file);

bool doesFileExist_Directory( File* directory, CString* filename );
Bool3 doesFileExist_FileSystem( FileSystem* file_system, CString* path );

/* register file and do uptodate checks */
File *fileExist_FileSystem( FileSystem *file_system, CString* path, FileKind kind);

NLinkTObj *incLinksCount_File(FileSystem *file_system, File *file, NLinkT delta);
int getLinksCount_File(FileSystem *file_system, File *file);

File *getParentDirectory_UpwardLink(FileSystem *file_system, UpwardLink *uplink);
File *getTheOnlyParentDirectory_File(FileSystem *file_system, File *file);
bool isDirectoryUplink_Name(FileSystem *file_system, CString *filename);

Bool3 isDescendantOf_Directory(FileSystem *file_system, File *descendant, File *ancestor);
Bool3 isDescendantOfItself_Directory(FileSystem *file_system, File *directory);

Bool3 isDescendantOf_Directory_SymLinks(FileSystem *file_system, File *descendant, File *ancestor);
Bool3 isDescendantOfItself_Directory_SymLinks(FileSystem *file_system, File *directory);

/************************************************************************/
/** Recursively removes file (and children if directory) for given path */
/***********************************************************************/
void recursive_remove( CallContext context, CString *directory);

CString *getParentDir_Path(CString *path);

CString *getBaseName_Path(CString *path);
CString *concat_Path(CString *parent, CString *child);
bool isAbsolute_Path(CString *path);
bool isRelative_Path(CString *path);
bool isEmpty_Path(CString *path);
bool isRoot_Path(CString *path);
CString *convertToAbsolute_Path(CallContext context, CString *path);
CString *resolveSymLinks_Path_Ext(FileSystem *file_system, CString *srcpath, Bool3 *eloop, List *resolved_links, int *nresolved);
List *split_Path(CString *path);
CString *resolveDirLinks_Path(CString *path);
CString *resolveDirLinks_Path2(CString *path);

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** __xmknod_spec **/
specification
IntT __xmknod_spec( CallContext context, IntT ver, CString *path, FileKind kind, FilePermissions *perms,  DevT dev, ErrorCode *errno );
void on__xmknod( CallContext context, IntT ver, CString *path, FileKind kind, FilePermissions *perms,  DevT dev, IntT retval, ErrorCode *errno );

/** link_spec **/
specification
IntT link_spec( CallContext context, CString *path1, CString *path2, ErrorCode *errno, CancelStatus status );
void on_link( CallContext context, CString *path1, CString *path2, IntT retval, ErrorCode *errno );
void link_FileSystem(FileSystem *fs, CString *path1, CString *path2);

/** remove_spec **/
specification
IntT remove_spec( CallContext context, CString *path, ErrorCode *errno, CancelStatus status );
void on_remove(  CallContext context, CString *path, IntT retval, ErrorCode *errno );

/** rename_spec **/
specification
IntT rename_spec( CallContext context, CString *oldPath, CString *newPath, ErrorCode *errno, CancelStatus status );
void on_rename( CallContext context, CString *oldPath, CString *newPath, IntT retval, ErrorCode *errno);
void rename_FileSystem(FileSystem *fs, CString *oldPath, CString *newPath);

/** unlink_spec **/
specification
IntT unlink_spec( CallContext context, CString *path, ErrorCode *errno, CancelStatus status );
void  on_unlink( CallContext context, CString *path, IntT retval, ErrorCode *errno );
File *unlink_FileSystem(FileSystem *fs, CString *path, bool keepFile);


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

NLinkTObj *diffLinksCount_File(File *a, File *b);
static void registerDirLink_Directory(File *target, File *directory, CString *filename);
static void registerUpwardLink_File(File *file, File *directory, CString *filename);
static FileIdObj *getDirLink_Directory(File *directory, CString *filename);
static void unregisterDirLink_Directory( File *directory, CString *filename);
static void unregisterUpwardLink_File(File *file, File *directory, CString *filename);



void updateAtimePath(CallContext context, FileSystem* fs, CString* path);
void updateCtimePath(CallContext context, FileSystem* fs, CString* path);
void updateMtimePath(CallContext context, FileSystem* fs, CString* path);
void resetTimeFlags_FileSystem(FileSystem* fs);

Bool3 isEACCES_unlink(CallContext context, FileSystem *fs, CString *path);

/********************************************************************/
/**                         Error Helpers                          **/
/********************************************************************/
FilePermission* getProcessAccessOnFile(CallContext context, File *file);
Bool3 isNoPermOnPath(CallContext context, FileSystem *fs, CString *path, bool read, bool write, bool execute);
Bool3 isNoPermOnPathComponents(CallContext context, FileSystem *fs, CString *path, bool read, bool write, bool execute);
Bool3 isEMLINK(CallContext context, FileSystem *fs, CString *path);
Bool3 isENAMETOOLONG(CallContext context, CString *path);

/*
 * Returns true iff search permission is denied for a directory in the file's path prefix.
 */
Bool3 isSearchDeniedForPathPrefix(CallContext context, CString* path);

/*
 * Returns true iff a loop exists in symbolic links encountered during 
 * resolution of the path.
 */
Bool3 doesSymbolicLinksLoopExist(CallContext context, CString* path);

/*
 * Returns true iff the length of the path arguments exceeds {PATH_MAX}.
 */
Bool3 doesPathLengthExceed_PATH_MAX(CallContext context, CString* path);

/*
 * Returns true iff a pathname component is longer than {NAME_MAX}.
 */
Bool3 doesPathComponentExceed_NAME_MAX(CallContext context, CString* path);

/*
 * Returns true iff a pathname component is longer than {NAME_MAX}
 * and POSIX option _POSIX_NO_TRUNC is enabled.
 */
Bool3 isPathComponentLengthError(CallContext context, CString* path);

/*
 * Returns true iff a component of path or file does not name an existing file.
 */
Bool3 isPathComponentAbsent(CallContext context, CString* path);

/*
 * Returns true iff a component of the file's path prefix is not a directory.
 */
Bool3 isPathComponentNotDirectory(CallContext context, CString* path);

/*
 * Returns true iff more than {SYMLOOP_MAX} symbolic links were encountered 
 * during resolution of the path or file.
 */
Bool3 doesSymbolicLinksExceed_SYMLOOP_MAX(CallContext context, CString* path);

/*
 * Returns true iff the length of the pathname string substituted as a result 
 * of encountering a symbolic link in resolution of the path argument 
 * exceeded {PATH_MAX}.
 */
Bool3 doesResultingPathLengthExceed_PATH_MAX(CallContext context, CString* path);


#endif

