/* 
 * File: memory/mman/tests/mman_errors_scenario.sec
 * 
 * Author:
 * Version:  $Id: mman_usualuse_scenario.sec,v 1.7 2007/07/25 09:25:03 egor Exp $
 * 
 * Copyright (c) 2005 ISP RAS.
 * 25, B.Communisticheskaya, Moscow, Russia.
 * All rights reserved.
 */

#include "memory/mman/tests/mman_scenario.seh"
#include "memory/mman/mman_model.seh"
#include "memory/mman/mman_media.seh"
#include "memory/mman/tests/mman_main.seh"
#include "common/common_scenario.seh"
#include "fs/meta/meta_model.seh"
#include "fs/fs/fs_model.seh"
#include "system/system/system_model.seh"

// context of process
static CallContext context_pr1;

/*
 * parameters of good maps for file and shm object and of testing map 
 * (addr - returned addr)
 */
static VoidTPtr uuse_file_addr;
static VoidTPtr uuse_test_addr;
static VoidTPtr uuse_shm_addr;
static SizeT uuse_file_size;
static SizeT uuse_test_size;
static SizeT uuse_shm_size;
static OffT uuse_file_off;
static OffT uuse_test_off;
static OffT uuse_shm_off;
static MmanProtFlags uuse_file_prot;
static MmanProtFlags uuse_test_prot;
static MmanProtFlags uuse_shm_prot;

// names and descriptors of testing file and shared memory object 
static CString* uuse_filename;
static CString* uuse_shared_object_name;
static CString* uuse_test_filename;
static CString* uuse_test_shared_object_name;
static FileDescId uuse_shared_desc_id; 
static FileDescId uuse_test_shared_desc_id;
static FileDescId uuse_file_desc_id; 
static FileDescId uuse_test_file_desc_id;

// permissions for file and shm_object when open
static FilePermissions* uuse_file_mode;
static FilePermissions* uuse_shm_mode;
static FilePermissions* uuse_test_mode;

static Shm_openOflags uuse_shm_oflags;
static Shm_openOflags uuse_test_shm_oflags;

static VoidTPtr test_maps[16];
static MmanProtFlags test_maps_flags[16];
// size of page for process with context context_pr1
static LongT pagesize;

static bool init_memory_mman_usual_scenario(int argc, char** argv)
{
    ProcessId pid;
    VoidTPtr temp_addr;

    FilePermission* full_control1;
    FilePermission* full_control2;
    FilePermission* full_control3;
    ErrorCode* errno;
    
    MmapFlags flags; //flags for map shm object and file

    ProcessState* prSt;

    initReqFilters();
    setFinishMode(UNTIL_END); 

    errno = requestErrorCode();
    //init global variables context_pr1 and pagesize
    context_pr1 = getContext(); 
    prSt = getProcessState_CallContext(context_pr1);
    put_Map(prSt->sysconf, create_IntTObj(SUT_SC_XOPEN_UNIX), create_LongTObj(1));
    pagesize = sysconf_spec( context_pr1, SUT_SC_PAGE_SIZE, requestErrorCode() );
    if ( pagesize == -1) 
    {
      return false;
    }
    else 
    {
        setSystemConfigurationValue( context_pr1, SUT_SC_PAGE_SIZE, pagesize);
    }
    pagesize = getSystemConfigurationValue(context_pr1, SUT_SC_PAGE_SIZE);
    //verbose("page_size %d \n", pagesize);

    //init temp variables
    pid = getProcessId_CallContext(context_pr1);
    temp_addr.address = (sut_ptr_t) 0;
    temp_addr.process = pid.process;
    temp_addr.system = pid.system;
    
    full_control1 = create_FilePermission(true, true, true);
    full_control2 = create_FilePermission(true, true, true);
    full_control3 = create_FilePermission(true, true, true);

    flags.MAP_FIXED_Flag = false;
    flags.MAP_PRIVATE_Flag = false;
    flags.MAP_SHARED_Flag = true;

    //init global variables file_* and shm_*
    //init of protection flags
    uuse_file_prot.PROT_EXEC_Flag = false;
    uuse_file_prot.PROT_NONE_Flag = false;
    uuse_file_prot.PROT_READ_Flag = true;
    uuse_file_prot.PROT_WRITE_Flag = true;
    uuse_shm_prot = uuse_file_prot;
    
    //init size
    uuse_file_size = (SizeT) pagesize * 19;
    uuse_shm_size = uuse_file_size;
    //verbose("uuse_shm_size %d\n", uuse_shm_size);

    //init offset
    uuse_file_off = (OffT) 0;
    uuse_shm_off = uuse_file_off;

    //init mode
    uuse_file_mode = create_FilePermissions(full_control1, full_control2, full_control3,
                                        False_Bool3, False_Bool3, False_Bool3);
    uuse_shm_mode = create_FilePermissions(full_control1, full_control2, full_control3,
                                       False_Bool3, False_Bool3, False_Bool3);
    
    //init names of files
    uuse_filename = create_CString("/uuse_filename");
    uuse_shared_object_name = create_CString("/shared_object_uuse");

    //init flags for shm_open
    uuse_shm_oflags.O_CREAT_Flag = true;
    uuse_shm_oflags.O_EXCL_Flag = false;
    uuse_shm_oflags.O_RDONLY_Flag = false;
    uuse_shm_oflags.O_RDWR_Flag = true;
    uuse_shm_oflags.O_TRUNC_Flag = false;
    
    //create shm object and base map for it
    uuse_shared_desc_id = shm_open_spec(context_pr1, uuse_shared_object_name, uuse_shm_oflags, 
                                   uuse_shm_mode, requestErrorCode());
    if (uuse_shared_desc_id.filedesc == -1)
    {
        traceUserInfo("Can't create basic shared memory object");
        return false;
    }
    
    uuse_shm_addr = mmap_spec(context_pr1, temp_addr, uuse_shm_size, uuse_shm_prot, flags, 
                         uuse_shared_desc_id, uuse_shm_off, false, errno);
    if (isInvalid_VoidTPtr(uuse_shm_addr))
    {
        traceUserInfo("Can't create basic map to shared memory object");
        return false;
    }

    return true;
}



static void finish_memory_mman_usual_scenario(void)
{
    shm_unlink_spec(context_pr1, uuse_shared_object_name, requestErrorCode());
    return;
}

bool make_small_maps(VoidTPtr addr, FileDescId id)
{
    int i, j, h, ind;
    VoidTPtr used_addr;
    MmapFlags map_flags;
    OffT off;
    off = (OffT)0;

    for (i = 0; i < 2; i++) // SHARED/PRIVATE
    { 
        for (j = 0; j < 2; j++) // FIXED/NOT FIXED
        {
            for (h = 0; h < 4; h++) 
                /*
                 * 0 - PROT_NONE; h & 1 != 0 - PROT_READ; h & 2 != 0 - PROT_WRITE 
                 * PROT_EXEC is optional in this standard
                 */
            {
                ind = i * 8 + j * 4 + h;
                uuse_test_prot.PROT_NONE_Flag = false;
                uuse_test_prot.PROT_EXEC_Flag = false;
                uuse_test_prot.PROT_READ_Flag = false;
                uuse_test_prot.PROT_WRITE_Flag = false;
                

                map_flags.MAP_PRIVATE_Flag = false;
                map_flags.MAP_SHARED_Flag = false;

                switch(i) {
                case 0:
                    map_flags.MAP_PRIVATE_Flag = true;
                    break;
                case 1:
                    map_flags.MAP_SHARED_Flag = true;
                    break;
                };

                switch(j) {
                case 0:
                    map_flags.MAP_FIXED_Flag = false;
                    break;
                case 1:
                    map_flags.MAP_FIXED_Flag = true;
                    break;
                };

                if(h == 0)
                {
                    uuse_test_prot.PROT_NONE_Flag = true;
                };
                if((h & 1) != 0)
                {
                    uuse_test_prot.PROT_READ_Flag = true;
                };
                if((h & 2) != 0)
                {
                    uuse_test_prot.PROT_WRITE_Flag = true;
                };

                used_addr = addr;
                used_addr.address += pagesize * ind;

                test_maps[ind] = mmap_spec(context_pr1, used_addr, pagesize, uuse_test_prot,
                          map_flags, id, off, false, requestErrorCode());
                test_maps_flags[ind] = uuse_test_prot;
             //   verbose("%d %p \n", ind, test_maps[ind].address);
            };
        };
    };
    return true;
}

bool write_to_small_maps()
{
    CByteArray* data;
    MappedMemoryBlock* mb;
    String* value;
    SizeT mb_len;
    int i;
    VoidTPtr addr;
    MsyncFlags s_flag;

     //temp TODO remove
    SystemState*   sysSt;
    FileIdObj* main_file;
    FileDescriptor* main_desc;
    

    //TODO remove this line
    main_desc = getFileDescriptor(uuse_test_shared_desc_id);
    main_file = create_FileIdObj(main_desc->file);

    s_flag.MS_SYNC_Flag = true;
    s_flag.MS_ASYNC_Flag = false;
    s_flag.MS_INVALIDATE_Flag = false;

    //value = create_String("12345678901234567890abcdefghijklmnopqrstuvwxyz7890");
    value = create_String("abcdefrtyu");
    mb_len = length_String(value);
    data = create_CByteArray( (ByteT*)toCharArray_String(value), mb_len + 1 );
    mb = create_MappedMemoryBlock((OffT)0, mb_len, data);

    for (i = 0; i < 3; i++)
    {
        if (test_maps_flags[i].PROT_WRITE_Flag == true)
        {
            addr = test_maps[i];
            addr.address += i;
            write_mapped_mem_block_spec(context_pr1, addr, mb_len, mb, requestErrorCode());
            msync_spec(context_pr1, test_maps[i], pagesize, s_flag, requestErrorCode());
        }
        
        sysSt = getSystemState_CallContext(context_pr1);
        //verbose("write % d done %d\n", i, size_Map(get_Map(sysSt->shared_memory_system->shm_files, main_file)));
        
    }    
    return true;
}

scenario bool usual_use_mman_functions_scen()
{
    // for read/write
    CByteArray* data;
    MappedMemoryBlock* mb;
    MappedMemoryBlock* res_read;
    String* value;
    SizeT mb_len;
    int i;
    
    // for other functions
    SizeT len;
    MLockallFlags mlockall_flags;
    MmapFlags map_flags;
    OffT off;

    //value = create_String("12345678901234567890abcdefghijklmnopqrstuvwxyz7890");
    value = create_String("1234567890");
    mb_len = length_String(value);
    data = create_CByteArray( (ByteT*)toCharArray_String(value), mb_len + 1 );
    mb = create_MappedMemoryBlock((OffT)0, mb_len, data);

    // shm_open
    uuse_test_shared_object_name = create_CString("/test_shm_obj");
    uuse_test_shm_oflags.O_CREAT_Flag = true;
    uuse_test_shm_oflags.O_EXCL_Flag = false;
    uuse_test_shm_oflags.O_RDWR_Flag = true;
    uuse_test_shm_oflags.O_RDONLY_Flag = false;
    uuse_test_shm_oflags.O_TRUNC_Flag = false;

    uuse_test_shared_desc_id = shm_open_spec(context_pr1, uuse_test_shared_object_name, uuse_test_shm_oflags, 
                                   uuse_shm_mode, requestErrorCode());

    //mmap with different parametrs
    if(make_small_maps(uuse_shm_addr, uuse_test_shared_desc_id) == false) 
        return false;

    if (write_to_small_maps() == false)
    {
        return false;
    }

    // Different variations of lock and unlock functions
    uuse_test_addr = uuse_shm_addr;
    len = pagesize * 5;
    mlock_spec(context_pr1, uuse_test_addr, len, requestErrorCode());

    mlockall_flags.MCL_CURRENT_Flag = true;
    mlockall_flags.MCL_FUTURE_Flag = true;
    mlockall_spec(context_pr1, mlockall_flags, requestErrorCode());

    uuse_test_addr.address += pagesize;
    munlock_spec (context_pr1, uuse_test_addr, len, requestErrorCode());

    munlockall_spec(context_pr1);
    
    mlock_spec(context_pr1, uuse_test_addr, len, requestErrorCode());
    munlock_spec (context_pr1, uuse_test_addr, len, requestErrorCode());

    // Checking if write and read functions work good
    write_mapped_mem_block_spec(context_pr1, uuse_shm_addr, mb_len, mb, requestErrorCode());

    munmap_spec(context_pr1, uuse_shm_addr, pagesize * 19, requestErrorCode());

    uuse_test_prot.PROT_NONE_Flag = false;
    uuse_test_prot.PROT_EXEC_Flag = false;
    uuse_test_prot.PROT_READ_Flag = true;
    uuse_test_prot.PROT_WRITE_Flag = true;
    map_flags.MAP_SHARED_Flag = true;
    map_flags.MAP_FIXED_Flag = false;
    map_flags.MAP_PRIVATE_Flag = false;
    off = (OffT) 0;

    uuse_test_addr = mmap_spec(context_pr1, uuse_shm_addr, pagesize, uuse_test_prot, 
        map_flags, uuse_test_shared_desc_id, off, false, requestErrorCode());

    mb = read_mapped_mem_block_spec(context_pr1, uuse_test_addr, mb_len + 15, requestErrorCode());

    /*
    verbose("data\n");
    for (i = 0; i < mb_len + 15; i++)
    {
        verbose("%d %c \n", i,mb->data->data[i]);
    }
    */
    
    //munlink and shm_open (with using mmap and read/write)
    shm_unlink_spec(context_pr1, uuse_test_shared_object_name, requestErrorCode());
    shm_open_spec(context_pr1, uuse_test_shared_object_name, uuse_test_shm_oflags, 
                                   uuse_shm_mode, requestErrorCode());
    uuse_shm_addr = mmap_spec(context_pr1, uuse_shm_addr, pagesize, uuse_test_prot, 
        map_flags, uuse_test_shared_desc_id, off, false, requestErrorCode());

    write_mapped_mem_block_spec(context_pr1, uuse_shm_addr, mb_len, mb, requestErrorCode());
    read_mapped_mem_block_spec(context_pr1, uuse_test_addr, mb_len , requestErrorCode());

    uuse_test_addr.address += 2;
    write_mapped_mem_block_spec(context_pr1, uuse_test_addr, mb_len, mb, requestErrorCode());
    uuse_test_addr.address -= 2;
    read_mapped_mem_block_spec(context_pr1, uuse_shm_addr, mb_len , requestErrorCode());

    munmap_spec(context_pr1, uuse_test_addr, pagesize, requestErrorCode());
    shm_unlink_spec(context_pr1, uuse_test_shared_object_name, requestErrorCode());
    return true;
}

scenario dfsm memory_mman_usual_scenario = //TODO shm_open agent also call ftruncate so need to change
{
    .init = init_memory_mman_usual_scenario,
    .finish = finish_memory_mman_usual_scenario,
    .actions = {
        usual_use_mman_functions_scen,
        NULL
    }
};

