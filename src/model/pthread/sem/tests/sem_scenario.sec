/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "pthread/sem/sem_model.seh"
#include "pthread/sem/tests/sem_scenario.seh"

#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "system/system/system_model.seh"

#include <atl/integer.h>


/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

#define SEM_THREAD_NUM 3


/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/

static CallContext context;
static CallContext contexts[SEM_THREAD_NUM];
static PThreadSemaphoreTPtr semaphore[SEM_THREAD_NUM];
static PThreadSemaphoreTPtr unnamed_semaphore[SEM_THREAD_NUM];

#define maxSize 1024

static StringTPtr semaphore_name[SEM_THREAD_NUM];
static char* sem_name = "/semaphore-917";


/*
scenario
bool sem_open_scen()
{
    writeCString_VoidTPtr(semaphore_name, create_CString("/Naaaaaaaaaaamee"));
    semaphore = sem_open_spec(context, semaphore_name, 0, 0600, 10);
    return true;
}

scenario
bool sem_wait_scen()
{
    printfSemaphoreModel(getSemaphore(semaphore));
    sem_wait_spec(context, semaphore);
    return true;
}

scenario
bool sem_post_scen()
{
    printfSemaphoreModel(getSemaphore(semaphore));
    sem_post_spec(context, semaphore);
    return true;
}

scenario
bool sem_close_scen()
{
    printfSemaphoreModel(getSemaphore(semaphore));
    sem_close_spec(context, semaphore);
    return true;
}
*/


/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

void cleanup_sem_plain_scenario()
{
    int i;

    /* delete threads */
    for(i = 1; i < SEM_THREAD_NUM; i++)
    {
        if(!isWrong_ThreadId(contexts[i]))
        {
            // TODO: delete thread
        }
    }

    /* deallocate memory */
    for(i = 1; i < SEM_THREAD_NUM; i++)
    {
        if (!isNULL_VoidTPtr(semaphore_name[i]))
        {
            deallocateMemoryBlock(contexts[i], semaphore_name[i]);
        }
    }
}

bool init_sem_plain_scen_data()
{
    int i;
    for(i=0; i<SEM_THREAD_NUM; i++)
    {
        writeCString_VoidTPtr(semaphore_name[i], create_CString(sem_name));
    }
    return true;
}

bool init_sem_plain_scenario(int argc, char** argv)
{
    int i;
    bool result=true;
    context = getContext();
    contexts[0] = context;

    for(i=1;i<SEM_THREAD_NUM;i++)
    {
        contexts[i] = createThread();
        if(isWrong_ThreadId(contexts[i])) result = false;
    }

    for(i=0;i<SEM_THREAD_NUM;i++)
    {
        semaphore_name[i] = allocateMemoryBlock(contexts[i], maxSize);
        if (isNULL_VoidTPtr(semaphore_name[i]))
            return false;
    }

    for(i=0;i<SEM_THREAD_NUM;i++)
    {
        unnamed_semaphore[i] = allocateMemoryBlock(contexts[i], 1024);
        if (isNULL_VoidTPtr(unnamed_semaphore[i]))
            return false;
    }

    if(!init_sem_plain_scen_data()) result = false;

    setFindFirstSeriesOnly(true);
    setWTimeMSec(3*SERIALIZATION_TIME);

    if(!result) cleanup_sem_plain_scenario();
    return result;
}

void finish_sem_plain_scenario(void)
{
    cleanup_sem_plain_scenario();
    return ;
}

bool isSemModelStateStationary(void)
{
    return true;
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/
Integer* get_Sem_State(void)
{
    return create_Integer(0);
}

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

Map* saveSemModelState(void)
{
    return clone(systems);
}

void restoreSemModelState(Map* saved_state)
{
    systems = saved_state;
}

/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/
#define SCENARIO_ERROR(error_code) {verbose("SCENARIO ERROR %d\n", error_code); result = false;}

/* Full OLVER Edition Source Start */
scenario
bool warmup_scen()
{
    bool result = true;
    IntT val;
    IntT *sval = &val;

    /* create open flags */
    OpenFlags openFlags = {ReadOnly, Blocking, false, true, false, false, false, false};

    FilePermission* owner = create_FilePermission(true, true, false);
    FilePermission* group = create_FilePermission(false, false, false);
    FilePermission* other = create_FilePermission(false, false, false);
    FilePermissions *filePermisions = create_FilePermissions(owner, group, other, Unknown_Bool3, Unknown_Bool3, Unknown_Bool3);
    semaphore[0] = sem_open_spec(contexts[0], semaphore_name[0], openFlags, filePermisions, 11, errno_model);

    //semaphore[0] = sem_open_spec(contexts[0], semaphore_name[0], openFlags, filePermisions, 1, errno_model);

    sem_getvalue_spec(contexts[0], semaphore[0], sval, errno_model);

    //sem_wait_spec(contexts[0], semaphore[0]);

    sem_post_spec(contexts[0], semaphore[0]);

    sem_close_spec(contexts[0], semaphore[0], errno_model);

//    verbose("finished sem_open_spec\n");
//
//    sem_wait_spec(contexts[0], semaphore[0]);
//    Sleep(SERIALIZATION_TIME);
//
    /*
    sem_wait_spec(contexts[0], semaphore[0]);
    Sleep(SERIALIZATION_TIME);

    /*
    semaphore[1] = NULL_VoidTPtr;
    semaphore[1] = sem_open_spec(contexts[1], semaphore_name[1], 0, 0600, 1 );
    sem_post_spec(contexts[1], semaphore[1]);
    Sleep(SERIALIZATION_TIME);
    */
    /*
    sem_wait_spec(contexts[0], semaphore[0]);
    Sleep(SERIALIZATION_TIME);
    */

//    verbose("finished sem_wait_spec\n");
//    //printfSemaphoreModel(getSemaphore(semaphore[0]));
//
//    sem_close_spec(contexts[0], semaphore[0]);
//
//    verbose("finished sem_close_spec\n");
//
//    res = sem_unlink_spec(contexts[0], semaphore_name[0]);
//
//    verbose("finished sem_unlink_spec\n");

    return result;
}
/* Full OLVER Edition Source End */

scenario
bool warmup_unnamed_scen()
{
    bool result = true;

    /* create open flags */
    OpenFlags openFlags = {ReadOnly, Blocking, false, true, false, false, false, false};

    FilePermission* owner = create_FilePermission(true, true, false);
    FilePermission* group = create_FilePermission(false, false, false);
    FilePermission* other = create_FilePermission(false, false, false);
    FilePermissions *filePermisions = create_FilePermissions(owner, group, other, Unknown_Bool3, Unknown_Bool3, Unknown_Bool3);

    //int sem_init(sem_t *sem, int pshared, unsigned value);
    sem_init_spec(contexts[0], unnamed_semaphore[0], 1, 11, errno_model);
    sem_destroy_spec(contexts[0], unnamed_semaphore[0], errno_model);
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm pthread_sem_dummy_scenario =
{
    .init = init_sem_plain_scenario,
    .finish = finish_sem_plain_scenario,
    .getState = (PtrGetState)get_Sem_State,
    .saveModelState = (PtrSaveModelState)saveSemModelState,
    .restoreModelState = (PtrRestoreModelState)restoreSemModelState,
    .isStationaryState = (PtrIsStationaryState)isSemModelStateStationary,
    .actions = {
        /* Full OLVER Edition Source Start */
        //warmup_scen,
        /* Full OLVER Edition Source End */
        warmup_unnamed_scen,
        /* Full OLVER Edition Source Start */
        /*
        sem_open_scen,
        sem_wait_scen,
        sem_post_scen,
        sem_close_scen,
        */
        /* Full OLVER Edition Source End */
        NULL
    }
};

