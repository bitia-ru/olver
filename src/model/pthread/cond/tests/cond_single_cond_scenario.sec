/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "pthread/cond/tests/cond_scenario.seh"
#include "pthread/cond/cond_model.seh"
#include "system/system/system_model.seh"
#include "common/common_scenario.seh"
#include "common/common_media.seh"
#include "process/process/process_common.seh"
#include "atl/integer.h"

#include "common/explicit_fsm.h"

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

/* number of threads */
#define THREAD_NUM 4

/* number of conditional variables */
#define COND_NUM 2

#define MUTEX_UNLOCK_HARD(mutex) \
        int t_list_sz = sizeof(t_list) / sizeof(int); \
        int t_index, t_index_chk; \
        for (t_index = 0; t_index < t_list_sz; ++t_index) \
        { \
            Mutex* mutexObj = getMutex(mutex); \
            for (t_index_chk = 0; t_index_chk < t_list_sz; ++t_index_chk) \
            { \
                if (equals_ThreadId(mutexObj->owner, context_array[t_list[t_index_chk]])) \
                { \
                    pthread_mutex_unlock_spec(mutexObj->owner, mutex); \
                    serialize(); \
                    break; \
                } \
            } \
            if ( ! traceFunctionCall( context, t_index_chk != t_list_sz, true, "t_index_chk == t_list_sz in MUTEX_UNLOCK_HARD", NULL ) ) \
            { \
                Error = true; \
                setBadVerdict("Incorrect Mutex owner!"); \
                return; \
            } \
        }

#define MUTEX_UNLOCK_SOFT(mutex) \
    { \
        Mutex* mutexObj = getMutex(mutex); \
        while (!equals_ThreadId(mutexObj->owner, WrongThreadId)) \
        { \
            pthread_mutex_unlock_spec(mutexObj->owner, mutex); \
            serialize(); \
            mutexObj = getMutex(mutex); \
        } \
    }

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/

static CallContext context;
static CallContext context_array[THREAD_NUM];
static VoidTPtr    memory_blocks[COND_NUM];

#define CONDITION_NOT_INITIALIZED (-1)
static List* condInitList = NULL;

static int Error = false;

/********************************************************************/
/**                         Auxiliary Types                        **/
/********************************************************************/

specification typedef struct SingleCondModelState
{
    Map* systems;
    List* condInitList;
} SingleCondModelState = {};

SingleCondModelState * create_SingleCondModelState(
    Map* systems,
    List* condInitList
)
{
    return create(&type_SingleCondModelState, systems, condInitList);
}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

void cleanup_single_cond_scenario()
{
    int i;
    CallContext context1 = getSystemContext(context.system, context.process);


    /* delete threads */
    for(i = 1; i < THREAD_NUM; i++)
    {
        if(!isWrong_ThreadId(context_array[i]))
        {
            // TODO: delete thread
        }
    }

    /* deallocate memory */
    for(i = 0; i < COND_NUM; i++)
    {
        if (!isNULL_VoidTPtr(memory_blocks[i]))
        {
            deallocateMemoryBlock(context1, memory_blocks[i]);
        }
    }
}

bool init_single_cond_scenario(int argc, char** argv)
{
    int i;

    bool result = true;

    /* initialize arrays */
    for(i = 0; i < THREAD_NUM; i++)
    {
        context_array[i].system = WrongId;
    }

    for(i = 0; i < COND_NUM; i++)
    {
        memory_blocks[i] = NULL_VoidTPtr;
    }

    /* create threads */
    context = getContext();
    context_array[0] = context;

    for(i = 1; i < THREAD_NUM; i++)
    {
        context_array[i] = createThread();

        if(isWrong_ThreadId(context_array[i]))
        {
            result = false;
            break;
        }
    }

    if (result)
    {
        /* allocate memory */
        for(i = 0; i < COND_NUM; i++)
        {
            memory_blocks[i] = allocateMemoryBlock(context, 1024);
            if (isNULL_VoidTPtr(memory_blocks[i]))
            {
                result = false;
                break;
            }
        }
    }

    if (!result)
    {
        cleanup_single_cond_scenario();
        return false;
    }

    /* fill model state */
    condInitList = create_List(&type_Integer);
    for(i = 0; i < COND_NUM; i++)
    {
        append_List(condInitList, create_Integer(CONDITION_NOT_INITIALIZED));
    }

    //initFibers(doScen);

    setTSTimeModel(NotUseTSTime);
    setFindFirstSeriesOnly(true);

    return true;
}

void finish_single_cond_scenario(void)
{
    cleanup_single_cond_scenario();
    TEST_SCENARIO_VERDICT_VERBOSE(sc_forever_scen);
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/

List* get_SingleCondState(void)
{
    return clone(condInitList);
}

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

SingleCondModelState* saveSingleCondState(void)
{
    return create_SingleCondModelState( systems, condInitList);
}

void restoreSingleCondState(SingleCondModelState* modelState)
{
    systems = modelState->systems;
    condInitList = modelState->condInitList;
}

/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

/* Full OLVER Edition Source Start */
scenario
bool sc_full_conformance_scen()
{
    PThreadCondT* condObj = NULL;
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];
    Integer* condInitialized = get_List(condInitList, 0);

    pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
    pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
    pthread_mutex_lock_spec(context_array[0], mutex);

    while (!condObj->predicate)
    {
        pthread_cond_wait_spec(context_array[0], cond, mutex);
        //serialize();
    }

    condObj->predicate = 0;
    pthread_mutex_unlock_spec(context_array[0], mutex);
    pthread_mutex_destroy_spec(context_array[0], mutex);
    pthread_cond_destroy_spec(context_array[0], cond);


    pthread_mutex_lock_spec(context_array[1], mutex);
    pthread_cond_signal_spec(context_array[1], cond);
    pthread_mutex_unlock_spec(context_array[1], mutex);
    //sleep(context_array[1], 500);

    while (true)
    {
        pthread_mutex_lock_spec(context_array[1], mutex);
        if (!condObj->predicate)
        {
            condObj->predicate = 1;
            pthread_cond_broadcast_spec(context_array[1], cond);
            pthread_mutex_unlock_spec(context_array[1], mutex);
            break;
        }
        else
        {
            pthread_mutex_unlock_spec(context_array[1], mutex);
            continue;
        }
    }
    return true;
}
/* Full OLVER Edition Source End */

scenario
bool sc_base_conformance_scen()
{
    PThreadCondT* condObj = NULL;
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    iterate (int i=0; i<9; ++i;)
    {
        switch (i)
        {
        case 0:
            pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
            pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
            break;
        case 1:
            pthread_mutex_lock_spec(context_array[0], mutex);
            break;
        case 2:
            pthread_cond_timedwait_spec(context_array[0], cond, mutex, 10);
            ts_sleep_msec(200);
            break;
        case 3:
            pthread_cond_wait_spec(context_array[0], cond, mutex);
            break;
        case 4:
            pthread_mutex_lock_spec(context_array[1], mutex);
            break;
        case 5:
            pthread_cond_signal_spec(context_array[1], cond);
            break;
        case 6:
            pthread_mutex_unlock_spec(context_array[1], mutex);
            break;
        case 7:
            pthread_mutex_unlock_spec(context_array[0], mutex);
            break;
        case 8:
            pthread_mutex_destroy_spec(context_array[0], mutex);
            pthread_cond_destroy_spec(context_array[0], cond);
            break;
        }
    }

    return true;
}

/* Full OLVER Edition Source Start */
scenario
bool sc_simple_scen()
{
    PThreadCondT* condObj = NULL;
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    iterate (int i=0; i<6; ++i;)
    {
        switch (i)
        {
        case 0:
            pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
            pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
            break;
        case 1:
            condObj = getCondVariable(cond);
            condObj->mutex = mutex;
            pthread_mutex_lock_spec(context_array[0], mutex);
            break;
        case 2:
            pthread_cond_wait_spec(context_array[0], cond, mutex);
            break;
        case 3:
            pthread_cond_signal_spec(context_array[1], cond);
            break;
        case 4:
            pthread_mutex_unlock_spec(context_array[0], mutex);
            break;
        case 5:
            pthread_mutex_destroy_spec(context_array[0], mutex);
            pthread_cond_destroy_spec(context_array[0], cond);
            break;
        }
    }

    return true;
}
/* Full OLVER Edition Source End */

/* Full OLVER Edition Source Start */
scenario
bool sc_init_scen()
{
    iterate(int i = 0; i < THREAD_NUM; i++;)
    {
        iterate(int j = 0; j < COND_NUM; j++;)
        {
            Integer* condInitialized = get_List(condInitList, j);

            if (*condInitialized == CONDITION_NOT_INITIALIZED)
            {
                pthread_cond_init_spec(context_array[i], memory_blocks[j], NULL_VoidTPtr);
                *condInitialized = i;
            }
        }
    }
    return true;
}
/* Full OLVER Edition Source End */

/* Full OLVER Edition Source Start */
scenario
bool sc_destroy_scen()
{
    iterate(int i = 0; i < THREAD_NUM; i++;)
    {
        iterate(int j = 0; j < COND_NUM; j++;)
        {
            Integer* condInitialized = get_List(condInitList, j);

            if (*condInitialized != CONDITION_NOT_INITIALIZED)
            {
                pthread_cond_destroy_spec(context_array[i], memory_blocks[j]);
                *condInitialized = CONDITION_NOT_INITIALIZED;
            }
        }
    }
    return true;
}
/* Full OLVER Edition Source End */

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/
/* Full OLVER Edition Source Start */
/*
scenario dfsm pthread_cond_cond_single_scenario =
{
    .init = init_single_cond_scenario,
    .finish = finish_single_cond_scenario,
    .getState = (PtrGetState)get_SingleCondState,
    .saveModelState = (PtrSaveModelState)saveSingleCondState,
    .restoreModelState = (PtrRestoreModelState)restoreSingleCondState,
    .isStationaryState = (PtrIsStationaryState)isCondModelStateStationary,
    .actions = {
            sc_base_conformance_scen,

//            sc_simple_scen,
//            sc_init_scen,
//            sc_destroy_scen,
              NULL
    }
};

*/
/* Full OLVER Edition Source End */

/*
void waitFiberFunc(void* x)
{
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
    pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
    serialize();

    pthread_mutex_lock_spec(context_array[0], mutex);
    serialize();

    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD / 10);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD / 10);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);

    SwitchToFiber(sigFiber);

    pthread_cond_wait_spec(context_array[0], cond, mutex);
    serialize();

    ts_sleep_msec(200);

    SwitchToFiber(sigFiber);

    pthread_mutex_unlock_spec(context_array[0], mutex);
    serialize();

    pthread_mutex_destroy_spec(context_array[0], mutex);
    pthread_cond_destroy_spec(context_array[0], cond);
    serialize();
}

void sigFiberFunc(void* x)
{
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();

    pthread_cond_signal_spec(context_array[1], cond);
    serialize();

    pthread_mutex_unlock_spec(context_array[1], mutex);
    serialize();

    SwitchToFiber(scenFiber);

    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();

    pthread_cond_broadcast_spec(context_array[1], cond);
    serialize();

    pthread_mutex_unlock_spec(context_array[1], mutex);
    serialize();

    SwitchToFiber(scenFiber);
}
*/

void doScen(void)
{
//    int i = 3;
    PThreadCondT* condObj;
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
    pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
    serialize();

    condObj = getCondVariable(cond);
    condObj->predicate = 0;

    while(!condObj->predicate)
    {
        pthread_mutex_lock_spec(context_array[1], mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);
        pthread_cond_signal_spec(context_array[1], cond);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);
        pthread_mutex_unlock_spec(context_array[1], mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);

        pthread_mutex_lock_spec(context_array[0], mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);

//        pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
        pthread_cond_wait_spec(context_array[0], cond, mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);
//        ts_sleep_msec(200);
    }

    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();
    pthread_cond_signal_spec(context_array[1], cond);
    serialize();
    pthread_mutex_unlock_spec(context_array[1], mutex);
    serialize();

    pthread_mutex_unlock_spec(context_array[0], mutex);
    serialize();

    pthread_mutex_destroy_spec(context_array[0], mutex);
    pthread_cond_destroy_spec(context_array[0], cond);

    serialize();
}

void doScen3(void)
{
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];
    const int TIME_BEFORE_DELAYED_RETURN_MSEC = 400;    // min - 200

    /*
     * Fiber 0 - signal sender
     * Fibers 1, 2 and 3 - waiters
     */

    // Fiber 1
    pthread_cond_init_spec(context_array[1], cond, NULL_VoidTPtr);
    pthread_mutex_init_spec(context_array[1], mutex, NULL_VoidTPtr);
    serialize();

    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();

    pthread_cond_wait_spec(context_array[1], cond, mutex);
    serialize();

    // Fiber 3
    pthread_mutex_lock_spec(context_array[3], mutex);
    serialize();

    pthread_cond_timedwait_spec(context_array[3], cond, mutex, 2*MILLIARD);
    serialize();

    // Fiber 2
    pthread_mutex_lock_spec(context_array[2], mutex);
    serialize();

    pthread_cond_timedwait_spec(context_array[2], cond, mutex, 1000);
    serialize();

    pthread_mutex_unlock_spec(context_array[2], mutex);
    serialize();

    // Common
    ts_sleep_msec(50);

    // Fiber 0
    pthread_mutex_lock_spec(context_array[0], mutex);
    serialize();

    pthread_cond_broadcast_spec(context_array[0], cond);
    serialize();

    // Common
    {
        int t_list[3] = { 0, 1, 3 };
        MUTEX_UNLOCK_HARD(mutex);
    }

    // Fiber 0
    pthread_mutex_lock_spec(context_array[0], mutex);
    serialize();

    pthread_cond_broadcast_spec(context_array[0], cond);
    serialize();

    pthread_mutex_unlock_spec(context_array[0], mutex);
    serialize();

    // Fiber 1
    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();

    pthread_cond_wait_spec(context_array[1], cond, mutex);
    serialize();

    // Fiber 2
    pthread_mutex_lock_spec(context_array[2], mutex);
    serialize();

    pthread_cond_wait_spec(context_array[2], cond, mutex);
    serialize();

    // Fiber 0
    pthread_mutex_lock_spec(context_array[0], mutex);
    serialize();

    pthread_cond_signal_spec(context_array[0], cond);
    pthread_cond_signal_spec(context_array[0], cond);
//    ts_sleep_msec(TIME_BEFORE_DELAYED_RETURN_MSEC);
    serialize();

    // Common
    MUTEX_UNLOCK_SOFT(mutex);

    // Fiber 2
    pthread_mutex_lock_spec(context_array[2], mutex);
    serialize();

    pthread_cond_signal_spec(context_array[2], cond);
    serialize();

    pthread_mutex_unlock_spec(context_array[2], mutex);
    serialize();

    // Fiber 1
    pthread_mutex_destroy_spec(context_array[1], mutex);
    pthread_cond_destroy_spec(context_array[1], cond);
    serialize();
}

scenario
bool sc_forever_scen()
{
    EXECUTE_EXPLICIT_FSM(doScen3);
    return !Error;
}

scenario dfsm pthread_cond_cond_single_scenario =
{
    .init = init_single_cond_scenario,
    .finish = finish_single_cond_scenario,
//    .getState = (PtrGetState)get_SingleCondState,
    .saveModelState = (PtrSaveModelState)saveSingleCondState,
    .restoreModelState = (PtrRestoreModelState)restoreSingleCondState,
    .isStationaryState = (PtrIsStationaryState)isCondModelStateStationary,
    .actions = {
            sc_forever_scen,
            NULL
    }
};

