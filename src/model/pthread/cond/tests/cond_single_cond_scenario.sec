/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "pthread/cond/tests/cond_scenario.seh"
#include "pthread/cond/cond_model.seh"
#include "system/system/system_model.seh"
#include "common/common_scenario.seh"
#include "common/common_media.seh"
#include "process/process/process_common.seh"
#include "atl/integer.h"

#include "common/explicit_fsm.h"

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

/* number of threads */
#define THREAD_NUM 4

/* number of conditional variables */
#define COND_NUM 2

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/

static CallContext context;
static CallContext context_array[THREAD_NUM];
static VoidTPtr    memory_blocks[COND_NUM];

#define CONDITION_NOT_INITIALIZED (-1)
static List* condInitList = NULL;

static int Error = false;

/********************************************************************/
/**                         Auxiliary Types                        **/
/********************************************************************/

specification typedef struct SingleCondModelState
{
    Map* systems;
    List* condInitList;
} SingleCondModelState = {};

SingleCondModelState * create_SingleCondModelState(
    Map* systems,
    List* condInitList
)
{
    return create(&type_SingleCondModelState, systems, condInitList);
}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

void cleanup_single_cond_scenario()
{
    int i;
    CallContext context1 = getSystemContext(context.system, context.process);


    /* delete threads */
    for(i = 1; i < THREAD_NUM; i++)
    {
        if(!isWrong_ThreadId(context_array[i]))
        {
            // TODO: delete thread
        }
    }

    /* deallocate memory */
    for(i = 0; i < COND_NUM; i++)
    {
        if (!isNULL_VoidTPtr(memory_blocks[i]))
        {
            deallocateMemoryBlock(context1, memory_blocks[i]);
        }
    }
}

bool init_single_cond_scenario(int argc, char** argv)
{
    int i;

    bool result = true;

    /* initialize arrays */
    for(i = 0; i < THREAD_NUM; i++)
    {
        context_array[i].system = WrongId;
    }

    for(i = 0; i < COND_NUM; i++)
    {
        memory_blocks[i] = NULL_VoidTPtr;
    }

    /* create threads */
    context = getContext();
    context_array[0] = context;

    for(i = 1; i < THREAD_NUM; i++)
    {
        context_array[i] = createThread();

        if(isWrong_ThreadId(context_array[i]))
        {
            result = false;
            break;
        }
    }

    if (result)
    {
        /* allocate memory */
        for(i = 0; i < COND_NUM; i++)
        {
            memory_blocks[i] = allocateMemoryBlock(context, 1024);
            if (isNULL_VoidTPtr(memory_blocks[i]))
            {
                result = false;
                break;
            }
        }
    }

    if (!result)
    {
        cleanup_single_cond_scenario();
        return false;
    }

    /* fill model state */
    condInitList = create_List(&type_Integer);
    for(i = 0; i < COND_NUM; i++)
    {
        append_List(condInitList, create_Integer(CONDITION_NOT_INITIALIZED));
    }

    //initFibers(doScen);

    setTSTimeModel(NotUseTSTime);
    setFindFirstSeriesOnly(true);

    return true;
}

void finish_single_cond_scenario(void)
{
    cleanup_single_cond_scenario();
    TEST_SCENARIO_VERDICT_VERBOSE(sc_forever_scen);
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/

List* get_SingleCondState(void)
{
    return clone(condInitList);
}

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

SingleCondModelState* saveSingleCondState(void)
{
    return create_SingleCondModelState( systems, condInitList);
}

void restoreSingleCondState(SingleCondModelState* modelState)
{
    systems = modelState->systems;
    condInitList = modelState->condInitList;
}

/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/


scenario
bool sc_base_conformance_scen()
{
    PThreadCondT* condObj = NULL;
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    iterate (int i=0; i<9; ++i;)
    {
        switch (i)
        {
        case 0:
            pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
            pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
            break;
        case 1:
            pthread_mutex_lock_spec(context_array[0], mutex);
            break;
        case 2:
            pthread_cond_timedwait_spec(context_array[0], cond, mutex, 10);
            ts_sleep_msec(200);
            break;
        case 3:
            pthread_cond_wait_spec(context_array[0], cond, mutex);
            break;
        case 4:
            pthread_mutex_lock_spec(context_array[1], mutex);
            break;
        case 5:
            pthread_cond_signal_spec(context_array[1], cond);
            break;
        case 6:
            pthread_mutex_unlock_spec(context_array[1], mutex);
            break;
        case 7:
            pthread_mutex_unlock_spec(context_array[0], mutex);
            break;
        case 8:
            pthread_mutex_destroy_spec(context_array[0], mutex);
            pthread_cond_destroy_spec(context_array[0], cond);
            break;
        }
    }

    return true;
}




/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

/*
void waitFiberFunc(void* x)
{
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
    pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
    serialize();

    pthread_mutex_lock_spec(context_array[0], mutex);
    serialize();

    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD / 10);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD / 10);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);

    SwitchToFiber(sigFiber);

    pthread_cond_wait_spec(context_array[0], cond, mutex);
    serialize();

    ts_sleep_msec(200);

    SwitchToFiber(sigFiber);

    pthread_mutex_unlock_spec(context_array[0], mutex);
    serialize();

    pthread_mutex_destroy_spec(context_array[0], mutex);
    pthread_cond_destroy_spec(context_array[0], cond);
    serialize();
}

void sigFiberFunc(void* x)
{
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();

    pthread_cond_signal_spec(context_array[1], cond);
    serialize();

    pthread_mutex_unlock_spec(context_array[1], mutex);
    serialize();

    SwitchToFiber(scenFiber);

    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();

    pthread_cond_broadcast_spec(context_array[1], cond);
    serialize();

    pthread_mutex_unlock_spec(context_array[1], mutex);
    serialize();

    SwitchToFiber(scenFiber);
}
*/

void doScen(void)
{
//    int i = 3;
    PThreadCondT* condObj;
    PThreadCondTPtr cond = memory_blocks[0];
    PThreadMutexTPtr mutex = memory_blocks[1];

    pthread_cond_init_spec(context_array[0], cond, NULL_VoidTPtr);
    pthread_mutex_init_spec(context_array[0], mutex, NULL_VoidTPtr);
    serialize();

    condObj = getCondVariable(cond);
    condObj->predicate = 0;

    while(!condObj->predicate)
    {
        pthread_mutex_lock_spec(context_array[1], mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);
        pthread_cond_signal_spec(context_array[1], cond);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);
        pthread_mutex_unlock_spec(context_array[1], mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);

        pthread_mutex_lock_spec(context_array[0], mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);

//        pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
        pthread_cond_wait_spec(context_array[0], cond, mutex);
        serialize();
        condObj = getCondVariable(cond);
        verbose("predicate: %d\n", condObj->predicate);
//        ts_sleep_msec(200);
    }

    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
    pthread_cond_timedwait_spec(context_array[0], cond, mutex, MILLIARD);
    pthread_mutex_lock_spec(context_array[1], mutex);
    serialize();
    pthread_cond_signal_spec(context_array[1], cond);
    serialize();
    pthread_mutex_unlock_spec(context_array[1], mutex);
    serialize();

    pthread_mutex_unlock_spec(context_array[0], mutex);
    serialize();

    pthread_mutex_destroy_spec(context_array[0], mutex);
    pthread_cond_destroy_spec(context_array[0], cond);

    serialize();
}

#define callFunc2( func, indexInContextArray, par2 )                                           \
    traceUserInfo( "doScen3 : before " #func " context_array[ " #indexInContextArray " ]\n" ); \
    func( context_array[ indexInContextArray ], par2 );                                        \
    traceUserInfo( "doScen3 : after  " #func " context_array[ " #indexInContextArray " ]\n" );

#define callFunc3( func, indexInContextArray, par2, par3 )                                     \
    traceUserInfo( "doScen3 : before " #func " context_array[ " #indexInContextArray " ]\n" ); \
    func( context_array[ indexInContextArray ], par2, par3 );                                  \
    traceUserInfo( "doScen3 : after  " #func " context_array[ " #indexInContextArray " ]\n" );

#define callFunc4( func, indexInContextArray, par2, par3, par4 )                               \
    traceUserInfo( "doScen3 : before " #func " context_array[ " #indexInContextArray " ]\n" ); \
    func( context_array[ indexInContextArray ], par2, par3, par4 );                            \
    traceUserInfo( "doScen3 : after  " #func " context_array[ " #indexInContextArray " ]\n" );

#define callSerialize( serializeName )                                  \
    traceUserInfo( "doScen3 : before serialize " #serializeName "\n" ); \
    serialize();                                                        \
    traceUserInfo( "doScen3 : after  serialize " #serializeName "\n" );

bool pre_pthread_mutex_lock_spec( CallContext context, PThreadMutexTPtr mutex );

void doScen3( void ) {
    PThreadCondTPtr cond = memory_blocks[ 0 ];
    PThreadMutexTPtr mutex = memory_blocks[ 1 ];
    const int TIME_BEFORE_DELAYED_RETURN_MSEC = 400;    // min - 200

    /*
     * Fiber 0 - signal sender
     * Fibers 1, 2 and 3 - waiters
     */

    // Fiber 1
    callFunc3( pthread_cond_init_spec, 1, cond, NULL_VoidTPtr )
    callFunc3( pthread_mutex_init_spec, 1, mutex, NULL_VoidTPtr )
    callSerialize( f11 )

    if ( pre_pthread_mutex_lock_spec( context_array[ 1 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 1, mutex )
        callSerialize( f12 )

        callFunc3( pthread_cond_wait_spec, 1, cond, mutex )
        callSerialize( f13 )
    }

    // Fiber 3
    if ( pre_pthread_mutex_lock_spec( context_array[ 3 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 3, mutex )
        callSerialize( f31 )

        callFunc4( pthread_cond_timedwait_spec, 3, cond, mutex, 2000000000 )
        callSerialize( f32 )
    }

    // Fiber 2
    if ( pre_pthread_mutex_lock_spec( context_array[ 2 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 2, mutex )
        callSerialize( f21 )

        callFunc4( pthread_cond_timedwait_spec, 2, cond, mutex, 1000 )
        callSerialize( f22 )

        callFunc2( pthread_mutex_unlock_spec, 2, mutex )
        callSerialize( f23 )
    }

    // Common
    ts_sleep_msec( 50 );

    // Fiber 0
    if ( pre_pthread_mutex_lock_spec( context_array[ 0 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 0, mutex )
        callSerialize( f01 )

        callFunc2( pthread_cond_broadcast_spec, 0, cond )
        callSerialize( f02 )
    }

    // Common
    {   int unlockFor[ 3 ] = { 0, 1, 3 }; // unlock for 0, 1, 3
        const int unlockForSize = sizeof( unlockFor ) / sizeof( unlockFor[ 0 ] );
        int findingNumber, i;
        for ( findingNumber = 1; findingNumber <= unlockForSize; findingNumber++ ) {
            Mutex * mutexObj = getMutex( mutex );
            bool contextOwnerFound = false;
            for ( i = 0; i < unlockForSize && ! contextOwnerFound; i++ ) {
                if ( equals_ThreadId( mutexObj->owner, context_array[ unlockFor[ i ] ] ) ) {
                    contextOwnerFound = true;
                    traceFormattedUserInfo( "doScen3 : mutex owner found for finding number %d\n", findingNumber );
                    traceFormattedUserInfo
                        ( "doScen3 : before pthread_mutex_unlock_spec context_array[ %d ]\n", unlockFor[ i ] );
                    pthread_mutex_unlock_spec( context_array[ unlockFor[ i ] ], mutex );
                    traceFormattedUserInfo
                        ( "doScen3 : after  pthread_mutex_unlock_spec context_array[ %d ]\n", unlockFor[ i ] );
                    callSerialize( c1 )
                }
            }
            if ( ! contextOwnerFound ) {
                traceFormattedUserInfo( "doScen3 : mutex owner not found for finding number %d\n", findingNumber );
                Error = true;
                setBadVerdict( "Incorrect Mutex owner!" );
                return;
            }
        }
    }

    // Fiber 0
    if ( pre_pthread_mutex_lock_spec( context_array[ 0 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 0, mutex )
        callSerialize( f03 )

        callFunc2( pthread_cond_broadcast_spec, 0, cond )
        callSerialize( f04 )

        callFunc2( pthread_mutex_unlock_spec, 0, mutex )
        callSerialize( f05 )
    }

    // Fiber 1
    if ( pre_pthread_mutex_lock_spec( context_array[ 1 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 1, mutex )
        callSerialize( f14 )

        callFunc3( pthread_cond_wait_spec, 1, cond, mutex )
        callSerialize( f15 )
    }

    // Fiber 2
    if ( pre_pthread_mutex_lock_spec( context_array[ 2 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 2, mutex )
        callSerialize( f24 )

        callFunc3( pthread_cond_wait_spec, 2, cond, mutex )
        callSerialize( f25 )
    }

    // Fiber 0
    if ( pre_pthread_mutex_lock_spec( context_array[ 0 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 0, mutex )
        callSerialize( f06 )

        callFunc2( pthread_cond_signal_spec, 0, cond )
        ts_sleep_msec( TIME_BEFORE_DELAYED_RETURN_MSEC );
        callFunc2( pthread_cond_signal_spec, 0, cond )
        ts_sleep_msec( TIME_BEFORE_DELAYED_RETURN_MSEC );
        callSerialize( f07 )
    }

    // Common
    {   Mutex * mutexObj = getMutex( mutex );
        int unlockCount = 0;
        while ( ! equals_ThreadId( mutexObj->owner, WrongThreadId ) ) {
            traceFormattedUserInfo( "doScen3 : unlock number %d for mutex\n", ++unlockCount );
            traceUserInfo( "doScen3 : before pthread_mutex_unlock_spec mutexObj->owner\n" );
            pthread_mutex_unlock_spec( mutexObj->owner, mutex );
            traceUserInfo( "doScen3 : after  pthread_mutex_unlock_spec mutexObj->owner\n" );
            callSerialize( c2 )
            mutexObj = getMutex( mutex );
        }
    }

    // Fiber 2
    if ( pre_pthread_mutex_lock_spec( context_array[ 2 ], mutex ) ) {
        callFunc2( pthread_mutex_lock_spec, 2, mutex )
        callSerialize( f26 )

        callFunc2( pthread_cond_signal_spec, 2, cond )
        callSerialize( f27 )

        callFunc2( pthread_mutex_unlock_spec, 2, mutex )
        callSerialize( f28 )
    }

    // Fiber 1
    callFunc2( pthread_mutex_destroy_spec, 1, mutex )
    callFunc2( pthread_cond_destroy_spec, 1, cond )
    callSerialize( f16 )
}

#undef callFunc2
#undef callFunc3
#undef callFunc4
#undef callSerialize

scenario bool sc_forever_scen() {
    EXECUTE_EXPLICIT_FSM( doScen3 );
    return ! Error;
}

scenario dfsm pthread_cond_cond_single_scenario =
{
    .init = init_single_cond_scenario,
    .finish = finish_single_cond_scenario,
    //.getState = (PtrGetState)get_SingleCondState,
    .saveModelState = (PtrSaveModelState)saveSingleCondState,
    .restoreModelState = (PtrRestoreModelState)restoreSingleCondState,
    .isStationaryState = (PtrIsStationaryState)isCondModelStateStationary,
    .actions = { sc_forever_scen,
                 NULL
               }
};
