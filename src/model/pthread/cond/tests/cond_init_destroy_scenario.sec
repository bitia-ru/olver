/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "pthread/cond/tests/cond_scenario.seh"
#include "pthread/cond/cond_model.seh"
#include "system/system/system_model.seh"
#include "common/common_scenario.seh"
#include "common/common_media.seh"
#include "atl/integer.h"

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

/* number of threads */
#define THREAD_NUM 4

/* number of conditional variables */
#define COND_NUM 2

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/

static CallContext context;
static CallContext context_array[THREAD_NUM];
static VoidTPtr    memory_blocks[COND_NUM];

#define CONDITION_NOT_INITIALIZED (-1)
static List* condInitList = NULL;

/********************************************************************/
/**                         Auxiliary Types                        **/
/********************************************************************/

specification typedef struct CondInitDestroyModelState
{
    Map* systems;
    List* condInitList;
} CondInitDestroyModelState = {};

CondInitDestroyModelState * create_CondInitDestroyModelState(
    Map* systems,
    List* condInitList
)
{
    return create(&type_CondInitDestroyModelState, systems, condInitList);
}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

void cleanup_cond_init_destroy_scenario()
{
    int i;

    /* delete threads */
    for(i = 1; i < THREAD_NUM; i++)
    {
        if(!isWrong_ThreadId(context_array[i]))
        {
            // TODO: delete thread
        }
    }

    /* deallocate memory */
    for(i = 0; i < COND_NUM; i++)
    {
        if (!isNULL_VoidTPtr(memory_blocks[i]))
        {
            deallocateMemoryBlock(context, memory_blocks[i]);
        }
    }
}

bool init_cond_init_destroy_scenario(int argc, char** argv)
{
    int i;

    bool result = true;

    /* initialize arrays */
    for(i = 0; i < THREAD_NUM; i++)
    {
        context_array[i].system = WrongId;
    }

    for(i = 0; i < COND_NUM; i++)
    {
        memory_blocks[i] = NULL_VoidTPtr;
    }

    /* create threads */
    context = getContext();
    context_array[0] = context;

    for(i = 1; i < THREAD_NUM; i++)
    {
        context_array[i] = createThread();

        if(isWrong_ThreadId(context_array[i]))
        {
            result = false;
            break;
        }
    }

    if (result)
    {
        /* allocate memory */
        for(i = 0; i < COND_NUM; i++)
        {
            memory_blocks[i] = allocateMemoryBlock(context, 1024);
            if (isNULL_VoidTPtr(memory_blocks[i]))
            {
                result = false;
                break;
            }
        }
    }

    if (!result)
    {
        cleanup_cond_init_destroy_scenario();
        return false;
    }

    /* fill model state */
    condInitList = create_List(&type_Integer);
    for(i = 0; i < COND_NUM; i++)
    {
        append_List(condInitList, create_Integer(CONDITION_NOT_INITIALIZED));
    }

    setTSTimeModel(NotUseTSTime);

    return true;
}

void finish_cond_init_destroy_scenario(void)
{
    cleanup_cond_init_destroy_scenario();
    return;
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/

List* get_CondInitDestroyState(void)
{
    return clone(condInitList);
}

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

CondInitDestroyModelState* saveCondInitDestroyState(void)
{
    return create_CondInitDestroyModelState(systems, condInitList);
}

void restoreCondInitDestroyState(CondInitDestroyModelState* modelState)
{
    systems = modelState->systems;
    condInitList = modelState->condInitList;
}

/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario
bool cond_init_scen()
{
    iterate(int i = 0; i < THREAD_NUM; i++;)
    {
        iterate(int j = 0; j < COND_NUM; j++;)
        {
            Integer* condInitialized = get_List(condInitList, j);

            if (*condInitialized == CONDITION_NOT_INITIALIZED)
            {
                pthread_cond_init_spec(context_array[i], memory_blocks[j], NULL_VoidTPtr);
                *condInitialized = i;
            }
        }
    }
    return true;
}

scenario
bool cond_destroy_scen()
{
    iterate(int i = 0; i < THREAD_NUM; i++;)
    {
        iterate(int j = 0; j < COND_NUM; j++;)
        {
            Integer* condInitialized = get_List(condInitList, j);

            if (*condInitialized != CONDITION_NOT_INITIALIZED)
            {
                pthread_cond_destroy_spec(context_array[i], memory_blocks[j]);
                *condInitialized = CONDITION_NOT_INITIALIZED;
            }
        }
    }
    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm pthread_cond_cond_init_destroy_scenario =
{
    .init = init_cond_init_destroy_scenario,
    .finish = finish_cond_init_destroy_scenario,
    .getState = (PtrGetState)get_CondInitDestroyState,
    .saveModelState = (PtrSaveModelState)saveCondInitDestroyState,
    .restoreModelState = (PtrRestoreModelState)restoreCondInitDestroyState,
    .isStationaryState = (PtrIsStationaryState)isCondModelStateStationary,
    .actions = {
            cond_init_scen,
            cond_destroy_scen,
            NULL
    }
};



