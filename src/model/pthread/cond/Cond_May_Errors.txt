Эти сценарии вешают целевую систему:

pthread_cond_init(&cond, NULL);
pthread_cond_destroy(&cond);
pthread_cond_destroy(&cond);

pthread_cond_init(&cond, NULL);
pthread_cond_destroy(&cond);
pthread_cond_broadcast(&cond);

pthread_cond_init(&cond, NULL);
pthread_cond_destroy(&cond);
pthread_cond_signal(&cond);

pthread_cond_init(&cond, NULL);
pthread_cond_destroy(&cond);
pthread_cond_[timed]wait(&cond);

В последнем случае проверка проводилась с запуском второго потока, посылающего signal, так что это именно повисание как ошибка, а не как нормальное ожидание по wait'у.

-------
Тестовый сценарий для проверки ERROR-макросов (тестовая машина - Fedora):
1. Установить PTHREAD_COND_TIMEDWAIT_FAILS_WITH_EINVAL_ON_BAD_COND в 1.
2. В сценарии sc_errors_scen в блоке, обрамлённом этой константой, закомментировать второй вызов timedwait.
3. Запустить. Сценарий должен выдать FAILED по причине: функция вернула ETIMEOUT, хотя должна была вернуть EINVAL.
