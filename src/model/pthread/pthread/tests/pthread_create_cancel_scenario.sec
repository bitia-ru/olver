/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "pthread/pthread/tests/pthread_scenario.seh"
#include "common/explicit_fsm.h"

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/
#define NUM_THREADS 5
#define MAX_SIZE    10000

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext     context;
static PThreadAttrTPtr attrs[NUM_THREADS];
static ThreadId        threadIDs[NUM_THREADS];
static IntT            curNumThreads=0;
static IntT            cancelStates[] ={ SUT_PTHREAD_CANCEL_ENABLE,  
                                  SUT_PTHREAD_CANCEL_DISABLE, 100};
static IntT numCancelStates=sizeof(cancelStates)/sizeof(IntT);

static bool cancelStateSet=false;

static IntT            cancelTypes[]  ={ SUT_PTHREAD_CANCEL_DEFERRED, 
                                  SUT_PTHREAD_CANCEL_ASYNCHRONOUS, 1000};
static IntT numCancelTypes=sizeof(cancelTypes)/sizeof(IntT);
static bool cancelTypeSet=false;


static bool firstTime=true;

static Set* allThreads;



static IntT detachStates[] = {SUT_PTHREAD_CREATE_DETACHED, 
                       SUT_PTHREAD_CREATE_JOINABLE, 2000};
static IntT numDetachStates=sizeof(detachStates)/sizeof(IntT);


static IntT guardSizes[] = {0, 1000, 2000};
static IntT numGuardSizes=sizeof(guardSizes)/sizeof(IntT);


static IntT inheritedScheds[] = {SUT_PTHREAD_INHERIT_SCHED, 
                          SUT_PTHREAD_EXPLICIT_SCHED, 30};
static IntT numInheritedScheds=sizeof(inheritedScheds)/sizeof(IntT);

static ShedParam* schedulingParam;


static IntT policies[]= {SUT_SCHED_FIFO, SUT_SCHED_RR, SUT_SCHED_OTHER, 
                  SUT_SCHED_SPORADIC, 20};
static IntT numPolicies=sizeof(policies)/sizeof(IntT);


static IntT scopes[]= {SUT_PTHREAD_SCOPE_SYSTEM, SUT_PTHREAD_SCOPE_PROCESS, 
                  130};
static IntT numScopes=sizeof(scopes)/sizeof(IntT);


static SizeT stackSizes[]= {0, 8192, 12288};
static IntT numStackSizes=sizeof(stackSizes)/sizeof(SizeT);



/********************************************************************/
/**                         Auxiliary Types                        **/
/********************************************************************/


specification typedef struct PThreadState
{
    IntT numThreads;
    bool stateSet;
    bool typeSet;
} PThreadState;

specification typedef struct PThreadState PThreadState = {};

PThreadState * create_PThreadState(
    IntT numThreads,
    bool stateSet,
    bool typeSet
    )
{
    return create(
        &type_PThreadState,
        numThreads,
        stateSet,
        typeSet
        );
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/


static Object* getPthreadCreateCancelState(void)
{
    return create_PThreadState( curNumThreads, 
        cancelStateSet, cancelTypeSet);
}


static bool init_simple_scenario(int argc, char** argv)
{
    int i=0;
    IntT            sched_priority=0;
    IntT            sched_ss_low_priority=2;
    TimeSpecT       timespec1 = {25, 45};
    TimeSpecTObj*   sched_ss_repl_period=create_TimeSpecTObj(timespec1);  
    TimeSpecT       timespec2 = {25, 5};
    TimeSpecTObj*   sched_ss_init_budget=create_TimeSpecTObj(timespec2);  
    IntT            sched_ss_max_repl=5;     
    context = createProcess();//getContext();
    
    curNumThreads=0;
    cancelStateSet=false;
    cancelTypeSet=false;
    firstTime=true;
    allThreads=create_Set(&type_ThreadIdObj);
    
    setTSTimeModel(NotUseTSTime);
    setFindFirstSeriesOnly(false);
    setWTimeMSec(SERIALIZATION_TIME);
    
    schedulingParam=create_ShedParam( sched_priority, 
        sched_ss_low_priority, sched_ss_repl_period, sched_ss_init_budget, 
        sched_ss_max_repl);;
    
    return true;
    
}


static void finish_simple_scenario(void)
{
    int i=0;

    for (i=0;i<NUM_THREADS;i++)
    {
        deallocateMemoryBlock(context, attrs[i]);
    }
    terminateProcess(context);
}

scenario
bool pthread_create_scen()
{
    int i=0;
    if (firstTime)
    {
        for (i=0;i<NUM_THREADS-1;i++)
        {
            attrs[i]=allocateMemoryBlock(context, MAX_SIZE);
            if (isNULL_VoidTPtr(attrs[i]))
                return false;
            pthread_attr_init_spec(context, attrs[i]);
            pthread_attr_init_spec(context, attrs[i]);
        }
        attrs[i] = NULL_VoidTPtr;
        firstTime=false;
    }
    
    if (curNumThreads<NUM_THREADS)
    {
        IntT curDetachState=detachStates[curNumThreads%numDetachStates];
        IntT curGuardSize=guardSizes[curNumThreads%numGuardSizes];
        IntT curInhSched=inheritedScheds[curNumThreads%numInheritedScheds];
        IntT curPolicy=policies[curNumThreads%numPolicies];
        IntT curScope=scopes[curNumThreads %numScopes];
        VoidTPtr curStackPtr=allocateMemoryBlock(context, 60000);
        SizeT curStackSize= stackSizes[curNumThreads%numStackSizes];
        
        curStackPtr.address=curStackPtr.address+(curStackPtr.address%16);
        
        if(!isNULL_VoidTPtr(attrs[curNumThreads]))
        {
            pthread_attr_destroy_spec(context, attrs[curNumThreads]);
            
            attrs[curNumThreads] = allocateMemoryBlock(context, MAX_SIZE);
            if (isNULL_VoidTPtr(attrs[curNumThreads]))
                return false;
            
            pthread_attr_init_spec(context, attrs[curNumThreads]);
            if (curNumThreads!=NUM_THREADS-2)
            {
                pthread_attr_setdetachstate_spec(context, attrs[curNumThreads], 
                    curDetachState);
                pthread_attr_setguardsize_spec(context, attrs[curNumThreads], 
                    curGuardSize);
                
                pthread_attr_setinheritsched_spec(context, attrs[curNumThreads], 
                    curInhSched);
                
                pthread_attr_setschedparam_spec(context, attrs[curNumThreads], 
                    schedulingParam);
                //       pthread_attr_setschedpolicy_spec(context, attrs[curNumThreads],
                //                                        curPolicy);
                pthread_attr_setscope_spec(context, attrs[curNumThreads],
                    curScope);
                
                pthread_attr_setstack_spec(context, attrs[curNumThreads], 
                    curStackPtr, curStackSize);
                
            }
        }
        
        if(pthread_create_spec(context, &threadIDs[curNumThreads], 
            attrs[curNumThreads], generateVirtualPointer(context))==0)
        {
            add_Set(allThreads, create_ThreadIdObj(threadIDs[curNumThreads]));
        }
        curNumThreads++;
    }
    return true;
    
}

scenario
bool pthread_cancel_scen()
{
    CallContext curContext;
    if (curNumThreads>0)
    {
        curContext=threadIDs[curNumThreads-1];
        pthread_testcancel_spec(curContext, cancel_status);
        pthread_self_spec(curContext);
        __errno_location_spec(curContext);
        pthread_cancel_spec(context, threadIDs[curNumThreads-1]);
        pthread_cancel_spec(context, threadIDs[curNumThreads-1]);
        pthread_detach_spec(context, threadIDs[curNumThreads-1]);
        curNumThreads--;
    }
    
    if (curNumThreads==0)
    {
        cancelStateSet=false;
        cancelTypeSet=false;
    }
    return true;
    
}

scenario
bool pthread_cancel_state_scen()
{
    int i;
    if (cancelStateSet)
    {
        return true;
    }
    if (curNumThreads<numCancelStates)
    {
        return true;
    }
    for (i=0;i<numCancelStates;i++)
    {
        pthread_setcancelstate_spec(threadIDs[i], cancelStates[i]);
    }
    
    cancelStateSet=true;
    
    return true;
}

scenario
bool pthread_cancel_type_scen()
{
    int i=0;
    if (cancelTypeSet)
    {
        return true;
    }
    if (curNumThreads<numCancelTypes)
    {
        return true;
    }
    for (i=0;i<numCancelTypes;i++)
    {
        pthread_setcanceltype_spec(threadIDs[i], cancelTypes[i]);
    }
    cancelTypeSet=true;
    
    return true;
    
}

void pthread_cancelpoints_scen_explicit(void)
{
    ThreadId curTh=createThreadInContext(context);
    ThreadId toJoin=createThreadInContext(context);
    VoidTPtr param=generateVirtualPointer(context);
    int i;
    serialize();

    pthread_setcancelstate_spec(curTh, SUT_PTHREAD_CANCEL_DISABLE);    
    serialize();

    pthread_cancel_spec(context, curTh);
    pthread_testcancel_spec(curTh, cancel_status);
    pthread_join_spec(curTh, toJoin, &param);

    serialize();

    pthread_exit_spec(toJoin, generateVirtualPointer(toJoin));    
    serialize();

    // curTh supposed to stay alive at this point. Kill it.
    if(isThreadActive(curTh))
    {
        pthread_exit_spec(curTh, NULL_VoidTPtr);
    } else {
        setBadVerdict("pthread_cancelpoints_scen_explicit: (1) thread curTh should be active");
    }
    
    serialize();

    curTh=createThreadInContext(context);

    serialize();

    pthread_setcancelstate_spec(curTh, SUT_PTHREAD_CANCEL_ENABLE);
    serialize();

    pthread_cancel_spec(context, curTh);
    ts_sleep_msec(300);

    serialize();
    pthread_testcancel_spec(curTh, cancel_status);
    ts_sleep_msec(300);
    serialize();
    
    if(isThreadActive(curTh))
    {
        setBadVerdict("pthread_cancelpoints_scen_explicit: (2) thread curTh should be cancelled");
        pthread_exit_spec(curTh, NULL_VoidTPtr);
    } 

    serialize();
    
    curTh=createThreadInContext(context);
    toJoin=createThreadInContext(context);

    serialize();

    pthread_setcancelstate_spec(curTh, SUT_PTHREAD_CANCEL_ENABLE);
    serialize();

    pthread_cancel_spec(context, curTh);    
    ts_sleep_msec(300);
    serialize();

    pthread_join_spec(curTh, toJoin, &param);
    ts_sleep_msec(300);
    
    serialize();

    if(isThreadActive(curTh))
    {
        setBadVerdict("pthread_cancelpoints_scen_explicit: (3) thread curTh should be cancelled in call to a JOIN");

        pthread_exit_spec(curTh, NULL_VoidTPtr);
        serialize();
    }

    if(isThreadActive(toJoin))
    {
        pthread_exit_spec(toJoin, NULL_VoidTPtr);
        serialize();
    }

    curTh=createThreadInContext(context);

    serialize();

    pthread_setcancelstate_spec(curTh, SUT_PTHREAD_CANCEL_ENABLE);
    pthread_cancel_spec(context, curTh);
    ts_sleep_msec(300);
    pthread_testcancel_spec(curTh, cancel_status);    
    ts_sleep_msec(300);
    serialize();

    if(isThreadActive(curTh))
    {
        pthread_self_spec(curTh);
        serialize();

        setBadVerdict("pthread_cancelpoints_scen_explicit: (4) thread curTh should be cancelled");
        pthread_exit_spec(curTh, NULL_VoidTPtr);
    } 
    serialize();
}

scenario
bool pthread_cancelpoints_scen()
{
    EXECUTE_EXPLICIT_FSM(pthread_cancelpoints_scen_explicit);

    return true;
}

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

static bool isPThreadModelStateStationary(void)
{
    int i=0;
    ProcessState*  ps=getProcessState_CallContext(context);
    ThreadId thid;
    ThreadState*   thState;
    
    for (i=0;i<curNumThreads;i++)
    {
        thid=threadIDs[i];
        thState = get_Map(ps->threads, create_ThreadIdObj(thid));
        if (thState==NULL)
        {
            return false;
        }
    }
    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm pthread_create_cancel_scenario =
{
  .init = init_simple_scenario,
    .finish = finish_simple_scenario,
    .getState = getPthreadCreateCancelState,
    .saveModelState = (PtrSaveModelState)savePThreadModelState,
    .restoreModelState = (PtrRestoreModelState)restorePThreadModelState,
    .isStationaryState = (PtrIsStationaryState)isPThreadModelStateStationary,
    .actions = {
      pthread_cancel_type_scen,
      pthread_cancel_state_scen,
      pthread_create_scen,
      pthread_cancel_scen,
      NULL
  }
};


scenario dfsm pthread_cancelpoints_scenario =
{
    .init = init_simple_scenario,
    .finish = finish_simple_scenario,
    .getState = getPthreadCreateCancelState,
    .saveModelState = (PtrSaveModelState)savePThreadModelState,
    .restoreModelState = (PtrRestoreModelState)restorePThreadModelState,
    .isStationaryState = (PtrIsStationaryState)isPThreadModelStateStationary,
    .actions = {
        pthread_cancelpoints_scen,
        NULL
    }
};


