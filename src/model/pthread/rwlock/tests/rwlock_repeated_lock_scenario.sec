/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "pthread/rwlock/rwlock_model.seh"
#include "pthread/rwlock/tests/rwlock_scenario.seh"

#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/control_center.seh"

#include "common/common_scenario.seh"
#include "system/system/system_model.seh"

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/
/* number of threads */
#define THREAD_NUM_REPEAT 3
/* number of threads */
#define MAX_READ_LOCKS 2

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/

static VoidTPtr rwlock;
static VoidTPtr rwlock_area;
static CallContext context_rp;
static CallContext contexts_rp[THREAD_NUM_REPEAT];

/********************************************************************/
/**                         Auxiliary Types                        **/
/********************************************************************/

specification typedef struct RwlockStateSpecZ_RP
{
    bool initialized;
    int  wlocked[THREAD_NUM_REPEAT];
    unsigned int readers[THREAD_NUM_REPEAT];
    unsigned int readers_wait[THREAD_NUM_REPEAT];
    unsigned int writers_wait[THREAD_NUM_REPEAT];
} RwlockStateSpecZ_RP;

specification typedef struct RwlockStateSpecZ_RP RwlockStateSpecZ_RP = {};

RwlockStateSpecZ_RP * create_RwlockStateSpecZ_RP(
    bool initialized,
    int  wlocked[THREAD_NUM_REPEAT],
    unsigned int readers[THREAD_NUM_REPEAT],
    unsigned int readers_wait[THREAD_NUM_REPEAT],
    unsigned int writers_wait[THREAD_NUM_REPEAT]
)
{
    return create(&type_RwlockStateSpecZ_RP,
        initialized,
        wlocked,
        readers,
        readers_wait,
        writers_wait
        );

}

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

void cleanup_rp_complete_scenario()
{
    int i;

    /* delete threads */
    for(i = 1; i < THREAD_NUM_REPEAT; i++)
    {
        if(!isWrong_ThreadId(contexts_rp[i]))
        {
            // TODO: delete thread
        }
    }

    if (!isNULL_VoidTPtr(rwlock_area)) deallocateMemoryBlock(context_rp, rwlock_area);
}

void finish_rp_complete_scenario(void)
{
    cleanup_rp_complete_scenario();
}

bool init_rp_complete_scenario(int argc, char** argv)
{
    int i;
    bool result = true;

    context_rp = getContext();
    contexts_rp[0] = context_rp;

    /* create threads */
    for(i=1;i<THREAD_NUM_REPEAT;i++)
    {
        contexts_rp[i] = createThread();
        if(isWrong_ThreadId(contexts_rp[i])) result = false;
    }

    rwlock_area = allocateMemoryBlock(context_rp, 1024);
    if (isNULL_VoidTPtr(rwlock_area)) result = false;
    rwlock = NULL_VoidTPtr;

    setTSTimeModel(NotUseTSTime);
    setWTimeMSec(SERIALIZATION_TIME);

    setFindFirstSeriesOnly(true);

    if(!result) cleanup_rp_complete_scenario();
    return result;
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/

RwlockStateSpecZ_RP* get_RwlockStateZ_RP(void)
{
    bool initialized = false; int wlocked[THREAD_NUM_REPEAT];
    unsigned int readers[THREAD_NUM_REPEAT], readers_wait[THREAD_NUM_REPEAT], writers_wait[THREAD_NUM_REPEAT];
    unsigned int i;

    CallContext thread;
    Map* threads;
    int size;

    for(i=0;i<THREAD_NUM_REPEAT;i++)
    {
        wlocked[i]=0;
        readers[i]=0;
        readers_wait[i]=0;
        writers_wait[i]=-1;
    }

    if(isNULL_VoidTPtr(rwlock)) initialized = false; else initialized = true;

    if(initialized)
    {
        Rwlock* rw_m = getRwlock(rwlock);
        List *cl_writer_wait_list;

        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            wlocked[i] = ThreadWriter(rw_m, contexts_rp[i]);
            readers[i] = howManyThreadReader(rw_m, contexts_rp[i]);
            readers_wait[i] = contains_Set(rw_m->reader_wait_list, create_ThreadIdObj(contexts_rp[i]));
        }

        // full writers_wait according to priority
        cl_writer_wait_list = clone(rw_m->writer_wait_list);
        threads = getThreads(contexts_rp[0]);

        size = size_List(cl_writer_wait_list);
        for(i=0; i<size; i++)
        {
            if(isEmpty_List(cl_writer_wait_list)) break;
            thread = getNextThread_SchedulingPolicy(threads, cl_writer_wait_list);
            writers_wait[getThreadIndexByValue(thread)] = i;
            remove_List(cl_writer_wait_list, indexOf_List( cl_writer_wait_list, create_ThreadIdObj(thread)));
        }
    }

    return create_RwlockStateSpecZ_RP(initialized, wlocked, readers, readers_wait, writers_wait);
}

/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario
bool rp_rdlock_takeover_scen()
{
    unsigned int i;

    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if (!LockedByWriter(rwlock_m) && howManyThreadReader(rwlock_m, tmp) < MAX_READ_LOCKS
                && !ThreadWaitReader(rwlock_m, tmp)&& !ThreadWaitWriter(rwlock_m, tmp))
            {
                verbose("RDLOCK          %u\n", tmp.thread);
                pthread_rwlock_rdlock_spec(contexts_rp[i], rwlock);
                break;
            }
        }
    }
    return true;
}

scenario
bool rp_tryrdlock_takeover_scen()
{
    unsigned int i;
    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if (!LockedByWriter(rwlock_m) && howManyThreadReader(rwlock_m, tmp) < MAX_READ_LOCKS
                && !ThreadWaitReader(rwlock_m, tmp)&& !ThreadWaitWriter(rwlock_m, tmp))
            {
                verbose("TRYRDLOCK          %u\n", tmp.thread);
                pthread_rwlock_tryrdlock_spec(contexts_rp[i], rwlock);
                break;
            }
        }
    }
    return true;
}

scenario
bool rp_rdlock_stuck_scen()
{
    unsigned int i;
    if (!isNULL_VoidTPtr(rwlock))
    {
        for (i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if(!ThreadReader(rwlock_m, tmp) && !ThreadWaitReader(rwlock_m, tmp)&& !ThreadWaitWriter(rwlock_m, tmp))
            {
                if (LockedByWriter(rwlock_m)&& !ThreadWriter(rwlock_m, tmp))
                {
                    verbose("RDLOCK STUCK            %u\n", tmp.thread);
                    pthread_rwlock_rdlock_spec(contexts_rp[i], rwlock);
                    break;
                }
            }
        }
    }
    return true;
}

scenario
bool rp_tryrdlock_stuck_scen()
{
    unsigned int i;
    if (!isNULL_VoidTPtr(rwlock))
    {
        for (i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if(!ThreadReader(rwlock_m, tmp) && !ThreadWaitReader(rwlock_m, tmp) && !ThreadWaitWriter(rwlock_m, tmp))
            {
                if (LockedByWriter(rwlock_m)&& !ThreadWriter(rwlock_m, tmp))
                {
                    verbose("TRYRDLOCK STUCK            %u\n", tmp.thread);
                    pthread_rwlock_tryrdlock_spec(contexts_rp[i], rwlock);
                    break;
                }
            }
        }
    }
    return true;
}


scenario
bool rp_wrlock_takeover_scen()
{
    unsigned int i;

    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if (!LockedByWriter(rwlock_m) && !ReaderExist(rwlock_m))
            {
                verbose("WRLOCK TAKEOVER         %u\n", tmp.thread);
                pthread_rwlock_wrlock_spec(contexts_rp[i], rwlock);
                break;
            }
        }
    }
    return true;
}

scenario
bool rp_trywrlock_takeover_scen()
{
    unsigned int i;

    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if (!LockedByWriter(rwlock_m) && !ReaderExist(rwlock_m))
            {
                verbose("TRYWRLOCK TAKEOVER         %u\n", tmp.thread);
                pthread_rwlock_trywrlock_spec(contexts_rp[i], rwlock);
                break;
            }
        }
    }
    return true;
}

scenario
bool rp_wrlock_stuck_scen()
{
    unsigned int i;

    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if(!ThreadWriter(rwlock_m, tmp) && !ThreadReader(rwlock_m, tmp) && !ThreadWaitReader(rwlock_m, tmp)
                && !ThreadWaitWriter(rwlock_m, tmp))
            {
                if(ReaderExist(rwlock_m)||
                    LockedByWriter(rwlock_m)
                    )
                {
                    verbose("WRLOCK STUCK         %u %u \n", getThreadIndexByValue(tmp), tmp.thread);
                    pthread_rwlock_wrlock_spec(tmp, rwlock);
                    break;
                }
            }
        }
    }
    return true;
}

scenario
bool rp_trywrlock_stuck_scen()
{
    unsigned int i;

    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if(!ThreadWriter(rwlock_m, tmp) && !ThreadReader(rwlock_m, tmp) && !ThreadWaitReader(rwlock_m, tmp)
                && !ThreadWaitWriter(rwlock_m, tmp))
            {
                if(ReaderExist(rwlock_m)||
                    LockedByWriter(rwlock_m)
                    )
                {
                    verbose("TRYWRLOCK STUCK         %u\n", tmp.thread);
                    pthread_rwlock_trywrlock_spec(tmp, rwlock);
                    break;
                }
            }
        }
    }
    return true;
}


scenario
bool rp_unlock_reader_scen()
{
    unsigned int i;

    if (!isNULL_VoidTPtr(rwlock))
    {
        for(i=0;i<THREAD_NUM_REPEAT;i++)
        {
            CallContext tmp = contexts_rp[i];
            Rwlock* rwlock_m = getRwlock(rwlock);
            if (ThreadReader(rwlock_m, tmp))
            {
                verbose("UNLOCK READER           %u\n", tmp.thread);
                pthread_rwlock_unlock_spec(contexts_rp[i], rwlock);
                ts_sleep_msec(200);
                break;
            }
        }
    }
    return true;
}

scenario
bool rp_unlock_writer_scen()
{
    if (!isNULL_VoidTPtr(rwlock))
    {
        Rwlock* rwlock_m = getRwlock(rwlock);
        if (LockedByWriter(rwlock_m))
        {
            Rwlock* rwlock_m = getRwlock(rwlock);
            verbose("UNLOCK WRITER           %u\n", rwlock_m->writer.thread);
            pthread_rwlock_unlock_spec(rwlock_m->writer, rwlock);
            ts_sleep_msec(200);
        }
    }
    return true;
}

scenario
bool rp_pthread_rwlock_init_scen()
{
    if (isNULL_VoidTPtr(rwlock))
    {
        verbose("pthread_rwlock_init_scen *****\n");
        pthread_rwlock_init_spec(contexts_rp[0], rwlock_area, NULL_VoidTPtr);
        rwlock = rwlock_area;
    }
    return true;
}

scenario
bool rp_pthread_rwlock_destroy_scen()
{
    if (!isNULL_VoidTPtr(rwlock))
    {
        if(isDestroyPossible(rwlock))
        {
            verbose("pthread_rwlock_destroy_scen *****\n");
            pthread_rwlock_destroy_spec(contexts_rp[0], rwlock);
            rwlock = NULL_VoidTPtr;
        }
    }
    return true;
}

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/
Map* saveRepeatModelState(void)
{
    return clone(systems);
}

void restoreRepeatModelState(Map* saved_state)
{
    systems = saved_state;
}

bool isRepeatModelStateStationary(void)
{
    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm pthread_rwlock_rwlock_repeated_lock_scenario =
{
    .init = init_rp_complete_scenario,
    .finish = finish_rp_complete_scenario,
    .getState = (PtrGetState)get_RwlockStateZ_RP,
    .saveModelState = (PtrSaveModelState)saveRepeatModelState,
    .restoreModelState = (PtrRestoreModelState)restoreRepeatModelState,
    .isStationaryState = (PtrIsStationaryState)isRepeatModelStateStationary,
    .actions = {
            rp_pthread_rwlock_init_scen,

            rp_rdlock_takeover_scen,
            rp_rdlock_stuck_scen,

            rp_tryrdlock_takeover_scen,
            rp_tryrdlock_stuck_scen,

            rp_wrlock_takeover_scen,
            rp_wrlock_stuck_scen,

            rp_trywrlock_takeover_scen,
            rp_trywrlock_stuck_scen,

            rp_unlock_writer_scen,
            rp_unlock_reader_scen,

            rp_pthread_rwlock_destroy_scen,
            NULL
    }
};

/********************************************************************/
/**                  Debug Functions                               **/
/********************************************************************/

int getThreadIndexByValue(CallContext thread)
{
    int i=0;
    for(i=0; i<THREAD_NUM_REPEAT; i++)
    {
        if(equals_ThreadId(thread, contexts_rp[i])) return i;
    }
    return -1;
}
