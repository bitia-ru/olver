/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "pthread/rwlock/tests/rwlock_scenario.seh"
#include "pthread/rwlock/rwlock_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/control_center.seh"

#include "common/common_scenario.seh"
#include "system/system/system_model.seh"

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

bool LockedByWriter(Rwlock *rwlock_m)
{
    return !isWrong_ThreadId(rwlock_m->writer);
}

bool ThreadWriter(Rwlock *rwlock_m, CallContext thread)
{
    return equals(create_ThreadIdObj(rwlock_m->writer), create_ThreadIdObj(thread));
}

bool ThreadReader(Rwlock *rwlock_m, CallContext thread)
{
    MultiSet* readers = rwlock_m->readers_list;
    return contains_MultiSet( readers, create_ThreadIdObj(thread));
}

bool ThreadWaitReader(Rwlock *rwlock_m, CallContext thread)
{
    Set* wait_readers = rwlock_m->reader_wait_list;
    return contains_Set( wait_readers, create_ThreadIdObj(thread));
}

bool ThreadWaitWriter(Rwlock *rwlock_m, CallContext thread)
{
    List* wait_writers = rwlock_m->writer_wait_list;
    return contains_List(wait_writers, create_ThreadIdObj(thread));
}

bool ReaderExist(Rwlock *rwlock_m)
{
    MultiSet* readers = rwlock_m->readers_list;
    return size_MultiSet(readers) > 0;
}

unsigned int howManyThreadReader(Rwlock *rwlock_m, CallContext thread)
{
    MultiSet* readers = rwlock_m->readers_list;
    unsigned int i, res=0;
    ThreadIdObj* tmp;
    for(i=0;i<size_MultiSet(readers);i++)
    {
        tmp = get_MultiSet(readers,i);
        if(equals(tmp, create_ThreadIdObj(thread))) res++;
    }
    return res;
}

bool isDestroyPossible(VoidTPtr rwlock)
{
    return isRwlockFullyFree(getRwlock(rwlock));
}
