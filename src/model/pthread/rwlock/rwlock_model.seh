/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef PTHREAD_RWLOCK_MODEL_SEH
#define PTHREAD_RWLOCK_MODEL_SEH

#include "common/common_model.seh"
#include "process/process/process_model.seh"
#include "pthread/pthread/pthread_model.seh"
#include "pthread/rwlock/rwlockattr_model.seh"

#include <atl/set.h>
#include <atl/multiset.h>


/********************************************************************/
/**                             Rwlock                             **/
/********************************************************************/
typedef VoidTPtr PThreadRwlockTPtr;

/* 
 * This type represents internal data of pthread_rwlock_t
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libpthread', header file 'pthread.h'.
 */
specification invariant typedef
struct Rwlock
{
    PThreadRwlockTPtr address;
    ThreadId          writer;
    MultiSet*         readers_list;
    Set*              reader_wait_list;
    List*             writer_wait_list;
    PThreadPShared    pshared;
} Rwlock;

/*

typedef struct _pthread_rwlock_t
{
  struct _pthread_fastlock __rw_lock;
  int __rw_readers;
  _pthread_descr __rw_writer;
  _pthread_descr __rw_read_waiting;
  _pthread_descr __rw_write_waiting;
  int __rw_kind;
  int __rw_pshared;
}

*/

Rwlock* create_Rwlock(PThreadRwlockTPtr prwlock, PThreadPShared pshared);
void registerRwlock(PThreadRwlockTPtr prwlock, PThreadPShared pshared);
void unregisterRwlock(PThreadRwlockTPtr prwlock);


/********************************************************************/
/**                          Rwlock Storage                        **/
/********************************************************************/
Rwlock* getRwlock(PThreadRwlockTPtr prwlock);
Rwlock* findRwlock(ObjectsInMemory* objects, PThreadRwlockTPtr prwlock);
ObjectsInMemory* getAllRwlocks(void);
int getNumberOfRwlocks(CallContext context);

Rwlock* findRwlock(ObjectsInMemory* objects,PThreadRwlockTPtr prwlock);

ObjectsInMemory* getAllRwlocks(void);


/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** pthread_rwlock_destroy_spec **/
specification
ErrorCode* pthread_rwlock_destroy_spec(CallContext context, PThreadRwlockTPtr rwlock);

void onPThreadRwlockDestroy(PThreadRwlockTPtr rwlock, ErrorCode* pthread_rwlock_destroy_spec);


/** pthread_rwlock_init_spec **/
specification
ErrorCode* pthread_rwlock_init_spec(CallContext context, VoidTPtr rwlock, PThreadRwlockAttrTPtr attr);

void onPThreadRwlockInit(VoidTPtr rwlock, PThreadRwlockAttrTPtr attr, ErrorCode* pthread_rwlock_init_spec);


/** pthread_rwlock_rdlock_spec **/
specification typedef
struct RwlockLockCall
{
  CallContext       context;
  PThreadRwlockTPtr rwlock;
} RwlockLockCall;

RwlockLockCall* create_RwlockLockCall(CallContext context, PThreadRwlockTPtr rwlock);

specification
void pthread_rwlock_rdlock_spec(CallContext context, PThreadRwlockTPtr rwlock);

void onPThreadRwlockRdlock(CallContext context, PThreadRwlockTPtr rwlock);


specification typedef
struct RwlockLockReturnType
{
  CallContext context;
  ErrorCode*  returned_value;
} RwlockLockReturnType;

RwlockLockReturnType * create_RwlockLockReturnType(
  CallContext context,
  ErrorCode*  returned_value
);

reaction RwlockLockReturnType* pthread_rwlock_rdlock_return(void);

void onPThreadRwlockRdlockReturn(CallContext context, ErrorCode* pthread_rwlock_rdlock_spec);


/** pthread_rwlock_timedrdlock_spec **/
specification typedef
struct RwlockTimedLockCall
{
  CallContext       context;
  PThreadRwlockTPtr rwlock;
  TimeInterval      t_stamp;
  TimeUnit          delta;
} RwlockTimedLockCall;

RwlockTimedLockCall* create_RwlockTimedLockCall(CallContext context, PThreadRwlockTPtr rwlock, TimeInterval t_stamp, TimeUnit delta);

specification
void pthread_rwlock_timedrdlock_spec(CallContext context, PThreadRwlockTPtr rwlock, TimeUnit delta);

void onPThreadRwlockTimedRdlock(CallContext context, PThreadRwlockTPtr rwlock, TimeInterval timestamp, TimeUnit delta);

reaction RwlockLockReturnType* pthread_rwlock_timedrdlock_return(void);

void onPThreadRwlockTimedRdlockReturn(CallContext context, ErrorCode* pthread_rwlock_rdlock_spec);

specification
ErrorCode* pthread_rwlock_timedrdlock_bad_spec(CallContext context, PThreadRwlockTPtr rwlock, IntT nsec);


/** pthread_rwlock_timedwrlock_spec **/
specification
void pthread_rwlock_timedwrlock_spec(CallContext context, PThreadRwlockTPtr rwlock, TimeUnit delta);

void onPThreadRwlockTimedWrlock(CallContext context, PThreadRwlockTPtr rwlock, TimeInterval timestamp, TimeUnit delta);

reaction RwlockLockReturnType* pthread_rwlock_timedwrlock_return(void);

void onPThreadRwlockTimedWrlockReturn(CallContext context, ErrorCode* pthread_rwlock_rdlock_spec);

specification
ErrorCode* pthread_rwlock_timedwrlock_bad_spec(CallContext context, PThreadRwlockTPtr rwlock, IntT nsec);


/** pthread_rwlock_tryrdlock_spec **/
specification
ErrorCode* pthread_rwlock_tryrdlock_spec(CallContext context, PThreadRwlockTPtr rwlock);

void onPThreadRwlockTryRdlock(CallContext context, PThreadRwlockTPtr rwlock, ErrorCode* pthread_rwlock_tryrdlock_spec);


/** pthread_rwlock_trywrlock_spec **/
specification
ErrorCode* pthread_rwlock_trywrlock_spec(CallContext context, PThreadRwlockTPtr rwlock);

void onPThreadRwlockTryWrlock(CallContext context, PThreadRwlockTPtr rwlock, ErrorCode* pthread_rwlock_trywrlock_spec);


/** pthread_rwlock_unlock_spec **/
specification
void pthread_rwlock_unlock_spec(CallContext context, PThreadRwlockTPtr rwlock);

specification typedef
struct RwlockUnlockCall
{
  CallContext      context;
  PThreadRwlockTPtr rwlock;
} RwlockUnlockCall;


void onPThreadRwlockUnlock(CallContext context, PThreadRwlockTPtr rwlock);
    
specification typedef
struct RwlockUnlockReturnType
{
  CallContext context;
  ErrorCode*  returned_value;
} RwlockUnlockReturnType;

RwlockUnlockReturnType * create_RwlockUnlockReturnType(
  CallContext context,
  ErrorCode*  returned_value
);

reaction RwlockUnlockReturnType* pthread_rwlock_unlock_return(void);

void onPThreadRwlockUnlockReturn(CallContext context, ErrorCode* pthread_rwlock_unlock_spec);


/** pthread_rwlock_wrlock_spec **/
specification
void pthread_rwlock_wrlock_spec(CallContext context, PThreadRwlockTPtr rwlock);

void onPThreadRwlockWrlock(CallContext context, PThreadRwlockTPtr rwlock);

reaction RwlockLockReturnType* pthread_rwlock_wrlock_return(void);

void onPThreadRwlockWrlockReturn(CallContext context, ErrorCode* pthread_rwlock_wrlock_spec);


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
bool isLocked_Rwlock(Rwlock* rwlock);
bool isWaitedWriterExist(Rwlock* rwlock);
bool isWriter_Rwlock(Rwlock* rwlock, CallContext context);
bool isReader_Rwlock(Rwlock* rwlock, CallContext context);
bool isOwner_Rwlock(Rwlock* rwlock, CallContext context);

List* getLockedThreads(Rwlock* rwlock);

bool isReadAvailable(Rwlock* rwlock,CallContext context);
bool isWriteAvailable(Rwlock* rwlock, CallContext context);
int compare_ThreadPriority(ThreadPriority x1, ThreadPriority x2);
bool isWaiterWithHigherPriority(CallContext context, List* waiters);
bool isRwlockFullyFree(Rwlock* rwlock);

List* getLockedThreads(Rwlock* rwlock);
List* getOwners(Rwlock* rwlock);

RwlockUnlockCall* create_RwlockUnlockCall(CallContext context, PThreadRwlockTPtr rwlock);

ThreadId getNextRwlockThread_SchedulingPolicy(CallContext context, Rwlock* rwlock);

/* This function is to help with debugging */
void printRwlock(Rwlock *rwlock);


#endif
