 /*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#ifdef _MSC_VER
#include <time.h>
#endif

#include "time/conversion/conversion_config.h"
#include "time/conversion/conversion_model.seh"
#include "process/process/process_common.seh"

#pragma SEC subsystem conversion "time.conversion"

/*
   The group of functions 'time.conversion' consists of:
       asctime [2]
       asctime_r [2]
       ctime [2]
       ctime_r [2]
       gmtime [2]
       gmtime_r [2]
       localtime [2]
       localtime_r [2]
       mktime [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    asctime, asctime_r - convert date and time to a string

SYNOPSIS

    #include <time.h>

    char *asctime(const struct tm *timeptr);

    [TSF] char *asctime_r(const struct tm *restrict tm, char *restrict buf);

DESCRIPTION

    For asctime(): [CX] The functionality described on this reference page is
    aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The asctime() function shall convert the broken-down time in the structure
    pointed to by timeptr into a string in the form:

    Sun Sep 16 01:03:52 1973\n\0

    using the equivalent of the following algorithm:

    char *asctime(const struct tm *timeptr) { static char wday_name[7][3] = { "
    Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" }; static char mon_name[12][3] =
    { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "
    Dec" }; static char result[26];

    sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n", wday_name[timeptr-&
    gt;tm_wday], mon_name[timeptr->tm_mon], timeptr->tm_mday, timeptr-&
    gt;tm_hour, timeptr->tm_min, timeptr->tm_sec, 1900 + timeptr-&
    gt;tm_year); return result; }

    The tm structure is defined in the <time.h> header.

    [CX] The asctime(), ctime(), gmtime(), and localtime() functions shall return
    values in one of two static objects: a broken-down time structure and an array
    of type char. Execution of any of the functions may overwrite the information
    returned in either of these objects by any of the other functions.

    The asctime() function need not be reentrant. A function that is not required
    to be reentrant is not required to be thread-safe.

    [TSF] The asctime_r() function shall convert the broken-down time in the
    structure pointed to by tm into a string (of the same form as that returned by
    asctime()) that is placed in the user-supplied buffer pointed to by buf (which
    shall contain at least 26 bytes) and then return buf.

RETURN VALUE

    Upon successful completion, asctime() shall return a pointer to the string. [CX]
    If the function is unsuccessful, it shall return NULL.

    [TSF] Upon successful completion, asctime_r() shall return a pointer to a
    character string containing the date and time. This string is pointed to by the
    argument buf. If the function is unsuccessful, it shall return NULL.

ERRORS

    No errors are defined.
*/
specification
CString * asctime_spec( CallContext context, TmTObj * timeptr )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        if ( asctime_spec == NULL )
        {
            /*
             * If the function is unsuccessful, it shall return NULL.
             */
            REQ( "asctime.02.02", "If the function is unsuccessful, it shall return NULL", asctime_spec == NULL );
        }
        else
        {
            /*
             * The asctime() function shall convert the broken-down time in the structure
             * pointed to by timeptr into a string in the form:
             *
             * Sun Sep 16 01:03:52 1973\n\0
             *
             * using the equivalent of the following algorithm:
             *
             * char *asctime(const struct tm *timeptr)
             * {
             *     static char wday_name[7][3] = {
             *         "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
             *     };
             *     static char mon_name[12][3] = {
             *         "Jan", "Feb", "Mar", "Apr", "May", "Jun",
             *         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
             *     };
             *     static char result[26];
             *
             *     sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
             *         wday_name[timeptr->tm_wday],
             *         mon_name[timeptr->tm_mon],
             *         timeptr->tm_mday, timeptr->tm_hour,
             *         timeptr->tm_min, timeptr->tm_sec,
             *         1900 + timeptr->tm_year);
             *     return result;
             * }
             */
            REQ( "asctime.01", "equivalent of the following algorithm",
                               equalsVerbose( "asctime_spec", asctime_spec, asctimeUnsafeAlgorithm( timeptr ) )
               );

            /*
             * Upon successful completion, asctime() shall return a pointer to the string.
             */
            REQ( "asctime.02.01", "Upon successful completion, asctime() shall return a pointer to the string",
                                  asctime_spec != NULL
               );
        }

        return true;
    }
}


specification
CString * asctime_r_spec( CallContext context, TmTObj * timeptr, CString * buf )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /*
         * the user-supplied buffer pointed to by buf (which shall contain at least 26
         * bytes)
         */
        REQ( "app.asctime_r.01", "buf shall contain at least 26 bytes", length_CString( buf ) >= 26 - 1 );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        if ( asctime_r_spec == NULL )
        {
            /*
             * If the function is unsuccessful, it shall return NULL.
             */
            REQ( "asctime_r.02.02", "If the function is unsuccessful, it shall return NULL", asctime_r_spec == NULL );
        }
        else
        {
            /*
             * The asctime() function shall convert the broken-down time in the structure
             * pointed to by timeptr into a string in the form:
             *
             * Sun Sep 16 01:03:52 1973\n\0
             *
             * using the equivalent of the following algorithm:
             *
             * char *asctime(const struct tm *timeptr)
             * {
             *     static char wday_name[7][3] = {
             *         "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
             *     };
             *     static char mon_name[12][3] = {
             *         "Jan", "Feb", "Mar", "Apr", "May", "Jun",
             *         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
             *     };
             *     static char result[26];
             *
             *     sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
             *         wday_name[timeptr->tm_wday],
             *         mon_name[timeptr->tm_mon],
             *         timeptr->tm_mday, timeptr->tm_hour,
             *         timeptr->tm_min, timeptr->tm_sec,
             *         1900 + timeptr->tm_year);
             *     return result;
             * }
             *
             * The asctime_r() function shall convert the broken-down time in the structure
             * pointed to by tm into a string (of the same form as that returned by asctime())
             */
            REQ( "asctime_r.01", "equivalent of the following algorithm",
                                 equalsVerbose( "asctime_r_spec", asctime_r_spec, asctimeUnsafeAlgorithm( timeptr ) )
               );

            /*
             * Upon successful completion, asctime_r() shall return a pointer to a character
             * string containing the date and time. This string is pointed to by the argument
             * buf.
             */
            REQ( "asctime_r.02.01", "Upon successful completion, asctime() shall return a pointer to the string",
                                    asctime_r_spec != NULL
               );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    ctime, ctime_r - convert a time value to a date and time string

SYNOPSIS

    #include <time.h>

    char *ctime(const time_t *clock);

    [TSF] char *ctime_r(const time_t *clock, char *buf);

DESCRIPTION

    For ctime(): [CX] The functionality described on this reference page is aligned
    with the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    The ctime() function shall convert the time pointed to by clock, representing
    time in seconds since the Epoch, to local time in the form of a string. It
    shall be equivalent to:

    asctime(localtime(clock))

    [CX] The asctime(), ctime(), gmtime(), and localtime() functions shall return
    values in one of two static objects: a broken-down time structure and an array
    of char. Execution of any of the functions may overwrite the information
    returned in either of these objects by any of the other functions.

    The ctime() function need not be reentrant. A function that is not required to
    be reentrant is not required to be thread-safe.

    [TSF] The ctime_r() function shall convert the calendar time pointed to by
    clock to local time in exactly the same form as ctime() and put the string into
    the array pointed to by buf (which shall be at least 26 bytes in size) and
    return buf.

    Unlike ctime(), the thread-safe version ctime_r() is not required to set tzname.

RETURN VALUE

    The ctime() function shall return the pointer returned by asctime() with that
    broken-down time as an argument.

    [TSF] Upon successful completion, ctime_r() shall return a pointer to the
    string pointed to by buf. When an error is encountered, a null pointer shall be
    returned.

ERRORS

    No errors are defined.
*/
specification
CString * ctime_spec( CallContext context, TimeTObj * clock )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        if ( ctime_spec == NULL )
        {
            /*
             * When an error is encountered, a null pointer shall be returned.
             */
            REQ( "ctime.02.02", "When an error is encountered, a null pointer shall be returned", ctime_spec == NULL );
        }
        else
        {
            /*
             * The ctime() function shall convert the time pointed to by clock, representing
             * time in seconds since the Epoch, to local time in the form of a string. It
             * shall be equivalent to:
             * asctime(localtime(clock))
             */
            REQ( "ctime.01",
                 "equivalent to asctime(localtime(clock))",
                 equalsVerbose( "ctime_spec", ctime_spec, asctimeUnsafeAlgorithm( localtimeAlgorithm( * clock ) ) )
               );

            /*
             * The ctime() function shall return the pointer returned by asctime() with that
             * broken-down time as an argument.
             */
            REQ( "ctime.02.01", "ctime() function shall return the pointer returned by asctime()", ctime_spec != NULL );
        }

        return true;
    }
}


specification
CString * ctime_r_spec( CallContext context, TimeTObj * clock, CString * buf )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /*
         * the array pointed to by buf (which shall be at least 26 bytes in size)
         */
        REQ( "app.ctime_r.01", "buf which shall be at least 26 bytes in size", length_CString( buf ) >= 26 - 1 );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        if ( ctime_r_spec == NULL )
        {
            /*
             * When an error is encountered, a null pointer shall be returned.
             */
            REQ( "ctime_r.02.02", "When an error is encountered, a null pointer shall be returned", ctime_r_spec == NULL );
        }
        else
        {
            /*
             * The ctime() function shall convert the time pointed to by clock, representing
             * time in seconds since the Epoch, to local time in the form of a string. It
             * shall be equivalent to:
             * asctime(localtime(clock))
             *
             * The ctime_r() function shall convert the calendar time pointed to by clock to
             * local time in exactly the same form as ctime()
             */
            REQ( "ctime_r.01",
                 "equivalent to asctime(localtime(clock))",
                 equalsVerbose( "ctime_r_spec", ctime_r_spec, asctimeUnsafeAlgorithm( localtimeAlgorithm( * clock ) ) )
               );

            /*
             * Upon successful completion, ctime_r() shall return a pointer to the string
             * pointed to by buf.
             */
            REQ( "ctime_r.02.01", "ctime_r() shall return a pointer to the string", ctime_r_spec != NULL );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    gmtime, gmtime_r - convert a time value to a broken-down UTC time

SYNOPSIS

    #include <time.h>

    struct tm *gmtime(const time_t *timer);

    [TSF] struct tm *gmtime_r(const time_t *restrict timer,

    struct tm *restrict result);

DESCRIPTION

    For gmtime(): [CX] The functionality described on this reference page is
    aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The gmtime() function shall convert the time in seconds since the Epoch pointed
    to by timer into a broken-down time, expressed as Coordinated Universal
    Time (UTC).

    [CX] The relationship between a time in seconds since the Epoch used as an
    argument to gmtime() and the tm structure (defined in the <time.h> header)
    is that the result shall be as specified in the expression given in the
    definition of seconds since the Epoch (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Section 4.14, Seconds Since the Epoch), where the names in the
    structure and in the expression correspond.

    [TSF] The same relationship shall apply for gmtime_r().

    [CX] The gmtime() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

    The asctime(), ctime(), gmtime(), and localtime() functions shall return values
    in one of two static objects: a broken-down time structure and an array of type
    char. Execution of any of the functions may overwrite the information returned
    in either of these objects by any of the other functions.

    [TSF] The gmtime_r() function shall convert the time in seconds since the Epoch
    pointed to by timer into a broken-down time expressed as Coordinated Universal
    Time (UTC). The broken-down time is stored in the structure referred to by
    result. The gmtime_r() function shall also return the address of the same
    structure.

RETURN VALUE

    Upon successful completion, the gmtime() function shall return a pointer to a
    struct tm. If an error is detected, gmtime() shall return a null pointer [CX]
    and set errno to indicate the error.

    [TSF] Upon successful completion, gmtime_r() shall return the address of the
    structure pointed to by the argument result. If an error is detected, gmtime_r()
    shall return a null pointer and set errno to indicate the error.

ERRORS

    The gmtime() [TSF] and gmtime_r() functions shall fail if:

    [EOVERFLOW] [CX] The result cannot be represented.
*/
specification
TmTObj * gmtime_spec( CallContext context, TimeTObj * timer, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an error is detected, gmtime() shall return a null pointer [CX]  and
         * set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_GMTIME, "gmtime.02.02", gmtime_spec == NULL, * errno )
            /*
             * The gmtime() [TSF]  and gmtime_r()  functions shall fail if:
             *
             * [EOVERFLOW]
             * [CX] The result cannot be represented.
             */
            ERROR_SHALL( POSIX_GMTIME, EOVERFLOW, "gmtime.03.01", TODO_ERR(EOVERFLOW) )
        ERROR_END()

        /*
         * The gmtime() function shall convert the time in seconds since the Epoch pointed
         * to by timer into a broken-down time, expressed as Coordinated Universal Time
         * (UTC).
         */
        REQ( "gmtime.01", "The gmtime() function shall convert the time in seconds since the Epoch into a UTC time",
                          equalsVerbose( "gmtime_spec", gmtime_spec, gmtimeAlgorithm( * timer ) )
           );

        /*
         * Upon successful completion, the gmtime() function shall return a pointer to a
         * struct tm.
         */
        REQ( "gmtime.02.01", "the gmtime() function shall return a pointer to a struct tm", gmtime_spec != NULL );

        return true;
    }
}


specification
TmTObj * gmtime_r_spec( CallContext context, TimeTObj * timer, TmTObj * result, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an error is detected, gmtime_r() shall return a null pointer and set errno
         * to indicate the error.
         */
        ERROR_BEGIN( POSIX_GMTIME_R, "gmtime_r.02.02", gmtime_r_spec == NULL, * errno )
            /*
             * The gmtime() [TSF]  and gmtime_r()  functions shall fail if:
             *
             * [EOVERFLOW]
             * [CX] The result cannot be represented.
             */
            ERROR_SHALL( POSIX_GMTIME_R, EOVERFLOW, "gmtime_r.03.01", TODO_ERR(EOVERFLOW) )
        ERROR_END()

        /*
         * The gmtime() function shall convert the time in seconds since the Epoch pointed
         * to by timer into a broken-down time, expressed as Coordinated Universal Time
         * (UTC).
         *
         * The same relationship shall apply for gmtime_r().
         */
        REQ( "gmtime_r.01", "The function shall convert the time in seconds since the Epoch into a UTC time",
                            equalsVerbose( "gmtime_r_spec", gmtime_r_spec, gmtimeAlgorithm( * timer ) )
           );


        /*
         * Upon successful completion, gmtime_r() shall return the address of the
         * structure pointed to by the argument result.
         */
        REQ( "gmtime_r.02.01", "gmtime_r() shall return the address of the result", gmtime_r_spec != NULL );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    localtime, localtime_r - convert a time value to a broken-down local time

SYNOPSIS

    #include <time.h>

    struct tm *localtime(const time_t *timer);

    [TSF] struct tm *localtime_r(const time_t *restrict timer,

    struct tm *restrict result);

DESCRIPTION

    For localtime(): [CX] The functionality described on this reference page is
    aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The localtime() function shall convert the time in seconds since the Epoch
    pointed to by timer into a broken-down time, expressed as a local time. The
    function corrects for the timezone and any seasonal time adjustments. [CX]
    Local timezone information is used as though localtime() calls tzset().

    The relationship between a time in seconds since the Epoch used as an argument
    to localtime() and the tm structure (defined in the <time.h> header) is
    that the result shall be as specified in the expression given in the definition
    of seconds since the Epoch (see the Base Definitions volume of IEEE Std 1003.1-
    2001, Section 4.14, Seconds Since the Epoch) corrected for timezone and any
    seasonal time adjustments, where the names in the structure and in the
    expression correspond.

    [TSF] The same relationship shall apply for localtime_r().

    [CX] The localtime() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

    The asctime(), ctime(), gmtime(), and localtime() functions shall return values
    in one of two static objects: a broken-down time structure and an array of type
    char. Execution of any of the functions may overwrite the information returned
    in either of these objects by any of the other functions.

    [TSF] The localtime_r() function shall convert the time in seconds since the
    Epoch pointed to by timer into a broken-down time stored in the structure to
    which result points. The localtime_r() function shall also return a pointer to
    that same structure.

    Unlike localtime(), the reentrant version is not required to set tzname.

    [TSF] If the reentrant version does not set tzname, it shall not set daylight
    and shall not set timezone.

RETURN VALUE

    Upon successful completion, the localtime() function shall return a pointer to
    the broken-down time structure. If an error is detected, localtime() shall
    return a null pointer [CX] and set errno to indicate the error.

    [TSF] Upon successful completion, localtime_r() shall return a pointer to the
    structure pointed to by the argument result. If an error is detected,
    localtime_r() shall return a null pointer and set errno to indicate the error.

ERRORS

    The localtime() [TSF] and localtime_r() functions shall fail if:

    [EOVERFLOW] [CX] The result cannot be represented.
*/
specification
TmTObj * localtime_spec( CallContext context, TimeTObj * timer, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an error is detected, localtime() shall return a null pointer [CX]
         * and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_LOCALTIME, "localtime.02.02", localtime_spec == NULL, * errno )
            /*
             * The localtime() [TSF]  and localtime_r()  functions shall fail if:
             *
             * [EOVERFLOW]
             * [CX] The result cannot be represented.
             */
            ERROR_SHALL( POSIX_LOCALTIME, EOVERFLOW, "localtime.03.01", TODO_ERR(EOVERFLOW) )
        ERROR_END()

        /*
         * The localtime() function shall convert the time in seconds since the Epoch
         * pointed to by timer into a broken-down time, expressed as a local time. The
         * function corrects for the timezone and any seasonal time adjustments.
         */
        REQ( "localtime.01", "The localtime() function shall convert the time in seconds into a local time",
                             equalsVerbose( "localtime_spec", localtime_spec, localtimeAlgorithm( * timer ) )
           );

        /*
         * Upon successful completion, the localtime() function shall return a pointer to
         * the broken-down time structure.
         */
        REQ( "localtime.02.01", "the localtime() function shall return a pointer to the broken-down time structure",
                                localtime_spec != NULL
           );

        return true;
    }
}


specification
TmTObj * localtime_r_spec( CallContext context, TimeTObj * timer, TmTObj * result, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If an error is detected, localtime_r() shall return a null pointer and set
         * errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_LOCALTIME_R, "localtime_r.02.02", localtime_r_spec == NULL, * errno )
            /*
             * The localtime() [TSF]  and localtime_r()  functions shall fail if:
             *
             * [EOVERFLOW]
             * [CX] The result cannot be represented.
             */
            ERROR_SHALL( POSIX_LOCALTIME_R, EOVERFLOW, "localtime_r.03.01", TODO_ERR(EOVERFLOW) )
        ERROR_END()

        /*
         * The localtime() function shall convert the time in seconds since the Epoch
         * pointed to by timer into a broken-down time, expressed as a local time. The
         * function corrects for the timezone and any seasonal time adjustments.
         *
         * The same relationship shall apply for localtime_r().
         */
        REQ( "localtime_r.01", "The function shall convert the time in seconds into a local time",
                               equalsVerbose( "localtime_r_spec", localtime_r_spec, localtimeAlgorithm( * timer ) )
           );


        /*
         * Upon successful completion, localtime_r() shall return a pointer to the
         * structure pointed to by the argument result.
         */
        REQ( "localtime_r.02.01", "localtime_r() shall return the address of the result", localtime_r_spec != NULL );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    mktime - convert broken-down time into time since the Epoch

SYNOPSIS

    #include <time.h>

    time_t mktime(struct tm *timeptr);

DESCRIPTION

    [CX] The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard. The mktime() function shall convert the broken-down time,
    expressed as local time, in the structure pointed to by timeptr, into a time
    since the Epoch value with the same encoding as that of the values returned by
    time(). The original values of the tm_wday and tm_yday components of the
    structure are ignored, and the original values of the other components are not
    restricted to the ranges described in <time.h>.

    [CX] A positive or 0 value for tm_isdst shall cause mktime() to presume
    initially that Daylight Savings Time, respectively, is or is not in effect for
    the specified time. A negative value for tm_isdst shall cause mktime() to
    attempt to determine whether Daylight Savings Time is in effect for the
    specified time.

    Local timezone information shall be set as though mktime() called tzset().

    The relationship between the tm structure (defined in the <time.h> header)
    and the time in seconds since the Epoch is that the result shall be as
    specified in the expression given in the definition of seconds since the
    Epoch (see the Base Definitions volume of IEEE Std 1003.1-2001, Section 4.14,
    Seconds Since the Epoch) corrected for timezone and any seasonal time
    adjustments, where the names in the structure and in the expression correspond.

    Upon successful completion, the values of the tm_wday and tm_yday components of
    the structure shall be set appropriately, and the other components are set to
    represent the specified time since the Epoch, but with their values forced to
    the ranges indicated in the <time.h> entry; the final value of tm_mday
    shall not be set until tm_mon and tm_year are determined.

RETURN VALUE

    The mktime() function shall return the specified time since the Epoch encoded
    as a value of type time_t. If the time since the Epoch cannot be represented,
    the function shall return the value (time_t)-1 [CX] and may set errno to
    indicate the error.

ERRORS

    The mktime() function may fail if:

    [EOVERFLOW] [CX] The result cannot be represented.
*/
specification
TimeT mktime_spec( CallContext context, TmTObj * timeptr, ErrorCode * errno )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * If the time since the Epoch cannot be represented, the function shall return
         * the value (time_t)-1 [CX]  and may set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_MKTIME, "mktime.02.02", mktime_spec == (TimeT)-1 && *errno, * errno )
            /*
             * The mktime() function may fail if:
             *
             * [EOVERFLOW]
             * [CX] The result cannot be represented.
             */
            ERROR_MAY( POSIX_MKTIME, EOVERFLOW, "mktime.03.01", TODO_ERR(EOVERFLOW) )
        ERROR_END()

        if(mktime_spec != (TimeT)-1 )
        {
            /*
             * The mktime() function shall return the specified time since the Epoch encoded
             * as a value of type time_t.
             *
             * The mktime() function shall convert the broken-down time, expressed as local
             * time, in the structure pointed to by timeptr, into a time since the Epoch
             * value with the same encoding as that of the values returned by time().
             */
            REQ( "mktime.02.01", "The mktime() function shall return the specified time since the Epoch",
                                 equalsVerbose( "mktime_spec", localtimeAlgorithm( mktime_spec ), timeptr )
               );
        }
        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool equalsVerbose( const char * prefix, Object * a, Object * b ) {
    bool result = equals( a, b );
    // if ( ! result ) {
    if ( true ) {
        traceFormattedUserInfo( "%s\n", prefix );
        if ( a == NULL ) {
            traceFormattedUserInfo( "%s : first  of compared is [NULL]\n", prefix );
        } else {
            String * tmp = toString( a );
            traceFormattedUserInfo( "%s : first  of compared is [%s]\n", prefix, toCharArray_String( tmp ) );
        }
        if ( b == NULL ) {
            traceFormattedUserInfo( "%s : second of compared is [NULL]\n", prefix );
        } else {
            String * tmp = toString( b );
            traceFormattedUserInfo( "%s : second of compared is [%s]\n", prefix, toCharArray_String( tmp ) );
        }
    }
    return result;
}

CString * asctimeUnsafeAlgorithm( TmTObj * tm ) {
    static char wday[ 7 ][ 3 ] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
    static char mon[ 12 ][ 3 ] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
    static char result[ 26 ];
    if ( tm == NULL ) {
        return NULL;
    } else {
        sprintf( result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
                         wday[ tm->wday ], mon[ tm->mon ], tm->mday, tm->hour, tm->min, tm->sec, 1900 + tm->year
               );
        return create_CString( result );
    }
}

struct tm * _gmtime_r   ( const time_t * timep, struct tm * p_tm );
struct tm * _localtime_r( const time_t * timep, struct tm * p_tm );

TmTObj * gmtimeAlgorithm( TimeT time ) {
    time_t timer = time;
    struct tm p_tm;
    struct tm * res = _gmtime_r( & timer, & p_tm );
    if ( res == NULL ) {
        return NULL;
    } else {
        return create_TmTObj( res->tm_sec, res->tm_min, res->tm_hour, res->tm_mday, res->tm_mon, res->tm_year,
                              res->tm_wday, res->tm_yday, res->tm_isdst
                            );
    }
}

TmTObj * localtimeAlgorithm( TimeT time ) {
    time_t timer = time;
    struct tm p_tm;
    struct tm * res = _localtime_r( & timer, & p_tm );
    if ( res == NULL ) {
        return NULL;
    } else {
        return create_TmTObj( res->tm_sec, res->tm_min, res->tm_hour, res->tm_mday, res->tm_mon, res->tm_year,
                              res->tm_wday, res->tm_yday, res->tm_isdst
                            );
    }
}
