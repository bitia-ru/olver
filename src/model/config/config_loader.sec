#include <string.h>
#include "atl/map.h"
#include <sys/stat.h> 
#include <fcntl.h>

#ifndef WIN32
    #include <unistd.h>
#else
    #include <windows.h>
    #include <io.h>
#endif

#include <errno.h>

#include "common/verbose.h"
#include "config/config_loader.seh"

Map * Map_Values; // String -> String
bool bDeleteConfig = true;
bool bLoadConfigReq = false;
char configFilePath[255];

int read_conf_macro(int in, int out);
int read_conf_file(const char * filename, int out);
bool load_conf_file(const char * filename);


void func_get_str_value(char* name, const char ** var)
{
	String * str_ = get_Map(Map_Values, create_String(name)); 
    if(str_) *var = toCharArray_String(str_); 
}

void func_get_int_value(char* name, int* var)
{
	const char * tmp_; 
	String * str_ = get_Map(Map_Values, create_String(name)); 
    if(str_){ 
		tmp_ = toCharArray_String(str_); 
		*var = atoi( tmp_ ); 
	} 
}


void func_get_bool_value(char* name, bool* var)
{
	String * str_ = get_Map(Map_Values, create_String(name)); 
	if(str_){ 
		if(    !compare(str_,create_String("True")) 
		|| !compare(str_,create_String("1")) 
		) 
		*var = 1; 
	else 
		*var = 0; 
	} 
}

int read_conf_macro(int in, int out)
{
    char ch, line[255], *p;
    int sz = 0, i = 0, cmd = CONF_NO_MACRO;

    while(read(in, &ch, 1) > 0)
    {
        if(ch == '\n') {
            line[i] = '\0';
            break;
        }

        switch(ch)
        {
        case '\\':
            read(in, &ch, 1);
            continue;

        default:
            line[i++] = ch;
        }
    }

    p = strtok(line, " \t");
    if(p == NULL) return 0;

    if(strcmp(p, "include") == 0) cmd = CONF_MACRO_INCLUDE;
    else cmd = CONF_MACRO_UNDEFINED;

    p = strtok(NULL, " \t");
    if(p == NULL) return 0;

    switch(cmd)
    {
    case CONF_MACRO_INCLUDE:
        i = strlen(p);

        while( (*p != '"') && *p) { i++; p++; }

        if(*p == '\0' || !(*p == '"' && p[i-1] == '"'))
        {
            VERBOSE("error: Include macro syntax error.\n");
            return 0;
        }

        p++; p[i-2] = '\0';

        sz += read_conf_file(p, out);
        break;

    default:;
    }

    return sz;
}

int read_conf_file(const char * filename, int out)
{
    char ch;
    bool bNewLine = true;
    int file = open(filename, O_RDONLY);
    int sz = 0;

    if(file == -1)
    {
        VERBOSE("error: Failed to open file '%s' for read.\n", filename);
        return 0;
    }

    while(read(file, &ch, 1) > 0)
    {
        switch(ch)
        {
        case ' ':
        case '\t':
            break;

        case '\n':
            bNewLine = true;
            break;

        case '#':
            if(bNewLine == false) break;
            sz += read_conf_macro(file, out);
            continue;

        default:
            bNewLine = false;
        }

        write(out, &ch, 1); sz++;
    }

    VERBOSE("notify: %d bytes had read from file \"%s\"\n", sz, filename);

    return sz;
}

bool load_conf_file(const char * filename)
{
    size_t fileSize;
    char* buffer;
    size_t readBytes;
    int TempFile, szTempFilePath;
    char TempFilePath[255], temp[255];

#ifndef WIN32
    strcpy(TempFilePath, "/tmp/olver.conf.temp");
    TempFile = open(TempFilePath, O_RDWR | O_CREAT,
        S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
#else
    if((szTempFilePath = GetTempPath(255, TempFilePath)) > 255)
    {
        VERBOSE("error: GetTempPath requires more than 255 bytes.");
        return false;
    }
    
    strcpy(temp, TempFilePath);
    GetTempFileName(temp, "OLV", 0, TempFilePath);

    TempFile = open(TempFilePath, O_RDWR | O_CREAT);
#endif

    if(TempFile == -1)
    {
        VERBOSE("error: Failed to create temporary file '%s': %s.\n",
            TempFilePath, strerror(errno));

        return false;
    } else
        VERBOSE("Used temporary file is '%s'.\n", TempFilePath);

    if((fileSize = read_conf_file(filename, TempFile)) == 0)
    {
        close(TempFile);
        
        if(bDeleteConfig)
        {
            if(remove(TempFilePath) == -1)
                VERBOSE("error: Can't delete temporary config file (%s)", strerror(errno));
        }
        
        return false;
    }

    if(lseek(TempFile, 0, SEEK_SET) == -1)
    {
        VERBOSE("error: Failed to seek begin of file.\n");
        close(TempFile);

        return false;
    }

    buffer = (char*)malloc(fileSize + 1);
    readBytes = read(TempFile, buffer, fileSize);
    close(TempFile);
    if(bDeleteConfig)
    {
        if(remove(TempFilePath) == -1)
            VERBOSE("error: Can't delete temporary config file (%s)", strerror(errno));
    }
    buffer[fileSize] = '\0';

    if (readBytes != fileSize)
    {
        VERBOSE("error: Failed to read file '%s'.\n", filename);
        return false;
    }

    Map_Values = create_Map(&type_String, &type_String);
    {
        int p_state = 0;
        char * p;
        char * name = "";
        char * value = "";
        char seps[]  = " \t=\n";
        char *token;

        token = strtok(buffer, seps);

        while(token != NULL)
        {
            if (*token == ' ' || *token == '\t')
            {
                continue;
            }

            p_state++;

            if (p_state == 1)
            {
                name = token;
                while(p = strstr(name, "."))
                    name = p+1;
            }
            else
            if (p_state == 2)
            {
                value = token;
                p_state = 0;

                put_Map(Map_Values, create_String(name), create_String(value) );
            }

            token = strtok(NULL, seps);
        } 
    }

    return true;

}

void load_config_from_tree(void);

bool load_config(void)
{    
    if(bLoadConfigReq) {
       if(!load_conf_file(configFilePath)) return false;
    } else {
        if(!load_conf_file("olver.conf"))
        {
            VERBOSE("Default config-values used.\n");

            return true;
        }
    }

	load_config_from_tree();

    return true;
}
