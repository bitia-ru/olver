/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "config/test_system_config.h" 
#include "math/math/math_data.seh"

/********************************************************************/
/**                  System Configuration Variables                **/
/********************************************************************/

/*
 * Returns the current variable value on the given process.
 * If the variable has no limit SC_VALUE_NO_LIMIT is returned.
 * If the value is unknown SC_VALUE_UNKNOWN is returned.
 */
LongT getSystemConfigurationValue(CallContext context,IntT name)
{
ProcessState* processState = getProcessState_CallContext(context);
LongTObj* value;

  assertion( processState != NULL, "getSystemConfigurationValue: Process not found" );

  value = get_Map( processState->sysconf, create_IntTObj(name) );
  if (value == NULL)
    return SC_VALUE_UNKNOWN;
  return *value;
}

/*
 * Sets the current variable value on the given process.
 */
void  setSystemConfigurationValue(CallContext context,IntT name,LongT value)
{
SystemState*  systemState  = getSystemState_CallContext(context);
ProcessState* processState = getProcessState_CallContext(context);
IntTObj* key;

  assertion( systemState != NULL,  "getSystemConfigurationValue: System not found" );
  assertion( processState != NULL, "getSystemConfigurationValue: Process not found" );
  assertion( value != SC_VALUE_UNKNOWN,  "getSystemConfigurationValue: INTERNAL ASSERTION FAILED" );

  key = create_IntTObj(name);
  if (!containsKey_Map( processState->sysconf, key ))
   {
    put_Map( processState->sysconf, key, create_LongTObj(value) );
    if (!containsKey_Map( systemState->configuration->sysconf, key ))
     {
      put_Map( systemState->configuration->sysconf, key, create_LongTObj(value) );
     }
   }
}


/********************************************************************/
/**             Pathname System Configuration Variables            **/
/********************************************************************/

Map * path_configs;

specification typedef struct PathConfig PathConfig = {};

bool initPathSystemConfiguration(void)
{
   
    path_configs = create_Map(&type_CString, &type_PathConfig);
    if(path_configs == NULL)
        return false;
    
    return true;
}

PathConfig * create_PathConfig()
{
    return (PathConfig *)create_Object(&type_PathConfig, 
     SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN,
     SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN,
     SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN,
     SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN, SC_VALUE_UNKNOWN
    );
}

PathConfig * getPathConfig(CallContext context, CString* path)
{
    if(path==NULL)
        return NULL;
    return (PathConfig*)get_Map(path_configs, path);
}

/*
 * Returns the current variable value on the given process.
 * If the variable has no limit SC_VALUE_NO_LIMIT is returned.
 * If the value is unknown SC_VALUE_UNKNOWN is returned.
 */
LongT getPathSystemConfigurationValue(CallContext context,CString* path,IntT name)
{
    PathConfig * pc;

    if(path == NULL)
        return SC_VALUE_UNKNOWN;

    pc = (PathConfig*)get_Map(path_configs, path);

    if(pc==NULL)
        return SC_VALUE_UNKNOWN;

    switch(name)
    {
    case SUT_PC_FILESIZEBITS: return pc->filesizebits; break;
    case SUT_PC_LINK_MAX: return pc->link_max; break;
    case SUT_PC_MAX_CANON: return pc->max_canon; break;
    case SUT_PC_MAX_INPUT: return pc->max_input; break;
    case SUT_PC_NAME_MAX: return pc->name_max; break;
    case SUT_PC_PATH_MAX: return pc->path_max; break;
    case SUT_PC_PIPE_BUF: return pc->pipe_buf; break;
    case SUT_PC_2_SYMLINKS: return pc->posix2_symlinks; break;
    case SUT_PC_ALLOC_SIZE_MIN: return pc->posix_alloc_size_min; break;
    case SUT_PC_REC_INCR_XFER_SIZE: return pc->posix_rec_incr_xfer_size; break;
    case SUT_PC_REC_MAX_XFER_SIZE: return pc->posix_rec_max_xfer_size; break;
    case SUT_PC_REC_MIN_XFER_SIZE: return pc->posix_rec_min_xfer_size; break;
    case SUT_PC_REC_XFER_ALIGN: return pc->posix_rec_xfer_align; break;
    case SUT_PC_SYMLINK_MAX: return pc->symlink_max; break;
    case SUT_PC_CHOWN_RESTRICTED: return pc->_posix_chown_restricted; break;
    case SUT_PC_NO_TRUNC: return pc->_posix_no_trunc; break;
    case SUT_PC_VDISABLE: return pc->_posix_vdisable; break;
    case SUT_PC_ASYNC_IO: return pc->_posix_async_io; break;
    case SUT_PC_PRIO_IO: return pc->_posix_prio_io; break;
    case SUT_PC_SYNC_IO: return pc->_posix_sync_io; break;
    }
    return SC_VALUE_UNKNOWN;
}

LongT getFileDescSystemConfigurationValue(CallContext context,FileDescId file_desc_id,IntT name)
{
    FileDescriptor* file_desc;
    ProcessState* process = getProcessState_FileDescId( file_desc_id );
    if (process == NULL)
        return SC_VALUE_UNKNOWN;
    
    file_desc = get_Map( process->file_descriptors, create_FileDescIdObj(file_desc_id) );
    
    if(file_desc==NULL)
        return SC_VALUE_UNKNOWN;
    
    return getPathSystemConfigurationValue(context,file_desc->path,name);
}

PathConfig * setPathSystemConfigurationValue(CallContext context, CString* path,IntT name, LongT value)
{
    
    PathConfig * pc;

    if(path==NULL)
        return NULL;

    pc = (PathConfig*)get_Map(path_configs, path);
    if(pc == NULL)
        pc = create_PathConfig();

    switch(name)
    {
    case SUT_PC_FILESIZEBITS:  pc->filesizebits = value; break;
    case SUT_PC_LINK_MAX:  pc->link_max = value; break;
    case SUT_PC_MAX_CANON:  pc->max_canon = value; break;
    case SUT_PC_MAX_INPUT:  pc->max_input = value; break;
    case SUT_PC_NAME_MAX:  pc->name_max = value; break;
    case SUT_PC_PATH_MAX:  pc->path_max = value; break;
    case SUT_PC_PIPE_BUF:  pc->pipe_buf = value; break;
    case SUT_PC_2_SYMLINKS:  pc->posix2_symlinks = value; break;
    case SUT_PC_ALLOC_SIZE_MIN:  pc->posix_alloc_size_min = value; break;
    case SUT_PC_REC_INCR_XFER_SIZE:  pc->posix_rec_incr_xfer_size = value; break;
    case SUT_PC_REC_MAX_XFER_SIZE:  pc->posix_rec_max_xfer_size = value; break;
    case SUT_PC_REC_MIN_XFER_SIZE:  pc->posix_rec_min_xfer_size = value; break;
    case SUT_PC_REC_XFER_ALIGN:  pc->posix_rec_xfer_align = value; break;
    case SUT_PC_SYMLINK_MAX:  pc->symlink_max = value; break;
    case SUT_PC_CHOWN_RESTRICTED:  pc->_posix_chown_restricted = value; break;
    case SUT_PC_NO_TRUNC:  pc->_posix_no_trunc = value; break;
    case SUT_PC_VDISABLE:  pc->_posix_vdisable = value; break;
    case SUT_PC_ASYNC_IO:  pc->_posix_async_io = value; break;
    case SUT_PC_PRIO_IO:  pc->_posix_prio_io = value; break;
    case SUT_PC_SYNC_IO:  pc->_posix_sync_io = value; break;
    }
    
    if(equals(pc,create_PathConfig()))
        remove_Map(path_configs, path);
    else
        put_Map(path_configs,path,pc);

    return pc;
}

/********************************************************************/
/**              System Configuration Initialization               **/
/********************************************************************/
void initSystemConfiguration(void)
{
  if(TARGET_DATA_TYPES_ARCH == LSB_ARCH_IA32)
  {
    sizeof_CharT  = 1;
    sizeof_ShortT = 2;
    sizeof_IntT   = 4;
    sizeof_LongT  = 4;
    sizeof_LLongT = 8;
    sizeof_WCharT = 4;
    sizeof_FloatT      = 4;
    sizeof_DoubleT     = 8;
    sizeof_LongDoubleT = 12;
    sizeof_VoidTPtr = 4;
  }
  else if( (TARGET_DATA_TYPES_ARCH == LSB_ARCH_S390) || (TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32))
  {
    sizeof_CharT  = 1;
    sizeof_ShortT = 2;
    sizeof_IntT   = 4;
    sizeof_LongT  = 4;
    sizeof_LLongT = 8;
    sizeof_WCharT = 4;
    sizeof_FloatT      = 4;
    sizeof_DoubleT     = 8;
    sizeof_LongDoubleT = 8;
    sizeof_VoidTPtr = 4;
  }
  else if( TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64 || (TARGET_DATA_TYPES_ARCH == LSB_ARCH_S390X) )
  {
    sizeof_CharT  = 1;
    sizeof_ShortT = 2;
    sizeof_IntT   = 4;
    sizeof_LongT  = 8;
    sizeof_LLongT = 8;
    sizeof_WCharT = 4;
    sizeof_FloatT      = 4;
    sizeof_DoubleT     = 8;
    sizeof_LongDoubleT = 8;
    sizeof_VoidTPtr = 8;
  }
  else if( (TARGET_DATA_TYPES_ARCH == LSB_ARCH_IA64) ||  (TARGET_DATA_TYPES_ARCH == LSB_ARCH_AMD64) )
  {
    sizeof_CharT  = 1;
    sizeof_ShortT = 2;
    sizeof_IntT   = 4;
    sizeof_LongT  = 8;
    sizeof_LLongT = 8;
    sizeof_WCharT = 4;
    sizeof_FloatT      = 4;
    sizeof_DoubleT     = 8;
    sizeof_LongDoubleT = 16;
    sizeof_VoidTPtr = 8;
  }
  else
  {
      verbose("Fatal Error: Architecture not found!");
      assertion(false, "Architecture not found");
  }

    if (TARGET_DATA_TYPES_ARCH == LSB_ARCH_IA32)
    {
        SUT_FP_ILOGB0 =    (-2147483647 - 1);
        SUT_FP_ILOGBNAN = (-2147483647 - 1);
    }

    if (TARGET_DATA_TYPES_ARCH == LSB_ARCH_IA64)
    {
        SUT_FP_ILOGB0 = -2147483648;
        SUT_FP_ILOGBNAN = 2147483647;
    }

    if ( (TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64) ||
         (TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32) ||
         (TARGET_DATA_TYPES_ARCH == LSB_ARCH_S390) ||
         (TARGET_DATA_TYPES_ARCH == LSB_ARCH_S390X) )
    {
        SUT_FP_ILOGB0 = -2147483647;
        SUT_FP_ILOGBNAN    = 2147483647;        
    }

    if (TARGET_DATA_TYPES_ARCH == LSB_ARCH_AMD64)
    {
        SUT_FP_ILOGB0 =    -2147483648;
        SUT_FP_ILOGBNAN = -2147483648;        
    }

if ( (TARGET_DATA_TYPES_ARCH == LSB_ARCH_IA32) || 
      (TARGET_DATA_TYPES_ARCH == LSB_ARCH_S390) || 
      (TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC32) 
    )
{
    min_CharT = -128;
    max_CharT = 127;

    min_SCharT = -128;
    max_SCharT = 127;
    max_UCharT = 255;

    min_ShortT  = (-32768);
    max_ShortT  = 32767;
    max_UShortT = 65535;

    min_IntT  = (-2147483647-1);
    max_IntT  = 2147483647;
    max_UIntT = 4294967295U;

    min_LongT  = (-0x7FFFFFFFL-1L);
    max_LongT  = 0x7FFFFFFFL;
    max_ULongT = 0xFFFFFFFFUL;

    min_WCharT = (-2147483647-1);
    max_WCharT = 2147483647;

    max_SSizeT = 0x7FFFFFFFL; // max_LongT
    max_SizeT  = 4294967295U; // max_UIntT - for IA32

    // Temporary: while CTesK does not support MSVS I64 POSTFIX
    //max_LLongT  = 9223372036854775807I64;
    max_LLongT  = 922; //9223372036854775807/*9223372036854775807LL*/;
    max_LLongT = max_LLongT*1000 + 337;
    max_LLongT = max_LLongT*1000 + 203;
    max_LLongT = max_LLongT*1000 + 685;
    max_LLongT = max_LLongT*1000 + 477;
    max_LLongT = max_LLongT*1000 + 580;
    max_LLongT = max_LLongT*10 + 7;
    min_LLongT  = - max_LLongT - 1; //(-9223372036854775807-1)/*(-LLONG_MAX-1LL)*/;
    max_ULLongT = 0; //18446744073709551615 /*18446744073709551615ULL */;
    max_ULLongT = 184;
    max_ULLongT = max_ULLongT*1000 + 467;
    max_ULLongT = max_ULLongT*1000 + 440;
    max_ULLongT = max_ULLongT*1000 + 737;
    max_ULLongT = max_ULLongT*1000 + 95;
    max_ULLongT = max_ULLongT*1000 + 516;
    max_ULLongT = max_ULLongT*100 + 15;

    min_IntMaxT  = min_LLongT;//(-9223372036854775807-1)/*(-LLONG_MAX-1LL)*/;
    max_IntMaxT  = max_LLongT;//9223372036854775807/*9223372036854775807LL*/;
    max_UIntMaxT = max_ULLongT;//18446744073709551615 /*18446744073709551615ULL */;

}
else if ( (TARGET_DATA_TYPES_ARCH == LSB_ARCH_IA64)  || 
        (TARGET_DATA_TYPES_ARCH == LSB_ARCH_AMD64) || 
        (TARGET_DATA_TYPES_ARCH == LSB_ARCH_PPC64) || 
        (TARGET_DATA_TYPES_ARCH == LSB_ARCH_S390X) 
      )
{
    min_CharT = -128;
    max_CharT = 127;

    min_SCharT = -128;
    max_SCharT = 127;
    max_UCharT = 255;

    min_ShortT  = (-32768);
    max_ShortT  = 32767;
    max_UShortT = 65535;

    min_IntT  = (-2147483647-1);
    max_IntT  = 2147483647;
    max_UIntT = 4294967295U;

    max_LLongT  = 922; //9223372036854775807/*9223372036854775807LL*/;
    max_LLongT = max_LLongT*1000 + 337;
    max_LLongT = max_LLongT*1000 + 203;
    max_LLongT = max_LLongT*1000 + 685;
    max_LLongT = max_LLongT*1000 + 477;
    max_LLongT = max_LLongT*1000 + 580;
    max_LLongT = max_LLongT*10 + 7;
    min_LLongT  = - max_LLongT - 1; //(-9223372036854775807-1)/*(-LLONG_MAX-1LL)*/;

    max_ULLongT = 0; //18446744073709551615 /*18446744073709551615ULL */;
    max_ULLongT = 184;
    max_ULLongT = max_ULLongT*1000 + 467;
    max_ULLongT = max_ULLongT*1000 + 440;
    max_ULLongT = max_ULLongT*1000 + 737;
    max_ULLongT = max_ULLongT*1000 + 95;
    max_ULLongT = max_ULLongT*1000 + 516;
    max_ULLongT = max_ULLongT*100 + 15;

    min_LongT = min_LLongT;//(-9223372036854775807LL-1LL);/*(-LLONG_MAX-1LL)*/;
    max_LongT = max_LLongT;//9223372036854775807LL;/*9223372036854775807LL*/;
    max_ULongT = max_ULLongT;//18446744073709551615ULL; /*18446744073709551615ULL */;

    min_WCharT = (-2147483647-1);
    max_WCharT = 2147483647;

    min_IntMaxT = min_LLongT;//(-9223372036854775807LL-1LL);/*(-LLONG_MAX-1LL)*/;
    max_IntMaxT = max_LLongT;//9223372036854775807LL;/*9223372036854775807LL*/;
    max_UIntMaxT = max_ULLongT;//18446744073709551615ULL; /*18446744073709551615ULL */;

    max_SSizeT = 0x7FFFFFFFL;//9223372036854775807LL;/*9223372036854775807LL*/; // max_LongT
    max_SizeT = 4294967295U;//18446744073709551615ULL; /*18446744073709551615ULL */; // max_ULongT
}
else
{
    min_CharT = -128;
    max_CharT = 127;

    min_SCharT = -128;
    max_SCharT = 127;
    max_UCharT = 255;

    min_ShortT  = (-32768);
    max_ShortT  = 32767;
    max_UShortT = 65535;

    min_IntT  = (-2147483647-1);
    max_IntT  = 2147483647;
    max_UIntT = 4294967295U;

    max_LLongT  = 922; //9223372036854775807/*9223372036854775807LL*/;
    max_LLongT = max_LLongT*1000 + 337;
    max_LLongT = max_LLongT*1000 + 203;
    max_LLongT = max_LLongT*1000 + 685;
    max_LLongT = max_LLongT*1000 + 477;
    max_LLongT = max_LLongT*1000 + 580;
    max_LLongT = max_LLongT*10 + 7;
    min_LLongT  = - max_LLongT - 1; //(-9223372036854775807-1)/*(-LLONG_MAX-1LL)*/;

    max_ULLongT = 0; //18446744073709551615 /*18446744073709551615ULL */;
    max_ULLongT = 184;
    max_ULLongT = max_ULLongT*1000 + 467;
    max_ULLongT = max_ULLongT*1000 + 440;
    max_ULLongT = max_ULLongT*1000 + 737;
    max_ULLongT = max_ULLongT*1000 + 95;
    max_ULLongT = max_ULLongT*1000 + 516;
    max_ULLongT = max_ULLongT*100 + 15;

    min_LongT = min_LLongT;//(-9223372036854775807LL-1LL);/*(-LLONG_MAX-1LL)*/;
    max_LongT = max_LLongT;//9223372036854775807LL;/*9223372036854775807LL*/;
    max_ULongT = max_ULLongT;//18446744073709551615ULL; /*18446744073709551615ULL */;

    min_WCharT = (-2147483647-1);
    max_WCharT = 2147483647;

    min_IntMaxT = min_LLongT;//(-9223372036854775807LL-1LL);/*(-LLONG_MAX-1LL)*/;
    max_IntMaxT = max_LLongT;//9223372036854775807LL;/*9223372036854775807LL*/;
    max_UIntMaxT = max_ULLongT;//18446744073709551615ULL; /*18446744073709551615ULL */;

    max_SSizeT = 0x7FFFFFFFL;//9223372036854775807LL;/*9223372036854775807LL*/; // max_LongT
    max_SizeT = 4294967295U;//18446744073709551615ULL; /*18446744073709551615ULL */; // max_ULongT

}

}


/********************************************************************/
/**                       System Configuration                     **/
/********************************************************************/
specification typedef struct SystemConfiguration SystemConfiguration = {};

void initSizeofTypes(Map* sizeofTypes)
{
#if defined(SINGLE_PLATFORM_CONFIGURATION)
  put_Map( sizeofTypes, create_String("char"),    create_SizeTObj( sizeof_CharT ) );
  put_Map( sizeofTypes, create_String("int"),     create_SizeTObj( sizeof_IntT ) );
  put_Map( sizeofTypes, create_String("long"),    create_SizeTObj( sizeof_LongT ) );
  put_Map( sizeofTypes, create_String("wchar_t"), create_SizeTObj( sizeof_WCharT ) );
  put_Map( sizeofTypes, create_String("void*"),   create_SizeTObj( sizeof_VoidTPtr ) );
#endif
}

SystemConfiguration* create_SystemConfiguration(void)
{
SystemConfiguration* configuration;
PThreadConfiguration pthreadConfiguration;

  initPThreadConfiguration(&pthreadConfiguration);
  configuration = create( &type_SystemConfiguration,
                              pthreadConfiguration,
                              create_Map( &type_String, &type_SizeTObj ),
                              // 'sysconf' System Configuration Variables
                              create_Map( &type_IntTObj, &type_LongTObj ),
                              // Hardware Configuration
                              LittleEndian,
                              PTHREAD_STACK_ALIGNMENT_VALUE,
                              -1,
                              -1
                        );
  initSizeofTypes( configuration->sizeofTypes );
  return configuration;
}


/********************************************************************/
/**                  System Configuration Functions                **/
/********************************************************************/
SystemConfiguration* getSystemConfiguration( CallContext context )
{
  return getSystemConfiguration_SystemId(context.system);
}

SystemConfiguration* getSystemConfiguration_SystemId( SystemId systemid )
{
SystemState* systemState = getSystemState(systemid);

  if (systemState == NULL)
    return NULL;
  return systemState->configuration;
}

SystemConfiguration* getSystemConfiguration_ProcessId( ProcessId processid )
{
  return getSystemConfiguration_SystemId(processid.system);
}

/********************************************************************/
/**               Alignment Requirements Configuration             **/
/********************************************************************/

#if defined(SINGLE_PLATFORM_CONFIGURATION)

/*
 * Alignment requirements to the main target types.
 */

SizeT alignment_AnyType = 4;


SizeT alignment_ShortT = 2;
SizeT alignment_IntT = 4;
SizeT alignment_LongT = 4;
SizeT alignment_LLongT = 4;

SizeT alignment_WCharT = 4;

SizeT alignment_FloatT = 4;
SizeT alignment_DoubleT = 4;
SizeT alignment_LongDoubleT = 4;

SizeT alignment_VoidTPtr = 4;

#endif /* SINGLE_PLATFORM_CONFIGURATION */

/********************************************************************/
/**                         Special System Parent                  **/
/********************************************************************/

/*
 * Returns process id of a special system process, 
 * which inherits all children of the process terminated.
 */
ProcessId getSpecialSystemParent( SystemId system )
{
  return create_ProcessId( system, 1 );
}

// To be moved
/********************************************************************/
/**                       Hardware Configuration                   **/
/********************************************************************/

ByteOrder getByteOrder(CallContext context)
{
SystemConfiguration* configuration;
  
  configuration = getSystemConfiguration(context);
  return configuration->byte_order;
}


#if defined(SINGLE_PLATFORM_CONFIGURATION)

ByteOrder SUT_ENDIANNESS = LittleEndian;

#endif /* SINGLE_PLATFORM_CONFIGURATION */


// Stack alignment
IntT getStackAlignmentValue(CallContext context)
{
    SystemConfiguration* configuration;
    
    configuration = getSystemConfiguration(context);
    return configuration->stackAlignmentValue;
}

/************************************************************************/
/**                        Platform Name                               **/
/************************************************************************/

const char* getArchName(int arch)
{
    switch(arch)
    {
    case LSB_ARCH_IA32: return "ia32";
    case LSB_ARCH_IA64: return "ia64";
    case LSB_ARCH_PPC32: return "ppc32";
    case LSB_ARCH_PPC64: return "ppc64";
    case LSB_ARCH_S390: return "s390";
    case LSB_ARCH_S390X: return "s390x";
    case LSB_ARCH_AMD64: return "amd64";
    }

    return "Invalid architecture value";
}
