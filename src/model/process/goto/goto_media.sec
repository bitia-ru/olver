/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "process/goto/goto_media.seh"
#include "common/common_media.seh"
#include "process/process/process_common.seh"

/********************************************************************/
/**                    Initialization Function                     **/
/********************************************************************/

void initProcessGotoSubsystem(void)
{
    // Set up mediators
    set_mediator___sigsetjmp_spec( __sigsetjmp_media );
    set_mediator__longjmp_spec   ( _longjmp_media    );
    set_mediator__setjmp_spec    ( _setjmp_media     );
    set_mediator_longjmp_spec    ( longjmp_media     );
    set_mediator_siglongjmp_spec ( siglongjmp_media  );

    // Set up formatters
    registerTSFormatter( "sigjmp_buf", (TSFormatterFuncType)sigjmp_buf_formatter );
    registerTSFormatter( "jmp_buf"   , (TSFormatterFuncType)jmp_buf_formatter    );
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** __sigsetjmp_spec **/
mediator __sigsetjmp_media for specification
IntT __sigsetjmp_spec( CallContext context, SigJmpBuf * env, IntT savemask )
{
    call
    {
        IntT res;

        TSCommand command = create_TSCommand();

        format_TSCommand( & command, "__sigsetjmp:$(int)$(int)", create_IntTObj( env->id ), create_IntTObj( savemask ) );
        executeCommandInContext( context, & command );
        if ( ! isBadVerdict() )
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream( & command.response );
            readSigJmpBuf_TSStream( & command.response, env );
        }

        destroy_TSCommand( & command );

        return res;
    }
}

/** _longjmp_spec **/
mediator _longjmp_media for specification
IntT _longjmp_spec( CallContext context, JmpBuf * env, IntT val )
{
    call
    {
        IntT res;

        TSCommand command = create_TSCommand();

        format_TSCommand( & command, "_longjmp:$(jmp_buf)$(int)", env, create_IntTObj( val ) );

        executeCommandInContext( context, & command );
        if ( ! isBadVerdict() )
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream( & command.response );
            readJmpBuf_TSStream( & command.response, env );
        }

        destroy_TSCommand( & command );

        return res;
    }
}

/** _setjmp_spec **/
mediator _setjmp_media for specification
IntT _setjmp_spec( CallContext context, JmpBuf * env )
{
    call
    {
        IntT res;

        TSCommand command = create_TSCommand();

        format_TSCommand( & command, "_setjmp:$(int)", create_IntTObj( env->id ) );
        executeCommandInContext( context, & command );
        if ( ! isBadVerdict() )
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream( & command.response );
            readJmpBuf_TSStream( & command.response, env );
        }

        destroy_TSCommand( & command );

        return res;
    }
}

/** longjmp_spec **/
mediator longjmp_media for specification
IntT longjmp_spec( CallContext context, JmpBuf * env, IntT val )
{
    call
    {
        IntT res;

        TSCommand command = create_TSCommand();

        format_TSCommand( & command, "longjmp:$(jmp_buf)$(int)", env, create_IntTObj( val ) );

        executeCommandInContext( context, & command );
        if ( ! isBadVerdict() )
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream( & command.response );
            readJmpBuf_TSStream( & command.response, env );
        }

        destroy_TSCommand( & command );

        return res;
    }
}

/** siglongjmp_spec **/
mediator siglongjmp_media for specification
IntT siglongjmp_spec( CallContext context, SigJmpBuf * env, IntT val )
{
    call
    {
        IntT res;

        TSCommand command = create_TSCommand();

        format_TSCommand( & command, "siglongjmp:$(sigjmp_buf)$(int)", env, create_IntTObj( val ) );

        executeCommandInContext( context, & command );
        if ( ! isBadVerdict() )
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream( & command.response );
            readSigJmpBuf_TSStream( & command.response, env );
        }

        destroy_TSCommand( & command );

        return res;
    }
}

/********************************************************************/
/**                  write-read for user types                     **/
/********************************************************************/

/* $(sigjmp_buf) */
void writeSigJmpBuf_TSStream( TSStream * stream, SigJmpBuf * value ) {
    writeTypeHeaderTSStream( stream, "sigjmp_buf" );
    writeInt_TSStream     ( stream, value->id   );
    writeCharList_TSStream( stream, value->data );
}

void sigjmp_buf_formatter( TSStream * stream, SigJmpBuf * value ) {
    VERIFY_TYPE( sigjmp_buf_formatter, & type_SigJmpBuf, value );
    writeSigJmpBuf_TSStream( stream, value );
}

void readSigJmpBuf_TSStream( TSStream * stream, SigJmpBuf * value ) {
    value->id = readInt_TSStream( stream );
    readCharList_TSStream( stream, value->data );
}

/* $(jmp_buf) */
void writeJmpBuf_TSStream( TSStream * stream, JmpBuf * value ) {
    writeTypeHeaderTSStream( stream, "jmp_buf" );
    writeInt_TSStream     ( stream, value->id   );
    writeCharList_TSStream( stream, value->data );
}

void jmp_buf_formatter( TSStream * stream, JmpBuf * value ) {
    VERIFY_TYPE( jmp_buf_formatter, & type_JmpBuf, value );
    writeJmpBuf_TSStream( stream, value );
}

void readJmpBuf_TSStream( TSStream * stream, JmpBuf * value ) {
    value->id = readInt_TSStream( stream );
    readCharList_TSStream( stream, value->data );
}
