/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef PROCESS_COMMON_SEH
#define PROCESS_COMMON_SEH

#include "process/process/process_model.seh"
#include "data/sys/time_model.seh"
#include "data/time_model.seh"

/********************************************************************/
/**                    Check in common reaction                    **/
/********************************************************************/

#define req4( name, id, msg, value ) \
    if ( startsWith_String( create_String( id ), concat_String( name, create_String( "." ) ) ) ) \
        { REQCSS( create_String( id ), create_String( msg ), value, #value ); }
//      { REQ( id, msg, value ); }

#define error_shall4( name, ERR_FUNC, errname, reqid, error_predicate ) \
    if ( startsWith_String( create_String( reqid ), concat_String( name, create_String( "." ) ) ) ) \
        { ERROR_SHALL( ERR_FUNC, errname, reqid, error_predicate ); }

#define error_may4( name, ERR_FUNC, errname, reqid, error_predicate ) \
    if ( startsWith_String( create_String( reqid ), concat_String( name, create_String( "." ) ) ) ) \
        { ERROR_MAY( ERR_FUNC, errname, reqid, error_predicate ); }

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

IntTObj * readIntValueByName( CallContext context, const char * name );

List * environMapAsList( Map * environ );

bool processReallyHaveHighPriority( CallContext context );
bool processReallyHaveLowPriority ( CallContext context );

UidT maxUserId ( CallContext context );
GidT maxGroupId( CallContext context );

List * createProcesses( bool needGetpwentSpecCalls );

bool terminateProcesses( List * threadIdsOrPars );

void dotPrint( int group, int line );

CallContext getWorkedContext_CallContext( CallContext context );

/********************************************************************/
/**                           CString                              **/
/********************************************************************/

int indexOfCStringC_String( CString * cs, CString * csToFind );

int lastIndexOfCharC_String( CString * cs, int ch );

int lastIndexOfCStringC_String( CString * cs, CString * csToFind );

CString * replaceC_String( CString * cs, char oldChar, char newChar );

bool startsWithC_String( CString * cs, CString * prefix );

CString * valueOfCharC_String( char c );

bool equalsToCreatedFrom2C_String( CString * cs, char * s1, char * s2            );
bool equalsToCreatedFrom3C_String( CString * cs, char * s1, char * s2, char * s3 );

void printC_String( const char * prefix, /* const */ CString * cs );

CString * cutOffSubstring_CString( CString * cs, int beginIndex, int endIndex );

/********************************************************************/
/**                           WString                              **/
/********************************************************************/

WString * createW_String( char * s );

WString * substringW_String( WString * ws, int first, int last );

WString * valueOfWCharW_String( WCharT wc );

void printW_String( const char * prefix, /* const */ WString * ws );

/********************************************************************/
/**                           Pointers                             **/
/********************************************************************/

VoidTPtrObj * make_VoidTPtrObj( SystemId system, PidT process, sut_ptr_t address );

List /* ByteTObj */ * readByteList_VoidTPtr( VoidTPtr ptr, SizeT size );

/********************************************************************/
/**                        read text file                          **/
/********************************************************************/

CString * getFileContents( CallContext context, CString * fileName );

CString * freadFile( CallContext context, FILETPtr * file, CString * fileName, CString * fileMode );

CString * readFile( CallContext context, FileDescId * fd, CString * fileName, OpenFlags fileOflag );

WString * fwreadFile( CallContext context, FILETPtr * file, CString * fileName, CString * fileMode );

/********************************************************************/
/**                     trace function call                        **/
/********************************************************************/

bool appendIfFileExists( CallContext context, const char * fileName, String * data, bool erasePrevious );

/* ... == "data1Name", data1AsString, ..., "dataNName", dataNAsString, NULL */
bool traceFunctionCall
         ( CallContext context, bool functionCallResult, bool needResultCorrect, const char * functionName, ... );
/********************************************************************/
/**                  execute function with ...                     **/
/********************************************************************/

/*
 * if ( initExpression == NULL ) {
 *     func( ..., parameterExpression, ... )
 * } else {
 *     ...
 *     initExpression
 *     ...
 *     func( ..., parameterExpression, ... )
 * }
 */
specification typedef
struct ArgumentDescriptor
{
    String * declaration   ; // may be NULL
    String * initialization; // may be NULL
    String * parameter     ;
} ArgumentDescriptor;

ArgumentDescriptor * create_ArgumentDescriptor( String * declaration, String * initialization, String * parameter );

ArgumentDescriptor * fromChars_ArgumentDescriptor
                         ( const char * declaration, const char * initialization, const char * parameter );

String * functionWithDotsText
             ( const char * funcName, List /* ArgumentDescriptor */ * argumentDescriptors, String * outputOperator );

IntT executeFunctionWithDots( CallContext context,
                              const char * funcName, List /* ArgumentDescriptor */ * argumentDescriptors,
                              String * outputOperator, CString * output, ErrorCode * errno,
                              TimeInterval * stimulTime
                            );

static void functionWithDotsTypedValuesCall( CallContext context, TSCommand * commandPtr, char * funcName,
                                             List /* NULL */ * arguments, CString * input, WString * wInput
                                           );
/* one is CString * or WString * */
static List /* LongTObj */ * createAndWriteForStringOne_DotsArguments( CallContext context, Object * one );

/* one is FloatTObj * */
static List /* LongTObj */ * createAndWriteForFloatOne_DotsArguments( CallContext context, Object * one, bool allByPtr );

/* sizeof( * one ) <= sizeof( LongT ) */
static List /* LongTObj */ * createAndWriteForSmallOne_DotsArguments( CallContext context, Object * one, bool allByPtr );

/* sizeof( * one ) >= sizeof( LongT ) */
static List /* LongTObj */ * createAndWriteForBigOne_DotsArguments( CallContext context, Object * one, bool allByPtr );

static List /* LongTObj */ * createAndWriteForOne_DotsArguments( CallContext context, Object * one, bool allByPtr );

// ! not static !
List /* LongTObj */ * createAndWrite_DotsArguments( CallContext context, List /* NULL */ * allArguments, bool allByPtr );

/* get_List( allArguments, allArgumentsI ) is CString * or WString * */
static bool readAndFreeForStringOne_DotsArguments
                ( CallContext context, LongTObj * address, List /* NULL */ * allArguments, int allArgumentsI );

/* get_List( allArguments, allArgumentsI ) is FloatTObj * */
static bool readAndFreeForFloatOne_DotsArguments( CallContext context, LongTObj * address,
                                                  List /* NULL */ * allArguments, int allArgumentsI, bool allByPtr
                                                );

/* sizeof( * get_List( allArguments, allArgumentsI ) ) <= sizeof( LongT ) */
static bool readAndFreeForSmallOne_DotsArguments
                ( CallContext context, LongTObj * address, List /* NULL */ * allArguments, int allArgumentsI );

/* sizeof( * get_List( allArguments, allArgumentsI ) ) >= sizeof( LongT ) */
static bool readAndFreeForBigOne_DotsArguments
                ( CallContext context, LongTObj * address, List /* NULL */ * allArguments, int allArgumentsI );

static bool readAndFree_DotsArguments( CallContext context,
                                       List /* LongTObj */ * longArguments, List /* NULL */ * allArguments, bool allByPtr
                                     );

static void functionWithDotsLongValuesCall( CallContext context, TSCommand * commandPtr, char * funcName,
                                            List /* NULL */ * arguments, bool allByPtr, CString * input, WString * wInput
                                          );

IntT functionWithDotsCall( CallContext context, char * funcName, List /* NULL */ * arguments, bool allByPtr,
                           CString * input, WString * wInput, ErrorCode * errno, CString * output, WString * wOutput,
                           CString * errput, TimeInterval * stimulTime
                         );

/********************************************************************/
/**                  expected result and reqIds                    **/
/********************************************************************/

void setExpectedResultAndReqIds( const char * funcName, Object * expectedResult, List /* String */ * expectedReqIds );

void modifyExpectedResult( const char * funcName, Object * modifiedExpectedResult );

bool checkExpectedResult( const char * funcName, Object * result, const char * prefixForCommonReq );

Object * getExpectedResult( const char * funcName );

void clearExpectedResultAndReqIds( const char * funcName );

/********************************************************************/
/**                     advanced reactions                         **/
/********************************************************************/

specification typedef
struct CallsList
{
    List /* String */ * names;
    List              * datas;
} CallsList;

CallsList * create_CallsList( void );

bool        isEmpty_CallsList        ( CallsList * callsList                                   );
CallsList * addToTail_CallsList      ( CallsList * callsList, const char * name, Object * data );
Object    * showDataForName_CallsList( CallsList * callsList, const char * name                );
Object    * removeForName_CallsList  ( CallsList * callsList, const char * name                );

void     startCommand(                     CallContext context, const char * name, Object * data );
Object * showCommand ( Map * blockedCalls, CallContext context, const char * name                );
Object * endCommand  (                     CallContext context, const char * name                );

/********************************************************************/
/**                     byte chain with id                         **/
/********************************************************************/

specification typedef struct MarkedByteChain { int id; List /* ByteTObj */ * data; } MarkedByteChain;

MarkedByteChain * create_MarkedByteChain( int id, List /* ByteTObj */ * data );

MarkedByteChain * createEmpty_MarkedByteChain( int id );

/* $(markedbytechain) */
void writeMarkedByteChain_TSStream( TSStream * stream, MarkedByteChain * value );

void markedbytechain_formatter( TSStream * stream, MarkedByteChain * value );

void readMarkedByteChain_TSStream( TSStream * stream, MarkedByteChain * value );

/********************************************************************/
/**                  write-read for int array                      **/
/********************************************************************/

/*
 * any data may be sended or received as int array
 * DANGER : byte and int order
 */
void writeIntArray_TSStream( TSStream * stream, const int * array, int size );

void readIntArray_TSStream( TSStream * stream, int * array, int size );

/********************************************************************/
/**                  write-read for user types                     **/
/********************************************************************/

/* $(strnullterminatedlist) */
void writeStringNullTerminatedList_TSStream( TSStream * stream, List * value );

void strnullterminated_list_formatter( TSStream * stream, List * value );

int readStringNullTerminatedList_TSStream( TSStream * stream, List * list );

/* $(uintlist) */
void writeUintList_TSStream( TSStream * stream, List * value );

void uint_list_formatter( TSStream * stream, List * value );

int readUintList_TSStream( TSStream * stream, List * list );

/* $(charlist) */
void writeCharList_TSStream( TSStream * stream, List /* CharTObj */ * value );

void char_list_formatter( TSStream * stream, /* CharTObj */ List * value );

int readCharList_TSStream( TSStream * stream, /* CharTObj */ List * list );

/* $(bytelist) */
void writeByteList_TSStream( TSStream * stream, List /* ByteTObj */ * value );

void byte_list_formatter( TSStream * stream, List /* ByteTObj */ * value );

int readByteList_TSStream( TSStream * stream, List /* ByteTObj */ * list );

/* $(timeval) */
void writeTimeVal_TSStream( TSStream * stream, TimeValTObj * value );

void timeval_formatter( TSStream * stream, TimeValTObj * value );

TimeValTObj * readTimeVal_TSStream( TSStream * stream );

/* $(itimerval) */
void writeITimerVal_TSStream( TSStream * stream, ITimerValTObj * value );

void itimerval_formatter( TSStream * stream, ITimerValTObj * value );

ITimerValTObj * readITimerVal_TSStream( TSStream * stream );

/* $(itimerspec) */
void writeITimerSpec_TSStream( TSStream * stream, ITimerSpecTObj * value );

void itimerspec_formatter( TSStream * stream, ITimerSpecTObj * value );

ITimerSpecTObj * readITimerSpec_TSStream( TSStream * stream );

/* $(errorcode) - read only */
ErrorCode * readErrorCode_TSStream( TSStream * stream );

/* $(argumentdescriptor) - simple write only */
void writeArgumentDescriptor_TSStream( TSStream * stream, ArgumentDescriptor * value );

/* $(argumentdescriptorlist) - write only */
void writeArgumentDescriptorList_TSStream( TSStream * stream, List * value );

void argument_descriptor_list_formatter( TSStream * stream, List * value );

/* $(dotsarguments) - write only */
void writeDotsArguments_TSStream( TSStream * stream, List * value );

void dotsarguments_formatter( TSStream * stream, List * value );

/* $(typedlistelement) */
void writeTypedListElement_TSStream( TSStream * stream, Object * value );

void typedlistelement_formatter( TSStream * stream, Object * value );

Object * readTypedListElement_TSStream( CallContext context, TSStream * stream );

/* $(typedlist) */
void writeTypedList_TSStream( TSStream * stream, List * value );

void typedlist_formatter( TSStream * stream, List * value );

int readTypedList_TSStream( CallContext context, TSStream * stream, List * list );

/* $(tm) */
void writeTm_TSStream( TSStream * stream, TmTObj * value );

void tm_formatter( TSStream * stream, TmTObj * value );

TmTObj * readTm_TSStream( TSStream * stream );

#endif // PROCESS_COMMON_SEH
