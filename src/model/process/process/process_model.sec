/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "config/system_config.seh"
#include "process/process/process_config.h"
#include "process/pgroup/pgroup_config.h"

#include "process/process/process_model.seh"
#include "process/process/process_common.seh"
#include "process/fenv/fenv_model.seh"
#include "process/meta/user_model.seh"
#include "system/system/system_model.seh"
#include "fs/dir/dir_model.seh"
#include "fs/meta/access_model.seh"
#include "data/sys/wait_model.seh"
#include "data/stdlib_model.seh"

#pragma SEC subsystem process "process.process"

/*
   The group of functions 'process.process' consists of:
       _Exit [1]
       __cxa_atexit [2]
       __libc_start_main [1]
       __register_atfork(GLIBC_2.3.2) [1]
       _exit [1]
       abort [1]
       daemon [2]
       execl [2]
       execle [2]
       execlp [2]
       execv [2]
       execve [2]
       execvp [2]
       exit [2]
       fork [2]
       forkpty [1]
       pclose [2]
       popen [2]
       return_from_main_spec
       system [2]
       vfork [2]
       wait [2]
       wait4 [1]
       waitpid [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
 * common for exit group and return_from_main
 */
specification typedef struct ExitCall ExitCall = {};

ExitCall * create_ExitCall( CallContext context, IntT status )
{
    return create( & type_ExitCall, context, status );
}

void onExit( CallContext context, IntT status )
{
    startCommand( context, "exit", create_ExitCall( context, status ) );
}

specification typedef struct ExitReturnType ExitReturnType = {};

ExitReturnType * create_ExitReturnType(
    String      * name,
    CallContext   context
)
{
    return create(&type_ExitReturnType,
        name,
        context);
}

reaction ExitReturnType * exitCalledProcess_return( void )
{
    post
    {
        String * name = exitCalledProcess_return->name;

        /*
         * These functions do not return.
         */
        req4( name, "_Exit.05"           , "These functions do not return", false );
        req4( name, "_exit.05"           , "These functions do not return", false );
        req4( name, "exit.05"            , "These functions do not return", false );
        req4( name, "return_from_main.05", "These functions do not return", false );

        return true;
    }
}

reaction ExitReturnType * exit_processTerminated( void )
{
    post
    {
        String      * name    = exit_processTerminated->name   ;
        CallContext   context = exit_processTerminated->context;

        ExitCall * blocked_call = showCommand( @getBlockedCalls(), context, "exit" );
        IntT status = blocked_call->status;

        SystemState * systemState = getSystemState( context.system );

        int i;
        bool checkResult;

        /*
         * The _Exit() [CX]  and _exit() functions shall not call functions registered
         * with atexit() nor any registered signal handlers.
         */
        req4( name, "_Exit.01", "", TODO_REQ() );
        req4( name, "_exit.01", "", TODO_REQ() );

        /*
         * The exit() function shall first call all functions registered by atexit(), in
         * the reverse order of their registration, except that a function is called after
         * any previously registered functions that had already been called at the time it
         * was registered. Each function is called as many times as it was registered.
         */
        req4( name, "exit.01"            , "", TODO_REQ());
        req4( name, "return_from_main.01", "", TODO_REQ());

        /*
         * If a function registered by a call to atexit() fails to return, the remaining
         * registered functions shall not be called and the rest of the exit() processing
         * shall not be completed.
         */
        req4( name, "exit.02"            , "", TODO_REQ() );
        req4( name, "return_from_main.02", "", TODO_REQ() );

        /*
         * The exit() function shall then flush all open streams with unwritten buffered
         * data, close all open streams, and remove all files created by tmpfile().
         */
        req4( name, "exit.03"            , "", TODO_REQ() );
        req4( name, "return_from_main.03", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * All of the file descriptors, directory streams, [XSI]  conversion descriptors,
         * and message catalog descriptors  open in the calling process shall be closed.
         */
        req4( name, "_Exit.04.01"           , "", TODO_REQ() );
        req4( name, "_exit.04.01"           , "", TODO_REQ() );
        req4( name, "exit.04.01"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.01", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * If the parent process of the calling process is executing a wait() or waitpid(),
         * [XSI]  and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD to SIG_IGN,
         * it shall be notified of the calling process' termination and the low-order
         * eight bits (that is, bits 0377) of status shall be made available to it. If the
         * parent is not waiting, the child's status shall be made available to it when
         * the parent subsequently executes wait() or waitpid().
         */
        req4( name, "_Exit.04.02"           , "", TODO_REQ() );
        req4( name, "_exit.04.02"           , "", TODO_REQ() );
        req4( name, "exit.04.02"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.02", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * If the parent process of the calling process is not executing a wait() or
         * waitpid(), [XSI]  and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD to
         * SIG_IGN, the calling process shall be transformed into a zombie process. A
         * zombie process is an inactive process and it shall be deleted at some later
         * time when its parent process executes wait() or waitpid().
         */
        req4( name, "_Exit.04.03"           , "", TODO_REQ() );
        req4( name, "_exit.04.03"           , "", TODO_REQ() );
        req4( name, "exit.04.03"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.03", "", TODO_REQ() );
        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * Termination of a process does not directly terminate its children. The sending
         * of a SIGHUP signal as described below indirectly terminates children in some
         * circumstances.
         */
        req4( name, "_Exit.04.04"           , "", TODO_REQ() );
        req4( name, "_exit.04.04"           , "", TODO_REQ() );
        req4( name, "exit.04.04"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.04", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * The parent process ID of all of the calling process' existing child processes
         * and zombie processes shall be set to the process ID of an implementation-
         * defined system process. That is, these processes shall be inherited by a
         * special system process.
         */
        checkResult = true;
        for ( i = 0; i < size_Map( systemState->processes ); i++ ) {
            ProcessIdObj * key = key_Map( systemState->processes, i );
            ProcessState * processState = get_Map( systemState->processes, key );
            if ( processState->meta.parent.process == context.process ) {
                checkResult = false;
                break;
            }
        }
        req4( name, "_Exit.04.05"           , "Parent process ID of existing child and zombie processes", checkResult );
        req4( name, "_exit.04.05"           , "Parent process ID of existing child and zombie processes", checkResult );
        req4( name, "exit.04.05"            , "Parent process ID of existing child and zombie processes", checkResult );
        req4( name, "return_from_main.04.05", "Parent process ID of existing child and zombie processes", checkResult );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [XSI] Each attached shared-memory segment is detached and the value of
         * shm_nattch (see shmget()) in the data structure associated with its shared
         * memory ID shall be decremented by 1.
         */
        req4( name, "_Exit.04.06"           , "", TODO_REQ() );
        req4( name, "_exit.04.06"           , "", TODO_REQ() );
        req4( name, "exit.04.06"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.06", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [XSI] For each semaphore for which the calling process has set a semadj value (
         * see semop() ), that value shall be added to the semval of the specified
         * semaphore.
         */
        req4( name, "_Exit.04.07"           , "", TODO_REQ() );
        req4( name, "_exit.04.07"           , "", TODO_REQ() );
        req4( name, "exit.04.07"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.07", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * If the process is a controlling process, the SIGHUP signal shall be sent to
         * each process in the foreground process group of the controlling terminal
         * belonging to the calling process.
         */
        req4( name, "_Exit.04.08"           , "", TODO_REQ() );
        req4( name, "_exit.04.08"           , "", TODO_REQ() );
        req4( name, "exit.04.08"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.08", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * If the process is a controlling process, the controlling terminal associated
         * with the session shall be disassociated from the session, allowing it to be
         * acquired by a new controlling process.
         */
        checkResult = true;
        req4( name, "_Exit.04.09"           , "The controlling terminal shall be disassociated", checkResult );
        req4( name, "_exit.04.09"           , "The controlling terminal shall be disassociated", checkResult );
        req4( name, "exit.04.09"            , "The controlling terminal shall be disassociated", checkResult );
        req4( name, "return_from_main.04.09", "The controlling terminal shall be disassociated", checkResult );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * If the exit of the process causes a process group to become orphaned, and if
         * any member of the newly-orphaned process group is stopped, then a SIGHUP signal
         * followed by a SIGCONT signal shall be sent to each process in the newly-
         * orphaned process group.
         */
        req4( name, "_Exit.04.10"           , "", TODO_REQ() );
        req4( name, "_exit.04.10"           , "", TODO_REQ() );
        req4( name, "exit.04.10"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.10", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [SEM] All open named semaphores in the calling process shall be closed as if
         * by appropriate calls to sem_close().
         */
        req4( name, "_Exit.04.11"           , "", TODO_REQ() );
        req4( name, "_exit.04.11"           , "", TODO_REQ() );
        req4( name, "exit.04.11"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.11", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [ML] Any memory locks established by the process via calls to mlockall() or
         * mlock() shall be removed. If locked pages in the address space of the calling
         * process are also mapped into the address spaces of other processes and are
         * locked by those processes, the locks established by the other processes shall
         * be unaffected by the call by this process to _Exit() or _exit().
         */
        req4( name, "_Exit.04.12"           , "", TODO_REQ() );
        req4( name, "_exit.04.12"           , "", TODO_REQ() );
        req4( name, "exit.04.12"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.12", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [MF|SHM] Memory mappings that were created in the process shall be unmapped
         * before the process is destroyed.
         */
        req4( name, "_Exit.04.13"           , "", TODO_REQ() );
        req4( name, "_exit.04.13"           , "", TODO_REQ() );
        req4( name, "exit.04.13"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.13", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [TYM] Any blocks of typed memory that were mapped in the calling process shall
         * be unmapped, as if munmap() was implicitly called to unmap them.
         */
        req4( name, "_Exit.04.14"           , "", TODO_REQ() );
        req4( name, "_exit.04.14"           , "", TODO_REQ() );
        req4( name, "exit.04.14"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.14", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [MSG] All open message queue descriptors in the calling process shall be
         * closed as if by appropriate calls to mq_close().
         */
        req4( name, "_Exit.04.15"           , "", TODO_REQ() );
        req4( name, "_exit.04.15"           , "", TODO_REQ() );
        req4( name, "exit.04.15"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.15", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [AIO] Any outstanding cancelable asynchronous I/O operations may be canceled.
         * Those asynchronous I/O operations that are not canceled shall complete as if
         * the _Exit() or _exit() operation had not yet occurred, but any associated
         * signal notifications shall be suppressed. The _Exit() or _exit() operation may
         * block awaiting such I/O completion. Whether any I/O is canceled, and which I/O
         * may be canceled upon _Exit() or _exit(), is implementation-defined.
         */
        req4( name, "_Exit.04.16"           , "", TODO_REQ() );
        req4( name, "_exit.04.16"           , "", TODO_REQ() );
        req4( name, "exit.04.16"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.16", "", TODO_REQ() );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * Threads terminated by a call to _Exit() or _exit() shall not invoke their
         * cancellation cleanup handlers or per-thread data destructors.
         */
        req4( name, "_Exit.04.17", "", true );
        req4( name, "_exit.04.17", "", true );

        /*
         * These functions shall terminate the calling process [CX]  with the following
         * consequences:
         *
         * [TRC] If the calling process is a trace controller process, any trace streams
         * that were created by the calling process shall be shut down as described by the
         * posix_trace_shutdown() function, and any process' mapping of trace event names
         * to trace event type identifiers built for these trace streams may be
         * deallocated.
         */
        req4( name, "_Exit.04.18"           , "", TODO_REQ() );
        req4( name, "_exit.04.18"           , "", TODO_REQ() );
        req4( name, "exit.04.18"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.18", "", TODO_REQ() );

        /*
         * If the implementation supports the SIGCHLD signal, a SIGCHLD shall be sent to
         * the parent process.
         */
        req4( name, "_Exit.04.19.01"           , "", TODO_REQ() );
        req4( name, "_exit.04.19.01"           , "", TODO_REQ() );
        req4( name, "exit.04.19.01"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.19.01", "", TODO_REQ() );

        /*
         * If the parent process has set its SA_NOCLDWAIT flag, or set SIGCHLD to SIG_IGN,
         * the status shall be discarded, and the lifetime of the calling process shall
         * end immediately.
         */
        req4( name, "_Exit.04.19.02"           , "", TODO_REQ() );
        req4( name, "_exit.04.19.02"           , "", TODO_REQ() );
        req4( name, "exit.04.19.02"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.19.02", "", TODO_REQ() );

        /*
         * If SA_NOCLDWAIT is set, it is implementation-defined whether a SIGCHLD signal
         * is sent to the parent process.
         */
        req4( name, "_Exit.04.19.03"           , "", TODO_REQ() );
        req4( name, "_exit.04.19.03"           , "", TODO_REQ() );
        req4( name, "exit.04.19.03"            , "", TODO_REQ() );
        req4( name, "return_from_main.04.19.03", "", TODO_REQ() );

        /*
         * The value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE, [CX]  or any other
         * value, though only the least significant 8 bits (that is, status & 0377) shall
         * be available to a waiting parent process.
         */
        checkResult = true;
        req4( name, "_Exit.06"           , "Only the least significant 8 bits of status shall be available", checkResult );
        req4( name, "_exit.06"           , "Only the least significant 8 bits of status shall be available", checkResult );
        req4( name, "exit.06"            , "Only the least significant 8 bits of status shall be available", checkResult );
        req4( name, "return_from_main.06", "Only the least significant 8 bits of status shall be available", checkResult );

        /*
         * Whether open streams are flushed or closed, or temporary files are removed is
         * implementation-defined.
         */
        req4( name, "_Exit.07", "", TODO_REQ() );
        req4( name, "_exit.07", "", TODO_REQ() );

        return true;
    }
}

void onExitCalledProcessReturn( CallContext context )
{
    endCommand( context, "exit" );
}

void onExitProcessTerminated( CallContext context )
{
    ExitCall * blocked_call = endCommand( context, "exit" );
    IntT status = blocked_call->status;

    SystemState * systemState = getSystemState( context.system );
    ProcessState * processState = getProcessState_CallContext( context );
    ProcessId processId = create_ProcessId( context.system, context.process );
    ProcessId specialSystemParent = getSpecialSystemParent( context.system );
    int i;
    if ( processState->childInCreation != NULL ) {
        // exit after vfork
        processState->childInCreation = NULL;
    } else {
        ProcessState * parent = getProcessState( processState->meta.parent );
        Set /* ProcessState */ * children = getChildren_CallContext( context );
        add_Set( parent->finishedChildren, create_FinishedChild( processState, status ) );
        for ( i = 0; i < size_Set( children ); i++ ) {
            ProcessState * child = get_Set( children, i );
            if ( child->meta.parent.process == context.process ) { child->meta.parent = specialSystemParent; }
        }
        remove_Map( systemState->processes, create_ProcessIdObj( processId ) );
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    exit, _Exit, _exit - terminate a process

SYNOPSIS

    #include <stdlib.h>

    void exit(int status);
    void _Exit(int status);


    #include <unistd.h>
    void _exit(int status);

DESCRIPTION

    For exit() and _Exit(): The functionality described on this reference page
    is aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE
    Std 1003.1-2001 defers to the ISO C standard.

    The value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE, or any other
    value, though only the least significant 8 bits (that is, status & 0377)
    shall be available to a waiting parent process.

    The exit() function shall first call all functions registered by atexit(),
    in the reverse order of their registration, except that a function is called
    after any previously registered functions that had already been called at
    the time it was registered. Each function is called as many times as it was
    registered. If, during the call to any such function, a call to the
    longjmp() function is made that would terminate the call to the registered
    function, the behavior is undefined.

    If a function registered by a call to atexit() fails to return, the
    remaining registered functions shall not be called and the rest of the
    exit() processing shall not be completed. If exit() is called more than
    once, the behavior is undefined.

    The exit() function shall then flush all open streams with unwritten
    buffered data, close all open streams, and remove all files created by
    tmpfile(). Finally, control shall be terminated with the consequences
    described below.

    The _Exit() and _exit() functions shall be functionally equivalent.

    The _Exit() and _exit() functions shall not call functions registered with
    atexit() nor any registered signal handlers. Whether open streams are
    flushed or closed, or temporary files are removed is implementation-defined.
    Finally, the calling process is terminated with the consequences described
    below.

    These functions shall terminate the calling process with the following
    consequences:

    Note:

        These consequences are all extensions to the ISO C standard and are not
        further CX shaded. However, XSI extensions are shaded.

        All of the file descriptors, directory streams, conversion descriptors,
        and message catalog descriptors open in the calling process shall be
        closed.

        If the parent process of the calling process is executing a wait() or
        waitpid(), and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD to
        SIG_IGN, it shall be notified of the calling process' termination and
        the low-order eight bits (that is, bits 0377) of status shall be made
        available to it. If the parent is not waiting, the child's status shall
        be made available to it when the parent subsequently executes wait() or
        waitpid().
        The semantics of the waitid() function shall be equivalent to wait().

        If the parent process of the calling process is not executing a wait()
        or waitpid(), and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD
        to SIG_IGN, the calling process shall be transformed into a zombie
        process. A zombie process is an inactive process and it shall be deleted
        at some later time when its parent process executes wait() or waitpid().
        The semantics of the waitid() function shall be equivalent to wait().

        Termination of a process does not directly terminate its children. The
        sending of a SIGHUP signal as described below indirectly terminates
        children in some circumstances.
        Either:
        If the implementation supports the SIGCHLD signal, a SIGCHLD shall be
        sent to the parent process.
        Or:
        If the parent process has set its SA_NOCLDWAIT flag, or set SIGCHLD to
        SIG_IGN, the status shall be discarded, and the lifetime of the calling
        process shall end immediately. If SA_NOCLDWAIT is set, it is
        implementation-defined whether a SIGCHLD signal is sent to the parent
        process.

        The parent process ID of all of the calling process' existing child
        processes and zombie processes shall be set to the process ID of an
        implementation-defined system process. That is, these processes shall be
        inherited by a special system process.

        Each attached shared-memory segment is detached and the value of
        shm_nattch (see shmget()) in the data structure associated with its
        shared memory ID shall be decremented by 1.

        For each semaphore for which the calling process has set a semadj value
        (see semop() ), that value shall be added to the semval of the specified
        semaphore.

        If the process is a controlling process, the SIGHUP signal shall be sent
        to each process in the foreground process group of the controlling
        terminal belonging to the calling process.

        If the process is a controlling process, the controlling terminal
        associated with the session shall be disassociated from the session,
        allowing it to be acquired by a new controlling process.

        If the exit of the process causes a process group to become orphaned,
        and if any member of the newly-orphaned process group is stopped, then a
        SIGHUP signal followed by a SIGCONT signal shall be sent to each process
        in the newly-orphaned process group.

        All open named semaphores in the calling process shall be closed as if
        by appropriate calls to sem_close().

        Any memory locks established by the process via calls to mlockall() or
        mlock() shall be removed. If locked pages in the address space of the
        calling process are also mapped into the address spaces of other
        processes and are locked by those processes, the locks established by
        the other processes shall be unaffected by the call by this process to
        _Exit() or _exit().

        Memory mappings that were created in the process shall be unmapped
        before the process is destroyed.

        Any blocks of typed memory that were mapped in the calling process shall
        be unmapped, as if munmap() was implicitly called to unmap them.

        All open message queue descriptors in the calling process shall be
        closed as if by appropriate calls to mq_close().

        Any outstanding cancelable asynchronous I/O operations may be canceled.
        Those asynchronous I/O operations that are not canceled shall complete
        as if the _Exit() or _exit() operation had not yet occurred, but any
        associated signal notifications shall be suppressed. The _Exit() or
        _exit() operation may block awaiting such I/O completion. Whether any
        I/O is canceled, and which I/O may be canceled upon _Exit() or _exit(),
        is implementation-defined.

        Threads terminated by a call to _Exit() or _exit() shall not invoke
        their cancellation cleanup handlers or per-thread data destructors.

        If the calling process is a trace controller process, any trace streams
        that were created by the calling process shall be shut down as described
        by the posix_trace_shutdown() function, and any process' mapping of
        trace event names to trace event type identifiers built for these trace
        streams may be deallocated.

RETURN VALUE

    These functions do not return.

ERRORS

    No errors are defined.
*/
specification
void _Exit_spec( CallContext context, IntT status )
{
    IntTObj * exitFailure; // EXIT_FAILURE

    pre
    {
        /* [Local variable initialization] */
        exitFailure = readIntValueByName( context, "EXIT_FAILURE" );

        /* [Consistency of test suite] */
        REQ( "", "Value for EXIT_FAILURE is known", exitFailure != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Status
    {
        if ( status == SUT_EXIT_SUCCESS )
        {
            return { StatusIsExitSuccess, "status is EXIT_SUCCESS" };
        }
        else if ( status == * exitFailure )
        {
            return { StatusIsExitFailure, "status is EXIT_FAILURE" };
        }
        else if ( status <= 0xFF )
        {
            return { StatusIsNotGreaterThanFF, "status is not greater than 0xFF" };
        }
        else
        {
            return { StatusIsGreaterThanFF, "status is greater than 0xFF" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __cxa_atexit -- register a function to be called by exit or when a shared
    library is unloaded

SYNOPSIS

    int __cxa_atexit(void (*func) (void *), void * arg, void * dso_handle);

DESCRIPTION

    As described in the Itanium C++ ABI, __cxa_atexit() registers a destructor
    function to be called by exit() or when a shared library is unloaded. When
    a shared library is unloaded, any destructor function associated with that
    shared library, identified by dso_handle, shall be called with the single
    argument arg, and then that function shall be removed, or marked as
    complete, from the list of functions to run at exit(). On a call to exit(),
    any remaining functions registered shall be called with the single argument
    arg. Destructor functions shall always be called in the reverse order to
    their registration (i.e. the most recently registered function shall be
    called first),

    The __cxa_atexit() function is used to implement atexit(), as described in
    ISO POSIX (2003). Calling atexit(func) from the statically linked part of an
    application shall be equivalent to __cxa_atexit(func, NULL, NULL).

    __cxa_atexit() is not in the source standard; it is only in the binary
    standard.

    Note: atexit() is not in the binary standard; it is only in the source
    standard.
*/
specification
IntT __cxa_atexit_spec( CallContext context, CString * func, VoidTPtr arg, VoidTPtr dso_handle )
{
    ProcessState * process_state;
    List /* CString */ * registeredForCallAtExit;

    pre
    {
        process_state = getProcessState_CallContext( context );
        registeredForCallAtExit = clone( process_state->registeredForCallAtExit );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        if ( __cxa_atexit_spec != 0 )
        {
            /*
             * [Upon successful completion, atexit() shall return 0]
             * otherwise, it shall return a non-zero value
             */
            REQ( "__cxa_atexit.07.02", "return a non-zero value", true );

            return true;
        }

        /*
         * As described in the Itanium C++ ABI, __cxa_atexit() registers a destructor
         * function to be called by exit() or when a shared library is unloaded.
         */
        append_List( registeredForCallAtExit, func );
        REQ( "__cxa_atexit.01", "__cxa_atexit() registers a destructor function",
                                equals( registeredForCallAtExit, process_state->registeredForCallAtExit )
           );

        /*
         * When a shared library is unloaded, any destructor function associated with that
         * shared library, identified by dso_handle, shall be called with the single
         * argument arg, and then that function shall be removed, or marked as complete,
         * from the list of functions to run at exit().
         */
        REQ("__cxa_atexit.02", "", TODO_REQ());

        /*
         * On a call to exit(), any remaining functions registered shall be called with
         * the single argument arg.
         */
        REQ("__cxa_atexit.03", "", TODO_REQ());

        /*
         * Destructor functions shall always be called in the reverse order to their
         * registration (i.e. the most recently registered function shall be called
         * first),
         */
        REQ("__cxa_atexit.04", "", TODO_REQ());

        /*
         * The __cxa_atexit() function is used to implement atexit(), as described in ISO
         * POSIX (2003).
         */
        REQ("__cxa_atexit.05", "", TODO_REQ());

        /*
         * Calling atexit(func) from the statically linked part of an application shall
         * be equivalent to __cxa_atexit(func, NULL, NULL).
         */
        REQ("__cxa_atexit.06", "", TODO_REQ());

        /*
         * Upon successful completion, atexit() shall return 0
         */
        REQ( "__cxa_atexit.07.01", "Upon successful completion, atexit() shall return 0", __cxa_atexit_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __libc_start_main -- initialization routine

SYNOPSIS

    int __libc_start_main(int *(main) (int, char * *, char * *),
    int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void
    (*rtld_fini) (void), void (* stack_end));

DESCRIPTION

    The __libc_start_main() function shall perform any necessary initialization
    of the execution environment, call the main function with appropriate
    arguments, and handle the return from main(). If the main() function
    returns, the return value shall be passed to the exit() function.

    Note: While this specification is intended to be implementation independent,
    process and library initialization may include:

        performing any necessary security checks if the effective user ID is not
        the same as the real user ID.

        initialize the threading subsystem.

        registering the rtld_fini to release resources when this dynamic shared
        object exits (or is unloaded).

        registering the fini handler to run at program exit.

        calling the initializer function (*init)().

        calling main() with appropriate arguments.

        calling exit() with the return value from main().

    This list is an example only.

    __libc_start_main() is not in the source standard; it is only in the binary
    standard.

See Also

    The section on Process Initialization in each of the architecture specific
    supplements.
*/
specification
IntT __libc_start_main_spec( CallContext context, CString * main, IntT argc, List /* CString */ * ubp_av,
                                                  CString * init, CString * fini, CString * rtld_fini,
                                                  VoidTPtr stack_end
                           )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * The __libc_start_main() function shall
         *
         * perform any necessary initialization of the execution environment
         */
        REQ("__libc_start_main.01.01", "", TODO_REQ());

        /*
         * The __libc_start_main() function shall
         *
         * call the main function with appropriate arguments
         */
        REQ("__libc_start_main.01.02", "", TODO_REQ());

        /*
         * The __libc_start_main() function shall
         *
         * handle the return from main()
         */
        REQ("__libc_start_main.01.03", "", TODO_REQ());

        /*
         * If the main() function returns, the return value shall be passed to the exit()
         * function.
         */
        REQ("__libc_start_main.02", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __register_atfork -- alias for register_atfork

SYNOPSIS

    int __register_atfork(void (*prepare) (void), void (*parent) (void),
    void (*child) (void), void * __dso_handle);

DESCRIPTION

    __register_atfork() implements pthread_atfork() as specified in ISO POSIX
    (2003). The additional parameter __dso_handle allows a shared object to pass
    in it's handle so that functions registered by __register_atfork() can be
    unregistered by the runtime when the shared object is unloaded.
*/
specification
IntT __register_atfork_spec( CallContext context,
                             CString * prepare, CString * parent, CString * child, VoidTPtr __dso_handle
                           )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        /*
         * [Upon successful completion, pthread_atfork() shall return a value of zero]
         * otherwise, an error number shall be returned to indicate the error
         */
        REQ("__register_atfork.09.02", "", TODO_REQ());
        ERROR_BEGIN(LSB___REGISTER_ATFORK, "__register_atfork.10.01", __register_atfork_spec != 0, __register_atfork_spec )
            /*
             * The pthread_atfork() function shall fail if:
             *
             * [ENOMEM]
             * Insufficient table space exists to record the fork handler addresses.
             */
            ERROR_UNCHECKABLE( LSB___REGISTER_ATFORK, ENOMEM, "__register_atfork.10.01", "" )

            /*
             * The pthread_atfork() function shall not return an error code of [EINTR].
             */
            ERROR_NEVER( LSB___REGISTER_ATFORK, EINTR, "__register_atfork.11" )
        ERROR_END()

        /*
         * __register_atfork() implements pthread_atfork() as specified in ISO POSIX
         * (2003).
         */
        REQ("__register_atfork.01", "", TODO_REQ());

        /*
         * The additional parameter __dso_handle allows a shared object to pass in it's
         * handle so that functions registered by __register_atfork() can be unregistered
         * by the runtime when the shared object is unloaded.
         */
        REQ("__register_atfork.02", "", TODO_REQ());

        /*
         * The pthread_atfork() function shall declare fork handlers to be called before
         * and after fork(), in the context of the thread that called fork().
         */
        REQ("__register_atfork.03", "", TODO_REQ());

        /*
         * The prepare fork handler shall be called before fork() processing commences.
         */
        REQ("__register_atfork.04", "", TODO_REQ());

        /*
         * The parent fork handle shall be called after fork() processing completes in the
         * parent process.
         */
        REQ("__register_atfork.05", "", TODO_REQ());

        /*
         * The child fork handler shall be called after fork() processing completes in
         * the child process.
         */
        REQ("__register_atfork.06", "", TODO_REQ());

        /*
         * If no handling is desired at one or more of these three points, the
         * corresponding fork handler address(es) may be set to NULL.
         */
        REQ("__register_atfork.07", "", TODO_REQ());

        /*
         * The order of calls to pthread_atfork() is significant.
         *
         * The parent and child fork handlers shall be called in the order in which they
         * were established by calls to pthread_atfork().
         */
        REQ("__register_atfork.08.01", "", TODO_REQ());

        /*
         * The order of calls to pthread_atfork() is significant.
         *
         * The prepare fork handlers shall be called in the opposite order.
         */
        REQ("__register_atfork.08.02", "", TODO_REQ());

        /*
         * Upon successful completion, pthread_atfork() shall return a value of zero
         */
        REQ("__register_atfork.09.01", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    exit, _Exit, _exit - terminate a process

SYNOPSIS

    #include <stdlib.h>

    void exit(int status);
    void _Exit(int status);


    #include <unistd.h>
    void _exit(int status);

DESCRIPTION

    For exit() and _Exit(): The functionality described on this reference page
    is aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE
    Std 1003.1-2001 defers to the ISO C standard.

    The value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE, or any other
    value, though only the least significant 8 bits (that is, status & 0377)
    shall be available to a waiting parent process.

    The exit() function shall first call all functions registered by atexit(),
    in the reverse order of their registration, except that a function is called
    after any previously registered functions that had already been called at
    the time it was registered. Each function is called as many times as it was
    registered. If, during the call to any such function, a call to the
    longjmp() function is made that would terminate the call to the registered
    function, the behavior is undefined.

    If a function registered by a call to atexit() fails to return, the
    remaining registered functions shall not be called and the rest of the
    exit() processing shall not be completed. If exit() is called more than
    once, the behavior is undefined.

    The exit() function shall then flush all open streams with unwritten
    buffered data, close all open streams, and remove all files created by
    tmpfile(). Finally, control shall be terminated with the consequences
    described below.

    The _Exit() and _exit() functions shall be functionally equivalent.

    The _Exit() and _exit() functions shall not call functions registered with
    atexit() nor any registered signal handlers. Whether open streams are
    flushed or closed, or temporary files are removed is implementation-defined.
    Finally, the calling process is terminated with the consequences described
    below.

    These functions shall terminate the calling process with the following
    consequences:

    Note:

        These consequences are all extensions to the ISO C standard and are not
        further CX shaded. However, XSI extensions are shaded.

        All of the file descriptors, directory streams, conversion descriptors,
        and message catalog descriptors open in the calling process shall be
        closed.

        If the parent process of the calling process is executing a wait() or
        waitpid(), and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD to
        SIG_IGN, it shall be notified of the calling process' termination and
        the low-order eight bits (that is, bits 0377) of status shall be made
        available to it. If the parent is not waiting, the child's status shall
        be made available to it when the parent subsequently executes wait() or
        waitpid().
        The semantics of the waitid() function shall be equivalent to wait().

        If the parent process of the calling process is not executing a wait()
        or waitpid(), and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD
        to SIG_IGN, the calling process shall be transformed into a zombie
        process. A zombie process is an inactive process and it shall be deleted
        at some later time when its parent process executes wait() or waitpid().
        The semantics of the waitid() function shall be equivalent to wait().

        Termination of a process does not directly terminate its children. The
        sending of a SIGHUP signal as described below indirectly terminates
        children in some circumstances.
        Either:
        If the implementation supports the SIGCHLD signal, a SIGCHLD shall be
        sent to the parent process.
        Or:
        If the parent process has set its SA_NOCLDWAIT flag, or set SIGCHLD to
        SIG_IGN, the status shall be discarded, and the lifetime of the calling
        process shall end immediately. If SA_NOCLDWAIT is set, it is
        implementation-defined whether a SIGCHLD signal is sent to the parent
        process.

        The parent process ID of all of the calling process' existing child
        processes and zombie processes shall be set to the process ID of an
        implementation-defined system process. That is, these processes shall be
        inherited by a special system process.

        Each attached shared-memory segment is detached and the value of
        shm_nattch (see shmget()) in the data structure associated with its
        shared memory ID shall be decremented by 1.

        For each semaphore for which the calling process has set a semadj value
        (see semop() ), that value shall be added to the semval of the specified
        semaphore.

        If the process is a controlling process, the SIGHUP signal shall be sent
        to each process in the foreground process group of the controlling
        terminal belonging to the calling process.

        If the process is a controlling process, the controlling terminal
        associated with the session shall be disassociated from the session,
        allowing it to be acquired by a new controlling process.

        If the exit of the process causes a process group to become orphaned,
        and if any member of the newly-orphaned process group is stopped, then a
        SIGHUP signal followed by a SIGCONT signal shall be sent to each process
        in the newly-orphaned process group.

        All open named semaphores in the calling process shall be closed as if
        by appropriate calls to sem_close().

        Any memory locks established by the process via calls to mlockall() or
        mlock() shall be removed. If locked pages in the address space of the
        calling process are also mapped into the address spaces of other
        processes and are locked by those processes, the locks established by
        the other processes shall be unaffected by the call by this process to
        _Exit() or _exit().

        Memory mappings that were created in the process shall be unmapped
        before the process is destroyed.

        Any blocks of typed memory that were mapped in the calling process shall
        be unmapped, as if munmap() was implicitly called to unmap them.

        All open message queue descriptors in the calling process shall be
        closed as if by appropriate calls to mq_close().

        Any outstanding cancelable asynchronous I/O operations may be canceled.
        Those asynchronous I/O operations that are not canceled shall complete
        as if the _Exit() or _exit() operation had not yet occurred, but any
        associated signal notifications shall be suppressed. The _Exit() or
        _exit() operation may block awaiting such I/O completion. Whether any
        I/O is canceled, and which I/O may be canceled upon _Exit() or _exit(),
        is implementation-defined.

        Threads terminated by a call to _Exit() or _exit() shall not invoke
        their cancellation cleanup handlers or per-thread data destructors.

        If the calling process is a trace controller process, any trace streams
        that were created by the calling process shall be shut down as described
        by the posix_trace_shutdown() function, and any process' mapping of
        trace event names to trace event type identifiers built for these trace
        streams may be deallocated.

RETURN VALUE

    These functions do not return.

ERRORS

    No errors are defined.
*/
specification
void _exit_spec( CallContext context, IntT status )
{
    IntTObj * exitFailure; // EXIT_FAILURE

    pre
    {
        /* [Local variable initialization] */
        exitFailure = readIntValueByName( context, "EXIT_FAILURE" );

        /* [Consistency of test suite] */
        REQ( "", "Value for EXIT_FAILURE is known", exitFailure != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Status
    {
        if ( status == SUT_EXIT_SUCCESS )
        {
            return { StatusIsExitSuccess, "status is EXIT_SUCCESS" };
        }
        else if ( status == * exitFailure )
        {
            return { StatusIsExitFailure, "status is EXIT_FAILURE" };
        }
        else if ( status <= 0xFF )
        {
            return { StatusIsNotGreaterThanFF, "status is not greater than 0xFF" };
        }
        else
        {
            return { StatusIsGreaterThanFF, "status is greater than 0xFF" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    abort - generate an abnormal process abort

SYNOPSIS

    #include <stdlib.h>

    void abort(void);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO C
    standard. Any conflict between the requirements described here and the ISO C
    standard is unintentional. This volume of IEEE Std 1003.1-2001 defers to the
    ISO C standard.

    The abort() function shall cause abnormal process termination to occur,
    unless the signal SIGABRT is being caught and the signal handler does not
    return.

    The abnormal termination processing shall include the default actions
    defined for SIGABRT and may include an attempt to effect fclose() on all
    open streams.

    The SIGABRT signal shall be sent to the calling process as if by means of
    raise() with the argument SIGABRT.

    The status made available to wait() or waitpid() by abort() shall be that of
    a process terminated by the SIGABRT signal. The abort() function shall
    override blocking or ignoring the SIGABRT signal.

RETURN VALUE

    The abort() function shall not return.

ERRORS

    No errors are defined.
*/
specification typedef struct AbortCall AbortCall = {};

AbortCall * create_AbortCall( CallContext context )
{
    return create( & type_AbortCall, context );
}

specification
void abort_spec( CallContext context )
{
    pre
    {
        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        return true;
    }
}

void onAbort( CallContext context )
{
    startBlockedCall( context, create_AbortCall( context ) );
}

specification typedef struct AbortReturnType AbortReturnType = {};

AbortReturnType * create_AbortReturnType(CallContext context)
{
    return create(&type_AbortReturnType, context);
}

reaction AbortReturnType * abortCalledProcess_return( void )
{
    post
    {
        /*
         * The abort() function shall not return.
         */
        REQ( "abort.02", "abort() function shall not return", false );

        return true;
    }
}

reaction AbortReturnType * abort_processTerminated( void )
{
    post
    {
        CallContext context = abort_processTerminated->context;

        AbortCall * blocked_call = findBlockedCall( @getBlockedCalls(), context );

        /*
         * The status made available to wait() or waitpid() by abort() shall be that of a
         * process terminated by the SIGABRT signal.
         */
        REQ("abort.01", "", TODO_REQ());

        /*
         * The abnormal termination processing shall include the default actions defined
         * for SIGABRT
         */
        REQ("abort.03", "", TODO_REQ());

        /*
         * may include an attempt to effect fclose() on all open streams.
         */
        REQ("abort.04", "", TODO_REQ());

        /*
         * The SIGABRT signal shall be sent to the calling process as if by means of raise(
         * ) with the argument SIGABRT.
         */
        REQ("abort.05", "", TODO_REQ());

        /*
         * The abort() function shall cause abnormal process termination to occur, unless
         * the signal SIGABRT is being caught and the signal handler does not return.
         */
        REQ("abort.06", "", TODO_REQ());

        /*
         * The abort() function shall override blocking or ignoring the SIGABRT signal.
         */
        REQ("abort.07", "", TODO_REQ());

        return true;
    }
}

void onAbortCalledProcessReturn( CallContext context )
{
}

void onAbortProcessTerminated( CallContext context )
{
    AbortCall * blocked_call = finishBlockedCall( context );

    SystemState * systemState = getSystemState( context.system );
    ProcessId processId = create_ProcessId( context.system, context.process );
    ProcessId specialSystemParent = getSpecialSystemParent( context.system );
    int i;
    remove_Map( systemState->processes, create_ProcessIdObj( processId ) );
    for ( i = 0; i < size_Map( systemState->processes ); i++ ) {
        ProcessIdObj * key = key_Map( systemState->processes, i );
        ProcessState * processState = get_Map( systemState->processes, key );
        if ( processState->meta.parent.process == context.process ) { processState->meta.parent = specialSystemParent; }
    }
}

/*
 * common for daemon, fork and vfork
 */
specification typedef struct ForkCall ForkCall = {};

ForkCall * create_ForkCall( CallContext context )
{
    return create( & type_ForkCall, context );
}

void onFork( CallContext context )
{
    ProcessState * process_state = getProcessState_CallContext( context );
    process_state->childInCreation = clone( process_state );

    startCommand( context, "fork", create_ForkCall( context ) );
    startCommand( context, "fork", create_ForkCall( context ) ); // for possible child
}

specification typedef struct ForkReturnType ForkReturnType = {};

ForkReturnType * create_ForkReturnType(
    String      * name,
    CallContext   context,
    ProcessId     returned_value,
    ErrorCode   * error_code,
    PThreadT      childThread
)
{
    return create(&type_ForkReturnType,
        name,
        context,
        returned_value,
        error_code,
        childThread);
}

reaction ForkReturnType * fork_return( void )
{
    post
    {
        String      * name      = fork_return->name          ;
        CallContext   context   = fork_return->context       ;
        ProcessId     fork_spec = fork_return->returned_value;
        ErrorCode   * errno     = fork_return->error_code    ;

        ForkCall * blocked_call = showCommand( @getBlockedCalls(), context, "fork" );

        ProcessState * parent_state = getProcessState_CallContext( context   );
        ProcessState * child_state  = getProcessState            ( fork_spec );

        if ( equals( create_String( "daemon" ), name ) )
        {
            /*
             * On error, -1 is returned, and the global variable errno is set to any of the
             * errors specified for the library functions fork() and setsid().
             */
            ERROR_BEGIN( LSB_DAEMON, "daemon.02.02", fork_spec.process == -1, * errno )
                /*
                 * The fork() function shall fail if:
                 *
                 * [EAGAIN]
                 *
                 * The system lacked the necessary resources to create another process, or the
                 * system-imposed limit on the total number of processes under execution system-
                 * wide or by a single user {CHILD_MAX} would be exceeded.
                 */
                ERROR_UNCHECKABLE(LSB_DAEMON, EAGAIN, "daemon.03.01", "")

                /*
                 * The fork() function may fail if:
                 *
                 * [ENOMEM]
                 *
                 * Insufficient storage space is available.
                 */
                ERROR_UNCHECKABLE(LSB_DAEMON, ENOMEM, "daemon.04.01", "")
            ERROR_END()
        }
        else if ( equals( create_String( "fork"  ), name ) )
        {
            /*
             * [Upon successful completion, fork() shall return 0 to the child process and
             * shall return the process ID of the child process to the parent process. Both
             * processes shall continue to execute from the fork() function.]
             * Otherwise, -1 shall be returned to the parent process, no child process shall
             * be created, and errno shall be set to indicate the error.
             */
            ERROR_BEGIN( POSIX_FORK, "fork.02.02", fork_spec.process == -1, * errno )
                /*
                 * The fork() function shall fail if:
                 *
                 * [EAGAIN]
                 *
                 * The system lacked the necessary resources to create another process, or the
                 * system-imposed limit on the total number ofprocesses under execution system-
                 * wide or by a single user {CHILD_MAX} would be exceeded.
                 */
                ERROR_UNCHECKABLE(POSIX_FORK, EAGAIN, "fork.03.01", "")

                /*
                 * The fork() function may fail if:
                 *
                 * [ENOMEM]
                 *
                 * Insufficient storage space is available.
                 */
                ERROR_UNCHECKABLE(POSIX_FORK, ENOMEM, "fork.04.01", "")
            ERROR_END()

            /*
             * Upon successful completion, fork() shall return 0 to the child process and
             * shall return the process ID of the child process to the parent process. Both
             * processes shall continue to execute from the fork() function.
             */
            // verbose( "fork_return : fork_spec                [%d|%d]\n", fork_spec.system               , fork_spec.process                );
            // verbose( "fork_return : child_state->processid   [%d|%d]\n", child_state->processid.system  , child_state->processid.process   );
            // verbose( "fork_return : child_state->meta.parent [%d|%d]\n", child_state->meta.parent.system, child_state->meta.parent.process );
            // verbose( "fork_return : parent_state->processid  [%d|%d]\n", parent_state->processid.system , parent_state->processid.process  );
            REQ( "fork.02.01", "fork() shall return the process ID of the child process to the parent process",
                               T( child_state != NULL                                                 ) &&
                               T( child_state->meta.parent.system  == parent_state->processid.system  ) &&
                               T( child_state->meta.parent.process == parent_state->processid.process )
               );
        }
        else if ( equals( create_String( "forkpty" ), name ) )
        {
            /*
             * On error, no new process shall be created, -1 shall be returned, and errno
             * shall be set appropriately.
             */
            ERROR_BEGIN( LSB_FORKPTY, "forkpty.02.02", fork_spec.process == -1, * errno )

                /*
                 * Errors
                 *
                 * [EAGAIN]
                 * Unable to create a new process.
                 */
                ERROR_SHALL(LSB_FORKPTY, EAGAIN, "forkpty.06.01", TODO_ERR(EAGAIN) )

                /*
                 * Errors
                 *
                 * [ENOENT]
                 * There are no available pseudo-terminals.
                 */
                ERROR_SHALL(LSB_FORKPTY, ENOENT, "forkpty.06.02", TODO_ERR(ENOENT) )

                /*
                 * Errors
                 *
                 * [ENOMEM]
                 * Insufficient memory was available.
                 */
                ERROR_SHALL(LSB_FORKPTY, ENOMEM, "forkpty.06.03", TODO_ERR(ENOMEM) )
            ERROR_END()

            /*
             * On success, the parent process shall return the process id of the child, and
             * the child shall return 0.
             */
            REQ( "forkpty.02.01", "the parent process shall return the process id of the child",
                                  T( child_state != NULL                                                 ) &&
                                  T( child_state->meta.parent.system  == parent_state->processid.system  ) &&
                                  T( child_state->meta.parent.process == parent_state->processid.process )
               );

            /*
             * On success, the parent process shall receive
             *
             * the file descriptor of the master side of the pseudo-terminal in the location
             * referenced by amaster
             */
            REQ("forkpty.05.01", "", TODO_REQ());

            /*
             * On success, the parent process shall receive
             *
             * if name is not NULL, the filename of the slave device in name
             */
            REQ("forkpty.05.02", "", TODO_REQ());
        }
        else if ( equals( create_String( "vfork" ), name ) )
        {
            /*
             * [Upon successful completion, vfork() shall return 0 to the child process and
             * return the process ID of the child process to the parent process.]
             * Otherwise, -1 shall be returned to the parent, no child process shall be created,
             * and errno shall be set to indicate the error.
             */
            ERROR_BEGIN( POSIX_VFORK, "vfork.02.02", fork_spec.process == -1, * errno )
                /*
                 * The vfork() function shall fail if:
                 *
                 * [EAGAIN]
                 *
                 * The system-wide limit on the total number of processes under execution would be
                 * exceeded, or the system-imposed limit on the total number of processes under
                 * execution by a single user would be exceeded.
                 */
                ERROR_UNCHECKABLE(POSIX_VFORK, EAGAIN, "vfork.03.01", "")

                /*
                 * The vfork() function shall fail if:
                 *
                 * [ENOMEM]
                 *
                 * There is insufficient swap space for the new process.
                 */
                ERROR_UNCHECKABLE(POSIX_VFORK, ENOMEM, "vfork.03.02", "")
            ERROR_END()

            /*
             * Upon successful completion, vfork() shall return 0 to the child process and
             * return the process ID of the child process to the parent process.
             *
             * [After vfork must be called _exit() or one of the exec family of functions.]
             */
            if ( child_state == NULL )
            {
                /* [After vfork was called _exit().] */
                REQ( "vfork.02.01", "vfork() shall return the process ID of the child process to the parent process",
                                    true
                   );
            }
            else
            {
                /* [After vfork was called one of the exec family of functions.] */
                REQ( "vfork.02.01", "vfork() shall return the process ID of the child process to the parent process",
                                    T( child_state->meta.parent.system  == parent_state->processid.system  ) &&
                                    T( child_state->meta.parent.process == parent_state->processid.process )
                   );
            }
        }
        else
        {
            REQTRACE( "fork_return : unknown name" );
            return false;
        }

        /*
         * After fork(), both the parent and the child processes shall be capable of
         * executing independently before either one terminates.
         */
        req4( name, "fork.07" , "", TODO_REQ() );
        req4( name, "vfork.07", "", TODO_REQ() );

        return true;
    }
}

reaction ForkReturnType * forkToChild_return( void )
{
    post
    {
        String      * name      = forkToChild_return->name          ;
        CallContext   context   = forkToChild_return->context       ;
        ProcessId     fork_spec = forkToChild_return->returned_value;
        ErrorCode   * errno     = forkToChild_return->error_code    ;

        ForkCall * blocked_call = showCommand( @getBlockedCalls(), context, "fork" );

        ProcessState * parent_state;
        ProcessState * child_state ;
        ProcessState * process_state = getProcessState_CallContext( context );

        if ( process_state->childInCreation != NULL )
        {
            parent_state = process_state                 ;
            child_state  = process_state->childInCreation;
        }
        else
        {
            parent_state = getProcessState( process_state->meta.parent );
            child_state  = process_state                                ;
        }

        /* [Consistency of test suite] */
        REQ( "", "Child process state exists" , child_state != NULL );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall have a unique process ID.
         */
        req4( name, "daemon.01.01", "The child process shall have a unique process ID", parent_state != NULL );
        req4( name, "fork.01.01"  , "The child process shall have a unique process ID", parent_state != NULL );
        req4( name, "vfork.01.01" , "The child process shall have a unique process ID", parent_state != NULL );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process ID also shall not match any active process group ID.
         */
        req4( name, "daemon.01.02", "The child process ID also shall not match any active process group ID.", TODO_REQ() );
        req4( name, "fork.01.02"  , "The child process ID also shall not match any active process group ID.", TODO_REQ() );
        req4( name, "vfork.01.02" , "The child process ID also shall not match any active process group ID.", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall have a different parent process ID, which shall be the
         * process ID of the calling process.
         */
        req4( name, "daemon.01.03", "The child process shall have a different parent process ID", parent_state != NULL );
        req4( name, "fork.01.03"  , "The child process shall have a different parent process ID", parent_state != NULL );
        req4( name, "vfork.01.03" , "The child process shall have a different parent process ID", parent_state != NULL );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall have its own copy of the parent's file descriptors.
         * Each of the child's file descriptors shall refer to the same open file
         * description with the corresponding file descriptor of the parent.
         */
        req4( name, "daemon.01.04", "The child process shall have its own copy of the parent's file descriptors",
                                    TODO_REQ()
            );
        req4( name, "fork.01.04"  , "The child process shall have its own copy of the parent's file descriptors",
                                    TODO_REQ()
            );
        req4( name, "vfork.01.04" , "The child process shall have its own copy of the parent's file descriptors",
                                    TODO_REQ()
            );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall have its own copy of the parent's open directory
         * streams. Each open directory stream in the child process may share directory
         * stream positioning with the corresponding directory stream of the parent.
         */
        req4( name, "daemon.01.05", "The child process shall have its own copy of the parent's open directory streams",
                                    TODO_REQ()
           );
        req4( name, "fork.01.05"  , "The child process shall have its own copy of the parent's open directory streams",
                                    TODO_REQ()
           );
        req4( name, "vfork.01.05" , "The child process shall have its own copy of the parent's open directory streams",
                                    TODO_REQ()
           );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall have its own copy of the parent's message catalog
         * descriptors.
         */
        req4( name, "daemon.01.06", "", TODO_REQ() );
        req4( name, "fork.01.06"  , "", TODO_REQ() );
        req4( name, "vfork.01.06" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process' values of tms_utime, tms_stime, tms_cutime, and tms_cstime
         * shall be set to 0.
         */
        req4( name, "daemon.01.07", "", TODO_REQ() );
        req4( name, "fork.01.07"  , "", TODO_REQ() );
        req4( name, "vfork.01.07" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The time left until an alarm clock signal shall be reset to zero, and the alarm,
         * if any, shall be canceled; see alarm().
         */
        req4( name, "daemon.01.08", "", TODO_REQ() );
        req4( name, "fork.01.08"  , "", TODO_REQ() );
        req4( name, "vfork.01.08" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * All semadj values shall be cleared.
         */
        req4( name, "daemon.01.09", "", TODO_REQ() );
        req4( name, "fork.01.09"  , "", TODO_REQ() );
        req4( name, "vfork.01.09" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * File locks set by the parent process shall not be inherited by the child
         * process.
         */
        req4( name, "daemon.01.10", "", TODO_REQ() );
        req4( name, "fork.01.10"  , "", TODO_REQ() );
        req4( name, "vfork.01.10" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The set of signals pending for the child process shall be initialized to the
         * empty set.
         */
        req4( name, "daemon.01.11", "", TODO_REQ() );
        req4( name, "fork.01.11"  , "", TODO_REQ() );
        req4( name, "vfork.01.11" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * Interval timers shall be reset in the child process.
         */
        req4( name, "daemon.01.12", "", TODO_REQ() );
        req4( name, "fork.01.12"  , "", TODO_REQ() );
        req4( name, "vfork.01.12" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * Any semaphores that are open in the parent process shall also be open in the
         * child process.
         */
        req4( name, "daemon.01.13", "", TODO_REQ() );
        req4( name, "fork.01.13"  , "", TODO_REQ() );
        req4( name, "vfork.01.13" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall not inherit any address space memory locks established
         * by the parent process via calls to mlockall() or mlock().
         */
        req4( name, "daemon.01.14", "", TODO_REQ() );
        req4( name, "fork.01.14"  , "", TODO_REQ() );
        req4( name, "vfork.01.14" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * Memory mappings created in the parent shall be retained in the child process.
         * MAP_PRIVATE mappings inherited from the parent shall also be MAP_PRIVATE
         * mappings in the child, and any modifications to the data in these mappings made
         * by the parent prior to calling fork() shall be visible to the child. Any
         * modifications to the data in MAP_PRIVATE mappings made by the parent after
         * fork() returns shall be visible only to the parent. Modifications to the data
         * in MAP_PRIVATE mappings made by the child shall be visible only to the child.
         */
        req4( name, "daemon.01.15", "", TODO_REQ() );
        req4( name, "fork.01.15"  , "", TODO_REQ() );
        req4( name, "vfork.01.15" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * For the SCHED_FIFO and SCHED_RR scheduling policies, the child process shall
         * inherit the policy and priority settings of the parent process during a fork()
         * function. For other scheduling policies, the policy and priority settings on
         * fork() are implementation-defined.
         */
        req4( name, "daemon.01.16", "", TODO_REQ() );
        req4( name, "fork.01.16"  , "", TODO_REQ() );
        req4( name, "vfork.01.16" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * Per-process timers created by the parent shall not be inherited by the child
         * process.
         */
        req4( name, "daemon.01.17", "", TODO_REQ() );
        req4( name, "fork.01.17"  , "", TODO_REQ() );
        req4( name, "vfork.01.17" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The child process shall have its own copy of the message queue descriptors of
         * the parent. Each of the message descriptors of the child shall refer to the
         * same open message queue description as the corresponding message descriptor of
         * the parent.
         */
        req4( name, "daemon.01.18", "", TODO_REQ() );
        req4( name, "fork.01.18"  , "", TODO_REQ() );
        req4( name, "vfork.01.18" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * No asynchronous input or asynchronous output operations shall be inherited by
         * the child process.
         */
        req4( name, "daemon.01.19", "", TODO_REQ() );
        req4( name, "fork.01.19"  , "", TODO_REQ() );
        req4( name, "vfork.01.19" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * A process shall be created with a single thread. If a multi-threaded process
         * calls fork(), the new process shall contain a replica of the calling thread and
         * its entire address space, possibly including the states of mutexes and other
         * resources. Consequently, to avoid errors, the child process may only execute
         * async-signal-safe operations until such time as one of the exec functions is
         * called. [THR]  Fork handlers may be established by means of the pthread_atfork(
         * ) function in order to maintain application invariants across fork() calls.
         *
         * When the application calls fork() from a signal handler and any of the fork
         * handlers registered by pthread_atfork() calls a function that is not asynch-
         * signal-safe, the behavior is undefined.
         */
        req4( name, "daemon.01.20", "", TODO_REQ() );
        req4( name, "fork.01.20"  , "", TODO_REQ() );
        req4( name, "vfork.01.20" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * [TRC TRI] If the Trace option and the Trace Inherit option are both supported:
         *
         * If the calling process was being traced in a trace stream that had its
         * inheritance policy set to POSIX_TRACE_INHERITED, the child process shall be
         * traced into that trace stream, and the child process shall inherit the parent's
         * mapping of trace event names to trace event type identifiers. If the trace
         * stream in which the calling process was being traced had its inheritance policy
         * set to POSIX_TRACE_CLOSE_FOR_CHILD, the child process shall not be traced into
         * that trace stream. The inheritance policy is set by a call to the
         * posix_trace_attr_setinherited() function.
         */
        req4( name, "daemon.01.21", "", TODO_REQ() );
        req4( name, "fork.01.21"  , "", TODO_REQ() );
        req4( name, "vfork.01.21" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * [TRC] If the Trace option is supported, but the Trace Inherit option is not
         * supported:
         *
         * The child process shall not be traced into any of the trace streams of its
         * parent process.
         */
        req4( name, "daemon.01.22", "", TODO_REQ() );
        req4( name, "fork.01.22"  , "", TODO_REQ() );
        req4( name, "vfork.01.22" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * If the Trace option is supported, the child process of a trace controller
         * process shall not control the trace streams controlled by its parent process.
         */
        req4( name, "daemon.01.23", "", TODO_REQ() );
        req4( name, "fork.01.23"  , "", TODO_REQ() );
        req4( name, "vfork.01.23" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The initial value of the CPU-time clock of the child process shall be set to
         * zero.
         */
        req4( name, "daemon.01.24", "", TODO_REQ() );
        req4( name, "fork.01.24"  , "", TODO_REQ() );
        req4( name, "vfork.01.24" , "", TODO_REQ() );

        /*
         * The fork() function shall create a new process. The new process (child process)
         * shall be an exact copy of the calling process (parent process) except as
         * detailed below:
         *
         * The initial value of the CPU-time clock of the single thread of the child
         * process shall be set to zero.
         */
        req4( name, "daemon.01.25", "", TODO_REQ() );
        req4( name, "fork.01.25"  , "", TODO_REQ() );
        req4( name, "vfork.01.25" , "", TODO_REQ() );


        /*
         * Upon successful completion, fork() shall return 0 to the child process and
         * shall return the process ID of the child process to the parent process. Both
         * processes shall continue to execute from the fork() function. Otherwise, -1
         * shall be returned to the parent process, no child process shall be created, and
         * errno shall be set to indicate the error.
         *
         * On success, the parent process shall return the process id of the child, and
         * the child shall return 0.
         *
         * Upon successful completion, vfork() shall return 0 to the child process and
         * return the process ID of the child process to the parent process. Otherwise, -1
         * shall be returned to the parent, no child process shall be created, and errno
         * shall be set to indicate the error.
         */
        req4( name, "daemon.02.01" , "fork() shall return 0 to the child process" , fork_spec.process == 0 );
        req4( name, "fork.02.01"   , "fork() shall return 0 to the child process" , fork_spec.process == 0 );
        req4( name, "forkpty.02.01", "the child shall return 0"                   , fork_spec.process == 0 );
        req4( name, "vfork.02.01"  , "vfork() shall return 0 to the child process", fork_spec.process == 0 );

        /*
         * All other process characteristics defined by IEEE Std 1003.1-2001 shall be the
         * same in the parent and child processes.
         */
        req4( name, "daemon.05", "", TODO_REQ() );
        req4( name, "fork.05"  , "", TODO_REQ() );
        req4( name, "vfork.05" , "", TODO_REQ() );

        /*
         * The inheritance of process characteristics not defined by IEEE Std 1003.1-2001
         * is unspecified by IEEE Std 1003.1-2001.
         */
        req4( name, "daemon.06", "", TODO_REQ() );
        req4( name, "fork.06"  , "", TODO_REQ() );
        req4( name, "vfork.06" , "", TODO_REQ() );

        /*
         * After fork(), both the parent and the child processes shall be capable of
         * executing independently before either one terminates.
         */
        req4( name, "daemon.07", "", TODO_REQ() );
        req4( name, "fork.07"  , "", TODO_REQ() );
        req4( name, "vfork.07" , "", TODO_REQ() );

        /*
         * The forkpty() function shall find and open a pseudo-terminal device pair in
         * the same manner as the openpty() function.
         */
        req4( name, "forkpty.01", "", TODO_REQ() );

        /*
         * If a pseudo-terminal is available, forkpty() shall create a new process in
         * the same manner as the fork() function
         */
        req4( name, "forkpty.03", "", TODO_REQ() );

        /*
         * prepares the new process for login in the same manner as login_tty().
         */
        req4( name, "forkpty.04", "", TODO_REQ() );

        return true;
    }
}

void onForkReturn( String * name, CallContext context, ProcessId fork_spec, ErrorCode * error_code )
{
    ProcessState * parentState;
    endCommand( context, "fork" );
    parentState = getProcessState_CallContext( context );
    if ( fork_spec.process == -1 ) {
        // no child
        endCommand( context, "fork" );
    } else {
        // complete and register child info
        ThreadIdObj * threadIdObj;
        ThreadState * oldThreadState;
        if ( parentState->childInCreation == NULL ) { return; } // vfork + _exit || vfork + execl
        // verbose( "onForkReturn : fork_spec                                 [%d|%d]\n", fork_spec.system                                , fork_spec.process                                 );
        // verbose( "onForkReturn : parentState->childInCreation->processid   [%d|%d]\n", parentState->childInCreation->processid.system  , parentState->childInCreation->processid.process   );
        // verbose( "onForkReturn : parentState->childInCreation->meta.parent [%d|%d]\n", parentState->childInCreation->meta.parent.system, parentState->childInCreation->meta.parent.process );
        // verbose( "onForkReturn : parentState->processid                    [%d|%d]\n", parentState->processid.system                   , parentState->processid.process                    );
        parentState->childInCreation->processid = fork_spec;
        parentState->childInCreation->meta.parent = parentState->processid;
        threadIdObj = key_Map( parentState->childInCreation->threads, 0 );
        oldThreadState = get_Map( parentState->childInCreation->threads, threadIdObj );
        threadIdObj->process = fork_spec.process; // threadIdObj->thread was or will be set in onForkToChildReturn
        clear_Map( parentState->childInCreation->threads );
        if ( getProcessState_ThreadId( * threadIdObj ) == NULL ) {
            // threadIdObj not fully created
            // verbose( "onForkReturn : threadIdObj not fully created\n" );
            put_Map( parentState->childInCreation->threads, threadIdObj, oldThreadState );
        } else {
            // threadIdObj fully created
            // verbose( "onForkReturn : threadIdObj fully created\n" );
            put_Map( parentState->childInCreation->threads, threadIdObj, create_DefaultThreadState( * threadIdObj ) );
        }
        registerProcessState( fork_spec, parentState->childInCreation );
        // for daemon remove parent info
        if ( equals( name, create_String( "daemon" ) ) ) {
            SystemState * systemState = getSystemState( context.system );
            ProcessId processId = create_ProcessId( context.system, context.process );
            ProcessId specialSystemParent = getSpecialSystemParent( context.system );
            int i;
            remove_Map( systemState->processes, create_ProcessIdObj( processId ) );
            for ( i = 0; i < size_Map( systemState->processes ); i++ ) {
                ProcessIdObj * key = key_Map( systemState->processes, i );
                ProcessState * processState = get_Map( systemState->processes, key );
                if ( processState->meta.parent.process == context.process ) {
                    processState->meta.parent = specialSystemParent;
                }
            }
        }
    }
    parentState->childInCreation = NULL;
}

void onForkToChildReturn( CallContext context, PThreadT childThread )
{
    ProcessState * parentState;
    ProcessState * childState;
    ThreadIdObj * threadIdObj;
    ThreadState * oldThreadState;
    endCommand( context, "fork" );
    parentState = getProcessState_CallContext( context );
    if ( parentState->childInCreation != NULL ) {
        // onForkToChildReturn before onForkReturn
        childState = parentState->childInCreation;
    } else {
        // onForkToChildReturn after onForkReturn
        Set /* ProcessState */ * children = getChildren_CallContext( context );
        childState = get_Set( children, 0 );
    }
    threadIdObj = key_Map( childState->threads, 0 );
    oldThreadState = get_Map( childState->threads, threadIdObj );
    threadIdObj->thread = childThread; // threadIdObj->process will be or was set in onForkReturn
    clear_Map( childState->threads );
    if ( getProcessState_ThreadId( * threadIdObj ) == NULL ) {
        // threadIdObj not fully created
        // verbose( "onForkToChildReturn : threadIdObj not fully created\n" );
        put_Map( childState->threads, threadIdObj, oldThreadState );
    } else {
        // threadIdObj fully created
        // verbose( "onForkToChildReturn : threadIdObj fully created\n" );
        put_Map( childState->threads, threadIdObj, create_DefaultThreadState( * threadIdObj ) );
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    daemon -- run in the background

SYNOPSIS

    #include <unistd.h>
    int daemon(int nochdir, int noclose);

DESCRIPTION

    The daemon() function shall create a new process, detached from the
    controlling terminal. If successful, the calling process shall exit and the
    new process shall continue to execute the application in the background. If
    nochdir evaluates to true, the current directory shall not be changed.
    Otherwise, daemon() shall change the current working directory to the root
    (`/'). If noclose evaluates to true the standard input, standard output, and
    standard error file descriptors shall not be altered. Otherwise, daemon()
    shall close the standard input, standard output and standard error file
    descriptors and reopen them attached to /dev/null.

RETURN VALUE

    On error, -1 is returned, and the global variable errno is set to any of the
    errors specified for the library functions fork() and setsid().
*/
specification
void daemon_spec( CallContext context, IntT nochdir, IntT noclose )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_NoChdir
    {
        if ( nochdir == 0 )
        {
            return { Zero, "nochdir is equal to zero" };
        }
        else
        {
            return { NotZero, "nochdir is not equal to zero" };
        }
    }
    coverage C_NoClose
    {
        if ( noclose == 0 )
        {
            return { Zero, "noclose is equal to zero" };
        }
        else
        {
            return { NotZero, "noclose is not equal to zero" };
        }
    }
    post
    {
        return true;
    }
}

/*
 * common for exec group
 */
specification typedef struct ExecCall ExecCall = {};

ExecCall * create_ExecCall( String * name,
                            CallContext context, CString * path, List /* CString */ * argv, List /* CString */ * envp
                          )
{
    return create( & type_ExecCall, name, context, path, argv, envp );
}

void onExec( String * name, CallContext context, CString * path, List /* CString */ * argv, List /* CString */ * envp )
{
    ProcessState * process_state = getProcessState_CallContext( context );
    process_state->inExecCall = true;

    startCommand( context, "exec", create_ExecCall( name, context, path, argv, envp ) );
}

specification typedef struct ExecReturnType ExecReturnType = {};

ExecReturnType * create_ExecReturnType(
    CallContext          context,
    IntT                 returned_value,
    CString            * path,
    List /* CString */ * argv,
    List /* CString */ * envp,
    ErrorCode          * error_code
)
{
    return create(&type_ExecReturnType,
        context,
        returned_value,
        path,
        argv,
        envp,
        error_code);

}

CallContext findCorrespondContext( CallContext context, Map * systems ) {
    int i, j;
    for ( i = 0; i < size_Map( systems ); i++ ) {
        Long * key = key_Map( systems, i );
        if ( * key == context.system ) {
            SystemState * systemState = get_Map( systems, key );
            for ( j = 0; j < size_Map( systemState->processes ); j++ ) {
                ProcessIdObj * key = key_Map( systemState->processes, j );
                if ( key->process == context.process ) {
                    ProcessState * processState = get_Map( systemState->processes, key );
                    if ( size_Map( processState->threads ) != 1 ) {
                        return WrongThreadId;
                    } else {
                        ThreadIdObj * key = key_Map( processState->threads, 0 );
                        context.thread = key->thread;
                        return context;
                    }
                }
            } // for j
        }
    } // for i
    return WrongThreadId;
}

reaction ExecReturnType * execOldProcess_return( void )
{
    post
    {
        CallContext context   = execOldProcess_return->context       ;
        IntT        exec_spec = execOldProcess_return->returned_value;
        CString   * post_path = execOldProcess_return->path          ;
        List      * post_argv = execOldProcess_return->argv          ;
        List      * post_envp = execOldProcess_return->envp          ;
        ErrorCode * errno     = execOldProcess_return->error_code    ;

        ExecCall * blocked_call = showCommand( @getBlockedCalls(), context, "exec" );
        String  * name     = blocked_call->name;
        CString * pre_path = blocked_call->path;
        List    * pre_argv = blocked_call->argv;
        List    * pre_envp = blocked_call->envp;

        bool checkResult, checkResult1, checkResult2;
        ErrorCode * tempErrno = requestErrorCode();

        ERROR_BEGIN( POSIX_EXECL, "execl.27.01", exec_spec == -1, * errno )

            if      ( equals( create_String( "execl"  ), name ) ) { extraCodes = HAS_EXTRA_ERROR_CODES( POSIX_EXECL  ); }
            else if ( equals( create_String( "execv"  ), name ) ) { extraCodes = HAS_EXTRA_ERROR_CODES( POSIX_EXECV  ); }
            else if ( equals( create_String( "execle" ), name ) ) { extraCodes = HAS_EXTRA_ERROR_CODES( POSIX_EXECLE ); }
            else if ( equals( create_String( "execve" ), name ) ) { extraCodes = HAS_EXTRA_ERROR_CODES( POSIX_EXECVE ); }
            else if ( equals( create_String( "execlp" ), name ) ) { extraCodes = HAS_EXTRA_ERROR_CODES( POSIX_EXECLP ); }
            else if ( equals( create_String( "execvp" ), name ) ) { extraCodes = HAS_EXTRA_ERROR_CODES( POSIX_EXECVP ); }
            else
            {
                REQTRACE( "execOldProcess_return : unknown name" );
                return false;
            }

            /*
             * The exec functions shall fail if:
             *
             * [E2BIG]
             *
             * The number of bytes used by the new process image's argument list and
             * environment list is greater than the system-imposed limit of {ARG_MAX} bytes.
             */
            error_shall4( name, POSIX_EXECL , E2BIG, "execl.27.01" , TODO_ERR( E2BIG ) )
            error_shall4( name, POSIX_EXECV , E2BIG, "execv.27.01" , TODO_ERR( E2BIG ) )
            error_shall4( name, POSIX_EXECLE, E2BIG, "execle.27.01", TODO_ERR( E2BIG ) )
            error_shall4( name, POSIX_EXECVE, E2BIG, "execve.27.01", TODO_ERR( E2BIG ) )
            error_shall4( name, POSIX_EXECLP, E2BIG, "execlp.27.01", TODO_ERR( E2BIG ) )
            error_shall4( name, POSIX_EXECVP, E2BIG, "execvp.27.01", TODO_ERR( E2BIG ) )

            /*
             * The exec functions shall fail if:
             *
             * [EACCES]
             *
             * Search permission is denied for a directory listed in the new process image
             * file's path prefix
             */
            checkResult = false;
            error_shall4( name, POSIX_EXECL , EACCES, "execl.27.02.01" , checkResult )
            error_shall4( name, POSIX_EXECV , EACCES, "execv.27.02.01" , checkResult )
            error_shall4( name, POSIX_EXECLE, EACCES, "execle.27.02.01", checkResult )
            error_shall4( name, POSIX_EXECVE, EACCES, "execve.27.02.01", checkResult )
            error_shall4( name, POSIX_EXECLP, EACCES, "execlp.27.02.01", checkResult )
            error_shall4( name, POSIX_EXECVP, EACCES, "execvp.27.02.01", checkResult )

            /*
             * The exec functions shall fail if:
             *
             * [EACCES]
             *
             * the new process image file denies execution permission
             */
            checkResult = false;
            error_shall4( name, POSIX_EXECL , EACCES, "execl.27.02.02" , checkResult )
            error_shall4( name, POSIX_EXECV , EACCES, "execv.27.02.02" , checkResult )
            error_shall4( name, POSIX_EXECLE, EACCES, "execle.27.02.02", checkResult )
            error_shall4( name, POSIX_EXECVE, EACCES, "execve.27.02.02", checkResult )
            error_shall4( name, POSIX_EXECLP, EACCES, "execlp.27.02.02", checkResult )
            error_shall4( name, POSIX_EXECVP, EACCES, "execvp.27.02.02", checkResult )

            /*
             * The exec functions shall fail if:
             *
             * [EACCES]
             *
             * the new process image file is not a regular file and the implementation does
             * not support execution of files of its type.
             */
            error_shall4( name, POSIX_EXECL , EACCES, "execl.27.02.03" , TODO_ERR( EACCES ) )
            error_shall4( name, POSIX_EXECV , EACCES, "execv.27.02.03" , TODO_ERR( EACCES ) )
            error_shall4( name, POSIX_EXECLE, EACCES, "execle.27.02.03", TODO_ERR( EACCES ) )
            error_shall4( name, POSIX_EXECVE, EACCES, "execve.27.02.03", TODO_ERR( EACCES ) )
            error_shall4( name, POSIX_EXECLP, EACCES, "execlp.27.02.03", TODO_ERR( EACCES ) )
            error_shall4( name, POSIX_EXECVP, EACCES, "execvp.27.02.03", TODO_ERR( EACCES ) )

            /*
             * The exec functions shall fail if:
             *
             * [EINVAL]
             *
             * The new process image file has the appropriate permission and has a recognized
             * executable binary format, but the system does not support execution of a file
             * with this format.
             */
            error_shall4( name, POSIX_EXECL , EINVAL, "execl.27.03" , TODO_ERR( EINVAL ) )
            error_shall4( name, POSIX_EXECV , EINVAL, "execv.27.03" , TODO_ERR( EINVAL ) )
            error_shall4( name, POSIX_EXECLE, EINVAL, "execle.27.03", TODO_ERR( EINVAL ) )
            error_shall4( name, POSIX_EXECVE, EINVAL, "execve.27.03", TODO_ERR( EINVAL ) )
            error_shall4( name, POSIX_EXECLP, EINVAL, "execlp.27.03", TODO_ERR( EINVAL ) )
            error_shall4( name, POSIX_EXECVP, EINVAL, "execvp.27.03", TODO_ERR( EINVAL ) )

            /*
             * The exec functions shall fail if:
             *
             * [ELOOP]
             *
             * A loop exists in symbolic links encountered during resolution of the path or
             * file argument.
             */
            checkResult = false;
            error_shall4( name, POSIX_EXECL , ELOOP, "execl.27.04" , checkResult )
            error_shall4( name, POSIX_EXECV , ELOOP, "execv.27.04" , checkResult )
            error_shall4( name, POSIX_EXECLE, ELOOP, "execle.27.04", checkResult )
            error_shall4( name, POSIX_EXECVE, ELOOP, "execve.27.04", checkResult )
            error_shall4( name, POSIX_EXECLP, ELOOP, "execlp.27.04", checkResult )
            error_shall4( name, POSIX_EXECVP, ELOOP, "execvp.27.04", checkResult )

            /*
             * The exec functions shall fail if:
             *
             * [ENAMETOOLONG]
             *
             * The length of the path or file arguments exceeds {PATH_MAX} or a pathname
             * component is longer than {NAME_MAX}.
             */
            checkResult = false;
            error_shall4( name, POSIX_EXECL , ENAMETOOLONG, "execl.27.05" , checkResult )
            error_shall4( name, POSIX_EXECV , ENAMETOOLONG, "execv.27.05" , checkResult )
            error_shall4( name, POSIX_EXECLE, ENAMETOOLONG, "execle.27.05", checkResult )
            error_shall4( name, POSIX_EXECVE, ENAMETOOLONG, "execve.27.05", checkResult )
            error_shall4( name, POSIX_EXECLP, ENAMETOOLONG, "execlp.27.05", checkResult )
            error_shall4( name, POSIX_EXECVP, ENAMETOOLONG, "execvp.27.05", checkResult )

            /*
             * The exec functions shall fail if:
             *
             * [ENOENT]
             *
             * A component of path or file does not name an existing file or path or file is
             * an empty string.
             */
            checkResult1 = false;
            checkResult2 = ( length_CString( pre_path ) == 0 );
            error_shall4( name, POSIX_EXECL , ENOENT, "execl.27.06" , checkResult1 || checkResult2 )
            error_shall4( name, POSIX_EXECV , ENOENT, "execv.27.06" , checkResult1 || checkResult2 )
            error_shall4( name, POSIX_EXECLE, ENOENT, "execle.27.06", checkResult1 || checkResult2 )
            error_shall4( name, POSIX_EXECVE, ENOENT, "execve.27.06", checkResult1 || checkResult2 )
            error_shall4( name, POSIX_EXECLP, ENOENT, "execlp.27.06", checkResult1 || checkResult2 )
            error_shall4( name, POSIX_EXECVP, ENOENT, "execvp.27.06", checkResult1 || checkResult2 )

            /*
             * The exec functions shall fail if:
             *
             * [ENOTDIR]
             *
             * A component of the new process image file's path prefix is not a directory.
             */
            checkResult = false;
            error_shall4( name, POSIX_EXECL , ENOTDIR, "execl.27.07" , checkResult )
            error_shall4( name, POSIX_EXECV , ENOTDIR, "execv.27.07" , checkResult )
            error_shall4( name, POSIX_EXECLE, ENOTDIR, "execle.27.07", checkResult )
            error_shall4( name, POSIX_EXECVE, ENOTDIR, "execve.27.07", checkResult )
            error_shall4( name, POSIX_EXECLP, ENOTDIR, "execlp.27.07", checkResult )
            error_shall4( name, POSIX_EXECVP, ENOTDIR, "execvp.27.07", checkResult )

            /*
             * The exec functions, except for execlp() and execvp(), shall fail if:
             *
             * [ENOEXEC]
             *
             * The new process image file has the appropriate access permission but has an
             * unrecognized format.
             */
            error_shall4( name, POSIX_EXECL , ENOEXEC, "execl.28" , TODO_ERR( ENOEXEC ) )
            error_shall4( name, POSIX_EXECV , ENOEXEC, "execv.28" , TODO_ERR( ENOEXEC ) )
            error_shall4( name, POSIX_EXECLE, ENOEXEC, "execle.28", TODO_ERR( ENOEXEC ) )
            error_shall4( name, POSIX_EXECVE, ENOEXEC, "execve.28", TODO_ERR( ENOEXEC ) )

            /*
             * The exec functions may fail if:
             *
             * [ELOOP]
             *
             * More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
             * the path or file argument.
             */
            checkResult = false;
            error_may4( name, POSIX_EXECL , ELOOP, "execl.29.01" , checkResult )
            error_may4( name, POSIX_EXECV , ELOOP, "execv.29.01" , checkResult )
            error_may4( name, POSIX_EXECLE, ELOOP, "execle.29.01", checkResult )
            error_may4( name, POSIX_EXECVE, ELOOP, "execve.29.01", checkResult )
            error_may4( name, POSIX_EXECLP, ELOOP, "execlp.29.01", checkResult )
            error_may4( name, POSIX_EXECVP, ELOOP, "execvp.29.01", checkResult )

            /*
             * The exec functions may fail if:
             *
             * [ENAMETOOLONG]
             *
             * As a result of encountering a symbolic link in resolution of the path argument,
             * the length of the substituted pathname string exceeded {PATH_MAX}.
             */
            checkResult = false;
            error_may4( name, POSIX_EXECL , ENAMETOOLONG, "execl.29.02" , checkResult )
            error_may4( name, POSIX_EXECV , ENAMETOOLONG, "execv.29.02" , checkResult )
            error_may4( name, POSIX_EXECLE, ENAMETOOLONG, "execle.29.02", checkResult )
            error_may4( name, POSIX_EXECVE, ENAMETOOLONG, "execve.29.02", checkResult )
            error_may4( name, POSIX_EXECLP, ENAMETOOLONG, "execlp.29.02", checkResult )
            error_may4( name, POSIX_EXECVP, ENAMETOOLONG, "execvp.29.02", checkResult )

            /*
             * The exec functions may fail if:
             *
             * [ENOMEM]
             *
             * The new process image requires more memory than is allowed by the hardware or
             * system-imposed memory management constraints.
             */
            error_may4( name, POSIX_EXECL , ENOMEM, "execl.29.03" , TODO_ERR( ENOMEM ) )
            error_may4( name, POSIX_EXECV , ENOMEM, "execv.29.03" , TODO_ERR( ENOMEM ) )
            error_may4( name, POSIX_EXECLE, ENOMEM, "execle.29.03", TODO_ERR( ENOMEM ) )
            error_may4( name, POSIX_EXECVE, ENOMEM, "execve.29.03", TODO_ERR( ENOMEM ) )
            error_may4( name, POSIX_EXECLP, ENOMEM, "execlp.29.03", TODO_ERR( ENOMEM ) )
            error_may4( name, POSIX_EXECVP, ENOMEM, "execvp.29.03", TODO_ERR( ENOMEM ) )

            /*
             * The exec functions may fail if:
             *
             * [ETXTBSY]
             *
             * The new process image file is a pure procedure (shared text) file that is
             * currently open for writing by some process.
             */
            error_may4( name, POSIX_EXECL , ETXTBSY, "execl.29.04" , TODO_ERR( ETXTBSY ) )
            error_may4( name, POSIX_EXECV , ETXTBSY, "execv.29.04" , TODO_ERR( ETXTBSY ) )
            error_may4( name, POSIX_EXECLE, ETXTBSY, "execle.29.04", TODO_ERR( ETXTBSY ) )
            error_may4( name, POSIX_EXECVE, ETXTBSY, "execve.29.04", TODO_ERR( ETXTBSY ) )
            error_may4( name, POSIX_EXECLP, ETXTBSY, "execlp.29.04", TODO_ERR( ETXTBSY ) )
            error_may4( name, POSIX_EXECVP, ETXTBSY, "execvp.29.04", TODO_ERR( ETXTBSY ) )

        ERROR_END()

        /* [reads path */
        REQ( "", "reads path", equals( pre_path, post_path ) );

        /*
         * If one of the exec functions returns to the calling process image, an error has
         * occurred; the return value shall be -1, and errno shall be set to indicate the
         * error.
         */
        checkResult = ( exec_spec == -1 );
        req4( name, "execl.26" , "Return shall value be -1", checkResult );
        req4( name, "execle.26", "Return shall value be -1", checkResult );
        req4( name, "execlp.26", "Return shall value be -1", checkResult );
        req4( name, "execv.26" , "Return shall value be -1", checkResult );
        req4( name, "execve.26", "Return shall value be -1", checkResult );
        req4( name, "execvp.26", "Return shall value be -1", checkResult );

        /*
         * The argv[] and envp[] arrays of pointers and the strings to which those arrays
         * point shall not be modified by a call to one of the exec functions, except as a
         * consequence of replacing the process image.
         */
        checkResult1 = equals( pre_argv, post_argv );
        checkResult2 = equals( pre_envp, post_envp );
        req4( name, "execl.46" , "The argv[] and envp[] shall not be modified", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execle.46", "The argv[] and envp[] shall not be modified", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execlp.46", "The argv[] and envp[] shall not be modified", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execv.46" , "The argv[] and envp[] shall not be modified", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execve.46", "The argv[] and envp[] shall not be modified", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execvp.46", "The argv[] and envp[] shall not be modified", T( checkResult1 ) && T( checkResult2 ) );

        return true;
    }
}

reaction ExecReturnType * execNewProcess_return( void )
{
    post
    {
        CallContext context  = findCorrespondContext( execNewProcess_return->context, @systems );
        CString   * new_path =                        execNewProcess_return->path               ;
        List      * new_argv =                        execNewProcess_return->argv               ;
        List      * new_envp =                        execNewProcess_return->envp               ;

        ExecCall * blocked_call = showCommand( @getBlockedCalls(), context, "exec" );
        String  * name     = blocked_call->name;
        CString * pre_path = blocked_call->path;
        List    * pre_argv = blocked_call->argv;
        List    * pre_envp = blocked_call->envp;

        ThreadId oldThreadId = context;
        ProcessId oldProcessId = create_ProcessId( oldThreadId.system, oldThreadId.process );
        SystemState * oldSystemState = get_Map( @systems, create_Long( oldThreadId.system ) );
        ProcessState * oldProcessState = get_Map( oldSystemState->processes, create_ProcessIdObj( oldProcessId ) );

        ThreadId newThreadId = execNewProcess_return->context;
        ProcessState * newProcessState = getProcessState_CallContext( newThreadId );
        ThreadState * newThreadState = getThreadState_CallContext( newThreadId );

        bool checkResult;
        bool checkResult1, checkResult2;

        /*
         * [
         * The arguments represented by arg0,... are pointers to null-terminated character strings.
         * The argument argv is an array of character pointers to null-terminated strings.
         * ]
         * These strings shall constitute the argument list available to the new process
         * image.
         */
        checkResult = equals( pre_argv, new_argv );
        req4( name, "execl.01" , "Check argument list available to the new process image", checkResult );
        req4( name, "execle.01", "Check argument list available to the new process image", checkResult );
        req4( name, "execlp.01", "Check argument list available to the new process image", checkResult );
        req4( name, "execv.01" , "Check argument list available to the new process image", checkResult );
        req4( name, "execve.01", "Check argument list available to the new process image", checkResult );
        req4( name, "execvp.01", "Check argument list available to the new process image", checkResult );

        /*
         * File descriptors open in the calling process image shall remain open in the new
         * process image, except for those whose close-on- exec flag FD_CLOEXEC is set.
         * For those file descriptors that remain open, all attributes of the open file
         * description remain unchanged. For any file descriptor that is closed for this
         * reason, file locks are removed as a result of the close as described in close().
         * Locks that are not removed by closing of file descriptors remain unchanged.
         */
        req4( name, "execl.02" , "", TODO_REQ() );
        req4( name, "execle.02", "", TODO_REQ() );
        req4( name, "execlp.02", "", TODO_REQ() );
        req4( name, "execv.02" , "", TODO_REQ() );
        req4( name, "execve.02", "", TODO_REQ() );
        req4( name, "execvp.02", "", TODO_REQ() );

        /*
         * Directory streams open in the calling process image shall be closed in the new
         * process image.
         */
        checkResult = isEmpty_Set( newProcessState->dir_descriptors );
        req4( name, "execl.03" , "Directory streams shall be closed in the new process image", checkResult );
        req4( name, "execle.03", "Directory streams shall be closed in the new process image", checkResult );
        req4( name, "execlp.03", "Directory streams shall be closed in the new process image", checkResult );
        req4( name, "execv.03" , "Directory streams shall be closed in the new process image", checkResult );
        req4( name, "execve.03", "Directory streams shall be closed in the new process image", checkResult );
        req4( name, "execvp.03", "Directory streams shall be closed in the new process image", checkResult );

        /*
         * The state of the floating-point environment in the new process image [THR]  or
         * in the initial thread of the new process image  shall be set to the default.
         */
        req4( name, "execl.04" , "", TODO_REQ() );
        req4( name, "execle.04", "", TODO_REQ() );
        req4( name, "execlp.04", "", TODO_REQ() );
        req4( name, "execv.04" , "", TODO_REQ() );
        req4( name, "execve.04", "", TODO_REQ() );
        req4( name, "execvp.04", "", TODO_REQ() );

        /*
         * Signals set to the default action (SIG_DFL) in the calling process image shall
         * be set to the default action in the new process image. Except for SIGCHLD,
         * signals set to be ignored (SIG_IGN) by the calling process image shall be set
         * to be ignored by the new process image. Signals set to be caught by the calling
         * process image shall be set to the default action in the new process image (see &
         * lt;signal.h>). If the SIGCHLD signal is set to be ignored by the calling
         * process image, it is unspecified whether the SIGCHLD signal is set to be
         * ignored or to the default action in the new process image. [XSI]  After a
         * successful call to any of the exec functions, alternate signal stacks are not
         * preserved and the SA_ONSTACK flag shall be cleared for all signals.
         */
        req4( name, "execl.05" , "", TODO_REQ() );
        req4( name, "execle.05", "", TODO_REQ() );
        req4( name, "execlp.05", "", TODO_REQ() );
        req4( name, "execv.05" , "", TODO_REQ() );
        req4( name, "execve.05", "", TODO_REQ() );
        req4( name, "execvp.02", "", TODO_REQ() );

        /*
         * After a successful call to any of the exec functions, any functions previously
         * registered by atexit() [THR]  or pthread_atfork()  are no longer registered.
         */
        req4( name, "execl.06" , "", TODO_REQ() );
        req4( name, "execle.06", "", TODO_REQ() );
        req4( name, "execlp.06", "", TODO_REQ() );
        req4( name, "execv.06" , "", TODO_REQ() );
        req4( name, "execve.06", "", TODO_REQ() );
        req4( name, "execvp.06", "", TODO_REQ() );

        /*
         * [XSI] If the ST_NOSUID bit is set for the file system containing the new
         * process image file, then the effective user ID, effective group ID, saved set-
         * user-ID, and saved set-group-ID are unchanged in the new process image.
         * Otherwise, if the set-user-ID mode bit of the new process image file is set,
         * the effective user ID of the new process image shall be set to the user ID of
         * the new process image file. Similarly, if the set-group-ID mode bit of the new
         * process image file is set, the effective group ID of the new process image
         * shall be set to the group ID of the new process image file. The real user ID,
         * real group ID, and supplementary group IDs of the new process image shall
         * remain the same as those of the calling process image. The effective user ID
         * and effective group ID of the new process image shall be saved (as the saved
         * set-user-ID and the saved set-group-ID) for use by setuid().
         */
        req4( name, "execl.07" , "", TODO_REQ() );
        req4( name, "execle.07", "", TODO_REQ() );
        req4( name, "execlp.07", "", TODO_REQ() );
        req4( name, "execv.07" , "", TODO_REQ() );
        req4( name, "execve.07", "", TODO_REQ() );
        req4( name, "execvp.07", "", TODO_REQ() );

        /*
         * [XSI] Any shared memory segments attached to the calling process image shall
         * not be attached to the new process image.
         */
        req4( name, "execl.08" , "", TODO_REQ() );
        req4( name, "execle.08", "", TODO_REQ() );
        req4( name, "execlp.08", "", TODO_REQ() );
        req4( name, "execv.08" , "", TODO_REQ() );
        req4( name, "execve.08", "", TODO_REQ() );
        req4( name, "execvp.08", "", TODO_REQ() );

        /*
         * [SEM] Any named semaphores open in the calling process shall be closed as if
         * by appropriate calls to sem_close().
         */
        req4( name, "execl.09" , "", TODO_REQ() );
        req4( name, "execle.09", "", TODO_REQ() );
        req4( name, "execlp.09", "", TODO_REQ() );
        req4( name, "execv.09" , "", TODO_REQ() );
        req4( name, "execve.09", "", TODO_REQ() );
        req4( name, "execvp.09", "", TODO_REQ() );

        /*
         * [TYM] Any blocks of typed memory that were mapped in the calling process are
         * unmapped, as if munmap() was implicitly called to unmap them.
         */
        req4( name, "execl.10" , "", TODO_REQ() );
        req4( name, "execle.10", "", TODO_REQ() );
        req4( name, "execlp.10", "", TODO_REQ() );
        req4( name, "execv.10" , "", TODO_REQ() );
        req4( name, "execve.10", "", TODO_REQ() );
        req4( name, "execvp.10", "", TODO_REQ() );

        /*
         * [ML] Memory locks established by the calling process via calls to mlockall()
         * or mlock() shall be removed. If locked pages in the address space of the
         * calling process are also mapped into the address spaces of other processes and
         * are locked by those processes, the locks established by the other processes
         * shall be unaffected by the call by this process to the exec function. If the
         * exec function fails, the effect on memory locks is unspecified.
         */
        req4( name, "execl.11" , "", TODO_REQ() );
        req4( name, "execle.11", "", TODO_REQ() );
        req4( name, "execlp.11", "", TODO_REQ() );
        req4( name, "execv.11" , "", TODO_REQ() );
        req4( name, "execve.11", "", TODO_REQ() );
        req4( name, "execvp.11", "", TODO_REQ() );

        /*
         * [MF|SHM] Memory mappings created in the process are unmapped before the
         * address space is rebuilt for the new process image.
         */
        req4( name, "execl.12" , "", TODO_REQ() );
        req4( name, "execle.12", "", TODO_REQ() );
        req4( name, "execlp.12", "", TODO_REQ() );
        req4( name, "execv.12" , "", TODO_REQ() );
        req4( name, "execve.12", "", TODO_REQ() );
        req4( name, "execvp.12", "", TODO_REQ() );

        /*
         * [PS] When the calling process image uses the SCHED_FIFO, SCHED_RR, or
         * SCHED_SPORADIC scheduling policies, the process policy and scheduling parameter
         * settings shall not be changed by a call to an exec function. [TPS]  The
         * initial thread in the new process image shall inherit the process scheduling
         * policy and parameters. It shall have the default system contention scope, but
         * shall inherit its allocation domain from the calling process image.
         */
        req4( name, "execl.13" , "", TODO_REQ() );
        req4( name, "execle.13", "", TODO_REQ() );
        req4( name, "execlp.13", "", TODO_REQ() );
        req4( name, "execv.13" , "", TODO_REQ() );
        req4( name, "execve.13", "", TODO_REQ() );
        req4( name, "execvp.13", "", TODO_REQ() );

        /*
         * [TMR] Per-process timers created by the calling process shall be deleted
         * before replacing the current process image with the new process image.
         */
        req4( name, "execl.14" , "", TODO_REQ() );
        req4( name, "execle.14", "", TODO_REQ() );
        req4( name, "execlp.14", "", TODO_REQ() );
        req4( name, "execv.14" , "", TODO_REQ() );
        req4( name, "execve.14", "", TODO_REQ() );
        req4( name, "execvp.14", "", TODO_REQ() );

        /*
         * [MSG] All open message queue descriptors in the calling process shall be
         * closed, as described in mq_close().
         */
        req4( name, "execl.15" , "", TODO_REQ() );
        req4( name, "execle.15", "", TODO_REQ() );
        req4( name, "execlp.15", "", TODO_REQ() );
        req4( name, "execv.15" , "", TODO_REQ() );
        req4( name, "execve.15", "", TODO_REQ() );
        req4( name, "execvp.15", "", TODO_REQ() );

        /*
         * [CPT] The new process image shall inherit the CPU-time clock of the calling
         * process image. This inheritance means that the process CPU-time clock of the
         * process being exec-ed shall not be reinitialized or altered as a result of the
         * exec function other than to reflect the time spent by the process executing the
         * exec function itself.
         */
        req4( name, "execl.16" , "", TODO_REQ() );
        req4( name, "execle.16", "", TODO_REQ() );
        req4( name, "execlp.16", "", TODO_REQ() );
        req4( name, "execv.16" , "", TODO_REQ() );
        req4( name, "execve.16", "", TODO_REQ() );
        req4( name, "execvp.16", "", TODO_REQ() );

        /*
         * [TCT] The initial value of the CPU-time clock of the initial thread of the new
         * process image shall be set to zero.
         */
        req4( name, "execl.17" , "", TODO_REQ() );
        req4( name, "execle.17", "", TODO_REQ() );
        req4( name, "execlp.17", "", TODO_REQ() );
        req4( name, "execv.17" , "", TODO_REQ() );
        req4( name, "execve.17", "", TODO_REQ() );
        req4( name, "execvp.17", "", TODO_REQ() );

        /*
         * [TRC] If the calling process is being traced, the new process image shall
         * continue to be traced into the same trace stream as the original process image,
         * but the new process image shall not inherit the mapping of trace event names to
         * trace event type identifiers that was defined by calls to the
         * posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions in
         * the calling process image.
         *
         * If the calling process is a trace controller process, any trace streams that
         * were created by the calling process shall be shut down as described in the
         * posix_trace_shutdown() function.
         */
        req4( name, "execl.18" , "", TODO_REQ() );
        req4( name, "execle.18", "", TODO_REQ() );
        req4( name, "execlp.18", "", TODO_REQ() );
        req4( name, "execv.18" , "", TODO_REQ() );
        req4( name, "execve.18", "", TODO_REQ() );
        req4( name, "execvp.18", "", TODO_REQ() );

        /*
         * The initial thread in the new process image shall have its cancellation type
         * set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
         * PTHREAD_CANCEL_ENABLED.
         */
        req4( name, "execl.19" , "", TODO_REQ() );
        req4( name, "execle.19", "", TODO_REQ() );
        req4( name, "execlp.19", "", TODO_REQ() );
        req4( name, "execv.19" , "", TODO_REQ() );
        req4( name, "execve.19", "", TODO_REQ() );
        req4( name, "execvp.19", "", TODO_REQ() );

        /*
         * The initial thread in the new process image shall have all thread-specific data
         * values set to NULL and all thread-specific data keys shall be removed by the
         * call to exec without running destructors.
         */
        checkResult1 = ( size_Map( newProcessState->threads ) == 1 )                     ;
        checkResult2 = equals( newThreadState, create_DefaultThreadState( newThreadId ) );
        req4( name, "execl.20" , "Check thread-specific data", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execle.20", "Check thread-specific data", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execlp.20", "Check thread-specific data", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execv.20" , "Check thread-specific data", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execve.20", "Check thread-specific data", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "execvp.20", "Check thread-specific data", T( checkResult1 ) && T( checkResult2 ) );

        /*
         * The initial thread in the new process image shall be joinable, as if created
         * with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.
         */
        checkResult = ( newThreadState->attr->detachstate == SUT_PTHREAD_CREATE_JOINABLE );
        req4( name, "execl.21" , "The initial thread in the new process image shall be joinable", checkResult );
        req4( name, "execle.21", "The initial thread in the new process image shall be joinable", checkResult );
        req4( name, "execlp.21", "The initial thread in the new process image shall be joinable", checkResult );
        req4( name, "execv.21" , "The initial thread in the new process image shall be joinable", checkResult );
        req4( name, "execve.21", "The initial thread in the new process image shall be joinable", checkResult );
        req4( name, "execvp.21", "The initial thread in the new process image shall be joinable", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * [XSI] Nice value (see nice())
         */
        req4( name, "execl.22.01" , "", TODO_REQ() );
        req4( name, "execle.22.01", "", TODO_REQ() );
        req4( name, "execlp.22.01", "", TODO_REQ() );
        req4( name, "execv.22.01" , "", TODO_REQ() );
        req4( name, "execve.22.01", "", TODO_REQ() );
        req4( name, "execvp.22.01", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * [XSI] semadj values (see semop())
         */
        req4( name, "execl.22.02" , "", TODO_REQ() );
        req4( name, "execle.22.02", "", TODO_REQ() );
        req4( name, "execlp.22.02", "", TODO_REQ() );
        req4( name, "execv.22.02" , "", TODO_REQ() );
        req4( name, "execve.22.02", "", TODO_REQ() );
        req4( name, "execvp.22.02", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Process ID
         */
        checkResult = ( oldProcessState->processid.system  == newProcessState->processid.system  &&
                        oldProcessState->processid.process == newProcessState->processid.process
                      );
        req4( name, "execl.22.03" , "The new process shall inherit process ID", checkResult );
        req4( name, "execle.22.03", "The new process shall inherit process ID", checkResult );
        req4( name, "execlp.22.03", "The new process shall inherit process ID", checkResult );
        req4( name, "execv.22.03" , "The new process shall inherit process ID", checkResult );
        req4( name, "execve.22.03", "The new process shall inherit process ID", checkResult );
        req4( name, "execvp.22.03", "The new process shall inherit process ID", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Parent process ID
         */
        checkResult = ( oldProcessState->meta.parent.system  == newProcessState->meta.parent.system  &&
                        oldProcessState->meta.parent.process == newProcessState->meta.parent.process
                      );
        req4( name, "execl.22.04" , "The new process shall inherit parent process ID", checkResult );
        req4( name, "execle.22.04", "The new process shall inherit parent process ID", checkResult );
        req4( name, "execlp.22.04", "The new process shall inherit parent process ID", checkResult );
        req4( name, "execv.22.04" , "The new process shall inherit parent process ID", checkResult );
        req4( name, "execve.22.04", "The new process shall inherit parent process ID", checkResult );
        req4( name, "execvp.22.04", "The new process shall inherit parent process ID", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Process group ID
         */
        checkResult = ( oldProcessState->meta.pgroup.system  == newProcessState->meta.pgroup.system  &&
                        oldProcessState->meta.pgroup.process == newProcessState->meta.pgroup.process
                      );
        req4( name, "execl.22.05" , "The new process shall inherit process group ID", checkResult );
        req4( name, "execle.22.05", "The new process shall inherit process group ID", checkResult );
        req4( name, "execlp.22.05", "The new process shall inherit process group ID", checkResult );
        req4( name, "execv.22.05" , "The new process shall inherit process group ID", checkResult );
        req4( name, "execve.22.05", "The new process shall inherit process group ID", checkResult );
        req4( name, "execvp.22.05", "The new process shall inherit process group ID", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Session membership
         */
        checkResult = ( oldProcessState->meta.session.system  == newProcessState->meta.session.system  &&
                        oldProcessState->meta.session.process == newProcessState->meta.session.process
                      );
        req4( name, "execl.22.06" , "The new process shall inherit session membership", checkResult );
        req4( name, "execle.22.06", "The new process shall inherit session membership", checkResult );
        req4( name, "execlp.22.06", "The new process shall inherit session membership", checkResult );
        req4( name, "execv.22.06" , "The new process shall inherit session membership", checkResult );
        req4( name, "execve.22.06", "The new process shall inherit session membership", checkResult );
        req4( name, "execvp.22.06", "The new process shall inherit session membership", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Real user ID
         */
        checkResult = ( oldProcessState->meta.real_userid == newProcessState->meta.real_userid );
        req4( name, "execl.22.07" , "The new process shall inherit real user ID", checkResult );
        req4( name, "execle.22.07", "The new process shall inherit real user ID", checkResult );
        req4( name, "execlp.22.07", "The new process shall inherit real user ID", checkResult );
        req4( name, "execv.22.07" , "The new process shall inherit real user ID", checkResult );
        req4( name, "execve.22.07", "The new process shall inherit real user ID", checkResult );
        req4( name, "execvp.22.07", "The new process shall inherit real user ID", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Real group ID
         */
        checkResult = ( oldProcessState->meta.real_groupid == newProcessState->meta.real_groupid );
        req4( name, "execl.22.08" , "The new process shall inherit real group ID", checkResult );
        req4( name, "execle.22.08", "The new process shall inherit real group ID", checkResult );
        req4( name, "execlp.22.08", "The new process shall inherit real group ID", checkResult );
        req4( name, "execv.22.08" , "The new process shall inherit real group ID", checkResult );
        req4( name, "execve.22.08", "The new process shall inherit real group ID", checkResult );
        req4( name, "execvp.22.08", "The new process shall inherit real group ID", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Supplementary group IDs
         */
        checkResult = equals( oldProcessState->meta.groups, newProcessState->meta.groups );
        req4( name, "execl.22.09" , "The new process shall inherit supplementary group IDs", checkResult );
        req4( name, "execle.22.09", "The new process shall inherit supplementary group IDs", checkResult );
        req4( name, "execlp.22.09", "The new process shall inherit supplementary group IDs", checkResult );
        req4( name, "execv.22.09" , "The new process shall inherit supplementary group IDs", checkResult );
        req4( name, "execve.22.09", "The new process shall inherit supplementary group IDs", checkResult );
        req4( name, "execvp.22.09", "The new process shall inherit supplementary group IDs", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Time left until an alarm clock signal (see alarm())
         */
        req4( name, "execl.22.10" , "", TODO_REQ() );
        req4( name, "execle.22.10", "", TODO_REQ() );
        req4( name, "execlp.22.10", "", TODO_REQ() );
        req4( name, "execv.22.10" , "", TODO_REQ() );
        req4( name, "execve.22.10", "", TODO_REQ() );
        req4( name, "execvp.22.10", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Current working directory
         */
        checkResult = ( oldProcessState->meta.workdir.system == newProcessState->meta.workdir.system &&
                        oldProcessState->meta.workdir.file   == newProcessState->meta.workdir.file
                      );
        req4( name, "execl.22.11" , "The new process shall inherit current working directory", checkResult );
        req4( name, "execle.22.11", "The new process shall inherit current working directory", checkResult );
        req4( name, "execlp.22.11", "The new process shall inherit current working directory", checkResult );
        req4( name, "execv.22.11" , "The new process shall inherit current working directory", checkResult );
        req4( name, "execve.22.11", "The new process shall inherit current working directory", checkResult );
        req4( name, "execvp.22.11", "The new process shall inherit current working directory", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Root directory
         */
        checkResult = ( oldProcessState->meta.root.system == newProcessState->meta.root.system &&
                        oldProcessState->meta.root.file   == newProcessState->meta.root.file
                      );
        req4( name, "execl.22.12" , "The new process shall inherit root directory", checkResult );
        req4( name, "execle.22.12", "The new process shall inherit root directory", checkResult );
        req4( name, "execlp.22.12", "The new process shall inherit root directory", checkResult );
        req4( name, "execv.22.12" , "The new process shall inherit root directory", checkResult );
        req4( name, "execve.22.12", "The new process shall inherit root directory", checkResult );
        req4( name, "execvp.22.12", "The new process shall inherit root directory", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * File mode creation mask (see umask())
         */
        checkResult = equals( oldProcessState->meta.umask, newProcessState->meta.umask );
        req4( name, "execl.22.13" , "The new process shall inherit file mode creation mask", checkResult );
        req4( name, "execle.22.13", "The new process shall inherit file mode creation mask", checkResult );
        req4( name, "execlp.22.13", "The new process shall inherit file mode creation mask", checkResult );
        req4( name, "execv.22.13" , "The new process shall inherit file mode creation mask", checkResult );
        req4( name, "execve.22.13", "The new process shall inherit file mode creation mask", checkResult );
        req4( name, "execvp.22.13", "The new process shall inherit file mode creation mask", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * [XSI] File size limit (see ulimit())
         */
        req4( name, "execl.22.14" , "", TODO_REQ() );
        req4( name, "execle.22.14", "", TODO_REQ() );
        req4( name, "execlp.22.14", "", TODO_REQ() );
        req4( name, "execv.22.14" , "", TODO_REQ() );
        req4( name, "execve.22.14", "", TODO_REQ() );
        req4( name, "execvp.22.14", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Process signal mask (see sigprocmask())
         */
        req4( name, "execl.22.15" , "", TODO_REQ() );
        req4( name, "execle.22.15", "", TODO_REQ() );
        req4( name, "execlp.22.15", "", TODO_REQ() );
        req4( name, "execv.22.15" , "", TODO_REQ() );
        req4( name, "execve.22.15", "", TODO_REQ() );
        req4( name, "execvp.22.15", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * Pending signal (see sigpending())
         */
        req4( name, "execl.22.16" , "", TODO_REQ() );
        req4( name, "execle.22.16", "", TODO_REQ() );
        req4( name, "execlp.22.16", "", TODO_REQ() );
        req4( name, "execv.22.16" , "", TODO_REQ() );
        req4( name, "execve.22.16", "", TODO_REQ() );
        req4( name, "execvp.22.16", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
         */
        req4( name, "execl.22.17" , "", TODO_REQ() );
        req4( name, "execle.22.17", "", TODO_REQ() );
        req4( name, "execlp.22.17", "", TODO_REQ() );
        req4( name, "execv.22.17" , "", TODO_REQ() );
        req4( name, "execve.22.17", "", TODO_REQ() );
        req4( name, "execvp.22.17", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * [XSI] Resource limits
         */
        req4( name, "execl.22.18" , "", TODO_REQ() );
        req4( name, "execle.22.18", "", TODO_REQ() );
        req4( name, "execlp.22.18", "", TODO_REQ() );
        req4( name, "execv.22.18" , "", TODO_REQ() );
        req4( name, "execve.22.18", "", TODO_REQ() );
        req4( name, "execvp.22.18", "", TODO_REQ() );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * [XSI] Controlling terminal
         */
        checkResult = equals( oldProcessState->meta.cterm, newProcessState->meta.cterm );
        req4( name, "execl.22.19" , "The new process shall inherit controlling terminal", checkResult );
        req4( name, "execle.22.19", "The new process shall inherit controlling terminal", checkResult );
        req4( name, "execlp.22.19", "The new process shall inherit controlling terminal", checkResult );
        req4( name, "execv.22.19" , "The new process shall inherit controlling terminal", checkResult );
        req4( name, "execve.22.19", "The new process shall inherit controlling terminal", checkResult );
        req4( name, "execvp.22.19", "The new process shall inherit controlling terminal", checkResult );

        /*
         * The new process shall inherit at least the following attributes from the
         * calling process image:
         *
         * [XSI] Interval timers
         */
        req4( name, "execl.22.20" , "", TODO_REQ() );
        req4( name, "execle.22.20", "", TODO_REQ() );
        req4( name, "execlp.22.20", "", TODO_REQ() );
        req4( name, "execv.22.20" , "", TODO_REQ() );
        req4( name, "execve.22.20", "", TODO_REQ() );
        req4( name, "execvp.22.20", "", TODO_REQ() );

        /*
         * The initial thread of the new process shall inherit at least the following
         * attributes from the calling thread:
         *
         * Signal mask (see sigprocmask() and pthread_sigmask())
         */
        req4( name, "execl.23.01" , "", TODO_REQ() );
        req4( name, "execle.23.01", "", TODO_REQ() );
        req4( name, "execlp.23.01", "", TODO_REQ() );
        req4( name, "execv.23.01" , "", TODO_REQ() );
        req4( name, "execve.23.01", "", TODO_REQ() );
        req4( name, "execvp.23.01", "", TODO_REQ() );

        /*
         * The initial thread of the new process shall inherit at least the following
         * attributes from the calling thread:
         *
         * Pending signals (see sigpending())
         */
        req4( name, "execl.23.02" , "", TODO_REQ() );
        req4( name, "execle.23.02", "", TODO_REQ() );
        req4( name, "execlp.23.02", "", TODO_REQ() );
        req4( name, "execv.23.02" , "", TODO_REQ() );
        req4( name, "execve.23.02", "", TODO_REQ() );
        req4( name, "execvp.23.02", "", TODO_REQ() );

        /*
         * [THR] A call to any exec function from a process with more than one thread
         * shall result in all threads being terminated and the new executable image being
         * loaded and executed. No destructor functions or cleanup handlers shall be
         * called.
         */
        req4( name, "execl.24" , "", TODO_REQ() );
        req4( name, "execle.24", "", TODO_REQ() );
        req4( name, "execlp.24", "", TODO_REQ() );
        req4( name, "execv.24" , "", TODO_REQ() );
        req4( name, "execve.24", "", TODO_REQ() );
        req4( name, "execvp.24", "", TODO_REQ() );

        /*
         * [XSI] The saved resource limits in the new process image are set to be a copy
         * of the process' corresponding hard and soft limits.
         */
        req4( name, "execl.25" , "", TODO_REQ() );
        req4( name, "execle.25", "", TODO_REQ() );
        req4( name, "execlp.25", "", TODO_REQ() );
        req4( name, "execv.25" , "", TODO_REQ() );
        req4( name, "execve.25", "", TODO_REQ() );
        req4( name, "execvp.25", "", TODO_REQ() );

        /*
         * The argument file is used to construct a pathname that identifies the new
         * process image file.
         */
        if ( indexOfChar_CString( pre_path, '/' ) != -1 )
        {
            /*
             * If the file argument contains a slash character, the file argument shall be
             * used as the pathname for this file.
             */
            checkResult = ( new_path == NULL ? true : equals( new_path, pre_path ) );
                                                   // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ may be not enough
            req4( name, "execlp.30.01", "The file argument shall be used as the pathname", checkResult );
            req4( name, "execvp.30.01", "The file argument shall be used as the pathname", checkResult );
        }
        else
        {
            /*
             * Otherwise, the path prefix for this file is obtained by a search of the
             * directories passed as the environment variable PATH (see the Base Definitions
             * volume of IEEE Std 1003.1-2001, Chapter 8, Environment Variables).
             */
            req4( name, "execlp.30.02", "", TODO_REQ() );
            req4( name, "execvp.30.02", "", TODO_REQ() );
        }

        /*
         * There are two distinct ways in which the contents of the process image file may
         * cause the execution to fail, distinguished by the setting of errno to either [
         * ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other
         * members of the exec family of functions would fail and set errno to [ENOEXEC],
         * the execlp() and execvp() functions shall execute a command interpreter and the
         * environment of the executed command shall be as if the process invoked the sh
         * utility using execl() as follows:
         *
         * execl(<shell path>, arg0, file, arg1, ..., (char *)0);
         *
         * where
         *
         * shell path> is an unspecified pathname for the sh utility, file is the process
         * image file, and for execvp(), where arg0, arg1, and so on correspond to the
         * values passed to execvp() in argv[0], argv[1], and so on.
         */
        req4( name, "execlp.31", "", TODO_REQ());
        req4( name, "execvp.31", "", TODO_REQ());

        /*
         * For those forms not containing an envp pointer ( execl(), execv(), execlp(),
         * and execvp()), the environment for the new process image shall be taken from
         * the external variable environ in the calling process.
         */
        checkResult = equals( new_envp, pre_envp );
        {
            String * newEnvpAsString = toString( new_envp );
            String * preEnvpAsString = toString( pre_envp );
            if ( checkResult ) { traceUserInfo( "equals( new_envp, pre_envp ) is true\n"  ); }
                          else { traceUserInfo( "equals( new_envp, pre_envp ) is false\n" ); }
            traceUserInfo( "newEnvpAsString\n" );
            traceUserInfo( toCharArray_String( newEnvpAsString ) );
            traceUserInfo( "\npreEnvpAsString\n" );
            traceUserInfo( toCharArray_String( preEnvpAsString ) );
            traceUserInfo( "\n" );
        }
        req4( name, "execl.32" , "The environment shall be taken from the environ in the calling process", checkResult );
        req4( name, "execlp.32", "The environment shall be taken from the environ in the calling process", checkResult );
        req4( name, "execv.32" , "The environment shall be taken from the environ in the calling process", checkResult );
        req4( name, "execvp.32", "The environment shall be taken from the environ in the calling process", checkResult );

        /*
         * These strings shall constitute the environment for the new process image.
         */
        checkResult = equals( new_envp, pre_envp );
        req4( name, "execle.32", "The environment shall be taken from the environ in the calling process", checkResult );
        req4( name, "execve.32", "The environment shall be taken from the environ in the calling process", checkResult );

        /*
         * If file descriptors 0, 1, and 2 would otherwise be closed after a successful
         * call to one of the exec family of functions, and the new process image file has
         * the set-user-ID or set-group-ID file mode bits set, [XSI]  and the ST_NOSUID
         * bit is not set for the file system containing the new process image file,
         * implementations may open an unspecified file for each of these file descriptors
         * in the new process image.
         */
        req4( name, "execl.34" , "", TODO_REQ() );
        req4( name, "execle.34", "", TODO_REQ() );
        req4( name, "execlp.34", "", TODO_REQ() );
        req4( name, "execv.34" , "", TODO_REQ() );
        req4( name, "execve.34", "", TODO_REQ() );
        req4( name, "execvp.34", "", TODO_REQ() );

        /*
         * setlocale(LC_ALL, "C")
         *
         * shall be executed at start-up.
         */
        req4( name, "execl.35" , "", TODO_REQ() );
        req4( name, "execle.35", "", TODO_REQ() );
        req4( name, "execlp.35", "", TODO_REQ() );
        req4( name, "execv.35" , "", TODO_REQ() );
        req4( name, "execve.35", "", TODO_REQ() );
        req4( name, "execvp.35", "", TODO_REQ() );

        /*
         * When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
         * SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of the
         * new process image and the initial thread in that new process image are
         * implementation-defined.
         */
        req4( name, "execl.36" , "", TODO_REQ() );
        req4( name, "execle.36", "", TODO_REQ() );
        req4( name, "execlp.36", "", TODO_REQ() );
        req4( name, "execv.36" , "", TODO_REQ() );
        req4( name, "execve.36", "", TODO_REQ() );
        req4( name, "execvp.36", "", TODO_REQ() );

        /*
         * [AIO] Any outstanding asynchronous I/O operations may be canceled. Those
         * asynchronous I/O operations that are not canceled shall complete as if the exec
         * function had not yet occurred, but any associated signal notifications shall be
         * suppressed. It is unspecified whether the exec function itself blocks awaiting
         * such I/O completion. In no event, however, shall the new process image created
         * by the exec function be affected by the presence of outstanding asynchronous I/
         * O operations at the time the exec function is called. Whether any I/O is
         * canceled, and which I/O may be canceled upon exec, is implementation-defined.
         */
        req4( name, "execl.37" , "", TODO_REQ() );
        req4( name, "execle.37", "", TODO_REQ() );
        req4( name, "execlp.37", "", TODO_REQ() );
        req4( name, "execv.37" , "", TODO_REQ() );
        req4( name, "execve.37", "", TODO_REQ() );
        req4( name, "execvp.37", "", TODO_REQ() );

        /*
         * [THR] The thread ID of the initial thread in the new process image is
         * unspecified.
         */
        checkResult = true;
        req4( name, "execl.38" , "The thread ID of the initial thread in the new process is unspecified", checkResult );
        req4( name, "execle.38", "The thread ID of the initial thread in the new process is unspecified", checkResult );
        req4( name, "execlp.38", "The thread ID of the initial thread in the new process is unspecified", checkResult );
        req4( name, "execv.38" , "The thread ID of the initial thread in the new process is unspecified", checkResult );
        req4( name, "execve.38", "The thread ID of the initial thread in the new process is unspecified", checkResult );
        req4( name, "execvp.38", "The thread ID of the initial thread in the new process is unspecified", checkResult );

        /*
         * The size and location of the stack on which the initial thread in the new
         * process image runs is unspecified.
         */
        checkResult = true;
        req4( name, "execl.39" , "The size and location of the stack is unspecified", checkResult );
        req4( name, "execle.39", "The size and location of the stack is unspecified", checkResult );
        req4( name, "execlp.39", "The size and location of the stack is unspecified", checkResult );
        req4( name, "execv.39" , "The size and location of the stack is unspecified", checkResult );
        req4( name, "execve.39", "The size and location of the stack is unspecified", checkResult );
        req4( name, "execvp.39", "The size and location of the stack is unspecified", checkResult );

        /*
         * All other process attributes defined in this volume of IEEE Std 1003.1-2001
         * shall be inherited in the new process image from the old process image.
         */
        req4( name, "execl.40" , "", TODO_REQ() );
        req4( name, "execle.40", "", TODO_REQ() );
        req4( name, "execlp.40", "", TODO_REQ() );
        req4( name, "execv.40" , "", TODO_REQ() );
        req4( name, "execve.40", "", TODO_REQ() );
        req4( name, "execvp.40", "", TODO_REQ() );

        /*
         * All other thread attributes defined in this volume of IEEE Std 1003.1-2001
         * shall be inherited in the initial thread in the new process image from the
         * calling thread in the old process image.
         */
        req4( name, "execl.41" , "", TODO_REQ() );
        req4( name, "execle.41", "", TODO_REQ() );
        req4( name, "execlp.41", "", TODO_REQ() );
        req4( name, "execv.41" , "", TODO_REQ() );
        req4( name, "execve.41", "", TODO_REQ() );
        req4( name, "execvp.41", "", TODO_REQ() );

        /*
         * The inheritance of process or thread attributes not defined by this volume of
         * IEEE Std 1003.1-2001 is implementation-defined.
         */
        req4( name, "execl.42" , "", TODO_REQ() );
        req4( name, "execle.42", "", TODO_REQ() );
        req4( name, "execlp.42", "", TODO_REQ() );
        req4( name, "execv.42" , "", TODO_REQ() );
        req4( name, "execve.42", "", TODO_REQ() );
        req4( name, "execvp.42", "", TODO_REQ() );

        /*
         * Upon successful completion, the exec functions shall mark for update the
         * st_atime field of the file.
         */
        req4( name, "execl.43" , "", TODO_REQ() );
        req4( name, "execle.43", "", TODO_REQ() );
        req4( name, "execlp.43", "", TODO_REQ() );
        req4( name, "execv.43" , "", TODO_REQ() );
        req4( name, "execve.43", "", TODO_REQ() );
        req4( name, "execvp.43", "", TODO_REQ() );

        /*
         * If an exec function failed but was able to locate the process image file,
         * whether the st_atime field is marked for update is unspecified.
         */
        req4( name, "execl.44" , "", TODO_REQ() );
        req4( name, "execle.44", "", TODO_REQ() );
        req4( name, "execlp.44", "", TODO_REQ() );
        req4( name, "execv.44" , "", TODO_REQ() );
        req4( name, "execve.44", "", TODO_REQ() );
        req4( name, "execvp.44", "", TODO_REQ() );

        /*
         * Should the exec function succeed, the process image file shall be considered to
         * have been opened with open(). The corresponding close() shall be considered to
         * occur at a time after this open, but before process termination or successful
         * completion of a subsequent call to one of the exec functions, posix_spawn(), or
         * posix_spawnp().
         */
        req4( name, "execl.45" , "", TODO_REQ() );
        req4( name, "execle.45", "", TODO_REQ() );
        req4( name, "execlp.45", "", TODO_REQ() );
        req4( name, "execv.45" , "", TODO_REQ() );
        req4( name, "execve.45", "", TODO_REQ() );
        req4( name, "execvp.45", "", TODO_REQ() );

        return true;
    }
}

void onExecOldProcessReturn( CallContext context )
{
    ExecCall * blocked_call = endCommand( context, "exec" );
    ProcessState * processState = getProcessState_CallContext( context );
    processState->inExecCall = false;
}

void onExecNewProcessReturn( CallContext context )
{
    CallContext oldContext = findCorrespondContext( context, systems );
    ExecCall * blocked_call = endCommand( oldContext, "exec" );
    ProcessState * processState = getProcessState_CallContext( oldContext );
    ThreadIdObj * threadIdObj;
    processState->inExecCall = false;

    if ( processState->childInCreation != NULL ) {
        // exec after vfork
        processState->childInCreation->processid.system  = context.system ;
        processState->childInCreation->processid.process = context.process;
        processState->childInCreation->inExecCall = false;
        processState->childInCreation->wasSuccessfulExecCall = true;
        processState->childInCreation->meta.parent = processState->processid;
        registerProcessState( processState->childInCreation->processid, processState->childInCreation );
        processState->childInCreation = NULL;
    } else {
        processState->wasSuccessfulExecCall = true;
        clear_Set( processState->dir_descriptors );
        threadIdObj = key_Map( processState->threads, 0 );
        threadIdObj->thread = context.thread;
        clear_Map( processState->threads );
        put_Map( processState->threads, threadIdObj, create_DefaultThreadState( * threadIdObj ) );
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    environ, execl, execv, execle, execve, execlp, execvp - execute a file

SYNOPSIS

    #include <unistd.h>

    extern char **environ;
    int execl(const char *path, const char *arg0, ... /*, (char *)0 * /);
    int execv(const char *path, char *const argv[]);
    int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]* /);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execlp(const char *file, const char *arg0, ... /*, (char *)0 * /);
    int execvp(const char *file, char *const argv[]);

DESCRIPTION

    The exec family of functions shall replace the current process image with a
    new process image. The new image shall be constructed from a regular,
    executable file called the new process image file. There shall be no return
    from a successful exec, because the calling process image is overlaid by the
    new process image.

    When a C-language program is executed as a result of this call, it shall be
    entered as a C-language function call as follows:

int main (int argc, char *argv[]);

    where argc is the argument count and argv is an array of character pointers
    to the arguments themselves. In addition, the following variable:

extern char **environ;

    is initialized as a pointer to an array of character pointers to the
    environment strings. The argv and environ arrays are each terminated by a
    null pointer. The null pointer terminating the argv array is not counted in
    argc.

    Conforming multi-threaded applications shall not use the environ variable to
    access or modify any environment variable while any other thread is
    concurrently modifying any environment variable. A call to any function
    dependent on any environment variable shall be considered a use of the
    environ variable to access that environment variable.

    The arguments specified by a program with one of the exec functions shall be
    passed on to the new process image in the corresponding main() arguments.

    The argument path points to a pathname that identifies the new process image
    file.

    The argument file is used to construct a pathname that identifies the new
    process image file. If the file argument contains a slash character, the
    file argument shall be used as the pathname for this file. Otherwise, the
    path prefix for this file is obtained by a search of the directories passed
    as the environment variable PATH (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Chapter 8, Environment Variables). If this environment
    variable is not present, the results of the search are
    implementation-defined.

    There are two distinct ways in which the contents of the process image file
    may cause the execution to fail, distinguished by the setting of errno to
    either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where
    the other members of the exec family of functions would fail and set errno
    to [ENOEXEC], the execlp() and execvp() functions shall execute a command
    interpreter and the environment of the executed command shall be as if the
    process invoked the sh utility using execl() as follows:

execl(<shell path>, arg0, file, arg1, ..., (char *)0);

    where <shell path> is an unspecified pathname for the sh utility, file is
    the process image file, and for execvp(), where arg0, arg1, and so on
    correspond to the values passed to execvp() in argv[0], argv[1], and so on.

    The arguments represented by arg0,... are pointers to null-terminated
    character strings. These strings shall constitute the argument list
    available to the new process image. The list is terminated by a null
    pointer. The argument arg0 should point to a filename that is associated
    with the process being started by one of the exec functions.

    The argument argv is an array of character pointers to null-terminated
    strings. The application shall ensure that the last member of this array is
    a null pointer. These strings shall constitute the argument list available
    to the new process image. The value in argv[0] should point to a filename
    that is associated with the process being started by one of the exec
    functions.

    The argument envp is an array of character pointers to null-terminated
    strings. These strings shall constitute the environment for the new process
    image. The envp array is terminated by a null pointer.

    For those forms not containing an envp pointer ( execl(), execv(), execlp(),
    and execvp()), the environment for the new process image shall be taken from
    the external variable environ in the calling process.

    The number of bytes available for the new process' combined argument and
    environment lists is {ARG_MAX}. It is implementation-defined whether null
    terminators, pointers, and/or any alignment bytes are included in this
    total.

    File descriptors open in the calling process image shall remain open in the
    new process image, except for those whose close-on- exec flag FD_CLOEXEC is
    set. For those file descriptors that remain open, all attributes of the open
    file description remain unchanged. For any file descriptor that is closed
    for this reason, file locks are removed as a result of the close as
    described in close(). Locks that are not removed by closing of file
    descriptors remain unchanged.

    If file descriptors 0, 1, and 2 would otherwise be closed after a successful
    call to one of the exec family of functions, and the new process image file
    has the set-user-ID or set-group-ID file mode bits set, and the ST_NOSUID
    bit is not set for the file system containing the new process image file,
    implementations may open an unspecified file for each of these file
    descriptors in the new process image.

    Directory streams open in the calling process image shall be closed in the
    new process image.

    The state of the floating-point environment in the new process image or in
    the initial thread of the new process image shall be set to the default.

    The state of conversion descriptors and message catalog descriptors in the
    new process image is undefined. For the new process image, the equivalent
    of:

setlocale(LC_ALL, "C")

    shall be executed at start-up.

    Signals set to the default action (SIG_DFL) in the calling process image
    shall be set to the default action in the new process image. Except for
    SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image
    shall be set to be ignored by the new process image. Signals set to be
    caught by the calling process image shall be set to the default action in
    the new process image (see <signal.h>). If the SIGCHLD signal is set to be
    ignored by the calling process image, it is unspecified whether the SIGCHLD
    signal is set to be ignored or to the default action in the new process
    image. After a successful call to any of the exec functions, alternate
    signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for
    all signals.

    After a successful call to any of the exec functions, any functions
    previously registered by atexit() or pthread_atfork() are no longer
    registered.

    If the ST_NOSUID bit is set for the file system containing the new process
    image file, then the effective user ID, effective group ID, saved
    set-user-ID, and saved set-group-ID are unchanged in the new process image.
    Otherwise, if the set-user-ID mode bit of the new process image file is set,
    the effective user ID of the new process image shall be set to the user ID
    of the new process image file. Similarly, if the set-group-ID mode bit of
    the new process image file is set, the effective group ID of the new process
    image shall be set to the group ID of the new process image file. The real
    user ID, real group ID, and supplementary group IDs of the new process image
    shall remain the same as those of the calling process image. The effective
    user ID and effective group ID of the new process image shall be saved (as
    the saved set-user-ID and the saved set-group-ID) for use by setuid().

    Any shared memory segments attached to the calling process image shall not
    be attached to the new process image.

    Any named semaphores open in the calling process shall be closed as if by
    appropriate calls to sem_close().

    Any blocks of typed memory that were mapped in the calling process are
    unmapped, as if munmap() was implicitly called to unmap them.

    Memory locks established by the calling process via calls to mlockall() or
    mlock() shall be removed. If locked pages in the address space of the
    calling process are also mapped into the address spaces of other processes
    and are locked by those processes, the locks established by the other
    processes shall be unaffected by the call by this process to the exec
    function. If the exec function fails, the effect on memory locks is
    unspecified.

    Memory mappings created in the process are unmapped before the address space
    is rebuilt for the new process image.

    When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of
    the new process image and the initial thread in that new process image are
    implementation-defined.

    When the calling process image uses the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the process policy and scheduling
    parameter settings shall not be changed by a call to an exec function. The
    initial thread in the new process image shall inherit the process scheduling
    policy and parameters. It shall have the default system contention scope,
    but shall inherit its allocation domain from the calling process image.

    Per-process timers created by the calling process shall be deleted before
    replacing the current process image with the new process image.

    All open message queue descriptors in the calling process shall be closed,
    as described in mq_close().

    Any outstanding asynchronous I/O operations may be canceled. Those
    asynchronous I/O operations that are not canceled shall complete as if the
    exec function had not yet occurred, but any associated signal notifications
    shall be suppressed. It is unspecified whether the exec function itself
    blocks awaiting such I/O completion. In no event, however, shall the new
    process image created by the exec function be affected by the presence of
    outstanding asynchronous I/O operations at the time the exec function is
    called. Whether any I/O is canceled, and which I/O may be canceled upon
    exec, is implementation-defined.

    The new process image shall inherit the CPU-time clock of the calling
    process image. This inheritance means that the process CPU-time clock of the
    process being exec-ed shall not be reinitialized or altered as a result of
    the exec function other than to reflect the time spent by the process
    executing the exec function itself.

    The initial value of the CPU-time clock of the initial thread of the new
    process image shall be set to zero.

    If the calling process is being traced, the new process image shall continue
    to be traced into the same trace stream as the original process image, but
    the new process image shall not inherit the mapping of trace event names to
    trace event type identifiers that was defined by calls to the
    posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions
    in the calling process image.

    If the calling process is a trace controller process, any trace streams that
    were created by the calling process shall be shut down as described in the
    posix_trace_shutdown() function.

    The thread ID of the initial thread in the new process image is unspecified.

    The size and location of the stack on which the initial thread in the new
    process image runs is unspecified.

    The initial thread in the new process image shall have its cancellation type
    set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
    PTHREAD_CANCEL_ENABLED.

    The initial thread in the new process image shall have all thread-specific
    data values set to NULL and all thread-specific data keys shall be removed
    by the call to exec without running destructors.

    The initial thread in the new process image shall be joinable, as if created
    with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

    The new process shall inherit at least the following attributes from the
    calling process image:

        Nice value (see nice())

        semadj values (see semop())

        Process ID

        Parent process ID

        Process group ID

        Session membership

        Real user ID

        Real group ID

        Supplementary group IDs

        Time left until an alarm clock signal (see alarm())

        Current working directory

        Root directory

        File mode creation mask (see umask())

        File size limit (see ulimit())

        Process signal mask (see sigprocmask())

        Pending signal (see sigpending())

        tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        Resource limits

        Controlling terminal

        Interval timers

    The initial thread of the new process shall inherit at least the following
    attributes from the calling thread:

        Signal mask (see sigprocmask() and pthread_sigmask())

        Pending signals (see sigpending())

    All other process attributes defined in this volume of IEEE Std 1003.1-2001
    shall be inherited in the new process image from the old process image. All
    other thread attributes defined in this volume of IEEE Std 1003.1-2001 shall
    be inherited in the initial thread in the new process image from the calling
    thread in the old process image. The inheritance of process or thread
    attributes not defined by this volume of IEEE Std 1003.1-2001 is
    implementation-defined.

    A call to any exec function from a process with more than one thread shall
    result in all threads being terminated and the new executable image being
    loaded and executed. No destructor functions or cleanup handlers shall be
    called.

    Upon successful completion, the exec functions shall mark for update the
    st_atime field of the file. If an exec function failed but was able to
    locate the process image file, whether the st_atime field is marked for
    update is unspecified. Should the exec function succeed, the process image
    file shall be considered to have been opened with open(). The corresponding
    close() shall be considered to occur at a time after this open, but before
    process termination or successful completion of a subsequent call to one of
    the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[]
    arrays of pointers and the strings to which those arrays point shall not be
    modified by a call to one of the exec functions, except as a consequence of
    replacing the process image.

    The saved resource limits in the new process image are set to be a copy of
    the process' corresponding hard and soft limits.

RETURN VALUE

    If one of the exec functions returns to the calling process image, an error
    has occurred; the return value shall be -1, and errno shall be set to
    indicate the error.

ERRORS

    The exec functions shall fail if:

    [E2BIG]
        The number of bytes used by the new process image's argument list and
        environment list is greater than the system-imposed limit of {ARG_MAX}
        bytes.
    [EACCES]
        Search permission is denied for a directory listed in the new process
        image file's path prefix, or the new process image file denies execution
        permission, or the new process image file is not a regular file and the
        implementation does not support execution of files of its type.
    [EINVAL]
        The new process image file has the appropriate permission and has a
        recognized executable binary format, but the system does not support
        execution of a file with this format.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path or file argument.
    [ENAMETOOLONG]
        The length of the path or file arguments exceeds {PATH_MAX} or a
        pathname component is longer than {NAME_MAX}.
    [ENOENT]
        A component of path or file does not name an existing file or path or
        file is an empty string.
    [ENOTDIR]
        A component of the new process image file's path prefix is not a
        directory.

    The exec functions, except for execlp() and execvp(), shall fail if:

    [ENOEXEC]
        The new process image file has the appropriate access permission but has
        an unrecognized format.

    The exec functions may fail if:

    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path or file argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The new process image requires more memory than is allowed by the
        hardware or system-imposed memory management constraints.
    [ETXTBSY]
        The new process image file is a pure procedure (shared text) file that
        is currently open for writing by some process.
*/
specification
void execl_spec( CallContext context, CString * path, List /* CString */ * argv )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists"    , process_state != NULL );
        REQ( "", "path point to pathname"  , path          != NULL );
        REQ( "", "argv correspond to array", argv          != NULL );

        /*
         * The arguments represented by arg0,... are pointers to null-terminated character
         * strings.
         */
        REQ( "app.execl.01.01", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The list is terminated by a null pointer.
         */
        REQ( "app.execl.01.02", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The argument arg0 should point to a filename that is associated with the
         * process being started by one of the exec functions.
         */
        REQ( "app.execl.01.03",
             "arg0 should point to a filename",
             T( size_List( argv ) >= 1 ) && T( equals( get_List( argv, 0 ), create_CString( "agent" ) ) )
           );

        /* [Restriction from agent] */
        REQ( "", "Restriction from agent on argv", size_List( argv ) <= 10 );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Path
    {
        if ( length_CString( path ) == 0 )
        {
            return { PathIsEmpty, "path is empty" };
        }
        else
        {
            return { PathIsNotEmpty, "path is not empty" };
        }
    }
    coverage C_Argv
    {
        if ( size_List( argv ) == 1 )
        {
            return { OnlyProgramName, "only program name" };
        }
        else
        {
            return { ProgramNameAndArguments, "program name and arguments" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    environ, execl, execv, execle, execve, execlp, execvp - execute a file

SYNOPSIS

    #include <unistd.h>

    extern char **environ;
    int execl(const char *path, const char *arg0, ... /*, (char *)0 * /);
    int execv(const char *path, char *const argv[]);
    int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]* /);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execlp(const char *file, const char *arg0, ... /*, (char *)0 * /);
    int execvp(const char *file, char *const argv[]);

DESCRIPTION

    The exec family of functions shall replace the current process image with a
    new process image. The new image shall be constructed from a regular,
    executable file called the new process image file. There shall be no return
    from a successful exec, because the calling process image is overlaid by the
    new process image.

    When a C-language program is executed as a result of this call, it shall be
    entered as a C-language function call as follows:

int main (int argc, char *argv[]);

    where argc is the argument count and argv is an array of character pointers
    to the arguments themselves. In addition, the following variable:

extern char **environ;

    is initialized as a pointer to an array of character pointers to the
    environment strings. The argv and environ arrays are each terminated by a
    null pointer. The null pointer terminating the argv array is not counted in
    argc.

    Conforming multi-threaded applications shall not use the environ variable to
    access or modify any environment variable while any other thread is
    concurrently modifying any environment variable. A call to any function
    dependent on any environment variable shall be considered a use of the
    environ variable to access that environment variable.

    The arguments specified by a program with one of the exec functions shall be
    passed on to the new process image in the corresponding main() arguments.

    The argument path points to a pathname that identifies the new process image
    file.

    The argument file is used to construct a pathname that identifies the new
    process image file. If the file argument contains a slash character, the
    file argument shall be used as the pathname for this file. Otherwise, the
    path prefix for this file is obtained by a search of the directories passed
    as the environment variable PATH (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Chapter 8, Environment Variables). If this environment
    variable is not present, the results of the search are
    implementation-defined.

    There are two distinct ways in which the contents of the process image file
    may cause the execution to fail, distinguished by the setting of errno to
    either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where
    the other members of the exec family of functions would fail and set errno
    to [ENOEXEC], the execlp() and execvp() functions shall execute a command
    interpreter and the environment of the executed command shall be as if the
    process invoked the sh utility using execl() as follows:

execl(<shell path>, arg0, file, arg1, ..., (char *)0);

    where <shell path> is an unspecified pathname for the sh utility, file is
    the process image file, and for execvp(), where arg0, arg1, and so on
    correspond to the values passed to execvp() in argv[0], argv[1], and so on.

    The arguments represented by arg0,... are pointers to null-terminated
    character strings. These strings shall constitute the argument list
    available to the new process image. The list is terminated by a null
    pointer. The argument arg0 should point to a filename that is associated
    with the process being started by one of the exec functions.

    The argument argv is an array of character pointers to null-terminated
    strings. The application shall ensure that the last member of this array is
    a null pointer. These strings shall constitute the argument list available
    to the new process image. The value in argv[0] should point to a filename
    that is associated with the process being started by one of the exec
    functions.

    The argument envp is an array of character pointers to null-terminated
    strings. These strings shall constitute the environment for the new process
    image. The envp array is terminated by a null pointer.

    For those forms not containing an envp pointer ( execl(), execv(), execlp(),
    and execvp()), the environment for the new process image shall be taken from
    the external variable environ in the calling process.

    The number of bytes available for the new process' combined argument and
    environment lists is {ARG_MAX}. It is implementation-defined whether null
    terminators, pointers, and/or any alignment bytes are included in this
    total.

    File descriptors open in the calling process image shall remain open in the
    new process image, except for those whose close-on- exec flag FD_CLOEXEC is
    set. For those file descriptors that remain open, all attributes of the open
    file description remain unchanged. For any file descriptor that is closed
    for this reason, file locks are removed as a result of the close as
    described in close(). Locks that are not removed by closing of file
    descriptors remain unchanged.

    If file descriptors 0, 1, and 2 would otherwise be closed after a successful
    call to one of the exec family of functions, and the new process image file
    has the set-user-ID or set-group-ID file mode bits set, and the ST_NOSUID
    bit is not set for the file system containing the new process image file,
    implementations may open an unspecified file for each of these file
    descriptors in the new process image.

    Directory streams open in the calling process image shall be closed in the
    new process image.

    The state of the floating-point environment in the new process image or in
    the initial thread of the new process image shall be set to the default.

    The state of conversion descriptors and message catalog descriptors in the
    new process image is undefined. For the new process image, the equivalent
    of:

setlocale(LC_ALL, "C")

    shall be executed at start-up.

    Signals set to the default action (SIG_DFL) in the calling process image
    shall be set to the default action in the new process image. Except for
    SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image
    shall be set to be ignored by the new process image. Signals set to be
    caught by the calling process image shall be set to the default action in
    the new process image (see <signal.h>). If the SIGCHLD signal is set to be
    ignored by the calling process image, it is unspecified whether the SIGCHLD
    signal is set to be ignored or to the default action in the new process
    image. After a successful call to any of the exec functions, alternate
    signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for
    all signals.

    After a successful call to any of the exec functions, any functions
    previously registered by atexit() or pthread_atfork() are no longer
    registered.

    If the ST_NOSUID bit is set for the file system containing the new process
    image file, then the effective user ID, effective group ID, saved
    set-user-ID, and saved set-group-ID are unchanged in the new process image.
    Otherwise, if the set-user-ID mode bit of the new process image file is set,
    the effective user ID of the new process image shall be set to the user ID
    of the new process image file. Similarly, if the set-group-ID mode bit of
    the new process image file is set, the effective group ID of the new process
    image shall be set to the group ID of the new process image file. The real
    user ID, real group ID, and supplementary group IDs of the new process image
    shall remain the same as those of the calling process image. The effective
    user ID and effective group ID of the new process image shall be saved (as
    the saved set-user-ID and the saved set-group-ID) for use by setuid().

    Any shared memory segments attached to the calling process image shall not
    be attached to the new process image.

    Any named semaphores open in the calling process shall be closed as if by
    appropriate calls to sem_close().

    Any blocks of typed memory that were mapped in the calling process are
    unmapped, as if munmap() was implicitly called to unmap them.

    Memory locks established by the calling process via calls to mlockall() or
    mlock() shall be removed. If locked pages in the address space of the
    calling process are also mapped into the address spaces of other processes
    and are locked by those processes, the locks established by the other
    processes shall be unaffected by the call by this process to the exec
    function. If the exec function fails, the effect on memory locks is
    unspecified.

    Memory mappings created in the process are unmapped before the address space
    is rebuilt for the new process image.

    When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of
    the new process image and the initial thread in that new process image are
    implementation-defined.

    When the calling process image uses the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the process policy and scheduling
    parameter settings shall not be changed by a call to an exec function. The
    initial thread in the new process image shall inherit the process scheduling
    policy and parameters. It shall have the default system contention scope,
    but shall inherit its allocation domain from the calling process image.

    Per-process timers created by the calling process shall be deleted before
    replacing the current process image with the new process image.

    All open message queue descriptors in the calling process shall be closed,
    as described in mq_close().

    Any outstanding asynchronous I/O operations may be canceled. Those
    asynchronous I/O operations that are not canceled shall complete as if the
    exec function had not yet occurred, but any associated signal notifications
    shall be suppressed. It is unspecified whether the exec function itself
    blocks awaiting such I/O completion. In no event, however, shall the new
    process image created by the exec function be affected by the presence of
    outstanding asynchronous I/O operations at the time the exec function is
    called. Whether any I/O is canceled, and which I/O may be canceled upon
    exec, is implementation-defined.

    The new process image shall inherit the CPU-time clock of the calling
    process image. This inheritance means that the process CPU-time clock of the
    process being exec-ed shall not be reinitialized or altered as a result of
    the exec function other than to reflect the time spent by the process
    executing the exec function itself.

    The initial value of the CPU-time clock of the initial thread of the new
    process image shall be set to zero.

    If the calling process is being traced, the new process image shall continue
    to be traced into the same trace stream as the original process image, but
    the new process image shall not inherit the mapping of trace event names to
    trace event type identifiers that was defined by calls to the
    posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions
    in the calling process image.

    If the calling process is a trace controller process, any trace streams that
    were created by the calling process shall be shut down as described in the
    posix_trace_shutdown() function.

    The thread ID of the initial thread in the new process image is unspecified.

    The size and location of the stack on which the initial thread in the new
    process image runs is unspecified.

    The initial thread in the new process image shall have its cancellation type
    set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
    PTHREAD_CANCEL_ENABLED.

    The initial thread in the new process image shall have all thread-specific
    data values set to NULL and all thread-specific data keys shall be removed
    by the call to exec without running destructors.

    The initial thread in the new process image shall be joinable, as if created
    with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

    The new process shall inherit at least the following attributes from the
    calling process image:

        Nice value (see nice())

        semadj values (see semop())

        Process ID

        Parent process ID

        Process group ID

        Session membership

        Real user ID

        Real group ID

        Supplementary group IDs

        Time left until an alarm clock signal (see alarm())

        Current working directory

        Root directory

        File mode creation mask (see umask())

        File size limit (see ulimit())

        Process signal mask (see sigprocmask())

        Pending signal (see sigpending())

        tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        Resource limits

        Controlling terminal

        Interval timers

    The initial thread of the new process shall inherit at least the following
    attributes from the calling thread:

        Signal mask (see sigprocmask() and pthread_sigmask())

        Pending signals (see sigpending())

    All other process attributes defined in this volume of IEEE Std 1003.1-2001
    shall be inherited in the new process image from the old process image. All
    other thread attributes defined in this volume of IEEE Std 1003.1-2001 shall
    be inherited in the initial thread in the new process image from the calling
    thread in the old process image. The inheritance of process or thread
    attributes not defined by this volume of IEEE Std 1003.1-2001 is
    implementation-defined.

    A call to any exec function from a process with more than one thread shall
    result in all threads being terminated and the new executable image being
    loaded and executed. No destructor functions or cleanup handlers shall be
    called.

    Upon successful completion, the exec functions shall mark for update the
    st_atime field of the file. If an exec function failed but was able to
    locate the process image file, whether the st_atime field is marked for
    update is unspecified. Should the exec function succeed, the process image
    file shall be considered to have been opened with open(). The corresponding
    close() shall be considered to occur at a time after this open, but before
    process termination or successful completion of a subsequent call to one of
    the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[]
    arrays of pointers and the strings to which those arrays point shall not be
    modified by a call to one of the exec functions, except as a consequence of
    replacing the process image.

    The saved resource limits in the new process image are set to be a copy of
    the process' corresponding hard and soft limits.

RETURN VALUE

    If one of the exec functions returns to the calling process image, an error
    has occurred; the return value shall be -1, and errno shall be set to
    indicate the error.

ERRORS

    The exec functions shall fail if:

    [E2BIG]
        The number of bytes used by the new process image's argument list and
        environment list is greater than the system-imposed limit of {ARG_MAX}
        bytes.
    [EACCES]
        Search permission is denied for a directory listed in the new process
        image file's path prefix, or the new process image file denies execution
        permission, or the new process image file is not a regular file and the
        implementation does not support execution of files of its type.
    [EINVAL]
        The new process image file has the appropriate permission and has a
        recognized executable binary format, but the system does not support
        execution of a file with this format.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path or file argument.
    [ENAMETOOLONG]
        The length of the path or file arguments exceeds {PATH_MAX} or a
        pathname component is longer than {NAME_MAX}.
    [ENOENT]
        A component of path or file does not name an existing file or path or
        file is an empty string.
    [ENOTDIR]
        A component of the new process image file's path prefix is not a
        directory.

    The exec functions, except for execlp() and execvp(), shall fail if:

    [ENOEXEC]
        The new process image file has the appropriate access permission but has
        an unrecognized format.

    The exec functions may fail if:

    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path or file argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The new process image requires more memory than is allowed by the
        hardware or system-imposed memory management constraints.
    [ETXTBSY]
        The new process image file is a pure procedure (shared text) file that
        is currently open for writing by some process.
*/
specification
void execle_spec( CallContext context, CString * path, List /* CString */ * argv, List /* CString */ * envp )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists"    , process_state != NULL );
        REQ( "", "path point to pathname"  , path          != NULL );
        REQ( "", "argv correspond to array", argv          != NULL );
        REQ( "", "envp correspond to array", envp          != NULL );

        /*
         * The arguments represented by arg0,... are pointers to null-terminated character
         * strings.
         */
        REQ( "app.execle.01.01", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The list is terminated by a null pointer.
         */
        REQ( "app.execle.01.02", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The argument arg0 should point to a filename that is associated with the
         * process being started by one of the exec functions.
         */
        REQ( "app.execle.01.03",
             "arg0 should point to a filename",
             T( size_List( argv ) >= 1 ) && T( equals( get_List( argv, 0 ), create_CString( "agent" ) ) )
           );

        /* [Restriction from agent] */
        REQ( "", "Restriction from agent on argv", size_List( argv ) <= 10 );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Path
    {
        if ( length_CString( path ) == 0 )
        {
            return { PathIsEmpty, "path is empty" };
        }
        else
        {
            return { PathIsNotEmpty, "path is not empty" };
        }
    }
    coverage C_Argv
    {
        if ( size_List( argv ) == 1 )
        {
            return { OnlyProgramName, "only program name" };
        }
        else
        {
            return { ProgramNameAndArguments, "program name and arguments" };
        }
    }
    coverage C_Envp
    {
        if ( isEmpty_List( envp ) )
        {
            return { EnvpIsEmpty, "envp is empty" };
        }
        else
        {
            return { EnvpIsNotEmpty, "envp is not empty" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    environ, execl, execv, execle, execve, execlp, execvp - execute a file

SYNOPSIS

    #include <unistd.h>

    extern char **environ;
    int execl(const char *path, const char *arg0, ... /*, (char *)0 * /);
    int execv(const char *path, char *const argv[]);
    int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]* /);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execlp(const char *file, const char *arg0, ... /*, (char *)0 * /);
    int execvp(const char *file, char *const argv[]);

DESCRIPTION

    The exec family of functions shall replace the current process image with a
    new process image. The new image shall be constructed from a regular,
    executable file called the new process image file. There shall be no return
    from a successful exec, because the calling process image is overlaid by the
    new process image.

    When a C-language program is executed as a result of this call, it shall be
    entered as a C-language function call as follows:

int main (int argc, char *argv[]);

    where argc is the argument count and argv is an array of character pointers
    to the arguments themselves. In addition, the following variable:

extern char **environ;

    is initialized as a pointer to an array of character pointers to the
    environment strings. The argv and environ arrays are each terminated by a
    null pointer. The null pointer terminating the argv array is not counted in
    argc.

    Conforming multi-threaded applications shall not use the environ variable to
    access or modify any environment variable while any other thread is
    concurrently modifying any environment variable. A call to any function
    dependent on any environment variable shall be considered a use of the
    environ variable to access that environment variable.

    The arguments specified by a program with one of the exec functions shall be
    passed on to the new process image in the corresponding main() arguments.

    The argument path points to a pathname that identifies the new process image
    file.

    The argument file is used to construct a pathname that identifies the new
    process image file. If the file argument contains a slash character, the
    file argument shall be used as the pathname for this file. Otherwise, the
    path prefix for this file is obtained by a search of the directories passed
    as the environment variable PATH (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Chapter 8, Environment Variables). If this environment
    variable is not present, the results of the search are
    implementation-defined.

    There are two distinct ways in which the contents of the process image file
    may cause the execution to fail, distinguished by the setting of errno to
    either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where
    the other members of the exec family of functions would fail and set errno
    to [ENOEXEC], the execlp() and execvp() functions shall execute a command
    interpreter and the environment of the executed command shall be as if the
    process invoked the sh utility using execl() as follows:

execl(<shell path>, arg0, file, arg1, ..., (char *)0);

    where <shell path> is an unspecified pathname for the sh utility, file is
    the process image file, and for execvp(), where arg0, arg1, and so on
    correspond to the values passed to execvp() in argv[0], argv[1], and so on.

    The arguments represented by arg0,... are pointers to null-terminated
    character strings. These strings shall constitute the argument list
    available to the new process image. The list is terminated by a null
    pointer. The argument arg0 should point to a filename that is associated
    with the process being started by one of the exec functions.

    The argument argv is an array of character pointers to null-terminated
    strings. The application shall ensure that the last member of this array is
    a null pointer. These strings shall constitute the argument list available
    to the new process image. The value in argv[0] should point to a filename
    that is associated with the process being started by one of the exec
    functions.

    The argument envp is an array of character pointers to null-terminated
    strings. These strings shall constitute the environment for the new process
    image. The envp array is terminated by a null pointer.

    For those forms not containing an envp pointer ( execl(), execv(), execlp(),
    and execvp()), the environment for the new process image shall be taken from
    the external variable environ in the calling process.

    The number of bytes available for the new process' combined argument and
    environment lists is {ARG_MAX}. It is implementation-defined whether null
    terminators, pointers, and/or any alignment bytes are included in this
    total.

    File descriptors open in the calling process image shall remain open in the
    new process image, except for those whose close-on- exec flag FD_CLOEXEC is
    set. For those file descriptors that remain open, all attributes of the open
    file description remain unchanged. For any file descriptor that is closed
    for this reason, file locks are removed as a result of the close as
    described in close(). Locks that are not removed by closing of file
    descriptors remain unchanged.

    If file descriptors 0, 1, and 2 would otherwise be closed after a successful
    call to one of the exec family of functions, and the new process image file
    has the set-user-ID or set-group-ID file mode bits set, and the ST_NOSUID
    bit is not set for the file system containing the new process image file,
    implementations may open an unspecified file for each of these file
    descriptors in the new process image.

    Directory streams open in the calling process image shall be closed in the
    new process image.

    The state of the floating-point environment in the new process image or in
    the initial thread of the new process image shall be set to the default.

    The state of conversion descriptors and message catalog descriptors in the
    new process image is undefined. For the new process image, the equivalent
    of:

setlocale(LC_ALL, "C")

    shall be executed at start-up.

    Signals set to the default action (SIG_DFL) in the calling process image
    shall be set to the default action in the new process image. Except for
    SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image
    shall be set to be ignored by the new process image. Signals set to be
    caught by the calling process image shall be set to the default action in
    the new process image (see <signal.h>). If the SIGCHLD signal is set to be
    ignored by the calling process image, it is unspecified whether the SIGCHLD
    signal is set to be ignored or to the default action in the new process
    image. After a successful call to any of the exec functions, alternate
    signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for
    all signals.

    After a successful call to any of the exec functions, any functions
    previously registered by atexit() or pthread_atfork() are no longer
    registered.

    If the ST_NOSUID bit is set for the file system containing the new process
    image file, then the effective user ID, effective group ID, saved
    set-user-ID, and saved set-group-ID are unchanged in the new process image.
    Otherwise, if the set-user-ID mode bit of the new process image file is set,
    the effective user ID of the new process image shall be set to the user ID
    of the new process image file. Similarly, if the set-group-ID mode bit of
    the new process image file is set, the effective group ID of the new process
    image shall be set to the group ID of the new process image file. The real
    user ID, real group ID, and supplementary group IDs of the new process image
    shall remain the same as those of the calling process image. The effective
    user ID and effective group ID of the new process image shall be saved (as
    the saved set-user-ID and the saved set-group-ID) for use by setuid().

    Any shared memory segments attached to the calling process image shall not
    be attached to the new process image.

    Any named semaphores open in the calling process shall be closed as if by
    appropriate calls to sem_close().

    Any blocks of typed memory that were mapped in the calling process are
    unmapped, as if munmap() was implicitly called to unmap them.

    Memory locks established by the calling process via calls to mlockall() or
    mlock() shall be removed. If locked pages in the address space of the
    calling process are also mapped into the address spaces of other processes
    and are locked by those processes, the locks established by the other
    processes shall be unaffected by the call by this process to the exec
    function. If the exec function fails, the effect on memory locks is
    unspecified.

    Memory mappings created in the process are unmapped before the address space
    is rebuilt for the new process image.

    When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of
    the new process image and the initial thread in that new process image are
    implementation-defined.

    When the calling process image uses the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the process policy and scheduling
    parameter settings shall not be changed by a call to an exec function. The
    initial thread in the new process image shall inherit the process scheduling
    policy and parameters. It shall have the default system contention scope,
    but shall inherit its allocation domain from the calling process image.

    Per-process timers created by the calling process shall be deleted before
    replacing the current process image with the new process image.

    All open message queue descriptors in the calling process shall be closed,
    as described in mq_close().

    Any outstanding asynchronous I/O operations may be canceled. Those
    asynchronous I/O operations that are not canceled shall complete as if the
    exec function had not yet occurred, but any associated signal notifications
    shall be suppressed. It is unspecified whether the exec function itself
    blocks awaiting such I/O completion. In no event, however, shall the new
    process image created by the exec function be affected by the presence of
    outstanding asynchronous I/O operations at the time the exec function is
    called. Whether any I/O is canceled, and which I/O may be canceled upon
    exec, is implementation-defined.

    The new process image shall inherit the CPU-time clock of the calling
    process image. This inheritance means that the process CPU-time clock of the
    process being exec-ed shall not be reinitialized or altered as a result of
    the exec function other than to reflect the time spent by the process
    executing the exec function itself.

    The initial value of the CPU-time clock of the initial thread of the new
    process image shall be set to zero.

    If the calling process is being traced, the new process image shall continue
    to be traced into the same trace stream as the original process image, but
    the new process image shall not inherit the mapping of trace event names to
    trace event type identifiers that was defined by calls to the
    posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions
    in the calling process image.

    If the calling process is a trace controller process, any trace streams that
    were created by the calling process shall be shut down as described in the
    posix_trace_shutdown() function.

    The thread ID of the initial thread in the new process image is unspecified.

    The size and location of the stack on which the initial thread in the new
    process image runs is unspecified.

    The initial thread in the new process image shall have its cancellation type
    set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
    PTHREAD_CANCEL_ENABLED.

    The initial thread in the new process image shall have all thread-specific
    data values set to NULL and all thread-specific data keys shall be removed
    by the call to exec without running destructors.

    The initial thread in the new process image shall be joinable, as if created
    with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

    The new process shall inherit at least the following attributes from the
    calling process image:

        Nice value (see nice())

        semadj values (see semop())

        Process ID

        Parent process ID

        Process group ID

        Session membership

        Real user ID

        Real group ID

        Supplementary group IDs

        Time left until an alarm clock signal (see alarm())

        Current working directory

        Root directory

        File mode creation mask (see umask())

        File size limit (see ulimit())

        Process signal mask (see sigprocmask())

        Pending signal (see sigpending())

        tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        Resource limits

        Controlling terminal

        Interval timers

    The initial thread of the new process shall inherit at least the following
    attributes from the calling thread:

        Signal mask (see sigprocmask() and pthread_sigmask())

        Pending signals (see sigpending())

    All other process attributes defined in this volume of IEEE Std 1003.1-2001
    shall be inherited in the new process image from the old process image. All
    other thread attributes defined in this volume of IEEE Std 1003.1-2001 shall
    be inherited in the initial thread in the new process image from the calling
    thread in the old process image. The inheritance of process or thread
    attributes not defined by this volume of IEEE Std 1003.1-2001 is
    implementation-defined.

    A call to any exec function from a process with more than one thread shall
    result in all threads being terminated and the new executable image being
    loaded and executed. No destructor functions or cleanup handlers shall be
    called.

    Upon successful completion, the exec functions shall mark for update the
    st_atime field of the file. If an exec function failed but was able to
    locate the process image file, whether the st_atime field is marked for
    update is unspecified. Should the exec function succeed, the process image
    file shall be considered to have been opened with open(). The corresponding
    close() shall be considered to occur at a time after this open, but before
    process termination or successful completion of a subsequent call to one of
    the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[]
    arrays of pointers and the strings to which those arrays point shall not be
    modified by a call to one of the exec functions, except as a consequence of
    replacing the process image.

    The saved resource limits in the new process image are set to be a copy of
    the process' corresponding hard and soft limits.

RETURN VALUE

    If one of the exec functions returns to the calling process image, an error
    has occurred; the return value shall be -1, and errno shall be set to
    indicate the error.

ERRORS

    The exec functions shall fail if:

    [E2BIG]
        The number of bytes used by the new process image's argument list and
        environment list is greater than the system-imposed limit of {ARG_MAX}
        bytes.
    [EACCES]
        Search permission is denied for a directory listed in the new process
        image file's path prefix, or the new process image file denies execution
        permission, or the new process image file is not a regular file and the
        implementation does not support execution of files of its type.
    [EINVAL]
        The new process image file has the appropriate permission and has a
        recognized executable binary format, but the system does not support
        execution of a file with this format.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path or file argument.
    [ENAMETOOLONG]
        The length of the path or file arguments exceeds {PATH_MAX} or a
        pathname component is longer than {NAME_MAX}.
    [ENOENT]
        A component of path or file does not name an existing file or path or
        file is an empty string.
    [ENOTDIR]
        A component of the new process image file's path prefix is not a
        directory.

    The exec functions, except for execlp() and execvp(), shall fail if:

    [ENOEXEC]
        The new process image file has the appropriate access permission but has
        an unrecognized format.

    The exec functions may fail if:

    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path or file argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The new process image requires more memory than is allowed by the
        hardware or system-imposed memory management constraints.
    [ETXTBSY]
        The new process image file is a pure procedure (shared text) file that
        is currently open for writing by some process.
*/
specification
void execlp_spec( CallContext context, CString * file, List /* CString */ * argv )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists"    , process_state != NULL );
        REQ( "", "file point to filename"  , file          != NULL );
        REQ( "", "argv correspond to array", argv          != NULL );

        /*
         * The arguments represented by arg0,... are pointers to null-terminated character
         * strings.
         */
        REQ( "app.execlp.01.01", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The list is terminated by a null pointer.
         */
        REQ( "app.execlp.01.02", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The argument arg0 should point to a filename that is associated with the
         * process being started by one of the exec functions.
         */
        REQ( "app.execlp.01.03",
             "arg0 should point to a filename",
             T( size_List( argv ) >= 1 ) && T( equals( get_List( argv, 0 ), create_CString( "agent" ) ) )
           );

        /* [Restriction from agent] */
        REQ( "", "Restriction from agent on argv", size_List( argv ) <= 10 );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_File
    {
        if ( length_CString( file ) == 0 )
        {
            return { FileIsEmpty, "file is empty" };
        }
        else
        {
            return { FileIsNotEmpty, "file is not empty" };
        }
    }
    coverage C_Argv
    {
        if ( size_List( argv ) == 1 )
        {
            return { OnlyProgramName, "only program name" };
        }
        else
        {
            return { ProgramNameAndArguments, "program name and arguments" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    environ, execl, execv, execle, execve, execlp, execvp - execute a file

SYNOPSIS

    #include <unistd.h>

    extern char **environ;
    int execl(const char *path, const char *arg0, ... /*, (char *)0 * /);
    int execv(const char *path, char *const argv[]);
    int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]* /);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execlp(const char *file, const char *arg0, ... /*, (char *)0 * /);
    int execvp(const char *file, char *const argv[]);

DESCRIPTION

    The exec family of functions shall replace the current process image with a
    new process image. The new image shall be constructed from a regular,
    executable file called the new process image file. There shall be no return
    from a successful exec, because the calling process image is overlaid by the
    new process image.

    When a C-language program is executed as a result of this call, it shall be
    entered as a C-language function call as follows:

int main (int argc, char *argv[]);

    where argc is the argument count and argv is an array of character pointers
    to the arguments themselves. In addition, the following variable:

extern char **environ;

    is initialized as a pointer to an array of character pointers to the
    environment strings. The argv and environ arrays are each terminated by a
    null pointer. The null pointer terminating the argv array is not counted in
    argc.

    Conforming multi-threaded applications shall not use the environ variable to
    access or modify any environment variable while any other thread is
    concurrently modifying any environment variable. A call to any function
    dependent on any environment variable shall be considered a use of the
    environ variable to access that environment variable.

    The arguments specified by a program with one of the exec functions shall be
    passed on to the new process image in the corresponding main() arguments.

    The argument path points to a pathname that identifies the new process image
    file.

    The argument file is used to construct a pathname that identifies the new
    process image file. If the file argument contains a slash character, the
    file argument shall be used as the pathname for this file. Otherwise, the
    path prefix for this file is obtained by a search of the directories passed
    as the environment variable PATH (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Chapter 8, Environment Variables). If this environment
    variable is not present, the results of the search are
    implementation-defined.

    There are two distinct ways in which the contents of the process image file
    may cause the execution to fail, distinguished by the setting of errno to
    either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where
    the other members of the exec family of functions would fail and set errno
    to [ENOEXEC], the execlp() and execvp() functions shall execute a command
    interpreter and the environment of the executed command shall be as if the
    process invoked the sh utility using execl() as follows:

execl(<shell path>, arg0, file, arg1, ..., (char *)0);

    where <shell path> is an unspecified pathname for the sh utility, file is
    the process image file, and for execvp(), where arg0, arg1, and so on
    correspond to the values passed to execvp() in argv[0], argv[1], and so on.

    The arguments represented by arg0,... are pointers to null-terminated
    character strings. These strings shall constitute the argument list
    available to the new process image. The list is terminated by a null
    pointer. The argument arg0 should point to a filename that is associated
    with the process being started by one of the exec functions.

    The argument argv is an array of character pointers to null-terminated
    strings. The application shall ensure that the last member of this array is
    a null pointer. These strings shall constitute the argument list available
    to the new process image. The value in argv[0] should point to a filename
    that is associated with the process being started by one of the exec
    functions.

    The argument envp is an array of character pointers to null-terminated
    strings. These strings shall constitute the environment for the new process
    image. The envp array is terminated by a null pointer.

    For those forms not containing an envp pointer ( execl(), execv(), execlp(),
    and execvp()), the environment for the new process image shall be taken from
    the external variable environ in the calling process.

    The number of bytes available for the new process' combined argument and
    environment lists is {ARG_MAX}. It is implementation-defined whether null
    terminators, pointers, and/or any alignment bytes are included in this
    total.

    File descriptors open in the calling process image shall remain open in the
    new process image, except for those whose close-on- exec flag FD_CLOEXEC is
    set. For those file descriptors that remain open, all attributes of the open
    file description remain unchanged. For any file descriptor that is closed
    for this reason, file locks are removed as a result of the close as
    described in close(). Locks that are not removed by closing of file
    descriptors remain unchanged.

    If file descriptors 0, 1, and 2 would otherwise be closed after a successful
    call to one of the exec family of functions, and the new process image file
    has the set-user-ID or set-group-ID file mode bits set, and the ST_NOSUID
    bit is not set for the file system containing the new process image file,
    implementations may open an unspecified file for each of these file
    descriptors in the new process image.

    Directory streams open in the calling process image shall be closed in the
    new process image.

    The state of the floating-point environment in the new process image or in
    the initial thread of the new process image shall be set to the default.

    The state of conversion descriptors and message catalog descriptors in the
    new process image is undefined. For the new process image, the equivalent
    of:

setlocale(LC_ALL, "C")

    shall be executed at start-up.

    Signals set to the default action (SIG_DFL) in the calling process image
    shall be set to the default action in the new process image. Except for
    SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image
    shall be set to be ignored by the new process image. Signals set to be
    caught by the calling process image shall be set to the default action in
    the new process image (see <signal.h>). If the SIGCHLD signal is set to be
    ignored by the calling process image, it is unspecified whether the SIGCHLD
    signal is set to be ignored or to the default action in the new process
    image. After a successful call to any of the exec functions, alternate
    signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for
    all signals.

    After a successful call to any of the exec functions, any functions
    previously registered by atexit() or pthread_atfork() are no longer
    registered.

    If the ST_NOSUID bit is set for the file system containing the new process
    image file, then the effective user ID, effective group ID, saved
    set-user-ID, and saved set-group-ID are unchanged in the new process image.
    Otherwise, if the set-user-ID mode bit of the new process image file is set,
    the effective user ID of the new process image shall be set to the user ID
    of the new process image file. Similarly, if the set-group-ID mode bit of
    the new process image file is set, the effective group ID of the new process
    image shall be set to the group ID of the new process image file. The real
    user ID, real group ID, and supplementary group IDs of the new process image
    shall remain the same as those of the calling process image. The effective
    user ID and effective group ID of the new process image shall be saved (as
    the saved set-user-ID and the saved set-group-ID) for use by setuid().

    Any shared memory segments attached to the calling process image shall not
    be attached to the new process image.

    Any named semaphores open in the calling process shall be closed as if by
    appropriate calls to sem_close().

    Any blocks of typed memory that were mapped in the calling process are
    unmapped, as if munmap() was implicitly called to unmap them.

    Memory locks established by the calling process via calls to mlockall() or
    mlock() shall be removed. If locked pages in the address space of the
    calling process are also mapped into the address spaces of other processes
    and are locked by those processes, the locks established by the other
    processes shall be unaffected by the call by this process to the exec
    function. If the exec function fails, the effect on memory locks is
    unspecified.

    Memory mappings created in the process are unmapped before the address space
    is rebuilt for the new process image.

    When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of
    the new process image and the initial thread in that new process image are
    implementation-defined.

    When the calling process image uses the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the process policy and scheduling
    parameter settings shall not be changed by a call to an exec function. The
    initial thread in the new process image shall inherit the process scheduling
    policy and parameters. It shall have the default system contention scope,
    but shall inherit its allocation domain from the calling process image.

    Per-process timers created by the calling process shall be deleted before
    replacing the current process image with the new process image.

    All open message queue descriptors in the calling process shall be closed,
    as described in mq_close().

    Any outstanding asynchronous I/O operations may be canceled. Those
    asynchronous I/O operations that are not canceled shall complete as if the
    exec function had not yet occurred, but any associated signal notifications
    shall be suppressed. It is unspecified whether the exec function itself
    blocks awaiting such I/O completion. In no event, however, shall the new
    process image created by the exec function be affected by the presence of
    outstanding asynchronous I/O operations at the time the exec function is
    called. Whether any I/O is canceled, and which I/O may be canceled upon
    exec, is implementation-defined.

    The new process image shall inherit the CPU-time clock of the calling
    process image. This inheritance means that the process CPU-time clock of the
    process being exec-ed shall not be reinitialized or altered as a result of
    the exec function other than to reflect the time spent by the process
    executing the exec function itself.

    The initial value of the CPU-time clock of the initial thread of the new
    process image shall be set to zero.

    If the calling process is being traced, the new process image shall continue
    to be traced into the same trace stream as the original process image, but
    the new process image shall not inherit the mapping of trace event names to
    trace event type identifiers that was defined by calls to the
    posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions
    in the calling process image.

    If the calling process is a trace controller process, any trace streams that
    were created by the calling process shall be shut down as described in the
    posix_trace_shutdown() function.

    The thread ID of the initial thread in the new process image is unspecified.

    The size and location of the stack on which the initial thread in the new
    process image runs is unspecified.

    The initial thread in the new process image shall have its cancellation type
    set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
    PTHREAD_CANCEL_ENABLED.

    The initial thread in the new process image shall have all thread-specific
    data values set to NULL and all thread-specific data keys shall be removed
    by the call to exec without running destructors.

    The initial thread in the new process image shall be joinable, as if created
    with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

    The new process shall inherit at least the following attributes from the
    calling process image:

        Nice value (see nice())

        semadj values (see semop())

        Process ID

        Parent process ID

        Process group ID

        Session membership

        Real user ID

        Real group ID

        Supplementary group IDs

        Time left until an alarm clock signal (see alarm())

        Current working directory

        Root directory

        File mode creation mask (see umask())

        File size limit (see ulimit())

        Process signal mask (see sigprocmask())

        Pending signal (see sigpending())

        tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        Resource limits

        Controlling terminal

        Interval timers

    The initial thread of the new process shall inherit at least the following
    attributes from the calling thread:

        Signal mask (see sigprocmask() and pthread_sigmask())

        Pending signals (see sigpending())

    All other process attributes defined in this volume of IEEE Std 1003.1-2001
    shall be inherited in the new process image from the old process image. All
    other thread attributes defined in this volume of IEEE Std 1003.1-2001 shall
    be inherited in the initial thread in the new process image from the calling
    thread in the old process image. The inheritance of process or thread
    attributes not defined by this volume of IEEE Std 1003.1-2001 is
    implementation-defined.

    A call to any exec function from a process with more than one thread shall
    result in all threads being terminated and the new executable image being
    loaded and executed. No destructor functions or cleanup handlers shall be
    called.

    Upon successful completion, the exec functions shall mark for update the
    st_atime field of the file. If an exec function failed but was able to
    locate the process image file, whether the st_atime field is marked for
    update is unspecified. Should the exec function succeed, the process image
    file shall be considered to have been opened with open(). The corresponding
    close() shall be considered to occur at a time after this open, but before
    process termination or successful completion of a subsequent call to one of
    the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[]
    arrays of pointers and the strings to which those arrays point shall not be
    modified by a call to one of the exec functions, except as a consequence of
    replacing the process image.

    The saved resource limits in the new process image are set to be a copy of
    the process' corresponding hard and soft limits.

RETURN VALUE

    If one of the exec functions returns to the calling process image, an error
    has occurred; the return value shall be -1, and errno shall be set to
    indicate the error.

ERRORS

    The exec functions shall fail if:

    [E2BIG]
        The number of bytes used by the new process image's argument list and
        environment list is greater than the system-imposed limit of {ARG_MAX}
        bytes.
    [EACCES]
        Search permission is denied for a directory listed in the new process
        image file's path prefix, or the new process image file denies execution
        permission, or the new process image file is not a regular file and the
        implementation does not support execution of files of its type.
    [EINVAL]
        The new process image file has the appropriate permission and has a
        recognized executable binary format, but the system does not support
        execution of a file with this format.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path or file argument.
    [ENAMETOOLONG]
        The length of the path or file arguments exceeds {PATH_MAX} or a
        pathname component is longer than {NAME_MAX}.
    [ENOENT]
        A component of path or file does not name an existing file or path or
        file is an empty string.
    [ENOTDIR]
        A component of the new process image file's path prefix is not a
        directory.

    The exec functions, except for execlp() and execvp(), shall fail if:

    [ENOEXEC]
        The new process image file has the appropriate access permission but has
        an unrecognized format.

    The exec functions may fail if:

    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path or file argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The new process image requires more memory than is allowed by the
        hardware or system-imposed memory management constraints.
    [ETXTBSY]
        The new process image file is a pure procedure (shared text) file that
        is currently open for writing by some process.
*/
specification
void execv_spec( CallContext context, CString * path, List /* CString */ * argv )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists"    , process_state != NULL );
        REQ( "", "path point to pathname"  , path          != NULL );
        REQ( "", "argv correspond to array", argv          != NULL );

        /*
         * The argument argv is an array of character pointers to null-terminated strings.
         */
        REQ( "app.execv.01.01", "", true );

        /*
         * The application shall ensure that the last member of this array is a null
         * pointer.
         */
        REQ( "app.execv.01.02", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The value in argv[0] should point to a filename that is associated with the
         * process being started by one of the exec functions.
         */
        REQ( "app.execv.01.03",
             "argv[0] should point to a filename",
             T( size_List( argv ) >= 1 ) && T( equals( get_List( argv, 0 ), create_CString( "agent" ) ) )
           );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Path
    {
        if ( length_CString( path ) == 0 )
        {
            return { PathIsEmpty, "path is empty" };
        }
        else
        {
            return { PathIsNotEmpty, "path is not empty" };
        }
    }
    coverage C_Argv
    {
        if ( size_List( argv ) == 1 )
        {
            return { OnlyProgramName, "only program name" };
        }
        else
        {
            return { ProgramNameAndArguments, "program name and arguments" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    environ, execl, execv, execle, execve, execlp, execvp - execute a file

SYNOPSIS

    #include <unistd.h>

    extern char **environ;
    int execl(const char *path, const char *arg0, ... /*, (char *)0 * /);
    int execv(const char *path, char *const argv[]);
    int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]* /);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execlp(const char *file, const char *arg0, ... /*, (char *)0 * /);
    int execvp(const char *file, char *const argv[]);

DESCRIPTION

    The exec family of functions shall replace the current process image with a
    new process image. The new image shall be constructed from a regular,
    executable file called the new process image file. There shall be no return
    from a successful exec, because the calling process image is overlaid by the
    new process image.

    When a C-language program is executed as a result of this call, it shall be
    entered as a C-language function call as follows:

int main (int argc, char *argv[]);

    where argc is the argument count and argv is an array of character pointers
    to the arguments themselves. In addition, the following variable:

extern char **environ;

    is initialized as a pointer to an array of character pointers to the
    environment strings. The argv and environ arrays are each terminated by a
    null pointer. The null pointer terminating the argv array is not counted in
    argc.

    Conforming multi-threaded applications shall not use the environ variable to
    access or modify any environment variable while any other thread is
    concurrently modifying any environment variable. A call to any function
    dependent on any environment variable shall be considered a use of the
    environ variable to access that environment variable.

    The arguments specified by a program with one of the exec functions shall be
    passed on to the new process image in the corresponding main() arguments.

    The argument path points to a pathname that identifies the new process image
    file.

    The argument file is used to construct a pathname that identifies the new
    process image file. If the file argument contains a slash character, the
    file argument shall be used as the pathname for this file. Otherwise, the
    path prefix for this file is obtained by a search of the directories passed
    as the environment variable PATH (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Chapter 8, Environment Variables). If this environment
    variable is not present, the results of the search are
    implementation-defined.

    There are two distinct ways in which the contents of the process image file
    may cause the execution to fail, distinguished by the setting of errno to
    either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where
    the other members of the exec family of functions would fail and set errno
    to [ENOEXEC], the execlp() and execvp() functions shall execute a command
    interpreter and the environment of the executed command shall be as if the
    process invoked the sh utility using execl() as follows:

execl(<shell path>, arg0, file, arg1, ..., (char *)0);

    where <shell path> is an unspecified pathname for the sh utility, file is
    the process image file, and for execvp(), where arg0, arg1, and so on
    correspond to the values passed to execvp() in argv[0], argv[1], and so on.

    The arguments represented by arg0,... are pointers to null-terminated
    character strings. These strings shall constitute the argument list
    available to the new process image. The list is terminated by a null
    pointer. The argument arg0 should point to a filename that is associated
    with the process being started by one of the exec functions.

    The argument argv is an array of character pointers to null-terminated
    strings. The application shall ensure that the last member of this array is
    a null pointer. These strings shall constitute the argument list available
    to the new process image. The value in argv[0] should point to a filename
    that is associated with the process being started by one of the exec
    functions.

    The argument envp is an array of character pointers to null-terminated
    strings. These strings shall constitute the environment for the new process
    image. The envp array is terminated by a null pointer.

    For those forms not containing an envp pointer ( execl(), execv(), execlp(),
    and execvp()), the environment for the new process image shall be taken from
    the external variable environ in the calling process.

    The number of bytes available for the new process' combined argument and
    environment lists is {ARG_MAX}. It is implementation-defined whether null
    terminators, pointers, and/or any alignment bytes are included in this
    total.

    File descriptors open in the calling process image shall remain open in the
    new process image, except for those whose close-on- exec flag FD_CLOEXEC is
    set. For those file descriptors that remain open, all attributes of the open
    file description remain unchanged. For any file descriptor that is closed
    for this reason, file locks are removed as a result of the close as
    described in close(). Locks that are not removed by closing of file
    descriptors remain unchanged.

    If file descriptors 0, 1, and 2 would otherwise be closed after a successful
    call to one of the exec family of functions, and the new process image file
    has the set-user-ID or set-group-ID file mode bits set, and the ST_NOSUID
    bit is not set for the file system containing the new process image file,
    implementations may open an unspecified file for each of these file
    descriptors in the new process image.

    Directory streams open in the calling process image shall be closed in the
    new process image.

    The state of the floating-point environment in the new process image or in
    the initial thread of the new process image shall be set to the default.

    The state of conversion descriptors and message catalog descriptors in the
    new process image is undefined. For the new process image, the equivalent
    of:

setlocale(LC_ALL, "C")

    shall be executed at start-up.

    Signals set to the default action (SIG_DFL) in the calling process image
    shall be set to the default action in the new process image. Except for
    SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image
    shall be set to be ignored by the new process image. Signals set to be
    caught by the calling process image shall be set to the default action in
    the new process image (see <signal.h>). If the SIGCHLD signal is set to be
    ignored by the calling process image, it is unspecified whether the SIGCHLD
    signal is set to be ignored or to the default action in the new process
    image. After a successful call to any of the exec functions, alternate
    signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for
    all signals.

    After a successful call to any of the exec functions, any functions
    previously registered by atexit() or pthread_atfork() are no longer
    registered.

    If the ST_NOSUID bit is set for the file system containing the new process
    image file, then the effective user ID, effective group ID, saved
    set-user-ID, and saved set-group-ID are unchanged in the new process image.
    Otherwise, if the set-user-ID mode bit of the new process image file is set,
    the effective user ID of the new process image shall be set to the user ID
    of the new process image file. Similarly, if the set-group-ID mode bit of
    the new process image file is set, the effective group ID of the new process
    image shall be set to the group ID of the new process image file. The real
    user ID, real group ID, and supplementary group IDs of the new process image
    shall remain the same as those of the calling process image. The effective
    user ID and effective group ID of the new process image shall be saved (as
    the saved set-user-ID and the saved set-group-ID) for use by setuid().

    Any shared memory segments attached to the calling process image shall not
    be attached to the new process image.

    Any named semaphores open in the calling process shall be closed as if by
    appropriate calls to sem_close().

    Any blocks of typed memory that were mapped in the calling process are
    unmapped, as if munmap() was implicitly called to unmap them.

    Memory locks established by the calling process via calls to mlockall() or
    mlock() shall be removed. If locked pages in the address space of the
    calling process are also mapped into the address spaces of other processes
    and are locked by those processes, the locks established by the other
    processes shall be unaffected by the call by this process to the exec
    function. If the exec function fails, the effect on memory locks is
    unspecified.

    Memory mappings created in the process are unmapped before the address space
    is rebuilt for the new process image.

    When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of
    the new process image and the initial thread in that new process image are
    implementation-defined.

    When the calling process image uses the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the process policy and scheduling
    parameter settings shall not be changed by a call to an exec function. The
    initial thread in the new process image shall inherit the process scheduling
    policy and parameters. It shall have the default system contention scope,
    but shall inherit its allocation domain from the calling process image.

    Per-process timers created by the calling process shall be deleted before
    replacing the current process image with the new process image.

    All open message queue descriptors in the calling process shall be closed,
    as described in mq_close().

    Any outstanding asynchronous I/O operations may be canceled. Those
    asynchronous I/O operations that are not canceled shall complete as if the
    exec function had not yet occurred, but any associated signal notifications
    shall be suppressed. It is unspecified whether the exec function itself
    blocks awaiting such I/O completion. In no event, however, shall the new
    process image created by the exec function be affected by the presence of
    outstanding asynchronous I/O operations at the time the exec function is
    called. Whether any I/O is canceled, and which I/O may be canceled upon
    exec, is implementation-defined.

    The new process image shall inherit the CPU-time clock of the calling
    process image. This inheritance means that the process CPU-time clock of the
    process being exec-ed shall not be reinitialized or altered as a result of
    the exec function other than to reflect the time spent by the process
    executing the exec function itself.

    The initial value of the CPU-time clock of the initial thread of the new
    process image shall be set to zero.

    If the calling process is being traced, the new process image shall continue
    to be traced into the same trace stream as the original process image, but
    the new process image shall not inherit the mapping of trace event names to
    trace event type identifiers that was defined by calls to the
    posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions
    in the calling process image.

    If the calling process is a trace controller process, any trace streams that
    were created by the calling process shall be shut down as described in the
    posix_trace_shutdown() function.

    The thread ID of the initial thread in the new process image is unspecified.

    The size and location of the stack on which the initial thread in the new
    process image runs is unspecified.

    The initial thread in the new process image shall have its cancellation type
    set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
    PTHREAD_CANCEL_ENABLED.

    The initial thread in the new process image shall have all thread-specific
    data values set to NULL and all thread-specific data keys shall be removed
    by the call to exec without running destructors.

    The initial thread in the new process image shall be joinable, as if created
    with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

    The new process shall inherit at least the following attributes from the
    calling process image:

        Nice value (see nice())

        semadj values (see semop())

        Process ID

        Parent process ID

        Process group ID

        Session membership

        Real user ID

        Real group ID

        Supplementary group IDs

        Time left until an alarm clock signal (see alarm())

        Current working directory

        Root directory

        File mode creation mask (see umask())

        File size limit (see ulimit())

        Process signal mask (see sigprocmask())

        Pending signal (see sigpending())

        tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        Resource limits

        Controlling terminal

        Interval timers

    The initial thread of the new process shall inherit at least the following
    attributes from the calling thread:

        Signal mask (see sigprocmask() and pthread_sigmask())

        Pending signals (see sigpending())

    All other process attributes defined in this volume of IEEE Std 1003.1-2001
    shall be inherited in the new process image from the old process image. All
    other thread attributes defined in this volume of IEEE Std 1003.1-2001 shall
    be inherited in the initial thread in the new process image from the calling
    thread in the old process image. The inheritance of process or thread
    attributes not defined by this volume of IEEE Std 1003.1-2001 is
    implementation-defined.

    A call to any exec function from a process with more than one thread shall
    result in all threads being terminated and the new executable image being
    loaded and executed. No destructor functions or cleanup handlers shall be
    called.

    Upon successful completion, the exec functions shall mark for update the
    st_atime field of the file. If an exec function failed but was able to
    locate the process image file, whether the st_atime field is marked for
    update is unspecified. Should the exec function succeed, the process image
    file shall be considered to have been opened with open(). The corresponding
    close() shall be considered to occur at a time after this open, but before
    process termination or successful completion of a subsequent call to one of
    the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[]
    arrays of pointers and the strings to which those arrays point shall not be
    modified by a call to one of the exec functions, except as a consequence of
    replacing the process image.

    The saved resource limits in the new process image are set to be a copy of
    the process' corresponding hard and soft limits.

RETURN VALUE

    If one of the exec functions returns to the calling process image, an error
    has occurred; the return value shall be -1, and errno shall be set to
    indicate the error.

ERRORS

    The exec functions shall fail if:

    [E2BIG]
        The number of bytes used by the new process image's argument list and
        environment list is greater than the system-imposed limit of {ARG_MAX}
        bytes.
    [EACCES]
        Search permission is denied for a directory listed in the new process
        image file's path prefix, or the new process image file denies execution
        permission, or the new process image file is not a regular file and the
        implementation does not support execution of files of its type.
    [EINVAL]
        The new process image file has the appropriate permission and has a
        recognized executable binary format, but the system does not support
        execution of a file with this format.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path or file argument.
    [ENAMETOOLONG]
        The length of the path or file arguments exceeds {PATH_MAX} or a
        pathname component is longer than {NAME_MAX}.
    [ENOENT]
        A component of path or file does not name an existing file or path or
        file is an empty string.
    [ENOTDIR]
        A component of the new process image file's path prefix is not a
        directory.

    The exec functions, except for execlp() and execvp(), shall fail if:

    [ENOEXEC]
        The new process image file has the appropriate access permission but has
        an unrecognized format.

    The exec functions may fail if:

    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path or file argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The new process image requires more memory than is allowed by the
        hardware or system-imposed memory management constraints.
    [ETXTBSY]
        The new process image file is a pure procedure (shared text) file that
        is currently open for writing by some process.
*/
specification
void execve_spec( CallContext context, CString * path, List /* CString */ * argv, List /* CString */ * envp )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists"    , process_state != NULL );
        REQ( "", "path point to pathname"  , path          != NULL );
        REQ( "", "argv correspond to array", argv          != NULL );
        REQ( "", "envp correspond to array", envp          != NULL );

        /*
         * The argument argv is an array of character pointers to null-terminated strings.
         */
        REQ( "app.execve.01.01", "", true );

        /*
         * The application shall ensure that the last member of this array is a null
         * pointer.
         */
        REQ( "app.execve.01.02", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The value in argv[0] should point to a filename that is associated with the
         * process being started by one of the exec functions.
         */
        REQ( "app.execve.01.03",
             "argv[0] should point to a filename",
             T( size_List( argv ) >= 1 ) && T( equals( get_List( argv, 0 ), create_CString( "agent" ) ) )
           );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Path
    {
        if ( length_CString( path ) == 0 )
        {
            return { PathIsEmpty, "path is empty" };
        }
        else
        {
            return { PathIsNotEmpty, "path is not empty" };
        }
    }
    coverage C_Argv
    {
        if ( size_List( argv ) == 1 )
        {
            return { OnlyProgramName, "only program name" };
        }
        else
        {
            return { ProgramNameAndArguments, "program name and arguments" };
        }
    }
    coverage C_Envp
    {
        if ( isEmpty_List( envp ) )
        {
            return { EnvpIsEmpty, "envp is empty" };
        }
        else
        {
            return { EnvpIsNotEmpty, "envp is not empty" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    environ, execl, execv, execle, execve, execlp, execvp - execute a file

SYNOPSIS

    #include <unistd.h>

    extern char **environ;
    int execl(const char *path, const char *arg0, ... /*, (char *)0 * /);
    int execv(const char *path, char *const argv[]);
    int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]* /);
    int execve(const char *path, char *const argv[], char *const envp[]);
    int execlp(const char *file, const char *arg0, ... /*, (char *)0 * /);
    int execvp(const char *file, char *const argv[]);

DESCRIPTION

    The exec family of functions shall replace the current process image with a
    new process image. The new image shall be constructed from a regular,
    executable file called the new process image file. There shall be no return
    from a successful exec, because the calling process image is overlaid by the
    new process image.

    When a C-language program is executed as a result of this call, it shall be
    entered as a C-language function call as follows:

int main (int argc, char *argv[]);

    where argc is the argument count and argv is an array of character pointers
    to the arguments themselves. In addition, the following variable:

extern char **environ;

    is initialized as a pointer to an array of character pointers to the
    environment strings. The argv and environ arrays are each terminated by a
    null pointer. The null pointer terminating the argv array is not counted in
    argc.

    Conforming multi-threaded applications shall not use the environ variable to
    access or modify any environment variable while any other thread is
    concurrently modifying any environment variable. A call to any function
    dependent on any environment variable shall be considered a use of the
    environ variable to access that environment variable.

    The arguments specified by a program with one of the exec functions shall be
    passed on to the new process image in the corresponding main() arguments.

    The argument path points to a pathname that identifies the new process image
    file.

    The argument file is used to construct a pathname that identifies the new
    process image file. If the file argument contains a slash character, the
    file argument shall be used as the pathname for this file. Otherwise, the
    path prefix for this file is obtained by a search of the directories passed
    as the environment variable PATH (see the Base Definitions volume of IEEE
    Std 1003.1-2001, Chapter 8, Environment Variables). If this environment
    variable is not present, the results of the search are
    implementation-defined.

    There are two distinct ways in which the contents of the process image file
    may cause the execution to fail, distinguished by the setting of errno to
    either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where
    the other members of the exec family of functions would fail and set errno
    to [ENOEXEC], the execlp() and execvp() functions shall execute a command
    interpreter and the environment of the executed command shall be as if the
    process invoked the sh utility using execl() as follows:

execl(<shell path>, arg0, file, arg1, ..., (char *)0);

    where <shell path> is an unspecified pathname for the sh utility, file is
    the process image file, and for execvp(), where arg0, arg1, and so on
    correspond to the values passed to execvp() in argv[0], argv[1], and so on.

    The arguments represented by arg0,... are pointers to null-terminated
    character strings. These strings shall constitute the argument list
    available to the new process image. The list is terminated by a null
    pointer. The argument arg0 should point to a filename that is associated
    with the process being started by one of the exec functions.

    The argument argv is an array of character pointers to null-terminated
    strings. The application shall ensure that the last member of this array is
    a null pointer. These strings shall constitute the argument list available
    to the new process image. The value in argv[0] should point to a filename
    that is associated with the process being started by one of the exec
    functions.

    The argument envp is an array of character pointers to null-terminated
    strings. These strings shall constitute the environment for the new process
    image. The envp array is terminated by a null pointer.

    For those forms not containing an envp pointer ( execl(), execv(), execlp(),
    and execvp()), the environment for the new process image shall be taken from
    the external variable environ in the calling process.

    The number of bytes available for the new process' combined argument and
    environment lists is {ARG_MAX}. It is implementation-defined whether null
    terminators, pointers, and/or any alignment bytes are included in this
    total.

    File descriptors open in the calling process image shall remain open in the
    new process image, except for those whose close-on- exec flag FD_CLOEXEC is
    set. For those file descriptors that remain open, all attributes of the open
    file description remain unchanged. For any file descriptor that is closed
    for this reason, file locks are removed as a result of the close as
    described in close(). Locks that are not removed by closing of file
    descriptors remain unchanged.

    If file descriptors 0, 1, and 2 would otherwise be closed after a successful
    call to one of the exec family of functions, and the new process image file
    has the set-user-ID or set-group-ID file mode bits set, and the ST_NOSUID
    bit is not set for the file system containing the new process image file,
    implementations may open an unspecified file for each of these file
    descriptors in the new process image.

    Directory streams open in the calling process image shall be closed in the
    new process image.

    The state of the floating-point environment in the new process image or in
    the initial thread of the new process image shall be set to the default.

    The state of conversion descriptors and message catalog descriptors in the
    new process image is undefined. For the new process image, the equivalent
    of:

setlocale(LC_ALL, "C")

    shall be executed at start-up.

    Signals set to the default action (SIG_DFL) in the calling process image
    shall be set to the default action in the new process image. Except for
    SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image
    shall be set to be ignored by the new process image. Signals set to be
    caught by the calling process image shall be set to the default action in
    the new process image (see <signal.h>). If the SIGCHLD signal is set to be
    ignored by the calling process image, it is unspecified whether the SIGCHLD
    signal is set to be ignored or to the default action in the new process
    image. After a successful call to any of the exec functions, alternate
    signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for
    all signals.

    After a successful call to any of the exec functions, any functions
    previously registered by atexit() or pthread_atfork() are no longer
    registered.

    If the ST_NOSUID bit is set for the file system containing the new process
    image file, then the effective user ID, effective group ID, saved
    set-user-ID, and saved set-group-ID are unchanged in the new process image.
    Otherwise, if the set-user-ID mode bit of the new process image file is set,
    the effective user ID of the new process image shall be set to the user ID
    of the new process image file. Similarly, if the set-group-ID mode bit of
    the new process image file is set, the effective group ID of the new process
    image shall be set to the group ID of the new process image file. The real
    user ID, real group ID, and supplementary group IDs of the new process image
    shall remain the same as those of the calling process image. The effective
    user ID and effective group ID of the new process image shall be saved (as
    the saved set-user-ID and the saved set-group-ID) for use by setuid().

    Any shared memory segments attached to the calling process image shall not
    be attached to the new process image.

    Any named semaphores open in the calling process shall be closed as if by
    appropriate calls to sem_close().

    Any blocks of typed memory that were mapped in the calling process are
    unmapped, as if munmap() was implicitly called to unmap them.

    Memory locks established by the calling process via calls to mlockall() or
    mlock() shall be removed. If locked pages in the address space of the
    calling process are also mapped into the address spaces of other processes
    and are locked by those processes, the locks established by the other
    processes shall be unaffected by the call by this process to the exec
    function. If the exec function fails, the effect on memory locks is
    unspecified.

    Memory mappings created in the process are unmapped before the address space
    is rebuilt for the new process image.

    When the calling process image does not use the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of
    the new process image and the initial thread in that new process image are
    implementation-defined.

    When the calling process image uses the SCHED_FIFO, SCHED_RR, or
    SCHED_SPORADIC scheduling policies, the process policy and scheduling
    parameter settings shall not be changed by a call to an exec function. The
    initial thread in the new process image shall inherit the process scheduling
    policy and parameters. It shall have the default system contention scope,
    but shall inherit its allocation domain from the calling process image.

    Per-process timers created by the calling process shall be deleted before
    replacing the current process image with the new process image.

    All open message queue descriptors in the calling process shall be closed,
    as described in mq_close().

    Any outstanding asynchronous I/O operations may be canceled. Those
    asynchronous I/O operations that are not canceled shall complete as if the
    exec function had not yet occurred, but any associated signal notifications
    shall be suppressed. It is unspecified whether the exec function itself
    blocks awaiting such I/O completion. In no event, however, shall the new
    process image created by the exec function be affected by the presence of
    outstanding asynchronous I/O operations at the time the exec function is
    called. Whether any I/O is canceled, and which I/O may be canceled upon
    exec, is implementation-defined.

    The new process image shall inherit the CPU-time clock of the calling
    process image. This inheritance means that the process CPU-time clock of the
    process being exec-ed shall not be reinitialized or altered as a result of
    the exec function other than to reflect the time spent by the process
    executing the exec function itself.

    The initial value of the CPU-time clock of the initial thread of the new
    process image shall be set to zero.

    If the calling process is being traced, the new process image shall continue
    to be traced into the same trace stream as the original process image, but
    the new process image shall not inherit the mapping of trace event names to
    trace event type identifiers that was defined by calls to the
    posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions
    in the calling process image.

    If the calling process is a trace controller process, any trace streams that
    were created by the calling process shall be shut down as described in the
    posix_trace_shutdown() function.

    The thread ID of the initial thread in the new process image is unspecified.

    The size and location of the stack on which the initial thread in the new
    process image runs is unspecified.

    The initial thread in the new process image shall have its cancellation type
    set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to
    PTHREAD_CANCEL_ENABLED.

    The initial thread in the new process image shall have all thread-specific
    data values set to NULL and all thread-specific data keys shall be removed
    by the call to exec without running destructors.

    The initial thread in the new process image shall be joinable, as if created
    with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

    The new process shall inherit at least the following attributes from the
    calling process image:

        Nice value (see nice())

        semadj values (see semop())

        Process ID

        Parent process ID

        Process group ID

        Session membership

        Real user ID

        Real group ID

        Supplementary group IDs

        Time left until an alarm clock signal (see alarm())

        Current working directory

        Root directory

        File mode creation mask (see umask())

        File size limit (see ulimit())

        Process signal mask (see sigprocmask())

        Pending signal (see sigpending())

        tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        Resource limits

        Controlling terminal

        Interval timers

    The initial thread of the new process shall inherit at least the following
    attributes from the calling thread:

        Signal mask (see sigprocmask() and pthread_sigmask())

        Pending signals (see sigpending())

    All other process attributes defined in this volume of IEEE Std 1003.1-2001
    shall be inherited in the new process image from the old process image. All
    other thread attributes defined in this volume of IEEE Std 1003.1-2001 shall
    be inherited in the initial thread in the new process image from the calling
    thread in the old process image. The inheritance of process or thread
    attributes not defined by this volume of IEEE Std 1003.1-2001 is
    implementation-defined.

    A call to any exec function from a process with more than one thread shall
    result in all threads being terminated and the new executable image being
    loaded and executed. No destructor functions or cleanup handlers shall be
    called.

    Upon successful completion, the exec functions shall mark for update the
    st_atime field of the file. If an exec function failed but was able to
    locate the process image file, whether the st_atime field is marked for
    update is unspecified. Should the exec function succeed, the process image
    file shall be considered to have been opened with open(). The corresponding
    close() shall be considered to occur at a time after this open, but before
    process termination or successful completion of a subsequent call to one of
    the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[]
    arrays of pointers and the strings to which those arrays point shall not be
    modified by a call to one of the exec functions, except as a consequence of
    replacing the process image.

    The saved resource limits in the new process image are set to be a copy of
    the process' corresponding hard and soft limits.

RETURN VALUE

    If one of the exec functions returns to the calling process image, an error
    has occurred; the return value shall be -1, and errno shall be set to
    indicate the error.

ERRORS

    The exec functions shall fail if:

    [E2BIG]
        The number of bytes used by the new process image's argument list and
        environment list is greater than the system-imposed limit of {ARG_MAX}
        bytes.
    [EACCES]
        Search permission is denied for a directory listed in the new process
        image file's path prefix, or the new process image file denies execution
        permission, or the new process image file is not a regular file and the
        implementation does not support execution of files of its type.
    [EINVAL]
        The new process image file has the appropriate permission and has a
        recognized executable binary format, but the system does not support
        execution of a file with this format.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path or file argument.
    [ENAMETOOLONG]
        The length of the path or file arguments exceeds {PATH_MAX} or a
        pathname component is longer than {NAME_MAX}.
    [ENOENT]
        A component of path or file does not name an existing file or path or
        file is an empty string.
    [ENOTDIR]
        A component of the new process image file's path prefix is not a
        directory.

    The exec functions, except for execlp() and execvp(), shall fail if:

    [ENOEXEC]
        The new process image file has the appropriate access permission but has
        an unrecognized format.

    The exec functions may fail if:

    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path or file argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The new process image requires more memory than is allowed by the
        hardware or system-imposed memory management constraints.
    [ETXTBSY]
        The new process image file is a pure procedure (shared text) file that
        is currently open for writing by some process.
*/
specification
void execvp_spec( CallContext context, CString * file, List /* CString */ * argv )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists"    , process_state != NULL );
        REQ( "", "file point to filename"  , file          != NULL );
        REQ( "", "argv correspond to array", argv          != NULL );

        /*
         * The argument argv is an array of character pointers to null-terminated strings.
         */
        REQ( "app.execvp.01.01", "", true );

        /*
         * The application shall ensure that the last member of this array is a null
         * pointer.
         */
        REQ( "app.execvp.01.02", "", true );

        /*
         * These strings shall constitute the argument list available to the new process
         * image.
         *
         * The value in argv[0] should point to a filename that is associated with the
         * process being started by one of the exec functions.
         */
        REQ( "app.execvp.01.03",
             "argv[0] should point to a filename",
             T( size_List( argv ) >= 1 ) && T( equals( get_List( argv, 0 ), create_CString( "agent" ) ) )
           );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_File
    {
        if ( length_CString( file ) == 0 )
        {
            return { FileIsEmpty, "file is empty" };
        }
        else
        {
            return { FileIsNotEmpty, "file is not empty" };
        }
    }
    coverage C_Argv
    {
        if ( size_List( argv ) == 1 )
        {
            return { OnlyProgramName, "only program name" };
        }
        else
        {
            return { ProgramNameAndArguments, "program name and arguments" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    exit, _Exit, _exit - terminate a process

SYNOPSIS

    #include <stdlib.h>

    void exit(int status);
    void _Exit(int status);


    #include <unistd.h>
    void _exit(int status);

DESCRIPTION

    For exit() and _Exit(): The functionality described on this reference page
    is aligned with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume of IEEE
    Std 1003.1-2001 defers to the ISO C standard.

    The value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE, or any other
    value, though only the least significant 8 bits (that is, status & 0377)
    shall be available to a waiting parent process.

    The exit() function shall first call all functions registered by atexit(),
    in the reverse order of their registration, except that a function is called
    after any previously registered functions that had already been called at
    the time it was registered. Each function is called as many times as it was
    registered. If, during the call to any such function, a call to the
    longjmp() function is made that would terminate the call to the registered
    function, the behavior is undefined.

    If a function registered by a call to atexit() fails to return, the
    remaining registered functions shall not be called and the rest of the
    exit() processing shall not be completed. If exit() is called more than
    once, the behavior is undefined.

    The exit() function shall then flush all open streams with unwritten
    buffered data, close all open streams, and remove all files created by
    tmpfile(). Finally, control shall be terminated with the consequences
    described below.

    The _Exit() and _exit() functions shall be functionally equivalent.

    The _Exit() and _exit() functions shall not call functions registered with
    atexit() nor any registered signal handlers. Whether open streams are
    flushed or closed, or temporary files are removed is implementation-defined.
    Finally, the calling process is terminated with the consequences described
    below.

    These functions shall terminate the calling process with the following
    consequences:

    Note:

        These consequences are all extensions to the ISO C standard and are not
        further CX shaded. However, XSI extensions are shaded.

        All of the file descriptors, directory streams, conversion descriptors,
        and message catalog descriptors open in the calling process shall be
        closed.

        If the parent process of the calling process is executing a wait() or
        waitpid(), and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD to
        SIG_IGN, it shall be notified of the calling process' termination and
        the low-order eight bits (that is, bits 0377) of status shall be made
        available to it. If the parent is not waiting, the child's status shall
        be made available to it when the parent subsequently executes wait() or
        waitpid().
        The semantics of the waitid() function shall be equivalent to wait().

        If the parent process of the calling process is not executing a wait()
        or waitpid(), and has neither set its SA_NOCLDWAIT flag nor set SIGCHLD
        to SIG_IGN, the calling process shall be transformed into a zombie
        process. A zombie process is an inactive process and it shall be deleted
        at some later time when its parent process executes wait() or waitpid().
        The semantics of the waitid() function shall be equivalent to wait().

        Termination of a process does not directly terminate its children. The
        sending of a SIGHUP signal as described below indirectly terminates
        children in some circumstances.
        Either:
        If the implementation supports the SIGCHLD signal, a SIGCHLD shall be
        sent to the parent process.
        Or:
        If the parent process has set its SA_NOCLDWAIT flag, or set SIGCHLD to
        SIG_IGN, the status shall be discarded, and the lifetime of the calling
        process shall end immediately. If SA_NOCLDWAIT is set, it is
        implementation-defined whether a SIGCHLD signal is sent to the parent
        process.

        The parent process ID of all of the calling process' existing child
        processes and zombie processes shall be set to the process ID of an
        implementation-defined system process. That is, these processes shall be
        inherited by a special system process.

        Each attached shared-memory segment is detached and the value of
        shm_nattch (see shmget()) in the data structure associated with its
        shared memory ID shall be decremented by 1.

        For each semaphore for which the calling process has set a semadj value
        (see semop() ), that value shall be added to the semval of the specified
        semaphore.

        If the process is a controlling process, the SIGHUP signal shall be sent
        to each process in the foreground process group of the controlling
        terminal belonging to the calling process.

        If the process is a controlling process, the controlling terminal
        associated with the session shall be disassociated from the session,
        allowing it to be acquired by a new controlling process.

        If the exit of the process causes a process group to become orphaned,
        and if any member of the newly-orphaned process group is stopped, then a
        SIGHUP signal followed by a SIGCONT signal shall be sent to each process
        in the newly-orphaned process group.

        All open named semaphores in the calling process shall be closed as if
        by appropriate calls to sem_close().

        Any memory locks established by the process via calls to mlockall() or
        mlock() shall be removed. If locked pages in the address space of the
        calling process are also mapped into the address spaces of other
        processes and are locked by those processes, the locks established by
        the other processes shall be unaffected by the call by this process to
        _Exit() or _exit().

        Memory mappings that were created in the process shall be unmapped
        before the process is destroyed.

        Any blocks of typed memory that were mapped in the calling process shall
        be unmapped, as if munmap() was implicitly called to unmap them.

        All open message queue descriptors in the calling process shall be
        closed as if by appropriate calls to mq_close().

        Any outstanding cancelable asynchronous I/O operations may be canceled.
        Those asynchronous I/O operations that are not canceled shall complete
        as if the _Exit() or _exit() operation had not yet occurred, but any
        associated signal notifications shall be suppressed. The _Exit() or
        _exit() operation may block awaiting such I/O completion. Whether any
        I/O is canceled, and which I/O may be canceled upon _Exit() or _exit(),
        is implementation-defined.

        Threads terminated by a call to _Exit() or _exit() shall not invoke
        their cancellation cleanup handlers or per-thread data destructors.

        If the calling process is a trace controller process, any trace streams
        that were created by the calling process shall be shut down as described
        by the posix_trace_shutdown() function, and any process' mapping of
        trace event names to trace event type identifiers built for these trace
        streams may be deallocated.

RETURN VALUE

    These functions do not return.

ERRORS

    No errors are defined.
*/
specification
void exit_spec( CallContext context, IntT status )
{
    IntTObj * exitFailure; // EXIT_FAILURE

    pre
    {
        // verbose( "exit_spec : status %d\n", status );
        /* [Local variable initialization] */
        exitFailure = readIntValueByName( context, "EXIT_FAILURE" );

        /* [Consistency of test suite] */
        REQ( "", "Value for EXIT_FAILURE is known", exitFailure != NULL );

        /*
         * If, during the call to any such function, a call to the longjmp() function is
         * made that would terminate the call to the registered function, the behavior is
         * undefined.
         */
        REQ( "app.exit.01", "", TODO_REQ() );

        /*
         * If exit() is called more than once, the behavior is undefined.
         */
        REQ( "app.exit.02", "", TODO_REQ() );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            // verbose( "exit_spec : Process with high priority\n", status );
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            // verbose( "exit_spec : Process with low priority\n", status );
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            // verbose( "exit_spec : Process with unknown priority\n", status );
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Status
    {
        if ( status == SUT_EXIT_SUCCESS )
        {
            return { StatusIsExitSuccess, "status is EXIT_SUCCESS" };
        }
        else if ( status == * exitFailure )
        {
            return { StatusIsExitFailure, "status is EXIT_FAILURE" };
        }
        else if ( status <= 0xFF )
        {
            return { StatusIsNotGreaterThanFF, "status is not greater than 0xFF" };
        }
        else
        {
            return { StatusIsGreaterThanFF, "status is greater than 0xFF" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    fork - create a new process

SYNOPSIS

    #include <unistd.h>
    pid_t fork(void);

DESCRIPTION

    The fork() function shall create a new process. The new process (child
    process) shall be an exact copy of the calling process (parent process)
    except as detailed below:

        * The child process shall have a unique process ID.

        * The child process ID also shall not match any active process group ID.

        * The child process shall have a different parent process ID, which
          shall be the process ID of the calling process.

        * The child process shall have its own copy of the parent's file
          descriptors. Each of the child's file descriptors shall refer to the
          same open file description with the corresponding file descriptor of
          the parent.

        * The child process shall have its own copy of the parent's open
          directory streams. Each open directory stream in the child process may
          share directory stream positioning with the corresponding directory
          stream of the parent.

        * The child process shall have its own copy of the parent's message
          catalog descriptors.

        * The child process' values of tms_utime, tms_stime, tms_cutime, and
          tms_cstime shall be set to 0.

        * The time left until an alarm clock signal shall be reset to zero, and
          the alarm, if any, shall be canceled; see alarm().

        * All semadj values shall be cleared.

        * File locks set by the parent process shall not be inherited by the
          child process.

        * The set of signals pending for the child process shall be initialized
          to the empty set.

        * Interval timers shall be reset in the child process.

        * Any semaphores that are open in the parent process shall also be open
          in the child process.

        * The child process shall not inherit any address space memory locks
          established by the parent process via calls to mlockall() or mlock().

        * Memory mappings created in the parent shall be retained in the child
          process. MAP_PRIVATE mappings inherited from the parent shall also be
          MAP_PRIVATE mappings in the child, and any modifications to the data
          in these mappings made by the parent prior to calling fork() shall be
          visible to the child. Any modifications to the data in MAP_PRIVATE
          mappings made by the parent after fork() returns shall be visible only
          to the parent. Modifications to the data in MAP_PRIVATE mappings made
          by the child shall be visible only to the child.

        * For the SCHED_FIFO and SCHED_RR scheduling policies, the child process
          shall inherit the policy and priority settings of the parent process
          during a fork() function. For other scheduling policies, the policy
          and priority settings on fork() are implementation-defined.

        * Per-process timers created by the parent shall not be inherited by the
          child process.

        * The child process shall have its own copy of the message queue
          descriptors of the parent. Each of the message descriptors of the
          child shall refer to the same open message queue description as the
          corresponding message descriptor of the parent.

        * No asynchronous input or asynchronous output operations shall be
          inherited by the child process.

        * A process shall be created with a single thread. If a multi-threaded
          process calls fork(), the new process shall contain a replica of the
          calling thread and its entire address space, possibly including the
          states of mutexes and other resources. Consequently, to avoid errors,
          the child process may only execute async-signal-safe operations until
          such time as one of the exec functions is called. Fork handlers may be
          established by means of the pthread_atfork() function in order to
          maintain application invariants across fork() calls.

          When the application calls fork() from a signal handler and any of the
          fork handlers registered by pthread_atfork() calls a function that is
          not asynch-signal-safe, the behavior is undefined.

        * If the Trace option and the Trace Inherit option are both supported:

          If the calling process was being traced in a trace stream that had its
          inheritance policy set to POSIX_TRACE_INHERITED, the child process
          shall be traced into that trace stream, and the child process shall
          inherit the parent's mapping of trace event names to trace event type
          identifiers. If the trace stream in which the calling process was
          being traced had its inheritance policy set to
          POSIX_TRACE_CLOSE_FOR_CHILD, the child process shall not be traced
          into that trace stream. The inheritance policy is set by a call to the
          posix_trace_attr_setinherited() function.

        * If the Trace option is supported, but the Trace Inherit option is not
          supported:

          The child process shall not be traced into any of the trace streams of
          its parent process.

        * If the Trace option is supported, the child process of a trace
          controller process shall not control the trace streams controlled by
          its parent process.

        * The initial value of the CPU-time clock of the child process shall be
          set to zero.

        * The initial value of the CPU-time clock of the single thread of the
          child process shall be set to zero.

    All other process characteristics defined by IEEE Std 1003.1-2001 shall be
    the same in the parent and child processes. The inheritance of process
    characteristics not defined by IEEE Std 1003.1-2001 is unspecified by IEEE
    Std 1003.1-2001.

    After fork(), both the parent and the child processes shall be capable of
    executing independently before either one terminates.

RETURN VALUE

    Upon successful completion, fork() shall return 0 to the child process and
    shall return the process ID of the child process to the parent process. Both
    processes shall continue to execute from the fork() function. Otherwise, -1
    shall be returned to the parent process, no child process shall be created,
    and errno shall be set to indicate the error.

ERRORS

    The fork() function shall fail if:

    [EAGAIN]
        The system lacked the necessary resources to create another process, or
        the system-imposed limit on the total number of processes under
        execution system-wide or by a single user {CHILD_MAX} would be exceeded.

    The fork() function may fail if:

    [ENOMEM]
        Insufficient storage space is available.
*/
specification
void fork_spec( CallContext context )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    forkpty -- Create a new process attached to an available pseudo-terminal

SYNOPSIS

    #include <pty.h>
    int forkpty(int * amaster, char * name, struct termios * termp,
    struct winsize * winp);

DESCRIPTION

    The forkpty() function shall find and open a pseudo-terminal device pair in
    the same manner as the openpty() function. If a pseudo-terminal is
    available, forkpty() shall create a new process in the same manner as the
    fork() function, and prepares the new process for login in the same manner
    as login_tty().

    If termp is not null, it shall refer to a termios structure that shall be
    used to initialize the characteristics of the slave device. If winp is not
    null, it shall refer to a winsize structure used to initialize the window
    size of the slave device.

RETURN VALUE

    On success, the parent process shall return the process id of the child, and
    the child shall return 0. On error, no new process shall be created, -1
    shall be returned, and errno shall be set appropriately. On success, the
    parent process shall receive the file descriptor of the master side of the
    pseudo-terminal in the location referenced by amaster, and, if name is not
    NULL, the filename of the slave device in name.

ERRORS

    [EAGAIN]
        Unable to create a new process.

    [ENOENT]
        There are no available pseudo-terminals.

    [ENOMEM]
        Insufficient memory was available.
*/
specification
void forkpty_spec( CallContext context )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /*
         * If termp is not null, it shall refer to a termios structure that shall be used
         * to initialize the characteristics of the slave device.
         */
        REQ("app.forkpty.01", "", TODO_REQ());

        /*
         * If winp is not null, it shall refer to a winsize structure used to initialize
         * the window size of the slave device.
         */
        REQ("app.forkpty.02", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    pclose - close a pipe stream to or from a process

SYNOPSIS

    #include <stdio.h>
    int pclose(FILE *stream);

DESCRIPTION

    The pclose() function shall close a stream that was opened by popen(), wait
    for the command to terminate, and return the termination status of the
    process that was running the command language interpreter. However, if a
    call caused the termination status to be unavailable to pclose(), then
    pclose() shall return -1 with errno set to [ECHILD] to report this
    situation. This can happen if the application calls one of the following
    functions:

        wait()

        waitpid() with a pid argument less than or equal to 0 or equal to the process
        ID of the command line interpreter

        Any other function not defined in this volume of IEEE Std 1003.1-2001
        that could do one of the above

    In any case, pclose() shall not return before the child process created by
    popen() has terminated.

    If the command language interpreter cannot be executed, the child
    termination status returned by pclose() shall be as if the command language
    interpreter terminated using exit(127) or _exit(127).

    The pclose() function shall not affect the termination status of any child
    of the calling process other than the one created by popen() for the
    associated stream.

    If the argument stream to pclose() is not a pointer to a stream created by
    popen(), the result of pclose() is undefined.

RETURN VALUE

    Upon successful return, pclose() shall return the termination status of the
    command language interpreter. Otherwise, pclose() shall return -1 and set
    errno to indicate the error.

ERRORS

    The pclose() function shall fail if:

    [ECHILD]
        The status of the child process could not be obtained, as described
        above.
*/
specification typedef struct PcloseCall PcloseCall = {};

PcloseCall * create_PcloseCall( CallContext context, FILETPtr stream )
{
    return create( & type_PcloseCall, context, stream );
}

specification
void pclose_spec( CallContext context, FILETPtr stream )
{
    pre
    {
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /*
         * If the argument stream to pclose() is not a pointer to a stream created by
         * popen(), the result of pclose() is undefined.
         */
        REQ( "app.pclose.01", "the argument stream to pclose() is a pointer to a stream created by popen()",
                              contains_Set( process_state->pipesFromPopen, create_VoidTPtrObj( stream ) )
           );

        return true;
    }
    coverage C
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        return true;
    }
}

void onPclose( CallContext context, FILETPtr stream )
{
    startBlockedCall( context, create_PcloseCall( context, stream ) );
}

specification typedef struct PcloseReturnType PcloseReturnType = {};

PcloseReturnType * create_PcloseReturnType(
    CallContext   context,
    IntT          returned_value,
    ErrorCode   * error_code
)
{
    return create(&type_PcloseReturnType,
        context,
        returned_value,
        error_code);
}

reaction PcloseReturnType * pclose_return( void )
{
    post
    {
        CallContext   context     = pclose_return->context       ;
        IntT          pclose_spec = pclose_return->returned_value;
        ErrorCode   * errno       = pclose_return->error_code    ;

        PcloseCall * blocked_call = findBlockedCall( @getBlockedCalls(), context );
        FILETPtr stream = blocked_call->stream;

        /*
         * [Upon successful return, pclose() shall return the termination status of the
         * command language interpreter.]
         * Otherwise, pclose() shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_PCLOSE, "pclose.05.02", pclose_spec == -1, * errno )
            /*
             * The pclose() function shall fail if:
             *
             * [ECHILD]
             * The status of the child process could not be obtained, as described above.
             */
            ERROR_SHALL(POSIX_PCLOSE, ECHILD, "pclose.06.01", TODO_ERR(ECHILD) )
        ERROR_END()

        /*
         * The pclose() function shall
         *
         * close a stream that was opened by popen()
         */
        REQ("pclose.01.01", "", TODO_REQ());

        /*
         * The pclose() function shall
         *
         * wait for the command to terminate
         */
        REQ("pclose.01.02", "", TODO_REQ());

        /*
         * The pclose() function shall
         *
         * return the termination status of the process that was running the command
         * language interpreter
         */
        REQ("pclose.01.03", "", TODO_REQ());

        /*
         * if a call caused the termination status to be unavailable to pclose(), then
         * pclose() shall return -1 with errno set to [ECHILD] to report this situation.
         * This can happen if the application calls one of the following functions:
         *
         * wait()
         */
        REQ("pclose.07.01", "", TODO_REQ());

        /*
         * if a call caused the termination status to be unavailable to pclose(), then
         * pclose() shall return -1 with errno set to [ECHILD] to report this situation.
         * This can happen if the application calls one of the following functions:
         *
         * waitpid() with a pid argument less than or equal to 0 or equal to the process
         * ID of the command line interpreter
         */
        REQ("pclose.07.02", "", TODO_REQ());

        /*
         * if a call caused the termination status to be unavailable to pclose(), then
         * pclose() shall return -1 with errno set to [ECHILD] to report this situation.
         * This can happen if the application calls one of the following functions:
         *
         * Any other function not defined in this volume of IEEE Std 1003.1-2001
         * that could do one of the above
         */
        REQ("pclose.07.03", "", TODO_REQ());

        /*
         * In any case, pclose() shall not return before the child process created by
         * popen() has terminated.
         */
        REQ("pclose.02", "", TODO_REQ());

        /*
         * If the command language interpreter cannot be executed, the child termination
         * status returned by pclose() shall be as if the command language interpreter
         * terminated using exit(127) or _exit(127).
         */
        REQ("pclose.03", "", TODO_REQ());

        /*
         * The pclose() function shall not affect the termination status of any child of
         * the calling process other than the one created by popen() for the associated
         * stream.
         */
        REQ("pclose.04", "", TODO_REQ());

        /*
         * Upon successful return, pclose() shall return the termination status of the
         * command language interpreter.
         */
        REQ("pclose.05.01", "", TODO_REQ());

        return true;
    }
}

void onPcloseReturn( CallContext context, IntT pclose_spec, ErrorCode * error_code )
{
    PcloseCall * blocked_call = finishBlockedCall( context );
    ProcessState * processState = getProcessState_CallContext( context );
    if ( pclose_spec != -1 ) { remove_Set( processState->pipesFromPopen, get_Set( processState->pipesFromPopen, 0 ) ); }
    // verbose( "onPcloseReturn : size_Set( processState->pipesFromPopen ) is %d\n", size_Set( processState->pipesFromPopen ) );
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    popen - initiate pipe streams to or from a process

SYNOPSIS

    #include <stdio.h>
    FILE *popen(const char *command, const char *mode);

DESCRIPTION

    The popen() function shall execute the command specified by the string
    command. It shall create a pipe between the calling program and the executed
    command, and shall return a pointer to a stream that can be used to either
    read from or write to the pipe.

    The environment of the executed command shall be as if a child process were
    created within the popen() call using the fork() function, and the child
    invoked the sh utility using the call:

    execl(shell path, "sh", "-c", command, (char *)0);

    where shell path is an unspecified pathname for the sh utility.

    The popen() function shall ensure that any streams from previous popen()
    calls that remain open in the parent process are closed in the new child
    process.

    The mode argument to popen() is a string that specifies I/O mode:

    If mode is r, when the child process is started, its file descriptor
    STDOUT_FILENO shall be the writable end of the pipe, and the file descriptor
    fileno(stream) in the calling process, where stream is the stream pointer
    returned by popen(), shall be the readable end of the pipe.

    If mode is w, when the child process is started its file descriptor
    STDIN_FILENO shall be the readable end of the pipe, and the file descriptor
    fileno(stream) in the calling process, where stream is the stream pointer
    returned by popen(), shall be the writable end of the pipe.

    If mode is any other value, the result is undefined.

    After popen(), both the parent and the child process shall be capable of
    executing independently before either terminates.

    Pipe streams are byte-oriented.

RETURN VALUE

    Upon successful completion, popen() shall return a pointer to an open stream
    that can be used to read or write to the pipe. Otherwise, it shall return a
    null pointer and may set errno to indicate the error.

ERRORS

    The popen() function may fail if:

    [EMFILE]
        {FOPEN_MAX} or {STREAM_MAX} streams are currently open in the calling
        process.

    [EINVAL]
        The mode argument is invalid.

    The popen() function may also set errno values as described by fork() or
    pipe().
*/
specification typedef struct PopenCall PopenCall = {};

PopenCall * create_PopenCall( CallContext context, CString * command, CString * mode )
{
    return create( & type_PopenCall, context, command, mode );
}

specification
void popen_spec( CallContext context, CString * Command, CString * mode )
{
    pre
    {
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /*
         * The mode argument to popen() is a string that specifies I/O mode:
         *
         * If mode is any other value, the result is undefined.
         */
        REQ( "app.popen.04.03", "If mode is not r or w, the result is undefined",
                                equals( create_CString( "r" ), mode ) || equals( create_CString( "w" ), mode )
           );

        return true;
    }
    coverage C
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        return true;
    }
}

void onPopen( CallContext context, CString * command, CString * mode )
{
    startBlockedCall( context, create_PopenCall( context, command, mode ) );
}

specification typedef struct PopenReturnType PopenReturnType = {};

PopenReturnType * create_PopenReturnType(
    CallContext   context,
    FILETPtr      returned_value,
    ErrorCode   * error_code
)
{
    return create(&type_PopenReturnType,
        context,
        returned_value,
        error_code);
}

reaction PopenReturnType * popen_return( void )
{
    post
    {
        CallContext   context    = popen_return->context       ;
        FILETPtr      popen_spec = popen_return->returned_value;
        ErrorCode   * errno      = popen_return->error_code    ;

        PopenCall * blocked_call = findBlockedCall( @getBlockedCalls(), context );
        CString * command = blocked_call->command;
        CString * mode    = blocked_call->mode   ;

        /*
         * [Upon successful completion, popen() shall return a pointer to an open stream
         * that can be used to read or write to the pipe.]
         * Otherwise, it shall return a null pointer and may set errno to indicate the
         * error.
         */
        ERROR_BEGIN( POSIX_POPEN, "popen.07.02", isNULL_VoidTPtr( popen_spec ), * errno )
            /*
             * The popen() function may fail if:
             *
             * [EMFILE]
             * {FOPEN_MAX} or {STREAM_MAX} streams are currently open in the calling process.
             */
            ERROR_MAY(POSIX_POPEN, EMFILE, "popen.08.01", TODO_ERR(EMFILE))

            /*
             * The popen() function may fail if:
             *
             * [EINVAL]
             * The mode argument is invalid.
             */
            ERROR_MAY(POSIX_POPEN, EINVAL, "popen.08.02", TODO_ERR(EINVAL))

            if ( isNULL_VoidTPtr( popen_spec ) )
            {
                /*
                 * The popen() function may also set errno values as described by fork() or pipe().
                 */
                REQ("popen.09", "", TODO_REQ());
            }
        ERROR_END()

        /*
         * The popen() function shall
         *
         * execute the command specified by the string command
         */
        REQ("popen.01.01", "", TODO_REQ());

        /*
         * The popen() function shall
         *
         * create a pipe between the calling program and the executed command
         */
        REQ("popen.01.02", "", TODO_REQ());

        /*
         * The popen() function shall
         *
         * return a pointer to a stream that can be used to either read from or write to
         * the pipe
         */
        REQ("popen.01.03", "", TODO_REQ());

        /*
         * The environment of the executed command shall be as if a child process were
         * created within the popen() call using the fork() function, and the child
         * invoked the sh utility using the call:
         * execl(shell path, "sh", "-c", command, (char *)0);
         * where shell path is an unspecified pathname for the sh utility.
         */
        REQ("popen.02", "", TODO_REQ());

        /*
         * The popen() function shall ensure that any streams from previous popen() calls
         * that remain open in the parent process are closed in the new child process.
         */
        REQ("popen.03", "", TODO_REQ());

        /*
         * The mode argument to popen() is a string that specifies I/O mode:
         *
         * If mode is r, when the child process is started, its file descriptor
         * STDOUT_FILENO shall be the writable end of the pipe, and the file descriptor
         * fileno(stream) in the calling process, where stream is the stream pointer
         * returned by popen(), shall be the readable end of the pipe.
         */
        REQ("popen.04.01", "", TODO_REQ());

        /*
         * The mode argument to popen() is a string that specifies I/O mode:
         *
         * If mode is w, when the child process is started its file descriptor
         * STDIN_FILENO shall be the readable end of the pipe, and the file descriptor
         * fileno(stream) in the calling process, where stream is the stream pointer
         * returned by popen(), shall be the writable end of the pipe.
         */
        REQ("popen.04.02", "", TODO_REQ());

        /*
         * After popen(), both the parent and the child process shall be capable of
         * executing independently before either terminates.
         */
        REQ("popen.05", "", TODO_REQ());

        /*
         * Pipe streams are byte-oriented.
         */
        REQ("popen.06", "", TODO_REQ());

        /*
         * Upon successful completion, popen() shall return a pointer to an open stream
         * that can be used to read or write to the pipe.
         */
        REQ("popen.07.01", "", TODO_REQ());

        return true;
    }
}

void onPopenReturn( CallContext context, FILETPtr popen_spec, ErrorCode * error_code )
{
    PopenCall * blocked_call = finishBlockedCall( context );
    ProcessState * processState = getProcessState_CallContext( context );
    if ( ! isNULL_VoidTPtr( popen_spec ) ) { add_Set( processState->pipesFromPopen, create_VoidTPtrObj( popen_spec ) ); }
    // verbose( "onPopenReturn : size_Set( processState->pipesFromPopen ) is %d\n", size_Set( processState->pipesFromPopen ) );
}

/*
 * [
 * return_from_main_spec
 *
 * As required by the ISO C standard, using return from main() has the same
 * behavior (other than with respect to language scope issues) as calling exit()
 * with the returned value. Reaching the end of the main() function has the same
 * behavior as calling exit(0).
 * ]
 */
specification
void return_from_main_spec( CallContext context, IntT status )
{
    IntTObj * exitFailure; // EXIT_FAILURE

    pre
    {
        /* [Local variable initialization] */
        exitFailure = readIntValueByName( context, "EXIT_FAILURE" );

        /* [Consistency of test suite] */
        REQ( "", "Value for EXIT_FAILURE is known", exitFailure != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Status
    {
        if ( status == SUT_EXIT_SUCCESS )
        {
            return { StatusIsExitSuccess, "status is EXIT_SUCCESS" };
        }
        else if ( status == * exitFailure )
        {
            return { StatusIsExitFailure, "status is EXIT_FAILURE" };
        }
        else if ( status <= 0xFF )
        {
            return { StatusIsNotGreaterThanFF, "status is not greater than 0xFF" };
        }
        else
        {
            return { StatusIsGreaterThanFF, "status is greater than 0xFF" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright  2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    system - issue a command

SYNOPSIS

    #include <stdlib.h>

    int system(const char *command);

DESCRIPTION

    The functionality described on this reference page is aligned
    with the ISO C standard. Any conflict between the requirements
    described here and the ISO C standard is unintentional. This volume
    of IEEE Std 1003.1-2001 defers to the ISO C standard.

    If command is a null pointer, the system() function shall determine
    whether the host environment has a command processor.  If command is
    not a null pointer, the system() function shall pass the string pointed
    to by command to that command processor to be executed in an
    implementation-defined manner; this might then cause the program calling
    system() to behave in a non-conforming manner or to terminate.



    The environment of the executed command shall be as if a child process
    were created using fork(), and the child process invoked the sh utility
    using execl() as follows:

    execl(<shell path>, "sh", "-c", command, (char *)0);

    where <shell path> is an unspecified pathname for the sh utility.

    The system() function shall ignore the SIGINT and SIGQUIT signals, and shall
    block the SIGCHLD signal, while waiting for the command to terminate.  If
    this might cause the application to miss a signal that would have killed it,
    then the application should examine the return value from system() and take
    whatever action is appropriate to the application if the command terminated
    due to receipt of a signal.

    The system() function shall not affect the termination status of any child
    of the calling processes other than the process or processes it itself creates.

    The system() function shall not return until the child process has terminated.

RETURN VALUE

    If command is a null pointer, system() shall return non-zero to indicate that
    a command processor is available, or zero if none is available.
    The system() function shall always return non-zero when command is NULL.

    If command is not a null pointer, system() shall return the termination status
    of the command language interpreter in the format specified by waitpid().  The
    termination status shall be as defined for the sh utility; otherwise, the
    termination status is unspecified.  If some error prevents the command language
    interpreter from executing after the child process is created, the return value
    from system() shall be as if the command language interpreter had terminated
    using exit(127) or _exit(127).  If a child process cannot be created, or if the
    termination status for the command language interpreter cannot be obtained,
    system() shall return -1 and set errno to indicate the error.

ERRORS

    The system() function may set errno values as described by fork().

    In addition, system() may fail if:

    [ECHILD]
    The status of the child process created by system() is no longer available.
*/
specification
IntT system_spec( CallContext context, CString *cmd, ErrorCode *errno )
{
  pre
  {
    return true;
  }
  coverage C
  {
    return { TheOnlyBranch, "The only branch" };
  }
  post
  {
       /*
         * If command is a null pointer, the system() function shall determine whether the
         * host environment has a command processor.
         */
        REQ("system.02", "", TODO_REQ());
        /*
         * If command is not a null pointer, the system() function shall pass the string
         * pointed to by command to that command processor to be executed in an
         * implementation-defined manner; this might then cause the program calling
         * system() to behave in a non-conforming manner or to terminate.
         */
        REQ("system.03", "", TODO_REQ());
        /*
         * The environment of the executed command shall be as if a child process were
         * created using fork(), and the child process invoked the sh utility using execl()
         * as follows:
         * execl(<shell path>, "sh", "-c", command, (char *)0);
         * where <shell path> is an unspecified pathname for the sh utility.
         */
        REQ("system.04", "", TODO_REQ());
        /*
         * The system() function shall ignore the SIGINT and SIGQUIT signals, and shall
         * block the SIGCHLD signal, while waiting for the command to terminate.
         */
        REQ("system.05", "", TODO_REQ());
        /*
         * If this might cause the application to miss a signal that would have killed it,
         * then the application should examine the return value from system() and take
         * whatever action is appropriate to the application if the command terminated due
         * to receipt of a signal.
         */
        REQ("system.06", "", TODO_REQ());
        /*
         * The system() function shall not affect the termination status of any child of
         * the calling processes other than the process or processes it itself creates.
         */
        REQ("system.07", "", TODO_REQ());
        /*
         * The system() function shall not return until the child process has terminated.
         */
        REQ("system.08", "", TODO_REQ());
        /*
         * If command is a null pointer, system() shall return non-zero to indicate that a
         * command processor is available, or zero if none is available.
         */
        REQ("system.09", "", TODO_REQ());
        /*
         * [CX] The system() function shall always return non-zero when command is NULL.
         */
        REQ("system.10", "", TODO_REQ());
        /*
         * [CX] If command is not a null pointer, system() shall return the termination
         * status of the command language interpreter in the format specified by waitpid().
         */
        REQ("system.11", "", TODO_REQ());
        /*
         * The termination status shall be as defined for the sh utility; otherwise, the
         * termination status is unspecified.
         */
        REQ("system.12", "", TODO_REQ());
        /*
         * If some error prevents the command language interpreter from executing after
         * the child process is created, the return value from system() shall be as if the
         * command language interpreter had terminated using exit(127) or _exit(127).
         */
        REQ("system.13", "", TODO_REQ());
        /*
         * If a child process cannot be created, or if the termination status for the
         * command language interpreter cannot be obtained, system() shall return -1 and
         * set errno to indicate the error.
         */
        REQ("system.14", "", TODO_REQ());
        /*
         * [CX] The system() function may set errno values as described by fork().
         */
        REQ("system.15", "", TODO_REQ());
        return true;
  }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    vfork - create a new process; share virtual memory

SYNOPSIS

    #include <unistd.h>
    pid_t vfork(void);

DESCRIPTION

    The vfork() function shall be equivalent to fork(), except that the behavior
    is undefined if the process created by vfork() either modifies any data
    other than a variable of type pid_t used to store the return value from
    vfork(), or returns from the function in which vfork() was called, or calls
    any other function before successfully calling _exit() or one of the exec
    family of functions.

RETURN VALUE

    Upon successful completion, vfork() shall return 0 to the child process and
    return the process ID of the child process to the parent process. Otherwise,
    -1 shall be returned to the parent, no child process shall be created, and
    errno shall be set to indicate the error.

ERRORS

    The vfork() function shall fail if:

    [EAGAIN]
        The system-wide limit on the total number of processes under execution
        would be exceeded, or the system-imposed limit on the total number of
        processes under execution by a single user would be exceeded.
    [ENOMEM]
        There is insufficient swap space for the new process.
*/
specification
void vfork_spec( CallContext context, CString * funcName )
{
    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /*
         * The vfork() function shall be equivalent to fork(), except that the behavior is
         * undefined if the process created by vfork() either modifies any data other than
         * a variable of type pid_t used to store the return value from vfork(), or
         * returns from the function in which vfork() was called, or calls any other
         * function before successfully calling _exit() or one of the exec family of
         * functions.
         */
        REQ( "app.vfork.01", "", equals( funcName, create_CString( "_exit" ) ) ||
                                 equals( funcName, create_CString( "execl" ) )
           );

        return true;
    }
    coverage C
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    post
    {
        return true;
    }
}

/*
 * common for wait group
 */
specification typedef struct WaitCall WaitCall = {};

WaitCall * create_WaitCall( String * name, CallContext context, ProcessId pid, bool isStatLocNull, IntT options )
{
    return create( & type_WaitCall, name, context, pid, isStatLocNull, options );
}

void onWait( String * name, CallContext context, ProcessId pid, bool isStatLocNull, IntT options )
{
    startCommand( context, "wait", create_WaitCall( name, context, pid, isStatLocNull, options ) );
}

specification typedef struct WaitReturnType WaitReturnType = {};

WaitReturnType * create_WaitReturnType(
    CallContext   context,
    ProcessId     returned_value,
    ErrorCode   * error_code,
    IntT          stat_loc,
    bool          isWIfExited,
    IntT          WExitStatus,
    bool          isWIfSignaled,
    IntT          WTermSig,
    bool          isWIfStopped,
    IntT          WStopSig,
    bool          isWIfContinued
)
{
    return create(&type_WaitReturnType,
        context,
        returned_value,
        error_code,
        stat_loc,
        isWIfExited,
        WExitStatus,
        isWIfSignaled,
        WTermSig,
        isWIfStopped,
        WStopSig,
        isWIfContinued
        );

}


ProcessState * getPreProcessState( ProcessId processId, Map * preSystems ) {
    SystemState * systemState = get_Map( preSystems, create_Long( processId.system ) );
    ProcessState * processState = get_Map( systemState->processes, create_ProcessIdObj( processId ) );
    return processState;
}

ProcessState * getPreProcessState_CallContext( CallContext context, Map * preSystems ) {
    return getPreProcessState( getProcessId_ThreadId( context ), preSystems );
}

reaction WaitReturnType * wait_return( void )
{
    post
    {
        CallContext   context        = wait_return->context       ;
        ProcessId     wait_spec      = wait_return->returned_value;
        ErrorCode   * errno          = wait_return->error_code    ;
        IntT          stat_loc       = wait_return->stat_loc      ;
        bool          isWIfExited    = wait_return->isWIfExited   ;
        IntT          WExitStatus    = wait_return->WExitStatus   ;
        bool          isWIfSignaled  = wait_return->isWIfSignaled ;
        IntT          WTermSig       = wait_return->WTermSig      ;
        bool          isWIfStopped   = wait_return->isWIfStopped  ;
        IntT          WStopSig       = wait_return->WStopSig      ;
        bool          isWIfContinued = wait_return->isWIfContinued;

        WaitCall * blocked_call = showCommand( @getBlockedCalls(), context, "wait" );
        String    * name          = blocked_call->name         ;
        ProcessId   pid           = blocked_call->pid          ;
        bool        isStatLocNull = blocked_call->isStatLocNull;
        IntT        options       = blocked_call->options      ;

        ProcessState * pre_processState = getPreProcessState_CallContext( context, @systems );
        ProcessState * processState     = getProcessState_CallContext   ( context           );

        ProcessState * childState        ;
        IntT           childReturnedValue;

        int fullOptionsMask; // WCONTINUED || WNOHANG || WUNTRACED
        bool checkResult, checkResult1, checkResult2, checkResult3;

        IntTObj * wContinued;
        if(IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED)
            wContinued = readIntValueByName( context, "WCONTINUED" );
        else
            wContinued = NULL;

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", processState != NULL );

        // stub
        return true;

        if ( equals( create_String( "wait" ), name ) )
        {
            ERROR_BEGIN( POSIX_WAIT, "wait.11.01", wait_spec.process == -1, * errno )
                /*
                 * The wait() function shall fail if:
                 *
                 * [ECHILD]
                 *
                 * The calling process has no existing unwaited-for child processes.
                 */
                ERROR_SHALL( POSIX_WAIT, ECHILD, "wait.11.01", isEmpty_Set( getChildren_CallContext( context ) ) )

                /*
                 * The wait() function shall fail if:
                 *
                 * [EINTR]
                 *
                 * The function was interrupted by a signal. The value of the location pointed to
                 * by stat_loc is undefined.
                 */
                ERROR_SHALL(POSIX_WAIT, EINTR, "wait.11.02", TODO_ERR(EINTR))

            ERROR_END()
        }
        else if ( equals( create_String( "wait4"  ), name ) )
        {
            ERROR_BEGIN( LSB_WAIT4, "wait4.11.01", wait_spec.process == -1, * errno )
                /*
                 * Errors
                 *
                 * [ECHILD] No unwaited-for child process as specified does exist.
                 */
                ERROR_MAY( LSB_WAIT4, ECHILD, "wait4.11.01", isEmpty_Set( getChildren_CallContext( context ) ) )

                /*
                 * Errors
                 *
                 * [ERESTARTSYS] A WNOHANG() was not set and an unblocked signal or a SIGCHILD was
                 * caught. This error is returned by the system call. The library interface is not
                 * allowed to return ERESTARTSYS, but will return EINTR.
                 */
                ERROR_MAY(LSB_WAIT4, EINTR, "wait4.11.02", TODO_ERR(EINTR))

            ERROR_END()
        }
        else if ( equals( create_String( "waitpid" ), name ) )
        {
            if ( options & SUT_WNOHANG == 0 && processState->finishedChild_for_wair_return == NULL )
            {
                /*
                 * If waitpid() was invoked with WNOHANG set in options, it has at least one child
                 * process specified by pid for which status is not available, and status is not
                 * available for any process specified by pid, 0 is returned.
                 *
                 * Otherwise, (pid_t)-1 shall be returned, and errno set to indicate the error.
                 */
                req4( name, "waitpid.21", "(pid_t)-1 shall be returned", wait_spec.process == -1 );
            }

            ERROR_BEGIN( POSIX_WAITPID, "waitpid.11.01", wait_spec.process == -1, * errno )
                /*
                 * The waitpid() function shall fail if:
                 *
                 * [ECHILD]
                 *
                 * The process specified by pid does not exist or is not a child of the calling
                 * process, or the process group specified by pid does not exist or does not have
                 * any member process that is a child of the calling process.
                 */
                ERROR_SHALL( POSIX_WAITPID, ECHILD, "waitpid.11.01", isEmpty_Set( getChildren_CallContext( context ) ) )

                /*
                 * The waitpid() function shall fail if:
                 *
                 * [EINTR]
                 *
                 * The function was interrupted by a signal. The value of the location pointed to
                 * by stat_loc is undefined.
                 */
                ERROR_SHALL(POSIX_WAITPID, EINTR, "waitpid.11.02", TODO_ERR(EINTR))

                /*
                 * The waitpid() function shall fail if:
                 *
                 * [EINVAL]
                 *
                 * The options argument is not valid.
                 */
                if ( wContinued != NULL ) { fullOptionsMask = * wContinued || SUT_WNOHANG || SUT_WUNTRACED; }
                                     else { fullOptionsMask =                 SUT_WNOHANG || SUT_WUNTRACED; }
                ERROR_SHALL( POSIX_WAITPID, EINVAL, "waitpid.11.03", ( options & fullOptionsMask ) != options )

            ERROR_END()
        }
        else
        {
            REQTRACE( "wait_return : unknown name" );
            return false;
        }

        if ( options & SUT_WNOHANG != 0 && processState->finishedChild_for_wair_return == NULL )
        {
            /*
             * If waitpid() was invoked with WNOHANG set in options, it has at least one child
             * process specified by pid for which status is not available, and status is not
             * available for any process specified by pid, 0 is returned.
             */
            req4( name, "waitpid.20", "0 is returned", wait_spec.process == 0 );

            return true;
        }

        /* [Consistency of test suite] */
        REQ( "", "finishedChild for wair_return shall exists", processState->finishedChild_for_wair_return != NULL );

        childState         = processState->finishedChild_for_wair_return->processState ;
        childReturnedValue = processState->finishedChild_for_wair_return->returnedValue;

        /*
         * The wait() and waitpid() functions shall obtain status information pertaining
         * to one of the caller's child processes. Various options permit status
         * information to be obtained for child processes that have terminated or stopped.
         */
        checkResult = ( childState != NULL );
        req4( name, "wait.01"   , "wait() and waitpid() functions shall obtain status of child process", checkResult );
        req4( name, "waitpid.01", "wait() and waitpid() functions shall obtain status of child process", checkResult );

        /*
         * If status information is available for two or more child processes, the order
         * in which their status is reported is unspecified.
         */
        req4( name, "wait.02"   , "order is unspecified", true );
        req4( name, "waitpid.02", "order is unspecified", true );

        /*
         * The wait() function shall suspend execution of the calling thread until status
         * information for one of the terminated child processes of the calling process is
         * available
         *
         * wait4() suspends execution of the current process until a child (as specified
         * by pid) has exited
         */
        checkResult = ( childState != NULL );
        req4( name, "wait.03.01"   , "wait() function shall suspend execution", childState );
        req4( name, "wait4.03.01"  , "wait4() suspends execution"             , childState );
        req4( name, "waitpid.03.01", "wait() function shall suspend execution", childState );

        /*
         * until delivery of a signal whose action is either to execute a signal-catching
         * function or to terminate the process.
         *
         * until a signal is delivered whose action is to terminate the current process or
         * to call a signal handling function.
         */
        req4( name, "wait.03.02"   , "until delivery of a signal" , true );
        req4( name, "wait4.03.02"  , "until a signal is delivered", true );
        req4( name, "waitpid.03.02", "until delivery of a signal" , true );

        /*
         * If more than one thread is suspended in wait() or waitpid() awaiting
         * termination of the same process, exactly one thread shall return the process
         * status at the time of the target process termination.
         */
        checkResult = ( childState != NULL );
        req4( name, "wait.03.03"   , "exactly one thread shall return the process status", checkResult );
        req4( name, "waitpid.03.03", "exactly one thread shall return the process status", checkResult );

        /*
         * If status information is available prior to the call to wait(), return shall be
         * immediate.
         *
         * If a child (as requested by pid) has already exited by the time of the call (a
         * so-called "zombie" process), the function returns immediately.
         */
        if ( contains_Set( pre_processState->finishedChildren, processState->finishedChild_for_wair_return ) )
        {
            req4( name, "wait.03.04"   , "If status information is already available, return shall be immediate", true );
            req4( name, "wait4.03.04"  , "If a child has already exited, the function returns immediately"      , true );
            req4( name, "waitpid.03.04", "If status information is already available, return shall be immediate", true );
        }

        /*
         * The value of pid can be one of:
         *
         * -1 wait for any child process; this is equivalent to calling wait3().
         *
         * The pid argument specifies a set of child processes for which status is
         * requested. The waitpid() function shall only return the status of a child
         * process from this set:
         *
         * If pid is equal to (pid_t)-1, status is requested for any child process. In
         * this respect, waitpid() is then equivalent to wait().
         */
        if ( pid.process == -1 )
        {
            checkResult1 = ( childState != NULL                                                 );
            checkResult2 = ( childState->meta.parent.process == processState->processid.process );
            req4( name, "wait4.04.01"  , "wait for any child"               , T( checkResult1 ) && T( checkResult2 ) );
            req4( name, "waitpid.04.01", "status is requested for any child", T( checkResult1 ) && T( checkResult2 ) );
        }

        /*
         * The value of pid can be one of:
         *
         * > 0 wait for the child whose process ID is equal to the value of pid.
         *
         * The pid argument specifies a set of child processes for which status is
         * requested. The waitpid() function shall only return the status of a child
         * process from this set:
         *
         * If pid is greater than 0, it specifies the process ID of a single child process
         * for which status is requested.
         */
        if ( pid.process > 0 )
        {
            checkResult1 = ( childState != NULL                                                 );
            checkResult2 = ( childState->meta.parent.process == processState->processid.process );
            checkResult3 = ( childState->processid.process == pid.process                       );
            req4( name, "wait4.04.02"  , "wait for the child whose process ID is equal to the value of pid",
                                         T( checkResult1 ) && T( checkResult2 ) && T( checkResult3 )
                );
            req4( name, "waitpid.04.02", "pid specifies the process ID of a single child process",
                                         T( checkResult1 ) && T( checkResult2 ) && T( checkResult3 )
                );
        }

        /*
         * The value of pid can be one of:
         *
         * 0 wait for any child process whose process group ID is equal to that of the
         * calling process.
         *
         * The pid argument specifies a set of child processes for which status is
         * requested. The waitpid() function shall only return the status of a child
         * process from this set:
         *
         * If pid is 0, status is requested for any child process whose process group ID
         * is equal to that of the calling process.
         */
        if ( pid.process == 0 )
        {
            checkResult1 = ( childState != NULL                                                   );
            checkResult2 = ( childState->meta.parent.process == processState->processid.process   );
            checkResult3 = ( childState->meta.pgroup.process == processState->meta.pgroup.process );
            req4( name, "wait4.04.03"  , "child process whose process group ID is equal to that of the calling process",
                                         T( checkResult1 ) && T( checkResult2 ) && T( checkResult3 )
                );
            req4( name, "waitpid.04.03", "child process whose process group ID is equal to that of the calling process",
                                         T( checkResult1 ) && T( checkResult2 ) && T( checkResult3 )
                );
        }

        /*
         * The value of pid can be one of:
         *
         * < -1 wait for any child process whose process group ID is equal to the
         * absolute value of pid.
         *
         * The pid argument specifies a set of child processes for which status is
         * requested. The waitpid() function shall only return the status of a child
         * process from this set:
         *
         * If pid is less than (pid_t)-1, status is requested for any child process whose
         * process group ID is equal to the absolute value of pid.
         */
        if ( pid.process < -1 )
        {
            checkResult1 = ( childState != NULL                                                 );
            checkResult2 = ( childState->meta.parent.process == processState->processid.process );
            checkResult3 = ( childState->meta.pgroup.process == - pid.process                   );
            req4( name, "wait4.04.04"  , "child process whose process group ID is equal to the absolute value of pid",
                                         T( checkResult1 ) && T( checkResult2 ) && T( checkResult3 )
                );
            req4( name, "waitpid.04.04", "child process whose process group ID is equal to the absolute value of pid",
                                         T( checkResult1 ) && T( checkResult2 ) && T( checkResult3 )
                );
        }

        /*
         * The options argument is constructed from the bitwise-inclusive OR of zero or
         * more of the following flags, defined in the <sys/wait.h> header:
         *
         * WCONTINUED
         *
         * [XSI] The waitpid() function shall report the status of any continued child
         * process specified by pid whose status has not been reported since it continued
         * from a job control stop.
         */
        if ( wContinued != NULL && ( options & * wContinued ) != 0 )
        {
            req4( name, "waitpid.05.01", "", TODO_REQ() );
        }

        /*
         * The value of options is a bitwise or of zero or more of the following constants:
         *
         * WNOHANG return immediately if no child is there to be waited for.
         *
         * The options argument is constructed from the bitwise-inclusive OR of zero or
         * more of the following flags, defined in the <sys/wait.h> header:
         *
         * WNOHANG
         *
         * The waitpid() function shall not suspend execution of the calling thread if
         * status is not immediately available for one of the child processes specified by
         * pid.
         */
        if ( ( options & SUT_WNOHANG ) != 0 )
        {
            req4( name, "wait4.05.02"  , "return immediately if no child is there to be waited for"            , true );
            req4( name, "waitpid.05.02", "waitpid() function shall not suspend execution of the calling thread", true );
        }

        /*
         * The value of options is a bitwise or of zero or more of the following constants:
         *
         * WUNTRACED return for children that are stopped, and whose status has not been
         * reported.
         *
         * The options argument is constructed from the bitwise-inclusive OR of zero or
         * more of the following flags, defined in the <sys/wait.h> header:
         *
         * WUNTRACED
         *
         * The status of any child processes specified by pid that are stopped, and whose
         * status has not yet been reported since they stopped, shall also be reported to
         * the requesting process.
         */
        if ( ( options & SUT_WUNTRACED ) != 0 )
        {
            req4( name, "wait4.05.03"  , "", TODO_REQ() );
            req4( name, "waitpid.05.03", "", TODO_REQ() );
        }

        /*
         * [XSI] If the calling process has SA_NOCLDWAIT set or has SIGCHLD set to
         * SIG_IGN, and the process has no unwaited-for children that were transformed
         * into zombie processes, the calling thread shall block until all of the children
         * of the process containing the calling thread terminate, and wait() and waitpid()
         * shall fail and set errno to [ECHILD].
         */
        req4( name, "wait.06"   , "", TODO_REQ() );
        req4( name, "waitpid.06", "", TODO_REQ() );

        /*
         * If wait() or waitpid() return because the status of a child process is
         * available, these functions shall return a value equal to the process ID of the
         * child process.
         */
        checkResult1 = ( childState != NULL                                 );
        checkResult2 = ( childState->processid.process == wait_spec.process );
        req4( name, "wait.07"   , "shall return child process ID", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "waitpid.07", "shall return child process ID", T( checkResult1 ) && T( checkResult2 ) );

        /*
         * In this case, if the value of the argument stat_loc is not a null pointer,
         * information shall be stored in the location pointed to by stat_loc.
         *
         * If status is not NULL, wait4() stores status information in the location status.
         */
        if ( ! isStatLocNull )
        {
            req4( name, "wait.08"   , "information shall be stored in the location pointed to by stat_loc", true );
            req4( name, "wait4.08"  , "wait4() stores status information in the location status"          , true );
            req4( name, "waitpid.08", "information shall be stored in the location pointed to by stat_loc", true );
        }

        /*
         * If _POSIX_REALTIME_SIGNALS is defined
         *
         * and the implementation queues the SIGCHLD signal, then if wait() or waitpid()
         * returns because the status of a child process is available, any pending SIGCHLD
         * signal associated with the process ID of the child process shall be discarded.
         * Any other pending SIGCHLD signals shall remain pending.
         */
        req4( name, "wait.09.01"   , "", TODO_REQ() );
        req4( name, "waitpid.09.01", "", TODO_REQ() );

        /*
         * If _POSIX_REALTIME_SIGNALS is defined
         *
         * Otherwise, if SIGCHLD is blocked, if wait() or waitpid() return because the
         * status of a child process is available, any pending SIGCHLD signal shall be
         * cleared unless the status of another child process is available.
         */
        req4( name, "wait.09.02"   , "", TODO_REQ() );
        req4( name, "waitpid.09.02", "", TODO_REQ() );

        /*
         * If wait() or waitpid() returns because the status of a child process is
         * available, these functions shall return a value equal to the process ID of the
         * child process for which status is reported.
         *
         * On success, the process ID of the child that exited is returned.
         */
        checkResult1 = ( childState != NULL                                 );
        checkResult2 = ( childState->processid.process == wait_spec.process );
        req4( name, "wait.10"   , "shall return child process ID"          , T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "wait4.10"  , "the process ID of the child is returned", T( checkResult1 ) && T( checkResult2 ) );
        req4( name, "waitpid.10", "shall return child process ID"          , T( checkResult1 ) && T( checkResult2 ) );

        if ( ! isStatLocNull )
        {
            /*
             * The value stored at the location pointed to by stat_loc shall be 0 if and only
             * if the status returned is from a terminated child process that terminated by
             * one of the following means:
             *
             * The process returned 0 from main().
             */
            checkResult1 = ( stat_loc           == 0 );
            checkResult2 = ( childReturnedValue == 0 );
            req4( name, "wait.12.01"   , "returned value from main()", T( checkResult1 ) == T( checkResult2 ) );
            req4( name, "waitpid.12.01", "returned value from main()", T( checkResult1 ) == T( checkResult2 ) );

            /*
             * The value stored at the location pointed to by stat_loc shall be 0 if and only
             * if the status returned is from a terminated child process that terminated by
             * one of the following means:
             *
             * The process called _exit() or exit() with a status argument of 0.
             */
            checkResult1 = ( stat_loc           == 0 );
            checkResult2 = ( childReturnedValue == 0 );
            req4( name, "wait.12.02"   , "_exit() or exit() with value", T( checkResult1 ) == T( checkResult2 ) );
            req4( name, "waitpid.12.02", "_exit() or exit() with value", T( checkResult1 ) == T( checkResult2 ) );

            /*
             * The value stored at the location pointed to by stat_loc shall be 0 if and only
             * if the status returned is from a terminated child process that terminated by
             * one of the following means:
             *
             * The process was terminated because the last thread in the process terminated.
             */
            checkResult1 = ( stat_loc           == 0 );
            checkResult2 = ( childReturnedValue == 0 );
            req4( name, "wait.12.03"   , "last thread in the process terminated", T( checkResult1 ) == T( checkResult2 ) );
            req4( name, "waitpid.12.03", "last thread in the process terminated", T( checkResult1 ) == T( checkResult2 ) );

            /*
             * Regardless of its value, this information may be interpreted using the
             * following macros, which are defined in <sys/wait.h> and evaluate to integral
             * expressions; the stat_val argument is the integer value pointed to by stat_loc.
             *
             * WIFEXITED(stat_val)
             *
             * Evaluates to a non-zero value if status was returned for a child process that
             * terminated normally.
             *
             * This status can be evaluated with the following macros:
             *
             * WIFEXITED(status) is nonzero if the child exited normally.
             */
            if ( isWIfExited )
            {
                req4( name, "wait.13.01"   , "non-zero value if child process that terminated normally" , true );
                req4( name, "wait4.13.01"  , "WIFEXITED(status) is nonzero if the child exited normally", true );
                req4( name, "waitpid.13.01", "non-zero value if child process that terminated normally" , true );

                /*
                 * Regardless of its value, this information may be interpreted using the
                 * following macros, which are defined in <sys/wait.h> and evaluate to integral
                 * expressions; the stat_val argument is the integer value pointed to by stat_loc.
                 *
                 * WEXITSTATUS(stat_val)
                 *
                 * If the value of WIFEXITED(stat_val) is non-zero, this macro evaluates to the
                 * low-order 8 bits of the status argument that the child process passed to _exit()
                 * or exit(), or the value the child process returned from main().
                 *
                 * This status can be evaluated with the following macros:
                 *
                 * WEXITSTATUS(status) evaluates to the least significant eight bits of the return
                 * code of the child that terminated, which may have been set as the argument to a
                 * call to exit() or as the argument for a return statement in the main program.
                 * This macro can only be evaluated if WIFEXITED() returned nonzero.
                 */
                checkResult = ( WExitStatus == ( 0xFF & childReturnedValue ) );
                req4( name, "wait.13.02"   , "low-order 8 bits returned from child process"                , checkResult );
                req4( name, "wait4.13.02"  , "least significant eight bits of the return code of the child", checkResult );
                req4( name, "waitpid.13.02", "low-order 8 bits returned from child process"                , checkResult );
            }

            /*
             * Regardless of its value, this information may be interpreted using the
             * following macros, which are defined in <sys/wait.h> and evaluate to integral
             * expressions; the stat_val argument is the integer value pointed to by stat_loc.
             *
             * WIFSIGNALED(stat_val)
             *
             * Evaluates to a non-zero value if status was returned for a child process that
             * terminated due to the receipt of a signal that was not caught (see <signal.h>
             * ).
             *
             * This status can be evaluated with the following macros:
             *
             * WIFSIGNALED(status) returns true if the child process exited because of a
             * signal that was not caught.
             */
            if ( isWIfSignaled )
            {
                req4( name, "wait.13.03"   , "", TODO_REQ() );
                req4( name, "wait4.13.03"  , "", TODO_REQ() );
                req4( name, "waitpid.13.03", "", TODO_REQ() );

                /*
                 * Regardless of its value, this information may be interpreted using the
                 * following macros, which are defined in <sys/wait.h> and evaluate to integral
                 * expressions; the stat_val argument is the integer value pointed to by stat_loc.
                 *
                 * WTERMSIG(stat_val)
                 *
                 * If the value of WIFSIGNALED(stat_val) is non-zero, this macro evaluates to the
                 * number of the signal that caused the termination of the child process.
                 *
                 * This status can be evaluated with the following macros:
                 *
                 * WTERMSIG(status) returns the number of the signal that caused the child process
                 * to terminate. This macro can only be evaluated if WIFSIGNALED() returned
                 * nonzero.
                 */
                req4( name, "wait.13.04"   , "", TODO_REQ() );
                req4( name, "wait4.13.04"  , "", TODO_REQ() );
                req4( name, "waitpid.13.04", "", TODO_REQ() );
            }

            /*
             * Regardless of its value, this information may be interpreted using the
             * following macros, which are defined in <sys/wait.h> and evaluate to integral
             * expressions; the stat_val argument is the integer value pointed to by stat_loc.
             *
             * WIFSTOPPED(stat_val)
             *
             * Evaluates to a non-zero value if status was returned for a child process that
             * is currently stopped.
             *
             * This status can be evaluated with the following macros:
             *
             * WIFSTOPPED(status) returns true if the child process that caused the return is
             * currently stopped; this is only possible if the call was done using WUNTRACED().
             */
            if ( isWIfStopped )
            {
                req4( name, "wait.13.05"   , "", TODO_REQ() );
                req4( name, "wait4.13.05"  , "", TODO_REQ() );
                req4( name, "waitpid.13.05", "", TODO_REQ() );

                /*
                 * Regardless of its value, this information may be interpreted using the
                 * following macros, which are defined in <sys/wait.h> and evaluate to integral
                 * expressions; the stat_val argument is the integer value pointed to by stat_loc.
                 *
                 * WSTOPSIG(stat_val)
                 *
                 * If the value of WIFSTOPPED(stat_val) is non-zero, this macro evaluates to the
                 * number of the signal that caused the child process to stop.
                 *
                 * This status can be evaluated with the following macros:
                 *
                 * WSTOPSIG(status) returns the number of the signal that caused the child to stop.
                 * This macro can only be evaluated if WIFSTOPPED() returned nonzero.
                 */
                req4( name, "wait.13.06"   , "", TODO_REQ() );
                req4( name, "wait4.13.06"  , "", TODO_REQ() );
                req4( name, "waitpid.13.06", "", TODO_REQ() );
            }

            /*
             * Regardless of its value, this information may be interpreted using the
             * following macros, which are defined in <sys/wait.h> and evaluate to integral
             * expressions; the stat_val argument is the integer value pointed to by stat_loc.
             *
             * WIFCONTINUED(stat_val)
             *
             * [XSI] Evaluates to a non-zero value if status was returned for a child process
             * that has continued from a job control stop.
             */
            if ( isWIfContinued )
            {
                req4( name, "wait.13.07"   , "", TODO_REQ() );
                req4( name, "waitpid.13.07", "", TODO_REQ() );
            }

            /*
             * [SPN] It is unspecified whether the status value returned by calls to wait()
             * or waitpid() for processes created by posix_spawn() or posix_spawnp() can
             * indicate a WIFSTOPPED(stat_val) before subsequent calls to wait() or waitpid()
             * indicate WIFEXITED(stat_val) as the result of an error detected before the new
             * process image starts executing.
             */
            req4( name, "wait.14"   , "", TODO_REQ() );
            req4( name, "waitpid.14", "", TODO_REQ() );

            /*
             * It is unspecified whether the status value returned by calls to wait() or
             * waitpid() for processes created by posix_spawn() or posix_spawnp() can indicate
             * a WIFSIGNALED(stat_val) if a signal is sent to the parent's process group after
             * posix_spawn() or posix_spawnp() is called.
             */
            req4( name, "wait.15"   , "", TODO_REQ() );
            req4( name, "waitpid.15", "", TODO_REQ() );

            /*
             * If the information pointed to by stat_loc was stored by a call to waitpid()
             * that specified the WUNTRACED flag [XSI]  and did not specify the WCONTINUED
             * flag, exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc),
             * and WIFSTOPPED(*stat_loc) shall evaluate to a non-zero value.
             */
            req4( name, "wait.16"   , "", TODO_REQ() );
            req4( name, "waitpid.16", "", TODO_REQ() );

            /*
             * If the information pointed to by stat_loc was stored by a call to waitpid()
             * that specified the WUNTRACED [XSI]  and WCONTINUED flags, exactly one of the
             * macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), WIFSTOPPED(*stat_loc), [
             * XSI]  and WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.
             */
            req4( name, "wait.17"   , "", TODO_REQ() );
            req4( name, "waitpid.17", "", TODO_REQ() );

            /*
             * If the information pointed to by stat_loc was stored by a call to waitpid()
             * that did not specify the WUNTRACED [XSI]  or WCONTINUED flags, or by a call
             * to the wait() function, exactly one of the macros WIFEXITED(*stat_loc) and
             * WIFSIGNALED(*stat_loc) shall evaluate to a non-zero value.
             */
            req4( name, "wait.18",
                  "exactly one of the macros WIFEXITED and WIFSIGNALED shall evaluate to a non-zero value",
                  T( isWIfExited ) != T( isWIfSignaled )
                );
            if ( ( options & SUT_WUNTRACED == 0 ) && ( wContinued == NULL || ( options & * wContinued ) == 0 ) )
            {
                req4( name, "waitpid.18",
                      "exactly one of the macros WIFEXITED and WIFSIGNALED shall evaluate to a non-zero value",
                      T( isWIfExited ) != T( isWIfSignaled )
                    );
            }

            /*
             * If the information pointed to by stat_loc was stored by a call to waitpid()
             * that did not specify the WUNTRACED flag [XSI]  and specified the WCONTINUED
             * flag, or by a call to the wait() function, exactly one of the macros WIFEXITED(
             * *stat_loc), WIFSIGNALED(*stat_loc), [XSI]  and WIFCONTINUED(*stat_loc) shall
             * evaluate to a non-zero value.
             */
            req4( name, "wait.19"   , "", TODO_REQ() );
            req4( name, "waitpid.19", "", TODO_REQ() );
        }

        /*
         * If rusage is not NULL, the struct rusage (as defined in sys/resource.h) that it
         * points to will be filled with accounting information. See getrusage() for
         * details.
         */
        req4( name, "wait4.22", "", TODO_REQ() );

        return true;
    }
}

void onWaitReturn( CallContext context, ProcessId returned_value )
{
    WaitCall * blocked_call = endCommand( context, "wait" );
    ProcessState * processState = getProcessState_CallContext( context );
    processState->finishedChild_for_wair_return = NULL;
    if ( returned_value.process > 0 ) {
        int i;
        for ( i = 0; i < size_Set( processState->finishedChildren ); i++ ) {
            FinishedChild * finishedChild = get_Set( processState->finishedChildren, i );
            if ( finishedChild->processState->processid.process == returned_value.process ) {
                processState->finishedChild_for_wair_return = finishedChild;
                remove_Set( processState->finishedChildren, finishedChild );
                break;
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wait, waitpid - wait for a child process to stop or terminate

SYNOPSIS

    #include <sys/wait.h>

    pid_t wait(int *stat_loc);
    pid_t waitpid(pid_t pid, int *stat_loc, int options);

DESCRIPTION

    The wait() and waitpid() functions shall obtain status information
    pertaining to one of the caller's child processes. Various options permit
    status information to be obtained for child processes that have terminated
    or stopped. If status information is available for two or more child
    processes, the order in which their status is reported is unspecified.

    The wait() function shall suspend execution of the calling thread until
    status information for one of the terminated child processes of the calling
    process is available, or until delivery of a signal whose action is either
    to execute a signal-catching function or to terminate the process. If more
    than one thread is suspended in wait() or waitpid() awaiting termination of
    the same process, exactly one thread shall return the process status at the
    time of the target process termination. If status information is available
    prior to the call to wait(), return shall be immediate.

    The waitpid() function shall be equivalent to wait() if the pid argument is
    (pid_t)-1 and the options argument is 0. Otherwise, its behavior shall be
    modified by the values of the pid and options arguments.

    The pid argument specifies a set of child processes for which status is
    requested. The waitpid() function shall only return the status of a child
    process from this set:

        If pid is equal to (pid_t)-1, status is requested for any child process.
        In this respect, waitpid() is then equivalent to wait().

        If pid is greater than 0, it specifies the process ID of a single child
        process for which status is requested.

        If pid is 0, status is requested for any child process whose process
        group ID is equal to that of the calling process.

        If pid is less than (pid_t)-1, status is requested for any child process
        whose process group ID is equal to the absolute value of pid.

    The options argument is constructed from the bitwise-inclusive OR of zero or
    more of the following flags, defined in the <sys/wait.h> header:

    WCONTINUED
        The waitpid() function shall report the status of any continued child
        process specified by pid whose status has not been reported since it
        continued from a job control stop.
    WNOHANG
        The waitpid() function shall not suspend execution of the calling thread
        if status is not immediately available for one of the child processes
        specified by pid.
    WUNTRACED
        The status of any child processes specified by pid that are stopped, and
        whose status has not yet been reported since they stopped, shall also be
        reported to the requesting process.

    If the calling process has SA_NOCLDWAIT set or has SIGCHLD set to SIG_IGN,
    and the process has no unwaited-for children that were transformed into
    zombie processes, the calling thread shall block until all of the children
    of the process containing the calling thread terminate, and wait() and
    waitpid() shall fail and set errno to [ECHILD].

    If wait() or waitpid() return because the status of a child process is
    available, these functions shall return a value equal to the process ID of
    the child process. In this case, if the value of the argument stat_loc is
    not a null pointer, information shall be stored in the location pointed to
    by stat_loc. The value stored at the location pointed to by stat_loc shall
    be 0 if and only if the status returned is from a terminated child process
    that terminated by one of the following means:

       1. The process returned 0 from main().

       2. The process called _exit() or exit() with a status argument of 0.

       3. The process was terminated because the last thread in the process
          terminated.

    Regardless of its value, this information may be interpreted using the
    following macros, which are defined in <sys/wait.h> and evaluate to integral
    expressions; the stat_val argument is the integer value pointed to by
    stat_loc.

    WIFEXITED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that terminated normally.
    WEXITSTATUS(stat_val)
        If the value of WIFEXITED(stat_val) is non-zero, this macro evaluates to
        the low-order 8 bits of the status argument that the child process
        passed to _exit() or exit(), or the value the child process returned
        from main().
    WIFSIGNALED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that terminated due to the receipt of a signal that was not caught (see
        <signal.h>).
    WTERMSIG(stat_val)
        If the value of WIFSIGNALED(stat_val) is non-zero, this macro evaluates
        to the number of the signal that caused the termination of the child
        process.
    WIFSTOPPED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that is currently stopped.
    WSTOPSIG(stat_val)
        If the value of WIFSTOPPED(stat_val) is non-zero, this macro evaluates
        to the number of the signal that caused the child process to stop.
    WIFCONTINUED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that has continued from a job control stop.

    It is unspecified whether the status value returned by calls to wait() or
    waitpid() for processes created by posix_spawn() or posix_spawnp() can
    indicate a WIFSTOPPED(stat_val) before subsequent calls to wait() or
    waitpid() indicate WIFEXITED(stat_val) as the result of an error detected
    before the new process image starts executing.

    It is unspecified whether the status value returned by calls to wait() or
    waitpid() for processes created by posix_spawn() or posix_spawnp() can
    indicate a WIFSIGNALED(stat_val) if a signal is sent to the parent's process
    group after posix_spawn() or posix_spawnp() is called.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that specified the WUNTRACED flag and did not specify the WCONTINUED flag,
    exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and
    WIFSTOPPED(*stat_loc) shall evaluate to a non-zero value.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that specified the WUNTRACED and WCONTINUED flags, exactly one of the macros
    WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), WIFSTOPPED(*stat_loc), and
    WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that did not specify the WUNTRACED or WCONTINUED flags, or by a call to the
    wait() function, exactly one of the macros WIFEXITED(*stat_loc) and
    WIFSIGNALED(*stat_loc) shall evaluate to a non-zero value.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that did not specify the WUNTRACED flag and specified the WCONTINUED flag,
    or by a call to the wait() function, exactly one of the macros
    WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and WIFCONTINUED(*stat_loc)
    shall evaluate to a non-zero value.

    If _POSIX_REALTIME_SIGNALS is defined, and the implementation queues the
    SIGCHLD signal, then if wait() or waitpid() returns because the status of a
    child process is available, any pending SIGCHLD signal associated with the
    process ID of the child process shall be discarded. Any other pending
    SIGCHLD signals shall remain pending.

    Otherwise, if SIGCHLD is blocked, if wait() or waitpid() return because the
    status of a child process is available, any pending SIGCHLD signal shall be
    cleared unless the status of another child process is available.

    For all other conditions, it is unspecified whether child status will be
    available when a SIGCHLD signal is delivered.

    There may be additional implementation-defined circumstances under which
    wait() or waitpid() report status. This shall not occur unless the calling
    process or one of its child processes explicitly makes use of a non-standard
    extension. In these cases the interpretation of the reported status is
    implementation-defined.

    If a parent process terminates without waiting for all of its child
    processes to terminate, the remaining child processes shall be assigned a
    new parent process ID corresponding to an implementation-defined system
    process.

RETURN VALUE

    If wait() or waitpid() returns because the status of a child process is
    available, these functions shall return a value equal to the process ID of
    the child process for which status is reported. If wait() or waitpid()
    returns due to the delivery of a signal to the calling process, -1 shall be
    returned and errno set to [EINTR]. If waitpid() was invoked with WNOHANG set
    in options, it has at least one child process specified by pid for which
    status is not available, and status is not available for any process
    specified by pid, 0 is returned. Otherwise, (pid_t)-1 shall be returned, and
    errno set to indicate the error.

ERRORS

    The wait() function shall fail if:

    [ECHILD]
        The calling process has no existing unwaited-for child processes.
    [EINTR]
        The function was interrupted by a signal. The value of the location
        pointed to by stat_loc is undefined.

    The waitpid() function shall fail if:

    [ECHILD]
        The process specified by pid does not exist or is not a child of the
        calling process, or the process group specified by pid does not exist or
        does not have any member process that is a child of the calling process.
    [EINTR]
        The function was interrupted by a signal. The value of the location
        pointed to by stat_loc is undefined.
    [EINVAL]
        The options argument is not valid.
*/
specification
void wait_spec( CallContext context, bool isStatLocNull )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_StatLoc
    {
        if ( isStatLocNull )
        {
            return { StatLocIsNull, "stat_loc is NULL" };
        }
        else
        {
            return { StatLocIsNotNull, "stat_loc is not NULL" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    wait4 -- wait for process termination, BSD style

SYNOPSIS

    #include <sys/types.h>
    #include <sys/resource.h>
    #include <sys/wait.h>

    pid_t wait4(pid_t pid, int * status, int options, struct rusage * rusage);

DESCRIPTION

    wait4() suspends execution of the current process until a child (as
    specified by pid) has exited, or until a signal is delivered whose action is
    to terminate the current process or to call a signal handling function. If a
    child (as requested by pid) has already exited by the time of the call (a
    so-called "zombie" process), the function returns immediately. Any system
    resources used by the child are freed.

    The value of pid can be one of:

        < -1
            wait for any child process whose process group ID is equal to the
            absolute value of pid.

        -1
            wait for any child process; this is equivalent to calling wait3().

        0
            wait for any child process whose process group ID is equal to that
            of the calling process.

        > 0
            wait for the child whose process ID is equal to the value of pid.

    The value of options is a bitwise or of zero or more of the following
    constants:

        WNOHANG
            return immediately if no child is there to be waited for.

        WUNTRACED
            return for children that are stopped, and whose status has not been
            reported.

    If status is not NULL, wait4() stores status information in the location
    status. This status can be evaluated with the following macros:

        Note: These macros take the status value (an int) as an argument -- not
        a pointer to the value!

    WIFEXITED(status)
        is nonzero if the child exited normally.

    WEXITSTATUS(status)
        evaluates to the least significant eight bits of the return code of the
        child that terminated, which may have been set as the argument to a call
        to exit() or as the argument for a return statement in the main program.
        This macro can only be evaluated if WIFEXITED() returned nonzero.

    WIFSIGNALED(status)
        returns true if the child process exited because of a signal that was
        not caught.

    WTERMSIG(status)
        returns the number of the signal that caused the child process to
        terminate. This macro can only be evaluated if WIFSIGNALED() returned
        nonzero.

    WIFSTOPPED(status)
        returns true if the child process that caused the return is currently
        stopped; this is only possible if the call was done using WUNTRACED().

    WSTOPSIG(status)
        returns the number of the signal that caused the child to stop. This
        macro can only be evaluated if WIFSTOPPED() returned nonzero.

    If rusage is not NULL, the struct rusage (as defined in sys/resource.h) that
    it points to will be filled with accounting information. See getrusage() for
    details.

RETURN VALUE

    On success, the process ID of the child that exited is returned. On error,
    -1 is returned (in particular, when no unwaited-for child processes of the
    specified kind exist), or 0 if WNOHANG() was used and no child was available
    yet. In the latter two cases, the global variable errno is set
    appropriately.

ERRORS

    [ECHILD]
        No unwaited-for child process as specified does exist.

    [ERESTARTSYS]
        A WNOHANG() was not set and an unblocked signal or a SIGCHILD was
        caught. This error is returned by the system call. The library interface
        is not allowed to return ERESTARTSYS, but will return EINTR.
*/
specification
void wait4_spec( CallContext context, ProcessId pid, bool isStatLocNull, IntT options, bool isRusageNull )
{
    IntTObj * wContinued;

    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        if(IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED)
            wContinued = readIntValueByName( context, "WCONTINUED" );
        else
            wContinued = NULL;

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Pid
    {
        if ( pid.process == -1 )
        {
            return { PidIsEqualToMinusOne, "pid is equal to (pid_t)-1" };
        }
        else if ( pid.process > 0 )
        {
            return { PidIsGreaterThanZero, "pid is greater than 0" };
        }
        else if ( pid.process == 0 )
        {
            return { PidIsEqualToZero, "pid is equal to 0" };
        }
        else // pid.process < -1
        {
            return { PidIsLessThanMinusOne, "pid is less than (pid_t)-1" };
        }
    }
    coverage C_StatLoc
    {
        if ( isStatLocNull )
        {
            return { StatLocIsNull, "stat_loc is NULL" };
        }
        else
        {
            return { StatLocIsNotNull, "stat_loc is not NULL" };
        }
    }
    coverage C_Options
    {
        if ( options == 0 )
        {
            return { OptionsIsEqualTo_0, "options is equal to 0" };
        }
        else if ( ( options & SUT_WUNTRACED ) == options )
        {
            return { OptionsIsEqualTo_WUNTRACED, "options is equal to WUNTRACED" };
        }
        else if ( ( options & SUT_WNOHANG ) == options )
        {
            return { OptionsIsEqualTo_WNOHANG, "options is equal to WNOHANG" };
        }
        else if ( ( options & ( SUT_WNOHANG | SUT_WUNTRACED ) ) == options )
        {
            return { OptionsIsEqualTo_WNOHANG_WUNTRACED, "options is equal to WNOHANG | WUNTRACED" };
        }

        #if IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED
            else if ( ( options & * wContinued ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED, "options is equal to WCONTINUED" };
                }
                else if ( ( options & ( * wContinued | SUT_WUNTRACED ) ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED_WUNTRACED, "options is equal to WCONTINUED | WUNTRACED" };
                }
                else if ( ( options & ( * wContinued | SUT_WNOHANG ) ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED_WNOHANG, "options is equal to WCONTINUED | WNOHANG" };
                }
                else if ( ( options & ( * wContinued | SUT_WNOHANG | SUT_WUNTRACED ) ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED_WNOHANG_WUNTRACED,
                             "options is equal to WCONTINUED | WNOHANG | WUNTRACED"
                           };
                }
        #endif // IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED

            else
            {
                return { OptionsIsNotValid, "The options argument is not valid." };
            }
    }
    coverage C_RusageNull
    {
        if ( isRusageNull )
        {
            return { RusageIsNull, "rusage is NULL" };
        }
        else
        {
            return { RusageIsNotNull, "rusage is not NULL" };
        }
    }
    post
    {
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    wait, waitpid - wait for a child process to stop or terminate

SYNOPSIS

    #include <sys/wait.h>

    pid_t wait(int *stat_loc);
    pid_t waitpid(pid_t pid, int *stat_loc, int options);

DESCRIPTION

    waitpid() is as specified in ISO POSIX (2003), but with differences as
    listed below.

    Need not support WCONTINUED or WIFCONTINUED

    Implementations need not support the XSI optional functionality of
    WCONTINUED() or WIFCONTINUED().

    The wait() and waitpid() functions shall obtain status information
    pertaining to one of the caller's child processes. Various options permit
    status information to be obtained for child processes that have terminated
    or stopped. If status information is available for two or more child
    processes, the order in which their status is reported is unspecified.

    The wait() function shall suspend execution of the calling thread until
    status information for one of the terminated child processes of the calling
    process is available, or until delivery of a signal whose action is either
    to execute a signal-catching function or to terminate the process. If more
    than one thread is suspended in wait() or waitpid() awaiting termination of
    the same process, exactly one thread shall return the process status at the
    time of the target process termination. If status information is available
    prior to the call to wait(), return shall be immediate.

    The waitpid() function shall be equivalent to wait() if the pid argument is
    (pid_t)-1 and the options argument is 0. Otherwise, its behavior shall be
    modified by the values of the pid and options arguments.

    The pid argument specifies a set of child processes for which status is
    requested. The waitpid() function shall only return the status of a child
    process from this set:

        If pid is equal to (pid_t)-1, status is requested for any child process.
        In this respect, waitpid() is then equivalent to wait().

        If pid is greater than 0, it specifies the process ID of a single child
        process for which status is requested.

        If pid is 0, status is requested for any child process whose process
        group ID is equal to that of the calling process.

        If pid is less than (pid_t)-1, status is requested for any child process
        whose process group ID is equal to the absolute value of pid.

    The options argument is constructed from the bitwise-inclusive OR of zero or
    more of the following flags, defined in the <sys/wait.h> header:

    WCONTINUED
        The waitpid() function shall report the status of any continued child
        process specified by pid whose status has not been reported since it
        continued from a job control stop.
    WNOHANG
        The waitpid() function shall not suspend execution of the calling thread
        if status is not immediately available for one of the child processes
        specified by pid.
    WUNTRACED
        The status of any child processes specified by pid that are stopped, and
        whose status has not yet been reported since they stopped, shall also be
        reported to the requesting process.

    If the calling process has SA_NOCLDWAIT set or has SIGCHLD set to SIG_IGN,
    and the process has no unwaited-for children that were transformed into
    zombie processes, the calling thread shall block until all of the children
    of the process containing the calling thread terminate, and wait() and
    waitpid() shall fail and set errno to [ECHILD].

    If wait() or waitpid() return because the status of a child process is
    available, these functions shall return a value equal to the process ID of
    the child process. In this case, if the value of the argument stat_loc is
    not a null pointer, information shall be stored in the location pointed to
    by stat_loc. The value stored at the location pointed to by stat_loc shall
    be 0 if and only if the status returned is from a terminated child process
    that terminated by one of the following means:

       1. The process returned 0 from main().

       2. The process called _exit() or exit() with a status argument of 0.

       3. The process was terminated because the last thread in the process
          terminated.

    Regardless of its value, this information may be interpreted using the
    following macros, which are defined in <sys/wait.h> and evaluate to integral
    expressions; the stat_val argument is the integer value pointed to by
    stat_loc.

    WIFEXITED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that terminated normally.
    WEXITSTATUS(stat_val)
        If the value of WIFEXITED(stat_val) is non-zero, this macro evaluates to
        the low-order 8 bits of the status argument that the child process
        passed to _exit() or exit(), or the value the child process returned
        from main().
    WIFSIGNALED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that terminated due to the receipt of a signal that was not caught (see
        <signal.h>).
    WTERMSIG(stat_val)
        If the value of WIFSIGNALED(stat_val) is non-zero, this macro evaluates
        to the number of the signal that caused the termination of the child
        process.
    WIFSTOPPED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that is currently stopped.
    WSTOPSIG(stat_val)
        If the value of WIFSTOPPED(stat_val) is non-zero, this macro evaluates
        to the number of the signal that caused the child process to stop.
    WIFCONTINUED(stat_val)
        Evaluates to a non-zero value if status was returned for a child process
        that has continued from a job control stop.

    It is unspecified whether the status value returned by calls to wait() or
    waitpid() for processes created by posix_spawn() or posix_spawnp() can
    indicate a WIFSTOPPED(stat_val) before subsequent calls to wait() or
    waitpid() indicate WIFEXITED(stat_val) as the result of an error detected
    before the new process image starts executing.

    It is unspecified whether the status value returned by calls to wait() or
    waitpid() for processes created by posix_spawn() or posix_spawnp() can
    indicate a WIFSIGNALED(stat_val) if a signal is sent to the parent's process
    group after posix_spawn() or posix_spawnp() is called.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that specified the WUNTRACED flag and did not specify the WCONTINUED flag,
    exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and
    WIFSTOPPED(*stat_loc) shall evaluate to a non-zero value.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that specified the WUNTRACED and WCONTINUED flags, exactly one of the macros
    WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), WIFSTOPPED(*stat_loc), and
    WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that did not specify the WUNTRACED or WCONTINUED flags, or by a call to the
    wait() function, exactly one of the macros WIFEXITED(*stat_loc) and
    WIFSIGNALED(*stat_loc) shall evaluate to a non-zero value.

    If the information pointed to by stat_loc was stored by a call to waitpid()
    that did not specify the WUNTRACED flag and specified the WCONTINUED flag,
    or by a call to the wait() function, exactly one of the macros
    WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and WIFCONTINUED(*stat_loc)
    shall evaluate to a non-zero value.

    If _POSIX_REALTIME_SIGNALS is defined, and the implementation queues the
    SIGCHLD signal, then if wait() or waitpid() returns because the status of a
    child process is available, any pending SIGCHLD signal associated with the
    process ID of the child process shall be discarded. Any other pending
    SIGCHLD signals shall remain pending.

    Otherwise, if SIGCHLD is blocked, if wait() or waitpid() return because the
    status of a child process is available, any pending SIGCHLD signal shall be
    cleared unless the status of another child process is available.

    For all other conditions, it is unspecified whether child status will be
    available when a SIGCHLD signal is delivered.

    There may be additional implementation-defined circumstances under which
    wait() or waitpid() report status. This shall not occur unless the calling
    process or one of its child processes explicitly makes use of a non-standard
    extension. In these cases the interpretation of the reported status is
    implementation-defined.

    If a parent process terminates without waiting for all of its child
    processes to terminate, the remaining child processes shall be assigned a
    new parent process ID corresponding to an implementation-defined system
    process.

RETURN VALUE

    If wait() or waitpid() returns because the status of a child process is
    available, these functions shall return a value equal to the process ID of
    the child process for which status is reported. If wait() or waitpid()
    returns due to the delivery of a signal to the calling process, -1 shall be
    returned and errno set to [EINTR]. If waitpid() was invoked with WNOHANG set
    in options, it has at least one child process specified by pid for which
    status is not available, and status is not available for any process
    specified by pid, 0 is returned. Otherwise, (pid_t)-1 shall be returned, and
    errno set to indicate the error.

ERRORS

    The wait() function shall fail if:

    [ECHILD]
        The calling process has no existing unwaited-for child processes.
    [EINTR]
        The function was interrupted by a signal. The value of the location
        pointed to by stat_loc is undefined.

    The waitpid() function shall fail if:

    [ECHILD]
        The process specified by pid does not exist or is not a child of the
        calling process, or the process group specified by pid does not exist or
        does not have any member process that is a child of the calling process.
    [EINTR]
        The function was interrupted by a signal. The value of the location
        pointed to by stat_loc is undefined.
    [EINVAL]
        The options argument is not valid.
*/
specification
void waitpid_spec( CallContext context, ProcessId pid, bool isStatLocNull, IntT options )
{
    IntTObj * wContinued;

    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        if(IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED)
            wContinued = readIntValueByName( context, "WCONTINUED" );
        else
            wContinued = NULL;

        /*
         * Implementations need not support the XSI optional functionality of WCONTINUED()
         * or WIFCONTINUED().
         */
        REQ( "app.waitpid.30", "", TODO_REQ() );

        return true;
    }
    coverage C_Priority
    {
        if ( processReallyHaveHighPriority( context ) )
        {
            return { PriorityIsReallyHigh, "Process with high priority" };
        }
        else if ( processReallyHaveLowPriority( context ) )
        {
            return { PriorityIsReallyLow, "Process with low priority" };
        }
        else
        {
            return { PriorityIsUnknown, "Process with unknown priority" };
        }
    }
    coverage C_Pid
    {
        if ( pid.process == -1 )
        {
            return { PidIsEqualToMinusOne, "pid is equal to (pid_t)-1" };
        }
        else if ( pid.process > 0 )
        {
            return { PidIsGreaterThanZero, "pid is greater than 0" };
        }
        else if ( pid.process == 0 )
        {
            return { PidIsEqualToZero, "pid is equal to 0" };
        }
        else // pid.process < -1
        {
            return { PidIsLessThanMinusOne, "pid is less than (pid_t)-1" };
        }
    }
    coverage C_StatLoc
    {
        if ( isStatLocNull )
        {
            return { StatLocIsNull, "stat_loc is NULL" };
        }
        else
        {
            return { StatLocIsNotNull, "stat_loc is not NULL" };
        }
    }
    coverage C_Options
    {
        if ( options == 0 )
        {
            return { OptionsIsEqualTo_0, "options is equal to 0" };
        }
        else if ( ( options & SUT_WUNTRACED ) == options )
        {
            return { OptionsIsEqualTo_WUNTRACED, "options is equal to WUNTRACED" };
        }
        else if ( ( options & SUT_WNOHANG ) == options )
        {
            return { OptionsIsEqualTo_WNOHANG, "options is equal to WNOHANG" };
        }
        else if ( ( options & ( SUT_WNOHANG | SUT_WUNTRACED ) ) == options )
        {
            return { OptionsIsEqualTo_WNOHANG_WUNTRACED, "options is equal to WNOHANG | WUNTRACED" };
        }

        #if IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED
            else if ( ( options & * wContinued ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED, "options is equal to WCONTINUED" };
                }
                else if ( ( options & ( * wContinued | SUT_WUNTRACED ) ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED_WUNTRACED, "options is equal to WCONTINUED | WUNTRACED" };
                }
                else if ( ( options & ( * wContinued | SUT_WNOHANG ) ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED_WNOHANG, "options is equal to WCONTINUED | WNOHANG" };
                }
                else if ( ( options & ( * wContinued | SUT_WNOHANG | SUT_WUNTRACED ) ) == options )
                {
                    return { OptionsIsEqualTo_WCONTINUED_WNOHANG_WUNTRACED,
                             "options is equal to WCONTINUED | WNOHANG | WUNTRACED"
                           };
                }
        #endif // IS_WCONTINUED_DEFINED == WCONTINUED_DEFINED

            else
            {
                return { OptionsIsNotValid, "The options argument is not valid." };
            }
    }
    post
    {
        return true;
    }
}

/********************************************************************/
/**                  Process Model Initialization                  **/
/********************************************************************/
void initProcessModel(void)
{
}

/********************************************************************/
/**                          Hash Table                            **/
/********************************************************************/
specification typedef struct HashSearchTable HashSearchTable = {};
HashSearchTable *create_HashSearchTable(Map* map, SizeT nel)
{
    HashSearchTable *res;
    res = create(&type_HashSearchTable, map, nel);
    return res;
}

/********************************************************************/
/**                       Process Meta Attributes                  **/
/********************************************************************/
static FilePermission* empty_FilePermission = NULL;

specification typedef struct WaitedSignal WaitedSignal = {};

WaitedSignal * create_WaitedSignal( UIntT nanoseconds, Signal * signal, TimerTObj * timer )
{
    return create( & type_WaitedSignal, nanoseconds, signal, timer );
}

ProcessMetaInfo create_ProcessMetaInfo( ProcessId processid )
{
SystemState* system;
ProcessMetaInfo meta;

  system = getSystemState( processid.system );

  memset(&meta,0,sizeof(meta));
  // Parent
  meta.parent = WrongProcessId;
  // Process Group
  meta.pgroup = WrongProcessId;
  // Session
  meta.session = WrongProcessId;
  // Controlling Terminal
  meta.cterm = NULL;

  // File System Attributes
  meta.workdir = WrongFileId;  // undefined

//#if defined(CTESK_VERSION)
    meta.root = (system != NULL) ? system->file_system->root : WrongFileId;
//#else
//  To be removed
//  meta.root = system->file_system->root;
//#endif

  meta.umask = create_FilePermissions(empty_FilePermission, empty_FilePermission, empty_FilePermission, Unknown_Bool3, Unknown_Bool3, Unknown_Bool3);

  // User Attributes
  meta.real_userid = (UidT)-1;
  meta.real_groupid = (GidT)-1;
  meta.effective_userid = (UidT)-1;
  meta.effective_groupid = (GidT)-1;
  meta.groups = NULL;
  meta.saved_setuserid  = (UidT)-1;
  meta.saved_setgroupid = (GidT)-1;
  // Nice Number
  meta.NZero = (UIntT)-1;
  meta.nice  = (UIntT)-1;
  // Clocks
  meta.clockIds = create_Set( & type_ClockidTObj );
  // Timers
  meta.timersToSignals = create_Map( & type_TimerTObj, & type_SignalObj );
  // signals waited from alarms and timers
  meta.waitedSignals = create_List( & type_WaitedSignal );
  return meta;
}

/********************************************************************/
/**                            Pam Data                            **/
/********************************************************************/

// struct PamData

specification typedef struct PamData PamData = {};

/* quasi constructor */
PamData * create_PamData( CString * service_name, CString * username, IntT pam_conversation, PamHandleT pamh ) {
    return create( & type_PamData, service_name, username, pam_conversation,
                                   pamh,
                                   false, false,
                                   create_Map( & type_IntTObj, & type_CString ), NULL
                 );
}

// static bool PamData::stringItemType( IntT itemType )
bool stringItemType_PamData( IntT itemType ) {
    return itemType == SUT_PAM_SERVICE || itemType == SUT_PAM_USER  || itemType == SUT_PAM_TTY         ||
           itemType == SUT_PAM_RHOST   || itemType == SUT_PAM_RUSER || itemType == SUT_PAM_USER_PROMPT;
}

// void PamData::setStringItem( IntT itemType, CString * itemValue )
void setStringItem_PamData( PamData * thisPamData, IntT itemType, CString * itemValue ) {
    assertion( thisPamData != NULL, "PamData::setStringItem : this is NULL\n" );
    assertion( stringItemType_PamData( itemType ), "PamData::setStringItem : stringItemType( %d ) is false\n", itemType );
    put_Map( thisPamData->stringItems, create_IntTObj( itemType ), itemValue );
}

// CString * PamData::getStringItem( IntT itemType ) const
CString * getStringItem_PamData( /* const */ PamData * thisPamData, IntT itemType ) {
    assertion( thisPamData != NULL, "PamData::getStringItem : this is NULL\n" );
    assertion( stringItemType_PamData( itemType ), "PamData::getStringItem : stringItemType( %d ) is false\n", itemType );
    return get_Map( thisPamData->stringItems, create_IntTObj( itemType ) );
}

// bool PamData::correspondTo( PamHandleT pamh ) const
bool correspondTo_PamData( /* const */ PamData * thisPamData, PamHandleT pamh ) {
    assertion( thisPamData != NULL, "PamData::correspondTo : this is NULL\n" );
    return equals_VoidTPtr( thisPamData->pamh, pamh );
}

// void PamData::setAuthentication( void )
void setAuthentication_PamData( PamData * thisPamData ) {
    assertion( thisPamData != NULL, "PamData::setAuthentication : this is NULL\n" );
    assertion( ! thisPamData->authenticate, "PamData::setAuthentication : authenticate is true\n" );
    thisPamData->authenticate = true;
}

// bool PamData::authenticated( void ) const
bool authenticated_PamData( /* const */ PamData * thisPamData ) {
    assertion( thisPamData != NULL, "PamData::authenticated : this is NULL\n" );
    return thisPamData->authenticate;
}

// void PamData::openSession( void )
void openSession_PamData( PamData * thisPamData ) {
    assertion( thisPamData != NULL, "PamData::openSession : this is NULL\n" );
    // assertion( thisPamData->authenticate, "PamData::openSession : authenticate is false\n" );
    thisPamData->sessionOpen = true;
}

// void PamData::closeSession( void )
void closeSession_PamData( PamData * thisPamData ) {
    assertion( thisPamData != NULL, "PamData::closeSession : this is NULL\n" );
    // assertion( thisPamData->authenticate, "PamData::closeSession : authenticate is false\n" );
    thisPamData->sessionOpen = false;
    thisPamData->authenticate = false;
}

// bool PamData::sessionOpened( void ) const
bool sessionOpened_PamData( /* const */ PamData * thisPamData ) {
    assertion( thisPamData != NULL, "PamData::sessionOpened : this is NULL\n" );
    return thisPamData->sessionOpen;
}

// static bool PamData::correctItemType( IntT itemType )
bool correctItemType_PamData( IntT itemType ) {
    return stringItemType_PamData( itemType ) || itemType == SUT_PAM_CONV;
}

// void PamData::setItem( IntT itemType, VoidTPtr itemPtr )
void setItem_PamData( PamData * thisPamData, IntT itemType, VoidTPtr itemPtr ) {
    assertion( thisPamData != NULL, "PamData::setItem : this is NULL\n" );
    assertion( correctItemType_PamData( itemType ), "PamData::setItem : correctItemType( %d ) is false\n", itemType );
    if ( stringItemType_PamData( itemType ) ) {
        CString * itemValue = readCString_VoidTPtr( itemPtr );
        setStringItem_PamData( thisPamData, itemType, itemValue );
    } else {
        // to do
        thisPamData->pamConv = NULL;
    }
}

// Object * PamData::getItem( IntT itemType ) const
Object * getItem( /* const */ PamData * thisPamData, IntT itemType ) {
    assertion( thisPamData != NULL, "PamData::getItem : this is NULL\n" );
    assertion( correctItemType_PamData( itemType ), "PamData::getItem : correctItemType( %d ) is false\n", itemType );
    if ( stringItemType_PamData( itemType ) ) { return getStringItem_PamData( thisPamData, itemType ); }
                                         else { return thisPamData->pamConv                          ; }
}

// struct PamDatas

specification typedef struct PamDatas PamDatas = {};

/* quasi constructor */
PamDatas * create_PamDatas( void ) { return create( & type_PamDatas, create_Set( & type_PamData ) ); }

// PamData * PamDatas::find( PamHandleT pamh )
PamData * find_PamDatas( PamDatas * thisPamDatas, PamHandleT pamh ) {
    int i;
    assertion( thisPamDatas != NULL, "PamDatas::find : this is NULL\n" );
    for ( i = 0; i < size_Set( thisPamDatas->datas ); i++ ) {
        PamData * pamData = get_Set( thisPamDatas->datas, i );
        if ( correspondTo_PamData( pamData, pamh ) ) { return pamData; }
    }
    return NULL;
}

// void PamDatas::add( const PamData * pamData )
void add_PamDatas( PamDatas * thisPamDatas, /* const */ PamData * pamData ) {
    assertion( thisPamDatas != NULL, "PamDatas::add : this is NULL\n" );
    add_Set( thisPamDatas->datas, pamData );
}

// void PamDatas::remove( PamHandleT pamh )
void remove_PamDatas( PamDatas * thisPamDatas, PamHandleT pamh ) {
    PamData * pamData;
    assertion( thisPamDatas != NULL, "PamDatas::remove : this is NULL\n" );
    pamData = find_PamDatas( thisPamDatas, pamh );
    remove_Set( thisPamDatas->datas, pamData );
}

/********************************************************************/
/**                          Process State                         **/
/********************************************************************/

specification typedef struct FinishedChild FinishedChild = {};

FinishedChild * create_FinishedChild( ProcessState * processState, IntT returnedValue )
{
    return create( & type_FinishedChild, processState, returnedValue );
}

// struct ProcessState

specification typedef struct ProcessState ProcessState = {};

/* quasi constructor */
ProcessState * create_ProcessState( ProcessId processid ) {
    // ProcessState * process;
    return create( & type_ProcessState,
                   processid,
                   // Process Environment
                   NULL,
                   // Memory State
                   create_List( &type_MemoryBlock ),
                   UnknownMMode,
                   // Threads State
                   create_Map( &type_ThreadIdObj, &type_ThreadState ),
                   // create_Map( &type_ThreadIdObj, NULL ), // TODO: to be removed
                   create_Set( &type_ThreadIdObj),
                   // File Descriptors
                   create_Map( &type_FileDescIdObj, &type_FileDescriptor ),
                   // Dir Descriptors
                   create_Set( &type_DIRT),
                       // staticData
                   create_Map(&type_CString, NULL),
                   // Process Meta Attributes
                   create_ProcessMetaInfo(processid),
                   // Process Signal Processing
                   create_Map( &type_SignalObj, &type_SigAction),
                   create_Map( &type_SignalObj, &type_List ),
                   create_Map( &type_SignalObj, &type_List ),
                   0,
                   // process is not stopped
                   false,
                   // process is not zombie
                   false,
                   // List of MMaps
                   create_List( &type_MMapState),
                   // 'sysconf' System Configuration Variables
                   create_Map( &type_IntTObj, &type_LongTObj ),
                   // Static Data
                   create_HashSearchTable(NULL, 0),
                   create_Set(&type_Passwd),
                   false,
                   true,
                   create_Set(&type_StartedThread),
                   NULL_VoidTPtr,
                   NULL_VoidTPtr,   // added by Alex Ivanov for buffer_string
                   // is now in fork-call, creating child
                   NULL,
                   // is now in exec-call
                   false,
                   // process has successfully executed one of the exec functions - used in pgroup
                   false,
                   // registered for call at exit
                   create_List( & type_CString ),
                   // finished child processes
                   create_Set( & type_FinishedChild ),
                   NULL,
                   // pipes between the calling program and the executed by popen commands
                   create_Set( & type_VoidTPtrObj ),
                   // prepared by getcontext
                   NULL,
                   // prepared by setjmp
                   NULL,
                   // prepared by sigsetjmp
                   NULL,
                   // Process Floating-Point Environment
                   NULL_VoidTPtr,
                   default_FEnvT(NULL_VoidTPtr),
                   //util.getopt
                   NULL,
                   NULL_VoidTPtr,
                   NULL_VoidTPtr,
                   0,0, // TermNLines, TermNCols
                   NULL, // riplines
                   NULL, // window_list
                   create_List(&type_Object),
                   false,
                   0, // slk_format
                   1,  // use_env
                   NULL,
                   NULL,
                   0,
                   create_Map(&type_Integer, &type_Integer),
                   create_Map(&type_Integer, &type_Integer),
                   NULL,
                   create_PamDatas(),
                   // Compiled regular expressions
                   NULL
                 );
} // create_ProcessState

// void ProcessState::initCompiledRegularExpressionsAsObject( Object * compiledRegularExpressionsAsObject )
void initCompiledRegularExpressionsAsObject_ProcessState
         ( ProcessState * thisProcessState, Object * compiledRegularExpressionsAsObject ) {
    assertion( thisProcessState != NULL, "ProcessState::initCompiledRegularExpressionsAsObject : this is NULL\n" );
    assertion( compiledRegularExpressionsAsObject != NULL,
               "ProcessState::initCompiledRegularExpressionsAsObject : compiledRegularExpressionsAsObject is NULL\n"
             );
    thisProcessState->compiledRegularExpressionsAsObject = compiledRegularExpressionsAsObject;
}

// Object * ProcessState::getCompiledRegularExpressionsAsObject( void )
Object * getCompiledRegularExpressionsAsObject_ProcessState( ProcessState * thisProcessState ) {
    assertion( thisProcessState != NULL, "ProcessState::getCompiledRegularExpressionsAsObject : this is NULL\n" );
    assertion( thisProcessState->compiledRegularExpressionsAsObject != NULL,
               "ProcessState::getCompiledRegularExpressionsAsObject : compiledRegularExpressionsAsObject is NULL\n"
             );
    return thisProcessState->compiledRegularExpressionsAsObject;
}

ProcessState* registerProcessState( ProcessId processid, ProcessState* process )
{
    SystemState* system;
    PThreadKey *resPThreadKey;
    VoidTPtr fakeKeyAddr;
    CallContext fakeContext;

    system = getSystemState( processid.system );
    if (system == NULL)
        return NULL;
    // process = create_ProcessState( processid );
    put_Map( system->processes, create_ProcessIdObj(processid), process );

    /* registering the key, that agent creates for it's own needs */
    fakeContext.process = processid.process;
    fakeContext.system = processid.system;
    fakeKeyAddr = generateVirtualPointer(fakeContext);
    resPThreadKey = create_PThreadKey(fakeKeyAddr, false);
    registerObjectInMemory(fakeKeyAddr, 0, resPThreadKey);

    return process;
}

ProcessState * registerProcess( ProcessId processid ) {
    return registerProcessState( processid, create_ProcessState( processid ) );
}

/********************************************************************/
/**                          Process Storage                       **/
/********************************************************************/
ProcessState* getProcessState( ProcessId processid )
{
    SystemState* systemState = getSystemState(processid.system);

    if (systemState == NULL)
        return NULL;
    return get_Map( systemState->processes, create_ProcessIdObj(processid) );
}

ProcessState* findProcessState( Map* processes, ProcessId processid )
{
    return get_Map( processes, create_ProcessIdObj(processid) );
}

ProcessState* getProcessState_CallContext( CallContext context )
{
    SystemState* systemState = getSystemState(context.system);

    if (systemState == NULL)
        return NULL;
    return get_Map( systemState->processes,
        create_ProcessIdObj(create_ProcessId(context.system, context.process)) );
}

ProcessState* getProcessState_ThreadId( ThreadId threadid )
{
    SystemState* systemState = getSystemState(threadid.system);

    if (systemState == NULL)
        return NULL;
    return get_Map( systemState->processes,
        create_ProcessIdObj(create_ProcessId(threadid.system, threadid.process)) );
}

ProcessState* getProcessState_FileDescId( FileDescId file_desc_id )
{
    SystemState* systemState = getSystemState(file_desc_id.system);

    if (systemState == NULL)
        return NULL;
    return get_Map( systemState->processes,
        create_ProcessIdObj(create_ProcessId(file_desc_id.system, file_desc_id.process)) );
}

/********************************************************************/
/**                       Static Process State                     **/
/********************************************************************/
Map* getProcessStaticDataMap(CallContext context)
{
    ProcessState* processState = getProcessState_CallContext(context);

    assertion(processState != NULL, "getProcessStateMap: processState is NULL");

    return processState->staticData;
}

Object* getProcessStaticData(CallContext context, CString* sDataName)
{
    Map* staticData = getProcessStaticDataMap(context);

    return get_Map(staticData, sDataName);
}

void setProcessStaticData(CallContext context, CString* sDataName, Object* Data)
{
    Map* staticData = getProcessStaticDataMap(context);

    if(!containsKey_Map(staticData, sDataName))
    {
        registerProcessStaticData(context, sDataName, Data);
        
        return;
    }

    put_Map(staticData, sDataName, Data);
}

int registerProcessStaticData(CallContext context, CString* sDataName, Object* initData)
{
    Map* staticData = getProcessStaticDataMap(context);

    if(containsKey_Map(staticData, sDataName)) return 1;

    put_Map(staticData, sDataName, initData);

    return 0;
}

/********************************************************************/
/**                         Helper Functions                       **/
/********************************************************************/
Map* getProcessEnvironment( CallContext context )
{
ProcessState* processState = getProcessState_CallContext(context);

  if (processState == NULL)
    return NULL;
  return processState->environ;
}

void setProcessEnvironment( CallContext context, Map* environ )
{
ProcessState* processState = getProcessState_CallContext(context);

  assertion( processState != NULL, "setProcessEnvironment: Process not found" );

  processState->environ = environ;
}

CString* getEnv_CallContext(CallContext context, CString* var)
{
    Map* environ = getProcessEnvironment(context);

    if(environ == NULL) return NULL;

    return get_Map(environ, var);
}

List* getMemoryState( CallContext context )
{
ProcessState* processState = getProcessState_CallContext(context);

  if (processState == NULL)
    return NULL;
  return processState->memory_blocks;
}

List* getMemoryState_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

  if (processState == NULL)
    return NULL;
  return processState->memory_blocks;
}

void toStandardMemMode(CallContext context)
{
}

Map* getThreads( CallContext context )
{
ProcessState* processState = getProcessState_CallContext(context);

  if (processState == NULL)
    return NULL;
  return processState->threads;
}

Map* getThreads_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

  if (processState == NULL)
    return NULL;
  return processState->threads;
}

int getNumberOfThreads( CallContext context )
{
  return size_Map(getThreads(context));
}

int getNumberOfThreads_ProcessId( ProcessId processid )
{
  return size_Map(getThreads_ProcessId(processid));
}

Map* getFileDescriptors( CallContext context )
{
ProcessState* processState = getProcessState_CallContext(context);

  if (processState == NULL)
    return NULL;
  return processState->file_descriptors;
}

Map* getFileDescriptors_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

  if (processState == NULL)
    return NULL;
  return processState->file_descriptors;
}

FEnvTPtr getDefaultFloatingPointEnvironment( CallContext context )
{
    ProcessState* processState = getProcessState_CallContext(context);

    assertion(processState != NULL,
        "getDefaultFloatingPointEnvironment: processState is NULL");

    return processState->fe_dfl_env;
}

FEnvTPtr getDefaultFloatingPointEnvironment_ProcessId( ProcessId processid )
{
    ProcessState* processState = getProcessState(processid);

    assertion(processState != NULL,
        "getDefaultFloatingPointEnvironment_ProcessId: processState is NULL");

    return processState->fe_dfl_env;
}

void setDefaultFloatingPointEnvironment( CallContext context, FEnvTPtr fe_dfl_env )
{
    ProcessState* processState = getProcessState_CallContext(context);

    assertion(processState != NULL,
        "setDefaultFloatingPointEnvironment: processState is NULL");

    processState->fe_dfl_env = fe_dfl_env;
}

void setDefaultFloatingPointEnvironment_ProcessId( ProcessId processid, FEnvTPtr fe_dfl_env )
{
    ProcessState* processState = getProcessState(processid);

    assertion(processState != NULL,
        "setDefaultFloatingPointEnvironment_ProcessId: processState is NULL");

    processState->fe_dfl_env = fe_dfl_env;
}

FEnvT* getFloatingPointEnvironment( CallContext context )
{
    ProcessState* processState = getProcessState_CallContext(context);

    assertion(processState != NULL,
        "getFloatingPointEnvironment: processState is NULL");

    return processState->fenv;
}

FEnvT* getFloatingPointEnvironment_ProcessId( ProcessId processid )
{
    ProcessState* processState = getProcessState(processid);

    assertion(processState != NULL,
        "getFloatingPointEnvironment_ProcessId: processState is NULL");

    return processState->fenv;
}

void setFloatingPointEnvironment( CallContext context, FEnvT *fenv)
{
    ProcessState* processState = getProcessState_CallContext(context);

    assertion(processState != NULL,
        "setFloatingPointEnvironment: processState is NULL");

    processState->fenv = fenv;
}

void setFloatingPointEnvironment_ProcessId( ProcessId processid, FEnvT *fenv )
{
    ProcessState* processState = getProcessState(processid);

    assertion(processState != NULL,
        "setFloatingPointEnvironment: processState is NULL");

    processState->fenv = fenv;
}

/*
 * Returns process group id of the process specified by processid
 * or WrongProcessId if the processid does not match any process.
 */
ProcessId getProcessGroupId_ProcessId(ProcessId processid)
{
ProcessState* processState = getProcessState(processid);

  if (processState == NULL)
    return WrongProcessId;
  return processState->meta.pgroup;
}

/*
 * Returns process group id of the process specified by processid
 * or WrongProcessId if the processid does not match any process.
 */
ProcessId getSessionId_ProcessId(ProcessId processid)
{
ProcessState* processState = getProcessState(processid);

  if (processState == NULL)
    return WrongProcessId;
  return processState->meta.session;
}

/*
 * Returns a name of the controlling terminal of the process specified by processid
 * or NULL if the process has no a controlling terminal.
 */
CString* getControllingTerminalName_ProcessId(ProcessId processid)
{
ProcessState* processState = getProcessState(processid);

  if (processState == NULL)
    return NULL;
  return processState->meta.cterm;
}

/*
 * Returns true if the process specified by processid has a controlling terminal.
 */
bool hasControllingTerminal_ProcessId(ProcessId processid)
{
ProcessState* processState = getProcessState(processid);

  assertion( processState != NULL, "hasControllingTerminal_ProcessId: process not found" );

  return (processState->meta.cterm != NULL);
}

/*
 * Returns true if the processid matches some process in the system.
 */
bool isValidProcessId(ProcessId processid)
{
ProcessState* processState = getProcessState(processid);

  return (processState != NULL);
}

/*
 * Returns true if the pgroupid matches some process group id in the system.
 */
bool isValidProcessGroupId(ProcessId pgroupid)
{
SystemState* systemState = getSystemState(pgroupid.system);
int i,size;

  if (systemState == NULL)
    return false;
  size = size_Map( systemState->processes );
  for( i = 0; i < size; i++ )
   {
    ProcessState* processState = get_Map( systemState->processes, key_Map( systemState->processes, i ) );
    if (equals_ProcessId(processState->meta.pgroup,pgroupid))
     {
      return true;
     }
   }
  return false;
}

/*
 * Returns true if the pgroupid matches some process group id in
 * the session specifed by sid.
 */
bool isValidProcessGroupIdInSession(ProcessId pgroupid, ProcessId sessionid)
{
SystemState* systemState = getSystemState(pgroupid.system);
int i,size;

  if (systemState == NULL)
    return false;
  size = size_Map( systemState->processes );
  for( i = 0; i < size; i++ )
   {
    ProcessState* processState = get_Map( systemState->processes, key_Map( systemState->processes, i ) );
    if (equals_ProcessId(processState->meta.pgroup,pgroupid))
     {
      return equals_ProcessId(processState->meta.session,sessionid);
     }
   }
  return false;
}

/*
 * Returns true if the pgroupid matches the orphaned process group id.
 * Orphaned process group is a process group in which the parent of
 * every member is either itself a member of the group or is not a member
 * of the group's session.
 */
Bool3 isOrphanedProcessGroupId(ProcessId pgroupid)
{
SystemState* systemState = getSystemState(pgroupid.system);
int i,size;

    if (systemState == NULL)
     {
        return Unknown_Bool3;
     }

    size = size_Map( systemState->processes );
    for( i = 0; i < size; i++ )
     {
        ProcessState* processState = get_Map( systemState->processes, key_Map( systemState->processes, i ) );
        if (equals_ProcessId(processState->meta.pgroup,pgroupid))
         {
            ProcessState* parent = get_Map( systemState->processes, create_ProcessIdObj(processState->meta.parent) );
            if (parent != NULL)
             {
                if ( !equals_ProcessId(processState->meta.pgroup,parent->meta.pgroup)
                  && equals_ProcessId(processState->meta.session,parent->meta.session)
                   )
                 {
                    return False_Bool3;
                 }
             }
            else
             {
                if (!equals_ProcessId( getSpecialSystemParent(pgroupid.system), processState->meta.parent ))
                 {
                    return Unknown_Bool3;
                 }
             }
         }
     }
  return True_Bool3;
}

/*
 * Return real/effective user/group id of the process specified by processid.
 */
UidTObj* getRealUserId_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return NULL;

    return create_UidTObj(processState->meta.real_userid);
}

GidTObj* getRealGroupId_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return NULL;

    return create_GidTObj(processState->meta.real_groupid);
}

UidTObj* getEffectiveUserId_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return NULL;

    return create_UidTObj(processState->meta.effective_userid);
}

GidTObj* getEffectiveGroupId_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return NULL;

    return create_GidTObj(processState->meta.effective_groupid);
}

/*
 * Returns fileid of the current root of the process specified by processid.
 */
FileId getRoot_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return WrongFileId;

    return processState->meta.root;
}

/*
 * Sets a root directory of the process specified by processid.
 */
void setRoot_ProcessId( ProcessId processid, FileId root )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return;

    processState->meta.root = root;
}

/*
 * Returns fileid of the current work directory of the process specified by processid.
 */
FileId getWorkDirectory_ProcessId( ProcessId processid )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return WrongFileId;

    return processState->meta.workdir;
}

/*
 * Sets a new current work directory of the process specified by processid.
 */
void setWorkDirectory_ProcessId( ProcessId processid, FileId workdir )
{
ProcessState* processState = getProcessState(processid);

    if(processState == NULL)
        return;

    processState->meta.workdir = workdir;
}

/*
 * Gets set of children for the calling process.
 */
Set /* ProcessState */ * getChildren_CallContext( CallContext context ) {
    Set * result = create_Set( & type_ProcessState );
    SystemState * systemState = getSystemState( context.system );
    int i;
    for ( i = 0; i < size_Map( systemState->processes ); i++ ) {
        ProcessIdObj * key = key_Map( systemState->processes, i );
        ProcessState * processState = get_Map( systemState->processes, key );
        if ( processState->meta.parent.process == context.process ) { add_Set( result, processState ); }
    }
    return result;
}

/*
 * Gets set of processes in the same group as the calling process.
 */
Set /* ProcessState */ * getProcessesInGroup_CallContext( CallContext context ) {
    Set * result = create_Set( & type_ProcessState );
    SystemState * systemState = getSystemState( context.system );
    ProcessState * callingProcessState = getProcessState_CallContext( context );
    ProcessId groupId = callingProcessState->meta.pgroup;
    int i;
    for ( i = 0; i < size_Map( systemState->processes ); i++ ) {
        ProcessIdObj * key = key_Map( systemState->processes, i );
        ProcessState * processState = get_Map( systemState->processes, key );
        if ( processState->meta.pgroup.process == groupId.process ) { add_Set( result, processState ); }
    }
    return result;
}

/*
 * Gets set of processes in the same session as the calling process.
 */
Set /* ProcessState */ * getProcessesInSession_CallContext( CallContext context ) {
    Set * result = create_Set( & type_ProcessState );
    SystemState * systemState = getSystemState( context.system );
    ProcessState * callingProcessState = getProcessState_CallContext( context );
    ProcessId sessionId = callingProcessState->meta.session;
    int i;
    for ( i = 0; i < size_Map( systemState->processes ); i++ ) {
        ProcessIdObj * key = key_Map( systemState->processes, i );
        ProcessState * processState = get_Map( systemState->processes, key );
        if ( processState->meta.session.process == sessionId.process ) { add_Set( result, processState ); }
    }
    return result;
}

/********************************************************************/
/**                    Signal Helper Functions                     **/
/********************************************************************/

/*
 * Returns new unique signal identificator
 */
int MakeNewCurrentUID(ProcessState* prSt)
{
    prSt->current_unique_sigid++;
    return prSt->current_unique_sigid;
}

/*
 * Returns true if the signal is blocked by the process specified by processid.
 */
bool isSignalBlocked_ProcessId(ProcessId processid, SignalVal signal)
{
  ProcessState* processState = getProcessState(processid);
  SignalObj* sig = create_SignalObj(signal);
  ThreadState* thrSt;
  StartedThread* thrInd;
  Set* mask;
  bool res = true;
  int i;

  assertion( processState != NULL, "isSignalBlocked_ProcessId: Process not found" );

  for (i = size_Set(processState->startedThreads) - 1; i >=0; i--)
  {
      thrInd = get_Set(processState->startedThreads, i);
      thrSt = getThread(thrInd->thid);
      mask = get_List(thrSt->signal_masks_stack, 0);
      if (!contains_Set(mask, sig))
      {
          res = false;
          break;
      }
  }
  return res;

  //return contains_Set( processState->blocked_signals, create_SignalObj(signal) );
}

/*
 * Returns signal handler of the process specified for the signal.
 * If the processid does not match any process in the system
 * SUT_SIG_ERR is returned.
 */
SignalHandler getSignalHandler_ProcessId(ProcessId processid, SignalVal signal)
{
ProcessState* processState = getProcessState(processid);
SignalHandler* res;

  if (processState == NULL)
   {
    return SUT_SIG_ERR;
   }
  res = get_Map( processState->signal_actions, create_SignalObj(signal) );
  if (res == NULL)
   {
    return SUT_SIG_ERR;
   }
  return *res;
}

/*
 * Returns true iff the signal is handled by the process specified by processid.
 */
bool isSignalHandled_ProcessId(ProcessId processid, SignalVal signal)
{
    SignalHandler signal_handler = getSignalHandler_ProcessId(processid, signal);

    return signal_handler == SIG_USER_CATCHER
        || signal_handler == SIG_USER_AGENT;
}

/*
 * Temporary here.
 */
void sendSignalToProcess(ProcessId processid, SignalVal signal)
{
}

void sendSignalToProcessGroup(ProcessId processid, SignalVal signal)
{
SystemState* systemState = getSystemState(processid.system);
int i,size;

  assertion( systemState != NULL, "sendSignalToProcessGroup: System not found" );
  size = size_Map( systemState->processes );
  for( i = 0; i < size; i++ )
   {
    ProcessState* processState = get_Map( systemState->processes, key_Map( systemState->processes, i ) );
    // SignalHandler* handler = get_Map( processState->signal_actions, create_SignalObj(signal) );

    // Incorrect temporary actions: do nothing
   }
}

/*
 * Temporary here.
 */
bool signalShouldBeSentToProcess(ProcessId processid, SignalVal signal)
{
  return true;
}

bool signalShouldBeSentToProcessGroup(ProcessId processid, SignalVal signal)
{
  return true;
}

/********************************************************************/
/**                    Signal Helper Functions                     **/
/********************************************************************/
void PrintfProcessSignalQueue(ProcessState* prSt)
{
    int i, size;
    Map* temp_map;
    List* temp_list;
    SignalObj* sig;

    if (prSt == NULL)
    {
        return;
    }
    temp_map = prSt->signal_queue;
    size = size_Map(temp_map);

    verbose("Process signal queue. %d\n", prSt->processid.process);
    for (i = 0; i < size; i++)
    {
        sig = key_Map(temp_map, i);
        temp_list = get_Map(temp_map, sig);
        if (temp_list == NULL)
        {
            continue;
        }
        verbose("signal %d - number of signals in the queue %d\n", (int)(*sig), size_List(temp_list));
    }
    verbose("\n");
    return;
}

void PrintfProcessProcessedSignals(ProcessState* prSt)
{
    int i, size, j, size2;
    Map* temp_map;
    List* temp_list;
    List* temp_list2;
    SignalObj* sig;

    temp_map = prSt->processed_signals;
    size = size_Map(temp_map);

    verbose("Processed signals of process %d\n", prSt->processid.process);
    for (i = 0; i < size; i++)
    {
        sig = key_Map(temp_map, i);
        temp_list = get_Map(temp_map, sig);
        if (temp_list == NULL)
        {
            continue;
        }
        verbose("signal %d - number of processed signals:", (int)(*sig));

        size2 = size_List(temp_list);
        for (j = 0; j < size2; j++)
        {
            temp_list2 = get_List(temp_list, j);
            if (temp_list2 == NULL)
            {
                continue;
            }
            verbose(" %d", size_List(temp_list2));
        }
        verbose("\n");
    }
    verbose("\n");
    return;
}

void PrintfProcessSignalActions(ProcessState* prSt)
{
    int i, size;
    Map* temp_map;
    List* temp_list;
    SignalObj* sig;
    SigAction* sa;

    temp_map = prSt->signal_actions;
    size = size_Map(temp_map);

    verbose("Process signal actions. %d all %d\n", prSt->processid.process, size);
    for (i = 0; i < size; i++)
    {
        sig = key_Map(temp_map, i);
        sa = get_Map(temp_map, sig);
        if (sa == NULL)
        {
            continue;
        }
        verbose("signal %d - sigaction %d\n", (int)(*sig), sa->m_sa_handler);
    }
    verbose("\n");
    return;
}

/********************************************************************/
/**                    Zombie Process Functions                    **/
/********************************************************************/
bool isProcessZombie(ProcessState* pr_st)
{
    //verbose("prSt %p\n", pr_st);
    if (pr_st == NULL)
    {
        //verbose("return true in if\n");
        return true;
    };
    if (pr_st->is_zombie)
    {
        //verbose("isZombie returns true\n");
    }
    else
    {
        //verbose("isZombie returns false\n");
    }
    return pr_st->is_zombie;
}
void setProcessZombie(ProcessState* pr_st)
{
    if (pr_st == NULL)
    {
        return;
    };
    pr_st->is_zombie = true;
    return;
}
