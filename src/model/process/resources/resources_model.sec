  /*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "process/resources/resources_config.h"
#include "process/resources/resources_model.seh"
#include "config/system_config.seh"
#include "data/errno_model.seh"
#include "common/common_media.seh"
#include "process/process/process_model.seh"

#pragma SEC subsystem resources "process.resources"



/* 
   The group of functions 'process.resources' consists of: 
       getrlimit [2]
       getrlimit64 [2]
       getrusage [2]
       setrlimit [2]
       setrlimit64 [3]
       ulimit [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getrlimit, setrlimit - control maximum resource consumption

SYNOPSIS

    [XSI]  #include <sys/resource.h>

    int getrlimit(int resource, struct rlimit *rlp);
    int setrlimit(int resource, const struct rlimit *rlp); 

DESCRIPTION

    The getrlimit() function shall get, and the setrlimit() function shall set,
    limits on the consumption of a variety of resources.

    Each call to either getrlimit() or setrlimit() identifies a specific 
    resource to be operated upon as well as a resource limit. A resource limit 
    is represented by an rlimit structure. The rlim_cur member specifies the 
    current or soft limit and the rlim_max member specifies the maximum or hard
    limit. Soft limits may be changed by a process to any value that is less 
    than or equal to the hard limit. A process may (irreversibly) lower its 
    hard limit to any value that is greater than or equal to the soft limit. 
    Only a process with appropriate privileges can raise a hard limit. Both 
    hard and soft limits can be changed in a single call to setrlimit() subject
    to the constraints described above.

    The value RLIM_INFINITY, defined in <sys/resource.h>, shall be considered 
    to be larger than any other limit value. If a call to getrlimit() returns 
    RLIM_INFINITY for a resource, it means the implementation shall not enforce
    limits on that resource. Specifying RLIM_INFINITY as any resource limit 
    value on a successful call to setrlimit() shall inhibit enforcement of that
    resource limit.

    The following resources are defined:

    RLIMIT_CORE

        This is the maximum size of a core file, in bytes, that may be created 
        by a process. A limit of 0 shall prevent the creation of a core file.
        If this limit is exceeded, the writing of a core file shall terminate 
        at this size.

    RLIMIT_CPU

        This is the maximum amount of CPU time, in seconds, used by a process. 
        If this limit is exceeded, SIGXCPU shall be generated for the process. 
        If the process is catching or ignoring SIGXCPU, or all threads 
        belonging to that process are blocking SIGXCPU, the behavior is 
        unspecified.

    RLIMIT_DATA

        This is the maximum size of a process' data segment, in bytes. If this
        limit is exceeded, the malloc() function shall fail with errno set to 
        [ENOMEM].

    RLIMIT_FSIZE
        
        This is the maximum size of a file, in bytes, that may be created by a
        process. If a write or truncate operation would cause this limit to be 
        exceeded, SIGXFSZ shall be generated for the thread. If the thread is 
        blocking, or the process is catching or ignoring SIGXFSZ, continued 
        attempts to increase the size of a file from end-of-file to beyond the 
        limit shall fail with errno set to [EFBIG].

    RLIMIT_NOFILE
    
      This is a number one greater than the maximum value that the system may 
      assign to a newly-created descriptor. If this limit is exceeded, 
      functions that allocate a file descriptor shall fail with errno set to 
      [EMFILE]. This limit constrains the number of file descriptors that a 
      process may allocate.

    RLIMIT_STACK
        
        This is the maximum size of the initial thread's stack, in bytes. The 
        implementation does not automatically grow the stack beyond this limit.
        If this limit is exceeded, SIGSEGV shall be generated for the thread. 
        If the thread is blocking SIGSEGV, or the process is ignoring or 
        catching SIGSEGV and has not made arrangements to use an alternate 
        stack, the disposition of SIGSEGV shall be set to SIG_DFL before it is 
        generated.

    RLIMIT_AS

        This is the maximum size of a process' total available memory, in 
        bytes. If this limit is exceeded, the malloc() and mmap() functions 
        shall fail with errno set to [ENOMEM]. In addition, the automatic stack
        growth fails with the effects outlined above.

    When using the getrlimit() function, if a resource limit can be represented
    correctly in an object of type rlim_t, then its representation is returned;
    otherwise, if the value of the resource limit is equal to that of the 
    corresponding saved hard limit, the value returned shall be RLIM_SAVED_MAX;
    otherwise, the value returned shall be RLIM_SAVED_CUR.

    When using the setrlimit() function, if the requested new limit is 
    RLIM_INFINITY, the new limit shall be "no limit"; otherwise, if the 
    requested new limit is RLIM_SAVED_MAX, the new limit shall be the 
    corresponding saved hard limit; otherwise, if the requested new limit is 
    RLIM_SAVED_CUR, the new limit shall be the corresponding saved soft limit; 
    otherwise, the new limit shall be the requested value. In addition, if the 
    corresponding saved limit can be represented correctly in an object of type
    rlim_t then it shall be overwritten with the new limit.

    The result of setting a limit to RLIM_SAVED_MAX or RLIM_SAVED_CUR is 
    unspecified unless a previous call to getrlimit() returned that value as 
    the soft or hard limit for the corresponding resource limit.

    The determination of whether a limit can be correctly represented in an 
    object of type rlim_t is implementation-defined. For example, some 
    implementations permit a limit whose value is greater than RLIM_INFINITY 
    and others do not.

    The exec family of functions shall cause resource limits to be saved.

RETURN VALUE

    Upon successful completion, getrlimit() and setrlimit() shall return 0.
    Otherwise, these functions shall return -1 and set errno to indicate the 
    error.

ERRORS

    The getrlimit() and setrlimit() functions shall fail if:

    [EINVAL]
        
        An invalid resource was specified; or in a setrlimit() call, the new 
        rlim_cur exceeds the new rlim_max.

    [EPERM]
        
        The limit specified to setrlimit() would have raised the maximum limit 
        value, and the calling process does not have appropriate privileges.

    The setrlimit() function may fail if:
    
    [EINVAL]
    
        The limit specified cannot be lowered because current usage is already 
        higher than the limit.
*/

/* [getrlimit64 and setrlimit64 specifications are
 * assumed to be equivalent to getrlimit & setrlimit specification] */
/* START EQUIVALENT SPECIFICATION: getrlimit_spec */

specification
IntT getrlimit_spec( CallContext context, IntT resource, RLimitT * rlp, ErrorCode * errno )
{
    RSavedLimitT * saved_lim;
    pre
    {
        return true;
    }
    coverage C
    {
        //res: norm, left, extrem
        //rlp: null, not null

        if( 0<=resource && resource<10)
        {
            //norm res
            if(rlp==NULL)
                return {NormResNullRlp, "Normal resource, NULL rlp"};
            else
                return {NormResNotNullRlp, "Normal resource, not NULL rlp"};

        }
        else if(resource>0)
        {
            //wrong res
            if(rlp==NULL)
                return {WrongResNullRlp, "Wrong resource, NULL rlp"};
            else
                return {WrongResNotNullRlp, "Wrong resource, not NULL rlp"};
        }
        else
        {
            //extr res
            if(rlp==NULL)
                return {ExtrResNullRlp, "Extremal resource, NULL rlp"};
            else
                return {ExtrResNotNullRlp, "Extremal resource, not NULL rlp"};
        }

    }
    post
    {
        ERROR_BEGIN(POSIX_GETRLIMIT, "getrlimit.10.02",  getrlimit_spec == -1, *errno )
        /*
         * The getrlimit() and setrlimit() functions shall fail if:
         * 
         * [EINVAL]
         *     An invalid resource was specified; or in a setrlimit() call, the new rlim_cur exceeds the new 
         *     rlim_max.
         */
            ERROR_SHALL(POSIX_GETRLIMIT, EINVAL,"getrlimit.12.01",TODO_ERR(EINVAL));
                       
        ERROR_END()

        /* Upon successful completion, getrlimit() and setrlimit() shall return 0. */
        REQ("getrlimit.10.01","Upon successful completion, getrlimit() and setrlimit() shall return 0",
            getrlimit_spec==0
           );
            
        /* [rlp == NULL shall cause failure] */
        REQ("","rlp!=NULL", rlp!=NULL);
              
        /*
         * When using the getrlimit() function, if a resource limit can be represented 
         * correctly in an object of type rlim_t, then its representation is returned;
         * otherwise, if the value of the resource limit is equal to that of the corresponding saved hard 
         * limit, the value returned shall be RLIM_SAVED_MAX; otherwise, the value returned shall be RLIM_SAVED_CUR.
         */
        saved_lim = get_Map(RSavedLimits, create_IntTObj(resource));
        if(saved_lim!=NULL)
        {
            if(canBeRepresentedAsRLimT(saved_lim->rlim_cur))
            {
                REQ("getrlimit.06","rlim_cur can be represented, shall be returned",
                    compare_RLimT(rlp->rlim_cur,toRLimT_RSavedLimitT(saved_lim,0))==0
                    );
            }
            else if(toRLimT_RSavedLimitT(saved_lim,0) == toRLimT_RSavedLimitT(saved_lim,1))
            {
                REQ("getrlimit.06","RLIM_SAVED_MAX shall be returned",
                    rlp->rlim_cur == SUT_RLIM_SAVED_MAX 
                    );
            }
            else
            {
                REQ("getrlimit.06","rlim_cur==RLIM_SAVED_CUR shall be returned",
                    rlp->rlim_cur == SUT_RLIM_SAVED_CUR
                    );
            }
            
            if(canBeRepresentedAsRLimT(saved_lim->rlim_max))
            {
                REQ("getrlimit.06","rlim_max can be represented, shall be returned",
                    compare_RLimT(rlp->rlim_max,toRLimT_RSavedLimitT(saved_lim,1))==0
                    );
            }
            else
            {
                REQ("getrlimit.06","rlim_max==RLIM_SAVED_CUR shall be returned",
                    rlp->rlim_max == SUT_RLIM_SAVED_MAX
                    );
            }
        }

        /*
         * The getrlimit() function shall get
         * limits on the consumption of a variety of resources.
         */
        REQ("getrlimit.01", "shall get limits", true);
        
        /* The value RLIM_INFINITY, defined in <sys/resource.h>, shall be 
         * considered to be larger than any other limit value.
         */
        IMPLEMENT_REQ("getrlimit.04");

        /* The determination of whether a limit can be correctly represented in 
         * an object of type rlim_t is implementation-defined.
         */
        IMPLEMENT_REQ("getrlimit.09");

        return true;
    }
}

/* END EQUIVALENT SPECIFICATION: getrlimit_spec */

/* START EQUIVALENT SPECIFICATION: setrlimit_spec */

specification
IntT setrlimit_spec( CallContext context, IntT resource, RLimitT * rlp, ErrorCode * errno )
{
    RSavedLimitT * saved_lim_pre;
    RSavedLimitT * saved_lim_post;
    pre
    {
        /*
         * The result of setting a limit to RLIM_SAVED_MAX or RLIM_SAVED_CUR is
         * unspecified unless a previous call to getrlimit() returned that value 
         * as the soft or hard limit for the corresponding resource limit.
         */
    /*    if( (rlp!=NULL )
         && ( rlp->rlim_cur == SUT_RLIM_SAVED_MAX 
           || rlp->rlim_cur == SUT_RLIM_SAVED_CUR
           || rlp->rlim_max == SUT_RLIM_SAVED_MAX
           || rlp->rlim_max == SUT_RLIM_SAVED_CUR
            )
          )
            REQ("app.setrlimit.08", "getrlimit shall be called before setting a limit to RLIM_SAVED_MAX or RLIM_SAVED_CUR", 
                containsKey_Map(RSavedLimits,create_IntTObj(resource))
               );
     */

        saved_lim_pre = get_Map(RSavedLimits,create_IntTObj(resource));
        return true;
    }
    coverage CRes
    {      
        if( containsKey_Map(RSavedLimits,create_IntTObj(resource)))
        {
            return {NormRes, "Normal resource value"};
        }
        else if(resource>0)
        {
            return {WrongRes, "Wrong resource"};
        }
        else
        {
            return {ExtrRes, "Extremal resource value"};
        }
    }
    coverage CCur
    {
        if(rlp == NULL)
        {
            return {RlpNULL, "rlp is NULL"};
        }
        else
        {
            if( saved_lim_pre!=NULL )
            {
                if(compare_RLimT(rlp->rlim_cur,rlp->rlim_max)>0)                
                    return {CurExcHard, "cur would exceed hard"};
                
                if(compare_RLimT(rlp->rlim_cur,toRLimT_RSavedLimitT(saved_lim_pre,1))>0)
                        return {CurExcOldHard, "rlim_cur exceeds old hardlim"};

                /*
                if(rlp->rlim_cur==SUT_RLIM_SAVED_CUR)
                    return {SavedCur,"rlim_cur == RLIM_SAVED_CUR"};

                if(rlp->rlim_cur==SUT_RLIM_SAVED_MAX)
                    return {SavedMax,"rlim_cur == RLIM_SAVED_MAX"};
                    /**/
                if(rlp->rlim_cur==SUT_RLIM_INFINITY)
                    return {Infinity,"rlim_cur == RLIM_INFINITY"};

                if(compare_RLimT(rlp->rlim_cur,rlp->rlim_max)==0)
                    return {EqMax, "rlim_cur equal to rlim_max"};

                return {CurNormal, "nothing special"};
            }
            else
                return {WrongResource, "Wrong resource"};
        }
    }
    coverage CMax
    {
        if(rlp == NULL)
        {
            return {RlpNULL, "rlp is NULL"};
        }
        else
        {
            if( saved_lim_pre!=NULL )
            {
                if(compare_RLimT(rlp->rlim_max,toRLimT_RSavedLimitT(saved_lim_pre,1))>0)
                {
                    if( isEnoughPrivilegesHardIncrease(context,resource) )
                        return {MaxIncrAllowed, "rlim_max increasing is allowed"};
                    else
                        return {MaxIncrNotAllowed, "rlim_max increasing is unallowed"};
                }

                if(compare_RLimT(rlp->rlim_cur,rlp->rlim_max)>0)                
                    return {CurExcHard, "cur would exceed hard"};
                
                if(compare_RLimT(toRLimT_RSavedLimitT(saved_lim_pre,0),rlp->rlim_max)>0)
                    return {CurExcOldHard, "old cur exceeds rlim_max"};

              /*  if(rlp->rlim_max==SUT_RLIM_SAVED_CUR)
                    return {SavedCur,"rlim_max == RLIM_SAVED_CUR"};

                if(rlp->rlim_max==SUT_RLIM_SAVED_MAX)
                    return {SavedMax,"rlim_max == RLIM_SAVED_MAX"};
                    /**/

                if(rlp->rlim_max==SUT_RLIM_INFINITY)
                    return {Infinity,"rlim_max == RLIM_INFINITY"};

                if(compare_RLimT(rlp->rlim_max,toRLimT_RSavedLimitT(saved_lim_pre,1))<0)
                    return {MaxDecr, "rlim_max decreasing"};

                return {CurNormal, "nothing special"};
            }
            else
                return {WrongResource, "Wrong resource"};
        }
    }
    post
    {
        ERROR_BEGIN(POSIX_SETRLIMIT, "setrlimit.10.02", setrlimit_spec==-1, *errno)
        /*
         * The getrlimit() and setrlimit() functions shall fail if:
         * [EINVAL]
         *      An invalid resource was specified; or in a setrlimit() call, the new 
         *      rlim_cur exceeds the new rlim_max.
         */
            ERROR_SHALL(POSIX_SETRLIMIT, EINVAL,"setrlimit.12.01", 
                        saved_lim_pre == NULL
                        || (rlp!=NULL && compare_RLimT(rlp->rlim_cur,rlp->rlim_max)>0)
                       );

        /*
         * The getrlimit() and setrlimit() functions shall fail if:
         * [EPERM]
         *      The limit specified to setrlimit() would have raised the maximum limit value, 
         *      and the calling process does not have appropriate privileges.
         */
            ERROR_SHALL(POSIX_SETRLIMIT, EPERM,"setrlimit.12.02", 
                        rlp != NULL && saved_lim_pre != NULL
                        && compare_RLimT(rlp->rlim_max,toRLimT_RSavedLimitT(saved_lim_pre,1))>0
                        && !isEnoughPrivilegesHardIncrease(context,resource)
                       )

        /*
         * The setrlimit() function may fail if:
         * [EINVAL]
         *      The limit specified cannot be lowered because current usage is already higher than the limit.
         */
            ERROR_MAY(POSIX_SETRLIMIT, EINVAL,"setrlimit.13.01", 
                      false // Unable to check. Even with getrusage() function.
                     )

        ERROR_END()

        /* Upon successful completion, getrlimit() and setrlimit() shall return 0. */
        REQ("setrlimit.10.01","Upon successful completion, getrlimit() and setrlimit() shall return 0",
            setrlimit_spec==0
        );

        /* [rlp == NULL can not lead to successfull comletion] */
        REQ("","rlp!=NULL", rlp!=NULL);
            
        /*
         * Soft limits may be changed by a process to any value 
         * that is less than or equal to the hard limit.
         */
        REQ("setrlimit.02", "On success soft limits shall be less than or equal to the hard limit", 
            compare_RLimT(rlp->rlim_cur,rlp->rlim_max)<=0
           );
       
        /*
         * A process may (irreversibly) lower its hard limit to any value that is greater than 
         * or equal to the soft limit. Only a process with appropriate privileges can raise a hard limit.
         */
        if(saved_lim_pre!=NULL)
        {  
            REQ("setrlimit.03", "hard limit constraints", 
                compare_RLimT(rlp->rlim_max,toRLimT_RSavedLimitT(saved_lim_pre,1))<=0
                || isEnoughPrivilegesHardIncrease(context,resource)
               );
        }

        /*
         * When using the setrlimit() function, if the requested new limit is RLIM_INFINITY,
         * the new limit shall be "no limit"; otherwise, if the requested new limit is 
         * RLIM_SAVED_MAX, the new limit shall be the corresponding saved hard limit; otherwise, if 
         * the requested new limit is RLIM_SAVED_CUR, the new limit shall be the corresponding 
         * saved soft limit; otherwise, the new limit shall be the requested value. In addition,
         * if the corresponding saved limit can be represented correctly in an object of type 
         * rlim_t then it shall be overwritten with the new limit.
         */
        saved_lim_post = get_Map(RSavedLimits,create_IntTObj(resource));
        
        if(saved_lim_post == NULL)
        {
            traceUserInfo("Resource limits have not been saved");
            return false;
        }
        
        if(rlp->rlim_cur == SUT_RLIM_INFINITY) 
        {
            REQ("setrlimit.07","rlim_cur shall equal to RLIM_INFINITY",
                (saved_lim_post->isNoLimit_cur == true)
                && canBeRepresentedAsRLimT(saved_lim_post->rlim_cur)
                );
        }
        else if(rlp->rlim_cur == SUT_RLIM_SAVED_MAX)
        {
            REQ("setrlimit.07","rlim_cur shall equal to saved max",
                toRLimT_RSavedLimitT(saved_lim_post,0) == toRLimT_RSavedLimitT(saved_lim_pre,1)
                );
        }
        else if(rlp->rlim_cur == SUT_RLIM_SAVED_CUR)
        {
            REQ("setrlimit.07","rlim_cur shall equal to saved cur",
                toRLimT_RSavedLimitT(saved_lim_post,0) == toRLimT_RSavedLimitT(saved_lim_pre,0)
                );
        }
        else
        {
            REQ("setrlimit.07","rlim_cur shall be the requested value",
                saved_lim_post->isNoLimit_cur == false
                && saved_lim_post->rlim_cur == rlp->rlim_cur
                );               
        }
        
        if(rlp->rlim_max == SUT_RLIM_INFINITY) 
        {
            REQ("setrlimit.07","rlim_max shall equal to RLIM_INFINITY",
                saved_lim_post->isNoLimit_max == true 
                && canBeRepresentedAsRLimT(saved_lim_post->rlim_max)
                );
        }
        else if(rlp->rlim_max == SUT_RLIM_SAVED_MAX)
        {
            REQ("setrlimit.07","rlim_max shall equal to saved max",
                toRLimT_RSavedLimitT(saved_lim_post,1) == toRLimT_RSavedLimitT(saved_lim_pre,1)
                );
        }
        else if(rlp->rlim_max == SUT_RLIM_SAVED_CUR)
        {
            REQ("setrlimit.07","rlim_max shall equal to saved cur",
                toRLimT_RSavedLimitT(saved_lim_post,1) == toRLimT_RSavedLimitT(saved_lim_pre,0)
                );
        }
        else
        {
            REQ("setrlimit.07","rlim_max shall be the requested value",
                saved_lim_post->isNoLimit_max == false
                && saved_lim_post->rlim_max == rlp->rlim_max
               );               
        }
        
        /*
         * The setrlimit() function shall get
         * limits on the consumption of a variety of resources.
         */
        REQ("setrlimit.01", "shall get limits", true);

        return true;
    }
}
/* END EQUIVALENT SPECIFICATION: setrlimit_spec */

/* [getrlimit64 and setrlimit64 specifications are
 * assumed to be equivalent to getrlimit & setrlimit specification] */

/* REFERENCES: getrlimit64_spec() refers the getrlimit_spec() */


specification
IntT getrlimit64_spec( CallContext context, IntT resource, RLimit64T * rlp, ErrorCode * errno )
{
    RSavedLimitT * saved_lim;
    pre
    {
        /*[!no specification]*/
        REQ("","rlp != NULL", rlp != NULL);
        return true;
    }
    coverage C
    {
        //res: norm, left, extrem
        //rlp: null, not null

        if( 0<=resource && resource<10)
        {
            return {NormRes, "Normal resource"};

        }
        else if(resource>0)
        {
            return {WrongRes,"Wrong resource"};
        }
        else
        {
            return {ExtrRes, "Extremal resource"};
        }

    }
    post
    {
        ERROR_BEGIN(POSIX_GETRLIMIT64, "getrlimit64.getrlimit.10.02", getrlimit64_spec == -1, *errno )
        /*
         * The getrlimit() and setrlimit() functions shall fail if:
         * 
         * [EINVAL]
         *     An invalid resource was specified; or in a setrlimit() call, the new rlim_cur exceeds the new 
         *     rlim_max.
         */
            ERROR_SHALL(POSIX_GETRLIMIT64, EINVAL,"getrlimit64.getrlimit.12.01", TODO_ERR(EINVAL));
        ERROR_END()

        /* Upon successful completion, getrlimit() and setrlimit() shall return 0. */
        REQ("getrlimit64.getrlimit.10.01","Upon successful completion, getrlimit() and setrlimit() shall return 0",
            getrlimit64_spec==0
           );
            
        /* [rlp == NULL shall cause failure] */
        REQ("","rlp!=NULL", rlp!=NULL);

        /*
         * The getrlimit() function shall get
         * limits on the consumption of a variety of resources.
         */
        REQ("getrlimit64.getrlimit.01", "rlp is correct rlimit64 object", is_correct_RLimit64T(rlp));
            
        /*
         * When using the getrlimit() function, if a resource limit can be represented 
         * correctly in an object of type rlim_t, then its representation is returned;
         * otherwise, if the value of the resource limit is equal to that of the corresponding saved hard 
         * limit, the value returned shall be RLIM_SAVED_MAX; otherwise, the value returned shall be RLIM_SAVED_CUR.
         */
        saved_lim = get_Map(RSavedLimits, create_IntTObj(resource));
        if(saved_lim!=NULL)
        {
            if(canBeRepresentedAsRLim64T(saved_lim->rlim_cur))
            {
                REQ("getrlimit64.getrlimit.06","rlim_cur can be represented, shall be returned",
                    compare_RLim64T(rlp->rlim_cur,toRLim64T_RSavedLimitT(saved_lim,0))==0
                   );
            }
            else if(toRLim64T_RSavedLimitT(saved_lim,0) == toRLim64T_RSavedLimitT(saved_lim,1))
            {
                REQ("getrlimit64.getrlimit.06","RLIM64_SAVED_MAX shall be returned",
                    rlp->rlim_cur == SUT_RLIM64_SAVED_MAX 
                   );
            }
            else
            {
                REQ("getrlimit64.getrlimit.06","rlim_cur==RLIM64_SAVED_CUR shall be returned",
                    rlp->rlim_cur == SUT_RLIM64_SAVED_CUR
                   );
            }

            if(canBeRepresentedAsRLim64T(saved_lim->rlim_max))
            {
                REQ("getrlimit64.getrlimit.06","rlim_max can be represented, shall be returned",
                    compare_RLim64T(rlp->rlim_max,toRLim64T_RSavedLimitT(saved_lim,1))==0
                   );
            }
            else
            {
                REQ("getrlimit64.getrlimit.06","rlim_max==RLIM64_SAVED_CUR shall be returned",
                    rlp->rlim_max == SUT_RLIM64_SAVED_MAX
                   );
            }
        }
        
        return true;
    }
}

//This specification refers to: setrlimit64, setrlimit
specification
IntT setrlimit64_spec( CallContext context, IntT resource, RLimit64T * rlp, ErrorCode * errno )
{
    RSavedLimitT * saved_lim_pre;
    RSavedLimitT * saved_lim_post;
    pre
    {
        /*[no specification]*/
        REQ("","rlp != NULL", rlp != NULL);
        
        saved_lim_pre = get_Map(RSavedLimits,create_IntTObj(resource));
        return true;
    }
    coverage CRes
    {      
        if( containsKey_Map(RSavedLimits,create_IntTObj(resource)))
        {
            return {NormRes, "Normal resource value"};
        }
        else if(resource>0)
        {
            return {WrongRes, "Wrong resource"};
        }
        else
        {
            return {ExtrRes, "Extremal resource value"};
        }
    }
    coverage CCur
    {
        if( saved_lim_pre!=NULL )
        {
            if(compare_RLim64T(rlp->rlim_cur,rlp->rlim_max)>0)                
                return {CurExcHard, "cur would exceed hard"};
            
            if(compare_RLim64T(rlp->rlim_cur,toRLim64T_RSavedLimitT(saved_lim_pre,1))>0)
                return {CurExcOldHard, "rlim_cur exceeds old hardlim"};
            
                /*
                if(rlp->rlim_cur==SUT_RLIM64_SAVED_CUR)
                return {SavedCur,"rlim_cur == RLIM_SAVED_CUR"};
                
                  if(rlp->rlim_cur==SUT_RLIM64_SAVED_MAX)
                  return {SavedMax,"rlim_cur == RLIM_SAVED_MAX"};
            /**/
            if(rlp->rlim_cur==SUT_RLIM64_INFINITY)
                return {Infinity,"rlim_cur == RLIM64_INFINITY"};
            
            if(compare_RLim64T(rlp->rlim_cur,rlp->rlim_max)==0)
                return {EqMax, "rlim_cur equal to rlim_max"};
            
            return {CurNormal, "nothing special"};
        }
        else
            return {WrongResource, "Wrong resource"};
    }
    coverage CMax
    {
        if( saved_lim_pre!=NULL )
        {
            if(compare_RLim64T(rlp->rlim_max,toRLim64T_RSavedLimitT(saved_lim_pre,1))>0)
            {
                if( isEnoughPrivilegesHardIncrease(context,resource) )
                    return {MaxIncrAllowed, "rlim_max increasing is allowed"};
                else
                    return {MaxIncrNotAllowed, "rlim_max increasing is unallowed"};
            }
            
            if(compare_RLim64T(rlp->rlim_cur,rlp->rlim_max)>0)                
                return {CurExcHard, "cur would exceed hard"};
            
            if(compare_RLim64T(toRLim64T_RSavedLimitT(saved_lim_pre,0),rlp->rlim_max)>0)
                return {CurExcOldHard, "old cur exceeds rlim_max"};
            
                /*  if(rlp->rlim_max==SUT_RLIM64_SAVED_CUR)
                return {SavedCur,"rlim_max == RLIM64_SAVED_CUR"};
                
                  if(rlp->rlim_max==SUT_RLIM64_SAVED_MAX)
                  return {SavedMax,"rlim_max == RLIM64_SAVED_MAX"};
            /**/
            
            if(rlp->rlim_max==SUT_RLIM64_INFINITY)
                return {Infinity,"rlim_max == RLIM64_INFINITY"};
            
            if(compare_RLim64T(rlp->rlim_max,toRLim64T_RSavedLimitT(saved_lim_pre,1))<0)
                return {MaxDecr, "rlim_max decreasing"};
            
            return {CurNormal, "nothing special"};
        }
        else
            return {WrongResource, "Wrong resource"};

    }
    post
    {
        ERROR_BEGIN(POSIX_SETRLIMIT64, "setrlimit64.setrlimit.12", setrlimit64_spec==-1, *errno)
        /*
         * The getrlimit() and setrlimit() functions shall fail if:
         * [EINVAL]
         *      An invalid resource was specified; or in a setrlimit() call, the new 
         *      rlim_cur exceeds the new rlim_max.
         */
            ERROR_SHALL(POSIX_SETRLIMIT64, EINVAL,"setrlimit64.setrlimit.12.01", 
                        saved_lim_pre == NULL
                        || (rlp!=NULL && compare_RLim64T(rlp->rlim_cur,rlp->rlim_max)>0)
                       );

        /*
         * The getrlimit() and setrlimit() functions shall fail if:
         * [EPERM]
         *      The limit specified to setrlimit() would have raised the maximum limit value, 
         *      and the calling process does not have appropriate privileges.
         */
            ERROR_SHALL(POSIX_SETRLIMIT64, EPERM,"setrlimit64.setrlimit.12.02", 
                        rlp != NULL && saved_lim_pre != NULL
                        && compare_RLim64T(rlp->rlim_max,toRLim64T_RSavedLimitT(saved_lim_pre,1))>0
                        && !isEnoughPrivilegesHardIncrease(context,resource)
                       )

        /*
         * The setrlimit() function may fail if:
         * [EINVAL]
         *      The limit specified cannot be lowered because current usage is already higher than the limit.
         */
            ERROR_MAY(POSIX_SETRLIMIT64, EINVAL,"setrlimit64.setrlimit.13.01", 
                      false // Unable to check. Even with getrusage() function.
                     )

        ERROR_END()


        /* Upon successful completion, getrlimit() and setrlimit() shall return 0. */
        REQ("setrlimit64.setrlimit.10.01","Upon successful completion, getrlimit() and setrlimit() shall return 0",
            setrlimit64_spec==0
           );

        /* [rlp == NULL can not lead to successfull comletion] */
        REQ("","rlp!=NULL", rlp!=NULL);
            
        /*
         * Soft limits may be changed by a process to any value 
         * that is less than or equal to the hard limit.
         */
        REQ("setrlimit64.setrlimit.02", "On success soft limits shall be less than or equal to the hard limit", 
            compare_RLim64T(rlp->rlim_cur,rlp->rlim_max)<=0
           );
           
        /*
         * A process may (irreversibly) lower its hard limit to any value that is greater than 
         * or equal to the soft limit. Only a process with appropriate privileges can raise a hard limit.
         */
        if(saved_lim_pre!=NULL)
        {  
            REQ("setrlimit64.setrlimit.03", "hard limit constraints", 
                compare_RLim64T(rlp->rlim_max,toRLim64T_RSavedLimitT(saved_lim_pre,1))<=0
                || isEnoughPrivilegesHardIncrease(context,resource)
               );
        }
            
        /*
         * When using the setrlimit() function, if the requested new limit is RLIM_INFINITY,
         * the new limit shall be "no limit"; otherwise, if the requested new limit is 
         * RLIM_SAVED_MAX, the new limit shall be the corresponding saved hard limit; otherwise, if 
         * the requested new limit is RLIM_SAVED_CUR, the new limit shall be the corresponding 
         * saved soft limit; otherwise, the new limit shall be the requested value. In addition,
         * if the corresponding saved limit can be represented correctly in an object of type 
         * rlim_t then it shall be overwritten with the new limit.
         */
        saved_lim_post = get_Map(RSavedLimits,create_IntTObj(resource));
            
        if(saved_lim_post == NULL)
        {
            traceUserInfo("Resource limits have not been saved");
            return false;
        }
            
        if(rlp->rlim_cur == SUT_RLIM64_INFINITY) 
        {
            REQ("setrlimit64.setrlimit.07","rlim_cur shall equal to RLIM64_INFINITY",
                (saved_lim_post->isNoLimit_cur == true)
                && canBeRepresentedAsRLim64T(saved_lim_post->rlim_cur)
               );
        }
        else if(rlp->rlim_cur == SUT_RLIM64_SAVED_MAX)
        {
            REQ("setrlimit64.setrlimit.07","rlim_cur shall equal to saved max",
                toRLim64T_RSavedLimitT(saved_lim_post,0) == toRLim64T_RSavedLimitT(saved_lim_pre,1)
               );
        }
        else if(rlp->rlim_cur == SUT_RLIM64_SAVED_CUR)
        {
            REQ("setrlimit64.setrlimit.07","rlim_cur shall equal to saved cur",
                toRLim64T_RSavedLimitT(saved_lim_post,0) == toRLim64T_RSavedLimitT(saved_lim_pre,0)
               );
        }
        else
        {
            REQ("setrlimit64.setrlimit.07","rlim_cur shall be the requested value",
                saved_lim_post->isNoLimit_cur == false
                && saved_lim_post->rlim_cur == rlp->rlim_cur
               );               
        }
            
        if(rlp->rlim_max == SUT_RLIM64_INFINITY) 
        {
            REQ("setrlimit64.setrlimit.07","rlim_max shall equal to RLIM64_INFINITY",
                saved_lim_post->isNoLimit_max == true 
                && canBeRepresentedAsRLim64T(saved_lim_post->rlim_max)
               );
        }
        else if(rlp->rlim_max == SUT_RLIM64_SAVED_MAX)
        {
            REQ("setrlimit64.setrlimit.07","rlim_max shall equal to saved max",
                toRLim64T_RSavedLimitT(saved_lim_post,1) == toRLim64T_RSavedLimitT(saved_lim_pre,1)
               );
        }
        else if(rlp->rlim_max == SUT_RLIM64_SAVED_CUR)
        {
            REQ("setrlimit64.setrlimit.07","rlim_max shall equal to saved cur",
                toRLim64T_RSavedLimitT(saved_lim_post,1) == toRLim64T_RSavedLimitT(saved_lim_pre,0)
               );
        }
        else
        {
            REQ("setrlimit64.setrlimit.07","rlim_max shall be the requested value",
                saved_lim_post->isNoLimit_max == false
                && saved_lim_post->rlim_max == rlp->rlim_max
               );               
        }
            
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME
    
    getrusage - get information about resource utilization

SYNOPSIS

    [XSI]  #include <sys/resource.h>
    
    int getrusage(int who, struct rusage *r_usage); 

DESCRIPTION

    The getrusage() function shall provide measures of the resources used by 
    the current process or its terminated and waited-for child processes. If 
    the value of the who argument is RUSAGE_SELF, information shall be returned
    about resources used by the current process. If the value of the who 
    argument is RUSAGE_CHILDREN, information shall be returned about resources 
    used by the terminated and waited-for children of the current process. If 
    the child is never waited for (for example, if the parent has SA_NOCLDWAIT 
    set or sets SIGCHLD to SIG_IGN), the resource information for the child 
    process is discarded and not included in the resource information provided 
    by getrusage().

    The r_usage argument is a pointer to an object of type struct rusage in 
    which the returned information is stored.

RETURN VALUE

    Upon successful completion, getrusage() shall return 0; otherwise, -1 shall
    be returned and errno set to indicate the error.    

ERRORS

    The getrusage() function shall fail if:

    [EINVAL]
    
        The value of the who argument is not valid.  
*/
specification
IntT getrusage_spec( CallContext context, IntT who, RusageT * r_usage, ErrorCode * errno)
{
    pre
    {   
        /*
         * The r_usage argument is a pointer to an object of type struct rusage
         * in which the returned information is stored.
         */
        REQ("app.getrusage.05", "r_usage!=NULL", r_usage!=NULL);
        
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        ERROR_BEGIN(POSIX_GETRUSAGE, "getrusage.06.02", getrusage_spec==-1 , *errno )
        /*
         * The getrusage() function shall fail if:
         * [EINVAL]
         *     The value of the who argument is not valid.
         */
         ERROR_SHALL3(POSIX_GETRUSAGE, EINVAL,"getrusage.08.01",
                      (who == SUT_RUSAGE_SELF || who == SUT_RUSAGE_CHILDREN)?False_Bool3:Unknown_Bool3
                     )
        ERROR_END()
        
        
        /* Upon successful completion, getrusage() shall return 0 */
        REQ("getrusage.06.01", "Upon successful completion shall return 0", getrusage_spec==0);
        
        /*
         * The getrusage() function shall provide measures of the resources
         * used by the current process or its terminated and waited-for child processes.
         */
        REQ("getrusage.01", 
            "Shall provide measures of the resources", 
            true);
        
        
        if(who == SUT_RUSAGE_SELF)
        {
            
            /* If the value of the who argument is RUSAGE_SELF, information shall be 
             * returned about resources used by the current process.
             */
            REQ("getrusage.02", 
                "If the value of the who argument is RUSAGE_SELF", 
                true);
        }
        else if(who == SUT_RUSAGE_CHILDREN)
        {
            
            /*
             * If the value of the who argument is RUSAGE_CHILDREN, information shall be returned about 
             * resources used by the terminated and waited-for children of the current process.
             */
            REQ("getrusage.03", 
                "If the value of the who argument is RUSAGE_CHILDREN", 
                true);
               
            /*
             * If the child is never waited for (for example, if the parent has SA_NOCLDWAIT 
             * set or sets SIGCHLD to SIG_IGN), the resource information for the child process 
             * is discarded and not included in the resource information provided by getrusage().
             */
            REQ("getrusage.04", 
                "If the child is never waited for", 
                true);
        }
               
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group
  
  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    ulimit - get and set process limits

SYNOPSIS

    [XSI]  
    #include <ulimit.h>
    long ulimit(int cmd, ...); 

DESCRIPTION

    The ulimit() function shall control process limits. The process limits that
    can be controlled by this function include the maximum size of a single 
    file that can be written (this is equivalent to using setrlimit() with 
    RLIMIT_FSIZE). The cmd values, defined in <ulimit.h>, include:

    UL_GETFSIZE
        Return the file size limit (RLIMIT_FSIZE) of the process. The limit 
        shall be in units of 512-byte blocks and shall be inherited by child 
        processes. Files of any size can be read. The return value shall be the
        integer part of the soft file size limit divided by 512. If the result
        cannot be represented as a long, the result is unspecified.

    UL_SETFSIZE
        Set the file size limit for output operations of the process to the 
        value of the second argument, taken as a long, multiplied by 512. If 
        the result would overflow an rlim_t, the actual value set is 
        unspecified. Any process may decrease its own limit, but only a process 
        with appropriate privileges may increase the limit. The return value 
        shall be the integer part of the new file size limit divided by 512.

    The ulimit() function shall not change the setting of errno if successful.

    As all return values are permissible in a successful situation, an 
    application wishing to check for error situations should set errno to 0,
    then call ulimit(), and, if it returns -1, check to see if errno is 
    non-zero.

RETURN VALUE

    Upon successful completion, ulimit() shall return the value of the 
    requested limit. Otherwise, -1 shall be returned and errno set to indicate 
    the error.

ERRORS

    The ulimit() function shall fail and the limit shall be unchanged if:
    [EINVAL]
        The cmd argument is not valid.
    [EPERM]
        A process not having appropriate privileges attempts to increase its 
        file size limit.
*/
/* errno is assumed to be in/out parameter */
specification
LongT ulimit_spec( CallContext context, IntT cmd, List * params, ErrorCode * errno )
{
    RSavedLimitT * saved_lim_pre = get_Map(RSavedLimits, create_IntTObj(SUT_RLIMIT_FSIZE));
    RSavedLimitT * saved_lim_post;
    LongT param2;
    LLongT tmp;

    pre
    {
        /* [shall call getrlimit, for example, before call ulimit] */
        REQ("","RLIMIT_FSIZE shall be known",saved_lim_pre!=NULL);

        if(cmd == SUT_UL_GETFSIZE)
        {   
            /*If the result cannot be represented as a long, the result is unspecified.*/   
            REQ("app.ulimit.03","result shall be represented as long",
                toRLimT_RSavedLimitT(saved_lim_pre,0) / 512 <= max_LongT
                );
            
        }
        else if( cmd == SUT_UL_SETFSIZE)
        {
            /* Set the file size limit for output operations of the process to the
             * value of the second argument, taken as a long, multiplied by 512.
             */
            REQ("app.ulimit.12","at least one parameter of type long required",
                size_List(params)>0
                && type(get_List(params,0)) == &type_LongTObj
               );          
            param2 = *(LongTObj *)get_List(params,0);
  
            /* If the result would overflow an rlim_t, the actual value set is unspecified.*/
            tmp = param2;
            REQ("app.ulimit.05","The result shall be representable by rlim_t",
                canBeRepresentedAsRLimT(tmp * 512)
               );
            traceFormattedUserInfo("param2 = %i", param2);
        }
        
        return true;
    }
    coverage C
    {
        if(cmd == SUT_UL_GETFSIZE)
        {
            return { CmdGetFSize, "cmd == UL_GETFSIZE" };
        }
        else if(cmd == SUT_UL_SETFSIZE)
        {
            if(param2 <= toRLimT_RSavedLimitT(saved_lim_pre,1))
            {
                if(param2 > toRLimT_RSavedLimitT(saved_lim_pre,0))
                    return{ paramBetwSoftAndHard, "soft < param < hard"};
                else
                    return{ paramLessSoft, "param < soft"};
            }
            else
            {
                if(isEnoughPrivilegesHardIncrease(context,SUT_RLIMIT_FSIZE))
                    return{ HardShallIncrease, "Hard limit shall increase"};
                else
                    return{ HardWouldIncrease, "Hard limit would increase"};
            }
        }
        else
        {
            return { anotherCmd, "Another cmd" };
        }
    }
    post
    {
        
        saved_lim_post = get_Map(RSavedLimits, create_IntTObj(SUT_RLIMIT_FSIZE));

                 
        ERROR_BEGIN(POSIX_ULIMIT, "ulimit.09.02",
                    ulimit_spec==-1 && *errno!=@*errno,
                    *errno
                   )
           /*
            * The ulimit() function shall fail and the limit shall be unchanged if:
            * 
            * [EPERM]
            * 
            * A process not having appropriate privileges attempts to increase its file size limit.
            * 
            */
            tmp = param2;
            ERROR_SHALL(POSIX_ULIMIT, EPERM,"ulimit.11.02",
                        cmd == SUT_UL_SETFSIZE 
                        && param2 > toRLimT_RSavedLimitT(saved_lim_pre,1) / 512
                        && !isEnoughPrivilegesHardIncrease(context,SUT_RLIMIT_FSIZE)
                       )

            /* [UL_GETFSIZE and UL_SETFSIZE are correct cmd values] */       
            ERROR_SHALL3(POSIX_ULIMIT, EINVAL, "ulimit.11.01",
                         (cmd == SUT_UL_GETFSIZE || cmd == SUT_UL_SETFSIZE )?False_Bool3:Unknown_Bool3
                        )

            if( (ulimit_spec==-1) && (*errno == SUT_EINVAL || *errno == SUT_EPERM) )
            {
                REQ("ulimit.11","the limit shall be unchanged", 
                    equals(saved_lim_post,saved_lim_pre)
                    );

                REQ("ulimit.11","the limit shall be unchanged", 
                    equals(saved_lim_post,saved_lim_pre)
                    );
            }

        ERROR_END()

        
        /* The ulimit() function shall not change the setting of errno if successful. */
        REQ("ulimit.08","shall not change the setting of errno if successful",
            *errno==@*errno        
           );
            
        if(cmd == SUT_UL_GETFSIZE)
        {   
            /* The return value shall be the integer part of the soft file size limit divided by 512.*/
            REQ("ulimit.02","UL_GETFSIZE:The return value shall be the soft file size limit divided by 512",
                ulimit_spec == toRLimT_RSavedLimitT(saved_lim_pre,0) / 512
               );
        }
        if(cmd == SUT_UL_SETFSIZE)
        {
            /*
             * shall be inherited by child processes.
             */
            REQ("ulimit.01", 
                "Shall be inherited by child processes", 
                true);    
                
            /* Set the file size limit for output operations of the process to the value 
             * of the second argument, taken as a long, multiplied by 512.
             */
            REQ("ulimit.04", "saved_lim_post!=NULL", saved_lim_post!=NULL);
            
            tmp = param2;              
            REQ("ulimit.04", "stored value", 
                tmp*512 == toRLimT_RSavedLimitT(saved_lim_post,0)
                && tmp*512 == toRLimT_RSavedLimitT(saved_lim_post,1) 
               );
               
            /* Any process may decrease its own limit, but only a process with 
             * appropriate privileges may increase the limit.
             */
            if(param2 > toRLimT_RSavedLimitT(saved_lim_pre,1) / 512)
            {
                REQ("ulimit.06","only a process with appropriate privileges may increase the limit",
                    isEnoughPrivilegesHardIncrease(context, SUT_RLIMIT_FSIZE)      
                   );
            }
                
            if(getUlimitBehaviorKind() == UlimitBehaviorLSB )
            {
               /* The return value shall be the integer part of the new file size limit divided by 512. */
               REQ("ulimit.02","UL_SETFSIZE:The return value shall be the integer part of the new file size limit divided by 512",
                   ulimit_spec == toRLimT_RSavedLimitT(saved_lim_post,0)/512
                  );
            }
            else /* [Behaviour == Glibc] */
            {
                /* [Shall return 0 if success] */
                REQ("","Glibc:Shall return 0 if success",
                    ulimit_spec==0 
                   );
            }
        }
             
        return true;
    }
}

/************************************************************************/
/*                       Interface Data                                 */
/************************************************************************/

specification typedef struct RLimitT RLimitT ={};

specification typedef struct RLimit64T RLimit64T ={};

specification typedef struct RSavedLimitT RSavedLimitT = {};

specification typedef struct RusageT RusageT = {};

RLimitT * create_RLimitT
(
    RLimT rlim_cur,
    RLimT rlim_max
)
{
    return create(&type_RLimitT,
        rlim_cur, rlim_max);
}

RLimit64T * create_RLimit64T
(
  RLim64T rlim_cur,
  RLim64T rlim_max
)
{
    return create(&type_RLimit64T,
        rlim_cur,
        rlim_max);
}

RusageT * create_RusageT
(
    TimeSpecT ru_utime,
    TimeSpecT ru_stime,
    LongT ru_maxrss,
    LongT ru_ixrss,
    LongT ru_idrss,
    LongT ru_isrss,
    LongT ru_minflt,
    LongT ru_majflt,
    LongT ru_nswap,
    LongT ru_inblock,
    LongT ru_oublock,
    LongT ru_msgsnd,
    LongT ru_msgrcv,
    LongT ru_nsignals,
    LongT ru_nvcsw,
    LongT ru_nivcsw
)
{
    return create(&type_RusageT,
        ru_utime,
        ru_stime,
        ru_maxrss,
        ru_ixrss,
        ru_idrss,
        ru_isrss,
        ru_minflt,
        ru_majflt,
        ru_nswap,
        ru_inblock,
        ru_oublock,
        ru_msgsnd,
        ru_msgrcv,
        ru_nsignals,
        ru_nvcsw,
        ru_nivcsw);

}

RSavedLimitT * create_RSavedLimitT(
  ULLongT rlim_cur,
  bool isNoLimit_cur, 
  ULLongT rlim_max,    
  bool isNoLimit_max
)
{
    return create(&type_RSavedLimitT,
        rlim_cur,
        isNoLimit_cur,
        rlim_max,
        isNoLimit_max);

}


/*[Unable to define such a long constants. Initialized in init_resource_model().]*/
ULLongT SUT_RLIM64_INFINITY;
ULLongT SUT_RLIM64_SAVED_CUR;
ULLongT SUT_RLIM64_SAVED_MAX;

/************************************************************************/
/*                        Model Data                                    */
/************************************************************************/

Map * RSavedLimits; /* [IntTObj * resource -m-> RSavedLimitT * saved_lim] */

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

RSavedLimitT * create_RSavedLimitT_RLimitT(RLimitT * rlp)
{
    RSavedLimitT * res = create_RSavedLimitT(0,0,0,0);

    if(rlp->rlim_cur == SUT_RLIM_INFINITY)
    {
        res->isNoLimit_cur = true;
        res->rlim_cur = 0;
    }
    else
    {
        res->isNoLimit_cur = false;
        res->rlim_cur = rlp->rlim_cur;
    }

    if(rlp->rlim_max == SUT_RLIM_INFINITY)
    {
        res->isNoLimit_max = true;
        res->rlim_max = 0;
    }
    else
    {
        res->isNoLimit_max = false;
        res->rlim_max = rlp->rlim_max;
    }
    
    return res;
}

RSavedLimitT * create_RSavedLimitT_RLimit64T(RLimit64T * rlp)
{
    RSavedLimitT * res = create_RSavedLimitT(0,0,0,0);

    if(rlp->rlim_cur == SUT_RLIM64_INFINITY)
    {
        res->isNoLimit_cur = true;
        res->rlim_cur = 0;
    }
    else
    {
        res->isNoLimit_cur = false;
        res->rlim_cur = rlp->rlim_cur;
    }

    if(rlp->rlim_max == SUT_RLIM64_INFINITY)
    {
        res->isNoLimit_max = true;
        res->rlim_max = 0;
    }
    else
    {
        res->isNoLimit_max = false;
        res->rlim_max = rlp->rlim_max;
    }
    
    return res;
}


RLimT toRLimT_RSavedLimitT(RSavedLimitT * saved_lim,int who)
{
    if(who==0)
    {
        if(saved_lim->isNoLimit_cur)
            return SUT_RLIM_INFINITY;
        else
            return saved_lim->rlim_cur;
    }
    else
    {
        if(saved_lim->isNoLimit_max)
            return SUT_RLIM_INFINITY;
        else
            return saved_lim->rlim_max;
    }
}

RLim64T toRLim64T_RSavedLimitT(RSavedLimitT * saved_lim,int who)
{
    if(who==0)
    {
        if(saved_lim->isNoLimit_cur)
            return SUT_RLIM64_INFINITY;
        else
            return saved_lim->rlim_cur;
    }
    else
    {
        if(saved_lim->isNoLimit_max)
            return SUT_RLIM64_INFINITY;
        else
            return saved_lim->rlim_max;
    }
}

int compare_RLimT(RLimT val1,RLimT val2)
{
    if(val2==val1)
        return 0;

    if(val1 == SUT_RLIM_INFINITY)
    {
        return 1;
    }
    else
    {
        if(val2 == SUT_RLIM_INFINITY)
            return -1;

        if(val2>val1)
            return -1;
        
        return 1;
    }
}

int compare_RLim64T(RLim64T val1,RLim64T val2)
{
    if(val1==val2)
        return 0;

    if(val1 == SUT_RLIM64_INFINITY)
    {
        return 1;
    }
    else
    {
        if(val2 == SUT_RLIM64_INFINITY)
            return -1;

        if(val2>val1)
            return -1;
        
        return 1;
    }
}

/* [Checks whether the process has enough privileges for increasing the 
 * corresponding hard limit.] 
 */
bool isEnoughPrivilegesHardIncrease( CallContext context, IntT resource )
{
    ProcessState * process_state = getProcessState_CallContext( context );
    ProcessMetaInfo * meta = & process_state->meta;
    
    return (meta->effective_userid==0); 
}

/* [getrlimit.09]
 * The determination of whether a limit can be correctly represented in an 
 * object of type rlim_t is implementation-defined. For example, some 
 * implementations permit a limit whose value is greater than RLIM_INFINITY and
 * others do not.
 */
/* [Checks whether the value of type ULongT can be represented correctly
 *  in an object of type RLimT]
 */
bool canBeRepresentedAsRLimT(ULLongT val)
{
    return (val!=SUT_RLIM_INFINITY)
        && (val<=max_ULongT);
}

bool canBeRepresentedAsRLim64T(ULLongT val)
{
    return (val<=SUT_RLIM64_INFINITY)
        && (val<=max_ULLongT);
}

bool is_correct_RLimT(RLimT val)
{
    return true;
}

bool is_correct_RLim64T(RLim64T val)
{
    return true;
}


bool is_correct_RLimitT(RLimitT * val)
{
    /* [getrlimit.04]
     * The value RLIM_INFINITY, defined in <sys/resource.h>, shall be 
     * considered to be larger than any other limit value.
     */
    
    return (compare_RLimT(val->rlim_cur,val->rlim_max)<=0)
          && is_correct_RLimT(val->rlim_cur)
          && is_correct_RLimT(val->rlim_max);    
}

bool is_correct_RLimit64T(RLimit64T * val)
{
    /* [getrlimit.04]
     * The value RLIM_INFINITY, defined in <sys/resource.h>, shall be 
     * considered to be larger than any other limit value.
     */

    return (compare_RLim64T(val->rlim_cur,val->rlim_max)<=0)
          && is_correct_RLim64T(val->rlim_cur)
          && is_correct_RLim64T(val->rlim_max);    
}

bool init_resources_model(void)
{
    RSavedLimits = create_Map(&type_IntTObj,&type_RSavedLimitT);

    SUT_RLIM64_INFINITY = max_ULLongT;
    SUT_RLIM64_SAVED_CUR = max_ULLongT;
    SUT_RLIM64_SAVED_MAX = max_ULLongT;    

    return true;
}
