/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "process/ipc/sem_model.seh"
#include "process/ipc/sem_config.h"


#pragma SEC subsystem ipc "process.ipc"



/* 
   The group of functions 'process.ipc.sem' consists of: 
       semctl [1]
       semget [1]
       semop [1]
 */


/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    semctl - XSI semaphore control operations

SYNOPSIS

    [XSI]  #include <sys/sem.h>
    int semctl(int semid, int semnum, int cmd, ...); 

DESCRIPTION

    The semctl() function operates on XSI semaphores (see the Base Definitions 
    volume of IEEE Std 1003.1-2001, Section 4.15, Semaphore). It is unspecified
    whether this function interoperates with the realtime interprocess 
    communication facilities defined in Realtime.

    The semctl() function provides a variety of semaphore control operations as
    specified by cmd. The fourth argument is optional and depends upon the 
    operation requested. 

    If required, it is of type union semun, which the application shall 
    explicitly declare:

        union semun {
            int val;
            struct semid_ds *buf;
            unsigned short  *array;
        } arg;

    The following semaphore control operations as specified by cmd are executed
    with respect to the semaphore specified by semid and semnum. The level of 
    permission required for each operation is shown with each command; see XSI
    Interprocess Communication. The symbolic names for the values of cmd are 
    defined in the <sys/sem.h> header:

        GETVAL 
        Return the value of semval; see <sys/sem.h>. Requires read permission.
        
        SETVAL 
        Set the value of semval to arg.val, where arg is the value of the 
        fourth argument to semctl(). When this command is successfully 
        executed, the semadj value corresponding to the specified semaphore in 
        all processes is cleared.Requires alter permission; see XSI 
        Interprocess Communication. 

        GETPID 
        Return the value of sempid. Requires read permission. 

        GETNCNT 
        Return the value of semncnt. Requires read permission. 

        GETZCNT 
        Return the value of semzcnt. Requires read permission. 
        
    The following values of cmd operate on each semval in the set of semaphores:

        GETALL 
        Return the value of semval for each semaphore in the semaphore set and 
        place into the array pointed to by arg.array, where arg is the fourth 
        argument to semctl(). Requires read permission. 

        SETALL 
        Set the value of semval for each semaphore in the semaphore set 
        according to the array pointed to by arg.array, where arg is the fourth
        argument to semctl(). When this command is successfully executed, the
        semadj values corresponding to each specified semaphore in all 
        processes are cleared. Requires alter permission. 

    The following values of cmd are also available:

        IPC_STAT 
        Place the current value of each member of the semid_ds data structure 
        associated with semid into the structure pointed to by arg.buf, where
        arg is the fourth argument to semctl(). The contents of this structure
        are defined in <sys/sem.h>. Requires read permission. 

        IPC_SET 
        Set the value of the following members of the semid_ds data structure 
        associated with semid to the corresponding value found in the structure
        pointed to by arg.buf, where arg is the fourth argument to semctl(): 
        
        sem_perm.uid
        sem_perm.gid
        sem_perm.mode


        The mode bits specified in IPC General Description are copied into the 
        corresponding bits of the sem_perm.mode associated with semid. The 
        stored values of any other bits are unspecified.

        This command can only be executed by a process that has an effective 
        user ID equal to either that of a process with appropriate privileges 
        or to the value of sem_perm.cuid or sem_perm.uid in the semid_ds data 
        structure associated with semid.

        IPC_RMID 
        Remove the semaphore identifier specified by semid from the system and 
        destroy the set of semaphores and semid_ds data structure associated 
        with it. This command can only be executed by a process that has an 
        effective user ID equal to either that of a process with appropriate
        privileges or to the value of sem_perm.cuid or sem_perm.uid in the 
        semid_ds data structure associated with semid. 

RETURN VALUE

    If successful, the value returned by semctl() depends on cmd as follows:

        GETVAL 
        The value of semval. 

        GETPID 
        The value of sempid. 

        GETNCNT 
        The value of semncnt. 

        GETZCNT 
        The value of semzcnt. 

        All others 
        0. 
        
    Otherwise, semctl() shall return -1 and set errno to indicate the error.

ERRORS

    The semctl() function shall fail if:

    [EACCES] 
    Operation permission is denied to the calling process; see XSI Interprocess
    Communication. 

    [EINVAL] 
    The value of semid is not a valid semaphore identifier, or the value of 
    semnum is less than 0 or greater than or equal to sem_nsems, or the value 
    of cmd is not a valid command. 

    [EPERM] 
    The argument cmd is equal to IPC_RMID or IPC_SET and the effective user ID 
    of the calling process is not equal to that of a process with appropriate 
    privileges and it is not equal to the value of sem_perm.cuid or 
    sem_perm.uid in the data structure associated with semid. 

    [ERANGE] 
    The argument cmd is equal to SETVAL or SETALL and the value to which semval
    is to be set is greater than the system-imposed maximum. 
*/

specification typedef struct SemidDs SemidDs = {};

specification
IntT semctl_GETVAL_spec(CallContext context, IntT semid, IntT semnum, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * Otherwise, semctl() shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_GETVAL_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        
        ERROR_END()

         /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * GETVAL The value of semval.
         */
        REQ("semctl.10.01", "", TODO_REQ());


        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());

        /*
        * The semctl() function provides a variety of semaphore control operations as 
        * specified by cmd.
        */
        REQ("semctl.03", "", TODO_REQ());
        
        /*
        * The fourth argument is optional and depends upon the operation requested.
        */
        REQ("semctl.04.01", "", TODO_REQ());
        
        /*
        * If required, it is of type union semun, which the application shall explicitly 
        * declare:
        * 
        * union semun { 
        *    int val; 
        *    struct semid_ds *buf; 
        *    unsigned short *array; 
        *  } arg; 
        *
        */
        REQ("semctl.04.02", "", TODO_REQ());
        

        /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * GETVAL Return the value of semval; see <sys/sem.h>. Requires read 
         * permission.
         */
        REQ("semctl.07.01", "", TODO_REQ());


      
        return true;
    }
}

specification
IntT semctl_SETVAL_spec(CallContext context, IntT semid, IntT semnum, IntT semval,  ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_SETVAL_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        
        /*
        * The semctl() function shall fail if:
        *
        * [ERANGE] The argument cmd is equal to SETVAL or SETALL and the value to which 
        * semval is to be set is greater than the system-imposed maximum.
        */
        ERROR_SHALL(POSIX_SEMCTL, ERANGE, "semctl.12.04", TODO_ERR(ERANGE) )
        
        ERROR_END()

        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * All others 0.
         */
        REQ("semctl.10.05", "Function shall return zero", semctl_SETVAL_spec==0);

       
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


        /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * SETVAL
         *
         * Set the value of semval to arg.val, where arg is the value of the fourth 
         * argument to semctl().
         */
        REQ("semctl.07.02.01", "", TODO_REQ());

        /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * SETVAL
         *
         * When this command is successfully executed, the semadj value corresponding to 
         * the specified semaphore in all processes is cleared
         */
        REQ("semctl.07.02.02", "", TODO_REQ());

        /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * SETVAL
         *
         * Requires alter permission;
         */
        REQ("semctl.07.02.03", "", TODO_REQ());

      
        return true;
    }
}


specification
IntT semctl_GETPID_spec(CallContext context, IntT semid, IntT semnum,  ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_GETPID_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        ERROR_END()

        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * GETPID The value of sempid.
         */
        REQ("semctl.10.02", "", TODO_REQ());

        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());

        /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * GETPID Return the value of sempid. Requires read permission.
         */
        REQ("semctl.07.03", "", TODO_REQ());

       
        return true;
    }
}

specification
IntT semctl_GETNCNT_spec(CallContext context, IntT semid, IntT semnum, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_GETNCNT_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
       
        ERROR_END()

        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * GETNCNT The value of semncnt.
         */
        REQ("semctl.10.03", "", TODO_REQ());

        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


         /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * GETNCNT Return the value of semncnt. Requires read permission.
         */
        REQ("semctl.07.04", "", TODO_REQ());

      
        return true;
    }
}



specification
IntT semctl_GETZCNT_spec(CallContext context, IntT semid, IntT semnum,  ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_GETZCNT_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        
        ERROR_END()

        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * GETZCNT The value of semzcnt.
         */
        REQ("semctl.10.04", "", TODO_REQ());


        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


        /*
         * The symbolic names for the values of cmd are defined in the <sys/sem.h> 
         * header:
         *
         * GETZCNT Return the value of semzcnt. Requires read permission.
         */
        REQ("semctl.07.05", "", TODO_REQ());
        
       
        return true;
    }
}


specification typedef struct SemctlGETALLReturnType SemctlGETALLReturnType = {};

SemctlGETALLReturnType * create_SemctlGETALLReturnType(
    IntT funcRes,
    List* values
)
{
    return create(&type_SemctlGETALLReturnType,
        funcRes, values);
}


specification
SemctlGETALLReturnType* semctl_GETALL_spec(CallContext context, IntT semid, IntT semnum, UShortT sem_nsems, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_GETALL_spec->funcRes==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        
        ERROR_END()


        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * All others 0.
         */
        REQ("semctl.10.05", "Function shall return zero", semctl_GETALL_spec->funcRes==0);


        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


         /*
         * The following values of cmd operate on each semval in the set of semaphores:
         *
         * GETALL
         *
         * Return the value of semval for each semaphore in the semaphore set and place 
         * into the array pointed to by arg.array, where arg is the fourth argument to 
         * semctl(). Requires read permission.
         */
        REQ("semctl.08.01.01", "", TODO_REQ());

      
        return true;
    }
}

specification
IntT semctl_SETALL_spec(CallContext context, IntT semid, IntT semnum, List* values,  ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_SETALL_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        
        /*
        * The semctl() function shall fail if:
        *
        * [ERANGE] The argument cmd is equal to SETVAL or SETALL and the value to which 
        * semval is to be set is greater than the system-imposed maximum.
        */
        ERROR_SHALL(POSIX_SEMCTL, ERANGE, "semctl.12.04", TODO_ERR(ERANGE) )
        
        ERROR_END()

        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * All others 0.
         */
        REQ("semctl.10.05", "Function shall return zero", semctl_SETALL_spec==0);

        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


        /*
         * The following values of cmd operate on each semval in the set of semaphores:
         *
         * SETALL
         *
         * Set the value of semval for each semaphore in the semaphore set according to 
         * the array pointed to by arg.array, where arg is the fourth argument to semctl().
         */
        REQ("semctl.08.02.01", "", TODO_REQ());

        /*
         * The following values of cmd operate on each semval in the set of semaphores:
         *
         * SETALL
         *
         * When this command is successfully executed, the semadj values corresponding to 
         * each specified semaphore in all processes are cleared.
         */
        REQ("semctl.08.02.02", "", TODO_REQ());

        /*
         * The following values of cmd operate on each semval in the set of semaphores:
         *
         * SETALL
         *
         * Requires alter permission.
         */
        REQ("semctl.08.02.03", "", TODO_REQ());

        
        return true;
    }
}


specification typedef struct IPCStatReturnType IPCStatReturnType = {};

IPCStatReturnType * create_IPCStatReturnType(
    IntT funcRes,
    SemidDs* data
)
{
    return create(&type_IPCStatReturnType,
        funcRes, data);
}

specification
IPCStatReturnType* semctl_IPC_STAT_spec(CallContext context, IntT semid, IntT semnum, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_IPC_STAT_spec->funcRes==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        
        ERROR_END()

        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * All others 0.
         */
        REQ("semctl.10.05", "Function shall return zero", semctl_IPC_STAT_spec->funcRes==0);

        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


        /*
         * The following values of cmd are also available:
         *
         * IPC_STAT
         *
         * Place the current value of each member of the semid_ds data structure 
         * associated with semid into the structure pointed to by arg.buf, where arg is 
         * the fourth argument to semctl().
         */
        REQ("semctl.09.01.01", "", TODO_REQ());

        /*
         * The following values of cmd are also available:
         *
         * IPC_STAT
         *
         * Requires read permission.
         */
        REQ("semctl.09.01.02", "", TODO_REQ());

      

        return true;
    }
}

specification
IntT semctl_IPC_SET_spec(CallContext context, IntT semid, IntT semnum, SemidDs* data,  ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_IPC_SET_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EPERM] The argument cmd is equal to IPC_RMID or IPC_SET and the effective user 
        * ID of the calling process is not equal to that of a process with appropriate 
        * privileges and it is not equal to the value of sem_perm.cuid or sem_perm.uid in 
        * the data structure associated with semid.
        */
        ERROR_SHALL(POSIX_SEMCTL, EPERM, "semctl.12.03", TODO_ERR(EPERM) )
        
        
        ERROR_END()


        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * All others 0.
         */
        REQ("semctl.10.05", "Function shall return zero", semctl_IPC_SET_spec==0);

        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


        /*
         * The following values of cmd are also available:
         *
         * IPC_SET
         *
         * Set the value of the following members of the semid_ds data structure 
         * associated with semid to the corresponding value found in the structure pointed 
         * to by arg.buf, where arg is the fourth argument to semctl(): 
         * sem_perm.uid           
         * sem_perm.gid 
         * sem_perm.mode 
         */
        REQ("semctl.09.02.01", "", TODO_REQ());

        /*
         * The following values of cmd are also available:
         *
         * IPC_SET
         *
         * The mode bits specified in IPC General Description are copied into the 
         * corresponding bits of the sem_perm.mode associated with semid.
         */
        REQ("semctl.09.02.02", "", TODO_REQ());

        /*
         * The following values of cmd are also available:
         *
         * IPC_SET
         *
         * The stored values of any other bits are unspecified.
         */
        REQ("semctl.09.02.03", "", TODO_REQ());

        /*
         * The following values of cmd are also available:
         *
         * IPC_SET
         *
         * This command can only be executed by a process that has an effective user ID 
         * equal to either that of a process with appropriate privileges or to the value 
         * of sem_perm.cuid or sem_perm.uid in the semid_ds data structure associated with 
         * semid.
         */
        REQ("semctl.09.02.04", "", TODO_REQ());

        return true;
    }
}

specification
IntT semctl_IPC_RMID_spec(CallContext context, IntT semid, IntT semnum, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * Otherwise, semctl() shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMCTL, "semctl.11", semctl_IPC_RMID_spec==-1, *errno)
            
        /*
        * The semctl() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMCTL, EACCES, "semctl.12.01", TODO_ERR(EACCES) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the value 
        * of semnum is less than 0 or greater than or equal to sem_nsems, or the value of 
        * cmd is not a valid command.
        */
        ERROR_SHALL(POSIX_SEMCTL, EINVAL, "semctl.12.02", TODO_ERR(EINVAL) )
        
        /*
        * The semctl() function shall fail if:
        *
        * [EPERM] The argument cmd is equal to IPC_RMID or IPC_SET and the effective user 
        * ID of the calling process is not equal to that of a process with appropriate 
        * privileges and it is not equal to the value of sem_perm.cuid or sem_perm.uid in 
        * the data structure associated with semid.
        */
        ERROR_SHALL(POSIX_SEMCTL, EPERM, "semctl.12.03", TODO_ERR(EPERM) )
        
        
        ERROR_END()


        /*
         * If successful, the value returned by semctl() depends on cmd as follows:
         *
         * All others 0.
         */
        REQ("semctl.10.05", "Function shall return zero", semctl_IPC_RMID_spec==0);

        
        /*
        * It is unspecified whether this function interoperates with the realtime 
        * interprocess communication facilities defined in Realtime.
        */
        REQ("semctl.02", "", TODO_REQ());

        /*
        * The following semaphore control operations as specified by cmd are executed 
        * with respect to the semaphore specified by semid and semnum.
        */
        REQ("semctl.05", "", TODO_REQ());
        
        /*
        * The level of permission required for each operation is shown with each command;
        */
        REQ("semctl.06", "", TODO_REQ());


        /*
         * The following values of cmd are also available:
         *
         * IPC_RMID
         *
         * Remove the semaphore identifier specified by semid from the system and destroy 
         * the set of semaphores and semid_ds data structure associated with it.
         */
        REQ("semctl.09.03.01", "", TODO_REQ());

        /*
         * The following values of cmd are also available:
         *
         * IPC_RMID
         *
         * This command can only be executed by a process that has an effective user ID 
         * equal to either that of a process with appropriate privileges or to the value 
         * of sem_perm.cuid or sem_perm.uid in the semid_ds data structure associated with 
         * semid.
         */
        REQ("semctl.09.03.02", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    semget - get set of XSI semaphores

SYNOPSIS

    [XSI]  #include <sys/sem.h>
    int semget(key_t key, int nsems, int semflg); 

DESCRIPTION

    The semget() function operates on XSI semaphores (see the Base Definitions 
    volume of IEEE Std 1003.1-2001, Section 4.15, Semaphore).It is unspecified
    whether this function interoperates with the realtime interprocess 
    communication facilities defined in Realtime.

    The semget() function shall return the semaphore identifier associated with
    key.

    A semaphore identifier with its associated semid_ds data structure and its
    associated set of nsems semaphores (see <sys/sem.h>) is created for key if 
    one of the following is true:

        The argument key is equal to IPC_PRIVATE.

        The argument key does not already have a semaphore identifier 
        associated with it and (semflg &IPC_CREAT) is non-zero.

    Upon creation, the semid_ds data structure associated with the new semaphore identifier is initialized as follows:

        In the operation permissions structure sem_perm.cuid, sem_perm.uid, 
        sem_perm.cgid, and sem_perm.gid shall be set equal to the effective 
        user ID and effective group ID, respectively, of the calling process.

        The low-order 9 bits of sem_perm.mode shall be set equal to the 
        low-order 9 bits of semflg.

        The variable sem_nsems shall be set equal to the value of nsems.

        The variable sem_otime shall be set equal to 0 and sem_ctime shall be 
        set equal to the current time.

        The data structure associated with each semaphore in the set need not 
        be initialized. The semctl() function with the command SETVAL or SETALL
        can be used to initialize each semaphore.

RETURN VALUE

    Upon successful completion, semget() shall return a non-negative integer, 
    namely a semaphore identifier; otherwise, it shall return -1 and set errno 
    to indicate the error.

ERRORS

    The semget() function shall fail if:

        [EACCES] 
        A semaphore identifier exists for key, but operation permission as 
        specified by the low-order 9 bits of semflg would not be granted; see 
        XSI Interprocess Communication. 

        [EEXIST] 
        A semaphore identifier exists for the argument key but
        ((semflg &IPC_CREAT) &&(semflg &IPC_EXCL)) is non-zero. 

        [EINVAL] 
        The value of nsems is either less than or equal to 0 or greater than
        the system-imposed limit, or a semaphore identifier exists for the 
        argument key, but the number of semaphores in the set associated with 
        it is less than nsems and nsems is not equal to 0. 

        [ENOENT] 
        A semaphore identifier does not exist for the argument key and 
        (semflg &IPC_CREAT) is equal to 0. 

        [ENOSPC] 
        A semaphore identifier is to be created but the system-imposed limit on
        the maximum number of allowed semaphores system-wide would be exceeded. 
*/

specification
IntT semget_spec(CallContext context, KeyT key, IntT nsems, IntT semflg, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
        * otherwise, it shall return -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SEMGET, "semget.06.02", semget_spec==-1, *errno)
            
        /*
        * The semget() function shall fail if:
        *
        * [EACCES] A semaphore identifier exists for key, but operation permission as 
        * specified by the low-order 9 bits of semflg would not be granted; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMGET, EACCES, "semget.07.01", TODO_ERR(EACCES) )
        
        /*
        * The semget() function shall fail if:
        *
        * [EEXIST] A semaphore identifier exists for the argument key but ((semflg & 
        * IPC_CREAT) &&(semflg &IPC_EXCL)) is non-zero.
        */
        ERROR_SHALL(POSIX_SEMGET, EEXIST, "semget.07.02", TODO_ERR(EEXIST) )
        
        /*
        * The semget() function shall fail if:
        *
        * [EINVAL] The value of nsems is either less than or equal to 0 or greater than 
        * the system-imposed limit, or a semaphore identifier exists for the argument 
        * key, but the number of semaphores in the set associated with it is less than 
        * nsems and nsems is not equal to 0.
        */
        ERROR_SHALL(POSIX_SEMGET, EINVAL, "semget.07.03", TODO_ERR(EINVAL) )
        
        /*
        * The semget() function shall fail if:
        *
        * [ENOENT] A semaphore identifier does not exist for the argument key and (semflg 
        * &IPC_CREAT) is equal to 0.
        */
        ERROR_SHALL(POSIX_SEMGET, ENOENT, "semget.07.04", TODO_ERR(ENOENT) )
        
        /*
        * The semget() function shall fail if:
        *
        * [ENOSPC] A semaphore identifier is to be created but the system-imposed limit 
        * on the maximum number of allowed semaphores system-wide would be exceeded.
        */
        ERROR_SHALL(POSIX_SEMGET, ENOSPC, "semget.07.05", TODO_ERR(ENOSPC) )
        
        ERROR_END()


        /*
        * Upon successful completion, semget() shall return a non-negative integer, 
        * namely a semaphore identifier;
        */
        REQ("semget.06.01", "Non negative value shall be returned", semget_spec>=0);
        
        /*
        * The semget() function shall return the semaphore identifier associated with key.
        */
        REQ("semget.03", "", TODO_REQ());
        
        /*
        * A semaphore identifier with its associated semid_ds data structure and its 
        * associated set of nsems semaphores (see <sys/sem.h>) is created for key 
        * if one of the following is true:
        *
        * The argument key is equal to IPC_PRIVATE.
        */
        REQ("semget.04.01", "", TODO_REQ());
        
        /*
        * A semaphore identifier with its associated semid_ds data structure and its 
        * associated set of nsems semaphores (see <sys/sem.h>) is created for key 
        * if one of the following is true:
        *
        * The argument key does not already have a semaphore identifier associated with 
        * it and (semflg &IPC_CREAT) is non-zero.
        */
        REQ("semget.04.02", "", TODO_REQ());
        
        /*
        * Upon creation, the semid_ds data structure associated with the new semaphore 
        * identifier is initialized as follows:
        *
        * In the operation permissions structure sem_perm.cuid, sem_perm.uid, sem_perm. 
        * cgid, and sem_perm.gid shall be set equal to the effective user ID and 
        * effective group ID, respectively, of the calling process.
        */
        REQ("semget.05.01", "", TODO_REQ());
        
        /*
        * Upon creation, the semid_ds data structure associated with the new semaphore 
        * identifier is initialized as follows:
        *
        * The low-order 9 bits of sem_perm.mode shall be set equal to the low-order 9 
        * bits of semflg.
        */
        REQ("semget.05.02", "", TODO_REQ());
        
        /*
        * Upon creation, the semid_ds data structure associated with the new semaphore 
        * identifier is initialized as follows:
        *
        * The variable sem_nsems shall be set equal to the value of nsems.
        */
        REQ("semget.05.03", "", TODO_REQ());
        
        /*
        * Upon creation, the semid_ds data structure associated with the new semaphore 
        * identifier is initialized as follows:
        *
        * The variable sem_otime shall be set equal to 0 and sem_ctime shall be set equal 
        * to the current time.
        */
        REQ("semget.05.04", "", TODO_REQ());
        
        /*
        * Upon creation, the semid_ds data structure associated with the new semaphore 
        * identifier is initialized as follows:
        *
        * The data structure associated with each semaphore in the set need not be 
        * initialized. The semctl() function with the command SETVAL or SETALL can be 
        * used to initialize each semaphore.
        */
        REQ("semget.05.05", "", TODO_REQ());
        


       
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    semop - XSI semaphore operations
    
SYNOPSIS

    [XSI]  #include <sys/sem.h>
    int semop(int semid, struct sembuf *sops, size_t nsops); 

DESCRIPTION

    The semop() function operates on XSI semaphores (see the Base Definitions 
    volume of IEEE Std 1003.1-2001, Section 4.15, Semaphore). It is unspecified
    whether this function interoperates with the realtime interprocess 
    communication facilities defined in Realtime.

    The semop() function shall perform atomically a user-defined array of 
    semaphore operations on the set of semaphores associated with the semaphore
    identifier specified by the argument semid.

    The argument sops is a pointer to a user-defined array of semaphore 
    operation structures. The implementation shall not modify elements of this 
    array unless the application uses implementation-defined extensions.

    The argument nsops is the number of such structures in the array.

    Each structure, sembuf, includes the following members:

        Member Type    Member Name     Description
        short          sem_num         Semaphore number.
        short          sem_op          Semaphore operation.
        short          sem_flg         Operation flags.
 

    Each semaphore operation specified by sem_op is performed on the 
    corresponding semaphore specified by semid and sem_num.

    The variable sem_op specifies one of three semaphore operations:

        If sem_op is a negative integer and the calling process has alter 
        permission, one of the following shall occur:

            If semval(see <sys/sem.h>) is greater than or equal to the absolute
            value of sem_op, the absolute value of sem_op is subtracted from 
            semval. Also, if (sem_flg &SEM_UNDO) is non-zero, the absolute 
            value of sem_op shall be added to the calling process' semadj value
            for the specified semaphore.

            If semval is less than the absolute value of sem_op and 
            (sem_flg &IPC_NOWAIT) is non-zero, semop() shall return 
            immediately.

            If semval is less than the absolute value of sem_op and 
            (sem_flg &IPC_NOWAIT) is 0, semop() shall increment the semncnt 
            associated with the specified semaphore and suspend execution of 
            the calling thread until one of the following conditions occurs:

                The value of semval becomes greater than or equal to the 
                absolute value of sem_op. When this occurs, the value of 
                semncnt associated with the specified semaphore shall be 
                decremented, the absolute value of sem_op shall be subtracted 
                from semval and, if (sem_flg &SEM_UNDO) is non-zero, the 
                absolute value of sem_op shall be added to the calling process'
                semadj value for the specified semaphore.

                The semid for which the calling thread is awaiting action is 
                removed from the system. When this occurs, errno shall be set 
                equal to [EIDRM] and -1 shall be returned.

                The calling thread receives a signal that is to be caught. When
                this occurs, the value of semncnt associated with the specified
                semaphore shall be decremented, and the calling thread shall 
                resume execution in the manner prescribed in sigaction().

        If sem_op is a positive integer and the calling process has alter 
        permission, the value of sem_op shall be added to semval and, if 
        (sem_flg &SEM_UNDO) is non-zero, the value of sem_op shall be 
        subtracted from the calling process' semadj value for the specified 
        semaphore.

        If sem_op is 0 and the calling process has read permission, one of the 
        following shall occur:

            If semval is 0, semop() shall return immediately.

            If semval is non-zero and (sem_flg &IPC_NOWAIT) is non-zero, 
            semop() shall return immediately.

            If semval is non-zero and (sem_flg &IPC_NOWAIT) is 0, semop() shall
            increment the semzcnt associated with the specified semaphore and 
            suspend execution of the calling thread until one of the following
            occurs:

                The value of semval becomes 0, at which time the value of
                semzcnt associated with the specified semaphore shall be 
                decremented.

                The semid for which the calling thread is awaiting action is 
                removed from the system. When this occurs, errno shall be set
                equal to [EIDRM] and -1 shall be returned.

                The calling thread receives a signal that is to be caught. When
                this occurs, the value of semzcnt associated with the specified
                semaphore shall be decremented, and the calling thread shall 
                resume execution in the manner prescribed in sigaction().

    Upon successful completion, the value of sempid for each semaphore 
    specified in the array pointed to by sops shall be set equal to the process
    ID of the calling process.

RETURN VALUE

    Upon successful completion, semop() shall return 0; otherwise, it shall 
    return -1 and set errno to indicate the error.

ERRORS

    The semop() function shall fail if:

        [E2BIG] 
        The value of nsops is greater than the system-imposed maximum. 

        [EACCES] 
        Operation permission is denied to the calling process; see XSI 
        Interprocess Communication. 

        [EAGAIN] 
        The operation would result in suspension of the calling process but 
        (sem_flg &IPC_NOWAIT) is non-zero. 

        [EFBIG] 
        The value of sem_num is less than 0 or greater than or equal to the 
        number of semaphores in the set associated with semid. 

        [EIDRM] 
        The semaphore identifier semid is removed from the system. 

        [EINTR] 
        The semop() function was interrupted by a signal. 

        [EINVAL] 
        The value of semid is not a valid semaphore identifier, or the number
        of individual semaphores for which the calling process requests a 
        SEM_UNDO would exceed the system-imposed limit. 

        [ENOSPC] 
        The limit on the number of individual processes requesting a SEM_UNDO 
        would be exceeded. 

        [ERANGE] 
        An operation would cause a semval to overflow the system-imposed limit,
        or an operation would cause a semadj value to overflow the 
        system-imposed limit. 
*/

specification typedef struct SemBuf SemBuf = {};

specification
IntT semop_spec(CallContext context, IntT semid, List* sops, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * otherwise, it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_SEMOP, "semop.11.02", semop_spec == -1, *errno)
            
        /*
        * The semop() function shall fail if:
        *
        * [E2BIG] The value of nsops is greater than the system-imposed maximum.
        */
        ERROR_SHALL(POSIX_SEMOP, E2BIG, "semop.12.01", TODO_ERR(E2BIG) )
        
        /*
        * The semop() function shall fail if:
        *
        * [EACCES] Operation permission is denied to the calling process; see XSI 
        * Interprocess Communication.
        */
        ERROR_SHALL(POSIX_SEMOP, EACCES, "semop.12.02", TODO_ERR(EACCES) )
        
        /*
        * The semop() function shall fail if:
        *
        * [EAGAIN] The operation would result in suspension of the calling process but 
        * (sem_flg &IPC_NOWAIT) is non-zero.
        */
        ERROR_SHALL(POSIX_SEMOP, EAGAIN, "semop.12.03", TODO_ERR(EAGAIN) )
        
        /*
        * The semop() function shall fail if:
        *
        * [EFBIG] The value of sem_num is less than 0 or greater than or equal to the 
        * number of semaphores in the set associated with semid.
        */
        ERROR_SHALL(POSIX_SEMOP, EFBIG, "semop.12.04", TODO_ERR(EFBIG) )
        
        /*
        * The semop() function shall fail if:
        *
        * [EIDRM] The semaphore identifier semid is removed from the system.
        */
        ERROR_SHALL(POSIX_SEMOP, EIDRM, "semop.12.05", TODO_ERR(EIDRM) )
        
        /*
        * The semop() function shall fail if:
        *
        * [EINTR] The semop() function was interrupted by a signal.
        */
        ERROR_SHALL(POSIX_SEMOP, EINTR, "semop.12.06", TODO_ERR(EINTR) )
        
        /*
        * The semop() function shall fail if:
        *
        * [EINVAL] The value of semid is not a valid semaphore identifier, or the number 
        * of individual semaphores for which the calling process requests a SEM_UNDO 
        * would exceed the system-imposed limit.
        */
        ERROR_SHALL(POSIX_SEMOP, EINVAL, "semop.12.07", TODO_ERR(EINVAL) )
        
        /*
        * The semop() function shall fail if:
        *
        * [ENOSPC] The limit on the number of individual processes requesting a SEM_UNDO 
        * would be exceeded.
        */
        ERROR_SHALL(POSIX_SEMOP, ENOSPC, "semop.12.08", TODO_ERR(ENOSPC) )
        
        /*
        * The semop() function shall fail if:
        *
        * [ERANGE] An operation would cause a semval to overflow the system-imposed 
        * limit, or an operation would cause a semadj value to overflow the system- 
        * imposed limit.
        */
        ERROR_SHALL(POSIX_SEMOP, ERANGE, "semop.12.09", TODO_ERR(ERANGE) )
        
        ERROR_END()

        
        /*
         * Upon successful completion, semop() shall return 0;
         */
        REQ("semop.11.01", "Zero shall be returned", semop_spec==0);

        
        /*
         * It is unspecified whether this function interoperates with the realtime 
         * interprocess communication facilities defined in Realtime.
         */
        REQ("semop.02", "", TODO_REQ());

        /*
         * The semop() function shall perform atomically a user-defined array of semaphore 
         * operations on the set of semaphores associated with the semaphore identifier 
         * specified by the argument semid.
         */
        REQ("semop.03", "", TODO_REQ());

        /*
         * The argument sops is a pointer to a user-defined array of semaphore operation 
         * structures.
         */
        REQ("semop.04", "", TODO_REQ());

        /*
         * The implementation shall not modify elements of this array unless the 
         * application uses implementation-defined extensions.
         */
        REQ("semop.05", "", TODO_REQ());

        /*
         * The argument nsops is the number of such structures in the array.
         */
        REQ("semop.06", "", TODO_REQ());

        /*
         * Each structure, sembuf, includes the following members:
         * Member Type
         * Member Name
         * Description
         * short
         * sem_num
         * Semaphore number.
         * short
         * sem_op
         * Semaphore operation.
         * short
         * sem_flg
         * Operation flags.
         */
        REQ("semop.07", "", TODO_REQ());

        /*
         * Each semaphore operation specified by sem_op is performed on the corresponding 
         * semaphore specified by semid and sem_num.
         */
        REQ("semop.08", "", TODO_REQ());

        /*
         * The variable sem_op specifies one of three semaphore operations:
         *
         * If sem_op is a negative integer and the calling process has alter permission, 
         * one of the following shall occur:
         */
        REQ("semop.09.01", "", TODO_REQ());

        /*
         * If semval(see <sys/sem.h>) is greater than or equal to the absolute value 
         * of sem_op, the absolute value of sem_op is subtracted from semval.
         */
        REQ("semop.09.01.01.01", "", TODO_REQ());

        /*
         * Also, if (sem_flg &SEM_UNDO) is non-zero, the absolute value of sem_op 
         * shall be added to the calling process' semadj value for the specified semaphore.
         */
        REQ("semop.09.01.01.02", "", TODO_REQ());

        /*
         * If semval is less than the absolute value of sem_op and (sem_flg & 
         * IPC_NOWAIT) is non-zero, semop() shall return immediately.
         */
        REQ("semop.09.01.02.01", "", TODO_REQ());

        /*
         * If semval is less than the absolute value of sem_op and (sem_flg & 
         * IPC_NOWAIT) is 0, semop() shall increment the semncnt associated with the 
         * specified semaphore
         */
        REQ("semop.09.01.03.01", "", TODO_REQ());

        /*
         * and suspend execution of the calling thread until one of the following 
         * conditions occurs:
         */
        REQ("semop.09.01.03.02", "", TODO_REQ());

        /*
         * The value of semval becomes greater than or equal to the absolute value of 
         * sem_op.
         */
        REQ("semop.09.01.03.02.01.01", "", TODO_REQ());

        /*
         * When this occurs, the value of semncnt associated with the specified semaphore 
         * shall be decremented,
         */
        REQ("semop.09.01.03.02.01.02", "", TODO_REQ());

        /*
         * the absolute value of sem_op shall be subtracted from semval
         */
        REQ("semop.09.01.03.02.01.03", "", TODO_REQ());

        /*
         * and, if (sem_flg &SEM_UNDO) is non-zero, the absolute value of sem_op shall 
         * be added to the calling process' semadj value for the specified semaphore.
         */
        REQ("semop.09.01.03.02.01.04", "", TODO_REQ());

        /*
         * The semid for which the calling thread is awaiting action is removed from the 
         * system.
         */
        REQ("semop.09.01.03.02.02.01", "", TODO_REQ());

        /*
         * When this occurs, errno shall be set equal to [EIDRM] and -1 shall be returned.
         */
        REQ("semop.09.01.03.02.02.02", "", TODO_REQ());

        /*
         * The calling thread receives a signal that is to be caught.
         */
        REQ("semop.09.01.03.02.03.01", "", TODO_REQ());

        /*
         * When this occurs, the value of semncnt associated with the specified semaphore 
         * shall be decremented, and the calling thread shall resume execution in the 
         * manner prescribed in sigaction().
         */
        REQ("semop.09.01.03.02.03.02", "", TODO_REQ());

        /*
         * If sem_op is a positive integer and the calling process has alter permission, 
         * the value of sem_op shall be added to semval
         */
        REQ("semop.09.02.01", "", TODO_REQ());

        /*
         * and, if (sem_flg &SEM_UNDO) is non-zero, the value of sem_op shall be 
         * subtracted from the calling process' semadj value for the specified semaphore.
         */
        REQ("semop.09.02.02", "", TODO_REQ());

        /*
         * The variable sem_op specifies one of three semaphore operations:
         *
         * If sem_op is 0 and the calling process has read permission, one of the 
         * following shall occur:
         *
         * If semval is 0, semop() shall return immediately.
         */
        REQ("semop.09.03.01", "", TODO_REQ());

        /*
         * The variable sem_op specifies one of three semaphore operations:
         *
         * If sem_op is 0 and the calling process has read permission, one of the 
         * following shall occur:
         *
         * If semval is non-zero and (sem_flg &IPC_NOWAIT) is non-zero, semop() shall 
         * return immediately.
         */
        REQ("semop.09.03.02", "", TODO_REQ());

        /*
         * If semval is non-zero and (sem_flg &IPC_NOWAIT) is 0, semop() shall 
         * increment the semzcnt associated with the specified semaphore
         */
        REQ("semop.09.03.03.01", "", TODO_REQ());

        /*
         * and suspend execution of the calling thread until one of the following occurs:
         *
         * The value of semval becomes 0, at which time the value of semzcnt associated 
         * with the specified semaphore shall be decremented.
         */
        REQ("semop.09.03.03.02.01", "", TODO_REQ());

        /*
         * The semid for which the calling thread is awaiting action is removed from the 
         * system.
         */
        REQ("semop.09.03.03.02.02.01", "", TODO_REQ());

        /*
         * When this occurs, errno shall be set equal to [EIDRM] and -1 shall be returned.
         */
        REQ("semop.09.03.03.02.02.02", "", TODO_REQ());

        /*
         * The calling thread receives a signal that is to be caught.
         */
        REQ("semop.09.03.03.02.03.01", "", TODO_REQ());

        /*
         * When this occurs, the value of semzcnt associated with the specified semaphore 
         * shall be decremented, and the calling thread shall resume execution in the 
         * manner prescribed in sigaction().
         */
        REQ("semop.09.03.03.02.03.02", "", TODO_REQ());

        /*
         * Upon successful completion, the value of sempid for each semaphore specified in 
         * the array pointed to by sops shall be set equal to the process ID of the 
         * calling process.
         */
        REQ("semop.10", "", TODO_REQ());


        return true;
    }
}


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/



SemBuf* create_SemBuf(ShortT sem_num, ShortT sem_op, ShortT sem_flg)
{
    return create(&type_SemBuf, sem_num, sem_op, sem_flg);
}


SemidDs* create_SemidDs(IpcPerm* sem_perm, UShortT sem_nsems, TimeT sem_otime, TimeT sem_ctime)
{
    return create(&type_SemidDs, sem_perm, sem_nsems, sem_otime, sem_ctime);
}
