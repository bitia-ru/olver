/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "process/meta/meta_user_config.h"
#include "process/meta/user_model.seh"
#include "system/system/system_model.seh"
#include "process/process/process_common.seh"

#pragma SEC subsystem meta "process.meta"

/*
    The group of functions 'process.meta.user' consists of:
        cuserid [3]
        getegid [2]
        geteuid [2]
        getgid [2]
        getgroups [2]
        getuid [2]
        initgroups [1]
        setegid [2]
        seteuid [2]
        setgid [2]
        setgroups [2]
        setregid [2]
        setreuid [2]
        setuid [2]
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    cuserid - character login name of the user (LEGACY)

SYNOPSIS

    #include <stdio.h>
    char *cuserid(char *s);

DESCRIPTION

    The cuserid() function generates a character representation of the name
    associated with the real or effective user ID of the process.

    If s is a null pointer, this representation is generated in an area that
    may be static (and thus overwritten by subsequent calls to cuserid()), the
    address of which is returned. If s is not a null pointer, s is assumed to
    point to an array of at least {L_cuserid} bytes; the representation is
    deposited in this array. The symbolic constant {L_cuserid} is defined in
    <stdio.h> and has a value greater than 0.

    If the application uses any of the _POSIX_THREAD_SAFE_FUNCTIONS or
    _POSIX_THREADS interfaces, the cuserid() function must be called with a
    non-NULL parameter.

RETURN VALUE

    If s is not a null pointer, s is returned. If s is not a null pointer and
    the login name cannot be found, the null byte `\0' will be placed at *s. If
    s is a null pointer and the login name cannot be found, cuserid() returns a
    null pointer. If s is a null pointer and the login name can be found, the
    address of a buffer (possibly static) containing the login name is
    returned.

ERRORS

    No errors are defined.
*/
specification
StringTPtr cuserid_spec( CallContext context, StringTPtr s )
{
    pre
    {
        /* [Consistency of test suite] */
        REQ( "", "Process state exists", getProcessState_CallContext( context ) != NULL );

        /*
         * If s is a null pointer, this representation is generated in an area that may be
         * static (and thus overwritten by subsequent calls to cuserid()), the address of
         * which is returned.
         */
        REQ("app.cuserid.01", "", TODO_REQ());

        /*
         * If s is not a null pointer, s is assumed to point to an array of at least {
         * L_cuserid} bytes; the representation is deposited in this array.
         */
        REQ( "app.cuserid.02", "s is null or valid pointer", isNULL_VoidTPtr( s ) || isValidPointer( context, s ) );

        /*
         * If the application uses any of the _POSIX_THREAD_SAFE_FUNCTIONS or
         * _POSIX_THREADS interfaces, the cuserid() function must be called with a non-
         * NULL parameter.
         */
        REQ("app.cuserid.03", "", TODO_REQ());

        return true;
    }
    coverage C
    {
        if ( isNULL_VoidTPtr( s ) )
        {
            return { SIsNullPointer, "s is a null pointer" };
        }
        else
        {
            return { SIsNotNullPointer, "s is not a null pointer" };
        }
    }
    post
    {
        SystemState * systemState = getSystemState_CallContext( context );

#ifdef NewCTesK
        if ( C == C.SIsNotNullPointer )
#else
        if ( coverage( C ) == SIsNotNullPointer )
#endif
        {
            /*
             * If s is not a null pointer, s is returned.
             */
            REQ( "cuserid.02", "If s is not a null pointer, s is returned", equals_VoidTPtr( cuserid_spec, s ) );

            if ( equals( readCString_VoidTPtr( cuserid_spec ), create_CString( "" ) ) )
            {
                /*
                 * If s is not a null pointer and the login name cannot be found, the null byte `\
                 * 0' will be placed at *s.
                 */
                REQ( "cuserid.03", "s is not a null pointer and the login name cannot be found", true );
            }
        }
        else
        {
            if ( isNULL_VoidTPtr( cuserid_spec ) )
            {
                /*
                 * If s is a null pointer and the login name cannot be found, cuserid() returns a
                 * null pointer.
                 */
                REQ( "cuserid.04", "s is a null pointer and the login name cannot be found", true );
            }
        }

        if ( systemState->isGlobalSetFilled )
        {
            CString * res = readCString_VoidTPtr( cuserid_spec );
            ProcessState * process_state = getProcessState_CallContext( context );
            UidT uid  = process_state->meta.real_userid     ;
            UidT euid = process_state->meta.effective_userid;
            Set * allUsers = systemState->globalUsers;
            Set * foundedUsers = create_Set( & type_CString );
            int i;
            for ( i = 0; i < size_Set( allUsers ); i++ ) {
                Passwd * user = get_Set( allUsers, i );
                if ( user->pw_uid == uid || user->pw_uid == euid ) { add_Set( foundedUsers, user->pw_name ); }
            }
            /*
             * The cuserid() function generates a character representation of the name
             * associated with the real or effective user ID of the process.
             */
            REQ( "cuserid.01", "User must be found"                       , ! isEmpty_Set( foundedUsers )     );
            REQ( "cuserid.01", "User name must be equal to cuserid result", contains_Set( foundedUsers, res ) );

#ifdef NewCTesK
            if ( C == C.SIsNullPointer )
#else
            if ( coverage( C ) == SIsNullPointer )
#endif
            {
                /*
                 * If s is a null pointer and the login name can be found, the address of a buffer
                 * (possibly static) containing the login name is returned.
                 */
                REQ( "cuserid.05", "s is a null pointer and the login name can be found", true );
            }
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getegid - get the effective group ID

SYNOPSIS

    #include <unistd.h>
    gid_t getegid(void);

DESCRIPTION

    The getegid() function shall return the effective group ID of the calling
    process.

RETURN VALUE

    The getegid() function shall always be successful and no return value is
    reserved to indicate an error.

ERRORS

    No errors are defined.
*/
specification
GidT getegid_spec( CallContext context )
{
    ProcessState * process_state;

    pre
    {
        /* [Local variable initialization] */
        process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C
    {
        if ( process_state->meta.real_groupid == process_state->meta.effective_groupid )
        {
            return { GeneralProcess, "General process" };
        }
        else
        {
            return { SetBitProcess, "Set-bit process" };
        }
    }
    post
    {
        /*
         * The getegid() function shall return the effective group ID of the calling
         * process.
         *
         * The getegid() function shall always be successful and no return value is
         * reserved to indicate an error.
         */
        REQ( "getegid.01", "The getegid() function shall return the effective group ID of the calling process",
                           getegid_spec == process_state->meta.effective_groupid
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    geteuid - get the effective user ID

SYNOPSIS

    #include <unistd.h>
    uid_t geteuid(void);

DESCRIPTION

    The geteuid() function shall return the effective user ID of the calling
    process.

RETURN VALUE

    The geteuid() function shall always be successful and no return value is
    reserved to indicate an error.

ERRORS

    No errors are defined.
*/
specification
UidT geteuid_spec( CallContext context )
{
    ProcessState * process_state;

    pre
    {
        /* [Local variable initialization] */
        process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C
    {
        if ( process_state->meta.real_userid == process_state->meta.effective_userid )
        {
            return { GeneralProcess, "General process" };
        }
        else
        {
            return { SetBitProcess, "Set-bit process" };
        }
    }
    post
    {
        /*
         * The geteuid() function shall return the effective user ID of the calling
         * process.
         *
         * The geteuid() function shall always be successful and no return value is
         * reserved to indicate an error.
         */
        REQ( "geteuid.01", "The geteuid() function shall return the effective user ID of the calling process",
                           geteuid_spec == process_state->meta.effective_userid
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getgid - get the real group ID

SYNOPSIS

    #include <unistd.h>
    gid_t getgid(void);

DESCRIPTION

    The getgid() function shall return the real group ID of the calling process.

RETURN VALUE

    The getgid() function shall always be successful and no return value is
    reserved to indicate an error.

ERRORS

    No errors are defined.
*/
specification
GidT getgid_spec( CallContext context )
{
    ProcessState * process_state;

    pre
    {
        /* [Local variable initialization] */
        process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C
    {
        if ( process_state->meta.real_groupid == process_state->meta.effective_groupid )
        {
            return { GeneralProcess, "General process" };
        }
        else
        {
            return { SetBitProcess, "Set-bit process" };
        }
    }
    post
    {
        /*
         * The getgid() function shall return the real group ID of the calling process.
         *
         * The getgid() function shall always be successful and no return value is
         * reserved to indicate an error.
         */
        REQ( "getgid.01", "The getgid() function shall return the real group ID of the calling process",
                          getgid_spec == process_state->meta.real_groupid
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getgroups - get supplementary group IDs

SYNOPSIS

    #include <unistd.h>
    int getgroups(int gidsetsize, gid_t grouplist[]);

DESCRIPTION

    The getgroups() function shall fill in the array grouplist with the current
    supplementary group IDs of the calling process. It is
    implementation-defined whether getgroups() also returns the effective group
    ID in the grouplist array.

    The gidsetsize argument specifies the number of elements in the array
    grouplist. The actual number of group IDs stored in the array shall be
    returned. The values of array entries with indices greater than or equal to
    the value returned are undefined.

    If gidsetsize is 0, getgroups() shall return the number of group IDs that
    it would otherwise return without modifying the array pointed to by
    grouplist.

    If the effective group ID of the process is returned with the supplementary
    group IDs, the value returned shall always be greater than or equal to one
    and less than or equal to the value of {NGROUPS_MAX}+1.

RETURN VALUE

    Upon successful completion, the number of supplementary group IDs shall be
    returned. A return value of -1 indicates failure and errno shall be set to
    indicate the error.

ERRORS

    The getgroups() function shall fail if:

    [EINVAL]
        The gidsetsize argument is non-zero and less than the number of group
        IDs that would have been returned.

*/
specification
IntT getgroups_spec( CallContext context, IntT gidsetsize, List * grouplist /* & type_GidTObj */, ErrorCode * errno )
    updates grouplist
    writes  * errno
{
    static int shift;
    ProcessState * process_state;
    LongT nGroupsMax; // NGROUPS_MAX

    if(GETGROUPS_RETURNS_THE_EFFECTIVE_GROUP_ID_IN_THE_GROUPLIST_ARRAY)
        shift = 1;
    else
        shift = 0;

    pre
    {
        /* [Local variable initialization] */
        process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variable initialization] */
        nGroupsMax = getSystemConfigurationValue( context, SUT_SC_NGROUPS_MAX );

        /* [Consistency of test suite] */
        REQ( "", "Value for NGROUPS_MAX is known", nGroupsMax != SC_VALUE_UNKNOWN );

        return true;
    }
    coverage C
    {
        if ( gidsetsize == 0 )
        {
            return { RequestForGroupIDsNumber, "Request for number of group IDs" };
        }
        else if ( process_state->meta.groups == NULL )
        {
            return { MayBeReceiveGrouplist, "May be receive grouplist" };
        }
        else if ( gidsetsize == size_List( process_state->meta.groups ) + shift - 1 )
        {
            return { GrouplistLittleBitSmall, "Grouplist little bit small" };
        }
        else if ( gidsetsize < size_List( process_state->meta.groups ) + shift )
        {
            return { GrouplistTooSmall, "Grouplist too small" };
        }
        else
        {
            return { ReceiveGrouplist, "Receive grouplist" };
        }
    }
    post
    {
        List * groups = process_state->meta.groups;
        Set * result;

        /*
         * A return value of -1 indicates failure and errno shall be set to indicate the
         * error.
         */
        ERROR_BEGIN( POSIX_GETGROUPS, "getgroups.07.02", getgroups_spec == -1, * errno )
            /*
             * The getgroups() function shall fail if:
             *
             * [EINVAL]
             *
             * The gidsetsize argument is non-zero and less than the number of group IDs that
             * would have been returned.
             *
             * The gidsetsize argument specifies the number of elements in the array grouplist.
             */
#ifdef NewCTesK
            ERROR_SHALL( POSIX_GETGROUPS, EINVAL, "getgroups.08.01",
                                                  C == C.GrouplistLittleBitSmall                           ||
                                                  C == C.GrouplistTooSmall                                 ||
                                                  ( C == C.MayBeReceiveGrouplist && getgroups_spec == -1 )
                       )
#else
            ERROR_SHALL( POSIX_GETGROUPS, EINVAL, "getgroups.08.01",
                                                  coverage( C ) == GrouplistLittleBitSmall                           ||
                                                  coverage( C ) == GrouplistTooSmall                                 ||
                                                  ( coverage( C ) == MayBeReceiveGrouplist && getgroups_spec == -1 )
                       )
#endif
        ERROR_END()

#ifdef NewCTesK
        if ( C == C.RequestForGroupIDsNumber )
#else
        if ( coverage( C ) == RequestForGroupIDsNumber )
#endif
        {
            if ( groups != NULL )
            {
                /*
                 * If gidsetsize is 0, getgroups() shall return the number of group IDs that it
                 * would otherwise return without modifying the array pointed to by grouplist.
                 */
                REQ( "getgroups.05",
                     "Getgroups() shall return number of group IDs"       , getgroups_spec == size_List( groups ) + shift
                   );
                REQ( "getgroups.05",
                     "Without modifying the array pointed to by grouplist", equals( grouplist, @grouplist )
                   );
            }
        }
        else // coverage( C ) == ReceiveGrouplist || ( coverage( C ) == MayBeReceiveGrouplist && getgroups_spec != -1 )
        {
            result = create_Set( & type_GidTObj );
            addAll_Set( result, toSet_List( groups ) );
            if ( shift == 1 ) // defined GETGROUPS_RETURNS_THE_EFFECTIVE_GROUP_ID_IN_THE_GROUPLIST_ARRAY
            {
                /*
                 * It is implementation-defined whether getgroups() also returns the effective
                 * group ID in the grouplist array.
                 */
                REQ( "getgroups.02", "getgroups() may also returns the effective group ID in the grouplist", true );

                add_Set( result, create_GidTObj( process_state->meta.effective_groupid ) );
            }

            /*
             * The getgroups() function shall fill in the array grouplist with the current
             * supplementary group IDs of the calling process.
             */
            REQ( "getgroups.01", "getgroups() function shall fill grouplist with the current supplementary group IDs",
                                 equals( toSet_List( subList_List( grouplist, 0, getgroups_spec ) ), result )
               );

            /*
             * The values of array entries with indices greater than or equal to the value
             * returned are undefined.
             */
            REQ( "getgroups.04", "The values in the tail of grouplist are undefined", true );

            /*
             * If the effective group ID of the process is returned with the supplementary
             * group IDs, the value returned shall always be greater than or equal to one and
             * less than or equal to the value of {NGROUPS_MAX}+1.
             */
            REQ( "getgroups.06", "Value returned shall be greater or equal", getgroups_spec >= 0 + shift );
            if ( nGroupsMax != SC_VALUE_NO_LIMIT )
            {
                REQ( "getgroups.06", "Value returned shall be less or equal", getgroups_spec <= nGroupsMax + shift );
            }

            /*
             * Upon successful completion, the number of supplementary group IDs shall be
             * returned.
             *
             * The actual number of group IDs stored in the array shall be returned.
             */
            REQ( "getgroups.07.01", "Number of supplementary group IDs shall be returned",
                                    getgroups_spec == size_List( groups ) + shift
               );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    getuid - get a real user ID

SYNOPSIS

    #include <unistd.h>
    uid_t getuid(void);

DESCRIPTION

    The getuid() function shall return the real user ID of the calling process.

RETURN VALUE

    The getuid() function shall always be successful and no return value is
    reserved to indicate the error.

ERRORS

    No errors are defined.
*/
specification
UidT getuid_spec( CallContext context )
{
    ProcessState * process_state;

    pre
    {
        /* [Local variable initialization] */
        process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C
    {
        if ( process_state->meta.real_groupid == process_state->meta.effective_groupid )
        {
            return { GeneralProcess, "General process" };
        }
        else
        {
            return { SetBitProcess, "Set-bit process" };
        }
    }
    post
    {
        /*
         * The getuid() function shall return the real user ID of the calling process.
         *
         * The getuid() function shall always be successful and no return value is
         * reserved to indicate the error.
         */
        REQ( "getuid.01", "The getuid() function shall return the real user ID of the calling process",
                          getuid_spec == process_state->meta.real_userid
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    initgroups -- initialize the supplementary group access list

SYNOPSIS

    #include <grp.h>
    #include <sys/types.h>

    int initgroups(const char * user, gid_t group);

DESCRIPTION

    If the process has appropriate privilege, the initgroups() function shall
    initialize the Supplementary Group IDs for the current process by reading
    the group database and using all groups of which user is a member. The
    additional group group is also added to the list.

RETURN VALUE

    On success, 0 is returned. On error, -1 is returned and the global variable
    errno is set appropriately.

ERRORS

    EPERM
        The calling process does not have sufficient privileges.
    ENOMEM
        Insufficient memory to allocate group information structure.
*/
specification
IntT initgroups_spec( CallContext context, CString * user, GidT group, ErrorCode * errno )
    reads  user
    writes * errno
{
    ProcessState * process_state;

    pre
    {
        /* [Local variable initialization] */
        process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        return true;
    }
    coverage C
    {
        return { InitializeSupplementaryGroupAccessList, "Initialize the supplementary group access list" };
    }
    post
    {
        /*
         * On error, -1 is returned and the global variable errno is set appropriately.
         */
        ERROR_BEGIN( POSIX_INITGROUPS, "initgroups.03.02", initgroups_spec == -1, * errno )
            /*
             * Errors
             *
             * [EPERM] The calling process does not have sufficient privileges.
             */
            ERROR_SHALL( POSIX_INITGROUPS, EPERM,
                         "initgroups.04.01",
                         processReallyHaveLowPriority( context )                                 ||
                         ( ! processReallyHaveHighPriority( context ) && initgroups_spec == -1 )
                       )

            /*
             * Errors
             *
             * [ENOMEM] Insufficient memory to allocate group information structure.
             */
            ERROR_SHALL(POSIX_INITGROUPS, ENOMEM, "initgroups.04.02", TODO_ERR(ENOMEM))
        ERROR_END()

        /*
         * If the process has appropriate privilege, the initgroups() function shall
         * initialize the Supplementary Group IDs for the current process by reading the
         * group database and using all groups of which user is a member.
         */
        REQ( "initgroups.01",
             "If the process has appropriate privilege, the initgroups() shall initialize the Supplementary Group IDs",
             true
           );

        /*
         * The additional group group is also added to the list.
         */
        REQ( "initgroups.02", "The additional group group is also added to the list",
                              contains_List( process_state->meta.groups, create_GidTObj( group ) )
           );

        /*
         * On success, 0 is returned.
         */
        REQ( "initgroups.03.01", "On success, 0 is returned", initgroups_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    setegid - set the effective group ID

SYNOPSIS

    #include <unistd.h>
    int setegid(gid_t gid);

DESCRIPTION

    If gid is equal to the real group ID or the saved set-group-ID, or if the
    process has appropriate privileges, setegid() shall set the effective group
    ID of the calling process to gid; the real group ID, saved set-group-ID,
    and any supplementary group IDs shall remain unchanged.

    The setegid() function shall not affect the supplementary group list in any
    way.

RETURN VALUE

    Upon successful completion, 0 shall be returned; otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The setegid() function shall fail if:

    [EINVAL]
        The value of the gid argument is invalid and is not supported by the
        implementation.
    [EPERM]
        The process does not have appropriate privileges and gid does not match
        the real group ID or the saved set-group-ID.

*/
specification
IntT setegid_spec( CallContext context, GidT gid, ErrorCode * errno )
    writes * errno
{
    ProcessMetaInfo * meta;
    GidT   pre_real_groupid     ;
    GidT   pre_effective_groupid;
    GidT   pre_saved_setgroupid ;
    List * pre_groups           ;

    IdCoverage       gid_coverage     ;
    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_real_groupid      = meta->real_groupid     ;
        pre_effective_groupid = meta->effective_groupid;
        pre_saved_setgroupid  = meta->saved_setgroupid ;

        pre_groups = clone( meta->groups );

        return true;
    }
    coverage C
    {
        gid_coverage      = GidCoverage( context, gid, meta, Id_ReallyInvalid | Id_SavedSetId | Id_RealId | Id_Unknown );
        priority_coverage = ProcessPriorityCoverage( context )                                                          ;

        switch ( DoubleCoverageSwitch( gid_coverage, priority_coverage ) )
        {
            DoubleCoverage( gid, Id_ReallyInvalid, Priority_ReallyHigh )
            DoubleCoverage( gid, Id_ReallyInvalid, Priority_ReallyLow  )
            DoubleCoverage( gid, Id_ReallyInvalid, Priority_Unknown    )
            DoubleCoverage( gid, Id_SavedSetId   , Priority_ReallyHigh )
            DoubleCoverage( gid, Id_SavedSetId   , Priority_ReallyLow  )
            DoubleCoverage( gid, Id_SavedSetId   , Priority_Unknown    )
            DoubleCoverage( gid, Id_RealId       , Priority_ReallyHigh )
            DoubleCoverage( gid, Id_RealId       , Priority_ReallyLow  )
            DoubleCoverage( gid, Id_RealId       , Priority_Unknown    )
            DoubleCoverage( gid, Id_Unknown      , Priority_ReallyHigh )
            DoubleCoverage( gid, Id_Unknown      , Priority_ReallyLow  )
            DoubleCoverage( gid, Id_Unknown      , Priority_Unknown    )
        }
    }
    post
    {
        /*
         * the real group ID, saved set-group-ID, and any supplementary group IDs shall
         * remain unchanged
         */
        REQ( "setegid.02", "Real group ID shall remain unchanged"     , meta->real_groupid     == pre_real_groupid     );
        REQ( "setegid.02", "Saved set-group-ID shall remain unchanged", meta->saved_setgroupid == pre_saved_setgroupid );

        /*
         * The setegid() function shall not affect the supplementary group list in any way.
         */
        REQ( "setegid.03", "setegid() shall not affect the supplementary group list", equals( meta->groups, pre_groups ) );

        /*
         * [Upon successful completion, 0 shall be returned]
         * otherwise, -1 shall be returned and errno set to indicate the error
         */
        ERROR_BEGIN( POSIX_SETEGID, "setegid.04.02", setegid_spec == -1, * errno )
            /*
             * The setegid() function shall fail if:
             *
             * [EINVAL]
             *
             * The value of the gid argument is invalid and is not supported by the
             * implementation.
             */
            ERROR_SHALL( POSIX_SETEGID, EINVAL, "setegid.05.01", gid_coverage == Id_ReallyInvalid                     ||
                                                                 ( gid_coverage == Id_Unknown && setegid_spec == -1 )
                       )

            /*
             * The setegid() function shall fail if:
             *
             * [EPERM]
             *
             * The process does not have appropriate privileges and gid does not match the
             * real group ID or the saved set-group-ID.
             */
            ERROR_SHALL( POSIX_SETEGID, EPERM, "setegid.05.02",
                                               ( priority_coverage == Priority_ReallyLow                         ||
                                                 ( priority_coverage == Priority_Unknown && setegid_spec == -1 )
                                               )                                                                    &&
                                               ( gid_coverage != Id_RealId && gid_coverage != Id_SavedSetId )
                       );

            if ( setegid_spec == -1 )
            {
                REQ( "", "Effective group ID shall remain unchanged", meta->effective_groupid == pre_effective_groupid );
            }
        ERROR_END()

        /*
         * If gid is equal to the real group ID or the saved set-group-ID, or if the
         * process has appropriate privileges, setegid() shall set the effective group ID
         * of the calling process to gid
         */
        REQ( "setegid.01",
             "Gid is equal to the real group ID or the saved set-group-ID, or the process has appropriate privileges",
             ( gid_coverage == Id_RealId || gid_coverage == Id_SavedSetId                  ) ||
             ( gid_coverage != Id_ReallyInvalid && priority_coverage != Priority_ReallyLow )
        );
        REQ( "setegid.01", "Set the effective group ID to gid", meta->effective_groupid == gid );

        /*
         * Upon successful completion, 0 shall be returned
         */
        REQ("setegid.04.01",
            "Upon successful completion, 0 shall be returned",
            setegid_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    seteuid - set effective user ID

SYNOPSIS

    #include <unistd.h>
    int seteuid(uid_t uid);

DESCRIPTION

    If uid is equal to the real user ID or the saved set-user-ID, or if the
    process has appropriate privileges, seteuid() shall set the effective user
    ID of the calling process to uid; the real user ID and saved set-user-ID
    shall remain unchanged.

    The seteuid() function shall not affect the supplementary group list in any
    way.

RETURN VALUE

    Upon successful completion, 0 shall be returned; otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The seteuid() function shall fail if:

    [EINVAL]
        The value of the uid argument is invalid and is not supported by the
        implementation.
    [EPERM]
        The process does not have appropriate privileges and uid does not match
        the real user ID or the saved set-user-ID.
*/
specification
IntT seteuid_spec( CallContext context, UidT uid, ErrorCode * errno )
    writes * errno
{
    ProcessMetaInfo * meta;
    UidT   pre_real_userid     ;
    UidT   pre_effective_userid;
    UidT   pre_saved_setuserid ;
    List * pre_groups          ;

    IdCoverage       uid_coverage     ;
    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_real_userid      = meta->real_userid     ;
        pre_effective_userid = meta->effective_userid;
        pre_saved_setuserid  = meta->saved_setuserid ;

        pre_groups = clone( meta->groups );

        return true;
    }
    coverage C
    {
        uid_coverage      = UidCoverage( context, uid, meta, Id_ReallyInvalid | Id_SavedSetId | Id_RealId | Id_Unknown );
        priority_coverage = ProcessPriorityCoverage( context )                                                          ;

        switch ( DoubleCoverageSwitch( uid_coverage, priority_coverage ) )
        {
            DoubleCoverage( uid, Id_ReallyInvalid, Priority_ReallyHigh )
            DoubleCoverage( uid, Id_ReallyInvalid, Priority_ReallyLow  )
            DoubleCoverage( uid, Id_ReallyInvalid, Priority_Unknown    )
            DoubleCoverage( uid, Id_SavedSetId   , Priority_ReallyHigh )
            DoubleCoverage( uid, Id_SavedSetId   , Priority_ReallyLow  )
            DoubleCoverage( uid, Id_SavedSetId   , Priority_Unknown    )
            DoubleCoverage( uid, Id_RealId       , Priority_ReallyHigh )
            DoubleCoverage( uid, Id_RealId       , Priority_ReallyLow  )
            DoubleCoverage( uid, Id_RealId       , Priority_Unknown    )
            DoubleCoverage( uid, Id_Unknown      , Priority_ReallyHigh )
            DoubleCoverage( uid, Id_Unknown      , Priority_ReallyLow  )
            DoubleCoverage( uid, Id_Unknown      , Priority_Unknown    )
        }
    }
    post
    {
        /*
         * the real user ID and saved set-user-ID shall remain unchanged
         */
        REQ( "seteuid.02", "Real user ID shall remain unchanged"     , meta->real_userid     == pre_real_userid     );
        REQ( "seteuid.02", "Saved set-user-ID shall remain unchanged", meta->saved_setuserid == pre_saved_setuserid );

        /*
         * The seteuid() function shall not affect the supplementary group list in any way.
         */
        REQ( "seteuid.03", "seteuid() shall not affect the supplementary group list", equals( meta->groups, pre_groups ) );

        /*
         * [Upon successful completion, 0 shall be returned]
         * otherwise, -1 shall be returned and errno set to indicate the error
         */
        ERROR_BEGIN( POSIX_SETEUID, "seteuid.04.02", seteuid_spec == -1, * errno )
            /*
             * The seteuid() function shall fail if:
             *
             * [EINVAL]
             *
             * The value of the uid argument is invalid and is not supported by the
             * implementation.
             */
            ERROR_SHALL( POSIX_SETEUID, EINVAL, "seteuid.05.01", uid_coverage == Id_ReallyInvalid                     ||
                                                                 ( uid_coverage == Id_Unknown && seteuid_spec == -1 )
                       )

            /*
             * The seteuid() function shall fail if:
             *
             * [EPERM]
             *
             * The process does not have appropriate privileges and uid does not match the
             * real user ID or the saved set-user-ID.
             */
            ERROR_SHALL( POSIX_SETEUID, EPERM, "seteuid.05.02",
                                               ( priority_coverage == Priority_ReallyLow                         ||
                                                 ( priority_coverage == Priority_Unknown && seteuid_spec == -1 )
                                               )                                                                    &&
                                               ( uid_coverage != Id_RealId && uid_coverage != Id_SavedSetId )
                       );

            if ( seteuid_spec == -1 )
            {
                REQ( "", "Effective user ID shall remain unchanged", meta->effective_userid == pre_effective_userid );
            }
        ERROR_END()

        /*
         * If uid is equal to the real user ID or the saved set-user-ID, or if the process
         * has appropriate privileges, seteuid() shall set the effective user ID of the
         * calling process to uid
         */
        REQ( "seteuid.01",
             "Uid is equal to the real user ID or the saved set-user-ID, if the process has appropriate privileges",
             ( uid_coverage == Id_RealId || uid_coverage == Id_SavedSetId                  ) ||
             ( uid_coverage != Id_ReallyInvalid && priority_coverage != Priority_ReallyLow )
        );
        REQ( "seteuid.01", "Set the effective user ID to uid", meta->effective_userid == uid );

        /*
         * Upon successful completion, 0 shall be returned
         */
        REQ( "seteuid.04.01", "Upon successful completion, 0 shall be returned", seteuid_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    setgid - set-group-ID

SYNOPSIS

    #include <unistd.h>
    int setgid(gid_t gid);

DESCRIPTION

    If the process has appropriate privileges, setgid() shall set the real
    group ID, effective group ID, and the saved set-group-ID of the calling
    process to gid.

    If the process does not have appropriate privileges, but gid is equal to
    the real group ID or the saved set-group-ID, setgid() shall set the
    effective group ID to gid; the real group ID and saved set-group-ID shall
    remain unchanged.

    The setgid() function shall not affect the supplementary group list in any
    way.

    Any supplementary group IDs of the calling process shall remain unchanged.

RETURN VALUE

    Upon successful completion, 0 is returned. Otherwise, -1 shall be returned
    and errno set to indicate the error.

ERRORS

    The setgid() function shall fail if:

    [EINVAL]
        The value of the gid argument is invalid and is not supported by the
        implementation.
    [EPERM]
        The process does not have appropriate privileges and gid does not match
        the real group ID or the saved set-group-ID.
*/
specification
IntT setgid_spec( CallContext context, GidT gid, ErrorCode * errno )
    writes * errno
{
    ProcessMetaInfo * meta;
    GidT   pre_real_groupid     ;
    GidT   pre_effective_groupid;
    GidT   pre_saved_setgroupid ;
    List * pre_groups           ;

    IdCoverage       gid_coverage     ;
    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_real_groupid      = meta->real_groupid     ;
        pre_effective_groupid = meta->effective_groupid;
        pre_saved_setgroupid  = meta->saved_setgroupid ;

        pre_groups = clone( meta->groups );

        return true;
    }
    coverage C
    {
        gid_coverage      = GidCoverage( context, gid, meta, Id_ReallyInvalid | Id_SavedSetId | Id_RealId | Id_Unknown );
        priority_coverage = ProcessPriorityCoverage( context )                                                          ;

        switch ( DoubleCoverageSwitch( gid_coverage, priority_coverage ) )
        {
            DoubleCoverage( gid, Id_ReallyInvalid, Priority_ReallyHigh )
            DoubleCoverage( gid, Id_ReallyInvalid, Priority_ReallyLow  )
            DoubleCoverage( gid, Id_ReallyInvalid, Priority_Unknown    )
            DoubleCoverage( gid, Id_SavedSetId   , Priority_ReallyHigh )
            DoubleCoverage( gid, Id_SavedSetId   , Priority_ReallyLow  )
            DoubleCoverage( gid, Id_SavedSetId   , Priority_Unknown    )
            DoubleCoverage( gid, Id_RealId       , Priority_ReallyHigh )
            DoubleCoverage( gid, Id_RealId       , Priority_ReallyLow  )
            DoubleCoverage( gid, Id_RealId       , Priority_Unknown    )
            DoubleCoverage( gid, Id_Unknown      , Priority_ReallyHigh )
            DoubleCoverage( gid, Id_Unknown      , Priority_ReallyLow  )
            DoubleCoverage( gid, Id_Unknown      , Priority_Unknown    )
        }
    }
    post
    {
        bool checkResult;

        /*
         * The setgid() function shall not affect the supplementary group list in any way.
         *
         * Any supplementary group IDs of the calling process shall remain unchanged.
         */
        REQ( "setgid.03", "setgid() shall not affect the supplementary group list", equals( meta->groups, pre_groups ) );

        /*
         * [Upon successful completion, 0 is returned.]
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SETGID, "setgid.05.02",  setgid_spec == -1, * errno )
            /*
             * The setgid() function shall fail if:
             *
             * [EINVAL]
             *
             * The value of the gid argument is invalid and is not supported by the
             * implementation.
             */
            ERROR_SHALL( POSIX_SETGID, EINVAL, "setgid.06.01", ( gid_coverage == Id_ReallyInvalid && setgid_spec == -1 ) ||
                                                               ( gid_coverage == Id_Unknown       && setgid_spec == -1 )
                       )

            /*
             * The setgid() function shall fail if:
             *
             * [EPERM]
             *
             * The process does not have appropriate privileges and gid does not match the
             * real group ID or the saved set-group-ID.
             */
            ERROR_SHALL( POSIX_SETGID, EPERM, "setgid.06.02",
                                              ( priority_coverage == Priority_ReallyLow                        ||
                                                ( priority_coverage == Priority_Unknown && setgid_spec == -1 )
                                              )                                                                   &&
                                              ( gid_coverage != Id_RealId && gid_coverage != Id_SavedSetId )
                       )

            if ( setgid_spec == -1 )
            {
                REQ( "", "Real group ID shall remain unchanged"     , meta->real_groupid      == pre_real_groupid      );
                REQ( "", "Effective group ID shall remain unchanged", meta->effective_groupid == pre_effective_groupid );
                REQ( "", "Saved set-group-ID shall remain unchanged", meta->saved_setgroupid  == pre_saved_setgroupid  );
            }
        ERROR_END()

        /*
         * If the process has appropriate privileges, setgid() shall set the real group ID,
         * effective group ID, and the saved set-group-ID of the calling process to gid.
         *
         * If the process does not have appropriate privileges, but gid is equal to the
         * real group ID or the saved set-group-ID, setgid() shall set the effective group
         * ID to gid; the real group ID and saved set-group-ID shall remain unchanged.
         */
        checkResult = ( meta->effective_groupid == gid );
        REQ( "setgid.01", "Set the effective group ID to gid", checkResult );
        REQ( "setgid.02", "Set the effective group ID to gid", checkResult );

        if ( priority_coverage == Priority_ReallyHigh                                ||
             ( gid_coverage == Id_Unknown && priority_coverage == Priority_Unknown )
           )
        {
            /*
             * If the process has appropriate privileges, setgid() shall set the real group ID,
             * effective group ID, and the saved set-group-ID of the calling process to gid.
             */
            REQ( "setgid.01", "Set the real group ID to gid"     , meta->real_groupid     == gid );
            REQ( "setgid.01", "Set the saved set-group-ID to gid", meta->saved_setgroupid == gid );
        }
        else if ( priority_coverage == Priority_ReallyLow )
        {
            /*
             * If the process does not have appropriate privileges, but gid is equal to the real
             * group ID or the saved set-group-ID, setgid() shall set the effective group ID to
             * gid; the real group ID and saved set-group-ID shall remain unchanged.
             */
            REQ( "setgid.02", "Real group ID remain unchanged"     , meta->real_groupid     == pre_real_groupid     );
            REQ( "setgid.02", "Saved set-group-ID remain unchanged", meta->saved_setgroupid == pre_saved_setgroupid );
        }
        else
        {
            /*
             * If the process has appropriate privileges, setgid() shall set the real group ID,
             * effective group ID, and the saved set-group-ID of the calling process to gid.
             *
             * If the process does not have appropriate privileges, but gid is equal to the real
             * group ID or the saved set-group-ID, setgid() shall set the effective group ID to
             * gid; the real group ID and saved set-group-ID shall remain unchanged.
             */
            checkResult =
                ( ( T( meta->real_groupid == pre_real_groupid ) && T( meta->saved_setgroupid == pre_saved_setgroupid ) ) ||
                  ( T( meta->real_groupid == gid              ) && T( meta->saved_setgroupid == gid                  ) )
                );
            REQ( "setgid.01", "Real group ID and saved set-group-ID can be changed only to gid value", checkResult );
            REQ( "setgid.02", "Real group ID and saved set-group-ID can be changed only to gid value", checkResult );
        }

        /*
         * Upon successful completion, 0 is returned.
         */
        REQ( "setgid.05.01", "Upon successful completion, 0 is returned", setgid_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    setgroups -- set list of supplementary group IDs

SYNOPSIS

    #include <grp.h>
    int setgroups(size_t size, const gid_t * list);

DESCRIPTION

    If the process has appropriate privilege, the setgroups() function shall set
    the supplementary group IDs for the current process. list shall reference an
    array of size group IDs. A process may have at most NGROUPS_MAX
    supplementary group IDs.

RETURN VALUE

    On successful completion, 0 is returned. On error, -1 is returned and the
    errno is set to indicate the error.

ERRORS

    EPERM
        The calling process does not have sufficient privileges.
    ENOMEM
        Insufficient memory to allocate group information structure.
*/
specification
IntT setgroups_spec( CallContext context, SizeT size, List * list /* & type_GidTObj */, ErrorCode * errno )
    reads  list
    writes * errno
{
    ProcessMetaInfo * meta;

    List * pre_groups;

    LongT nGroupsMax; // NGROUPS_MAX

    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variable initialization] */
        nGroupsMax = getSystemConfigurationValue( context, SUT_SC_NGROUPS_MAX );

        /* [Consistency of test suite] */
        REQ( "", "Value for NGROUPS_MAX is known", nGroupsMax != SC_VALUE_UNKNOWN );

        /* list shall reference an array of size group IDs */
        REQ( "", "list shall reference an array of size group IDs", list != NULL => size_List( list ) == size );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_groups = clone( meta->groups );
        return true;
    }
    coverage C
    {
        priority_coverage = ProcessPriorityCoverage( context );

        if ( priority_coverage == Priority_ReallyLow || list == NULL || (LongT)size > nGroupsMax )
        {
            return { InvalidListOrInvalidSizeOrInvalidPriority, "List or size or process are invalid" };
        }
        else if ( priority_coverage == Priority_Unknown )
        {
            return { UnknownPriority, "List and size is valid but priority is unknown" };
        }
        else // priority_coverage == Priority_ReallyHigh
        {
            return { RightParameters, "All parameters are valid" };
        }
    }
    post
    {
        /*
         * On error, -1 is returned and the errno is set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SETGROUPS, "setgroups.02.02", setgroups_spec == -1, * errno )
            /*
             * Errors
             *
             * [EFAULT] list has an invalid address.
             *
             * list shall reference an array of size group IDs.
             */
            ERROR_SHALL( POSIX_SETGROUPS, EFAULT, "setgroups.03.01", list == NULL )

            /*
             * Errors
             *
             * [EPERM] The process does not have appropriate privileges.
             */
            ERROR_SHALL( POSIX_SETGROUPS, EPERM, "setgroups.03.02",
                                                 priority_coverage == Priority_ReallyLow                           ||
                                                 ( priority_coverage == Priority_Unknown && setgroups_spec == -1 )
             )

            /*
             * Errors
             *
             * [EINVAL] size is greater than NGROUPS_MAX.
             *
             * A process may have at most NGROUPS_MAX supplementary group IDs.
             */
            ERROR_SHALL( POSIX_SETGROUPS, EINVAL, "setgroups.03.03", (LongT)size > nGroupsMax )

            if ( setgroups_spec == -1 )
            {
                /* [On error, the setgroups() function shall not affect the supplementary group list.] */
                REQ( "", "On error, the setgroups() function shall not affect the supplementary group list",
                     equals( meta->groups, pre_groups )
                   );
            }
        ERROR_END()

        /*
         * If the process has appropriate privilege, the setgroups() function shall set
         * the supplementary group IDs for the current process.
         */
        REQ( "setgroups.01", "Set the supplementary group IDs", equals( meta->groups, list ) );

        /*
         * On successful completion, 0 is returned.
         */
        REQ( "setgroups.02.01", "On successful completion, 0 is returned", setgroups_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    setregid - set real and effective group IDs

SYNOPSIS

    #include <unistd.h>
    int setregid(gid_t rgid, gid_t egid);

DESCRIPTION

    The setregid() function shall set the real and effective group IDs of the
    calling process.

    If rgid is -1, the real group ID shall not be changed; if egid is -1, the
    effective group ID shall not be changed.

    The real and effective group IDs may be set to different values in the same
    call.

    Only a process with appropriate privileges can set the real group ID and
    the effective group ID to any valid value.

    A non-privileged process can set either the real group ID to the saved
    set-group-ID from one of the exec family of functions, or the effective
    group ID to the saved set-group-ID or the real group ID.

    Any supplementary group IDs of the calling process remain unchanged.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error, and neither of the group IDs
    are changed.

ERRORS

    The setregid() function shall fail if:

    [EINVAL]
        The value of the rgid or egid argument is invalid or out-of-range.
    [EPERM]
        The process does not have appropriate privileges and a change other
        than changing the real group ID to the saved set-group-ID, or changing
        the effective group ID to the real group ID or the saved set-group-ID,
        was requested.
*/
specification
IntT setregid_spec( CallContext context, GidT rgid, GidT egid, ErrorCode * errno )
    writes * errno
{
    ProcessMetaInfo * meta;
    GidT   pre_real_groupid     ;
    GidT   pre_effective_groupid;
    List * pre_groups           ;

    IdCoverage rgid_coverage;
    IdCoverage egid_coverage;

    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_real_groupid      = meta->real_groupid     ;
        pre_effective_groupid = meta->effective_groupid;

        pre_groups = clone( meta->groups );

        return true;
    }
    coverage C
    {
        rgid_coverage = GidCoverage( context, rgid, meta, Id_SkipValue | Id_SavedSetId |             Id_Unknown );
        egid_coverage = GidCoverage( context, egid, meta, Id_SkipValue | Id_SavedSetId | Id_RealId | Id_Unknown );

        priority_coverage = ProcessPriorityCoverage( context );

        switch ( TripleCoverageSwitch( rgid_coverage, egid_coverage, priority_coverage ) ) {
            TripleCoverage( rgid, Id_SkipValue , egid, Id_SkipValue , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_SkipValue , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_SkipValue , Priority_Unknown    )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_SavedSetId, Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_SavedSetId, Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_SavedSetId, Priority_Unknown    )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_RealId    , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_RealId    , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_RealId    , Priority_Unknown    )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_Unknown   , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_Unknown   , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SkipValue , egid, Id_Unknown   , Priority_Unknown    )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_SkipValue , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_SkipValue , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_SkipValue , Priority_Unknown    )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_SavedSetId, Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_SavedSetId, Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_SavedSetId, Priority_Unknown    )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_RealId    , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_RealId    , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_RealId    , Priority_Unknown    )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_Unknown   , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_Unknown   , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_SavedSetId, egid, Id_Unknown   , Priority_Unknown    )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_SkipValue , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_SkipValue , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_SkipValue , Priority_Unknown    )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_SavedSetId, Priority_ReallyHigh )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_SavedSetId, Priority_ReallyLow  )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_SavedSetId, Priority_Unknown    )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_RealId    , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_RealId    , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_RealId    , Priority_Unknown    )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_Unknown   , Priority_ReallyHigh )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_Unknown   , Priority_ReallyLow  )
            TripleCoverage( rgid, Id_Unknown   , egid, Id_Unknown   , Priority_Unknown    )
        }
    }
    post
    {
        /*
         * Any supplementary group IDs of the calling process remain unchanged.
         */
        REQ( "setregid.05", "Any supplementary group IDs of the calling process remain unchanged",
                            equals( meta->groups, pre_groups )
           );

        /*
         * [Upon successful completion, 0 shall be returned.]
         * Otherwise, -1 shall be returned and errno set to indicate the error, and
         * neither of the group IDs are changed.
         */
        ERROR_BEGIN( POSIX_SETREGID, "setregid.06.02", setregid_spec == -1, * errno )
            /*
             * The setregid() function shall fail if:
             *
             * [EINVAL]
             *
             * The value of the rgid or egid argument is invalid or out-of-range.
             */
            ERROR_SHALL( POSIX_SETREGID, EINVAL, "setregid.07.01",
                                                 ( rgid_coverage == Id_Unknown && setregid_spec == -1 ) ||
                                                 ( egid_coverage == Id_Unknown && setregid_spec == -1 )
                       )

            /*
             * The setregid() function shall fail if:
             *
             * [EPERM]
             *
             * The process does not have appropriate privileges and a change other than
             * changing the real group ID to the saved set-group-ID, or changing the effective
             * group ID to the real group ID or the saved set-group-ID, was requested.
             */
            ERROR_SHALL(
                POSIX_SETREGID, EPERM,
                "setregid.07.02",
                ( priority_coverage == Priority_ReallyLow                          ||
                  ( priority_coverage == Priority_Unknown && setregid_spec == -1 )
                )                                                                                                      &&
                ( ( rgid_coverage != Id_SkipValue &&                               rgid_coverage != Id_SavedSetId ) ||
                  ( egid_coverage != Id_SkipValue && egid_coverage != Id_RealId && egid_coverage != Id_SavedSetId )
                )
            )

            if ( setregid_spec == -1 )
            {
                /*
                 * neither of the group IDs are changed
                 */
                REQ( "setregid.06.03", "real group ID"     , meta->real_groupid      == pre_real_groupid      );
                REQ( "setregid.06.03", "effective group ID", meta->effective_groupid == pre_effective_groupid );
            }
        ERROR_END()

        if ( rgid_coverage == Id_SkipValue )
        {
            /*
             * The setregid() function shall set the real and effective group IDs of the
             * calling process.
             *
             * If rgid is -1, the real group ID shall not be changed
             */
            REQ( "setregid.01.01", "real group ID", meta->real_groupid == pre_real_groupid );
        }
        else
        {
            if ( priority_coverage == Priority_ReallyHigh                                    ||
                 ( priority_coverage == Priority_Unknown && rgid_coverage != Id_SavedSetId )
               )
            {
                /*
                 * Only a process with appropriate privileges can set the real group ID and the
                 * effective group ID to any valid value.
                 */
                REQ( "setregid.03", "Set the real group ID to rgid", meta->real_groupid == rgid );
            }
            else
            {
                /*
                 * A non-privileged process can set either the real group ID to the saved set-
                 * group-ID from one of the exec family of functions, or the effective group ID to
                 * the saved set-group-ID or the real group ID.
                 */
                REQ( "setregid.04", "Set the real group ID to rgid",
                                    rgid_coverage == Id_SavedSetId && meta->real_groupid == rgid
                   );
            }
        }

        if ( egid_coverage == Id_SkipValue )
        {
            /*
             * The setregid() function shall set the real and effective group IDs of the
             * calling process.
             *
             * if egid is -1, the effective group ID shall not be changed
             */
            REQ( "setregid.01.02", "effective group ID", meta->effective_groupid == pre_effective_groupid );
        }
        else
        {
            if ( priority_coverage == Priority_ReallyHigh                                     ||
                 ( priority_coverage == Priority_Unknown && egid_coverage != Id_SavedSetId &&
                                                            egid_coverage != Id_RealId
                 )
               )
            {
                /*
                 * Only a process with appropriate privileges can set the real group ID and the
                 * effective group ID to any valid value.
                 */
                REQ( "setregid.03", "Set the effective group ID to egid", meta->effective_groupid == egid );
            }
            else
            {
                /*
                 * A non-privileged process can set either the real group ID to the saved set-
                 * group-ID from one of the exec family of functions, or the effective group ID to
                 * the saved set-group-ID or the real group ID.
                 */
                REQ( "setregid.04",
                     "Set the effective group ID to egid",
                     ( egid_coverage == Id_RealId || egid_coverage == Id_SavedSetId ) && meta->effective_groupid == egid
                   );
            }
        }

        /*
         * The real and effective group IDs may be set to different values in the same
         * call.
         */
        REQ( "setregid.02", "The real and effective group IDs may be set to different values in the same call", true );

        /*
         * Upon successful completion, 0 shall be returned.
         */
        REQ( "setregid.06.01", "Upon successful completion, 0 shall be returned", setregid_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    setreuid - set real and effective user IDs

SYNOPSIS

    #include <unistd.h>
    int setreuid(uid_t ruid, uid_t euid);

DESCRIPTION

    The setreuid() function shall set the real and effective user IDs of the
    current process to the values specified by the ruid and euid arguments. If
    ruid or euid is -1, the corresponding effective or real user ID of the
    current process shall be left unchanged.

    A process with appropriate privileges can set either ID to any value. An
    unprivileged process can only set the effective user ID if the euid
    argument is equal to either the real, effective, or saved user ID of the
    process.

    It is unspecified whether a process without appropriate privileges is
    permitted to change the real user ID to match the current real, effective,
    or saved set-user-ID of the process.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The setreuid() function shall fail if:

    [EINVAL]
        The value of the ruid or euid argument is invalid or out-of-range.
    [EPERM]
        The current process does not have appropriate privileges, and either an
        attempt was made to change the effective user ID to a value other than
        the real user ID or the saved set-user-ID or an attempt was made to
        change the real user ID to a value not permitted by the implementation.

*/
specification
IntT setreuid_spec( CallContext context, UidT ruid, UidT euid, ErrorCode * errno )
    writes * errno
{
    ProcessMetaInfo * meta;
    UidT pre_real_userid     ;
    UidT pre_effective_userid;

    IdCoverage ruid_coverage;
    IdCoverage euid_coverage;

    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_real_userid      = meta->real_userid     ;
        pre_effective_userid = meta->effective_userid;

        return true;
    }
    coverage C
    {
        ruid_coverage = UidCoverage( context, ruid, meta, Id_SkipValue |                  Id_Unknown );
        euid_coverage = UidCoverage( context, euid, meta, Id_SkipValue | Id_SavedSetId  |
                                                                         Id_RealId      |
                                                                         Id_EffectiveId | Id_Unknown
                                   );

        priority_coverage = ProcessPriorityCoverage( context );

        switch ( TripleCoverageSwitch( ruid_coverage, euid_coverage, priority_coverage ) ) {
            TripleCoverage( ruid, Id_SkipValue, euid, Id_SkipValue  , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_SkipValue  , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_SkipValue  , Priority_Unknown    )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_SavedSetId , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_SavedSetId , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_SavedSetId , Priority_Unknown    )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_RealId     , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_RealId     , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_RealId     , Priority_Unknown    )
            // Priority_ReallyHigh => Id_EffectiveId == Id_SavedSetId
            // TripleCoverage( ruid, Id_SkipValue, euid, Id_EffectiveId, Priority_ReallyHigh )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_EffectiveId, Priority_ReallyLow  )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_EffectiveId, Priority_Unknown    )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_Unknown    , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_Unknown    , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_SkipValue, euid, Id_Unknown    , Priority_Unknown    )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_SkipValue  , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_SkipValue  , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_SkipValue  , Priority_Unknown    )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_SavedSetId , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_SavedSetId , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_SavedSetId , Priority_Unknown    )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_RealId     , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_RealId     , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_RealId     , Priority_Unknown    )
            // Priority_ReallyHigh => Id_EffectiveId == Id_SavedSetId
            // TripleCoverage( ruid, Id_Unknown  , euid, Id_EffectiveId, Priority_ReallyHigh )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_EffectiveId, Priority_ReallyLow  )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_EffectiveId, Priority_Unknown    )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_Unknown    , Priority_ReallyHigh )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_Unknown    , Priority_ReallyLow  )
            TripleCoverage( ruid, Id_Unknown  , euid, Id_Unknown    , Priority_Unknown    )
        }
    }
    post
    {
        /*
         * [Upon successful completion, 0 shall be returned.]
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SETREUID, "setreuid.05.02", setreuid_spec == -1, * errno )
            /*
             * The setreuid() function shall fail if:
             *
             * [EINVAL]
             *
             * The value of the ruid or euid argument is invalid or out-of-range.
             */
            ERROR_SHALL( POSIX_SETREUID, EINVAL, "setreuid.06.01",
                                                 ( ruid_coverage == Id_Unknown && setreuid_spec == -1 ) ||
                                                 ( euid_coverage == Id_Unknown && setreuid_spec == -1 )
                       )

            /*
             * The setreuid() function shall fail if:
             *
             * [EPERM]
             *
             * The current process does not have appropriate privileges, and either an attempt
             * was made to change the effective user ID to a value other than the real user ID
             * or the saved set-user-ID or an attempt was made to change the real user ID to a
             * value not permitted by the implementation.
             */
            ERROR_SHALL( POSIX_SETREUID, EPERM,
                         "setreuid.06.02",
                         ( priority_coverage == Priority_ReallyLow                          ||
                           ( priority_coverage == Priority_Unknown && setreuid_spec == -1 )
                         )                                                                            &&
                         ( ( ruid_coverage != Id_SkipValue                                       ) ||
                           ( euid_coverage != Id_SkipValue && euid_coverage != Id_RealId      &&
                                                              euid_coverage != Id_EffectiveId &&
                                                              euid_coverage != Id_SavedSetId
                           )
                         )
                       )

            if ( setreuid_spec == -1 )
            {
                /* [Neither of the user IDs are changed.] */
                REQ( "", "Real user ID shall remain unchanged"     , meta->real_userid      == pre_real_userid      );
                REQ( "", "Effective user ID shall remain unchanged", meta->effective_userid == pre_effective_userid );
            }
        ERROR_END()

        if ( ruid_coverage == Id_SkipValue )
        {
            /*
             * If ruid or euid is -1, the corresponding effective or real user ID of the
             * current process shall be left unchanged.
             */
            REQ( "setreuid.07", "Real user ID shall not be changed", meta->real_userid == pre_real_userid );
        }
        else
        {
            /*
             * The setreuid() function shall set the real and effective user IDs of the
             * current process to the values specified by the ruid and euid arguments.
             */
            REQ( "setreuid.01", "Set the real user ID to ruid", meta->real_userid == ruid );

            if ( priority_coverage == Priority_ReallyHigh )
            {
                /*
                 * A process with appropriate privileges can set either ID to any value.
                 */
                REQ( "setreuid.02", "process with appropriate privileges", true );
            }

            if ( priority_coverage == Priority_ReallyLow )
            {
                /*
                 * It is unspecified whether a process without appropriate privileges is permitted
                 * to change the real user ID to match the current real, effective, or saved set-
                 * user-ID of the process.
                 */
                REQ( "setreuid.04", "process without appropriate privileges", true );
            }
        }

        if ( euid_coverage == Id_SkipValue )
        {
            /*
             * If ruid or euid is -1, the corresponding effective or real user ID of the
             * current process shall be left unchanged.
             */
            REQ( "setreuid.07", "Effective user ID shall not be changed", meta->effective_userid == pre_effective_userid );
        }
        else
        {
            /*
             * The setreuid() function shall set the real and effective user IDs of the
             * current process to the values specified by the ruid and euid arguments.
             */
            REQ( "setreuid.01", "Set the effective user ID to euid", meta->effective_userid == euid );

            if ( priority_coverage == Priority_ReallyHigh )
            {
                /*
                 * A process with appropriate privileges can set either ID to any value.
                 */
                REQ( "setreuid.02", "process with appropriate privileges", true );
            }

            if ( priority_coverage == Priority_ReallyLow )
            {
                /*
                 * An unprivileged process can only set the effective user ID if the euid argument
                 * is equal to either the real, effective, or saved user ID of the process.
                 */
                REQ( "setreuid.03", "unprivileged process", euid_coverage == Id_RealId      ||
                                                            euid_coverage == Id_SavedSetId  ||
                                                            euid_coverage == Id_EffectiveId
                   );
            }
        }

        /*
         * Upon successful completion, 0 shall be returned.
         */
        REQ( "setreuid.05.01", "Upon successful completion, 0 shall be returned", setreuid_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    setuid - set user ID

SYNOPSIS

    #include <unistd.h>
    int setuid(uid_t uid);

DESCRIPTION

    If the process has appropriate privileges, setuid() shall set the real user
    ID, effective user ID, and the saved set-user-ID of the calling process to
    uid.

    If the process does not have appropriate privileges, but uid is equal to
    the real user ID or the saved set-user-ID, setuid() shall set the effective
    user ID to uid; the real user ID and saved set-user-ID shall remain
    unchanged.

    The setuid() function shall not affect the supplementary group list in any
    way.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The setuid() function shall fail, return -1, and set errno to the
    corresponding value if one or more of the following are true:

    [EINVAL]
        The value of the uid argument is invalid and not supported by the
        implementation.
    [EPERM]
        The process does not have appropriate privileges and uid does not match
        the real user ID or the saved set-user-ID.

*/
specification
IntT setuid_spec( CallContext context, UidT uid, ErrorCode * errno )
    writes * errno
{
    ProcessMetaInfo * meta;
    UidT   pre_real_userid     ;
    UidT   pre_effective_userid;
    UidT   pre_saved_setuserid ;
    List * pre_groups          ;

    IdCoverage       uid_coverage     ;
    PriorityCoverage priority_coverage;

    pre
    {
        /* [Local variable initialization] */
        ProcessState * process_state = getProcessState_CallContext( context );

        /* [Consistency of test suite] */
        REQ( "", "Process state exists", process_state != NULL );

        /* [Local variables initialization] */
        meta = & process_state->meta;

        pre_real_userid      = meta->real_userid     ;
        pre_effective_userid = meta->effective_userid;
        pre_saved_setuserid  = meta->saved_setuserid ;

        pre_groups = clone( meta->groups );

        return true;
    }
    coverage C
    {
        uid_coverage      = UidCoverage( context, uid, meta, Id_ReallyInvalid | Id_SavedSetId | Id_RealId | Id_Unknown );
        priority_coverage = ProcessPriorityCoverage( context )                                                          ;

        switch ( DoubleCoverageSwitch( uid_coverage, priority_coverage ) )
        {
            DoubleCoverage( uid, Id_ReallyInvalid, Priority_ReallyHigh )
            DoubleCoverage( uid, Id_ReallyInvalid, Priority_ReallyLow  )
            DoubleCoverage( uid, Id_ReallyInvalid, Priority_Unknown    )
            DoubleCoverage( uid, Id_SavedSetId   , Priority_ReallyHigh )
            DoubleCoverage( uid, Id_SavedSetId   , Priority_ReallyLow  )
            DoubleCoverage( uid, Id_SavedSetId   , Priority_Unknown    )
            DoubleCoverage( uid, Id_RealId       , Priority_ReallyHigh )
            DoubleCoverage( uid, Id_RealId       , Priority_ReallyLow  )
            DoubleCoverage( uid, Id_RealId       , Priority_Unknown    )
            DoubleCoverage( uid, Id_Unknown      , Priority_ReallyHigh )
            DoubleCoverage( uid, Id_Unknown      , Priority_ReallyLow  )
            DoubleCoverage( uid, Id_Unknown      , Priority_Unknown    )
        }
    }
    post
    {
        bool checkResult;

        /*
         * The setuid() function shall not affect the supplementary group list in any way.
         */
        REQ( "setuid.03", "setuid() shall not affect the supplementary group list", equals( meta->groups, pre_groups ) );

        /*
         * [Upon successful completion, 0 shall be returned.]
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN( POSIX_SETUID, "setuid.04.02", setuid_spec == -1, * errno )
            /*
             * The setuid() function shall fail, return -1, and set errno to the corresponding
             * value if one or more of the following are true:
             *
             * [EINVAL]
             *
             * The value of the uid argument is invalid and not supported by the
             * implementation.
             */
            ERROR_SHALL( POSIX_SETUID, EINVAL, "setuid.05.01", ( uid_coverage == Id_ReallyInvalid && setuid_spec == -1 ) ||
                                                               ( uid_coverage == Id_Unknown       && setuid_spec == -1 )
                       )

            /*
             * The setuid() function shall fail, return -1, and set errno to the corresponding
             * value if one or more of the following are true:
             *
             * [EPERM]
             *
             * The process does not have appropriate privileges and uid does not match the
             * real user ID or the saved set-user-ID.
             */
            ERROR_SHALL( POSIX_SETUID, EPERM, "setuid.05.02",
                                              ( priority_coverage == Priority_ReallyLow                        ||
                                                ( priority_coverage == Priority_Unknown && setuid_spec == -1 )
                                              )                                                                   &&
                                              ( uid_coverage != Id_RealId && uid_coverage != Id_SavedSetId )
                       )

            if ( setuid_spec == -1 )
            {
                REQ( "", "Real user ID shall remain unchanged"     , meta->real_userid      == pre_real_userid      );
                REQ( "", "Effective user ID shall remain unchanged", meta->effective_userid == pre_effective_userid );
                REQ( "", "Saved set-user-ID shall remain unchanged", meta->saved_setuserid  == pre_saved_setuserid  );
            }
        ERROR_END()

        /*
         * If the process has appropriate privileges, setuid() shall set the real user ID,
         * effective user ID, and the saved set-user-ID of the calling process to uid.
         *
         * If the process does not have appropriate privileges, but uid is equal to the
         * real user ID or the saved set-user-ID, setuid() shall set the effective user ID
         * to uid; the real user ID and saved set-user-ID shall remain unchanged.
         */
        checkResult = ( meta->effective_userid == uid );
        REQ( "setuid.01", "Set the effective user ID to uid", checkResult );
        REQ( "setuid.02", "Set the effective user ID to uid", checkResult );

        if ( priority_coverage == Priority_ReallyHigh                              ||
           ( uid_coverage == Id_Unknown && priority_coverage == Priority_Unknown )
        )
        {
            /*
             * If the process has appropriate privileges, setuid() shall set the real user ID,
             * effective user ID, and the saved set-user-ID of the calling process to uid.
             */
            REQ( "setuid.01", "Set the real user ID to uid"     , meta->real_userid     == uid );
            REQ( "setuid.01", "Set the saved set-user-ID to uid", meta->saved_setuserid == uid );
        }
        else if ( priority_coverage == Priority_ReallyLow )
        {
            /*
             * If the process does not have appropriate privileges, but uid is equal to the
             * real user ID or the saved set-user-ID, setuid() shall set the effective user ID
             * to uid; the real user ID and saved set-user-ID shall remain unchanged.
             */
            REQ( "setuid.02", "Real user ID shall remain unchanged"     , meta->real_userid     == pre_real_userid     );
            REQ( "setuid.02", "Saved set-user-ID shall remain unchanged", meta->saved_setuserid == pre_saved_setuserid );
        }
        else
        {
            checkResult =
                ( ( T( meta->real_userid == pre_real_userid ) && T( meta->saved_setuserid == pre_saved_setuserid ) ) ||
                  ( T( meta->real_userid == uid             ) && T( meta->saved_setuserid == uid                 ) )
                );
            REQ( "setuid.01", "Real user ID and saved set-user-ID can be changed only to uid value", checkResult );
            REQ( "setuid.02", "Real user ID and saved set-user-ID can be changed only to uid value", checkResult );
        }

        /*
         * Upon successful completion, 0 shall be returned.
         */
        REQ( "setuid.04.01", "Upon successful completion, 0 shall be returned", setuid_spec == 0 );

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

unsigned int DoubleCoverageSwitch( IdCoverage id_coverage, PriorityCoverage priority_coverage ) {
    return id_coverage << 8 | priority_coverage;
}

unsigned int TripleCoverageSwitch( IdCoverage id1_coverage, IdCoverage id2_coverage, PriorityCoverage priority_coverage ) {
    return id1_coverage << 16 | id2_coverage << 8 | priority_coverage;
}

PriorityCoverage ProcessPriorityCoverage( CallContext context ) {
    if      ( processReallyHaveHighPriority( context ) ) { return Priority_ReallyHigh; }
    else if ( processReallyHaveLowPriority ( context ) ) { return Priority_ReallyLow ; }
                                                    else { return Priority_Unknown   ; }
}

IdCoverage GidCoverage( CallContext context, GidT Id, const ProcessMetaInfo * meta, unsigned int Allowed ) {
    if      ( ( Allowed & Id_SkipValue     ) != 0 && Id == -1                               ) { return Id_SkipValue    ; }
    else if ( ( Allowed & Id_ReallyInvalid ) != 0 && gidValueIsReallyInvalid( context, Id ) ) { return Id_ReallyInvalid; }
    else if ( ( Allowed & Id_SavedSetId    ) != 0 && Id == meta->saved_setgroupid           ) { return Id_SavedSetId   ; }
    else if ( ( Allowed & Id_RealId        ) != 0 && Id == meta->real_groupid               ) { return Id_RealId       ; }
    else if ( ( Allowed & Id_EffectiveId   ) != 0 && Id == meta->effective_groupid          ) { return Id_EffectiveId  ; }
    else if ( ( Allowed & Id_Unknown       ) != 0                                           ) { return Id_Unknown      ; }
    assertion( false, "GidCoverage: bad Allowed" );
    return 0; // for make compiler happy
}

IdCoverage UidCoverage( CallContext context, UidT Id, const ProcessMetaInfo * meta, unsigned int Allowed ) {
    if      ( ( Allowed & Id_SkipValue     ) != 0 && Id == -1                               ) { return Id_SkipValue    ; }
    else if ( ( Allowed & Id_ReallyInvalid ) != 0 && uidValueIsReallyInvalid( context, Id ) ) { return Id_ReallyInvalid; }
    else if ( ( Allowed & Id_SavedSetId    ) != 0 && Id == meta->saved_setuserid            ) { return Id_SavedSetId   ; }
    else if ( ( Allowed & Id_RealId        ) != 0 && Id == meta->real_userid                ) { return Id_RealId       ; }
    else if ( ( Allowed & Id_EffectiveId   ) != 0 && Id == meta->effective_userid           ) { return Id_EffectiveId  ; }
    else if ( ( Allowed & Id_Unknown       ) != 0                                           ) { return Id_Unknown      ; }
    assertion( false, "UidCoverage: bad Allowed" );
    return 0; // for make compiler happy
}

/* 
 * Makes sure the context has appropriate privileges in standard POSIX way.
 * Returns true on success.
 */
bool makeSureProcessHasRootPrivileges(CallContext context)
{
IntT res_uid,res_gid;
    
    res_uid = setuid_spec(context, 0, requestErrorCode());
    res_gid = setgid_spec(context, 0, requestErrorCode());
    return (res_uid == 0) && (res_gid == 0);
}


bool gidValueIsReallyInvalid( CallContext context, GidT gid ) { return (signed)gid == -1; }
bool uidValueIsReallyInvalid( CallContext context, UidT uid ) { return (signed)uid == -1; }
