/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "process/scheduler/process_scheduler_config.h"
#include "process/scheduler/scheduler_model.seh"
#include "system/system/system_model.seh"
#include "data/errno_model.seh"

#pragma SEC subsystem scheduler "process.scheduler"



/*
   The group of functions 'process.scheduler' consists of:
       sched_get_priority_max [2]
       sched_get_priority_min [2]
       sched_getparam [2]
       sched_getscheduler [2]
       sched_rr_get_interval [2]
       sched_setparam [2]
       sched_setscheduler [2]
       sched_yield [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sched_get_priority_max, sched_get_priority_min - get priority limits
        (REALTIME)

SYNOPSIS

    [PS|TPS]  #include <sched.h>

    int sched_get_priority_max(int policy);
    int sched_get_priority_min(int policy);

DESCRIPTION

    The sched_get_priority_max() and sched_get_priority_min() functions shall
    return the appropriate maximum or minimum, respectively, for the scheduling
    policy specified by policy.

    The value of policy shall be one of the scheduling policy values defined in
    <sched.h>.

RETURN VALUE

    If successful, the sched_get_priority_max() and sched_get_priority_min()
    functions shall return the appropriate maximum or minimum values,
    respectively. If unsuccessful, they shall return a value of -1 and set
    errno to indicate the error.

ERRORS

    The sched_get_priority_max() and sched_get_priority_min() functions shall
    fail if:

        [EINVAL]
        The value of the policy parameter does not represent a defined
        scheduling policy.
*/

//This specification refers to: sched_get_priority_min, sched_get_priority_max
specification
IntT sched_get_priority_min_max_spec( CallContext context, IntT policy, ErrorCode* errno, bool min)
{
    pre
    {
        if (min)
        {
            FILTER("sched_get_priority_min");
        }
        else
        {
            FILTER("sched_get_priority_max");
        }
        return true;
    }
    post
    {
        /*
        * The value of policy shall be one of the scheduling policy values
        * defined in <sched.h>.
        */
        REQ("sched_get_priority_max.02;sched_get_priority_min.02",
            "The value of policy shall be one of the scheduling policy values "
            "defined in <sched.h>", isValid_Policy(policy) != 0);

        /*
        * If unsuccessful, they shall return a value of -1 and set errno to
        * indicate the error.
        */
        ERROR_BEGIN(POSIX_SCHED_GET_PRIORITY_MAX,
                   "sched_get_priority_max.03.02;sched_get_priority_min.03.02",
                    sched_get_priority_min_max_spec == -1, *errno)

        /*
        * The sched_get_priority_max() and sched_get_priority_min() functions
        * shall fail if:
        *
        * [EINVAL] The value of the policy parameter does not represent a
        * defined scheduling policy.
        */
        ERROR_SHALL(POSIX_SCHED_GET_PRIORITY_MAX, EINVAL,
                   "sched_get_priority_max.04.01;sched_get_priority_min.04.01",
                    isValid_Policy(policy) == 0)

        ERROR_END()

        FILTER_CLEAN;

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sched_getparam - get scheduling parameters (REALTIME)

SYNOPSIS

    [PS]  #include <sched.h>
    int sched_getparam(pid_t pid, struct sched_param *param);

DESCRIPTION

    The sched_getparam() function shall return the scheduling parameters of a
    process specified by pid in the sched_param structure pointed to by param.

    If a process specified by pid exists, and if the calling process has
    permission, the scheduling parameters for the process whose process ID is
    equal to pid shall be returned.

    If pid is zero, the scheduling parameters for the calling process shall be
    returned. The behavior of the sched_getparam() function is unspecified if
    the value of pid is negative.

RETURN VALUE

    Upon successful completion, the sched_getparam() function shall return
    zero.If the call to sched_getparam() is unsuccessful, the function shall
    return a value of -1 and set errno to indicate the error.

ERRORS

    The sched_getparam() function shall fail if:

        [EPERM]
        The requesting process does not have permission to obtain the
        scheduling parameters of the specified process.

        [ESRCH]
        No process can be found corresponding to that specified by pid.
*/
specification typedef struct SchedGetParamReturnType SchedGetParamReturnType = {};

SchedGetParamReturnType * create_SchedGetParamReturnType(
    IntT funcRes,
    ShedParam* shParam
)
{
    return create(&type_SchedGetParamReturnType, funcRes, shParam);
}

RRGetIntervalReturnType * create_RRGetIntervalReturnType(
    IntT          funcRes,
    TimeSpecTObj* interval
)
{
    return create(&type_RRGetIntervalReturnType, funcRes, interval);
}


specification
SchedGetParamReturnType* sched_getparam_spec( CallContext context, PidT pid, ErrorCode* errno)
{
    pre
    {
        /*
        * The behavior of the sched_getparam() function is unspecified if the value of
        * pid is negative.
        */
        REQ("app.sched_getparam.04",
            "The behavior is unspecified if pid<0",
            pid >= 0);

        return true;
    }
    post
    {
        ProcessState* process_state;
        if(pid == 0)
            process_state = getProcessState_CallContext(context);
        else
            process_state = findProcessState_PidT(pid);

        /*
        * If the call to sched_getparam() is unsuccessful, the function shall return a
        * value of -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SCHED_GETPARAM, "sched_getparam.05.02", sched_getparam_spec->funcRes == -1, *errno)

        /*
        * The sched_getparam() function shall fail if:
        *
        * [EPERM] The requesting process does not have permission to obtain the
        * scheduling parameters of the specified process.
        */
        ERROR_SHALL(POSIX_SCHED_GETPARAM, EPERM, "sched_getparam.06.01", TODO_ERR(EPERM) )

        /*
        * The sched_getparam() function shall fail if:
        *
        * [ESRCH] No process can be found corresponding to that specified by pid.
        */
        ERROR_SHALL(POSIX_SCHED_GETPARAM, ESRCH, "sched_getparam.06.02", TODO_ERR(ESRCH) )

        ERROR_END()

        /*
        * Upon successful completion, the sched_getparam() function shall
        * return zero.
        */
        REQ("sched_getparam.05.01",
            "Function shall return zero",
             sched_getparam_spec->funcRes == 0);

        if((pid != 0) && (process_state->param != NULL))
        {
            /*
            * The sched_getparam() function shall return the scheduling
            * parameters of a process specified by pid in the sched_param
            * structure pointed to by param.
            */
            /*
            * If a process specified by pid exists, and if the calling process
            * has permission, the scheduling parameters for the process whose
            * process ID is equal to pid shall be returned.
            */
            REQ("sched_getparam.01;sched_getparam.02",
                "Shall return scheduling parameters",
                 compareSchedParam(context, process_state->param,
                                   sched_getparam_spec->shParam) == true);
        }

        if((pid == 0) && (process_state->param != NULL))
        {
            /*
            * If pid is zero, the scheduling parameters for the calling process
            * shall be returned.
            */
            REQ("sched_getparam.03", "If pid is zero",
                 compareSchedParam(context, process_state->param,
                                   sched_getparam_spec->shParam) == true);
        }
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sched_getscheduler - get scheduling policy (REALTIME)

SYNOPSIS

    [PS]  #include <sched.h>
    int sched_getscheduler(pid_t pid);

DESCRIPTION

    The sched_getscheduler() function shall return the scheduling policy of the
    process specified by pid. If the value of pid is negative, the behavior of
    the sched_getscheduler() function is unspecified.

    The values that can be returned by sched_getscheduler() are defined in the
    <sched.h> header.

    If a process specified by pid exists, and if the calling process has
    permission, the scheduling policy shall be returned for the process whose
    process ID is equal to pid.

    If pid is zero, the scheduling policy shall be returned for the calling
    process.

RETURN VALUE

    Upon successful completion, the sched_getscheduler() function shall return
    the scheduling policy of the specified process. If unsuccessful, the
    function shall return -1 and set errno to indicate the error.

ERRORS

    The sched_getscheduler() function shall fail if:

        [EPERM]
        The requesting process does not have permission to determine the
        scheduling policy of the specified process.

        [ESRCH]
        No process can be found corresponding to that specified by pid.
*/
specification
IntT sched_getscheduler_spec(CallContext context, PidT pid, ErrorCode* errno)
{
    pre
    {
        /*
        * If the value of pid is negative, the behavior of the sched_getscheduler()
        * function is unspecified.
        */
        REQ("app.sched_getscheduler.02",
            "The behavior is unspecified if pid<0",
            pid >= 0);

        return true;
    }
    post
    {
        ProcessState* process_state;
        if(pid == 0)
            process_state = getProcessState_CallContext(context);
        else
            process_state = findProcessState_PidT(pid);

        /*
        * If unsuccessful, the function shall return -1 and set errno to indicate the
        * error.
        */
        ERROR_BEGIN(POSIX_SCHED_GETSCHEDULER, "sched_getscheduler.06.02", sched_getscheduler_spec == -1, *errno)

        /*
        * The sched_getscheduler() function shall fail if:
        *
        * [EPERM] The requesting process does not have permission to determine the
        * scheduling policy of the specified process.
        */
        ERROR_SHALL(POSIX_SCHED_GETSCHEDULER, EPERM, "sched_getscheduler.07.01", TODO_ERR(EPERM) )

        /*
        * The sched_getscheduler() function shall fail if:
        *
        * [ESRCH] No process can be found corresponding to that specified by pid.
        */
        ERROR_SHALL(POSIX_SCHED_GETSCHEDULER, ESRCH, "sched_getscheduler.07.02", TODO_ERR(ESRCH) )

        ERROR_END()

        if((pid != 0) && (process_state->param != NULL))
        {
            /*
            * The sched_getscheduler() function shall return the scheduling
            * policy of the process specified by pid.
            */
            /*
            * If a process specified by pid exists, and if the calling process
            * has permission, the scheduling policy shall be returned for the
            * process whose process ID is equal to pid.
            */
            /*
            * Upon successful completion, the sched_getscheduler() function
            * shall return the scheduling policy of the specified process.
            */
            REQ("sched_getscheduler.01;sched_getscheduler.04;"
                "sched_getscheduler.06.01",
                "Function shall return the scheduling policy",
                 process_state->policy == sched_getscheduler_spec);
        }

        if((pid == 0) && (process_state->param != NULL))
        {
            /*
            * If pid is zero, the scheduling policy shall be returned for the
            * calling process.
            */
            REQ("sched_getscheduler.05", "If pid is zero",
                 process_state->policy == sched_getscheduler_spec);
        }

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sched_rr_get_interval - get execution time limits (REALTIME)

SYNOPSIS

    [PS|TPS]  #include <sched.h>
    int sched_rr_get_interval(pid_t pid, struct timespec *interval);

DESCRIPTION

    The sched_rr_get_interval() function shall update the timespec structure
    referenced by the interval argument to contain the current execution time
    limit (that is, time quantum) for the process specified by pid. If pid is
    zero, the current execution time limit for the calling process shall be
    returned.

RETURN VALUE

    If successful, the sched_rr_get_interval() function shall return zero.
    Otherwise, it shall return a value of -1 and set errno to indicate the
    error.

ERRORS

    The sched_rr_get_interval() function shall fail if:

        [ESRCH]
        No process can be found corresponding to that specified by pid.
*/
specification typedef struct RRGetIntervalReturnType RRGetIntervalReturnType = {};

specification
RRGetIntervalReturnType* sched_rr_get_interval_spec( CallContext context, PidT pid, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        /*
        * Otherwise, it shall return a value of -1 and set errno to indicate the error.
        */
        ERROR_BEGIN(POSIX_SCHED_RR_GET_INTERVAL, "sched_rr_get_interval.03.02", sched_rr_get_interval_spec->funcRes == -1, *errno)

        /*
        * The sched_rr_get_interval() function shall fail if:
        *
        * [ESRCH] No process can be found corresponding to that specified by pid.
        */
        ERROR_SHALL(POSIX_SCHED_RR_GET_INTERVAL, ESRCH, "sched_rr_get_interval.04.01", TODO_ERR(ESRCH) )

        ERROR_END()

        /*
        * If successful, the sched_rr_get_interval() function shall return zero.
        */
        REQ("sched_rr_get_interval.03.01",
            "Function shall return zero",
             sched_rr_get_interval_spec->funcRes == 0);

        /*
        * The sched_rr_get_interval() function shall update the timespec structure
        * referenced by the interval argument to contain the current execution time
        * limit (that is, time quantum) for the process specified by pid.
        */
        REQ("sched_rr_get_interval.01", "", TODO_REQ());

        /*
        * If pid is zero, the current execution time limit for the calling process shall
        * be returned.
        */
        REQ("sched_rr_get_interval.02", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sched_setparam - set scheduling parameters (REALTIME)

SYNOPSIS

    [PS]  #include <sched.h>
    int sched_setparam(pid_t pid, const struct sched_param *param);

DESCRIPTION

    The sched_setparam() function shall set the scheduling parameters of the
    process specified by pid to the values specified by the sched_param
    structure pointed to by param. The value of the sched_priority member in
    the sched_param structure shall be any integer within the inclusive
    priority range for the current scheduling policy of the process specified
    by pid. Higher numerical values for the priority represent higher
    priorities.If the value of pid is negative, the behavior of the
    sched_setparam() function is unspecified.

    If a process specified by pid exists, and if the calling process has
    permission, the scheduling parameters shall be set for the process whose
    process ID is equal to pid.

    If pid is zero, the scheduling parameters shall be set for the calling
    process.

    The conditions under which one process has permission to change the
    scheduling parameters of another process are implementation-defined.

    Implementations may require the requesting process to have the appropriate
    privilege to set its own scheduling parameters or those of another process.

    The target process, whether it is running or not running, shall be moved to
    the tail of the thread list for its priority.

    If the priority of the process specified by the pid argument is set higher
    than that of the lowest priority running process and if the specified
    process is ready to run, the process specified by the pid argument shall
    preempt a lowest priority running process. Similarly, if the process
    calling sched_setparam() sets its own priority lower than that of one or
    more other non-empty process lists, then the process that is the head of
    the highest priority list shall also preempt the calling process. Thus, in
    either case, the originating process might not receive notification of the
    completion of the requested priority change until the higher priority
    process has executed.

    [SS]  If the scheduling policy of the target process is SCHED_SPORADIC, the
    value specified by the sched_ss_low_priority member of the param argument
    shall be any integer within the inclusive priority range for the sporadic
    server policy. The sched_ss_repl_period and sched_ss_init_budget members of
    the param argument shall represent the time parameters to be used by the
    sporadic server scheduling policy for the target process. The
    sched_ss_max_repl member of the param argument shall represent the maximum
    number of replenishments that are allowed to be pending simultaneously for
    the process scheduled under this scheduling policy.

    The specified sched_ss_repl_period shall be greater than or equal to the
    specified sched_ss_init_budget for the function to succeed; if it is not,
    then the function shall fail.

    The value of sched_ss_max_repl shall be within the inclusive range [1,
    {SS_REPL_MAX}] for the function to succeed; if not, the function shall
    fail.

    If the scheduling policy of the target process is either SCHED_FIFO or
    SCHED_RR, the sched_ss_low_priority, sched_ss_repl_period, and
    sched_ss_init_budget members of the param argument shall have no effect on
    the scheduling behavior.If the scheduling policy of this process is not
    SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC, the effects of these members are
    implementation-defined; this case includes the SCHED_OTHER policy.

    If the current scheduling policy for the process specified by pid is not
    SCHED_FIFO, SCHED_RR, [SS]   or SCHED_SPORADIC,   the result is
    implementation-defined; this case includes the SCHED_OTHER policy.

    The effect of this function on individual threads is dependent on the
    scheduling contention scope of the threads:

    For threads with system scheduling contention scope, these functions shall
    have no effect on their scheduling.

    For threads with process scheduling contention scope, the threads'
    scheduling parameters shall not be affected. However, the scheduling of
    these threads with respect to threads in other processes may be dependent
    on the scheduling parameters of their process, which are governed using
    these functions.

    If an implementation supports a two-level scheduling model in which library
    threads are multiplexed on top of several kernel-scheduled entities, then
    the underlying kernel-scheduled entities for the system contention scope
    threads shall not be affected by these functions.

    The underlying kernel-scheduled entities for the process contention scope
    threads shall have their scheduling parameters changed to the value
    specified in param. Kernel-scheduled entities for use by process contention
    scope threads that are created after this call completes shall inherit
    their scheduling policy and associated scheduling parameters from the
    process.

    This function is not atomic with respect to other threads in the process.
    Threads may continue to execute while this function call is in the process
    of changing the scheduling policy for the underlying kernel-scheduled
    entities used by the process contention scope threads.

RETURN VALUE

    If successful, the sched_setparam() function shall return zero.

    If the call to sched_setparam() is unsuccessful, the priority shall remain
    unchanged, and the function shall return a value of -1 and set errno to
    indicate the error.

ERRORS

    The sched_setparam() function shall fail if:

        [EINVAL]
        One or more of the requested scheduling parameters is outside the range
        defined for the scheduling policy of the specified pid.

        [EPERM]
        The requesting process does not have permission to set the scheduling
        parameters for the specified process, or does not have the appropriate
        privilege to invoke sched_setparam().

        [ESRCH]
        No process can be found corresponding to that specified by pid.
*/
specification
IntT sched_setparam_spec( CallContext context, PidT pid, ShedParam* param, ErrorCode* errno)
{
    ProcessState* process_state = findProcessState_PidT(pid);
    LongT repl_max = getSystemConfigurationValue(context, SUT_SS_REPL_MAX);

    pre
    {
        /*
        * If the value of pid is negative, the behavior of the sched_setparam() function
        * is unspecified.
        */
        REQ("app.sched_setparam.04",
            "The value of pid must be positive or zero",
             pid >= 0);

        /*
         * The value of the sched_priority member in the sched_param structure shall be
         * any integer within the inclusive priority range for the current scheduling
         * policy of the process specified by pid.
         */
        REQ("sched_setparam.02",
            "Sched_priority member in the sched_param is valid",
             isValid_Priority(context, process_state->policy, process_state, param) == true);

        if((process_state->policy == SUT_SCHED_SPORADIC) &&
           (isDefined_SporadicServer(context) == true))
        {
            /*
             * If the scheduling policy of the target process is
             * SCHED_SPORADIC, the value specified by the sched_ss_low_priority
             * member of the param argument shall be any integer within the
             * inclusive priority range for the sporadic server policy.
             */
            REQ("sched_setparam.13", "sched_ss_low_priority is valid",
                 isValid_LowPriority(context, process_state->policy, process_state, param) == true);
        }

        return true;
    }
    post
    {
        /*
         * If the call to sched_setparam() is unsuccessful, the priority shall
         * remain unchanged, and the function shall return a value of -1 and
         * set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_SCHED_SETPARAM, "sched_setparam.27", sched_setparam_spec == -1, *errno)

        /*
        * The sched_setparam() function shall fail if:
        *
        * [EINVAL] One or more of the requested scheduling parameters is
        * outside the range defined for the scheduling policy of the specified
        * pid.
        */
        ERROR_SHALL(POSIX_SCHED_SETPARAM, EINVAL, "sched_setparam.28.01",
                    (isValid_SchedParam(context, process_state->policy, process_state, param) == false))

        /*
        * The sched_setparam() function shall fail if:
        *
        * [EPERM] The requesting process does not have permission to set the
        * scheduling parameters for the specified process, or does not have the
        * appropriate privilege to invoke sched_setparam().
        */
        ERROR_SHALL(POSIX_SCHED_SETPARAM, EPERM, "sched_setparam.28.02", TODO_ERR(EPERM) )

        /*
        * The sched_setparam() function shall fail if:
        *
        * [ESRCH] No process can be found corresponding to that specified by
        * pid.
        */
        ERROR_SHALL(POSIX_SCHED_SETPARAM, ESRCH, "sched_setparam.28.03", TODO_ERR(ESRCH) )

        ERROR_END()

        if((isValid_ReplPeriod_And_InitBudget(param) == false) &&
           (isDefined_SporadicServer(context) == true))
        {
            /*
             * The specified sched_ss_repl_period shall be greater than or
             * equal to the specified sched_ss_init_budget for the function to
             * succeed; if it is not, then the function shall fail.
             */
            REQ("sched_setparam.16",
                "Shall be: sched_ss_repl_period>=sched_ss_init_budget",
                sched_setparam_spec == -1);
        }

        if(((param->sched_ss_max_repl < 1) ||
           (param->sched_ss_max_repl > repl_max)) &&
           (isDefined_SporadicServer(context) == true))
        {
            /*
             * The value of sched_ss_max_repl shall be within the inclusive
             * range [1, {SS_REPL_MAX}] for the function to succeed; if not,
             * the function shall fail.
             */
            REQ("sched_setparam.17",
                "sched_ss_max_repl shall be within [1, {SS_REPL_MAX}]",
                sched_setparam_spec == -1);
        }

        /*
         * If successful, the sched_setparam() function shall return zero.
         */
        REQ("sched_setparam.26", "Function shall return zero", sched_setparam_spec == 0);

        /*
         * The sched_setparam() function shall set the scheduling parameters of
         * the process specified by pid to the values specified by the
         * sched_param structure pointed to by param.
         */
        REQ("sched_setparam.01", "", TODO_REQ());

        /*
         * Higher numerical values for the priority represent higher priorities.
         */
        REQ("sched_setparam.03", "", TODO_REQ());

        /*
         * If a process specified by pid exists, and if the calling process has
         * permission, the scheduling parameters shall be set for the process
         * whose process ID is equal to pid.
         */
        REQ("sched_setparam.05", "", TODO_REQ());

        /*
         * If pid is zero, the scheduling parameters shall be set for the
         * calling process.
         */
        REQ("sched_setparam.06", "", TODO_REQ());

        /*
         * The conditions under which one process has permission to change the
         * scheduling parameters of another process are implementation-defined.
         */
        REQ("sched_setparam.07", "", TODO_REQ());

        /*
         * Implementations may require the requesting process to have the
         * appropriate privilege to set its own scheduling parameters or those
         * of another process.
         */
        REQ("sched_setparam.08", "", TODO_REQ());

        /*
         * The target process, whether it is running or not running, shall be
         * moved to the tail of the thread list for its priority.
         */
        REQ("sched_setparam.09", "", TODO_REQ());

        /*
         * If the priority of the process specified by the pid argument is set
         * higher than that of the lowest priority running process and if the
         * specified process is ready to run, the process specified by the pid
         * argument shall preempt a lowest priority running process.
         */
        REQ("sched_setparam.10", "", TODO_REQ());

        /*
         * Similarly, if the process calling sched_setparam() sets its own
         * priority lower than that of one or more other non-empty process
         * lists, then the process that is the head of the highest priority
         * list shall also preempt the calling process.
         */
        REQ("sched_setparam.11", "", TODO_REQ());

        /*
         * Thus, in either case, the originating process might not receive
         * notification of the completion of the requested priority change
         * until the higher priority process has executed.
         */
        REQ("sched_setparam.12", "", TODO_REQ());

        /*
         * The sched_ss_repl_period and sched_ss_init_budget members of the
         * param argument shall represent the time parameters to be used by the
         * sporadic server scheduling policy for the target process.
         */
        REQ("sched_setparam.14", "", TODO_REQ());

        /*
         * The sched_ss_max_repl member of the param argument shall represent
         * the maximum number of replenishments that are allowed to be pending
         * simultaneously for the process scheduled under this scheduling
         * policy.
         */
        REQ("sched_setparam.15", "", TODO_REQ());

        /*
         * If the scheduling policy of the target process is either SCHED_FIFO
         * or SCHED_RR, the sched_ss_low_priority, sched_ss_repl_period, and
         * sched_ss_init_budget members of the param argument shall have no
         * effect on the scheduling behavior.
         */
        REQ("sched_setparam.18", "", TODO_REQ());

        /*
         * If the scheduling policy of this process is not SCHED_FIFO,
         * SCHED_RR, or SCHED_SPORADIC, the effects of these members are
         * implementation-defined; this case includes the SCHED_OTHER policy.
         */
        REQ("sched_setparam.19", "", TODO_REQ());

        /*
         * If the current scheduling policy for the process specified by pid is
         * not SCHED_FIFO, SCHED_RR, [SS] or SCHED_SPORADIC, the result is
         * implementation-defined; this case includes the SCHED_OTHER policy.
         */
        REQ("sched_setparam.20", "", TODO_REQ());

        /*
         * The effect of this function on individual threads is dependent on
         * the scheduling contention scope of the threads:
         *
         * For threads with system scheduling contention scope, these functions
         * shall have no effect on their scheduling.
         */
        REQ("sched_setparam.21.01", "", TODO_REQ());

        /*
         * For threads with process scheduling contention scope, the threads'
         * scheduling parameters shall not be affected.
         */
        REQ("sched_setparam.21.02.01", "", TODO_REQ());

        /*
         * However, the scheduling of these threads with respect to threads in
         * other processes may be dependent on the scheduling parameters of
         * their process, which are governed using these functions.
         */
        REQ("sched_setparam.21.02.02", "", TODO_REQ());

        /*
         * If an implementation supports a two-level scheduling model in which
         * library threads are multiplexed on top of several kernel-scheduled
         * entities, then the underlying kernel-scheduled entities for the
         * system contention scope threads shall not be affected by these
         * functions.
         */
        REQ("sched_setparam.22", "", TODO_REQ());

        /*
         * The underlying kernel-scheduled entities for the process contention
         * scope threads shall have their scheduling parameters changed to the
         * value specified in param.
         */
        REQ("sched_setparam.23", "", TODO_REQ());

        /*
         * Kernel-scheduled entities for use by process contention scope
         * threads that are created after this call completes shall inherit
         * their scheduling policy and associated scheduling parameters from
         * the process.
         */
        REQ("sched_setparam.24", "", TODO_REQ());

        /*
         * This function is not atomic with respect to other threads in the
         * process. Threads may continue to execute while this function call is
         * in the process of changing the scheduling policy for the underlying
         * kernel-scheduled entities used by the process contention scope
         * threads.
         */
        REQ("sched_setparam.25", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    sched_setscheduler - set scheduling policy and parameters (REALTIME)

SYNOPSIS

    [PS]  #include <sched.h>

    int sched_setscheduler(pid_t pid, int policy,
        const struct sched_param *param);


DESCRIPTION

    The sched_setscheduler() function shall set the scheduling policy and
    scheduling parameters of the process specified by pid to policy and the
    parameters specified in the sched_param structure pointed to by param,
    respectively. The value of the sched_priority member in the sched_param
    structure shall be any integer within the inclusive priority range for the
    scheduling policy specified by policy. If the value of pid is negative, the
    behavior of the sched_setscheduler() function is unspecified.

    The possible values for the policy parameter are defined in the <sched.h>
    header.

    If a process specified by pid exists, and if the calling process has
    permission, the scheduling policy and scheduling parameters shall be set
    for the process whose process ID is equal to pid.

    If pid is zero, the scheduling policy and scheduling parameters shall be
    set for the calling process.

    The conditions under which one process has the appropriate privilege to
    change the scheduling parameters of another process are
    implementation-defined.

    Implementations may require that the requesting process have permission to
    set its own scheduling parameters or those of another process.
    Additionally, implementation-defined restrictions may apply as to the
    appropriate privileges required to set a process' own scheduling policy, or
    another process' scheduling policy, to a particular value.

    The sched_setscheduler() function shall be considered successful if it
    succeeds in setting the scheduling policy and scheduling parameters of the
    process specified by pid to the values specified by policy and the
    structure pointed to by param, respectively.

    [SS] If the scheduling policy specified by policy is SCHED_SPORADIC, the
    value specified by the sched_ss_low_priority member of the param argument
    shall be any integer within the inclusive priority range for the sporadic
    server policy. The sched_ss_repl_period and sched_ss_init_budget members of
    the param argument shall represent the time parameters used by the sporadic
    server scheduling policy for the target process. The sched_ss_max_repl
    member of the param argument shall represent the maximum number of
    replenishments that are allowed to be pending simultaneously for the
    process scheduled under this scheduling policy.

    The specified sched_ss_repl_period shall be greater than or equal to the
    specified sched_ss_init_budget for the function to succeed; if it is not,
    then the function shall fail.

    The value of sched_ss_max_repl shall be within the inclusive range [1,
    {SS_REPL_MAX}] for the function to succeed; if not, the function shall
    fail.

    If the scheduling policy specified by policy is either SCHED_FIFO or
    SCHED_RR, the sched_ss_low_priority, sched_ss_repl_period, and
    sched_ss_init_budget members of the param argument shall have no effect on
    the scheduling behavior.

    The effect of this function on individual threads is dependent on the
    scheduling contention scope of the threads:

    For threads with system scheduling contention scope, these functions shall
    have no effect on their scheduling.

    For threads with process scheduling contention scope, the threads'
    scheduling policy and associated parameters shall not be affected. However,
    the scheduling of these threads with respect to threads in other processes
    may be dependent on the scheduling parameters of their process, which are
    governed using these functions.

    If an implementation supports a two-level scheduling model in which library
    threads are multiplexed on top of several kernel-scheduled entities, then
    the underlying kernel-scheduled entities for the system contention scope
    threads shall not be affected by these functions.

    The underlying kernel-scheduled entities for the process contention scope
    threads shall have their scheduling policy and associated scheduling
    parameters changed to the values specified in policy and param,
    respectively. Kernel-scheduled entities for use by process contention scope
    threads that are created after this call completes shall inherit their
    scheduling policy and associated scheduling parameters from the process.

    This function is not atomic with respect to other threads in the process.
    Threads may continue to execute while this function call is in the process
    of changing the scheduling policy and associated scheduling parameters for
    the underlying kernel-scheduled entities used by the process contention
    scope threads.

RETURN VALUE

    Upon successful completion, the function shall return the former scheduling
    policy of the specified process. If the sched_setscheduler() function fails
    to complete successfully, the policy and scheduling parameters shall remain
    unchanged, and the function shall return a value of -1 and set errno to
    indicate the error.

ERRORS

    The sched_setscheduler() function shall fail if:

        [EINVAL]
        The value of the policy parameter is invalid, or one or more of the
        parameters contained in param is outside the valid range for the
        specified scheduling policy.

        [EPERM]
        The requesting process does not have permission to set either or both
        of the scheduling parameters or the scheduling policy of the specified
        process.

        [ESRCH]
        No process can be found corresponding to that specified by pid.
*/

specification
IntT sched_setscheduler_spec( CallContext context, PidT pid, IntT policy, IntT* former_policy, ShedParam* param, ErrorCode* errno)
{
    ProcessState* process_state = findProcessState_PidT(pid);
    LongT repl_max = getSystemConfigurationValue(context, SUT_SS_REPL_MAX);

    pre
    {
        /*
        * If the value of pid is negative, the behavior of the
        * sched_setscheduler() function is unspecified.
        */
        REQ("app.sched_setscheduler.03",
            "The value of pid must be positive or zero",
             pid >= 0);

        /*
        * The value of the sched_priority member in the sched_param structure
        * shall be any integer within the inclusive priority range for the
        * scheduling policy specified by policy.
        */
        REQ("sched_setscheduler.02",
            "Sched_priority member in the sched_param is valid",
             isValid_Priority(context, policy, process_state, param) == true);

        if((policy == SUT_SCHED_SPORADIC) &&
           (isDefined_SporadicServer(context) == true))
        {
            /*
             * If the scheduling policy specified by policy is SCHED_SPORADIC,
             * the value specified by the sched_ss_low_priority member of the
             * param argument shall be any integer within the inclusive
             * priority range for the sporadic server policy.
             */
            REQ("sched_setscheduler.11",
                "sched_ss_low_priority is valid",
                 isValid_LowPriority(context, policy, process_state, param) == true);
        }
        return true;
    }
    post
    {
         /*
         * If the sched_setscheduler() function fails to complete successfully,
         * the policy and scheduling parameters shall remain unchanged, and the
         * function shall return a value of -1 and set errno to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_SCHED_SETSCHEDULER, "sched_setscheduler.22.02",
                    sched_setscheduler_spec == -1, *errno)

        /*
        * The sched_setscheduler() function shall fail if:
        *
        * [EINVAL] The value of the policy parameter is invalid, or one or more
        * of the parameters contained in param is outside the valid range for
        * the specified scheduling policy.
        */
        ERROR_SHALL(POSIX_SCHED_SETSCHEDULER, EINVAL, "sched_setscheduler.23.01",
                    (isValid_Policy(policy) == false) ||
                    (isValid_SchedParam(context, policy, process_state, param) == false))

        /*
        * The sched_setscheduler() function shall fail if:
        *
        * [EPERM] The requesting process does not have permission to set either
        * or both of the scheduling parameters or the scheduling policy of the
        * specified process.
        */
        ERROR_SHALL(POSIX_SCHED_SETSCHEDULER, EPERM, "sched_setscheduler.23.02", TODO_ERR(EPERM) )

        /*
        * The sched_setscheduler() function shall fail if:
        *
        * [ESRCH] No process can be found corresponding to that specified by
        * pid.
        */
        ERROR_SHALL(POSIX_SCHED_SETSCHEDULER, ESRCH, "sched_setscheduler.23.03", TODO_ERR(ESRCH) )

        ERROR_END()

        if((isValid_ReplPeriod_And_InitBudget(param) == false) &&
           (isDefined_SporadicServer(context) == true))
        {
            /*
             * The specified sched_ss_repl_period shall be greater than or
             * equal to the specified sched_ss_init_budget for the function to
             * succeed; if it is not, then the function shall fail.
             */
            REQ("sched_setscheduler.14",
                "repl_period shall be grater then init_budget",
                 sched_setscheduler_spec == -1);
        }

        if(((param->sched_ss_max_repl < 1) ||
           (param->sched_ss_max_repl > repl_max)) &&
           (isDefined_SporadicServer(context) == true))
        {
            /*
             * The value of sched_ss_max_repl shall be within the inclusive
             * range [1, {SS_REPL_MAX}] for the function to succeed; if not,
             * the function shall fail.
             */
            REQ("sched_setscheduler.15",
                "sched_ss_max_repl shall be within [1, {SS_REPL_MAX}]",
                 sched_setscheduler_spec == -1);
        }

        /*
         * The sched_setscheduler() function shall set the scheduling policy
         * and scheduling parameters of the process specified by pid to policy
         * and the parameters specified in the sched_param structure pointed to
         * by param, respectively.
         */
        REQ("sched_setscheduler.01", "", TODO_REQ());

        /*
         * If a process specified by pid exists, and if the calling process has
         * permission, the scheduling policy and scheduling parameters shall be
         * set for the process whose process ID is equal to pid.
         */
        REQ("sched_setscheduler.05", "", TODO_REQ());

        /*
         * If pid is zero, the scheduling policy and scheduling parameters
         * shall be set for the calling process.
         */
        REQ("sched_setscheduler.06", "", TODO_REQ());

        /*
         * The sched_setscheduler() function shall be considered successful if
         * it succeeds in setting the scheduling policy and scheduling
         * parameters of the process specified by pid to the values specified
         * by policy and the structure pointed to by param, respectively.
         */
        REQ("sched_setscheduler.10", "", TODO_REQ());

        /*
         * The conditions under which one process has the appropriate privilege
         * to change the scheduling parameters of another process are
         * implementation-defined.
         */
        REQ("sched_setscheduler.07", "", TODO_REQ());

        /*
         * Implementations may require that the requesting process have
         * permission to set its own scheduling parameters or those of another
         * process.
         */
        REQ("sched_setscheduler.08", "", TODO_REQ());

        /*
         * Additionally, implementation-defined restrictions may apply as to
         * the appropriate privileges required to set a process' own scheduling
         * policy, or another process' scheduling policy, to a particular
         * value.
         */
        REQ("sched_setscheduler.09", "", TODO_REQ());

        /*
         * The sched_ss_max_repl member of the param argument shall represent
         * the maximum number of replenishments that are allowed to be pending
         * simultaneously for the process scheduled under this scheduling
         * policy.
         */
        REQ("sched_setscheduler.13", "", TODO_REQ());

        /*
         * If the scheduling policy specified by policy is either SCHED_FIFO or
         * SCHED_RR, the sched_ss_low_priority, sched_ss_repl_period, and
         * sched_ss_init_budget members of the param argument shall have no
         * effect on the scheduling behavior.
         */
        REQ("sched_setscheduler.16", "", TODO_REQ());

        /*
         * The effect of this function on individual threads is dependent on
         * the scheduling contention scope of the threads:
         *
         * For threads with system scheduling contention scope, these functions
         * shall have no effect on their scheduling.
         */
        REQ("sched_setscheduler.17.01", "", TODO_REQ());

        /*
         * For threads with process scheduling contention scope, the threads'
         * scheduling policy and associated parameters shall not be affected.
         */
        REQ("sched_setscheduler.17.02.01", "", TODO_REQ());

        /*
         * However, the scheduling of these threads with respect to threads in
         * other processes may be dependent on the scheduling parameters of
         * their process, which are governed using these functions.
         */
        REQ("sched_setscheduler.17.02.02", "", TODO_REQ());

        /*
         * If an implementation supports a two-level scheduling model in which
         * library threads are multiplexed on top of several kernel-scheduled
         * entities, then the underlying kernel-scheduled entities for the
         * system contention scope threads shall not be affected by these
         * functions.
         */
        REQ("sched_setscheduler.18", "", TODO_REQ());

        /*
         * The underlying kernel-scheduled entities for the process contention
         * scope threads shall have their scheduling policy and associated
         * scheduling parameters changed to the values specified in policy and
         * param, respectively.
         */
        REQ("sched_setscheduler.19", "", TODO_REQ());

        /*
         * Kernel-scheduled entities for use by process contention scope
         * threads that are created after this call completes shall inherit
         * their scheduling policy and associated scheduling parameters from
         * the process.
         */
        REQ("sched_setscheduler.20", "", TODO_REQ());

        /*
         * This function is not atomic with respect to other threads in the
         * process. Threads may continue to execute while this function call is
         * in the process of changing the scheduling policy and associated
         * scheduling parameters for the underlying kernel-scheduled entities
         * used by the process contention scope threads.
         */
        REQ("sched_setscheduler.21", "", TODO_REQ());

        if(sched_setscheduler_spec != -1)
        {
            /*
             * Upon successful completion, the function shall return the former
             * scheduling policy of the specified process.
             */
            REQ("sched_setscheduler.22.01",
                "Shall return the former scheduling policy",
                 sched_setscheduler_spec == *former_policy);
        }

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    sched_yield - yield the processor

SYNOPSIS

    [PS|THR]  #include <sched.h>

    int sched_yield(void);

DESCRIPTION

    The sched_yield() function shall force the running thread to relinquish the
    processor until it again becomes the head of its thread list. It takes no
    arguments.

RETURN VALUE

    The sched_yield() function shall return 0 if it completes successfully;
    otherwise, it shall return a value of -1 and set errno to indicate the
    error.

ERRORS

    No errors are defined.
*/
specification
IntT sched_yield_spec( CallContext context, ErrorCode * errno )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { YieldProcessor, "Yield the processor" };
    }
    post
    {
        /*
         * otherwise, it shall return a value of -1 and set
         * errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_SCHED_YIELD, "sched_yield.02.02", sched_yield_spec == -1 && *errno != SUT_EOK, *errno )

            /* No errors are defined. */

        ERROR_END()

        /*
         * The sched_yield() function shall return 0 if it completes
         * successfully
         */
        REQ("sched_yield.02.01",
            "sched_yield() shall return 0 if it completes successfully",
             sched_yield_spec == 0);

        /*
         * The sched_yield() function shall force the running thread to
         * relinquish the processor until it again becomes the head of its
         * thread list.
         */
        REQ("sched_yield.01", "", TODO_REQ());

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

ProcessState * findProcessState_PidT(PidT pid_t)
{
    int i, j, size1, size2;
    SystemState * systemState;
    ProcessState* processState;
    ProcessId process_id;

    size1 = size_Map(systems);
    for( i = 0; i < size1; i++ )
    {
        systemState = get_Map( systems, key_Map( systems, i ) );
        size2 = size_Map(systemState->processes);
        for( j = 0; j < size2; j++ )
        {
            processState = get_Map( systemState->processes, key_Map( systemState->processes, j ) );
            process_id = processState->processid;
            if( process_id.process == pid_t)
                return processState;
        }
    }
    return NULL;
}

BoolT isValid_Policy(IntT policy)
{
    return (policy == SUT_SCHED_OTHER) || (policy == SUT_SCHED_FIFO) ||
           (policy == SUT_SCHED_RR) || (policy == SUT_SCHED_SPORADIC);
}

BoolT isValid_Priority(CallContext context, IntT policy, ProcessState* process_state, ShedParam* param)
{
    Integer* priority_min;
    Integer* priority_max;

    switch(policy)
    {
    case SUT_SCHED_OTHER:
        priority_min = get_Map(process_state->priority_min, create_Integer(SUT_SCHED_OTHER));
        priority_max = get_Map(process_state->priority_max, create_Integer(SUT_SCHED_OTHER));
        return (param->sched_priority <= *priority_max) &&
               (param->sched_priority >= *priority_min);
    case SUT_SCHED_FIFO:
        priority_min = get_Map(process_state->priority_min, create_Integer(SUT_SCHED_FIFO));
        priority_max = get_Map(process_state->priority_max, create_Integer(SUT_SCHED_FIFO));
        return (param->sched_priority <= *priority_max) &&
               (param->sched_priority >= *priority_min);
    case SUT_SCHED_RR:
        priority_min = get_Map(process_state->priority_min, create_Integer(SUT_SCHED_RR));
        priority_max = get_Map(process_state->priority_max, create_Integer(SUT_SCHED_RR));
        return (param->sched_priority <= *priority_max) &&
               (param->sched_priority >= *priority_min);
    case SUT_SCHED_SPORADIC:
        if(isDefined_SporadicServer(context))
        {
            priority_min = get_Map(process_state->priority_min, create_Integer(SUT_SCHED_SPORADIC));
            priority_max = get_Map(process_state->priority_max, create_Integer(SUT_SCHED_SPORADIC));
            return (param->sched_priority <= *priority_max) &&
                   (param->sched_priority >= *priority_min);
        }
        else
            return true;
    default:
        return true;
    }
}

BoolT isValid_MaxRepl(CallContext context, IntT max_repl)
{
    LongT ReplMax = getSystemConfigurationValue(context, SUT_SS_REPL_MAX);
    return (1 <= max_repl) && (max_repl <= ReplMax);
}

BoolT isValid_LowPriority(CallContext context, IntT policy, ProcessState* process_state, ShedParam* param)
{
    Integer* priority_min;
    Integer* priority_max;
    priority_min = get_Map(process_state->priority_min, create_Integer(SUT_SCHED_SPORADIC));
    priority_max = get_Map(process_state->priority_max, create_Integer(SUT_SCHED_SPORADIC));
    return (param->sched_ss_low_priority <= *priority_max) &&
           (param->sched_ss_low_priority >= *priority_min);
}

BoolT isValid_ReplPeriod_And_InitBudget(ShedParam* param)
{
    LLongT delta_sec, delta_nsec;
    delta_sec = (LLongT)param->sched_ss_repl_period->sec - (LLongT)param->sched_ss_init_budget->sec;
    delta_nsec = (LLongT)param->sched_ss_repl_period->nsec - (LLongT)param->sched_ss_init_budget->nsec;
    if(delta_sec + delta_nsec/1000000000 > 0)
    {
        return true;
    }
    else if(delta_sec + delta_nsec/1000000000 == 0)
    {
        if(delta_nsec >= 0)
            return true;
        else
            return false;
    }
    else
    {
        return false;
    }
}

BoolT isValid_SchedParam(CallContext context, IntT policy, ProcessState* process_state, ShedParam* param)
{
    if(isDefined_SporadicServer(context) == true)
        return isValid_Priority(context, policy, process_state, param) &&
               isValid_ReplPeriod_And_InitBudget(param) &&
               isValid_MaxRepl(context, param->sched_ss_max_repl) &&
               isValid_LowPriority(context, policy, process_state, param);
    else
        return isValid_Priority(context, policy, process_state, param);
}

BoolT compareSchedParam(CallContext context, ShedParam* param1, ShedParam* param2)
{
    if(isDefined_SporadicServer(context) == true)
        return (param1->sched_ss_init_budget->sec == param2->sched_ss_init_budget->sec) &&
               (param1->sched_ss_init_budget->nsec == param2->sched_ss_init_budget->nsec) &&
               (param1->sched_ss_repl_period->sec == param2->sched_ss_repl_period->sec) &&
               (param1->sched_ss_repl_period->nsec == param2->sched_ss_repl_period->nsec) &&
               (param1->sched_priority == param2->sched_priority) &&
               (param1->sched_ss_low_priority == param2->sched_ss_low_priority) &&
               (param1->sched_ss_max_repl == param2->sched_ss_max_repl);
    else
        return (param1->sched_priority == param2->sched_priority);
}

BoolT isDefined_SporadicServer(CallContext context)
{
    LongT thread_sporadic_server = getSystemConfigurationValue(context, SUT_SC_THREAD_SPORADIC_SERVER);
    LongT sporadic_server = getSystemConfigurationValue(context, SUT_SC_SPORADIC_SERVER);
    return ( (thread_sporadic_server != -1) || (sporadic_server != -1) );
}

