/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "config/interpretation.seh"
#include "process/fenv/fenv_config.h"
#include "process/fenv/fenv_model.seh"
#include "process/process/process_model.seh"

#pragma SEC subsystem fenv "process.fenv"

/* 
   The group of functions 'process.fenv' consists of: 
       feclearexcept    [SUSv3]
       fegetenv         [SUSv3]
       fegetexceptflag  [SUSv3]
       fegetround       [SUSv3]
       feholdexcept     [SUSv3]
       feraiseexcept    [SUSv3]
       fesetenv         [SUSv3]
       fesetexceptflag  [SUSv3]
       fesetround       [SUSv3]
       fetestexcept     [SUSv3]
       feupdateenv      [SUSv3]
       matherr          [ISOC99]
 */

/*****************************************************************************/
/**                          Interface Functions                            **/
/*****************************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    feclearexcept - clear floating-point exception

SYNOPSIS

    #include <fenv.h>

    int feclearexcept(int excepts);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard.

    The feclearexcept() function shall attempt to clear the supported
    floating-point exceptions represented by excepts.

RETURN VALUE

    If the argument is zero or if all the specified exceptions were
    successfully cleared, feclearexcept() shall return zero. Otherwise, it
    shall return a non-zero value.

ERRORS

    No errors are defined.
*/
specification
IntT feclearexcept_spec(CallContext context, FEnvExceptions excepts)
{
    pre
    {
        return true;
    }
    coverage C
    {
        FENV_EXCEPTIONS_COVERAGE(feclearexcept, "feclearexcept()", excepts);
    }
    post
    {
        FEnvT *post_fenv = getFloatingPointEnvironment(context);

        /*
         * The feclearexcept() function shall attempt to clear the supported
         * floating-point exceptions represented by excepts.
         */
        if(isClear_FEnvExceptions(excepts))
        {
            /*
             * If the argument is zero or if all the specified exceptions were
             * successfully cleared, feclearexcept() shall return zero.
             */
            REQ("?feclearexcept.01;feclearexcept.02", "feclearexcept() shall return zero",
                feclearexcept_spec == 0);
        }
        else if(feclearexcept_spec == 0)
        {
            /*
             * If the argument is zero or if all the specified exceptions were
             * successfully cleared, feclearexcept() shall return zero.
             */
            REQ("?feclearexcept.01;feclearexcept.02",
                "feclearexcept() shall clear FE_DIVBYZERO",
            (
                excepts.divbyzero => (post_fenv->excepts->divbyzero == False_Bool3)
            ));

            REQ("?feclearexcept.01;feclearexcept.02",
                "feclearexcept() shall clear FE_INEXACT",
            (
                excepts.inexact => (post_fenv->excepts->inexact == False_Bool3)
            ));

            REQ("?feclearexcept.01;feclearexcept.02",
                "feclearexcept() shall clear FE_INVALID",
            (
                excepts.invalid => (post_fenv->excepts->invalid == False_Bool3)
            ));

            REQ("?feclearexcept.01;feclearexcept.02",
                "feclearexcept() shall clear FE_OVERFLOW",
            (
                excepts.overflow => (post_fenv->excepts->overflow == False_Bool3)
            ));

            REQ("?feclearexcept.01;feclearexcept.02",
                "feclearexcept() shall clear FE_UNDERFLOW",
            (
                excepts.underflow => (post_fenv->excepts->underflow == False_Bool3)
            ));
        }
        else
        {
            /*
             * Otherwise, it shall return a non-zero value.
             */
            REQ("?feclearexcept.01;feclearexcept.03", "feclearexcept() shall return non-zero",
                feclearexcept_spec != 0);
        }
    
        return true;
    }
}

void onFEClearExcept(CallContext context, FEnvExceptions excepts, IntT feclearexcept_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);

    assertion(fenv != NULL, "onFEClearExcept: fenv is NULL");

    if(excepts.divbyzero && fenv->excepts->divbyzero != False_Bool3)
    {
        fenv->excepts->divbyzero = feclearexcept_spec == 0 ? False_Bool3 : Unknown_Bool3;
    }
    if(excepts.inexact && fenv->excepts->inexact != False_Bool3)
    {
        fenv->excepts->inexact = feclearexcept_spec == 0 ? False_Bool3 : Unknown_Bool3;
    }
    if(excepts.invalid && fenv->excepts->invalid != False_Bool3)
    {
        fenv->excepts->invalid = feclearexcept_spec == 0 ? False_Bool3 : Unknown_Bool3;
    }
    if(excepts.overflow && fenv->excepts->overflow != False_Bool3)
    {
        fenv->excepts->overflow = feclearexcept_spec == 0 ? False_Bool3 : Unknown_Bool3;
    }
    if(excepts.underflow && fenv->excepts->underflow != False_Bool3)
    {
        fenv->excepts->underflow = feclearexcept_spec == 0 ? False_Bool3 : Unknown_Bool3;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    fegetenv, fesetenv - get and set current floating-point environment

SYNOPSIS

    #include <fenv.h>

    int fegetenv(fenv_t *envp);
    int fesetenv(const fenv_t *envp);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The fegetenv() function shall attempt to store the current floating-point
    environment in the object pointed to by envp.

    The fesetenv() function shall attempt to establish the floating-point
    environment represented by the object pointed to by envp. The argument envp
    shall point to an object set by a call to fegetenv() or feholdexcept(), or
    equal a floating-point environment macro. The fesetenv() function does not
    raise floating-point exceptions, but only installs the state of the
    floating-point status flags represented through its argument.

RETURN VALUE

    If the representation was successfully stored, fegetenv() shall return
    zero. Otherwise, it shall return a non-zero value. If the environment was
    successfully established, fesetenv() shall return zero. Otherwise, it shall
    return a non-zero value.

ERRORS

    No errors are defined.
*/
specification
IntT fegetenv_spec(CallContext context, FEnvTPtr envp)
{
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "envp is valid", isValidPointer(context, envp));

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The fegetenv() function shall attempt to store the current
         * floating-point environment in the object pointed to by envp.
         */
        if(fegetenv_spec == 0)
        {
            FEnvT *dst_fenv = getFEnvT(envp);

            /*
             * If the representation was successfully stored, fegetenv() shall
             * return zero.
             */
            REQ("?fegetenv.01;fegetenv.02", "fegetenv() shall store fenv",
                equals_FEnvT(pre_fenv, dst_fenv) != False_Bool3);
        }
        else
        {
            /*
             * Otherwise, it shall return a non-zero value.
             */
            REQ("?fegetenv.01;fegetenv.03", "fegetenv() shall return non-zero",
                fegetenv_spec != 0);
        }

        return true;
    }
}

void onFEGetEnv(CallContext context, FEnvTPtr envp, IntT fegetenv_spec)
{
    FEnvT *fenv = clone(getFloatingPointEnvironment(context));
    FEnvT *dst_fenv = getFEnvT(envp);

    assertion(fenv != NULL, "onFEGetEnv: fenv is NULL");

    if(fegetenv_spec == 0)
    {
        fenv->address = envp;

        if(dst_fenv == NULL)
        {
            registerObjectInMemory(envp, sizeof_Type(context, "fenv_t"), fenv);
        }
        else
        {
            copy(fenv, dst_fenv);
        }
    }
    else
    {
        if(dst_fenv != NULL)
        {
            dst_fenv->excepts->divbyzero = Unknown_Bool3;
            dst_fenv->excepts->inexact   = Unknown_Bool3;
            dst_fenv->excepts->invalid   = Unknown_Bool3;
            dst_fenv->excepts->overflow  = Unknown_Bool3;
            dst_fenv->excepts->underflow = Unknown_Bool3;

            dst_fenv->round = NULL;

            dst_fenv->nonstop = Unknown_Bool3;
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    fegetexceptflag, fesetexceptflag - get and set floating-point status flags

SYNOPSIS

    #include <fenv.h>

    int fegetexceptflag(fexcept_t *flagp, int excepts);
    int fesetexceptflag(const fexcept_t *flagp, int excepts);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The fegetexceptflag() function shall attempt to store an
    implementation-defined representation of the states of the floating-point
    status flags indicated by the argument excepts in the object pointed to by
    the argument flagp.

    The fesetexceptflag() function shall attempt to set the floating-point
    status flags indicated by the argument excepts to the states stored in the
    object pointed to by flagp. The value pointed to by flagp shall have been
    set by a previous call to fegetexceptflag() whose second argument
    represented at least those floating-point exceptions represented by the
    argument excepts. This function does not raise floating-point exceptions,
    but only sets the state of the flags.

RETURN VALUE

    If the representation was successfully stored, fegetexceptflag() shall
    return zero. Otherwise, it shall return a non-zero value. If the excepts
    argument is zero or if all the specified exceptions were successfully set,
    fesetexceptflag() shall return zero. Otherwise, it shall return a non-zero
    value.

ERRORS

    No errors are defined.
*/
specification
IntT fegetexceptflag_spec(CallContext context, FExceptTPtr flagp, FEnvExceptions excepts)
{
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "flagp is valid", isValidPointer(context, flagp));

        return true;
    }
    coverage C
    {
        FENV_EXCEPTIONS_COVERAGE(fegetexceptflag, "fegetexceptflag()", excepts);
    }
    post
    {
        /*
         * The fegetexceptflag() function shall attempt to store an
         * implementation-defined representation of the states of the
         * floating-point status flags indicated by the argument excepts in the
         * object pointed to by the argument flagp.
         */
        if(fegetexceptflag_spec == 0)
        {
            FExceptT *fexcepts = getFExceptT(flagp);

            /*
             * If the representation was successfully stored, fegetexceptflag()
             * shall return zero.
             */
            REQ("?fegetexceptflag.01;fegetexceptflag.02",
                "fegetexceptflag shall store FE_DIVBYZERO",
            (
                excepts.divbyzero => (fexcepts->divbyzero == pre_fenv->excepts->divbyzero)
            ));

            REQ("?fegetexceptflag.01;fegetexceptflag.02",
                "fegetexceptflag shall store FE_INEXACT",
            (
                excepts.inexact => (fexcepts->inexact == pre_fenv->excepts->inexact)
            ));

            REQ("?fegetexceptflag.01;fegetexceptflag.02",
                "fegetexceptflag shall store FE_INVALID",
            (
                excepts.invalid => (fexcepts->invalid == pre_fenv->excepts->invalid)
            ));

            REQ("?fegetexceptflag.01;fegetexceptflag.02",
                "fegetexceptflag shall store FE_OVERFLOW",
            (
                excepts.overflow => (fexcepts->overflow == pre_fenv->excepts->overflow)
            ));

            REQ("?fegetexceptflag.01;fegetexceptflag.02",
                "fegetexceptflag shall store FE_UNDERFLOW",
            (
                excepts.underflow => (fexcepts->underflow == pre_fenv->excepts->underflow)
            ));
        }
        else
        {
            /*
             * Otherwise, it shall return a non-zero value.
             */
            REQ("?fegetexceptflag.01;fegetexceptflag.02", "fegetexceptflag shall return non-zero",
                fegetexceptflag_spec != 0);
        }

        return true;
    }
}

void onFEGetExceptFlag(CallContext context, FExceptTPtr flagp, FEnvExceptions excepts,
                       IntT fegetexceptflag_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);
    FExceptT *dst_fexcepts = getFExceptT(flagp);

    assertion(fenv != NULL, "onFEGetExceptFlag: fenv is NULL");

    if(fegetexceptflag_spec == 0)
    {
        FExceptT *src_fexcepts = default_FExceptT(flagp);

        src_fexcepts->excepts = excepts;

        src_fexcepts->divbyzero = (excepts.divbyzero ? fenv->excepts->divbyzero : False_Bool3);
        src_fexcepts->inexact   = (excepts.inexact   ? fenv->excepts->inexact   : False_Bool3);
        src_fexcepts->invalid   = (excepts.invalid   ? fenv->excepts->invalid   : False_Bool3);
        src_fexcepts->overflow  = (excepts.overflow  ? fenv->excepts->overflow  : False_Bool3);
        src_fexcepts->underflow = (excepts.underflow ? fenv->excepts->underflow : False_Bool3);

        if(dst_fexcepts == NULL)
        {
            registerObjectInMemory(flagp, sizeof_Type(context, "fexcept_t"), src_fexcepts);
        }
        else
        {
            copy(src_fexcepts, dst_fexcepts);
        }
    }
    else
    {
        if(dst_fexcepts != NULL)
        {
            dst_fexcepts->divbyzero = Unknown_Bool3;
            dst_fexcepts->inexact   = Unknown_Bool3;
            dst_fexcepts->invalid   = Unknown_Bool3;
            dst_fexcepts->overflow  = Unknown_Bool3;
            dst_fexcepts->underflow = Unknown_Bool3;
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    fegetround, fesetround - get and set current rounding direction

SYNOPSIS

    #include <fenv.h>

    int fegetround(void);
    int fesetround(int round);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard.

    The fegetround() function shall get the current rounding direction.

    The fesetround() function shall establish the rounding direction
    represented by its argument round. If the argument is not equal to the
    value of a rounding direction macro, the rounding direction is not changed.

RETURN VALUE

    The fegetround() function shall return the value of the rounding direction
    macro representing the current rounding direction or a negative value if
    there is no such rounding direction macro or the current rounding direction
    is not determinable.

    The fesetround() function shall return a zero value if and only if the
    requested rounding direction was established.

ERRORS

    No errors are defined.
*/
specification
IntT fegetround_spec(CallContext context)
{
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);

    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        if(pre_fenv->round != NULL)
        {
            if(isKnown_FEnvRoundingDirection(*pre_fenv->round))
            {
                /*
                 * The fegetround() function shall return the value of the
                 * rounding direction macro representing the current rounding
                 * direction
                 */
                REQ("fegetround.01.01", "fegetround() shall return the rounding direction",
                    fegetround_spec == *pre_fenv->round);
            }
            else
            {
                /*
                 * or a negative value if there is no such rounding direction
                 * macro or the current rounding direction is not determinable.
                 */
                REQ("fegetround.01.02", "fegetround() shall return a negative value",
                    fegetround_spec < 0);
            }
        }
        else
        {
            /*
             * The fegetround() function shall get the current rounding
             * direction.
             */
            REQ("fegetround.01.01;fegetround.01.02",
                "fegetround() shall return either a known or a negative value",
            (
                isKnown_FEnvRoundingDirection(fegetround_spec) || fegetround_spec < 0
            ));
        }
        
        return true;
    }
}

void onFEGetRound(CallContext context, IntT fegetround_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);

    assertion(fenv != NULL, "onFEGetRound: fenv is NULL");

    if(fegetround_spec >= 0)
    {
        if(fenv->round == NULL)
        {
            fenv->round = create_IntTObj(fegetround_spec);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    feholdexcept - save current floating-point environment

SYNOPSIS

    #include <fenv.h>

    int feholdexcept(fenv_t *envp);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The feholdexcept() function shall save the current floating-point
    environment in the object pointed to by envp, clear the floating-point
    status flags, and then install a non-stop (continue on floating-point
    exceptions) mode, if available, for all floating-point exceptions.

RETURN VALUE

    The feholdexcept() function shall return zero if and only if non-stop
    floating-point exception handling was successfully installed.

ERRORS

    No errors are defined.
*/
specification
IntT feholdexcept_spec(CallContext context, FEnvTPtr envp)
{
    FEnvT *pre_fenv = clone(getFloatingPointEnvironment(context));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "envp is valid", isValidPointer(context, envp));

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The feholdexcept() function shall return zero if and only if
         * non-stop floating-point exception handling was successfully
         * installed.
         */
        if(feholdexcept_spec == 0)
        {
            FEnvT *dst_fenv  = getFEnvT(envp);
            FEnvT *post_fenv = getFloatingPointEnvironment(context);

            /*
             * The feholdexcept() function shall save the current
             * floating-point environment in the object pointed to by envp
             */
            REQ("?feholdexcept.01.01;feholdexcept.02", "feholdexcept() shall save fenv",
                equals_FEnvT(pre_fenv, dst_fenv) != False_Bool3);

            /*
             * clear the floating-point status flags
             */
            REQ("?feholdexcept.01.02;feholdexcept.02",
                "feholdexcept() shall clear FE_DIVBYZERO",
            (
                post_fenv->excepts->divbyzero == False_Bool3
            ));

            REQ("?feholdexcept.01.02;feholdexcept.02",
                "feholdexcept() shall clear FE_INEXACT",
            (
                post_fenv->excepts->inexact == False_Bool3
            ));

            REQ("?feholdexcept.01.02;feholdexcept.02",
                "feholdexcept() shall clear FE_INVALID",
            (
                post_fenv->excepts->invalid == False_Bool3
            ));

            REQ("?feholdexcept.01.02;feholdexcept.02",
                "feholdexcept() shall clear FE_OVERFLOW",
            (
                post_fenv->excepts->overflow == False_Bool3
            ));

            REQ("?feholdexcept.01.02;feholdexcept.02",
                "feholdexcept() shall clear FE_UNDERFLOW",
            (
                post_fenv->excepts->underflow == False_Bool3
            ));

            /*
             * and then install a non-stop (continue on floating-point
             * exceptions) mode, if available, for all floating-point
             * exceptions.
             */
            REQ("?feholdexcept.01.03", "feholdexcept() shall install non-stop mode",
                post_fenv->nonstop == True_Bool3);
        }
        else
        {
            REQ("?feholdexcept.02", "feholdexcept() shall return non-zero",
                feholdexcept_spec != 0);
        }

        return true;
    }
}

void onFEHoldExcept(CallContext context, FEnvTPtr envp, IntT feholdexcept_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);
    FEnvT *dst_fenv = getFEnvT(envp);

    assertion(fenv != NULL, "onFEHoldExcept: fenv is NULL");

    if(feholdexcept_spec == 0)
    {
        FEnvT *src_fenv = clone(fenv);

        src_fenv->address = envp;

        traceUserInfo("HOLD");

        if(dst_fenv == NULL)
        {
            registerObjectInMemory(envp, sizeof_Type(context, "fenv_t"), src_fenv);
        }
        else
        {
            copy(src_fenv, dst_fenv);
        }

        fenv->excepts->divbyzero = False_Bool3;
        fenv->excepts->inexact   = False_Bool3;
        fenv->excepts->invalid   = False_Bool3;
        fenv->excepts->overflow  = False_Bool3;
        fenv->excepts->underflow = False_Bool3;

        fenv->nonstop = True_Bool3;
    }
    else
    {
        if(dst_fenv != NULL)
        {
            fenv->excepts->divbyzero = Unknown_Bool3;
            fenv->excepts->inexact   = Unknown_Bool3;
            fenv->excepts->invalid   = Unknown_Bool3;
            fenv->excepts->overflow  = Unknown_Bool3;
            fenv->excepts->underflow = Unknown_Bool3;

            fenv->round = NULL;

            fenv->nonstop = Unknown_Bool3;
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    feraiseexcept - raise floating-point exception

SYNOPSIS

    #include <fenv.h>

    int feraiseexcept(int excepts);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The feraiseexcept() function shall attempt to raise the supported
    floating-point exceptions represented by the argument excepts. The order in
    which these floating-point exceptions are raised is unspecified. Whether
    the feraiseexcept() function additionally raises the inexact floating-point
    exception whenever it raises the overflow or underflow floating-point
    exception is implementation-defined.

RETURN VALUE

    If the argument is zero or if all the specified exceptions were
    successfully raised, feraiseexcept() shall return zero. Otherwise, it shall
    return a non-zero value.

ERRORS

    No errors are defined.
*/
specification
IntT feraiseexcept_spec(CallContext context, FEnvExceptions excepts)
{
    FEnvT *pre_fenv = clone(getFloatingPointEnvironment(context));

    pre
    {
        return true;
    }
    coverage C
    {
        FENV_EXCEPTIONS_COVERAGE(feraiseexcept, "feraiseexcept()", excepts);
    }
    post
    {
        /*
         * The feraiseexcept() function shall attempt to raise the supported
         * floating-point exceptions represented by the argument excepts.
         */
        if(feraiseexcept_spec == 0)
        {
            FEnvT *post_fenv = getFloatingPointEnvironment(context);

            /*
             * If the argument is zero or if all the specified exceptions were
             * successfully raised, feraiseexcept() shall return zero.
             */
            REQ("?feraiseexcept.01;feraiseexcept.04",
                "feraiseexcept() shall raise FE_DIVBYZERO",
            (
                excepts.divbyzero => (post_fenv->excepts->divbyzero == True_Bool3)
            ));

            REQ("?feraiseexcept.01;feraiseexcept.04",
                "feraiseexcept() shall raise FE_INEXACT",
            (
                excepts.inexact => (post_fenv->excepts->inexact == True_Bool3)
            ));

            REQ("?feraiseexcept.01;feraiseexcept.04",
                "feraiseexcept() shall raise FE_INVALID",
            (
                excepts.invalid => (post_fenv->excepts->invalid == True_Bool3)
            ));

            REQ("?feraiseexcept.01;feraiseexcept.04",
                "feraiseexcept() shall raise FE_OVERFLOW",
            (
                excepts.overflow => (post_fenv->excepts->overflow == True_Bool3)
            ));

            REQ("?feraiseexcept.01;feraiseexcept.04",
                "feraiseexcept() shall raise FE_UNDERFLOW",
            (
                excepts.underflow => (post_fenv->excepts->underflow == True_Bool3)
            ));

            /*
             * The order in which these floating-point exceptions are raised is
             * unspecified.
             */
            REQ("feraiseexcept.01;feraiseexcept.02",
                "The order of exceptions is unspecified", true);

            if(excepts.overflow && !excepts.inexact && pre_fenv->excepts->inexact != True_Bool3)
            {
                /*
                 * Whether the feraiseexcept() function additionally raises the
                 * inexact floating-point exception whenever it raises the
                 * overflow or underflow floating-point exception is
                 * implementation-defined.
                 */
                if(POSIX_PROCESS_FENV_OVERFLOW_RAISING_BEHAVIOUR ==
                    POSIX_PROCESS_FENV_OVERFLOW_SHALL_RAISE_INEXACT
                   )
                {
                    REQ("?feraiseexcept.01;feraiseexcept.03",
                        "feraiseexcept() shall raise FE_INEXACT [FE_OVERFLOW]",
                    (
                        post_fenv->excepts->inexact == True_Bool3
                    ));
                }
                else if(POSIX_PROCESS_FENV_OVERFLOW_RAISING_BEHAVIOUR ==
                         POSIX_PROCESS_FENV_OVERFLOW_SHALL_NOT_RAISE_INEXACT
                        )
                {
                    REQ("?feraiseexcept.01;feraiseexcept.03",
                        "feraiseexcept() shall not raise FE_INEXACT [FE_OVERFLOW]",
                    (
                        post_fenv->excepts->inexact != True_Bool3
                    ));
                }
            }

            if(excepts.underflow && !excepts.inexact && pre_fenv->excepts->inexact != True_Bool3)
            {
                /*
                 * Whether the feraiseexcept() function additionally raises the
                 * inexact floating-point exception whenever it raises the
                 * overflow or underflow floating-point exception is
                 * implementation-defined.
                 */
                if( POSIX_PROCESS_FENV_UNDERFLOW_RAISING_BEHAVIOUR ==
                     POSIX_PROCESS_FENV_UNDERFLOW_SHALL_RAISE_INEXACT
                    )
                {
                    REQ("?feraiseexcept.01;feraiseexcept.03",
                        "feraiseexcept() shall raise FE_INEXACT [FE_UNDERFLOW]",
                    (
                        post_fenv->excepts->inexact == True_Bool3
                    ));
                }
                else if( POSIX_PROCESS_FENV_UNDERFLOW_RAISING_BEHAVIOUR ==
                          POSIX_PROCESS_FENV_UNDERFLOW_SHALL_NOT_RAISE_INEXACT
                        )
                {
                    REQ("?feraiseexcept.01;feraiseexcept.03",
                        "feraiseexcept() shall raise FE_INEXACT [FE_UNDERFLOW]",
                    (
                        post_fenv->excepts->inexact != True_Bool3
                    ));
                }
            }
        }
        else
        {
            /*
             * Otherwise, it shall return a non-zero value.
             */
            REQ("feraiseexcept.01;feraiseexcept.05", "feraiseexcept() shall return non-zero",
                feraiseexcept_spec != 0);
        }

        return true;
    }
}

void onFERaiseExcept(CallContext context, FEnvExceptions excepts, IntT feraiseexcept_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);

    assertion(fenv != NULL, "onFERaiseExcept: fenv is NULL");

    if(excepts.divbyzero && fenv->excepts->divbyzero != True_Bool3)
    {
        fenv->excepts->divbyzero = (feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3);
    }
    if(excepts.inexact && fenv->excepts->inexact != True_Bool3)
    {
        fenv->excepts->inexact = (feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3);
    }
    if(excepts.invalid && fenv->excepts->invalid != True_Bool3)
    {
        fenv->excepts->invalid = (feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3);
    }
    if(excepts.overflow && fenv->excepts->overflow != True_Bool3)
    {
        fenv->excepts->overflow = (feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3);
    }
    if(excepts.underflow && fenv->excepts->underflow != True_Bool3)
    {
        fenv->excepts->underflow = (feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3);
    }

    if(excepts.overflow && !excepts.inexact && fenv->excepts->inexact != True_Bool3)
    {
        if(POSIX_PROCESS_FENV_OVERFLOW_RAISING_BEHAVIOUR ==
            POSIX_PROCESS_FENV_OVERFLOW_SHALL_RAISE_INEXACT
           )
        {
            fenv->excepts->inexact = feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3;        
        }
        else if(POSIX_PROCESS_FENV_OVERFLOW_RAISING_BEHAVIOUR ==
                 POSIX_PROCESS_FENV_OVERFLOW_MAY_RAISE_INEXACT
                )
        {
            fenv->excepts->inexact = Unknown_Bool3;        
        }
    }

    if(excepts.underflow && !excepts.inexact && fenv->excepts->inexact != True_Bool3)
    {
        if(POSIX_PROCESS_FENV_UNDERFLOW_RAISING_BEHAVIOUR ==
            POSIX_PROCESS_FENV_UNDERFLOW_SHALL_RAISE_INEXACT
           )
        {
            fenv->excepts->inexact = (feraiseexcept_spec == 0 ? True_Bool3 : Unknown_Bool3);
        }
        else if(POSIX_PROCESS_FENV_OVERFLOW_RAISING_BEHAVIOUR ==
                 POSIX_PROCESS_FENV_OVERFLOW_MAY_RAISE_INEXACT
                )
        {
            fenv->excepts->inexact = Unknown_Bool3;        
        }
    }
}

specification
IntT fesetenv_spec(CallContext context, FEnvTPtr envp)
{
    FEnvT *src_fenv = getFEnvT(envp);
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);
    FEnvTPtr default_fenvp = getDefaultFloatingPointEnvironment(context);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "envp is valid", isValidPointer(context, envp));

        /*
         * The argument envp shall point to an object set by a call to
         * fegetenv() or feholdexcept(), or equal a floating-point environment
         * macro.
         */
        REQ("app.fesetenv.01", "The envp shall be correct",
        (
            equals_VoidTPtr(envp, default_fenvp) || src_fenv != NULL
        ));

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The fesetenv() function shall attempt to establish the
         * floating-point environment represented by the object pointed to by
         * envp.
         */
        if(fesetenv_spec == 0)
        {
            FEnvT *post_fenv = getFloatingPointEnvironment(context);

            /*
             * The fesetenv() function does not raise floating-point
             * exceptions, but only installs the state of the floating-point
             * status flags represented through its argument.
             */
            REQ("fesetenv.01;fesetenv.02", "fesetenv() shall not raise exceptions", true);

            /*
             * If the environment was successfully established, fesetenv()
             * shall return zero.
             */
            REQ("?fesetenv.01;fesetenv.03", "fesetenv() shall set fenv",
                equals_FEnvT(post_fenv, src_fenv) != False_Bool3);
        }
        else
        {
            /*
             * Otherwise, it shall return a non-zero value.
             */
            REQ("?fesetenv.01;fesetenv.04", "fesetenv() shall return non-zero",
                fesetenv_spec != 0);
        }

        return true;
    }
}

void onFESetEnv(CallContext context, FEnvTPtr envp, IntT fesetenv_spec)
{
    FEnvT *src_fenv = getFEnvT(envp);
    FEnvT *dst_fenv = getFloatingPointEnvironment(context);

    assertion(dst_fenv != NULL, "onFESetEnv: dst_fenv is NULL");

    if(fesetenv_spec == 0 && src_fenv != NULL)
    {
        dst_fenv->excepts->divbyzero = src_fenv->excepts->divbyzero;
        dst_fenv->excepts->inexact   = src_fenv->excepts->inexact;
        dst_fenv->excepts->invalid   = src_fenv->excepts->invalid;
        dst_fenv->excepts->overflow  = src_fenv->excepts->overflow;
        dst_fenv->excepts->underflow = src_fenv->excepts->underflow;

        dst_fenv->round = clone(src_fenv->round);

        dst_fenv->nonstop = src_fenv->nonstop;
    }
    else
    {
        dst_fenv->excepts->divbyzero = Unknown_Bool3;
        dst_fenv->excepts->inexact   = Unknown_Bool3;
        dst_fenv->excepts->invalid   = Unknown_Bool3;
        dst_fenv->excepts->overflow  = Unknown_Bool3;
        dst_fenv->excepts->underflow = Unknown_Bool3;

        dst_fenv->round = NULL;

        dst_fenv->nonstop = Unknown_Bool3;
    }
}

specification
IntT fesetexceptflag_spec(CallContext context, FExceptTPtr flagp, FEnvExceptions excepts)
{
    FExceptT *fexcepts = getFExceptT(flagp);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "flagp is valid", isValidPointer(context, flagp));

        /*
         * The value pointed to by flagp shall have been set by a previous call
         * to fegetexceptflag() whose second argument represented at least
         * those floating-point exceptions represented by the argument excepts.
         */
        REQ("app.fesetexceptflag.01", "flagp shall be correct",
        (
            fexcepts != NULL && isSubsetOf_FEnvExceptions(fexcepts->excepts, excepts)
        ));

        return true;
    }
    coverage C
    {
        FENV_EXCEPTIONS_COVERAGE(fesetexceptflag, "fesetexceptflag()", excepts);
    }
    post
    {
        /*
         * The fesetexceptflag() function shall attempt to set the floating-point status
         * flags indicated by the argument excepts to the states stored in the object
         * pointed to by flagp.
         */
        if(fesetexceptflag_spec == 0)
        {
            FEnvT *post_fenv = getFloatingPointEnvironment(context);

            /*
             * This function does not raise floating-point exceptions, but only
             * sets the state of the flags.
             */
            REQ("fesetexceptflag.01;fesetexceptflag.02",
                "fesetexceptflag() shall not raise exceptions", true);

            /*
             * If the excepts argument is zero or if all the specified
             * exceptions were successfully set, fesetexceptflag() shall return
             * zero.
             */
            REQ("?fesetexceptflag.01;fesetexceptflag.03",
                "fesetexceptflag() shall set FE_DIVBYZERO",
            (
                excepts.divbyzero => (fexcepts->divbyzero == post_fenv->excepts->divbyzero)
            ));

            REQ("?fesetexceptflag.01;fesetexceptflag.03",
                "fesetexceptflag() shall set FE_INEXACT",
            (
                excepts.inexact => (fexcepts->inexact == post_fenv->excepts->inexact)
            ));

            REQ("?fesetexceptflag.01;fesetexceptflag.03",
                "fesetexceptflag() shall set FE_INVALID",
            (
                excepts.invalid => (fexcepts->invalid == post_fenv->excepts->invalid)
            ));

            REQ("?fesetexceptflag.01;fesetexceptflag.03",
                "fesetexceptflag() shall set FE_OVERFLOW",
            (
                excepts.overflow => (fexcepts->overflow == post_fenv->excepts->overflow)
            ));

            REQ("?fesetexceptflag.01;fesetexceptflag.03",
                "fesetexceptflag() shall set FE_UNDERFLOW",
            (
                excepts.underflow => (fexcepts->underflow == post_fenv->excepts->underflow)
            ));
        }
        else
        {
            /*
             * Otherwise, it shall return a non-zero value.
             */
            REQ("fesetexceptflag.01;fesetexceptflag.04", "fesetexceptflag() shall return non-zero",
                fesetexceptflag_spec != 0);
        }

        return true;
    }
}

void onFESetExceptFlag(CallContext context, FExceptTPtr flagp, FEnvExceptions excepts,
                       IntT fesetexceptflag_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);
    FExceptT *fexcepts = getFExceptT(flagp);

    assertion(fenv != NULL, "onFESetExceptFlag: fenv is NULL");

    if(fesetexceptflag_spec == 0)
    {
        if(excepts.divbyzero)
        {
            fenv->excepts->divbyzero = True_Bool3;
        }
        if(excepts.inexact)
        {
            fenv->excepts->inexact = True_Bool3;
        }
        if(excepts.invalid)
        {
            fenv->excepts->invalid = True_Bool3;
        }
        if(excepts.overflow)
        {
            fenv->excepts->overflow = True_Bool3;
        }
        if(excepts.underflow)
        {
            fenv->excepts->underflow = True_Bool3;
        }
    }
    else
    {
        fenv->excepts->divbyzero = Unknown_Bool3;
        fenv->excepts->inexact   = Unknown_Bool3;
        fenv->excepts->invalid   = Unknown_Bool3;
        fenv->excepts->overflow  = Unknown_Bool3;
        fenv->excepts->underflow = Unknown_Bool3;
    }
}

specification
IntT fesetround_spec(CallContext context, IntT round)
{
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);

    pre
    {
        return true;
    }
    coverage C
    {
        if(round == SUT_FE_DOWNWARD)
        {
            return { Downward, "Downward" };
        }
        else if(round == SUT_FE_TONEAREST)
        {
            return { ToNearest, "To nearest" };
        }
        else if(round == SUT_FE_TOWARDZERO)
        {
            return { TowardZero, "Toward zero" };
        }
        else if(round == SUT_FE_UPWARD)
        {
            return { Upward, "Upward" };
        }
        else if(round >= 0)
        {
            return { UnknownPositive, "Unknown positive" };
        }
        else
        {
            return { UnknownNegative, "Unknown negative" };
        }
    }
    post
    {
        FEnvT *post_fenv = getFloatingPointEnvironment(context);

        /*
         * The fesetround() function shall establish the rounding direction represented by
         * its argument round.
         */
        if(!isKnown_FEnvRoundingDirection(round))
        {
            /*
             * If the argument is not equal to the value of a rounding
             * direction macro, the rounding direction is not changed.
             */
            REQ("fesetround.02", "fesetround() shall not set rounding direction",
            (
                fesetround_spec != 0 && post_fenv->round == pre_fenv->round
            ));
        }

        if(fesetround_spec == 0)
        {
            /*
             * The fesetround() function shall return a zero value if and only
             * if the requested rounding direction was established.
             */
            REQ("?fesetround.01;fesetround.03", "fesetround() shall set rounding direction",
            (
                post_fenv->round != NULL && *post_fenv->round == round
            ));
        }

        return true;
    }
}

void onFESetRound(CallContext context, IntT round, IntT fesetround_spec)
{
    FEnvT *fenv = getFloatingPointEnvironment(context);

    assertion(fenv != NULL, "onFESetRound: fenv is NULL");

    if(fesetround_spec == 0)
    {
        fenv->round = create_IntTObj(round);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    fetestexcept - test floating-point exception flags

SYNOPSIS

    #include <fenv.h>

    int fetestexcept(int excepts);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The fetestexcept() function shall determine which of a specified subset of
    the floating-point exception flags are currently set. The excepts argument
    specifies the floating-point status flags to be queried.

RETURN VALUE

    The fetestexcept() function shall return the value of the bitwise-inclusive
    OR of the floating-point exception macros corresponding to the currently
    set floating-point exceptions included in excepts.

ERRORS

    No errors are defined.
*/
specification
FEnvExceptions fetestexcept_spec(CallContext context, FEnvExceptions excepts)
{
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);

    pre
    {
        return true;
    }
    coverage C
    {
        FENV_EXCEPTIONS_COVERAGE(fetestexcept, "fetestexcept()", excepts);
    }
    post
    {
        /*
         * The fetestexcept() function shall determine which of a specified
         * subset of the floating-point exception flags are currently set. The
         * excepts argument specifies the floating-point status flags to be
         * queried.
         *
         * The fetestexcept() function shall return the value of the
         * bitwise-inclusive OR of the floating-point exception macros
         * corresponding to the currently set floating-point exceptions
         * included in excepts.
         */
        REQ("fetestexcept.01.01", "fetestexcept() shall return FE_DIVBYZERO",
        (
            fetestexcept_spec.divbyzero => (pre_fenv->excepts->divbyzero != False_Bool3)
        ));

        REQ("fetestexcept.01.01", "fetestexcept() shall return FE_INEXACT",
        (
            fetestexcept_spec.inexact => (pre_fenv->excepts->inexact != False_Bool3)
        ));

        REQ("fetestexcept.01.01", "fetestexcept() shall return FE_INVALID",
        (
            fetestexcept_spec.invalid => (pre_fenv->excepts->invalid != False_Bool3)
        ));

        REQ("fetestexcept.01.01", "fetestexcept() shall return FE_OVERFLOW",
        (
            fetestexcept_spec.overflow => (pre_fenv->excepts->overflow != False_Bool3)
        ));

        REQ("fetestexcept.01.01", "fetestexcept() shall return FE_UNDERFLOW",
        (
            fetestexcept_spec.underflow => (pre_fenv->excepts->underflow != False_Bool3)
        ));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    feupdateenv - update floating-point environment

SYNOPSIS

    #include <fenv.h>

    int feupdateenv(const fenv_t *envp);

DESCRIPTION

    The functionality described on this reference page is aligned with the ISO
    C standard. Any conflict between the requirements described here and the
    ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001 defers
    to the ISO C standard. 

    The feupdateenv() function shall attempt to save the currently raised
    floating-point exceptions in its automatic storage, attempt to install the
    floating-point environment represented by the object pointed to by envp,
    and then attempt to raise the saved floating-point exceptions. The argument
    envp shall point to an object set by a call to feholdexcept() or
    fegetenv(), or equal a floating-point environment macro.

RETURN VALUE

    The feupdateenv() function shall return a zero value if and only if all the
    required actions were successfully carried out.

ERRORS

    No errors are defined.
*/
specification
IntT feupdateenv_spec(CallContext context, FEnvTPtr envp)
{
    FEnvT *src_fenv = getFEnvT(envp);
    FEnvT *pre_fenv = getFloatingPointEnvironment(context);
    FEnvTPtr default_fenvp = getDefaultFloatingPointEnvironment(context);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "envp is valid", isValidPointer(context, envp));
        
        /*
         * The argument envp shall point to an object set by a call to
         * feholdexcept() or fegetenv(), or equal a floating-point environment
         * macro.
         */
        REQ("app.feupdateenv.01", "The envp shall be correct",
        (
            equals_VoidTPtr(envp, default_fenvp) || src_fenv != NULL
        ));

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * The feupdateenv() function shall return a zero value if and only if
         * all the required actions were successfully carried out.
         */
        if(feupdateenv_spec == 0)
        {
            FEnvT *post_fenv = getFloatingPointEnvironment(context);

            /*
             * The feupdateenv() function shall attempt to save the currently
             * raised floating-point exceptions in its automatic storage
             */
            REQ("?feupdateenv.01.01;feupdateenv.02",
                "feupdateenv() shall save exceptions", true);

            /*
             * attempt to install the floating-point environment represented by
             * the object pointed to by envp
             */
            REQ("?feupdateenv.01.02;feupdateenv.02", "feupdateenv() shall set FE_DIVBYZERO",
            (
                (src_fenv->excepts->divbyzero == True_Bool3) =>
                    (post_fenv->excepts->divbyzero == True_Bool3)
            ));

            REQ("?feupdateenv.01.02;feupdateenv.02", "feupdateenv() shall set FE_INEXACT",
            (
                (src_fenv->excepts->inexact == True_Bool3) =>
                    (post_fenv->excepts->inexact == True_Bool3)
            ));

            REQ("?feupdateenv.01.02;feupdateenv.02", "feupdateenv() shall set FE_INVALID",
            (
                (src_fenv->excepts->invalid == True_Bool3) =>
                    (post_fenv->excepts->invalid == True_Bool3)
            ));

            REQ("?feupdateenv.01.02;feupdateenv.02", "feupdateenv() shall set FE_OVERFLOW",
            (
                (src_fenv->excepts->overflow == True_Bool3) =>
                    (post_fenv->excepts->overflow == True_Bool3)
            ));

            REQ("?feupdateenv.01.02;feupdateenv.02", "feupdateenv() shall set FE_UNDERFLOW",
            (
                (src_fenv->excepts->underflow == True_Bool3) =>
                    (post_fenv->excepts->underflow == True_Bool3)
            ));

            /*
             * and then attempt to raise the saved floating-point exceptions.
             */
            REQ("?feupdateenv.01.03;feupdateenv.02",
                "feupdateenv() shall raise the saved FE_DIVBYZERO",
            (
                (pre_fenv->excepts->divbyzero == True_Bool3) =>
                    (post_fenv->excepts->divbyzero == True_Bool3)
            ));

            REQ("?feupdateenv.01.03;feupdateenv.02",
                "feupdateenv() shall raise the saved FE_INEXACT",
            (
                (pre_fenv->excepts->inexact == True_Bool3) =>
                    (post_fenv->excepts->inexact == True_Bool3)
            ));

            REQ("?feupdateenv.01.03;feupdateenv.02",
                "feupdateenv() shall raise the saved FE_INVALID",
            (
                (pre_fenv->excepts->invalid == True_Bool3) =>
                    (post_fenv->excepts->invalid == True_Bool3)
            ));

            REQ("?feupdateenv.01.03;feupdateenv.02",
                "feupdateenv() shall raise the saved FE_OVERFLOW",
            (
                (pre_fenv->excepts->overflow == True_Bool3) =>
                    (post_fenv->excepts->overflow == True_Bool3)
            ));

            REQ("?feupdateenv.01.03;feupdateenv.02",
                "feupdateenv() shall raise the saved FE_UNDERFLOW",
            (
                (pre_fenv->excepts->underflow == True_Bool3) =>
                    (post_fenv->excepts->underflow == True_Bool3)
            ));
        }

        return true;
    }
}

void onFEUpdateEnv(CallContext context, FEnvTPtr envp, IntT feupdateenv_spec)
{
    FEnvT *src_fenv = getFEnvT(envp);
    FEnvT *dst_fenv = getFloatingPointEnvironment(context);

    assertion(dst_fenv != NULL, "onFEUpdateEnv: dst_fenv is NULL");

    if(feupdateenv_spec == 0 && src_fenv != NULL)
    {
        dst_fenv->excepts->divbyzero =
            or_Bool3(dst_fenv->excepts->divbyzero, src_fenv->excepts->divbyzero);

        dst_fenv->excepts->inexact =
            or_Bool3(dst_fenv->excepts->inexact, src_fenv->excepts->inexact);

        dst_fenv->excepts->invalid =
            or_Bool3(dst_fenv->excepts->invalid, src_fenv->excepts->invalid);

        dst_fenv->excepts->overflow =
            or_Bool3(dst_fenv->excepts->overflow, src_fenv->excepts->overflow);

        dst_fenv->excepts->underflow =
            or_Bool3(dst_fenv->excepts->underflow, src_fenv->excepts->underflow);

        dst_fenv->round = clone(src_fenv->round);

        dst_fenv->nonstop = src_fenv->nonstop;
    }
    else
    {
        dst_fenv->excepts->divbyzero = Unknown_Bool3;
        dst_fenv->excepts->inexact   = Unknown_Bool3;
        dst_fenv->excepts->invalid   = Unknown_Bool3;
        dst_fenv->excepts->overflow  = Unknown_Bool3;
        dst_fenv->excepts->underflow = Unknown_Bool3;

        dst_fenv->round = NULL;

        dst_fenv->nonstop = Unknown_Bool3;
    }
}


specification
IntT matherr_spec(CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        return true;
    }
}
