/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "common/common_model.seh"

#include "ncurses/slk/slk_model.seh"
#include "ncurses/slk/slk_model.seh"

#pragma SEC subsystem slk "ncurses.slk"

/*
   The group of functions 'ncurses.slk' consists of:
       slk_attr_set [1]
       slk_attroff [1]
       slk_attron [1]
       slk_attrset [1]
       slk_clear [1]
       slk_color [1]
       slk_init [1]
       slk_label [1]
       slk_noutrefresh [1]
       slk_refresh [1]
       slk_restore [1]
       slk_set [1]
       slk_touch [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

slk_attroff, slk_attr_off, slk_attron, slk_attr_on, slk_attrset,
slk_attr_set, slk_clear, slk_color, slk_init, slk_label, slk_noutrefresh,
slk_refresh, slk_restore, slk_set, slk_touch, slk_wset - soft label functions

SYNOPSIS

#include <curses.h>

int slk_attroff(const chtype attrs);

int slk_attr_off(const attr_t attrs, void *opts);

int slk_attron(const chtype attrs);

int slk_attr_on(const attr_t attrs, void *opts);

int slk_attrset(const chtype attrs);

int slk_attr_set(const attr_t attrs, short color_pair_number, void *opts);

int slk_clear(void);

int slk_color(short color_pair_number);

int slk_init(int fmt);

char *slk_label(int labnum);

int slk_noutrefresh(void);

int slk_refresh(void);

int slk_restore(void);

int slk_set(int labnum, const char *label, int justify);

int slk_touch(void);

int slk_wset(int labnum, const wchar_t *label, int justify);

DESCRIPTION

The Curses interface manipulates the set of soft function-key labels that
exist on many terminals. For those terminals that do not have soft labels,
Curses takes over the bottom line of stdscr, reducing the size of stdscr
and the value of the LINES external variable. There can be up to eight
labels of up to eight display columns each.

To use soft labels, slk_init() must be called before initscr(), newterm()
or ripoffline() is called. If initscr() eventually uses a line from
stdscr to emulate the soft labels, then fmt determines how the labels are
arranged on the screen. Setting fmt to 0 indicates a 3-2-3 arrangement of
the labels; 1 indicates a 4-4 arrangement. Other values for fmt are
unspecified.

The slk_init() function has the effect of calling ripoffline() to reserve
one screen line to accommodate the requested format.

The slk_set() and slk_wset() functions specify the text of soft label
number labnum, within the range from 1 to and including 8. The label argument
is the string to be put on the label. With slk_set(), and slk_wset(),
the width of the label is limited to eight column positions. A null string or
a null pointer specifies a blank label. The justify argument can have the
following values to indicate how to justify label within the space reserved
for it:

0Align the start of label with the start of the space

1Center label within the space

2Align the end of label with the end of the space

The slk_refresh() and slk_noutrefresh() functions correspond to the
wrefresh() and wnoutrefresh() functions.

The slk_label() function obtains soft label number labnum.

The slk_clear() function immediately clears the soft labels from the screen.

The slk_restore() function immediately restores the soft labels to the screen
after a call to slk_clear().

The slk_touch() function forces all the soft labels to be output the next
time slk_noutrefresh() or slk_refresh() is called.

The slk_attron(), slk_attrset() and slk_attroff() functions correspond to
attron(), attrset(), and attroff(). They have an effect only if soft labels
are simulated on the bottom line of the screen.

The slk_attr_off(), slk_attr_on(), slk_attr_set(), and slk_color()
functions correspond to slk_attroff(), slk_attron(), slk_attrset() and
color_set() and thus support the attribute constants with the WA_ prefix and
colour.

The opts argument is reserved for definition in a future edition of this
document. Currently, the application must provide a null pointer as opts.

RETURN VALUE

Upon successful completion, slk_label() returns the requested label with
leading and trailing blanks stripped. Otherwise, it returns a null pointer.

Upon successful completion, the other functions return OK. Otherwise, they
return ERR.

ERRORS

No errors are defined.

*/

specification
IntT slk_attrset_spec( CallContext context, ChTypeT attrs )
{
    pre
    {
        REQ("","blank attrs are not supported by test",
            !equals_NCursesAttrT( getAttrFromChType(attrs), create_emptyNcursesAttrT() )
            );

        return true;
    }
    post
    {
        if(slk_attrset_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_attrset.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_attrset.09.01", "return OK", slk_attrset_spec == SUT_OK);


        /*
         * The slk_attron(), slk_attrset() and slk_attroff() functions correspond to
         * attron(), attrset(), and attroff().
         */
        /*
         * The attrset() and wattrset() functions set the background attributes of the
         * current or specified window to attrs.
         */
        REQ("slk_attrset.04", "", TODO_REQ());

        /*
         * They have an effect only if soft labels are simulated on the bottom line of
         * the screen.
         */
        REQ("slk_attrset.05", "", TODO_REQ());

        return true;
    }
}

void onSlkAttrset(CallContext context, ChTypeT attrs, IntT slk_attrset_spec )
{
    if(slk_attrset_spec == SUT_OK)
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.attrs = attrs;
    }
}

/**/

specification
IntT slk_attr_set_spec( CallContext context, NcursesAttrT attrs, ShortT color_pair_number, VoidTPtr opt )
{
    pre
    {
        REQ("","blank attrs are not supported by test",
            !equals_NCursesAttrT( attrs, create_emptyNcursesAttrT() )
            );

        /*
         * Currently, the application must provide a null pointer as opts.
         */
        REQ("app.slk_attr_set.05","must provide a null pointer as opts", isNULL_VoidTPtr(opt) );

        return true;
    }
    post
    {
        if(slk_attr_set_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_attr_set.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_attr_set.09.01", "return OK", slk_attr_set_spec == SUT_OK);


        /*
         * The slk_attr_off(), slk_attr_on(), slk_attr_set(), and slk_color() functions
         * correspond to slk_attroff(), slk_attron(), slk_attrset() and color_set() and
         * thus support the attribute constants with the WA_ prefix and colour.
         */
        /*
         * The attrset() and wattrset() functions set the background attributes of the
         * current or specified window to attrs.
         */
        REQ("slk_attr_set.04", "", TODO_REQ());

        return true;
    }
}

void onSlkAttrSet(CallContext context, NcursesAttrT attrs, ShortT color_pair_number, VoidTPtr opt, IntT slk_attr_set_spec )
{
    if(slk_attr_set_spec == SUT_OK)
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.attrs = combineChTypeTWithAttrs(attrs, std_term->slk.attrs);

        std_term->slk.attrs.colorPair = color_pair_number;
    }
}

/**/

specification
IntT slk_attroff_spec( CallContext context, ChTypeT attrs)
{
    pre
    {
        return true;
    }
    post
    {
        if(slk_attroff_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_attroff.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_attroff.09.01", "return OK", slk_attroff_spec == SUT_OK);


        /*
         * The slk_attron(), slk_attrset() and slk_attroff() functions correspond to
         * attron(), attrset(), and attroff().
         */
        /*
         * The attroff() and wattroff() functions turn off attrs in the current or
         * specified window without affecting any others.
         */
        REQ("slk_attroff.04", "", TODO_REQ());

        /*
         * They have an effect only if soft labels are simulated on the bottom line of
         * the screen.
         */
        REQ("slk_attroff.05", "", TODO_REQ());

        return true;
    }
}

void onSlkAttroff(CallContext context, ChTypeT attrs, IntT slk_attroff_spec )
{
    if(slk_attroff_spec  == SUT_OK)
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.attrs = TurnOff_ChTypeT(std_term->slk.attrs, attrs);
    }
}

/**/

specification
IntT slk_attron_spec( CallContext context, ChTypeT attrs)
{
    pre
    {
        return true;
    }
    post
    {
        if(slk_attron_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_attron.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_attron.09.01", "return OK", slk_attron_spec == SUT_OK);


        /*
         * The slk_attron(), slk_attrset() and slk_attroff() functions correspond to
         * attron(), attrset(), and attroff().
         */
        /*
         * The attron() and wattron() functions turn on attrs in the current or
         * specified window without affecting any others.
         */
        REQ("slk_attron.04", "", TODO_REQ());

        /*
         * They have an effect only if soft labels are simulated on the bottom line of
         * the screen.
         */
        REQ("slk_attron.05", "", TODO_REQ());

        return true;
    }
}

void onSlkAttron(CallContext context, ChTypeT attrs, IntT slk_attron_spec )
{
    if(slk_attron_spec  == SUT_OK)
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.attrs = TurnOn_ChTypeT(std_term->slk.attrs, attrs);
    }
}

/**/

specification
IntT slk_clear_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { ImmediatelyClearsSoftLabelsFromScreen, "immediately clears the soft labels from the screen" };
    }
    post
    {
        IntT x, cols;
        NcursesAttrT attrs;
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        if( slk_clear_spec == SUT_ERR )
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_clear.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_clear.09.01", "return OK", slk_clear_spec == SUT_OK );

        /*
         * The slk_clear() function immediately clears the soft labels from the screen.
         */
        cols = getTermNCols(context);
        x = 0;
        my_slkSkipSpace(context, &x, getAttrFromChType(std_term->slk.attrs) );

        REQ("slk_clear.04", "clears", x == cols);

        return true;
    }
}

void onSlkClear(CallContext context, IntT slk_clear_spec)
{
    if( slk_clear_spec == SUT_OK )
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.invis = true;

        onSlkRefresh(context, slk_clear_spec);
    }
}

/**/

specification
IntT slk_color_spec( CallContext context, ShortT color_pair_number)
{
    pre
    {
        return true;
    }
    post
    {
        if(slk_color_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_color.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_color.09.01", "return OK", slk_color_spec == SUT_OK);

        /*
         * The slk_attr_off(), slk_attr_on(), slk_attr_set(), and slk_color()
         * functions correspond to slk_attroff(), slk_attron(), slk_attrset() and
         * color_set() and thus support the attribute constants with the WA_ prefix and
         * colour.
         */
        /*
         * The color_set() and wcolor_set() functions set the window colour of the
         * current or specified window to color_pair_number.
         */
        REQ("slk_color.04", "", TODO_REQ());

        return true;
    }
}

void onSlkColor(CallContext context, ShortT color_pair_number, IntT slk_color_spec )
{
    if(slk_color_spec == SUT_OK)
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.attrs.colorPair = color_pair_number;
    }
}

/**/

specification
IntT slk_init_spec( CallContext context, IntT fmt )
{
    pre
    {

        NCursesWindow * std_win = getNCursesStdWindow(context);
        List * riplist = getRipLines(context);

        /*
         * To use soft labels, slk_init() must be called before initscr(), newterm()
         * or ripoffline() is called.
         */
        REQ("app.slk_init.04", "slk_init must be called before initscr, newterm or ripoffline",
             (std_win == NULL) && ( size_List(riplist) == 0 )
           );

        /*
         * Setting fmt to 0 indicates a 3-2-3 arrangement of the labels;
         * 1 indicates a 4-4 arrangement.
         *
         * Other values for fmt are unspecified.
         */
        REQ("app.slk_init.07", "fmt equals 0 or 1", (fmt==0) || (fmt==1) );

        return true;
    }
    post
    {
        if(slk_init_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_init.09.02", "err", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_init.09.01", "return OK", slk_init_spec == SUT_OK);


        /* The Curses interface manipulates the set of soft function-key labels
         * that exist on many terminals.
         */
        REQ("ncurses.slk.01", "", TODO_REQ());

        /* For those terminals that do not have soft labels, Curses takes over
         * the bottom line of stdscr, reducing the size of stdscr and the value of the LINES external variable.
         */
        REQ("ncurses.slk.02", "", TODO_REQ());

        /*
         * If initscr() eventually uses a line from stdscr to emulate the soft labels,
         * then fmt determines how the labels are arranged on the screen.
         */
        REQ("slk_init.05", "", TODO_REQ());

        /*
         * Setting fmt to 0 indicates a 3-2-3 arrangement of the labels;
         */
        REQ("slk_init.06.01", "", TODO_REQ());

        /*
         * 1 indicates a 4-4 arrangement.
         */
        REQ("slk_init.06.02", "", TODO_REQ());

        /*
         * The slk_init() function has the effect of calling ripoffline() to reserve
         * one screen line to accommodate the requested format.
         */
        IMPLEMENT_REQ("slk_init.08");

        return true;
    }
}

void onSlkInit(CallContext context, IntT fmt, IntT slk_init_spec)
{
    if(slk_init_spec == SUT_OK)
    {
        setSlkFormat(context, fmt);

        /*
         * The slk_init() function has the effect of calling ripoffline() to reserve
         * one screen line to accommodate the requested format.
         */
        addRipLine(context, create_RipLineT(-1, 0, NULL_VoidTPtr, 0));
    }
}


specification
CString * slk_label_spec( CallContext context, IntT labnum )
{
    pre
    {
        return true;
    }
    post
    {
        SlkSoftkeyT model_label;
        NCursesTerminal * std_term = getNCursesStdTerminal(context);
        CString * tmp_str;

        if(slk_label_spec == NULL)
        {
            /*
             * Otherwise, it returns a null pointer.
             */
            REQ("slk_label.05.02","",TODO_REQ());

            return true;
        }

        /*
         * There can be up to eight labels of up to eight display columns each.
         */
        REQ("slk_label.03", "There can be up to eight labels", (labnum>=1) && (labnum<=8) );


        model_label = std_term->slk.slk_labels[labnum-1];

        if(model_label.label == NULL)
            model_label.label = create_CString("");

        tmp_str = trim_CString(slk_label_spec);
        if( equals(tmp_str, model_label.label) )
        {
            /*
             * The slk_label() function obtains soft label number labnum.
             */
            /*
             * Upon successful completion, slk_label() returns the requested label with
             * leading and trailing blanks stripped.
             */
            REQ("slk_label.04;slk_label.05.01", "leading and trailing blanks are stripped",
                 equals(slk_label_spec, model_label.label)
               );
        }
        else
        {
            traceFormattedUserInfo("label: '$(obj)'?='$(obj)' {'$(obj)'}",
                    model_label.label, tmp_str, slk_label_spec );

            /*
             * The slk_label() function obtains soft label number labnum.
             */
            REQ("slk_label.04", "returns the requested label",
                 false
               );
        }


        return true;
    }
}

bool post_refresh_check(CallContext context)
{
    IntT x, n;
    IntT cols;
    IntT res_lspace, res_rspace;
    CString * label;
    IntT label_len;
    NCursesTerminal * std_term = getNCursesStdTerminal(context);
    SlkSoftkeyT model_label;
    NcursesAttrT attrs;

    cols = getTermNCols(context);
    x = 0;
    n = 0; // number of a softkey

    attrs = getAttrFromChType(std_term->slk.attrs);

    while(x<cols)
    {
        IntT spaces = my_slkSkipSpace(context, &x, attrs);
        IntT res = my_slkReadSoftKey(context, &x, &res_lspace, &res_rspace, &label, attrs);

        if(res<0)
            break;

        traceFormattedUserInfo("sp:%d; l:%d; r:%d;", spaces, res_lspace, res_rspace);

        if(label)
            traceFormattedUserInfo("label:$(obj)", label);
        /*
         * There can be up to eight labels of up to eight display columns each.
         */
        REQ("ncurses.slk.03.count","There can be up to eight labels", n<8);
        REQ("ncurses.slk.03.width","of up to eight display columns each",
                res_lspace + res_rspace + (label?length_CString(label):0) == 8
            );

        model_label = std_term->slk.slk_labels[n];

        traceFormattedUserInfo("model.justify:%d", model_label.justify);
        if(model_label.label)
            traceFormattedUserInfo("model_label:$(obj)", model_label.label);

        if(label)
        {
            label_len = length_CString(label);

            /*
             * The justify argument can have the following values to indicate
             * how to justify label within the space reserved for it:
             */
            if(model_label.justify == 0)
            {
                /* 0  Align the start of label with the start of the space */
                REQ("slk_set.08.01", "align left", res_lspace == 0);
            }
            else if(model_label.justify == 1)
            {
                /* 1  Center label within the space */
                REQ("slk_set.08.02", "align center", abs(res_lspace - res_rspace)<=1);
            }
            else if(model_label.justify == 2)
            {
                /* 2  Align the end of label with the end of the space */
                REQ("slk_set.08.03", "align right", res_rspace == 0);
            }

            /*
             * With slk_set(), and slk_wset(), the width of the label
             * is limited to eight column positions.
             */
            REQ("slk_set.06","the width of the label is limited to 8", label_len<=8);

            REQ("","model label exists", model_label.label != NULL);


            if(label_len<8)
            {
                REQ("slk_set.05","labels are equal", equals(label, model_label.label) );
            }
            else
            {
                REQ("slk_set.05","label is cut",
                     equals(label, substring_CString(model_label.label,0,8))
                   );
            }

            //DUMP("%s ", toCharArray_CString(label));
        }
        else
        {
            /*
             * A null string or a null pointer specifies a blank label.
             */
            REQ("slk_set.07","blank label", model_label.label == NULL);
        }

        n++;
    }
    //DUMP("\n");

    if( std_term->slk.invis )
    {
        REQ("slk_clear.04","cleared", n==0);
    }

    return true;
}

specification
IntT slk_refresh_spec( CallContext context )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { CorrespondToWrefreshWnoutrefresh, "Correspond to the wrefresh()" };
    }
    post
    {
        if(slk_refresh_spec == SUT_ERR)
        {
            /*
             * Upon successful completion, the other functions return OK.
             * Otherwise, they return ERR.
             */
            REQ("slk_refresh.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_refresh.09.01", "return OK", slk_refresh_spec == SUT_OK);

        /*
         * The slk_refresh() and slk_noutrefresh() functions correspond to the
         * wrefresh() and wnoutrefresh() functions.
         */
        IMPLEMENT_REQ("slk_refresh.04");

        return post_refresh_check(context);
    }
}

void onSlkRefresh(CallContext context, IntT slk_refresh_spec)
{
    IntT cols = getTermNCols(context);
    IntT lines = getTermNLines(context);
    CByteArray * ba;
    ChTypeTArray * ar;

    ba = ncursesScreenDump(context);
    ar = create_ChTypeTArray_ScreenDump(ba, cols, lines);
    DUMP_image(ar, cols, lines); //
    set_stdScreenContent(ar);
}

specification
IntT slk_restore_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { ImmediatelyRestoresSoftLabelsToScreen, "Immediately restores the soft labels to the screen" };
    }
    post
    {
        if(slk_restore_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_restore.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_restore.09.01", "return OK", slk_restore_spec == SUT_OK);

        /*
         * The slk_restore() function immediately restores the soft labels to the screen
         * after a call to slk_clear().
         */
        IMPLEMENT_REQ("slk_restore.04");

        return post_refresh_check(context);
    }
}

void onSlkRestore(CallContext context, IntT slk_restore_spec)
{
    if(slk_restore_spec == SUT_OK)
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.invis = false;

        onSlkRefresh(context, SUT_OK);
    }
}

specification
IntT slk_set_spec( CallContext context, IntT labnum, CString *label, IntT justify)
{
    pre
    {
        return true;
    }
    post
    {

        if( slk_set_spec == SUT_ERR )
        {
            /*
             * Upon successful completion, the other functions return OK.
             * Otherwise, they return ERR.
             */
            REQ("slk_set.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_set.09.01", "return OK", slk_set_spec == SUT_OK );

        /*
         * There can be up to eight labels of up to eight display columns each.
         */
        /*
         * The slk_set() and slk_wset() functions specify the text of soft label
         * number labnum, within the range from 1 to and including 8.
         */
        REQ("slk_set.03;slk_set.04", "labnum from 1 to 8", (labnum>=1) && (labnum<=8) );

        /*
         * The label argument is the string to be put on the label.
         */
        REQ("slk_set.05", "", TODO_REQ());

        /*
         * With slk_set(), and slk_wset(), the width of the label is limited to eight
         * column positions.
         */
        REQ("slk_set.06", "", TODO_REQ());

        /*
         * A null string or a null pointer specifies a blank label.
         */
        REQ("slk_set.07", "", TODO_REQ());

        /*
         * The justify argument can have the following values to indicate how to justify
         * label within the space reserved for it:
         *
         * 0  Align the start of label with the start of the space
         */
        REQ("slk_set.08.01", "", TODO_REQ());

        /*
         * The justify argument can have the following values to indicate how to justify
         * label within the space reserved for it:
         *
         * 1  Center label within the space
         */
        REQ("slk_set.08.02", "", TODO_REQ());

        /*
         * The justify argument can have the following values to indicate how to justify
         * label within the space reserved for it:
         *
         * 2  Align the end of label with the end of the space
         */
        REQ("slk_set.08.03", "", TODO_REQ());

        return true;
    }
}

void onSlkSet(CallContext context, IntT labnum, CString *label, IntT justify, IntT slk_set_spec)
{
    if( (slk_set_spec == SUT_OK) && (labnum>=1) && (labnum<=8) )
    {
        NCursesTerminal * std_term = getNCursesStdTerminal(context);

        std_term->slk.slk_labels[labnum-1].justify = justify;

        // trim
        label = trim_CString(label);
        if(length_CString(label) > 8)
        {
            label = substring_CString(label,0,8);
        }
        if(length_CString(label) > 0)
        {
            std_term->slk.slk_labels[labnum-1].label = label;
        }
    }
}

/**/

specification
IntT slk_noutrefresh_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { CorrespondToWnoutrefresh, "Correspond to the wnoutrefresh()" };
    }
    post
    {
        if(slk_noutrefresh_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_noutrefresh.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_noutrefresh.09.01", "return OK", slk_noutrefresh_spec == SUT_OK);

        /*
         * The slk_refresh() and slk_noutrefresh() functions correspond to the
         * wrefresh() and wnoutrefresh() functions.
         */
        REQ("slk_noutrefresh.04", "", TODO_REQ());

        return true;
    }
}

void onSlkNoutrefresh(CallContext context, IntT slk_noutrefresh_spec)
{
    /**/
}

/**/

specification
IntT slk_touch_spec( CallContext context )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { ForcesAllSoftLabelsToBeOutput,
                 "Forces all the soft labels to be output the next time slk_noutrefresh() or slk_refresh() is called"
               };
    }
    post
    {
        if(slk_touch_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("slk_touch.09.02", "return ERR", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("slk_touch.09.01", "return OK", slk_touch_spec == SUT_OK);

        /*
         * The slk_touch() function forces all the soft labels to be output the next
         * time slk_noutrefresh() or slk_refresh() is called.
         */
        REQ("slk_touch.04", "", TODO_REQ());

        return true;
    }
}

void onSlkTouch(CallContext context, IntT slk_touch_spec)
{
    /**/
}

/********************************************************************/
/**                        Helper Functions                        **/
/********************************************************************/

IntT my_slkIsSoftKey(CallContext context, IntT x, NcursesAttrT attrs)
{
    WCharT blank_letter = ' ';
    IntT y = getTermNLines(context)-1;
    IntT maxX = getTermNCols(context);
    ChTypeT ch;
    NcursesAttrT attr2;

    if(x>=maxX)
        return -1;

    ch = getElement_stdScreenContent_YX(context, y, x);
    attr2 = getAttrFromChType(ch);

    if( equals_NCursesAttrT(attr2, attrs) )
    {
        if(ch.letter!=blank_letter)
        {
            return 2;
        }

        return 1;
    }

    return 0;
}

IntT my_slkSkipSpace(CallContext context, IntT * x, NcursesAttrT attrs)
{
    IntT res = 0;

    while( my_slkIsSoftKey(context, *x, attrs) == 0 )
    {
        (*x)++;
        res++;
    };

    return res;
}

IntT my_slkReadSoftKey(CallContext context, IntT * x, IntT *res_lspace, IntT * res_rspace, CString ** label, NcursesAttrT attrs)
{
    CharT lab[9];
    int i;
    IntT y = getTermNLines(context)-1;

    *res_lspace = 0;
    *res_rspace = 0;
    if(label)
        *label = NULL;

    for(i=0;i<9;i++)
        lab[i] = 0;

    if(my_slkIsSoftKey(context, *x, attrs) <= 0)
    {
        return -1;
    }

    while( my_slkIsSoftKey(context, *x, attrs) == 1 )
    {
        (*x)++;
        (*res_lspace)++;
    };

    if(my_slkIsSoftKey(context, *x, attrs) <= 0)
    {
        return 0;
    }

    i=0;
    while( my_slkIsSoftKey(context, *x, attrs) == 2 )
    {
        lab[i] = getElement_stdScreenContent_YX(context, y, *x).letter;
        (*x)++;
        i++;
    };

    if(my_slkIsSoftKey(context, *x, attrs) <= 0)
    {
        if(label)
            *label = create_CString(lab);

        return 0;
    }

    while( my_slkIsSoftKey(context, *x, attrs) == 1 )
    {
        (*x)++;
        (*res_rspace)++;
    };

    if(label)
        *label = create_CString(lab);

    return 0;
}
