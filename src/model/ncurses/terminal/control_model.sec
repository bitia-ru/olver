/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/terminal/control_model.seh"


#pragma SEC subsystem terminal "ncurses.terminal"



/*
   The group of functions 'ncurses.terminal.control' consists of:
       clearok [1]
       echo [1]
       has_ic [1]
       has_il [1]
       idcok [1]
       idlok [1]
       immedok [1]
       leaveok [1]
       noecho [1]
       noqiflush [1]
       qiflush [1]
       scrollok [1]
       setscrreg [1]
       use_env [1]
       wsetscrreg [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    clearok, idlok, leaveok, scrollok, setscrreg, wsetscrreg - terminal output
    control functions

SYNOPSIS

    #include <curses.h>

    int clearok(WINDOW *win, bool bf);

    int idlok(WINDOW *win, bool bf);

    int leaveok(WINDOW *win, bool bf);

    int scrollok(WINDOW *win, bool bf);

    int setscrreg(int top, int bot);

    int wsetscrreg(WINDOW *win, int top, int bot);

DESCRIPTION

    These functions set options that deal with output within Curses.

    The clearok() function assigns the value of bf to an internal flag in the
    specified window that governs clearing of the screen during a refresh. If,
    during a refresh operation on the specified window, the flag in curscr is
    TRUE or the flag in the specified window is TRUE, then the implementation
    clears the screen, redraws it in its entirety, and sets the flag to FALSE in
    curscr and in the specified window. The initial state is unspecified.

    The idlok() function specifies whether the implementation may use the hardware
    insert-line, delete-line, and scroll features of terminals so equipped. If bf
    is TRUE, use of these features is enabled. If bf is FALSE, use of these
    features is disabled and lines are instead redrawn as required. The initial
    state is FALSE.

    The leaveok() function controls the cursor position after a refresh operation.
    If bf is TRUE, refresh operations on the specified window may leave the
    terminal's cursor at an arbitrary position. If bf is FALSE, then at the end of
    any refresh operation, the terminal's cursor is positioned at the cursor
    position contained in the specified window. The initial state is FALSE.

    The scrollok() function controls the use of scrolling. If bf is TRUE, then
    scrolling is enabled for the specified window, with the consequences discussed
    in

    Truncation, Wrapping and Scrolling . If bf is FALSE, scrolling is disabled for
    the specified window. The initial state is FALSE.

    The setscrreg() and wsetscrreg() functions define a software scrolling
    region in the current or specified window. The top and bot arguments are the
    line numbers of the first and last line defining the scrolling region. ( Line
    0 is the top line of the window.) If this option and scrollok() are
    enabled, an attempt to move off the last line of the margin causes all lines
    in the scrolling region to scroll one line in the direction of the first line.
    Only characters in the window are scrolled. If a software scrolling region is
    set and scrollok() is not enabled, an attempt to move off the last line of
    the margin does not reposition any lines in the scrolling region.

RETURN VALUE

    Upon successful completion, setscrreg() and wsetscrreg() return OK.
    Otherwise, they return ERR.

    The other functions always return OK.

ERRORS

    No errors are defined.

*/

specification
IntT clearok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    NCursesWindow* curWin = getWindowMayNULL(context, &win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    post
    {
        clearok_model(localWin, bf, clearok_spec);

        /*
         * These functions set options that deal with output within Curses.
         */
        REQ("clearok.01", "", TODO_REQ());

        /*
         * If, during a refresh operation on the specified window, the flag in curscr is
         * TRUE or the flag in the specified window is TRUE, then the implementation
         * clears the screen,
         */
        REQ("clearok.03.01", "", TODO_REQ());

        /*
         * redraws it in its entirety,
         */
        REQ("clearok.03.02", "", TODO_REQ());

        /*
         * and sets the flag to FALSE in curscr and in the specified window.
         */
        REQ("clearok.03.03", "", TODO_REQ());

        /*
         * The initial state is unspecified.
         */
        REQ("clearok.04", "", TODO_REQ());

        /*
         * The other functions always return OK.
         */
        REQ("clearok.05", "return value should be OK", clearok_spec == SUT_OK);

        REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


specification
IntT idlok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    NCursesWindow* curWin = getWindowMayNULL(context, &win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    post
    {
        // idlok_model(localWin, bf, idlok_spec);

        /*
         * These functions set options that deal with output within Curses.
         */
        REQ("idlok.01", "", TODO_REQ());

        /*
         * The idlok() function specifies whether the implementation may use the hardware
         * insert-line, delete-line, and scroll features of terminals so equipped.
         */
        REQ("idlok.02", "", TODO_REQ());

        /*
         * If bf is TRUE, use of these features is enabled.
         */
        REQ("idlok.03.01", "", TODO_REQ());

        /*
         * If bf is FALSE, use of these features is disabled and lines are instead
         * redrawn as required.
         */
        REQ("idlok.03.02", "", TODO_REQ());

        /*
         * The initial state is FALSE.
         */
        REQ("idlok.04", "", TODO_REQ());

        /*
         * The other functions always return OK.
         */
        REQ("idlok.05", "return value should be OK", idlok_spec == SUT_OK);

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


specification
IntT leaveok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    NCursesWindow* curWin = getWindowMayNULL(context, &win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    post
    {
        leaveok_model(localWin, bf, leaveok_spec);

        /*
         * These functions set options that deal with output within Curses.
         */
        REQ("leaveok.01", "", TODO_REQ());

        /*
         * The leaveok() function controls the cursor position after a refresh operation.
         */
        REQ("leaveok.02", "", TODO_REQ());

        /*
         * If bf is TRUE, refresh operations on the specified window may leave the
         * terminal's cursor at an arbitrary position.
         */
        REQ("leaveok.03.01", "", TODO_REQ());

        /*
         * If bf is FALSE, then at the end of any refresh operation, the terminal's
         * cursor is positioned at the cursor position contained in the specified window.
         */
        REQ("leaveok.03.02", "", TODO_REQ());

        /*
         * The initial state is FALSE.
         */
        REQ("leaveok.04", "", TODO_REQ());

        /*
         * The other functions always return OK.
         */
        REQ("leaveok.05", "return value should be OK", leaveok_spec == SUT_OK);

        REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


specification
IntT scrollok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    NCursesWindow* curWin = getWindowMayNULL(context, &win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    post
    {
        scrollok_model(localWin, bf, scrollok_spec);

        /*
         * These functions set options that deal with output within Curses.
         */
        REQ("scrollok.01", "", TODO_REQ());

        /*
         * The scrollok() function controls the use of scrolling.
         */
        REQ("scrollok.02", "", TODO_REQ());

        /*
         * If bf is TRUE, then scrolling is enabled for the specified window, with the
         * consequences discussed in
         * Truncation, Wrapping and Scrolling .
         */
        REQ("scrollok.03.01", "", TODO_REQ());

        /*
         * If bf is FALSE, scrolling is disabled for the specified window.
         */
        REQ("scrollok.03.02", "", TODO_REQ());

        /*
         * The initial state is FALSE.
         */
        REQ("scrollok.04", "", TODO_REQ());

        /*
         * The other functions always return OK.
         */
        REQ("scrollok.05", "return value should be OK", scrollok_spec == SUT_OK);

        REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}

//This specification refers to: setscrreg, wsetscrreg
specification
IntT setscrreg_spec(CallContext context, WindowTPtr* win, IntT top, IntT bot)
{
    NCursesWindow* curWin = getWindowMayNULL(context, win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    if (win == NULL)
    {
        FILTER("setscrreg");
    }
    else
    {
        FILTER("wsetscrreg");
    }

    pre
    {
        return true;
    }
    post
    {
        setscrreg_model(localWin, top, bot, setscrreg_spec);

        /*
         * These functions set options that deal with output within Curses.
         */
        REQ("setscrreg.01;wsetscrreg.01", "", TODO_REQ());

        /*
         * The setscrreg() and wsetscrreg() functions define a software scrolling
         * region in the current or specified window.
         */
        REQ("setscrreg.02;wsetscrreg.02", "", TODO_REQ());

        /*
         * The top and bot arguments are the line numbers of the first and last line
         * defining the scrolling region.
         */
        REQ("setscrreg.03;wsetscrreg.03", "", TODO_REQ());

        /*
         * Line 0 is the top line of the window.
         */
        REQ("setscrreg.04;wsetscrreg.04", "", TODO_REQ());

        /*
         * If this option and scrollok() are enabled, an attempt to move off the last
         * line of the margin causes all lines in the scrolling region to scroll one line
         * in the direction of the first line.
         */
        REQ("setscrreg.05;wsetscrreg.05", "", TODO_REQ());

        /*
         * Only characters in the window are scrolled.
         */
        REQ("setscrreg.06;wsetscrreg.06", "", TODO_REQ());

        /*
         * If a software scrolling region is set and scrollok() is not enabled, an
         * attempt to move off the last line of the margin does not reposition any lines
         * in the scrolling region.
         */
        REQ("setscrreg.07;wsetscrreg.07", "", TODO_REQ());

        /*
         * Upon successful completion, setscrreg() and wsetscrreg() return OK.
         */
        /*
         * Otherwise, they return ERR.
         */
        REQ("setscrreg.08.01;wsetscrreg.08.01;setscrreg.08.02;wsetscrreg.08.02", "return value should be OK or ERR",
            T(setscrreg_spec == SUT_OK)
            ||
            T(setscrreg_spec == SUT_ERR)
           );

        REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
    FILTER_CLEAN;
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    echo, noecho - enable/disable terminal echo

SYNOPSIS

    #include <curses.h>

    int echo(void);

    int noecho(void);

DESCRIPTION

    The echo() function enables Echo mode for the current screen. The noecho()
    function disables Echo mode for the current screen. Initially, curses software
    echo mode is enabled and hardware echo mode of the tty driver is disabled.
    echo() and noecho() control software echo only. Hardware echo must remain
    disabled for the duration of the application, else the behaviour is undefined.


RETURN VALUE

    Upon successful completion, these functions return OK. Otherwise, they
    return ERR.

ERRORS

    No errors are defined.

*/

specification
IntT echo_spec(CallContext context)
{
    NCursesWindow* curWin = getNCursesStdWindow(context);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    coverage C
    {
        return { EnableTerminalEcho, "Enable terminal echo" };
    }
    post
    {
        // echo_model(localWin, echo_spec);

        /*
         * The echo() function enables Echo mode for the current screen.
         */
        REQ("echo.01", "", TODO_REQ());

        /*
         * Initially, curses software echo mode is enabled and hardware echo mode of the
         * tty driver is disabled.
         */
        REQ("echo.02", "", TODO_REQ());

        /*
         * echo() and noecho() control software echo only.
         */
        REQ("echo.03", "", TODO_REQ());

        /*
         * Hardware echo must remain disabled for the duration of the application, else
         * the behaviour is undefined.
         */
        REQ("echo.04", "", TODO_REQ());

        /*
         * Upon successful completion, these functions return OK.
         */
        /*
         * Otherwise, they return ERR.
         */
        REQ("echo.05.01;echo.05.02", "return value should be OK or ERR",
            T(echo_spec == SUT_OK)
            ||
            T(echo_spec == SUT_ERR)
           );

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


specification
IntT noecho_spec(CallContext context)
{
    NCursesWindow* curWin = getNCursesStdWindow(context);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    coverage C
    {
        return { DisableTerminalEcho, "Disable terminal echo" };
    }
    post
    {
        // noecho_model(localWin, noecho_spec);

        /*
         * The noecho() function disables Echo mode for the current screen.
         */
        REQ("noecho.01", "", TODO_REQ());

        /*
         * Initially, curses software echo mode is enabled and hardware echo mode of the
         * tty driver is disabled.
         */
        REQ("noecho.02", "", TODO_REQ());

        /*
         * echo() and noecho() control software echo only.
         */
        REQ("noecho.03", "", TODO_REQ());

        /*
         * Hardware echo must remain disabled for the duration of the application, else
         * the behaviour is undefined.
         */
        REQ("noecho.04", "", TODO_REQ());

        /*
         * Upon successful completion, these functions return OK.
         */
        /*
         * Otherwise, they return ERR.
         */
        REQ("noecho.05.01;noecho.05.02", "return value should be OK or ERR",
            T(noecho_spec == SUT_OK)
            ||
            T(noecho_spec == SUT_ERR)
           );

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    has_ic, has_il - query functions for terminal insert and delete capability

SYNOPSIS

    #include <curses.h>

    bool has_ic(void);

    bool has_il(void);

DESCRIPTION

    The has_ic() function indicates whether the terminal has insert- and delete-
    character capabilities.

    The has_il() function indicates whether the terminal has insert- and delete-
    line capabilities, or can simulate them using scrolling regions.

RETURN VALUE

    The has_ic() function returns TRUE if the terminal has insert- and delete-
    character capabilities. Otherwise, it returns FALSE.

    The has_il() function returns TRUE if the terminal has insert- and delete-line
    capabilities. Otherwise, it returns FALSE.

ERRORS

    No errors are defined.

*/

specification
IntT has_ic_spec(CallContext context)
{
    NCursesWindow* curWin = getNCursesStdWindow(context);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    coverage C
    {
        return { HasTerminalInsertAndDeleteCharacterCapabilities,
                 "Indicates whether the terminal has insert- and delete-character capabilities"
               };
    }
    post
    {
        REQ("", "", has_ic_check(localWin, has_ic_spec));

        /*
         * The has_ic() function indicates whether the terminal has insert- and delete-
         * character capabilities.
         */
        REQ("has_ic.01", "", TODO_REQ());

        /*
         * The has_ic() function returns TRUE if the terminal has insert- and delete-
         * character capabilities.
         */
        REQ("has_ic.02.01", "", TODO_REQ());

        /*
         * Otherwise, it returns FALSE.
         */
        REQ("has_ic.02.02", "", TODO_REQ());

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


specification
IntT has_il_spec(CallContext context)
{
    NCursesWindow* curWin = getNCursesStdWindow(context);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    coverage C
    {
        return { HasTerminalInsertAndDeleteLineCapabilities,
                 "Indicates whether the terminal has insert- and delete-line capabilities"
               };
    }
    post
    {
        REQ("", "", has_il_check(localWin, has_il_spec));

        /*
         * The has_il() function indicates whether the terminal has insert- and delete-
         * line capabilities, or can simulate them using scrolling regions.
         */
        REQ("has_il.01", "", TODO_REQ());

        /*
         * The has_il() function returns TRUE if the terminal has insert- and delete-line
         * capabilities.
         */
        REQ("has_il.02.01", "", TODO_REQ());

        /*
         * Otherwise, it returns FALSE.
         */
        REQ("has_il.02.02", "", TODO_REQ());

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    idcok - enable or disable use of hardware insert- and delete-character features

SYNOPSIS

    #include <curses.h>

    void idcok(WINDOW *win, bool bf);

DESCRIPTION

    The idcok() function specifies whether the implementation may use hardware
    insert- and delete-character features in win if the terminal is so equipped.
    If bf is TRUE, use of these features in win is enabled. If bf is FALSE, use of
    these features in win is disabled. The initial state is TRUE.

RETURN VALUE

    The idcok() function does not return a value.

ERRORS

    No errors are defined.

*/

specification
void idcok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    NCursesWindow* curWin = getWindowMayNULL(context, &win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    post
    {
        // idcok_model(localWin, bf);

        /*
         * The idcok() function specifies whether the implementation may use hardware
         * insert- and delete-character features in win if the terminal is so equipped.
         */
        REQ("idcok.01", "", TODO_REQ());

        /*
         * If bf is TRUE, use of these features in win is enabled.
         */
        REQ("idcok.02", "", TODO_REQ());

        /*
         * If bf is FALSE, use of these features in win is disabled.
         */
        REQ("idcok.03", "", TODO_REQ());

        /*
         * The initial state is TRUE.
         */
        REQ("idcok.04", "", TODO_REQ());

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    immedok - enable or disable immediate terminal refresh

SYNOPSIS

    #include <curses.h>

    void immedok(WINDOW *win, bool bf);

DESCRIPTION

    The immedok() function specifies whether the screen is refreshed whenever the
    window pointed to by win is changed. If bf is TRUE, the window is implicitly
    refreshed on each such change. If bf is FALSE, the window is not implicitly
    refreshed. The initial state is FALSE.

RETURN VALUE

    The immedok() function does not return a value.

ERRORS

    No errors are defined.

*/

specification
void immedok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    NCursesWindow* curWin = getWindowMayNULL(context, &win);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    post
    {
        immedok_model(localWin, bf);

        /*
         * The immedok() function specifies whether the screen is refreshed whenever the
         * window pointed to by win is changed.
         */
        REQ("immedok.01", "", TODO_REQ());

        /*
         * If bf is TRUE, the window is implicitly refreshed on each such change.
         */
        REQ("immedok.02", "", TODO_REQ());

        /*
         * If bf is FALSE, the window is not implicitly refreshed.
         */
        REQ("immedok.03", "", TODO_REQ());

        /*
         * The initial state is FALSE.
         */
        REQ("immedok.04", "", TODO_REQ());

        REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    noqiflush, qiflush - enable/disable queue flushing

SYNOPSIS

    #include <curses.h>

    void noqiflush(void);

    void qiflush(void);

DESCRIPTION

    The qiflush() function causes all output in the display driver queue to be
    flushed whenever an interrupt key (interrupt, suspend, or quit) is pressed.
    The noqiflush() causes no such flushing to occur. The default for the option
    is inherited from the display driver settings.

RETURN VALUE

    These functions do not return a value.

ERRORS

    No errors are defined.

*/

specification
void noqiflush_spec(CallContext context)
{
    NCursesWindow* curWin = getNCursesStdWindow(context);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    coverage C
    {
        return { DisableQueueFlushing, "Disable queue flushing" };
    }
    post
    {
        // noqiflush_model(localWin);

        /*
         * The noqiflush() causes no such flushing to occur.
         */
        REQ("noqiflush.01", "", TODO_REQ());

        /*
         * The default for the option is inherited from the display driver settings.
         */
        REQ("noqiflush.02", "", TODO_REQ());

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


specification
void qiflush_spec(CallContext context)
{
    NCursesWindow* curWin = getNCursesStdWindow(context);
    NCursesWindow* localWin = createNCursesWindow_Local(curWin);

    pre
    {
        return true;
    }
    coverage C
    {
        return { EnableQueueFlushing, "Enable queue flushing" };
    }
    post
    {
        // qiflush_model(localWin);

        /*
         * The qiflush() function causes all output in the display driver queue to be
         * flushed whenever an interrupt key (interrupt, suspend, or quit) is pressed.
         */
        REQ("qiflush.01", "", TODO_REQ());

        /*
         * The default for the option is inherited from the display driver settings.
         */
        REQ("qiflush.02", "", TODO_REQ());

        // REQ("", "check all", check_NCursesWindows(curWin, localWin, CH_ALL, NUM_FAILS));

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    use_env - specify source of screen size information

SYNOPSIS

    #include <curses.h>

    void use_env(bool boolval);

DESCRIPTION

    The use_env() function specifies the technique by which the implementation
    determines the size of the screen. If boolval is FALSE, the implementation
    uses the values of lines and columns specified in the terminfo database. If
    boolval is TRUE, the implementation uses the and environment variables.
    The initial value is TRUE.

    Any call to use_env() must precede calls to initscr(), newterm() or
    setupterm().

RETURN VALUE

    The function does not return a value.

ERRORS

    No errors are defined.

*/

specification
void use_env_spec(CallContext context, IntT boolval)
{
    pre
    {
        /*
         * Any call to use_env() must precede calls to initscr(), newterm() or
         * setupterm().
         */
        REQ("app.use_env.03", "", TODO_REQ());

        return true;
    }
    post
    {
        /*
         * The use_env() function specifies the technique by which the implementation
         * determines the size of the screen.
         */
        REQ("use_env.01", "", TODO_REQ());

        /*
         * If boolval is FALSE, the implementation uses the values of lines and columns
         * specified in the terminfo database.
         */
        REQ("use_env.02.01", "", TODO_REQ());

        /*
         * If boolval is TRUE, the implementation uses the and environment variables.
         */
        REQ("use_env.02.02", "", TODO_REQ());

        /*
         * The initial value is TRUE.
         */
        REQ("use_env.02.03", "", TODO_REQ());

        return true;
    }
}
void onUse_Env(CallContext context, IntT boolval)
{
    set_use_env(context, boolval);
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

const int NUM_FAILS = 5;

void clearok_model(NCursesWindow* curWnd, IntT bf, IntT clearok_spec)
{
    /*
     * The clearok() function assigns the value of bf to an internal flag in the
     * specified window that governs clearing of the screen during a refresh.
     */
    IMPLEMENT_REQ("clearok.02");

    if (clearok_spec == SUT_OK)
    {
        curWnd->clear = bf;
    }
}

void echo_model(NCursesScreen* curScr, IntT echo_spec)
{
    if (echo_spec == SUT_OK)
    {
//        curScr->echo = true;
    }
}

IntT has_ic_model(NCursesWindow* curWnd)
{
    return true;
}

IntT has_il_model(NCursesWindow* curWnd)
{
    return true;
}

void idcok_model(NCursesWindow* curWnd, IntT bf)
{
    curWnd->idcok = bf /* && has_ic() */;
}

void idlok_model(NCursesWindow* curWnd, IntT bf, IntT idlok_spec)
{
    if (idlok_spec == SUT_OK)
    {
        curWnd->idlok = bf /* && (has_il() || change_scroll_region) */;
    }
}

void immedok_model(NCursesWindow* curWnd, IntT bf)
{
    curWnd->immed = bf;
}

void leaveok_model(NCursesWindow* curWnd, IntT bf, IntT leaveok_spec)
{
    if (leaveok_spec == SUT_OK)
    {
        curWnd->leaveok = bf;
    }
}

void noecho_model(NCursesScreen* curScr, IntT noecho_spec)
{
    if (noecho_spec == SUT_OK)
    {
//        curScr->echo = false;
    }
}

void noqiflush_model(NCursesWindow* curWnd)
{
//     curWnd->qiflush = false;
}

void qiflush_model(NCursesWindow* curWnd)
{
//     curWnd->qiflush = true;
}

void scrollok_model(NCursesWindow* curWnd, IntT bf, IntT scrollok_spec)
{
    if (scrollok_spec == SUT_OK)
    {
        curWnd->scroll = bf;
    }
}

void setscrreg_model(NCursesWindow* curWnd, IntT top, IntT bot, IntT setscrreg_spec)
{
    if (setscrreg_spec == SUT_OK)
    {
        curWnd->regtop = top;
        curWnd->regbottom = bot;
    }
}

bool has_ic_check(NCursesWindow* curWnd, IntT has_ic_spec)
{
/*
    IntT has_ic = has_ic_model(curWnd);
    if ((has_ic && has_ic_spec) || (!has_ic && !has_ic_spec))
        return true;
    else
        return false;
*/
    return true;
}

bool has_il_check(NCursesWindow* curWnd, IntT has_il_spec)
{
/*
    IntT has_ic = has_ic_model(curWnd);
    if ((has_ic && has_ic_spec) || (!has_ic && !has_ic_spec))
        return true;
    else
        return false;
*/
    return true;
}
