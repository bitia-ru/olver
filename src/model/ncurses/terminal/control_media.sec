/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "ncurses/terminal/control_media.seh"
#include "common/common_media.seh"


/********************************************************************/
/**                    Initialization Function                     **/
/********************************************************************/
void initNcursesTerminalControlSubsystem(void)
{
    // Set up mediators
    set_mediator_clearok_spec(clearok_media);
    set_mediator_echo_spec(echo_media);
    set_mediator_has_ic_spec(has_ic_media);
    set_mediator_has_il_spec(has_il_media);
    set_mediator_idcok_spec(idcok_media);
    set_mediator_idlok_spec(idlok_media);
    set_mediator_immedok_spec(immedok_media);
    set_mediator_leaveok_spec(leaveok_media);
    set_mediator_noecho_spec(noecho_media);
    set_mediator_noqiflush_spec(noqiflush_media);
    set_mediator_qiflush_spec(qiflush_media);
    set_mediator_scrollok_spec(scrollok_media);
    set_mediator_setscrreg_spec(setscrreg_media);
    set_mediator_use_env_spec(use_env_media);
}


/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** clearok_spec **/
mediator clearok_media for specification
IntT clearok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "clearok:$(ptr)$(int)",
                         create_VoidTPtrObj(win),
                         create_IntTObj(bf)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, &win, clearok_spec);
    }
}


/** echo_spec **/
mediator echo_media for specification
IntT echo_spec(CallContext context)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "echo");
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, NULL, echo_spec);
    }
}


/** has_ic_spec **/
mediator has_ic_media for specification
IntT has_ic_spec(CallContext context)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "has_ic");
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, NULL, has_ic_spec);
    }
}


/** has_il_spec **/
mediator has_il_media for specification
IntT has_il_spec(CallContext context)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "has_il");
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, NULL, has_il_spec);
    }
}


/** idcok_spec **/
mediator idcok_media for specification
void idcok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "idcok:$(ptr)$(int)",
                         create_VoidTPtrObj(win),
                         create_IntTObj(bf)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }

        destroy_TSCommand(&command);
    }
    state
    {
        onNCursesUniversal(context, &win, SUT_OK);
    }
}


/** idlok_spec **/
mediator idlok_media for specification
IntT idlok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "idlok:$(ptr)$(int)",
                         create_VoidTPtrObj(win),
                         create_IntTObj(bf)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, &win, idlok_spec);
    }
}


/** immedok_spec **/
mediator immedok_media for specification
void immedok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "immedok:$(ptr)$(int)",
                         create_VoidTPtrObj(win),
                         create_IntTObj(bf)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }

        destroy_TSCommand(&command);
    }
    state
    {
        onNCursesUniversal(context, &win, SUT_OK);
    }
}


/** leaveok_spec **/
mediator leaveok_media for specification
IntT leaveok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "leaveok:$(ptr)$(int)",
                         create_VoidTPtrObj(win),
                         create_IntTObj(bf)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, &win, leaveok_spec);
    }
}


/** noecho_spec **/
mediator noecho_media for specification
IntT noecho_spec(CallContext context)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "noecho");
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, NULL, noecho_spec);
    }
}


/** noqiflush_spec **/
mediator noqiflush_media for specification
void noqiflush_spec(CallContext context)
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "noqiflush");
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }

        destroy_TSCommand(&command);
    }
    state
    {
        onNCursesUniversal(context, NULL, SUT_OK);
    }
}


/** qiflush_spec **/
mediator qiflush_media for specification
void qiflush_spec(CallContext context)
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "qiflush");
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }

        destroy_TSCommand(&command);
    }
    state
    {
        onNCursesUniversal(context, NULL, SUT_OK);
    }
}


/** scrollok_spec **/
mediator scrollok_media for specification
IntT scrollok_spec(CallContext context, WindowTPtr win, IntT bf)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "scrollok:$(ptr)$(int)",
                         create_VoidTPtrObj(win),
                         create_IntTObj(bf)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, &win, scrollok_spec);
    }
}


/** setscrreg_spec **/
//This mediator refers to: setscrreg, wsetscrreg
mediator setscrreg_media for specification
IntT setscrreg_spec(CallContext context, WindowTPtr* win, IntT top, IntT bot)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();

        if (win == NULL)
        {
            format_TSCommand(&command, "setscrreg:$(int)$(int)",
                             create_IntTObj(top),
                             create_IntTObj(bot)
                            );
        }
        else
        {
            format_TSCommand(&command, "wsetscrreg:$(ptr)$(int)$(int)",
                             create_VoidTPtrObj(*win),
                             create_IntTObj(top),
                             create_IntTObj(bot)
                            );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onNCursesUniversal(context, win, setscrreg_spec);
    }
}


/** use_env_spec **/
mediator use_env_media for specification
void use_env_spec(CallContext context, IntT boolval)
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "use_env:$(int)",
                         create_IntTObj(boolval)
                        );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }

        destroy_TSCommand(&command);
    }
    state
    {
        onUse_Env(context, boolval);
    }

}

