/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */


#include "ncurses/terminal/terminal_model.seh"
#include "process/process/process_model.seh"


#pragma SEC subsystem terminal "ncurses.terminal"



/*
   The group of functions 'ncurses.terminal.terminal' consists of:
       delay_output [1]
       delscreen [1]
       endwin [1]
       filter [1]
       initscr [1]
       longname [1]
       newterm [1]
       set_term [1]
       termattrs [1]
       vidattr [1]
       vidputs [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    delay_output - delay output

SYNOPSIS

    #include <curses.h>
    int delay_output(int ms);

DESCRIPTION

    On terminals that support pad characters, delay_output() pauses the output
    for at least ms milliseconds.Otherwise, the length of the delay is
    unspecified.

RETURN VALUE

    Upon successful completion, delay_output() returns OK. Otherwise, it
    returns ERR.

ERRORS

    No errors are defined.
*/
specification
IntT delay_output_spec( CallContext context, IntT ms)
{
    pre
    {
        return true;
    }
    post
    {
        if (delay_output_spec == SUT_OK)
        {
            /*
            * Upon successful completion, delay_output() returns OK.
            */
            REQ("delay_output.02.01", "Function shall return OK", delay_output_spec == SUT_OK);

            /*
            * On terminals that support pad characters, delay_output() pauses the output for
            * at least ms milliseconds.
            */
            REQ("delay_output.01.01", "", TODO_REQ());

            /*
            * Otherwise, the length of the delay is unspecified.
            */
            REQ("delay_output.01.02", "", TODO_REQ());

        }
        else
        {
            /*
            * Otherwise, it returns ERR.
            */
            REQ("delay_output.02.02", "Function shall return ERR", delay_output_spec == SUT_ERR);

        }

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

--------------------------------------------------------------------------------

NAME

    delscreen - free storage associated with a screen

SYNOPSIS

    #include <curses.h>
    void delscreen(SCREEN *sp);

DESCRIPTION

    The delscreen() function frees storage associated with the SCREEN pointed
    to by sp.

RETURN VALUE

    The delscreen() function does not return a value.

ERRORS

    No errors are defined.
*/

specification
void delscreen_spec( CallContext context, ScreenTPtr scr)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { FreeStorageAssociatedWithScreen, "Free storage associated with a screen" };
    }
    post
    {
        NCursesTerminal* term = findInitedTerminal(context, scr);

        /*
        * The delscreen() function frees storage associated with the SCREEN pointed to by
        * sp.
        */
        REQ("?delscreen.01", "Terminal screen shall be deleted", term == NULL);

        return true;
    }
}

void onDelScreen( CallContext context, ScreenTPtr scr)
{
    NCursesTerminal* term = findInitedTerminal(context, scr);

    remove_List(getNCursesInitedTerminals(context), indexOf_List(getNCursesInitedTerminals(context), term));
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    endwin - suspend Curses session

SYNOPSIS

    #include <curses.h>
    int endwin(void);

DESCRIPTION

    The endwin() function restores the terminal after Curses activity by at
    least restoring the saved shell terminal mode, flushing any output to the
    terminal and moving the cursor to the first column of the last line of the
    screen. Refreshing a window resumes program mode. The application must call
    endwin() for each terminal being used before exiting. If newterm() is
    called more than once for the same terminal, the first screen created must
    be the last one for which endwin() is called.

RETURN VALUE

    Upon successful completion, endwin() returns OK. Otherwise, it returns ERR.

ERRORS

    No errors are defined.
*/
specification
IntT endwin_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { SuspendCursesSession, "Suspend Curses session" };
    }
    post
    {
        if (endwin_spec==SUT_EOK)
        {
            /*
            * Upon successful completion, endwin() returns OK.
            */
            REQ("endwin.05.01", "Function shall return OK", endwin_spec==SUT_EOK);


            /*
            * The endwin() function restores the terminal after Curses activity by at least
            * restoring the saved shell terminal mode,
            */
            REQ("endwin.01.01", "", TODO_REQ());

            /*
            * flushing any output to the terminal
            */
            REQ("endwin.01.02", "", TODO_REQ());

            /*
            * and moving the cursor to the first column of the last line of the screen.
            */
            REQ("endwin.01.03", "", TODO_REQ());

            /*
            * Refreshing a window resumes program mode.
            */
            REQ("endwin.02", "", TODO_REQ());
        }
        else
        {
            /*
            * Otherwise, it returns ERR.
            */
            REQ("endwin.05.02", "Function shall return ERR", endwin_spec == SUT_ERR);
        }

        return true;
    }
}


void onEndWin(CallContext context, IntT endwin_spec)
{
    set_endwin_no_refresh(1);
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

--------------------------------------------------------------------------------

NAME

    filter - disable use of certain terminal capabilities

SYNOPSIS

    #include <curses.h>
    void filter(void);

DESCRIPTION

    The filter() function changes the algorithm for initialising terminal
    capabilities that assume that the terminal has more than one line. A
    subsequent call to initscr() or newterm() performs the following additional
    actions:

    Disable use of clear, cud, cud1, cup, cuu1 and vpa.

    Set the value of the home string to the value of the cr. string

    Set lines equal to 1.

    Any call to filter() must precede the call to initscr() or newterm().

RETURN VALUE

    The filter() function does not return a value.

ERRORS

    No errors are defined.
*/
specification
void filter_spec( CallContext context)
{
    ProcessState* ps =getProcessState_CallContext(context);

    pre
    {
        /*
         * Any call to filter() must precede the call to initscr() or newterm().
         */
        REQ("app.filter.03", "initscr() or newterm() shall not be called", isNULL_VoidTPtr(ps->stdscr_wnd));

        return true;
    }
    coverage C
    {
        return { DisableUseOfCertainTerminalCapabilities, "Disable use of certain terminal capabilities" };
    }
    post
    {



        return true;
    }
}

void onFilter( CallContext context)
{
    setTerminalFilterSet(context, true);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group


  refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    initscr, newterm - screen initialisation functions

SYNOPSIS

    #include <curses.h>
    WINDOW *initscr(void);
    SCREEN *newterm(char *type, FILE *outfile, FILE *infile);

DESCRIPTION

    The initscr() function determines the terminal type and initialises all
    implementation data structures. The environment variable specifies the
    terminal type. The initscr() function also causes the first refresh
    operation to clear the screen. If errors occur, initscr() writes an
    appropriate error message to standard error and exits.The only functions
    that can be called before initscr() or newterm() are filter(),
    ripoffline(), slk_init(), use_env() and the functions whose prototypes are
    defined in <term.h>.Portable applications must not call initscr() twice.

    The newterm() function can be called as many times as desired to attach a
    terminal device.The type argument points to a string specifying the
    terminal type, except that if type is a null pointer, the environment
    variable is used. The outfile and infile arguments are file pointers for
    output to the terminal and input from the terminal, respectively. It is
    unspecified whether Curses modifies the buffering mode of these file
    pointers. The newterm() function should be called once for each terminal.

    The initscr() function is equivalent to:


        newterm(getenv("TERM"), stdout, stdin);
        return stdscr;


    If the current disposition for the signals SIGINT, SIGQUIT or SIGTSTP is
    SIGDFL, then initscr() may also install a handler for the signal, which
    may remain in effect for the life of the process or until the process
    changes the disposition of the signal.

    The initscr() and newterm() functions initialise the cur_term external
    variable.

RETURN VALUE

    Upon successful completion, initscr() returns a pointer to stdscr.
    Otherwise, it does not return.

    Upon successful completion, newterm() returns a pointer to the specified
    terminal. Otherwise, it returns a null pointer.

ERRORS

    No errors are defined.
*/
specification typedef struct InitScrReturnType InitScrReturnType = {};

InitScrReturnType * create_InitScrReturnType(
    WindowTPtr ptr,
    IntT cols,
    IntT lines
    )
{
    return create(&type_InitScrReturnType, ptr, cols, lines );
}

bool isScreenCleared(CallContext context)
{
    NCursesWindow* wnd=getNCursesStdWindow(context);
    IntT i=0;
    ChTypeT backCh = create_emptyChTypeT();

    for (i=0;i<wnd->ncols*wnd->nlines;i++)
    {
        if (!equals_ChTypeT(getElement_NCursesWindow_Offset(wnd, i), backCh))
        {
            return false;
        }
    }

    return true;

}


specification
InitScrReturnType* initscr_spec( CallContext context)
{

    pre
    {
        /*
        * Portable applications must not call initscr() twice.
        */
        REQ("app.initscr.06", "initscr() shall not be called twice",
            isNULL_VoidTPtr(getNCursesCurrentWindow(context)));


        return true;
    }
    coverage C
    {
        return { ScreenInitialisationFunction, "Screen initialisation function" };
    }
    post
    {
        List * riplist;
        int i, riplist_size;
        IntT lines, cols;

        /*
         * The initscr() function determines the terminal type and initialises all
         * implementation data structures.
         */
        REQ_UNCHECKABLE("initscr.01", "This is implemention specific information");

        /*
        * The initscr() function also causes the first refresh operation to clear the
        * screen.
        */
        //REQ("initscr.03", "Screen shall be cleared", isScreenCleared(context));

        /*
        * The initscr() and newterm() functions initialise the cur_term external variable.
        */
        REQ("initscr.08", "cur_term external variable shall be initialized", !isNULL_VoidTPtr(get_cur_term(context)));

        /*
        * Upon successful completion, initscr() returns a pointer to stdscr.
        */
        REQ("?initscr.09.01", "Pointer sto stdscr shall be valid", equals_VoidTPtr(getNCursesCurrentWindow(context),
            initscr_spec->ptr));

        /*
        * If errors occur, initscr() writes an appropriate error message to standard
        * error and exits.
        */
        REQ_UNCHECKABLE("initscr.04", "In the case of error program will not reach this point");

        /*
        * Otherwise, it does not return.
        */
        REQ_UNCHECKABLE("initscr.09.02", "In the case of error program will not reach this point");


        /*[ Ripoffline REQs]*/
        riplist = getRipLines(context);
        riplist_size = size_List(riplist);
        lines = getTermNLines(context);
        cols = getTermNCols(context);

        if( initscr_spec->cols != cols ){
            // The size of screen returned differs from a model one
            if( riplist_size == 0){
                // Resume execution with new size
                setTermNLines(context, initscr_spec->lines);
                setTermNCols(context, initscr_spec->cols);
            }
        }

        if(riplist_size){
            REQ("","columns number check, ripoffline and slk checks cannot be trusted if failed", initscr_spec->cols == cols);
        }

        for(i=0;i<riplist_size;i++)
        {
            RipLineT * ripline;

            ripline = get_List(riplist,i);

            if(ripline->line>=0)
            {
                /*
                 * If line is positive, one line is removed from the beginning of stdscr;
                 */
                IMPLEMENT_REQ("?ripoffline.03.01");

                lines--;
            }else
            if(ripline->line<0)
            {
                /*
                 * if line is negative, one line is removed from the end.
                 */
                IMPLEMENT_REQ("?ripoffline.03.02");

                lines--;
            }

            if(ripline->init)
            {
                /*
                 * When the subsequent call is made, the function pointed to by init is called...
                 */
                REQ("ripoffline.05.all_called","All init-functions are called.", !isNULL_VoidTPtr(ripline->win));

            }
        }

       /*if(lines != initscr_spec->lines)
        {
            DUMP("lines == %d, initscr_spec->lines ==  %d\n", lines , initscr_spec->lines);
        }*/
        if(riplist_size){
            /*
            * Removal occurs during the subsequent call to initscr() or newterm().
            */
            REQ("ripoffline.04", "Depends on ripoffline.03.01;ripoffline.03.02, remove lines from stdscr",
                    initscr_spec->lines == lines);
        }
        
        VERBOSE("Linux lines: %d\n", initscr_spec->lines);
        VERBOSE("Model lines: %d\n", lines);
        
        REQ("","columns number check", initscr_spec->cols == cols);

        return true;
    }
}

void initscr_model(CallContext context, WindowTPtr win, IntT lines, IntT cols)
{
    IntT Scr_nLines = getTermNLines(context);
    IntT Scr_nCols = getTermNCols(context);
    
    if(  Scr_nCols != cols ){
        // The size of screen returned differs from a model one
        List * riplist = getRipLines(context);
        int riplist_size = size_List(riplist);
        
        if( riplist_size == 0 ){
            // Create model window with correct size
            Scr_nLines = lines;
            Scr_nCols = cols;
        }
    }
    
    create_stdScreenContent(Scr_nLines, Scr_nCols);
    create_doupdate_screen(Scr_nLines, Scr_nCols);
    set_refresh_forbidden(0);

    setNCursesStdWindow(context, win);

    create_defaultNCursesWindow(context, win, Scr_nLines, Scr_nCols);

    registerStdTerminal(context);
    setVariables_StdTerminal(context);
    readTerminfo(context, create_CString(OLVERCT_TERMINFO_PATH));

    if (getTerminalFilterSet(context))
    {
        NCursesTerminal * stdterm = getNCursesStdTerminal(context);
        CString* crString = (CString*) getItem_NCursesTerminfo(context, create_CString("cr"));

        /*
         * A subsequent call to initscr() or newterm() performs the following additional
         * actions:
         *
         * Disable use of clear, cud, cud1, cup, cuu1 and vpa.
         */
        IMPLEMENT_REQ("filter.02.01");

        delItem_NCursesTerminfo(context, create_CString("clear"), 's');
        delItem_NCursesTerminfo(context, create_CString("cud"), 's');
        delItem_NCursesTerminfo(context, create_CString("cud1"), 's');
        delItem_NCursesTerminfo(context, create_CString("cup"), 's');
        delItem_NCursesTerminfo(context, create_CString("cuu1"), 's');
        delItem_NCursesTerminfo(context, create_CString("vpa"), 's');

        /*
         * A subsequent call to initscr() or newterm() performs the following additional
         * actions:
         *
         * Set the value of the home string to the value of the cr. string
         */
        IMPLEMENT_REQ("filter.02.02");

        addItem_NCursesTerminfo(context, create_CString("home"), crString, 's');

        /*
         * A subsequent call to initscr() or newterm() performs the following additional
         * actions:
         *
         * Set lines equal to 1.
         */
        IMPLEMENT_REQ("filter.02.03");

        addItem_NCursesTerminfo(context, create_CString("lines"), create_IntTObj(1), 'n');

        setTermNLines(context, 1);
    }

    if(!get_use_env(context))
    {
        NCursesTerminal* term = getNCursesStdTerminal(context);

        setTermNLines(context,  *( (IntTObj*)    getItem_NCursesTerminfo(context,
                                                create_CString("lines"))) );
        setTermNCols(context,  *( (IntTObj*)    getItem_NCursesTerminfo(context,
                                                create_CString("cols"))) );
    }
}


void onInit_scr(CallContext context, InitScrReturnType* initscr_spec)
{
    initscr_model(context, initscr_spec->ptr, initscr_spec->lines, initscr_spec->cols);

}


specification typedef struct NewTermReturnType NewTermReturnType = {};

NewTermReturnType * create_NewTermReturnType(
    WindowTPtr stdscr,
    IntT       cols,
    IntT       lines,
    VoidTPtr   SCREEN_ptr,
    CString*   type
    )
{
    return create(&type_NewTermReturnType, stdscr, cols, lines, SCREEN_ptr, type);
}

specification
NewTermReturnType* newterm_spec( CallContext context, CString* type, CString* outfile, CString* infile)
{
    pre
    {
        if (type!=NULL)
        {
            IntT i;

            for (i=0;i<size_List(getNCursesInitedTerminals(context));i++)
            {
                NCursesTerminal* cterm=(NCursesTerminal*)get_List(getNCursesInitedTerminals(context), i);
                /*
                * The newterm() function should be called once for each terminal.
                */
                REQ("app.newterm.05", "Terminal shall not be initialized", !equals(cterm->screen->term, type));
            }
        }

        return true;
    }
    coverage C
    {
        return { ScreenInitialisationFunction, "Screen initialisation function" };
    }
    post
    {
        if (!isNULL_VoidTPtr(newterm_spec->SCREEN_ptr))
        {
            NCursesTerminal* stdTerm = getNCursesStdTerminal(context);
            /*
            * Upon successful completion, newterm() returns a pointer to the specified
            * terminal.
            */
            REQ("?newterm.09.01", "Pointer to terminal shall be returned",
                equals_VoidTPtr(stdTerm->screen->address, newterm_spec->SCREEN_ptr));

            /*
            * The initscr() and newterm() functions initialise the cur_term external variable.
            */
            REQ("newterm.08", "cur_term external variable shall be initialized",
                !isNULL_VoidTPtr(get_cur_term(context)));

            /*
            * It is unspecified whether Curses modifies the buffering mode of these file
            * pointers.
            */
            REQ_UNCHECKABLE("newterm.04", "Can not check buffering mode");

            if (type!=NULL)
            {
                /*
                * The type argument points to a string specifying the terminal type, except that
                * if type is a null pointer, the environment variable is used.
                */
                REQ("?newterm.02", "Screen type shall be valid",
                    equals(stdTerm->screen->term, type));
            }
            else
            {
                /*
                * The type argument points to a string specifying the terminal type, except that
                * if type is a null pointer, the environment variable is used.
                */
                REQ("?newterm.02", "Screen type shall be valid",
                    stdTerm->screen->term != NULL);
            }
        }
        else
        {
            /*
            * Otherwise, it returns a null pointer.
            */
            REQ("?newterm.09.02", "Function shall return NULL",
                isNULL_VoidTPtr(newterm_spec->SCREEN_ptr));
        }

        /*
        * If the current disposition for the signals SIGINT, SIGQUIT or SIGTSTP is
        * SIGDFL, then initscr() may also install a handler for the signal, which may
        * remain in effect for the life of the process or until the process changes the
        * disposition of the signal.
        */
        REQ("newterm.07", "", TODO_REQ());

        return true;
    }
}

void onNewTerm(CallContext context, CString* type, CString* outfile, CString* infile, NewTermReturnType* newterm_spec)
{
    NCursesTerminal *term;

    if (!isNULL_VoidTPtr(newterm_spec->SCREEN_ptr))
    {
        initscr_model(context, newterm_spec->stdscr, newterm_spec->lines, newterm_spec->cols);
        term = getNCursesStdTerminal(context);
        term->screen = create_NCursesScreen(newterm_spec->SCREEN_ptr,  newterm_spec->type, infile, outfile);

        append_List(getNCursesInitedTerminals(context), term);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    longname - get verbose description of current terminal

SYNOPSIS

    #include <curses.h>
    char *longname(void);

DESCRIPTION

    The longname() function generates a verbose description of the current
    terminal.The maximum length of a verbose description is 128 bytes.It is
    defined only after the call to initscr() or newterm().

RETURN VALUE

    Upon successful completion, longname() returns a pointer to the description
    specified above. Otherwise, it returns a null pointer on error.

ERRORS

    No errors are defined.
*/

specification
CString* longname_spec( CallContext context)
{
    pre
    {
        /*
        * It is defined only after the call to initscr() or newterm().
        */
        REQ("app.longname.03", "initscr() or newterm() shall be called first",
            !isNULL_VoidTPtr(getNCursesCurrentWindow(context)));

        return true;
    }
    coverage C
    {
        return { GetVerboseDescriptionOfCurrentTerminal, "Get verbose description of current terminal" };
    }
    post
    {
        if (longname_spec!=NULL)
        {
            /*
            * Upon successful completion, longname() returns a pointer to the description
            * specified above.
            */
            REQ("longname.04.01", "Function shall return not NULL", longname_spec!=NULL);

            /*
            * The maximum length of a verbose description is 128 bytes.
            */
            REQ("longname.02", "The maximum length of a verbose description is 128 bytes",
                length_CString(longname_spec)<=128);

        }
        else
        {
            /*
            * Otherwise, it returns a null pointer on error.
            */
            REQ("longname.04.02", "Function shall return NULL", longname_spec==NULL);
        }

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    set_term - switch between screens

SYNOPSIS

    #include <curses.h>
    SCREEN *set_term(SCREEN *new);

DESCRIPTION

    The set_term() function switches between different screens. The new
    argument specifies the new current screen.

RETURN VALUE

    Upon successful completion, set_term() returns a pointer to the previous
    screen.Otherwise, it returns a null pointer.

ERRORS

    No errors are defined.
*/

specification typedef struct SetTermReturnType SetTermReturnType = {};

SetTermReturnType * create_SetTermReturnType(
    ScreenTPtr scr,
    WindowTPtr stdscr
    )
{
    return create(&type_SetTermReturnType, scr, stdscr);
}

NCursesTerminal* findInitedTerminal(CallContext context, ScreenTPtr new_term)
{
    IntT i;

    for(i=0;i<size_List(getNCursesInitedTerminals(context));i++)
    {
        NCursesTerminal* term=(NCursesTerminal*)get_List(getNCursesInitedTerminals(context), i);
        if (equals_VoidTPtr(term->screen->address, new_term))
        {
            return term;
        }
    }

    return NULL;
}


specification
SetTermReturnType* set_term_spec( CallContext context, ScreenTPtr new_term)
{
    NCursesScreen* scr = clone(getNCursesStdScreen(context));

    pre
    {
        return true;
    }
    post
    {
        NCursesTerminal* switched_term = findInitedTerminal(context, new_term);

        if (!isNULL_VoidTPtr(set_term_spec->scr))
        {
            /*
            * Upon successful completion, set_term() returns a pointer to the previous screen.
            */
            REQ("set_term.03.01", "Return value shall be valid", equals_VoidTPtr(set_term_spec->scr, scr->address));
        }
        else
        {
            /*
            * Otherwise, it returns a null pointer.
            */
            REQ("set_term.03.02", "Function shall return NULL", isNULL_VoidTPtr(set_term_spec->scr));
        }

        /*
        * The set_term() function switches between different screens.
        */
        REQ("set_term.01", "The set_term() function switches between different screens",
            equals_VoidTPtr(get_cur_term(context), switched_term->address));


        return true;
    }
}




void onSetTerm(CallContext context, ScreenTPtr new_term, SetTermReturnType* set_term_spec)
{
    if (!isNULL_VoidTPtr(set_term_spec->scr))
    {
        NCursesTerminal* term=findInitedTerminal(context, new_term);

        setNCursesStdWindow(context,  set_term_spec->stdscr);
        setNCursesStdTerminal(context, term->address);
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers


The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    termattrs - get supported terminal video attributes

SYNOPSIS

    #include <curses.h>
    chtype termattrs(void);
    attr_t term_attrs(void);

DESCRIPTION

    The termattrs() function extracts the video attributes of the current
    terminal which is supported by the chtype data type.

    The term_attrs() function extracts information for the video attributes of
    the current terminal which is supported for a cchar_t

RETURN VALUE

    The termattrs() function returns a logical OR of A_ values of all video
    attributes supported by the terminal.

    The term_attrs() function returns a logical OR of WA_ values of all video
    attributes supported by the terminal.

ERRORS

    No errors are defined.
*/

ChTypeT termattrs_model(CallContext context)
{
    ChTypeT res = create_emptyChTypeT();
    NCursesTerminal * stdterm = getNCursesStdTerminal(context);

    res.altcharset = (getItem_NCursesTerminfo(context, create_CString("rmacs")) != NULL);  // Alternate character set
    res.blink  = (getItem_NCursesTerminfo(context, create_CString("blink")) != NULL);      // Blinking
    res.bold  = (getItem_NCursesTerminfo(context, create_CString("bold")) != NULL);        // Extra bright or bold
    res.dim  = (getItem_NCursesTerminfo(context, create_CString("dim")) != NULL);          // Half bright
    res.invis  = (getItem_NCursesTerminfo(context, create_CString("invis")) != NULL);      // Invisible
    res.protect  = (getItem_NCursesTerminfo(context, create_CString("prot")) != NULL);     // Protected
    res.reverse = (getItem_NCursesTerminfo(context, create_CString("rev")) != NULL);       // Reverse video
    res.standout = (getItem_NCursesTerminfo(context, create_CString("smso")) != NULL);     // Best highlighting mode of the terminal
    res.underline = (getItem_NCursesTerminfo(context, create_CString("rmul")) != NULL);    // Underlining

    res.letter = 0;

    return res;
}

specification
ChTypeT termattrs_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { GetSupportedTerminalVideoAttributes, "get supported terminal video attributes" };
    }
    post
    {
        ChTypeT model_value = termattrs_model(context);

        /*
        * The termattrs() function extracts the video attributes of the current terminal
        * which is supported by the chtype data type.
        */
        /*
        * The termattrs() function returns a logical OR of A_ values of all video
        * attributes supported by the terminal.
        */
        REQ("termattrs.01;termattrs.02", "Return value shall be valid", equals_ChTypeT(termattrs_spec, model_value));

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

--------------------------------------------------------------------------------

NAME

    vidattr, vid_attr, vidputs, vid_puts - output attributes to the terminal

SYNOPSIS

    #include <curses.h>
    int vidattr(chtype attr);
    int vid_attr(attr_t attr, short color_pair_number, void *opt);
    int vidputs(chtype attr, int (*putfunc)(int));
    int vid_puts(attr_t attr, short color_pair_number, void *opt, int
        (*putfunc)(int));

DESCRIPTION

    These functions output commands to the terminal that change the terminal's
    attributes.

    If the terminfo database indicates that the terminal in use can display
    characters in the rendition specified by attr, then vidattr() outputs one
    or more commands to request that the terminal display subsequent characters
    in that rendition. The function outputs by calling putchar(). The vidattr()
    function neither relies on nor updates the model which Curses maintains of
    the prior rendition mode.

    The vidputs() function computes the same terminal output string that
    vidattr() does, based on attr, but vidputs() outputs by calling the
    user-supplied function putfunc. The vid_attr() and vid_puts() functions
    correspond to vidattr() and vidputs() respectively, but take a set of
    arguments, one of type attr_t for the attributes, short for the colour
    pair number and a void *, and thus support the attribute constants with
    the WA_ prefix.

    The opts argument is reserved for definition in a future edition of this
    document. Currently, the application must provide a null pointer as opts.

    The user-supplied function putfunc (which can be specified as an argument
    to either vidputs() or vid_puts()) is either putchar() or some other
    function with the same prototype. Both the vidputs() and the vid_puts()
    function ignore the return value of putfunc.

RETURN VALUE

    Upon successful completion, these functions return OK.Otherwise, they
    return ERR.

ERRORS

    No errors are defined.
*/

specification typedef struct VidAttrReturnType VidAttrReturnType = {};

VidAttrReturnType * create_VidAttrReturnType(
    IntT retVal
    )
{
    return create(&type_VidAttrReturnType, retVal);
}

/** vidattr_spec **/
//This specification refers to: vidattr, vidputs
specification
VidAttrReturnType* vidattr_spec( CallContext context, ChTypeT ch, bool usePutfunc)
{
    NCursesPosition* oldPos= clone(getWindowPositionMayNULL(getWindowMayNULL(context, NULL), NULL));

    if (usePutfunc) {  FILTER("vidputs"); }
    else{  FILTER("vidattr"); }

    pre
    {
        return true;
    }
    post
    {
        if (vidattr_spec->retVal == SUT_EOK)
        {
            CByteArray*    ba     = ncursesScreenDump(context);
            NCursesWindow* stdscr = getNCursesStdWindow(context);
            ChTypeTArray*  charr  = create_ChTypeTArray_ScreenDump(ba, stdscr->ncols, stdscr->nlines);

            /*
            * Upon successful completion, these functions return OK.
            */
            REQ("vidattr.06.01;vidputs.06.01", "Function shall return OK", vidattr_spec->retVal == SUT_EOK);

            if(! equals_ChTypeT(charr->arr[oldPos->x+oldPos->y * stdscr->ncols ], ch))
            {
                DUMP("$(obj)\n$(obj)\n", create_ChTypeTObj(charr->arr[oldPos->x+oldPos->y * stdscr->ncols ]), create_ChTypeTObj(ch));
                DUMP("$(obj)\n$(obj)\n", create_ChTypeTObj(getElement_NCursesWindow(getWindowMayNULL(context, NULL), oldPos)), create_ChTypeTObj(ch));
                DUMP("\n");

                DUMP_screens(context);
            }
            /*
            * If the terminfo database indicates that the terminal in use can display
            * characters in the rendition specified by attr, then vidattr() outputs one or
            * more commands to request that the terminal display subsequent characters in
            * that rendition.
            */
            REQ("vidattr.02", "Read character shall be valid",
                equals_ChTypeT(charr->arr[oldPos->x+oldPos->y * stdscr->ncols ], ch));
        }
        else
        {
            /*
            * Otherwise, they return ERR.
            */
            REQ("vidattr.06.02;vidputs.06.02", "Function shall return ERR", vidattr_spec->retVal == SUT_ERR);
        }


        return true;
    }
    FILTER_CLEAN;
}

void onVidattr( CallContext context, ChTypeT ch, VidAttrReturnType* vidattr_spec)
{
    if (vidattr_spec->retVal == SUT_EOK)
    {
        NCursesWindow* stdscr = getNCursesStdWindow(context);

        advanceCursorOnePos(stdscr);
    }
}

/*
specification
ReturnType vidputs_spec( CallContext context, ... )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        return true;
    }
}
****/

specification typedef struct RipofflineInitfuncCallT RipofflineInitfuncCallT = {};

RipofflineInitfuncCallT * create_RipofflineInitfuncCallT(
    CallContext context,
    WindowTPtr win,
    IntT columns
    )
{
    return create(&type_RipofflineInitfuncCallT,
        context,
        win,
        columns
        );
}

reaction RipofflineInitfuncCallT* ripoffline_initfunc_call(void)
{
    post
    {
        RipofflineInitfuncCallT* data = ripoffline_initfunc_call;
        WindowState * win_state;
        List * riplist;
        RipLineT * ripline;
        IntT Scr_nLines = getTermNLines(data->context);

        /* When the subsequent call is made, the function pointed to by init is called
         * with two arguments: a WINDOW pointer to the one-line window that has been
         * allocated and an integer with the number of columns in the window.
         */
        REQ("ripoffline.05.window","win!=NULL", !isNULL_VoidTPtr(data->win));

        win_state = window_state(data->context, data->win);
        riplist = getRipLines(data->context);
        ripline = findRipLine_byWinOrigin(riplist, win_state, Scr_nLines);

        REQ("ripoffline.05.init","ripline!=NULL", ripline!=NULL);

        REQ("ripoffline.05.init","init!=NULL", ripline->init);

        REQ("ripoffline.05.one_line","one-line", win_state->_maxy == 0);

        REQ("ripoffline.05.columns","number of columns in the window", win_state->_maxx + 1 == data->columns);

    }
}

void onRipofflineInitfuncCall(RipofflineInitfuncCallT* data)
{
    NCursesWindow * nwin;
    WindowState * win_state;
    List * riplist;
    RipLineT * ripline;
    IntT Scr_nLines;

    Scr_nLines = getTermNLines(data->context);

    win_state = window_state(data->context, data->win);

    if(win_state == NULL)
    {
        //setBadVerdict("onRipoffLineInitfuncCall: win_state = NULL");
        DUMP("onRipofflineInitfuncCall: can't get the window state.");
        return;
    }

    riplist = getRipLines(data->context);

    ripline = findRipLine_byWinOrigin(riplist, win_state, Scr_nLines);

    if(ripline == NULL)
    {
        //setBadVerdict("Reserved line not found in model.");
        DUMP("onRipofflineInitfuncCall: Reserved line not found in model.");
        return;
    }

    if(!equals_VoidTPtr(ripline->win ,NULL_VoidTPtr))
    {
        setBadVerdict("onRipofflineInitfuncCall: Two windows on the same line.");
        ripline->win = NULL_VoidTPtr;
        return;
    }

    ripline->win = data->win;

    nwin = create_NCursesWindow(ripline->win,
                                    win_state->_maxx,
                                    win_state->_maxy,
                                    win_state->_begy + win_state->_yoffset,
                                    win_state->_begx,
                                    win_state->_parent
                                    );

    registerNCursesWindow( ripline->win, nwin);

    updateNCursesWindowMayNULL(data->context, &(ripline->win));
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
