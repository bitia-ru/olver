/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/color/color_model.seh"


#pragma SEC subsystem color "ncurses.color"



/*
   The group of functions 'ncurses.color' consists of:
       can_change_color [1]
       color_content [1]
       has_colors [1]
       init_color [1]
       init_pair [1]
       pair_content [1]
       start_color [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    can_change_color, color_content, has_colors, init_color, init_pair,
    start_color, pair_content - colour manipulation functions

SYNOPSIS

    #include <curses.h>

    bool can_change_color(void);
    int color_content(short color, short *red, short * green, short *blue);
    int COLOR_PAIR(int n);
    bool has_colors(void);
    int init_color(short color, short red, short green, short blue);
    int init_pair(short pair, short f, short b);
    int pair_content(short pair, short *f, short *b);
    int PAIR_NUMBER(int value);
    int start_color(void);
    extern int COLOR_PAIRS;
    extern int COLORS;

DESCRIPTION

    These functions manipulate colour on terminals that support colour.

    Querying Capabilities

        The has_colors() function indicates whether the terminal is a colour
        terminal. The can_change_color() function indicates whether the
        terminal is a colour terminal on which colours can be redefined.

    Initialisation

        The start_color() function must be called in order to enable use of
        colours and before any colour manipulation function is called. The
        function initialises eight basic colours (black, blue, green, cyan,
        red, magenta, yellow, and white) that can be specified by the colour
        macros (such as COLOR_BLACK) defined in <curses.h>.(See Colour-related
        Macros .) The initial appearance of these eight colours is not
        specified.

    The function also initialises two global external variables:

    COLORS

        defines the number of colours that the terminal supports. (See Colour
        Identification below.) If COLORS is 0, the terminal does not support
        redefinition of colours (and can_change_color() will return FALSE).

    COLOR_PAIRS

        defines the maximum number of colour-pairs that the terminal
        supports. (See User-defined Colour Pairs below.)

    The start_color() function also restores the colours on the terminal to
    terminal-specific initial values. The initial background colour is assumed
    to be black for all terminals.

    Colour Identification

        The init_color() function redefines colour number
        color, on terminals that support the redefinition of colours, to have
        the red, green, and blue intensity components specified by red, green,
        and blue, respectively. Calling init_color() also changes all
        occurrences of the specified colour on the screen to the new
        definition.

        The color_content() function identifies the intensity components of
        colour number color. It stores the red, green, and blue intensity
        components of this colour in the addresses pointed to by red, green,
        and blue, respectively.

        For both functions, the color argument must be in the range from 0 to
        and including COLORS-1. Valid intensity values range from 0 (no
        intensity component) up to and including 1000 (maximum intensity
        in that component).

    User-Defined Colour Pairs

        Calling init_pair() defines or redefines colour-pair number pair to
        have foreground colour f and background colour b. Calling init_pair()
        changes any characters that were displayed in the colour pair's old
        definition to the new definition and refreshes the screen.

        After defining the colour pair, the macro COLOR_PAIR(n) returns the
        value of colour pair n. This value is the colour attribute as it would
        be extracted from a chtype.Conversely, the macro PAIR_NUMBER(value)
        returns the colour pair number associated with the colour attribute
        value.

        The pair_content() function retrieves the component colours of a
        colour-pair number pair. It stores the foreground and background
        colour numbers in the variables pointed to by f and b, respectively.

        With init_pair() and pair_content(), the value of pair must be in a
        range from 0 to and including COLOR_PAIRS-1.(There may be an
        implementation-specific upper limit on the valid value of pair, but
        any such limit is at least 63.) Valid values for f and b are the range
        from 0 to and including COLORS-1.

RETURN VALUE

    The has_colors() function returns TRUE if the terminal can manipulate
    colors; otherwise, it returns FALSE.

    The can_change_color() function returns TRUE if the terminal supports
    colors and can change their definitions; otherwise, it returns FALSE.

    Upon successful completion, the other functions return OK; otherwise,
    they return ERR.

ERRORS

    No errors are defined.
*/

specification
IntT can_change_color_spec( CallContext context)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    pre
    {
        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("can_change_color.01",
            "You shall call has_color before calling this function",
            term->has_colors);

        return true;
    }
    coverage C
    {
        return { IndicateIsColourTerminalOnWhichColoursCanBeRedefined,
                 "Indicates whether the terminal is a colour terminal on which colours can be redefined"
               };
    }
    post
    {
        if(can_change_color_spec)
        {
            /*
             * The can_change_color() function returns TRUE if the terminal
             * supports colors and can change their definitions;
             */
            REQ("can_change_color.03.01",
                "Shall returns TRUE if the terminal supports colors and can "
                "change their definitions",
                term->can_change_color);
        }
        else
        {
            /*
             * otherwise, it returns FALSE.
             */
            REQ("can_change_color.03.02",
                "otherwise, it returns FALSE",
                !term->can_change_color);
        }

        /*
         * The can_change_color() function indicates whether the terminal is
         * a colour terminal on which colours can be redefined.
         */
        REQ("can_change_color.02", "", TODO_REQ());

        return true;
    }
}
void onCanChangeColor( CallContext context, IntT can_change_color_spec)
{
    NCursesTerminal* cur_term = getNCursesStdTerminal(context);

    cur_term->can_change_color = can_change_color_spec;
}

specification
IntT color_content_spec(CallContext context, ShortT color, RGBColor* rgb_color)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    pre
    {
        /*
         * The start_color() function must be called in order to enable use of
         * colours and before any colour manipulation function is called.
         */
        REQ("color_content.02",
            "Must be called in order to enable use of colours and before any "
            "colour manipulation function is called",
            term->start_color);

        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("color_content.01",
            "You shall call has_color before calling this function",
            term->has_colors);

        return true;
    }
    post
    {
        if(color_content_spec == SUT_ERR)
        {
            /*
             * otherwise, they return ERR.
             */
            REQ("color_content.10.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK;
         */
        REQ("color_content.10.01",
            "Upon successful completion, the other functions return OK",
            color_content_spec == SUT_OK);

        /*
         * For both functions, the color argument must be in the range from
         * 0 to and including COLORS-1.
         */
        REQ("color_content.04",
            "For both functions, the color argument must be in the range "
            "from 0 to and including COLORS-1",
            color >= 0 && color <= term->COLORS-1);

        /*
         * The color_content() function identifies the intensity components of
         * colour number color.
         */
        REQ("color_content.02",
            "Identifies the intensity components of colour number color",
                equals( get_Map(term->initialized_colors,
                                create_ShortTObj(color)),
                        rgb_color));
        /*
         * It stores the red, green, and blue intensity components of this
         * colour in the addresses pointed to by red, green, and blue,
         * respectively.
         */
        //Implemented in mediator
        IMPLEMENT_REQ("color_content.03");

        /*
         * Valid intensity values range from 0 (no intensity component) up to
         * and including 1000 (maximum intensity in that component).
         */
        REQ("color_content.05",
            "Intensity from 0 to 1000",
                    rgb_color->red >= 0 && rgb_color->red <= 1000
                &&  rgb_color->green >= 0 && rgb_color->green <= 1000
                &&  rgb_color->blue >= 0 && rgb_color->blue <= 1000);

        return true;
    }
}
void onColor_content(   CallContext context, ShortT color, RGBColor* rgb_color,
                        IntT color_content_spec)
{
    if(color_content_spec == SUT_EOK)
    {
        NCursesTerminal* term = getNCursesStdTerminal(context);
        Map* mp = term->initialized_colors;

        put_Map(mp, create_ShortTObj(color), rgb_color);
    }
}

specification
IntT has_colors_spec( CallContext context)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);
    pre
    {
        return true;
    }
    coverage C
    {
        return { IndicateIsColourTerminal, "Indicates whether the terminal is a colour terminal" };
    }
    post
    {
        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("has_colors.01",
            "Manipulate colour on terminals that support colour",
            term->has_colors);

        if(has_colors_spec)
        {
            /*
             * The has_colors() function returns TRUE if the terminal can
             * manipulate colors;
             */
            REQ("has_colors.03.01",
                "Returns TRUE if the terminal can manipulate colors",
                term->has_colors);
        }
        else
        {
            /*
             * otherwise, it returns FALSE.
             */
            REQ("has_colors.03.02",
                "Otherwise, it returns FALSE",
                !term->has_colors);
        }

        /*
         * The has_colors() function indicates whether the terminal is a colour
         * terminal.
         */
        REQ("has_colors.02", "", TODO_REQ());

        return true;
    }
}

void onHasColors( CallContext context, IntT has_colors_spec)
{
    NCursesTerminal* cur_term = getNCursesStdTerminal(context);

    cur_term->has_colors = has_colors_spec;
}

specification
IntT init_color_spec(   CallContext context, ShortT color, RGBColor* rgb_color)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    pre
    {
        /*
         * The start_color() function must be called in order to enable use of
         * colours and before any colour manipulation function is called.
         */
        REQ("init_color.02",
            "Must be called in order to enable use of colours and before any "
            "colour manipulation function is called",
            term->start_color);

        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("init_color.01",
            "You shall call has_color before calling this function",
            term->has_colors);

        //REQ("", "Terminal supports color redefinition",term->can_change_color);

        /*
         * For both functions, the color argument must be in the range from 0
         * to and including COLORS-1.
         */
        REQ("init_color.04",
            "Color argument must be from 0 to COLORS-1",
            color >= 0 && color <= term->COLORS-1);

        /*
         * Valid intensity values range from 0 (no intensity component) up to
         * and including 1000 (maximum intensity in that component).
         */
        REQ("init_color.05",
            "Intensity from 0 to 1000",
                    rgb_color->red >= 0 && rgb_color->red <= 1000
                &&  rgb_color->green >= 0 && rgb_color->green <= 1000
                &&  rgb_color->blue >= 0 && rgb_color->blue <= 1000);

        return true;
    }
    post
    {
        if(init_color_spec == SUT_ERR)
        {
            /*
             * otherwise, they return ERR.
             */
            REQ("init_color.10.02", "", TODO_REQ());

            return true;
        }
        /*
         * Upon successful completion, the other functions return OK;
         */
        REQ("init_color.10.01",
            "Upon successful completion return OK",
            init_color_spec == SUT_OK);

        /*
         * The init_color() function redefines colour number color, on
         * terminals that support the redefinition of colours, to have the
         * red, green, and blue intensity components specified by red, green,
         * and blue, respectively.
         */
        REQ("init_color.02",
            "Redefines colour number color",
            term->initialized_color_pairs);

        /*
         * Calling init_color() also changes all occurrences of the specified
         * colour on the screen to the new definition.
         */
        REQ("init_color.03", "", TODO_REQ());

        return true;
    }
}

void onInit_color( CallContext context, ShortT color, RGBColor* rgb_color,
                  IntT init_color_spec)
{
    if(init_color_spec == SUT_EOK)
    {
        NCursesTerminal* term = getNCursesStdTerminal(context);
        ShortTObj* color_obj = create_ShortTObj(color);
        Map* mp = term->initialized_colors;

        if(containsKey_Map(mp, color_obj))
        {
            remove_Map(mp, color_obj);
        }

        put_Map(mp, color_obj, rgb_color);
    }
}


specification
IntT init_pair_spec( CallContext context, ShortT pair, ColorPair* color_pair)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    pre
    {
        /*
         * The start_color() function must be called in order to enable use of
         * colours and before any colour manipulation function is called.
         */
        REQ("init_pair.02",
            "Must be called in order to enable use of colours and before any "
            "colour manipulation function is called",
            term->start_color);

        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("init_pair.01",
            "You shall call has_color before calling this function",
            term->has_colors);
        /*
         * With init_pair() and pair_content(), the value of pair must be in a
         * range from 0 to and including COLOR_PAIRS-1.
         */
        REQ("init_pair.07",
            "Pair must be from 0 to COLOR_PAIRS-1",
            pair >= 0  && pair <= term->COLOR_PAIRS);
        /*
         * Valid values for f and b are the range from 0 to and including
         * COLORS-1.
         */
        REQ("init_pair.09",
            "f and b must be from 0 to COLORS-1",
            color_pair->foreground >= 0
            &&  color_pair->foreground <= term->COLORS-1
            &&  color_pair->background >= 0
            &&  color_pair->background <= term->COLORS-1);
        return true;
    }
    post
    {
        Map* mp = term->initialized_color_pairs;
        ColorPair* pr = get_Map(mp, create_ShortTObj(pair));

        if(init_pair_spec == SUT_ERR)
        {
            /*
             * otherwise, they return ERR.
             */
            REQ("init_pair.10.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK;
         */
        REQ("init_pair.10.01",
            "Upon successful completion return OK",
            init_pair_spec == SUT_OK);

        /*
         * Calling init_pair() defines or redefines colour-pair number pair
         * to have foreground colour f and background colour b.
         */
        REQ("init_pair.02",
            "Defines or redefines colour-pair number pair",
            equals(pr, color_pair));

        /*
         * Calling init_pair() changes any characters that were displayed in
         * the colour pair's old definition to the new definition and
         * refreshes the screen.
         */
        REQ("init_pair.03", "", TODO_REQ());

        /*
         * After defining the colour pair, the macro COLOR_PAIR(n) returns the
         * value of colour pair n.
         */
        REQ("init_pair.04", "", TODO_REQ());

        /*
         * This value is the colour attribute as it would be extracted from a
         * chtype.
         */
        REQ("init_pair.05", "", TODO_REQ());

        /*
         * Conversely, the macro PAIR_NUMBER(value) returns the colour pair
         * number associated with the colour attribute value.
         */
        REQ("init_pair.06", "", TODO_REQ());

        /*
         * There may be an implementation-specific upper limit on the valid
         * value of pair, but any such limit is at least 63.
         */
        REQ("init_pair.08", "", TODO_REQ());

        return true;
    }
}

void onInit_pair(CallContext context, ShortT pair, ColorPair* color_pair,
                 IntT init_pair_spec)
{
    if(init_pair_spec == SUT_EOK)
    {
        NCursesTerminal* term = getNCursesStdTerminal(context);
        ShortTObj* pair_obj = create_ShortTObj(pair);
        Map* mp = term->initialized_color_pairs;

        if(containsKey_Map(mp, pair_obj))
        {
            remove_Map(mp, pair_obj);
        }

        put_Map(mp, pair_obj, color_pair);
    }
}


specification
IntT pair_content_spec( CallContext context, ShortT pair,
                        ColorPair* color_pair)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    pre
    {
        /*
         * The start_color() function must be called in order to enable use of
         * colours and before any colour manipulation function is called.
         */
        REQ("pair_content.02",
            "Must be called in order to enable use of colours and before any "
            "colour manipulation function is called",
            term->start_color);

        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("pair_content.01",
            "You shall call has_color before calling this function",
            term->has_colors);
        /*
         * With init_pair() and pair_content(), the value of pair must be
         * in a range from 0 to and including COLOR_PAIRS-1.
         */
        REQ("pair_content.07",
            "Pair must be from 0 to COLOR_PAIRS-1",
            pair >= 0 && pair <= term->COLOR_PAIRS);

        return true;
    }
    post
    {
        if(pair_content_spec == SUT_ERR)
        {
            /*
             * otherwise, they return ERR.
             */
            REQ("pair_content.10.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK;
         */
        REQ("pair_content.10.01",
            "Upon successful completion return OK",
            pair_content_spec == SUT_OK);

        if(containsKey_Map(term->initialized_color_pairs,
                        create_ShortTObj(pair)))
        {
            /*
             * The pair_content() function retrieves the component colours of a
             * colour-pair number pair.
             */
            /*
             * It stores the foreground and background colour numbers in the
             * variables pointed to by f and b, respectively.
             */
            REQ("pair_content.02;pair_content.03",
                "It stores the foreground and background colour numbers in "
                "the variables pointed to by f and b, respectively",
                equals( color_pair,
                        get_Map( term->initialized_color_pairs,
                                 create_ShortTObj(pair))));
        }

        /*
         * There may be an implementation-specific upper limit on the valid
         * value of pair, but any such limit is at least 63.
         */
        REQ("pair_content.08", "", TODO_REQ());

        /*
         * Valid values for f and b are the range from 0 to and including
         * COLORS-1.
         */
        REQ("pair_content.09",
            "f and b are from 0 to COLORS-1",
            color_pair->foreground >= 0
            &&  color_pair->foreground <= term->COLORS-1
            &&  color_pair->background >= 0
            &&  color_pair->background <= term->COLORS-1);
        return true;
    }
}
void onPair_content(CallContext context, ShortT pair, ColorPair* color_pair,
                 IntT pair_content_spec)
{
    if(pair_content_spec == SUT_EOK)
    {
        NCursesTerminal* term = getNCursesStdTerminal(context);
        ShortTObj* pair_obj = create_ShortTObj(pair);
        Map* mp = term->initialized_color_pairs;

        if(!containsKey_Map(mp, pair_obj))
        {
            put_Map(mp, pair_obj, color_pair);
        }
    }
}

specification
IntT start_color_spec( CallContext context)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    pre
    {
        /*
         * These functions manipulate colour on terminals that support colour.
         */
        REQ("start_color.01",
            "You shall call has_color before calling this function",
            term->has_colors);

        return true;
    }
    coverage C
    {
        return { EnableUseOfColours, "Enable use of colours" };
    }
    post
    {
        if(start_color_spec == SUT_ERR)
        {
            /*
             * otherwise, they return ERR.
             */
            REQ("start_color.10.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK;
         */
        REQ("start_color.10.01",
            "Upon successful completion return OK",
            start_color_spec == SUT_OK);

        /*
         * The function initialises eight basic colours (black, blue, green,
         * cyan, red, magenta, yellow, and white) that can be specified by
         * the colour macros (such as COLOR_BLACK) defined in <curses.h>.
         */
        REQ("start_color.03", "", TODO_REQ());

        /*
         * The initial appearance of these eight colours is not specified.
         */
        REQ("start_color.04", "", TODO_REQ());

        /*
         * The function also initialises two global external variables:
         *
         * COLORS
         *
         *      defines the number of colours that the terminal supports.
         *      (See Colour Identification below.)
         */
        REQ("start_color.05.01.01", "", TODO_REQ());

        if(!getCOLORS(context))
        {
            /*
             * If COLORS is 0, the terminal does not support redefinition of
             * colours (and can_change_color() will return FALSE).
             */
            REQ("start_color.05.01.02",
                "If COLORS is 0, can_change_color() will return FALSE",
                !term->can_change_color);
        }

        /*
         * The function also initialises two global external variables:
         *
         * COLOR_PAIRS
         *
         *      defines the maximum number of colour-pairs that the
         *      terminal supports. (See User-defined Colour Pairs below.)
         */
        REQ("start_color.05.02", "", TODO_REQ());

        /*
         * The start_color() function also restores the colours on the
         * terminal to terminal-specific initial values.
         */
        REQ("start_color.06", "", TODO_REQ());

        /*
         * The initial background colour is assumed to be black for all
         * terminals.
         */
        REQ("start_color.07", "", TODO_REQ());

        return true;
    }
}
void onStartColor( CallContext context, IntT start_color_spec)
{
    NCursesTerminal* term = getNCursesStdTerminal(context);

    term->start_color = 1;
}
/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
