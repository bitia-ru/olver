/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/window/refresh_model.seh"


#pragma SEC subsystem window "ncurses.window"



/*
   The group of functions 'ncurses.window.refresh' consists of:
       doupdate [1]
       is_linetouched [1]
       is_wintouched [1]
       isendwin [1]
       redrawwin [1]
       refresh [1]
       syncok [1]
       touchline [1]
       touchwin [1]
       untouchwin [1]
       wcursyncup [1]
       wnoutrefresh [1]
       wredrawln [1]
       wrefresh [1]
       wsyncdown [1]
       wsyncup [1]
       wtouchln [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    doupdate, refresh, wnoutrefresh, wrefresh - refresh windows and lines

SYNOPSIS

    #include <curses.h>

    int doupdate(void);

    int refresh(void);

    int wnoutrefresh(WINDOW *win);

    int wrefresh(WINDOW *win);

DESCRIPTION

    The refresh() and wrefresh() functions refresh the current or specified
    window. The functions position the terminal's cursor at the cursor position
    of the window, except that if the leaveok() mode has been enabled, they may
    leave the cursor at an arbitrary position.

    The wnoutrefresh() function determines which parts of the terminal may need
    updating. The doupdate() function sends to the terminal the commands to
    perform any required changes.

RETURN VALUE

    Upon successful completion, these functions return OK. Otherwise they
    return ERR.

ERRORS

    No errors are defined.
*/

specification
IntT doupdate_spec( CallContext context)
{
    NCursesWindow* stdWnd = getNCursesStdWindow(context);
    NCursesWindow* local = createNCursesWindow_Local(stdWnd);

    pre
    {
        doupdate_model(local);

        return true;
    }
    coverage C
    {
        return { SendCommandsToPerformChanges, "send to the terminal the commands to perform any required changes" };
    }
    post
    {
        if(doupdate_spec == SUT_ERR)
        {
            /*
             * Otherwise they return ERR.
             */
            REQ("doupdate.03.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("doupdate.03.01",
            "Upon successful completion, return OK",
            doupdate_spec == SUT_OK);

        /*
         * The doupdate() function sends to the terminal the commands to
         * perform any required changes.
         */
        REQ("doupdate.01", "", TODO_REQ());

        REQ("", "Check all", check_NCursesWindows(stdWnd, local, CH_ALL, -1));
        REQ("", "Screen check", compareScreens_Context(context));

        return true;
    }
}

void doupdate_model(NCursesWindow* local)
{
}

void onDoupdate( CallContext context, IntT doupdate_spec)
{
    if(doupdate_spec == SUT_OK)
    {
        NCursesWindow* stdWnd = getNCursesStdWindow(context);

        updateNCursesWindow(context, stdWnd->address);

        set_endwin_no_refresh(0);

        if(get_refresh_forbidden())
        {
            set_stdScreenContent(get_doupdate_screen());
            set_refresh_forbidden(0);
        }
    }
}


//This specification refers to: refresh, wrefresh
specification
IntT refresh_spec( CallContext context, WindowTPtr* win)
{
    NCursesWindow* curWnd = getWindowMayNULL(context, win);
    NCursesWindow* local = createNCursesWindow_Local(curWnd);

    pre
    {
        return true;
    }
    coverage C
    {
        return { RefreshWindow, "Refresh the current or specified window" };
    }
    post
    {
        if(refresh_spec == SUT_ERR)
        {
            /*
             * Otherwise they return ERR.
             */
            REQ("refresh.03.02;wrefresh.03.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("refresh.03.01;wrefresh.03.01",
            "Upon successful completion, return OK",
            refresh_spec == SUT_OK);

        /*
         * The refresh() and wrefresh() functions refresh the current or
         * specified window.
         */
        REQ("refresh.01;wrefresh.01",
            "Refresh the current or specified window",
            compareScreens_Context(context));

        /*
         * The functions position the terminal's cursor at the cursor position
         * of the window, except that if the leaveok() mode has been enabled,
         * they may leave the cursor at an arbitrary position.
         */
        REQ("refresh.02;wrefresh.02", "", TODO_REQ());

        REQ("", "Check All", check_NCursesWindows(curWnd, local, CH_ALL, -1));

        return true;
    }
}
void onRefresh( CallContext context, WindowTPtr* win, IntT refresh_spec)
{
    if(refresh_spec == SUT_OK)
    {
        updateNCursesWindowMayNULL(context, win);
        refresh_WindowTPtr(context, win, 1);
    }
}


specification
IntT wnoutrefresh_spec( CallContext context, NCursesWindow*  win)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    pre
    {
        wnoutrefresh_model(local);

        return true;
    }
    coverage C
    {
        return { DetermineWhichPartsMayNeedUpdating, "Determine which parts of the terminal may need updating" };
    }
    post
    {
        REQ("wnoutrefresh.01", "Check All", check_NCursesWindows(win, local, CH_ALL, -1));

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("wnoutrefresh.03.01", "", TODO_REQ());

        /*
         * Otherwise they return ERR.
         */
        REQ("wnoutrefresh.03.02", "", TODO_REQ());

        return true;
    }
}

void wnoutrefresh_model(NCursesWindow* local)
{
}

void onWnoutrefresh( CallContext context, NCursesWindow* win,
                  IntT wnoutrefresh_spec)
{
    if(wnoutrefresh_spec == SUT_OK)
    {
        updateNCursesWindow(context, win->address);
        wnoutrefresh_WindowTPtr(context, &win->address);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    is_linetouched, is_wintouched, touchline, touchwin, untouchwin, wtouchln -
    window refresh control functions

SYNOPSIS

    #include <curses.h>

    bool is_linetouched(WINDOW *win, int line);

    bool is_wintouched(WINDOW *win);

    int touchline(WINDOW *win, int start, int count);

    int touchwin(WINDOW *win);

    int untouchwin(WINDOW *win);

    int wtouchln(WINDOW *win, int y, int n, int changed);

DESCRIPTION

    The touchwin() function touches the specified window (that is, marks it as
    having changed more recently than the last refresh operation).  The
    touchline() function only touches count lines, beginning with line start.

    The untouchwin() function marks all lines in the window as unchanged since
    the last refresh operation.

    Calling wtouchln(), if changed is 1, touches n lines in the specified
    window, starting at line y. If changed is 0, wtouchln() marks such lines as
    unchanged since the last refresh operation.

    The is_wintouched() function determines whether the specified window is
    touched. The is_linetouched() function determines whether line line of the
    specified window is touched.

RETURN VALUE

    The is_linetouched() and is_wintouched() functions return TRUE if any of
    the specified lines, or the specified window, respectively, has been
    touched since the last refresh operation. Otherwise, they return FALSE.

    Upon successful completion, the other functions return OK. Otherwise, they
    return ERR.Exceptions to this are noted in the preceding function
    descriptions.

ERRORS

    No errors are defined.
*/

specification
IntT is_linetouched_spec( CallContext context, NCursesWindow* win,  IntT line)
{
    pre
    {
        return true;
    }
    post
    {
        if(line_touched(win, line))
        {
            /*
             * The is_linetouched() and is_wintouched() functions return TRUE
             * if any of the specified lines, or the specified window,
             * respectively, has been touched since the last refresh operation.
             */
            REQ("is_linetouched.02.01",
                "Return TRUE if any of the specified lines, or the specified "
                "window has been touched since the last refresh operation",
                is_linetouched_spec);
        }
        else
        {
            /*
             * Otherwise, they return FALSE.
             */
            REQ("is_linetouched.02.02",
                "Otherwise, return FALSE",
                !is_linetouched_spec);
        }



        return true;
    }
}


specification
IntT is_wintouched_spec( CallContext context, NCursesWindow* win)
{
    pre
    {
        return true;
    }
    post
    {
        if(win_touched(win))
        {
            /*
             * The is_linetouched() and is_wintouched() functions return TRUE
             * if any of the specified lines, or the specified window,
             * respectively, has been touched since the last refresh operation.
             */
            REQ("is_wintouched.02.01",
                "Return TRUE if any of the specified lines, or the specified "
                "window, has been touched since the last refresh operation",
                is_wintouched_spec);
        }
        else
        {
            /*
             * Otherwise, they return FALSE.
             */
            REQ("is_wintouched.02.02",
                "Otherwise, return FALSE",
                !is_wintouched_spec);
        }


        return true;
    }
}


specification
IntT touchline_spec( CallContext context, NCursesWindow* win,  IntT start,
                    IntT count)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    pre
    {
        touchline_model(local, start, count);

        return true;
    }
    post
    {
        if(touchline_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("touchline.02.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("touchline.02.01",
            "Upon successful completion, return OK",
            touchline_spec == SUT_OK);

        /*
         * The touchline() function only touches count lines, beginning with
         * line start.
         */
        REQ("touchline.01", "", TODO_REQ());

        REQ("", "Check All", check_NCursesWindows(win, local, CH_ALL, -1));

        return true;
    }
}

void touchline_model(NCursesWindow* local, IntT start,IntT count)
{
    wtouchln_model(local, start, count, 1);
}

void onTouchline( CallContext context, NCursesWindow* win,  IntT start,
                    IntT count, IntT touchline_spec)
{
    if(touchline_spec == SUT_OK)
    {
        updateNCursesWindow(context, win->address);
        refresh_WindowTPtr(context, &win->address, 0);
    }
}


specification
IntT touchwin_spec( CallContext context, NCursesWindow* win)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    pre
    {
        touchwin_model(local);

        return true;
    }
    coverage C
    {
        return { ToucheWindow, "Touche the specified window" };
    }
    post
    {
        if(touchwin_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("touchwin.02.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("touchwin.02.01",
            "Upon successful completion, return OK",
            touchwin_spec == SUT_OK);

        /*
         * The touchwin() function touches the specified window (that is,
         * marks it as having changed more recently than the last refresh
         * operation).
         */
        REQ("touchwin.01", "", TODO_REQ());

        REQ("", "Check All", check_NCursesWindows(win, local, CH_ALL, -1));

        return true;
    }
}

void touchwin_model(NCursesWindow* local)
{
    wtouchln_model(local, 0, local->nlines, 1);
}

void onTouchwin( CallContext context, NCursesWindow* win, IntT touchwin_spec)
{
    if(touchwin_spec == SUT_OK)
    {
        updateNCursesWindow(context, win->address);
        refresh_WindowTPtr(context, &win->address, 0);
    }
}


specification
IntT untouchwin_spec( CallContext context, NCursesWindow* win)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    pre
    {
        untouchwin_model(local);

        return true;
    }
    coverage C
    {
        return { UntoucheWindow, "Untouche the specified window" };
    }
    post
    {
        if(untouchwin_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("untouchwin.02.02", "", TODO_REQ());

            return true;
        }
        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("untouchwin.02.01",
            "Upon successful completion, return OK",
            untouchwin_spec == SUT_OK);

        /*
         * The untouchwin() function marks all lines in the window as
         * unchanged since the last refresh operation.
         */
        REQ("untouchwin.01", "", TODO_REQ());

        REQ("", "Check All", check_NCursesWindows(win, local, CH_ALL, -1));

        return true;
    }
}

void untouchwin_model(NCursesWindow* local)
{
    wtouchln_model(local, 0, local->nlines, 0);
}

void onUntouchwin( CallContext context, NCursesWindow* win,
                  IntT untouchwin_spec)
{
    if(untouchwin_spec == SUT_OK)
    {
        updateNCursesWindow(context, win->address);
        refresh_WindowTPtr(context, &win->address, 0);
    }
}


specification
IntT wtouchln_spec( CallContext context, NCursesWindow* win, IntT y, IntT n,
                   IntT changed)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    pre
    {
        wtouchln_model(local, y, n, changed);

        return true;
    }
    post
    {
        if(wtouchln_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("wtouchln.02.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, the other functions return OK.
         */
        REQ("wtouchln.02.01",
            "Upon successful completion, return OK",
            wtouchln_spec == SUT_OK);

        /*
         * Calling wtouchln(), if changed is 1, touches n lines in the
         * specified window, starting at line y.
         */
        REQ("wtouchln.01.01", "", TODO_REQ());

        /*
         * If changed is 0, wtouchln() marks such lines as unchanged since
         * the last refresh operation.
         */
        REQ("wtouchln.01.02", "", TODO_REQ());

        REQ("", "Check all", check_NCursesWindows(win, local, CH_ALL, -1));

        return true;
    }
}

void wtouchln_model(NCursesWindow* local, IntT y, IntT n, IntT changed)
{
    IntT end = (y + n) < local->nlines ? (y + n) : local->nlines;
    IntT i, j;

    for(i=0;i<local->ncols;i++)
        for(j=y;j<end;j++)
        {
            setRefresh_NCursesWindow(local, create_NCursesPosition(i, j),
                                                            changed ? 3 : 0);
        }

    pushNCursesWindow(local);
}

void onWtouchln( CallContext context, NCursesWindow* win, IntT y, IntT n,
                IntT changed, IntT wtouchln_spec)
{
    if(wtouchln_spec == SUT_OK)
    {
       updateNCursesWindow(context, win->address);
       refresh_WindowTPtr(context, &win->address, 0);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    isendwin - determine whether a screen has been refreshed

SYNOPSIS

    #include <curses.h>

    bool isendwin(void);

DESCRIPTION

    The isendwin() function indicates whether the screen has been refreshed since the last call to endwin().

RETURN VALUE

    The isendwin() function returns TRUE if endwin() has been called without any subsequent refresh. Otherwise, it returns FALSE.

ERRORS

    No errors are defined.

*/

specification
IntT isendwin_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { DetermineWhetherScreenHasBeenRefreshed, "Determine whether a screen has been refreshed" };
    }
    post
    {
        if(isendwin_spec)
        {
            /*
             * The isendwin() function returns TRUE if endwin() has been called
             * without any subsequent refresh.
             */
            REQ("isendwin.02.01",
                "Returns TRUE if endwin() has been called "
                "without any subsequent refresh",
                get_endwin_no_refresh());
        }
        else
        {
            /*
             * Otherwise, it returns FALSE.
             */
            REQ("isendwin.02.02",
                "Otherwise, returns FALSE",
                !get_endwin_no_refresh());
        }



        return true;
    }
}



/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    redrawwin, wredrawln - line update status functions

SYNOPSIS

    #include <curses.h> int redrawwin(WINDOW *win); int wredrawln(WINDOW *
    win, int beg_line, int num_lines);

DESCRIPTION

    The redrawwin() and wredrawln() functions inform the implementation that some
    or all of the information physically displayed for the specified window may
    have been corrupted. The redrawwin() function marks the entire window;
    wredrawln() marks only num_lines lines starting at line number beg_line. The
    functions prevent the next refresh operation on that window from performing any
    optimisation based on assumptions about what is physically displayed there.

RETURN VALUE

    Upon successful completion, these functions return OK. Otherwise they return
    ERR.

ERRORS

    No errors are defined.
*/

specification
IntT redrawwin_spec( CallContext context, NCursesWindow* win)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    touchwin_model(local);

    pre
    {
        return true;
    }
    coverage C
    {
        return { LineUpdateStatus, "Line update status" };
    }
    post
    {

        if(redrawwin_spec == SUT_ERR)
        {
            /*
             * Otherwise they return ERR.
             */
            REQ("redrawwin.04.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("redrawwin.04.01",
            "Upon successful completion, return OK",
            redrawwin_spec == SUT_OK);

        /*
         * The redrawwin() and wredrawln() functions inform the implementation
         * that some or all of the information physically displayed for the
         * specified window may have been corrupted.
         */
        REQ("redrawwin.01", "", TODO_REQ());

        /*
         * The redrawwin() function marks the entire window;
         */
        REQ("redrawwin.02", "", TODO_REQ());

        /*
         * The functions prevent the next refresh operation on that window from
         * performing any optimisation based on assumptions about what is
         * physically displayed there.
         */
        REQ("redrawwin.03", "", TODO_REQ());

        return true;
    }
}
void onRedrawwin( CallContext context, NCursesWindow* win, IntT redrawwin_spec)
{
    if(redrawwin_spec == SUT_OK)
    {
        updateNCursesWindow(context, win->address);
        refresh_WindowTPtr(context, &win->address, 0);
    }
}


specification
IntT wredrawln_spec( CallContext context, NCursesWindow* win,  IntT beg_line,
                    IntT num_lines)
{
    NCursesWindow* local = createNCursesWindow_Local(win);

    touchline_model(local, beg_line, num_lines);

    pre
    {
        return true;
    }
    post
    {
        if(wredrawln_spec == SUT_ERR)
        {
            /*
             * Otherwise they return ERR.
             */
            REQ("wredrawln.04.02", "", TODO_REQ());
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("wredrawln.04.01",
            "Upon successful completion, return OK",
            wredrawln_spec == SUT_OK);

        /*
         * The redrawwin() and wredrawln() functions inform the implementation
         * that some or all of the information physically displayed for the
         * specified window may have been corrupted.
         */
        REQ("wredrawln.01", "", TODO_REQ());

        /*
         * wredrawln() marks only num_lines lines starting at line number
         * beg_line.
         */
        REQ("wredrawln.02", "", TODO_REQ());

        /*
         * The functions prevent the next refresh operation on that window from
         * performing any optimisation based on assumptions about what is
         * physically displayed there.
         */
        REQ("wredrawln.03", "", TODO_REQ());

        return true;
    }
}
void onWredrawln( CallContext context, NCursesWindow* win,  IntT beg_line,
                    IntT num_lines, IntT wredrawln_spec)
{
    if(wredrawln_spec == SUT_OK)
    {
        updateNCursesWindow(context, win->address);
        refresh_WindowTPtr(context, &win->address, 0);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    syncok, wcursyncup, wsyncdown, wsyncup - synchronise a window with its
    parents or children

SYNOPSIS

    #include <curses.h>

    int syncok(WINDOW *win, bool bf);

    void wcursyncup(WINDOW *win);

    void wsyncdown(WINDOW *win);

    void wsyncup(WINDOW *win);

DESCRIPTION

    The syncok() function determines whether all ancestors of the specified
    window are implicitly touched whenever there is a change in the window.If
    bf is TRUE, such implicit touching occurs.If bf is FALSE, such implicit
    touching does not occur.The initial state is FALSE.

    The wcursyncup() function updates the current cursor position of the
    ancestors of win to reflect the current cursor position of win.

    The wsyncdown() function touches win if any ancestor window has been
    touched.

    The wsyncup() function unconditionally touches all ancestors of win.

RETURN VALUE

    Upon successful completion, syncok() returns OK. Otherwise, it returns ERR.

    The other functions do not return a value.

ERRORS

    No errors are defined.
*/

specification
IntT syncok_spec( CallContext context, NCursesWindow* win, IntT bf)
{
    pre
    {
        return true;
    }
    post
    {
       /*
         * The syncok() function determines whether all ancestors of the specified window
         * are implicitly touched whenever there is a change in the window.
         */
        REQ("syncok.01", "", TODO_REQ());

        /*
         * If bf is TRUE, such implicit touching occurs.
         */
        REQ("syncok.02.01", "", TODO_REQ());

        /*
         * If bf is FALSE, such implicit touching does not occur.
         */
        REQ("syncok.02.02", "", TODO_REQ());

        /*
         * The initial state is FALSE.
         */
        REQ("syncok.03", "", TODO_REQ());

        /*
         * Upon successful completion, syncok() returns OK.
         */
        REQ("syncok.04.01", "", TODO_REQ());

        /*
         * Otherwise, it returns ERR.
         */
        REQ("syncok.04.02", "", TODO_REQ());

        return true;
    }
}


specification
void wcursyncup_spec( CallContext context, NCursesWindow* win )
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { UpdateCurrentCursorPosition, "Update the current cursor position" };
    }
    post
    {
        /*
         * The wcursyncup() function updates the current cursor position of the ancestors
         * of win to reflect the current cursor position of win.
         */
        REQ("wcursyncup.01", "", TODO_REQ());

        return true;
    }
}
void onWcursync(CallContext context, NCursesWindow* win)
{
    wcursyncup_NCursesWindow(win);
}


specification
void wsyncdown_spec( CallContext context, NCursesWindow* win)
{
    pre
    {
        return true;
    }
    post
    {
        /*
         * The wsyncdown() function touches win if any ancestor window has been touched.
         */
        REQ("wsyncdown.01", "", TODO_REQ());

        return true;
    }
}
void onWsyncdown( CallContext context, NCursesWindow* win)
{
    wsyncdown_NCursesWindow(win);
}


specification
void wsyncup_spec( CallContext context, NCursesWindow* win)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { ToucheAllAncestorsOfWindow, "Touche all ancestors of win" };
    }
    post
    {
        /*
         * The wsyncup() function unconditionally touches all ancestors of win.
         */
        REQ("wsyncup.01", "", TODO_REQ());

        return true;
    }
}
void onWsyncup( CallContext context, NCursesWindow* win)
{
    wsyncup_NCursesWindow(win);
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
IntT line_touched(NCursesWindow* wnd, IntT line)
{
    IntT i;
    NCursesPosition* pos = create_NCursesPosition(-1, line);

    for(i=0;i<wnd->ncols;i++)
    {
        pos->x++;
        if(getRefresh_NCursesWindow(wnd, pos))
            return true;
    }

    return false;
}
IntT win_touched(NCursesWindow* wnd)
{
    IntT i;

    for(i=0;i<wnd->nlines;i++)
        if(line_touched(wnd, i))
            return true;

    return false;
}


