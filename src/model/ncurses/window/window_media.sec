/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "ncurses/window/window_media.seh"
#include "common/common_media.seh"


/********************************************************************/
/**                    Initialization Function                     **/
/********************************************************************/
void initNcursesWindowSubsystem(void)
{
  // Set up mediators
    set_mediator_copywin_spec(copywin_media);
    set_mediator_curs_set_spec(curs_set_media);
    set_mediator_delwin_spec(delwin_media);
    set_mediator_derwin_spec(derwin_media);
    set_mediator_dupwin_spec(dupwin_media);
    set_mediator_getwin_spec(getwin_media);
    set_mediator_intrflush_spec(intrflush_media);
    set_mediator_keypad_spec(keypad_media);
    set_mediator_meta_spec(meta_media);
    set_mediator_mvderwin_spec(mvderwin_media);
    set_mediator_mvwin_spec(mvwin_media);
    set_mediator_newwin_spec(newwin_media);
    set_mediator_nodelay_spec(nodelay_media);
    set_mediator_overlay_spec(overlay_media);
    set_mediator_overwrite_spec(overwrite_media);
    set_mediator_putwin_spec(putwin_media);
    set_mediator_subwin_spec(subwin_media);
}


/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** copywin_spec **/

mediator copywin_media for specification
IntT copywin_spec( CallContext context, WindowTPtr* srcwin, WindowTPtr* dstwin,
                  IntT sminrow, IntT smincol, IntT dminrow, IntT dmincol,
                  IntT dmaxrow, IntT dmaxcol, IntT overlay)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "copywin:$(ptr)$(ptr)$(int)$(int)$(int)"
            "$(int)$(int)$(int)$(int)", create_VoidTPtrObj(*srcwin),
            create_VoidTPtrObj(*dstwin),  create_IntTObj(sminrow),
            create_IntTObj(smincol), create_IntTObj(dminrow),
            create_IntTObj(dmincol), create_IntTObj(dmaxrow),
            create_IntTObj(dmaxcol), create_IntTObj(overlay));

        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onCopywin(context, srcwin, dstwin, sminrow, smincol, dminrow, dmincol,
                  dmaxrow, dmaxcol, overlay, copywin_spec);        
    }
}



/** curs_set_spec **/

mediator curs_set_media for specification
IntT curs_set_spec( CallContext context, IntT visibility)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "curs_set:$(int)",
            create_IntTObj(visibility));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onCurs_set(context, visibility, curs_set_spec);
    }
}



/** delwin_spec **/

mediator delwin_media for specification
IntT delwin_spec( CallContext context, WindowTPtr* win)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "delwin:$(ptr)", create_VoidTPtrObj(*win));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onDelwin(context, win, delwin_spec);
    }
}



/** derwin_spec **/

mediator derwin_media for specification
WindowTPtr derwin_spec( CallContext context, WindowTPtr* orig, IntT nlines,
                       IntT ncols, IntT begin_y, IntT begin_x)
{
    call
    {
        TSCommand command = create_TSCommand();
        WindowTPtr res;
    

        format_TSCommand( &command,"derwin:$(ptr)$(int)$(int)$(int)$(int)",
            create_VoidTPtrObj(*orig),
            create_IntTObj(nlines), create_IntTObj(ncols),
            create_IntTObj(begin_y), create_IntTObj(begin_x));


        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res =readPointer_TSStream(context, &command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onDerwin(context, orig, nlines, ncols, begin_y, begin_x, derwin_spec);
    }
}



/** dupwin_spec **/

mediator dupwin_media for specification
WindowTPtr dupwin_spec( CallContext context, WindowTPtr* win)
{
    call
    {
        TSCommand command = create_TSCommand();
        WindowTPtr res;
        
        format_TSCommand( &command, "dupwin:$(ptr)", create_VoidTPtrObj(*win));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readPointer_TSStream(context, &command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onDupwin(context, win, dupwin_spec);
    }
}



/** getwin_spec **/

mediator getwin_media for specification
WindowTPtr getwin_spec( CallContext context, CString* filep)
{
    call
    {
        TSCommand command = create_TSCommand();
        WindowTPtr res;
    
        format_TSCommand( &command, "getwin:$(str)", filep);
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readPointer_TSStream(context, &command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onGetwin(context, filep, getwin_spec);
    }
}



/** intrflush_spec **/

mediator intrflush_media for specification
IntT intrflush_spec( CallContext context, WindowTPtr* win, IntT bf)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "intrflush:$(ptr)$(int)",
            create_VoidTPtrObj(*win),
            create_IntTObj(bf));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onIntrflush(context, win, bf, intrflush_spec);
    }
}



/** keypad_spec **/
mediator keypad_media for specification
IntT keypad_spec( CallContext context, WindowTPtr* win, IntT bf)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "keypad:$(ptr)$(int)",
            create_VoidTPtrObj(*win),
            create_IntTObj(bf));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onKeypad(context, win, bf, keypad_spec);
    }
}


/** meta_spec **/
mediator meta_media for specification
IntT meta_spec( CallContext context, WindowTPtr* win, IntT bf)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "meta:$(ptr)$(int)",
            create_VoidTPtrObj(*win),
            create_IntTObj(bf));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onMeta(context, win, bf, meta_spec);
    }
}


/** mvderwin_spec **/

mediator mvderwin_media for specification
IntT mvderwin_spec( CallContext context, WindowTPtr* win, NCursesPosition* pos)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "mvderwin:$(ptr)$(int)$(int)",
            create_VoidTPtrObj(*win),  create_IntTObj(pos->y),
            create_IntTObj(pos->x));

        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onMvderwin(context, win, pos, mvderwin_spec);
    }
}



/** mvwin_spec **/

mediator mvwin_media for specification
IntT mvwin_spec( CallContext context, WindowTPtr* win, IntT y, IntT x)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "mvwin:$(ptr)$(int)$(int)", 
            create_VoidTPtrObj(*win),
            create_IntTObj(y), create_IntTObj(x));

        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res =readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onMvwin(context, win, y, x, mvwin_spec);
    }
}



/** newwin_spec **/
mediator newwin_media for specification
NewWinReturnType* newwin_spec( CallContext context, IntT nlines, IntT ncols, IntT begin_y, IntT begin_x)
{
    call
    {
        TSCommand command = create_TSCommand();
        NewWinReturnType* res=NULL;
        WindowTPtr ptr;
        IntT cols;
        IntT lines;
        
        format_TSCommand( &command, "newwin:$(int)$(int)$(int)$(int)", 
            create_IntTObj(nlines), create_IntTObj(ncols), create_IntTObj(begin_y),
            create_IntTObj(begin_x));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            ptr=readPointer_TSStream(context, &command.response);
            cols=readInt_TSStream(&command.response);
            lines=readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return create_NewWinReturnType(ptr, cols, lines);
    }
    state
    {
        onNewwin(context, nlines, ncols, begin_y, begin_x, newwin_spec);

    }
}


/** nodelay_spec **/
mediator nodelay_media for specification
IntT nodelay_spec( CallContext context, WindowTPtr* win, IntT bf)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "nodelay:$(ptr)$(int)",
            create_VoidTPtrObj(*win),
            create_IntTObj(bf));
        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onNodelay(context, win, bf, nodelay_spec);
    }
}


/** overlay_spec **/

mediator overlay_media for specification
IntT overlay_spec( CallContext context, WindowTPtr* srcwin,
                            WindowTPtr* dstwin)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "overlay:$(ptr)$(ptr)", 
            create_VoidTPtrObj(*srcwin), create_VoidTPtrObj(*dstwin));

        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onOverlay(context, srcwin, dstwin, overlay_spec);
    }
}



/** overwrite_spec **/
mediator overwrite_media for specification
IntT overwrite_spec( CallContext context, WindowTPtr* srcwin,
                            WindowTPtr* dstwin)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "overwrite:$(ptr)$(ptr)", 
            create_VoidTPtrObj(*srcwin), create_VoidTPtrObj(*dstwin));

        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onOverwrite(context, srcwin, dstwin, overwrite_spec);
    }
}


/** putwin_spec **/

mediator putwin_media for specification
IntT putwin_spec( CallContext context, WindowTPtr* win, CString* filep)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res;
    
        format_TSCommand( &command, "putwin:$(ptr)$(str)",
            create_VoidTPtrObj(*win), filep);

        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onPutwin(context, win, filep, putwin_spec);
    }
}



/** subwin_spec **/
mediator subwin_media for specification
WindowTPtr subwin_spec( CallContext context, WindowTPtr* orig, IntT nlines,
                       IntT ncols, IntT begin_y, IntT begin_x)
{
    call
    {
        TSCommand command = create_TSCommand();
        WindowTPtr res;
    

        format_TSCommand( &command,"subwin:$(ptr)$(int)$(int)$(int)$(int)",
            create_VoidTPtrObj(*orig),
            create_IntTObj(nlines), create_IntTObj(ncols),
            create_IntTObj(begin_y), create_IntTObj(begin_x));


        executeCommandInContext( context, &command );
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res =readPointer_TSStream(context, &command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onSubwin(context, orig, nlines, ncols, begin_y, begin_x, subwin_spec);
    }
}




