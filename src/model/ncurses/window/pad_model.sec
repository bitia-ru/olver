/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/window/pad_model.seh"


#pragma SEC subsystem window "ncurses.window"



/*
   The group of functions 'ncurses.window.pad' consists of:
       newpad [1]
       pechochar [1]
       pnoutrefresh [1]
       prefresh [1]
       subpad [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    newpad, pnoutrefresh, prefresh, subpad - pad management functions

SYNOPSIS

    #include <curses.h>

    WINDOW *newpad(IntT nlines, IntT ncols);

    IntT pnoutrefresh(WINDOW *pad, IntT pminrow, IntT pmincol, IntT sminrow,
                                IntT smincol, IntT smaxrow, IntT smaxcol);

    IntT prefresh(WINDOW *pad, IntT pminrow, IntT pmincol, IntT sminrow,
                                IntT smincol, IntT smaxrow, IntT smaxcol);

    WINDOW *subpad(WINDOW *orig, IntT nlines, IntT ncols, IntT begin_y,
                                IntT begin_x);

DESCRIPTION

    The newpad() function creates a specialised window called a pad with nlines
    lines and ncols columns. A pad is like a window, except that it is not
    restricted by the screen size and is not necessarily associated with a
    particular part of the screen. Automatic refreshes of pads (e.g., from
    scrolling or echoing of input) do not occur.

    The subpad() function creates a specialised window within a pad (called the
    parent pad) called a subpad with nlines lines and ncols columns. Unlike
    subwin() which uses screen coordinates, the subpad is created at position
    (begin_y, begin_x) within the parent pad. Changes made to either the parent
    pad or the subpad affect the other. The subpad must fit totally within the
    parent pad.

    The prefresh() and pnoutrefresh() functions are analogous to wrefresh()
    and wnoutrefresh() except that they relate to pads instead of windows. The
    additional arguments indicate what part of the pad and screen are involved.
    The pminrow and pmincol arguments specify the origin of the rectangle to be
    displayed in the pad. The sminrow, smincol, smaxrow and smaxcol arguments
    specify the edges of the rectangle to be displayed on the screen. The lower
    right-hand corner of the rectangle to be displayed in the pad is calculated
    from the screen coordinates, since the rectangles must be the same size.
    Both rectangles must be entirely contained within their respective
    structures. Negative values of pminrow, pmincol, sminrow or smincol are
    treated as if they were zero.

RETURN VALUE

    Upon successful completion, the newpad()  and subpad()  functions return a
    pointer to the pad data structure. Otherwise, they return a null pointer.

    Upon successful completion, pnoutrefresh() and prefresh() return OK.
    Otherwise, they return ERR.

ERRORS

    No errors are defined.
*/

specification
WindowTPtr newpad_spec( CallContext context, IntT nlines, IntT ncols )
{
    pre
    {
        return true;
    }
    post
    {
        NCursesWindow* pad = getWindow(&newpad_spec);

        if(isNULL_VoidTPtr(newpad_spec))
        {
            /*
             * Otherwise, they return a null pointer.
             */
            REQ("newpad.04.02", "", TODO_REQ());

            return true;
        }

        /*
         * The newpad() function creates a specialised window called a pad
         * with nlines lines and ncols columns.
         */
        REQ("newpad.01",
            "Creates a specialised window",
            pad->ncols == ncols && pad->nlines == nlines);

        /*
         * A pad is like a window, except that it is not restricted by the
         * screen size and is not necessarily associated with a particular
         * part of the screen.
         */
        REQ("newpad.02", "", TODO_REQ());

        /*
         * Automatic refreshes of pads (e.g., from scrolling or echoing of
         * input) do not occur.
         */
        REQ("newpad.03", "", TODO_REQ());

        return true;
    }
}
void onNewpad(  CallContext context, IntT nlines, IntT ncols,
                WindowTPtr newpad_spec )
{
    if(!isNULL_VoidTPtr(newpad_spec))
    {
        NCursesWindow* wnd = create_NCursesWindow(newpad_spec,
                    nlines, ncols, -1, -1, NULL_VoidTPtr);

        registerNCursesWindow( newpad_spec, wnd);
        updateNCursesWindow(context, wnd->address);
    }
}

specification
IntT pnoutrefresh_spec( CallContext context, NCursesWindow* pad, IntT pminrow,
                    IntT pmincol, IntT sminrow, IntT smincol, IntT smaxrow,
                    IntT smaxcol )
{
    NCursesWindow* stdWnd = getNCursesStdWindow(context);
    NCursesWindow* local = createNCursesWindow_Local(pad);

    prefresh_model(context, local, pminrow, pmincol, sminrow, smincol,
                    smaxrow, smaxcol);
    pre
    {
        /*
         * The lower right-hand corner of the rectangle to be displayed in the
         * pad is calculated from the screen coordinates, since the rectangles
         * must be the same size.
         */
        REQ("app.pnoutrefresh.05", "", TODO_REQ());

        /*
         * Both rectangles must be entirely contained within their respective
         * structures.
         */
        REQ("app.pnoutrefresh.06",
            "Both rectangles must be entirely contained "
            "within their respective structures",
                                           stdWnd->nlines > smaxrow
                                        && stdWnd->ncols > smaxcol
                                        && pad->nlines >
                                            (pminrow<0 ? 0 : pminrow) + smaxrow
                                            - (sminrow<0 ? 0 : sminrow)
                                        && pad->ncols >
                                            (pmincol<0 ? 0 : pmincol) + smaxcol
                                            - (smincol<0 ? 0 : smincol));
        return true;
    }
    post
    {
        if(pnoutrefresh_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("pnoutrefresh.08.02", "", TODO_REQ());

            return true;
        }

        /*
         * Upon successful completion, pnoutrefresh() and prefresh() return OK.
         */
        REQ("pnoutrefresh.08.01",
            "Upon successful completion, return OK",
            pnoutrefresh_spec == SUT_OK);

        REQ("", "Screen compare", compareScreens_Context(context));
        REQ("", "Check all", check_NCursesWindows(pad, local, CH_ALL, -1));

    

        return true;
    }
}

void onPnoutrefresh( CallContext context, NCursesWindow* pad,
                    IntT pnoutrefresh_spec)
{
    if(pnoutrefresh_spec == SUT_OK)
    {
        updateNCursesWindow(context, pad->address);
        pnoutrefresh_NCursesWindow(context, pad);
    }
}


specification
IntT prefresh_spec( CallContext context, NCursesWindow* pad, IntT pminrow,
                    IntT pmincol, IntT sminrow, IntT smincol, IntT smaxrow,
                    IntT smaxcol )
{
    NCursesWindow* stdWnd = getNCursesStdWindow(context);
    NCursesWindow* local = createNCursesWindow_Local(pad);

    prefresh_model(context, local, pminrow, pmincol, sminrow, smincol,
                    smaxrow, smaxcol);
    pre
    {
        /*
         * The lower right-hand corner of the rectangle to be displayed in the
         * pad is calculated from the screen coordinates, since the rectangles
         * must be the same size.
         */
        REQ("app.prefresh.05", "", TODO_REQ());

        /*
         * Both rectangles must be entirely contained within their respective
         * structures.
         */
        REQ("app.prefresh.06",
            "Both rectangles must be entirely contained "
            "within their respective structures",
                                           stdWnd->nlines > smaxrow
                                        && stdWnd->ncols > smaxcol
                                        && pad->nlines >
                                            (pminrow<0 ? 0 : pminrow) + smaxrow
                                            - (sminrow<0 ? 0 : sminrow)
                                        && pad->ncols >
                                            (pmincol<0 ? 0 : pmincol) + smaxcol
                                            - (smincol<0 ? 0 : smincol));
        return true;
    }
    post
    {
        if(prefresh_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("prefresh.08.02", "", TODO_REQ());

            return true;
        }
        /*
         * Upon successful completion, pnoutrefresh() and prefresh() return OK.
         */
        REQ("prefresh.08.01",
            "Upon successful completion, return OK",
            prefresh_spec == SUT_OK);

        REQ("", "Screen compare", compareScreens_Context(context));
        REQ("", "Check all", check_NCursesWindows(pad, local, CH_ALL, -1));

   

        return true;
    }
}

void prefresh_model( CallContext context, NCursesWindow* local, IntT pminrow,
                    IntT pmincol, IntT sminrow, IntT smincol, IntT smaxrow,
                    IntT smaxcol )
{
    local->pad->_pad_x = (ShortT)   (pmincol<0 ? 0 : pmincol);
    local->pad->_pad_y = (ShortT)   (pminrow<0 ? 0 : pminrow);
    local->pad->_pad_top = (ShortT) (smincol<0 ? 0 : smincol);
    local->pad->_pad_left = (ShortT)(sminrow<0 ? 0 : sminrow);
    local->pad->_pad_bottom = (ShortT)smaxcol;
    local->pad->_pad_right = (ShortT)smaxrow;
    local->begx = (ShortT) (smincol<0 ? 0 : smincol);
    local->begy = (ShortT) (sminrow<0 ? 0 : sminrow);
}

void onPrefresh( CallContext context, NCursesWindow* pad, IntT prefresh_spec)
{
    if(prefresh_spec == SUT_OK)
    {
        updateNCursesWindow(context, pad->address);
        refresh_WindowTPtr(context, &pad->address, 1);
    }
}

specification
WindowTPtr subpad_spec( CallContext context, WindowTPtr orig, IntT nlines,
                       IntT ncols, IntT begin_y, IntT begin_x )
{
    NCursesWindow* wnd = getWindow(&orig);

    pre
    {
        REQ("", "Implicit precondition: orig shall be pad",
                                                    wnd->flags & SUT__ISPAD);

        return true;
    }
    post
    {
        if(isNULL_VoidTPtr(subpad_spec))
        {
            /*
             * Otherwise, they return a null pointer.
             */
            REQ("subpad.04.02", "", TODO_REQ());

            return true;
        }

        /*
         * The subpad() function creates a specialised window within a pad
         * (called the parent pad) called a subpad with nlines lines and
         * ncols columns.
         */
        REQ("subpad.01", "", TODO_REQ());

        /*
         * Unlike subwin() which uses screen coordinates, the subpad is
         * created at position (begin_y, begin_x) within the parent pad.
         */
        REQ("subpad.02", "", TODO_REQ());

        /*
         * Changes made to either the parent pad or the subpad affect the other.
         */
        REQ("subpad.03", "", TODO_REQ());

        /*
         * The subpad must fit totally within the parent pad.
         */
        REQ("subpad.05",
            "The subpad must fit totally within the parent pad",
                                wnd->ncols >= ncols + begin_x
                            &&  wnd->nlines >= nlines + begin_y);

        return true;
    }
}
void onSubpad(  CallContext context, WindowTPtr orig, IntT nlines,
                IntT ncols, IntT begin_y, IntT begin_x, WindowTPtr subpad_spec)
{
    if(!isNULL_VoidTPtr(subpad_spec))
    {
        NCursesWindow* wnd = create_NCursesWindow(subpad_spec,
                    nlines, ncols, begin_y, begin_x, orig);

        wnd->wnd_image = NULL;

        registerNCursesWindow( subpad_spec, wnd);
        updateNCursesWindow(context, wnd->address);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    pechochar, pecho_wchar - write a character and rendition and immediately
    refresh the pad

SYNOPSIS

    #include <curses.h> int pechochar(WINDOW *pad, chtype ch); int
    pecho_wchar(WINDOW *pad, const cchar_t *wch);

DESCRIPTION

    The pechochar() and pecho_wchar() functions output one character to a pad and
    immediately refresh the pad. They are equivalent to a call to waddch() or
    wadd_wch(), respectively, followed by a call to prefresh(). The last location
    of the pad on the screen is reused for the arguments to prefresh().

RETURN VALUE

    Upon successful completion, these functions return OK. Otherwise, they return
    ERR.

ERRORS

    No errors are defined.
*/

specification
IntT pechochar_spec( CallContext context, NCursesWindow* pad, ChTypeT ch)
{
    NCursesWindow* local = createNCursesWindow_Local(pad);

    pechochar_model(context, local, ch);

    pre
    {
        return true;
    }
    post
    {
        if(pechochar_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("pechochar.04.02", "", TODO_REQ());

            return true;
        }
        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("pechochar.04.01",
            "Upon successful completion, return OK",
            pechochar_spec == SUT_OK);

        REQ("", "Screen compare", compareScreens_Context(context));
        REQ("", "Check all", check_NCursesWindows(pad, local, CH_ALL, -1));

        /*
         *
         are equivalent to a call to waddch() or wadd_wch(),
         * respectively, followed by a call to prefresh().
         */
        REQ("pechochar.02", "", TODO_REQ());

   

        return true;
    }
}

void pechochar_model( CallContext context, NCursesWindow* local, ChTypeT ch)
{
    setElement_NCursesWindow(local, local->cursorPos, ch);
    changeCursorPos(local, local->cursorPos, 1);
}

void onPechochar( CallContext context, NCursesWindow* pad, IntT pechochar_spec)
{
    if(pechochar_spec == SUT_OK)
    {
        updateNCursesWindow(context, pad->address);
        refresh_WindowTPtr(context, &pad->address, 1);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

    newpad, pnoutrefresh, prefresh, subpad - pad management functions

SYNOPSIS

    #include <curses.h> WINDOW *newpad(int nlines, int ncols); int
    pnoutrefresh(WINDOW *pad, int pminrow, int pmincol, int sminrow, int smincol,
    int smaxrow, int smaxcol); int prefresh(WINDOW *pad, int pminrow, int pmincol,
    int sminrow, int smincol, int smaxrow, int smaxcol); WINDOW *subpad(WINDOW *
    orig, int nlines, int ncols, int begin_y, int begin_x);

DESCRIPTION

    The newpad() function creates a specialised window called a pad with nlines
    lines and ncols columns. A pad is like a window, except that it is not
    restricted by the screen size and is not necessarily associated with a
    particular part of the screen. Automatic refreshes of pads (e.g., from
    scrolling or echoing of input) do not occur.

    The subpad() function creates a specialised window within a pad (called
    the parent pad) called a subpad with nlines lines and ncols columns. Unlike
    subwin() which uses screen coordinates,    the subpad is created at position
    (begin_y, begin_x) within the parent pad. Changes made to either the parent
    pad or the subpad affect the other. The subpad must fit totally within the
    parent pad.

    The prefresh() and pnoutrefresh() functions are analogous to wrefresh() and
    wnoutrefresh() except that they relate to pads instead of windows. The
    additional arguments indicate what part of the pad and screen are involved. The
    pminrow and pmincol arguments specify the origin of the rectangle to be
    displayed in the pad. The sminrow, smincol, smaxrow and smaxcol arguments
    specify the edges of the rectangle to be displayed on the screen. The lower
    right-hand corner of the rectangle to be displayed in the pad is calculated
    from the screen coordinates, since the rectangles must be the same size. Both
    rectangles must be entirely contained within their respective structures.
    Negative values of pminrow, pmincol, sminrow or smincol are treated as if they
    were zero.

RETURN VALUE

    Upon successful completion, the newpad() and
    subpad() functions return a pointer to the pad data structure. Otherwise, they
    return a null pointer. Upon successful completion, pnoutrefresh() and prefresh()
    return OK. Otherwise, they return ERR.

ERRORS

    No errors are defined.
*/


