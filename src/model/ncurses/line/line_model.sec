/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/line/line_model.seh"
#include "data/ncurses_model.seh"
#include "ncurses/ncurses/chtypearray.seh"

#pragma SEC subsystem line "ncurses.line"



/*
   The group of functions 'ncurses.line' consists of:
       hline [1]
       whline [1]
       mvhline [1]
       mvwhline [1]

       vline [1]
       wvline [1]
       mvvline [1]
       mvwvline [1]

       insdelln [1]
       winsdelln [1]

       insertln [1]
       winsertln [1]

       ripoffline [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

hline, mvhline, mvvline, mvwhline, mvwvline, vline, whline, wvline - draw
lines from single-byte characters and renditions

SYNOPSIS

#include <curses.h>

int hline(chtype ch, int n);
int mvhline(int y, int x, chtype ch, int n);
int mvvline(int y, int x, chtype ch, int n);
int mvwhline(WINDOW *win, int y, int x, chtype ch, int n);
int mvwvline(WINDOW *win, int y, int x, chtype ch, int n);
int vline(chtype ch, int n);
int whline(WINDOW *win, chtype ch, int n);
int wvline(WINDOW *win, chtype ch, int n);

DESCRIPTION

These functions draw a line in the current or specified window starting at the
current or specified position, using ch. The line is at most n positions
long, or as many as fit into the window.

These functions do not advance the cursor position. These functions do not
perform special character processing. These functions do not perform wrapping.


The hline(), mvhline(), mvwhline() and whline() functions draw a line
proceeding toward the last column of the same line.

The vline(), mvvline(), mvwvline() and wvline() functions draw a line
proceeding toward the last line of the window.

RETURN VALUE

Upon successful completion, these functions return OK. Otherwise, they return
ERR.

ERRORS

No errors are defined.
*/
IntT hline_model( CallContext context,NCursesWindow * uWnd, NCursesPosition* position, ChTypeT ch, IntT n )
{
    NCursesPosition * rpos;

    int n_to_draw;
    int max_line_len;
    int i;

    /*
     * These functions draw a line in the current or specified window starting at the
     * current or specified position...
     */
    IMPLEMENT_REQ("?hline.01;mvhline.01;mvwhline.01;whline.01");
    rpos = getUsedPos(context, position, uWnd);

    /*
     * The line is at most n positions long, or as many as fit into the window.
     */
    IMPLEMENT_REQ("?hline.02;mvhline.02;mvwhline.02;whline.02");
    max_line_len = uWnd->ncols - rpos->x;
    if(n>max_line_len)
        n_to_draw = max_line_len;
    else
        n_to_draw = n;

    /*
     * The hline(), mvhline(), mvwhline() and whline() functions draw a line
     * proceeding toward the last column of the same line.
     */
    IMPLEMENT_REQ("?hline.06;mvhline.06;mvwhline.06;whline.06");
    for(i=0;i<n_to_draw;i++)
    {
        setElement_NCursesWindow_YX(uWnd, rpos->y, rpos->x+i, ch);
    }

    /*
     * These functions do not perform wrapping.
     */
    IMPLEMENT_REQ("hline.05;mvhline.05;mvwhline.05;whline.05");
    /*
     * These functions do not perform special character processing.
     */
    IMPLEMENT_REQ("hline.04;mvhline.04;mvwhline.04;whline.04");

    if (position!=NULL)
    {
        uWnd->cursorPos=clone(position);
    }

    return 0;
}

//This specification refers to: hline, mvhline, mvwhline, whline
specification
IntT hline_spec( CallContext context, WindowTPtr* win, NCursesPosition* position, ChTypeT ch, IntT n )
{
    NCursesWindow * oldWnd;

    pre
    {
        oldWnd = createNCursesWindow_Local( getUsedWindow(context, win) );

        hline_model(context, oldWnd, position, ch, n);

        pushNCursesWindow(oldWnd);

        return true;
    }
    post
    {
        NCursesWindow * uWnd;
        NCursesPosition * uPos;
        int i, j, max_line_len, n_to_draw;
        bool check;

        /*
         * These functions draw a line in the current or specified window starting at the
         * current or specified position, using ch.
         */
        uWnd = getUsedWindow(context, win);
        uPos = getUsedPos(context, position, uWnd);

        if (position==NULL)
        {
            /*
             * These functions do not advance the cursor position.
             */
            REQ("?hline.03;mvhline.03;mvwhline.03;whline.03",
                "do not advance the cursor position",
                equals_NCursesPosition(uWnd->cursorPos, oldWnd->cursorPos)
               );
        }
        else
        {
            /*
             * These functions do not advance the cursor position.
             */
            REQ("?hline.03;mvhline.03;mvwhline.03;whline.03",
                "do not advance the cursor position",
                equals_NCursesPosition(uWnd->cursorPos, position)
               );
        }
        if(hline_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("hline.07.02;mvhline.07.02;mvwhline.07.02;whline.07.02", "", TODO_REQ());

            REQ("", "screen shall not change",
                equals_ChTypeTArray(uWnd->wnd_image, uWnd->wnd_image)
               );

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("hline.07.01;mvhline.07.01;mvwhline.07.01;whline.07.01",
            "Upon successful completion, these functions return OK", hline_spec == SUT_EOK);


        REQ("","total comparison", check_NCursesWindows(uWnd, oldWnd, CH_ALL, 1));

        return true;
    }
}

void onHline(CallContext context, WindowTPtr* win, NCursesPosition* position, ChTypeT ch, IntT n, IntT hline_spec)
{
    updateNCursesWindowMayNULL( context, win);

    refresh_WindowTPtr(context,win,0);
}


IntT vline_model( CallContext context, NCursesWindow * uWnd, NCursesPosition* position, ChTypeT ch, IntT n )
{
    NCursesPosition * rpos;
    int n_to_draw;
    int max_line_len;
    int i;

    /*
     * These functions draw a line in the current or specified window starting at the
     * current or specified position
     */
    IMPLEMENT_REQ("?vline.01;mvvline.01;mvwvline.01;wvline.01");
    rpos = getUsedPos(context, position, uWnd);

    /*
     * The line is at most n positions long, or as many as fit into the window.
     */
    IMPLEMENT_REQ("?vline.02;mvvline.02;mvwvline.02;wvline.02");
    max_line_len = uWnd->nlines - rpos->y;
    if(n>max_line_len)
        n_to_draw = max_line_len;
    else
        n_to_draw = n;

    /*
     * The vline(), mvvline(), mvwvline() and wvline() functions draw a line
     * proceeding toward the last column of the same line.
     */
    IMPLEMENT_REQ("?vline.06;mvvline.06;mvwvline.06;wvline.06");
    for(i=0;i<n_to_draw;i++)
    {
        setElement_NCursesWindow_YX(uWnd, rpos->y+i, rpos->x, ch);
    }

    /*
     * These functions do not perform special character processing.
     */
    IMPLEMENT_REQ("vline.04;mvvline.04;mvwvline.04;wvline.04");
    /*
     * These functions do not perform wrapping.
     */
    IMPLEMENT_REQ("vline.05;mvvline.05;mvwvline.05;wvline.05");

    if (position!=NULL)
    {
        uWnd->cursorPos=clone(position);
    }
    return 0;
}

/** vline_spec **/
//This specification refers to: mvwvline, wvline, mvvline, vline
specification
IntT vline_spec( CallContext context, WindowTPtr* win, NCursesPosition* position, ChTypeT ch, IntT n )
{
    NCursesWindow * oldWnd;

    pre
    {
        oldWnd = createNCursesWindow_Local( getUsedWindow(context, win) );

        vline_model(context, oldWnd, position, ch, n);

        pushNCursesWindow(oldWnd);

        return true;
    }
    post
    {
        NCursesWindow * uWnd;
        NCursesPosition * uPos;
        int i, j, max_line_len, n_to_draw;
        bool check;

        /*
         * These functions draw a line in the current or specified window starting at the
         * current or specified position, using ch.
         */
        uWnd = getUsedWindow(context, win);
        uPos = getUsedPos(context, position, uWnd);

        if (position==NULL)
        {
            /*
             * These functions do not advance the cursor position.
             */
            REQ("?vline.03;mvvline.03;mvwvline.03;wvline.03",
                "do not advance the cursor position",
                equals_NCursesPosition(uWnd->cursorPos, oldWnd->cursorPos)
               );
        }
        else
        {
            /*
             * These functions do not advance the cursor position.
             */
            REQ("?vline.03;mvvline.03;mvwvline.03;wvline.03",
                "do not advance the cursor position",
                equals_NCursesPosition(uWnd->cursorPos, position)
               );
        }

        if(vline_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("vline.07.02;mvvline.07.02;mvwvline.07.02;wvline.07.02", "", TODO_REQ());

            REQ("", "screen shall not change",
                equals_ChTypeTArray(uWnd->wnd_image, uWnd->wnd_image)
               );

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("vline.07.01;mvvline.07.01;mvwvline.07.01;wvline.07.01",
            "Upon successful completion, these functions return OK", vline_spec == SUT_EOK);

        REQ("","total comparison", check_NCursesWindows(uWnd, oldWnd, CH_ALL, 1));

        REQ("","total comparison", compareScreens_Context(context));

        return true;
    }
}

void onVline(CallContext context, WindowTPtr* win, NCursesPosition* position, ChTypeT ch, IntT n, IntT vline_spec)
{
    updateNCursesWindowMayNULL( context, win);

    refresh_WindowTPtr(context,win,0);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

insertln, winsertln - insert lines into a window

SYNOPSIS

#include <curses.h>

int insertln(void);

int winsertln(WINDOW *win);

DESCRIPTION

The insertln() and winsertln() functions insert a blank line before the
current line in the current or specified window. The bottom line is no
longer displayed. The cursor position does not change.

RETURN VALUE

Upon successful completion, these functions return OK. Otherwise, they return
 ERR.

ERRORS

No errors are defined.
*/

IntT insertln_model(CallContext context, NCursesWindow* uWnd)
{
    NCursesPosition * uPos;
    int x,y;

    /*
     * The insertln() and winsertln() functions insert a blank line before the
     * current line in the current or specified window.
     */
    IMPLEMENT_REQ("?insertln.01;winsertln.01");
    /*
     * The bottom line is no longer displayed.
     */
    IMPLEMENT_REQ("?insertln.02;insertln.02");

    /*[current position] */
    uPos = uWnd->cursorPos;

    /*[shifting]*/
    for(y=uWnd->nlines-1-1;y>=uPos->y; y--)
    {
        for(x=0;x<uWnd->ncols;x++)
        {
            ChTypeT ch = getElement_NCursesWindow_YX(uWnd, y, x);
            setElement_NCursesWindow_YX(uWnd, y+1, x, ch);
        }
    }
    /* [line clearing] */
    for(x=0;x<uWnd->ncols;x++)
    {
        setElement_NCursesWindow_YX(uWnd, uPos->y, x, uWnd->bkgd);
    }

    return 0;
}

/** insertln_spec **/
//This specification refers to: insertln, winsertln
specification
IntT insertln_spec( CallContext context, WindowTPtr* win)
{
    NCursesWindow * oldWnd;

    pre
    {
        oldWnd = createNCursesWindow_Local( getUsedWindow(context, win) );

        insertln_model(context, oldWnd);

        pushNCursesWindow(oldWnd);

        return true;
    }
    coverage C
    {
        return { InsertLineIntoWindow, "Insert line into a window" };
    }
    post
    {
        NCursesWindow * uWnd;
        NCursesPosition * uPos;
        int i, j;
        bool check;

        /*
         * The insertln() and winsertln() functions insert a blank line before the
         * current line in the current or specified window.
         */
        uWnd = getUsedWindow(context, win);
        uPos = uWnd->cursorPos;

        /*
         * The cursor position does not change.
         */
        REQ("insertln.03", "cursor position does not change",
            equals_NCursesPosition(uWnd->cursorPos, oldWnd->cursorPos)
           );

        if(insertln_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("insertln.04.02;winsertln.04.02", "", TODO_REQ());

            /*[implicit condition]*/
            REQ("","screen shall not change", check_NCursesWindows(uWnd, oldWnd, CH_ALL, 1));

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("insertln.04.01;winsertln.04.01",
            "Upon successful completion, these functions return OK", insertln_spec == SUT_EOK);

        REQ("","total comparison", check_NCursesWindows(uWnd, oldWnd, CH_ALL, 1));

        return true;
    }
}

void onInsertln(CallContext context, WindowTPtr* win, IntT insertln_spec)
{
    updateNCursesWindowMayNULL( context, win);

    refresh_WindowTPtr(context,win,0);
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

insdelln, winsdelln - delete or insert lines into a window

SYNOPSIS

#include <curses.h>

int insdelln(int n);

int winsdelln(WINDOW *win, int n);

DESCRIPTION

The insdelln() and winsdelln() functions perform the following actions:

If n is positive, these functions insert n lines into the current or specified
window before the current line. The n last lines are no longer displayed.

If n is negative, these functions delete n lines from the current or specified
window starting with the current line, and move the remaining lines toward the
cursor. The last n lines are cleared.

The current cursor position remains the same.

RETURN VALUE

Upon successful completion, these functions return OK. Otherwise, they return
ERR.

ERRORS

No errors are defined.
*/

IntT insdelln_model( CallContext context, NCursesWindow* uWnd, IntT n)
{
    NCursesPosition * uPos;
    ChTypeT ch;
    int x,y;

    /* ...starting with the current line... */
    uPos = uWnd->cursorPos;

    if( n>0 )
    {
        /*
         * The insdelln() and winsdelln() functions perform the following actions:
         *
         * If n is positive, these functions insert n lines into the current or specified
         * window before the current line.
         */
        IMPLEMENT_REQ("?insdelln.01.01;winsdelln.01.01");
        for(y = uWnd->nlines - 1 - n; (y >= uPos->y); y--)
        {
            for(x=0;x<uWnd->ncols;x++)
            {
                ch = getElement_NCursesWindow_YX(uWnd, y, x);
                setElement_NCursesWindow_YX(uWnd, y+n, x, ch);
            }
        }

        /*
         * The insdelln() and winsdelln() functions perform the following actions:
         *
         * The n last lines are no longer displayed.
         */
        IMPLEMENT_REQ("?insdelln.01.02;winsdelln.01.02");
        for(y = uPos->y; (y < uPos->y+n)&&(y < uWnd->nlines); y++)
        {
            for(x=0;x<uWnd->ncols;x++)
            {
                setElement_NCursesWindow_YX(uWnd, y, x, uWnd->bkgd);
            }
        }
    }
    else if( n<0 )
    {

        /*
         * If n is negative, these functions delete n lines from the current or specified
         * window starting with the current line, and move the remaining lines toward the
         * cursor.
         */
        IMPLEMENT_REQ("insdelln.02.01;winsdelln.02.01");
        if( uPos->y + (-n) > uWnd->nlines)
            n = - (uWnd->nlines - uPos->y);

        for( y = uPos->y + (-n); y < uWnd->nlines; y++)
        {
            for(x=0;x<uWnd->ncols;x++)
            {
                ch = getElement_NCursesWindow_YX(uWnd, y, x);
                setElement_NCursesWindow_YX(uWnd, y-(-n), x, ch);
            }
        }

        /*
         * The last n lines are cleared.
         */
        IMPLEMENT_REQ("insdelln.02.02;winsdelln.02.02");
        for(y = uWnd->nlines - (-n); y < uWnd->nlines; y++)
        {
            for(x=0;x<uWnd->ncols;x++)
            {
                setElement_NCursesWindow_YX(uWnd, y, x, uWnd->bkgd);
            }
        }
    }

    return 0;
}

/** insdelln_spec **/
//This specification refers to: insdelln, winsdelln
specification
IntT insdelln_spec( CallContext context, WindowTPtr* win, IntT n)
{
    NCursesWindow * oldWnd;

    pre
    {
        oldWnd = createNCursesWindow_Local( getUsedWindow(context, win) );

        insdelln_model(context, oldWnd, n);

        pushNCursesWindow(oldWnd);

        return true;
    }
    post
    {
        NCursesWindow * uWnd;
        NCursesPosition * uPos;
        int i, j;
        bool check;

        /*
         * current or specified window
         */
        uWnd = getUsedWindow(context, win);
        uPos = uWnd->cursorPos;

        /*
         * The current cursor position remains the same.
         */
        REQ("?insdelln.03;winsdelln.03", "cursor position remains the same",
            equals_NCursesPosition(uWnd->cursorPos, oldWnd->cursorPos)
           );


        if(insdelln_spec == SUT_ERR)
        {
            /*
             * Otherwise, they return ERR.
             */
            REQ("insdelln.04.02;winsdelln.04.02", "", TODO_REQ());

            /*[implicit condition]*/
            REQ("","screen shall not change", check_NCursesWindows(uWnd, oldWnd, CH_ALL, 1));

            return true;
        }

        /*
         * Upon successful completion, these functions return OK.
         */
        REQ("insdelln.04.01;winsdelln.04.01",
            "Upon successful completion, these functions return OK", insdelln_spec == SUT_EOK);

        REQ("","total comparison", check_NCursesWindows(uWnd, oldWnd, CH_ALL, 1));

        return true;
    }
}

void onInsdelln(CallContext context, WindowTPtr* win, IntT n, IntT insdelln_spec)
{
    updateNCursesWindowMayNULL( context, win);

    refresh_WindowTPtr(context,win,0);
}


/*
Linux Standard Base Core Specification 4.1

The interface ripoffline() shall behave as specified in X/Open Curses, except that 
ripoffline() shall return -1 if the number of lines that were ripped off exceeds five.

Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX (R) Specification, Version 2
Copyright (c) 1997 The Open Group

NAME

ripoffline - reserve a line for a dedicated purpose

SYNOPSIS

#include <curses.h>

int ripoffline(int line, int (*init)(WINDOW *win, int columns));

DESCRIPTION

The ripoffline() function reserves a screen line for use by the application.

Any call to ripoffline() must precede the call to initscr() or newterm().
If line is positive, one line is removed from the beginning of stdscr; if line
is negative, one line is removed from the end. Removal occurs during the
subsequent call to initscr() or newterm(). When the subsequent call is
made, the function pointed to by init is called with two arguments: a WINDOW
pointer to the one-line window that has been allocated and an integer with the
number of columns in the window. The initialisation function cannot use the
LINES and COLS external variables and cannot call wrefresh() or
doupdate(), but may call wnoutrefresh().

Up to five lines can be ripped off. Calls to ripoffline() above this limit
have no effect but report success.

RETURN VALUE

The ripoffline() function returns OK.

ERRORS

No errors are defined.

APPLICATION USAGE

Calling slk_init() reduces the size of the screen by one line if initscr()
eventually uses a line from stdscr to emulate the soft labels. If slk_init()
rips off a line, it thereby reduces by one the number of lines an application
can reserve by subsequent calls to ripoffline(). Thus, portable applications
that use soft label functions should not call ripoffline() more than four
times.

When initscr() or newterm() calls the initialisation function pointed to by
init, the implementation may pass NULL for the WINDOW pointer argument win.
This indicates inability to allocate a one-line window for the line that the
call to ripoffline() ripped off. Portable applications should verify that
win is not NULL before performing any operation on the window it represents.
*/

specification
IntT ripoffline_spec( CallContext context, IntT line, bool init)
{
    pre
    {
        NCursesWindow * tmp_win = getNCursesStdWindow(context);

        /*
         * Any call to ripoffline() must precede the call to initscr() or newterm().
         */
        REQ("?app.ripoffline.02", "must precede initscr() or newterm()", tmp_win == NULL);

        /*
         * The initialisation function cannot use the LINES and COLS external
         * variables and cannot call wrefresh() or doupdate()
         */
        REQ("app.ripoffline.06", "", TODO_REQ());

        return true;
    }
    post
    {
        List * old_rip_lines = @getRipLines(context);
        List * rip_lines = getRipLines(context);
        IntT old_rip_lines_count = (old_rip_lines?size_List(old_rip_lines):0);
        IntT rip_lines_count = (rip_lines?size_List(rip_lines):0);

        /* [function does nothing when called with such parameters] */
        if(line == 0)
            return true;
        if(init == 0)
            return true;

        if(old_rip_lines_count<5)
        {
            /*
             * The ripoffline() function reserves a screen line for use by the application.
             */
            REQ("?ripoffline.01", "reserves a screen line",
                rip_lines_count == old_rip_lines_count + 1
               );
        }

        /*
         * When the subsequent call is made, the function pointed to by init is called
         * with two arguments: a WINDOW pointer to the one-line window that has been
         * allocated and an integer with the number of columns in the window.
         */
        /* ripoffline.05 tests in terminal_mode.sec */

        /*
         * Up to five lines can be ripped off.
         */
        REQ("?ripoffline.07", "Up to five lines can be ripped off", rip_lines_count <= MAX_RIP_LINES);

        if(old_rip_lines_count == MAX_RIP_LINES)
        {
            /*
             * Calls to ripoffline() above this limit have no effect but report success.
             */
            REQ("?ripoffline.08", "have no effect", equals(old_rip_lines, rip_lines));
        }

        if(old_rip_lines_count == MAX_RIP_LINES)
        {
            /*
             * Outdated:
             * Calls to ripoffline() above this limit have no effect but report success.
             */
            /* Actual:
             * ripoffline() shall return -1 if the number of lines that were ripped off exceeds five.
             */
            REQ("ripoffline.09", "ripoffline() shall return -1 if the number of lines that were ripped off exceeds five", ripoffline_spec == -1);
        }
        else
        {
            /*
            * The ripoffline() function returns OK.
            */
            REQ("ripoffline.09", "returns OK", ripoffline_spec == SUT_EOK);
        }

        /*
         * The initialisation function ... may call wnoutrefresh().
         */
        REQ("ripoffline.10", "init function may call wnoutrefresh()", TODO_REQ());

        return true;
    }
}

void onRipoffline(CallContext context, IntT line_n, RipCallbackFunc init, IntT ripoffline_spec )
{
    List * riplist;
    IntT nTopLines, nBotomLines; // amount of top and bottom reserved lines
    int i;
    int size_riplist;

    if(line_n == 0)
        return;
    if(init == 0)
        return;


    riplist = getRipLines(context);

    size_riplist = size_List(riplist);

    /* Up to five lines can be ripped off. */
    if(size_riplist == MAX_RIP_LINES)
        return;

    /* [calculating of amount of top and bottom lines] */
    nTopLines = -1; nBotomLines = 0;
    for(i=0;i<size_riplist;i++)
    {
        RipLineT * ripline = (RipLineT *)get_List(riplist,i);

        if( (line_n > 0) && (ripline->line >= 0) )
            nTopLines++;

        if( (line_n < 0) && (ripline->line<0) )
            nBotomLines--;
    }

    /* If line is positive, one line is removed from the beginning of stdscr */
    if(line_n>0)
        line_n = nTopLines+1;
    /*  if line is negative, one line is removed from the end */
    if(line_n<0)
        line_n = nBotomLines-1;

    addRipLine(context, create_RipLineT(line_n, init, NULL_VoidTPtr, 0));
}


/********************************************************************/
/**                      Helper Functions                          **/
/********************************************************************/

NCursesWindow * getUsedWindow(CallContext context, WindowTPtr * win)
{
    NCursesWindow* rwin;

    if (win!=NULL)
        rwin = getWindow(win);
    else
        rwin = getNCursesStdWindow(context);

    return rwin;
}

NCursesPosition * getUsedPos(CallContext context, NCursesPosition* position, NCursesWindow * curWnd)
{
    NCursesPosition * rpos;

    if (position!=NULL)
        rpos = position;
    else
        rpos = curWnd->cursorPos;

    return rpos;
}
