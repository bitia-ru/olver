/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "common/common_scenario.seh"
#include "ncurses/bkgd/tests/bkgd_scenario.seh"
#include "ncurses/window/window_model.seh"
#include "ncurses/terminal/terminal_model.seh"
#include "ncurses/chstr/input_model.seh"
#include "ncurses/chstr/add_model.seh"
#include "ncurses/clear/clear_model.seh"

/********************************************************************/
/**                     Test Scenario Parameters                   **/
/********************************************************************/

/********************************************************************/
/**                       Test Scenario Data                       **/
/********************************************************************/
static CallContext context;

/********************************************************************/
/**                         Auxiliary Types                        **/
/********************************************************************/

/********************************************************************/
/**                     Model State Operations                     **/
/********************************************************************/

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/********************************************************************/

/********************************************************************/
/**                  Test Scenario Initialization                  **/
/********************************************************************/

void cleanup_bkgd_simple_scenario()
{
}

bool init_bkgd_simple_scenario(int argc, char** argv)
{
    context = createProcessForNCurses(40, 40);
    initReqFilters();

    return true;
}

void finish_bkgd_simple_scenario(void)
{
    cleanup_bkgd_simple_scenario();
    TEST_SCENARIO_VERDICT_VERBOSE(bkgd_simple_scenario);
}

/********************************************************************/
/**                          Test Actions                          **/
/********************************************************************/

scenario
bool bkgd_simple_scen() 
{
    ChTypeT ch, ch1, res;
    NewWinReturnType* winRet;
    NCursesWindow* std_win;
    NCursesPosition* pos = create_NCursesPosition(0, 0);
    ChTypeTArray* chstr_bg = create_ChTypeTArray(4);
    ChTypeTArray* chstr_test = create_ChTypeTArray(4);
    ChTypeTArray* chstr_res = create_ChTypeTArray(4);
    IntT n = 4;
    int i, j;
    InchnStrReturnType* str;
    String* tmp;

    ChTypeT a = {0}, a_alt = {0}, h = {0}, h_alt = {0}, x = {0}, x_alt = {0};
    typedef ChTypeT* PChTypeT;
    PChTypeT testBkgds[4] = {&a, &a_alt, &x, &x_alt};
    char names[4] = {'a', 'A', 'x', 'X'};


    initscr_spec(context);

    winRet = newwin_spec(context, 3, 10, 5, 5);
    std_win = getNCursesStdWindow(context);


    ch.altcharset = false;  // Alternate character set
    ch.blink = false;       // Blinking
    ch.bold = true;         // Extra bright or bold
    ch.dim = false;         // Half bright
    ch.invis = false;       // Invisible
    ch.protect = false;     // Protected
    ch.reverse = false;     // Reverse video
    ch.standout = false;    // Best highlighting mode of the terminal
    ch.underline = false;   // Underlining
    ch.colorPair = 0x00;
    ch.letter = 'a';

    ch1.altcharset = true;  // Alternate character set
    ch1.blink = true;       // Blinking
    ch1.bold = true;        // Extra bright or bold
    ch1.dim = true;         // Half bright
    ch1.invis = true;       // Invisible
    ch1.protect = true;     // Protected
    ch1.reverse = true;     // Reverse video
    ch1.standout = true;    // Best highlighting mode of the terminal
    ch1.underline = true;   // Underlining
    ch1.colorPair = 0x56;
    ch1.letter = 'x';

    //////////////////////////////////////////////////////////////////////////
    // Simple calls
    bkgd_spec(context, NULL, ch);
    res = getbkgd_spec(context, &(std_win->address));
    REQ("", "getbkgd should return the previously set character",
        equals_ChTypeT(res, ch)
       );

    ch.letter = 'b';
    bkgd_spec(context, &(winRet->win), ch);
    res = getbkgd_spec(context, &(winRet->win));
    REQ("", "getbkgd should return the previously set character",
        equals_ChTypeT(res, ch)
       );

    ch.letter = 'c';
    bkgdset_spec(context, NULL, ch);
    res = getbkgd_spec(context, &(std_win->address));
    REQ("", "getbkgd should return the previously set character",
        equals_ChTypeT(res, ch)
       );

    ch.letter = 'd';
    bkgdset_spec(context, &(winRet->win), ch);
    res = getbkgd_spec(context, &(winRet->win));
    REQ("", "getbkgd should return the previously set character",
        equals_ChTypeT(res, ch)
       );

    ch.letter = 'a';

    //////////////////////////////////////////////////////////////////////////
    // Check clearing of the window
    chstr_bg->arr[0] = ch;
    chstr_bg->arr[1] = ch;
    chstr_bg->arr[2] = ch;
    chstr_bg->arr[3] = ch;

    chstr_test->arr[0] = ch;
    chstr_test->arr[1] = ch;
    chstr_test->arr[2] = ch;
    chstr_test->arr[3] = ch;
    chstr_test->arr[1].letter = 'b';
    chstr_test->arr[1].altcharset = true;
    chstr_test->arr[1].colorPair = 0x12;
    chstr_test->arr[2].letter = 'x';
    chstr_test->arr[2].underline = true;
    chstr_test->arr[2].bold = false;
    chstr_test->arr[2].colorPair = 0x70;

    addchstr_spec(context, chstr_test, &n, &(winRet->win), pos);
    bkgd_spec(context, &(winRet->win), ch);
    clear_spec(context, &(winRet->win), false);
    str = inchstr_spec(context, &n, &(winRet->win), pos);
    REQ("", "cleared window should contain only background chars",
        equals(str->chstr, chstr_bg)
       );

    addchstr_spec(context, chstr_test, &n, &(winRet->win), pos);
    bkgdset_spec(context, &(winRet->win), ch);
    clear_spec(context, &(winRet->win), false);
    str = inchstr_spec(context, &n, &(winRet->win), pos);
    REQ("", "cleared window should contain only background chars",
        equals(str->chstr, chstr_bg)
       );

    //////////////////////////////////////////////////////////////////////////
    // Check setting new background char:
    // 1. Prepare the test string
    chstr_test->arr[0] = ch1;
    chstr_test->arr[1] = ch;
    chstr_test->arr[2] = ch1;
    chstr_test->arr[3] = ch;

    chstr_test->arr[1].letter = 'x';
    chstr_test->arr[2].letter = 'a';

    // 2. Construct the resultant string (what should appear after changing)
    ch.dim = true;
    ch.letter = 'b';

    chstr_res->arr[0] = ch;
    chstr_res->arr[0].altcharset = true;
    chstr_res->arr[0].letter = 'x';
    chstr_res->arr[1] = ch;
    chstr_res->arr[1].letter = 'x';
    chstr_res->arr[2] = ch;
    chstr_res->arr[2].altcharset = true;
    chstr_res->arr[2].letter = 'a';
    chstr_res->arr[3] = ch;
    chstr_res->arr[3].letter = 'b';

    // 3. Perform the setting and checking
    addchstr_spec(context, chstr_test, &n, &(winRet->win), pos);
    bkgd_spec(context, &(winRet->win), ch);
    str = inchstr_spec(context, &n, &(winRet->win), pos);
    REQ("", "setting a background char should convert the existing chars",
        equals(str->chstr, chstr_res)
       );

    //////////////////////////////////////////////////////////////////////////
    // Check A_ALTCHARSET features
    a_alt.altcharset = true;
    h_alt.altcharset = true;
    x_alt.altcharset = true;
    a.letter = a_alt.letter = 'a';
    h.letter = h_alt.letter = 'h';
    x.letter = x_alt.letter = 'x';
    chstr_test->arr[0] = a;
    chstr_test->arr[1] = a_alt;
    chstr_test->arr[2] = h;
    chstr_test->arr[3] = h_alt;

    for (i=0; i<4; ++i)
    {
        for (j=0; j<4; ++j)
        {
            if (j == i)
                continue;
            addchstr_spec(context, chstr_test, &n, NULL, pos);
            bkgdset_spec(context, NULL, *(testBkgds[i]));
            bkgd_spec(context, NULL, *(testBkgds[j]));
        }
    }

    endwin_spec(context);

    return true;
}

/********************************************************************/
/**                    Test Scenario Definition                    **/
/********************************************************************/

scenario dfsm bkgd_simple_scenario =
{
    .init = init_bkgd_simple_scenario,
    .finish = finish_bkgd_simple_scenario,
//     .getState = (PtrGetState)getSimpleState,
//     .saveModelState = (PtrSaveModelState)saveSimpleState,
//     .restoreModelState = (PtrRestoreModelState)restoreSimpleState,
//     .isStationaryState = (PtrIsStationaryState)isInitModelStateStationary,
    .actions = {
            bkgd_simple_scen,
            NULL
    }
};
