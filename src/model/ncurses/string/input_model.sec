/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/ncurses/ncurses_data.seh"
#include "data/ncurses_model.seh"
#include "ncurses/string/input_model.seh"
#include "config/type_config.seh"


#pragma SEC subsystem string "ncurses.string"



/*
   The group of functions 'ncurses.string.input' consists of:
       innstr [1]
       instr [1]
       mvinnstr [1]
       mvinstr [1]
       mvwinnstr [1]
       mvwinstr [1]
       winnstr [1]
       winstr [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    innstr, instr, mvinnstr, mvinstr, mvwinnstr, mvwinstr, winnstr, winstr -
        input a multi-byte character string from a window

SYNOPSIS

    #include <curses.h>
    int innstr(char *str, int n);
    int instr(char *str);
    int mvinnstr(int y, int x, char *str, int n);
    int mvinstr(int y, int x, char *str);
    int mvwinnstr(WINDOW *win, int y, int x, char *str, int n);
    int mvwinstr(WINDOW *win, int y, int x, char *str);
    int winnstr(WINDOW *win, char *str, int n);
    int winstr(WINDOW *win, char *str);

DESCRIPTION

    These functions place a string of characters from the current or specified
    window into the array pointed to by str, starting at the current or
    specified position and ending at the end of the line.

    The innstr(), mvinnstr(), mvwinnstr() and winnstr() functions store at
    most n bytes in the string pointed to by str.

    The innstr(), mvinnstr(), mvwinnstr() and winnstr() functions will only
    store the entire multi-byte sequence associated with a character.If the
    array is large enough to contain at least one character the array is
    filled with complete characters.If the array is not large enough to contain
    any complete characters, the function fails.

RETURN VALUE

    Upon successful completion, instr(), mvinstr(), mvwinstr() and winstr()
    return OK.

    Upon successful completion, innstr(), mvinnstr(), mvwinnstr() and winnstr()
    return the number of characters actually read into the string.

    Otherwise, all these functions return ERR.

ERRORS

    No errors are defined.
*/

specification typedef struct InStrReturnType InStrReturnType = {};

InStrReturnType* create_InStrReturnType(IntT result, CString* str)
{
    return create(&type_InStrReturnType, result, str);
}

//This specification refers to: mvwinnstr, winnstr, mvwinstr, winstr,
//mvinnstr, innstr, mvinstr, instr
specification
InStrReturnType* instr_spec( CallContext context, WindowTPtr* win, NCursesPosition* pos,  IntT* n)
{
    NCursesWindow*   curWnd = getWindowMayNULL(context, win);
    NCursesPosition* curPos = getWindowPositionMayNULL(curWnd, pos);
    IntT inPos, i;

    if (win!=NULL)
    {
        if (n!=NULL){
            if (pos!=NULL) {  FILTER("mvwinnstr"); }
            else{ FILTER("winnstr"); }
        }
        else{
            if (pos!=NULL){ FILTER("mvwinstr"); }
            else{ FILTER("winstr"); }
        }
    }
    else
    {
        if (n!=NULL){
            if (pos!=NULL){ FILTER("mvinnstr"); }
            else{ FILTER("innstr"); }
        }
        else{
            if (pos!=NULL){ FILTER("mvinstr"); }
            else{ FILTER("instr"); }
        }
    }


    pre
    {
        inPos = curPos->y*curWnd->ncols+curPos->x;

        return true;
    }
    post
    {
        if (instr_spec->result >=0)
        {
            if (n!=NULL)
            {
                /*
                * If the array is large enough to contain at least one character the array is
                * filled with complete characters.
                */
                /*
                * The innstr(), mvinnstr(), mvwinnstr() and winnstr() functions will only store
                * the entire multi-byte sequence associated with a character.
                */
                REQ("innstr.04;mvinnstr.04;mvwinnstr.04;winnstr.04;innstr.03;mvinnstr.03;mvwinnstr.03;winnstr.03",
                    "Complete characters shall be in array",
                    TODO_REQ());
            }

            for (i=0;i<length_CString(instr_spec->str);i++)
            {
                ChTypeT ch1=getElement_NCursesWindow_Offset(curWnd, inPos+i);
                CharT   ch=charAt_CString(instr_spec->str, i);

                if (inPos+i < (curPos->y+1)*curWnd->ncols && ch1.letter != -1)
                {
                    /*
                    * These functions place a string of characters from the current or specified
                    * window into the array pointed to by str, starting at the current or specified
                    * position and ending at the end of the line.
                    */
                    REQ("innstr.01;instr.01;mvinnstr.01;mvinstr.01;mvwinnstr.01;mvwinstr.01;winnstr.01;winstr.01",
                        "Character shall be valid",
                         ch == ch1.letter);
                }
            }

            if (n==NULL)
            {
                /*
                 * Upon successful completion, instr(), mvinstr(), mvwinstr() and winstr() return
                 * OK.
                 */
                REQ("instr.06.01;mvinstr.06.01;mvwinstr.06.01;winstr.06.01",
                    "Function shall return OK", instr_spec->result >= 0);
            }
            else
            {
                /*
                * The innstr(), mvinnstr(), mvwinnstr() and winnstr() functions store at most n
                * bytes in the string pointed to by str.
                */
                REQ("innstr.02;mvinnstr.02;mvwinnstr.02;winnstr.02",
                    "Function stores at most n bytes", length_CString(instr_spec->str) <= *n);

                /*
                * Upon successful completion, innstr(), mvinnstr(), mvwinnstr() and winnstr()
                * return the number of characters actually read into the string.
                */
                REQ("innstr.06.01;mvinnstr.06.01;mvwinnstr.06.01;winnstr.06.01", "Return value shall be valid",
                    instr_spec->result == length_CString(instr_spec->str));
            }

        }
        else
        {
            /*
            * Otherwise, all these functions return ERR.
            */
            REQ("innstr.06.02;instr.06.02;mvinnstr.06.02;mvinstr.06.02;mvwinnstr.06.02;mvwinstr.06.02;winnstr.06.02;winstr.06.02",
                "Function shall return ERR", instr_spec->result == SUT_ERR);
        }


        /*
        * If the array is not large enough to contain any complete characters, the
        * function fails.
        */
        REQ("innstr.05;mvinnstr.05;mvwinnstr.05;winnstr.05", "", TODO_REQ());

        return true;
    }
    FILTER_CLEAN;
}


void onInstr( CallContext context, WindowTPtr* win, NCursesPosition* pos,  IntT* n, InStrReturnType* instr_spec)
{
    NCursesWindow* curWnd = getWindowMayNULL(context, win);

    if (instr_spec->result != SUT_ERR)
    {
        if (pos!=NULL)
        {
            curWnd->cursorPos->x=pos->x;
            curWnd->cursorPos->y=pos->y;
        }
    }
}


/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
