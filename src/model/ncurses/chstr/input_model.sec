/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/ncurses/ncurses_data.seh"
#include "data/ncurses_model.seh"
#include "ncurses/chstr/input_model.seh"


#pragma SEC subsystem chstr "ncurses.chstr"

/*
   The group of functions 'ncurses.chstr.input' consists of:
       inchnstr [1]
       inchstr [1]
       mvinchnstr [1]
       mvinchstr [1]
       mvwinchnstr [1]
       mvwinchstr [1]
       winchnstr [1]
       winchstr [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers


The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    inchnstr, inchstr, mvinchnstr, mvinchstr, mvwinchnstr, mvwinchstr,
    winchnstr, winchstr - input an array of single-byte characters and
    renditions from a window

SYNOPSIS

    #include <curses.h>
    int inchnstr(chtype *chstr, int n);
    int inchstr(chtype *chstr);
    int mvinchnstr(int y, int x, chtype *chstr, int n);
    int mvinchstr(int y, int x, chtype *chstr);
    int mvwinchnstr(WINDOW *win, int y, int x, chtype *chstr, int n);
    int mvwinchstr(WINDOW *win, int y, int x, chtype *chstr);
    int winchnstr(WINDOW *win, chtype *chstr, int n);
    int winchstr(WINDOW *win, chtype *chstr);

DESCRIPTION

    These functions place characters and renditions from the current or
    specified window into the array pointed to by chstr, starting at the
    current or specified position and ending at the end of the line.

    The inchnstr(), mvinchnstr(), mvwinchnstr() and winchnstr() functions store
    at most n elements from the current or specified window into the array
    pointed to by chstr.

RETURN VALUE

    Upon successful completion, these functions return OK. Otherwise, they
    return ERR.

ERRORS

    No errors are defined.
*/


specification typedef struct InchnStrReturnType InchnStrReturnType = {};

InchnStrReturnType * create_InchnStrReturnType(
    IntT retVal,
    ChTypeTArray * chstr)
{
    return create(&type_InchnStrReturnType,
        retVal, chstr);
}

//This specification refers to: mvwinchnstr, winchnstr, mvwinchstr, winchstr,
//mvinchnstr, inchnstr, mvinchstr, inchstr
specification
InchnStrReturnType* inchstr_spec( CallContext context, IntT* n, WindowTPtr* win, NCursesPosition* pos)
{
    NCursesWindow* curWnd = getWindowMayNULL(context, win);
    NCursesPosition* curPos = getWindowPositionMayNULL(curWnd, pos);
    IntT inPos, i;

    if (win!=NULL){
        if (n!=NULL){
            if (pos!=NULL){
                FILTER("mvwinchnstr");
            }
            else{
                FILTER("winchnstr");
            }
        }
        else{
            if (pos!=NULL){
                FILTER("mvwinchstr");
            }
            else{
                FILTER("winchstr");
            }
        }
    }
    else{
        if (n!=NULL){
            if (pos!=NULL){
                FILTER("mvinchnstr");
            }
            else{
                FILTER("inchnstr");
            }
        }
        else{
            if (pos!=NULL){
                FILTER("mvinchstr");
            }
            else{
                FILTER("inchstr");
            }
        }
    }

    pre
    {
        inPos = curPos->y*curWnd->ncols+curPos->x;

        return true;
    }
    post
    {

        if (inchstr_spec->retVal != SUT_ERR)
        {
            /*
            * Upon successful completion, these functions return OK.
            */
            REQ("inchnstr.03.01;inchstr.03.01;mvinchnstr.03.01;mvinchstr.03.01;mvwinchnstr.03.01;mvwinchstr.03.01;winchnstr.03.01;winchstr.03.01",
                "Function shall return OK", inchstr_spec->retVal != SUT_ERR); // There is BUG in the implemention: function return number of chars added

            for (i=0;i<inchstr_spec->chstr->size;i++)
            {
                ChTypeT ch1=getElement_NCursesWindow_Offset(curWnd, inPos+i);
                ChTypeT ch2=(inchstr_spec->chstr->arr)[i];

                if (ch1.letter != -1)
                {
                    /*
                    * These functions place characters and renditions from the current or specified
                    * window into the array pointed to by chstr, starting at the current or specified
                    * position and ending at the end of the line.
                    */
                   REQ("inchnstr.01;inchstr.01;mvinchnstr.01;mvinchstr.01;mvwinchnstr.01;mvwinchstr.01;winchnstr.01;winchstr.01",
                       "Character shall be valid", equals(create_ChTypeTObj(ch1), create_ChTypeTObj(ch2)));
                }
            }

            if (n != NULL)
            {
                /*
                * The inchnstr(), mvinchnstr(), mvwinchnstr() and winchnstr() functions store at
                * most n elements from the current or specified window into the array pointed to
                * by chstr.
                */
                REQ("inchnstr.02;mvinchnstr.02;mvwinchnstr.02;winchnstr.02",
                    "Function stores at most n elements", inchstr_spec->chstr->size <= *n);
            }

        }
        else
        {
            /*
            * Otherwise, they return ERR.
            */
            REQ("inchnstr.03.02;inchstr.03.02;mvinchnstr.03.02;mvinchstr.03.02;mvwinchnstr.03.02;mvwinchstr.03.02;winchnstr.03.02;winchstr.03.02", "Function shall return ERR", inchstr_spec->retVal == SUT_ERR);
        }

        return true;
    }
    FILTER_CLEAN;
}


void onInchstr( CallContext context, IntT* n, WindowTPtr* win, NCursesPosition* pos, InchnStrReturnType* inchstr_spec)
{
    NCursesWindow* curWnd=getWindowMayNULL(context, win);

    if (inchstr_spec->retVal != SUT_ERR)
    {
        if (pos!=NULL)
        {
            curWnd->cursorPos->x = pos->x;
            curWnd->cursorPos->y = pos->y;
        }
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
