/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "ncurses/ncurses/ncurses_data.seh"
#include "data/ncurses_model.seh"
#include "ncurses/chstr/add_model.seh"


#pragma SEC subsystem chstr "ncurses.chstr"



/*
   The group of functions 'ncurses.chstr.add' consists of:
       addchnstr [1]
       addchstr [1]
       mvaddchnstr [1]
       mvaddchstr [1]
       mvwaddchnstr [1]
       mvwaddchstr [1]
       waddchnstr [1]
       waddchstr [1]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Single UNIX ® Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    addchstr, addchnstr, mvaddchstr, mvaddchnstr, mvwaddchstr, mvwaddchnstr,
    waddchstr, waddchnstr - add string of single-byte characters and renditions
    to a window

SYNOPSIS

    #include <curses.h>
    int addchstr(const chtype *chstr);
    int addchnstr(const chtype *chstr, int n);
    int mvaddchstr(int y, int x, const chtype *chstr);
    int mvaddchnstr(int y, int x, const chtype *chstr, int n);
    int mvwaddchstr(WINDOW *win, int y, int x, const chtype *chstr);
    int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *chstr,
        int n);
    int waddchstr(WINDOW *win, const chtype *chstr);
    int waddchnstr(WINDOW *win, const chtype *chstr, int n);


DESCRIPTION

    These functions overlay the contents of the current or specified window,
    starting at the current or specified position, with the contents of the
    array pointed to by chstr until a null chtype is encountered in the array
    pointed to by chstr.

    These functions do not change the cursor position. These functions do not
    perform special-character processing. These functions do not perform
    wrapping.

    The addchnstr(), mvaddchnstr(), mvwaddchnstr() and waddchnstr() functions
    copy at most n items, but no more than will fit on the current or specified
    line.If n is -1 then the whole string is copied, to the maximum number that
    fit on the current or specified line.

RETURN VALUE

    Upon successful completion, these functions return OK. Otherwise, they
    return ERR.

ERRORS

    No errors are defined.
*/

//This specification refers to: mvwaddchnstr, waddchnstr, mvwaddchstr, waddchstr,
//mvaddchnstr, addchnstr, mvaddchstr, addchstr
specification
IntT addchstr_spec( CallContext context, ChTypeTArray* chstr, IntT* n, WindowTPtr* win, NCursesPosition* pos)
{
    NCursesWindow* oldWindow=getWindowMayNULL(context, win);
    NCursesWindow* modifiedWindow;

    if (win!=NULL){
        if (n!=NULL){
            if (pos!=NULL){
                FILTER("mvwaddchnstr");
            }
            else{
                FILTER("waddchnstr");
            }
        }
        else{
            if (pos!=NULL){
                FILTER("mvwaddchstr");
            }
            else{
                FILTER("waddchstr");
            }
        }
    }
    else{
        if (n!=NULL){
            if (pos!=NULL){
                FILTER("mvaddchnstr");
            }
            else{
                FILTER("addchnstr");
            }
        }
        else{
            if (pos!=NULL){
                FILTER("mvaddchstr");
            }
            else{
                FILTER("addchstr");
            }
        }
    }

    pre
    {
        modifiedWindow = addchstr_model(context, chstr, n, win, pos);

        return true;
    }
    post
    {
        NCursesWindow* curWnd=getWindowMayNULL(context, win);

        if (addchstr_spec!=SUT_EOK)
        {
            /*
            * Otherwise, they return ERR.
            */
            REQ("addchstr.07.02;addchnstr.07.02;mvaddchstr.07.02;mvaddchnstr.07.02;mvwaddchstr.07.02;mvwaddchnstr.07.02;waddchstr.07.02;waddchnstr.07.02", "Function shall return NULL", addchstr_spec==SUT_ERR);
        }
        else
        {
            NCursesWindow* curWnd=getWindowMayNULL(context, win);

            /*
            * Upon successful completion, these functions return OK.
            */
            REQ("addchstr.07.01;addchnstr.07.01;mvaddchstr.07.01;mvaddchnstr.07.01;mvwaddchstr.07.01;mvwaddchnstr.07.01;waddchstr.07.01;waddchnstr.07.01",
                "Function shall return OK", addchstr_spec==SUT_EOK);

            if (pos==NULL)
            {
                /*
                * These functions do not change the cursor position.
                */
                REQ("addchstr.02;addchnstr.02;mvaddchstr.02;mvaddchnstr.02;mvwaddchstr.02;mvwaddchnstr.02;waddchstr.02;waddchnstr.02",
                    "Cursor position shall not be changed", equals(oldWindow->cursorPos, curWnd->cursorPos));
            }
            else
            {
                /*
                * These functions do not change the cursor position.
                */
                REQ("addchstr.02;addchnstr.02;mvaddchstr.02;mvaddchnstr.02;mvwaddchstr.02;mvwaddchnstr.02;waddchstr.02;waddchnstr.02",
                    "Cursor position shall be at the old position", equals(pos, curWnd->cursorPos));

            }
            /*
            * These functions do not perform special-character processing.
            */
            REQ("addchstr.03;addchnstr.03;mvaddchstr.03;mvaddchnstr.03;mvwaddchstr.03;mvwaddchnstr.03;waddchstr.03;waddchnstr.03", "", TODO_REQ());

            {
                NCursesPosition* curPos=getWindowPositionMayNULL(curWnd, pos);
                if (getChStrLength(chstr, n) > curWnd->ncols-curPos->x && curPos->y < curWnd->nlines-1)
                {
                    IntT i;

                    for (i=(curPos->y+1)*curWnd->ncols;i<curWnd->ncols*curWnd->nlines;i++)
                    {
                        /*
                        * These functions do not perform wrapping.
                        */
                        REQ("addchstr.04;addchnstr.04;mvaddchstr.04;mvaddchnstr.04;mvwaddchstr.04;mvwaddchnstr.04;waddchstr.04;waddchnstr.04",
                            "Data on the next lines shall not be changed",
                            equals_ChTypeT(getElement_NCursesWindow_Offset(curWnd, i),
                            getElement_NCursesWindow_Offset(oldWindow, i)));
                    }
                }
            }

            /*
            * [Compare model window with the real window]
            */
            REQ("", "Data in the window shall be valid", check_NCursesWindows(curWnd, modifiedWindow, CH_ALL, 10));

        }

        return true;
    }
    FILTER_CLEAN;
}


NCursesWindow* addchstr_model( CallContext context, ChTypeTArray* chstr, IntT* n, WindowTPtr* win, NCursesPosition* pos)
{
    NCursesWindow* curWnd;
    NCursesPosition* curPos;
    IntT numChars;
    IntT insPos;
    IntT i;


    curWnd=createNCursesWindow_Local(getWindowMayNULL(context, win));
    curPos=getWindowPositionMayNULL(curWnd, pos);

    insPos= curPos->y*curWnd->ncols+curPos->x;

    if (n!=NULL)
    {
        /*
        * The addchnstr(), mvaddchnstr(), mvwaddchnstr() and waddchnstr() functions copy
        * at most n items, but no more than will fit on the current or specified line.
        */
        IMPLEMENT_REQ("addchnstr.05;mvaddchnstr.05;mvwaddchnstr.05;waddchnstr.05");

        numChars=min(getChStrLength(chstr, n), curWnd->ncols-curPos->x);
    }
    else
    {
        numChars=min(getChStrLength(chstr, NULL), curWnd->ncols-curPos->x);
    }


    for (i=insPos;i<insPos+numChars;i++)
    {
        NCursesPosition* pos = create_NCursesPosition(
            i % curWnd->ncols,
            i / curWnd->ncols);

        /*
        * These functions overlay the contents of the current or specified window,
        * starting at the current or specified position, with the contents of the array
        * pointed to by chstr until a null chtype is encountered in the array pointed to
        * by chstr.
        */
        IMPLEMENT_REQ("addchstr.01;addchnstr.01;mvaddchstr.01;mvaddchnstr.01;mvwaddchstr.01;mvwaddchnstr.01;waddchstr.01;waddchnstr.01");

//        setElement_NCursesWindow_Offset(curWnd, i, chstr->arr[i-insPos]);

        setElement_NCursesWindow_Refresh(curWnd, pos, chstr->arr[i-insPos], true);
    }


    curWnd->cursorPos->x = curPos->x;
    curWnd->cursorPos->y = curPos->y;

    pushNCursesWindow(curWnd);

    return curWnd;
}




void onAddchstr( CallContext context, ChTypeTArray* chstr, IntT* n, WindowTPtr* win, NCursesPosition* pos, IntT addchstr_spec)
{
    if (addchstr_spec==SUT_EOK)
    {
        updateNCursesWindowMayNULL(context, win);

        refresh_WindowTPtr(context, win, 0);
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

IntT getChStrLength(ChTypeTArray* chstr, IntT* n)
{
    IntT i;
    IntT numChars;

    if (n == NULL)
    {
        numChars=chstr->size;
    }
    else
    {
        numChars=*n;
    }


    if (numChars==-1)
    {
        /*
        * If n is -1 then the whole string is copied, to the maximum number that fit
        * on the current or specified line.
        */
        IMPLEMENT_REQ("addchnstr.06;mvaddchnstr.06;mvwaddchnstr.06;waddchnstr.06");

        numChars=chstr->size;
    }

    for (i=0;i<numChars;i++)
    {
        assertion(i<chstr->size, "getChStrLength: n is invalid");

        if (chstr->arr[i].letter == '\0')
        {
            return i;
        }
    }

    return i;

}
