/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "io/syslog/syslog_model.seh"
#include "io/syslog/syslog_media.seh"
#include "common/common_media.seh"
#include "io/syslog/syslog_model.seh"
#include "process/process/process_model.seh"

#pragma SEC subsystem syslog "io.syslog"

/*
   The group of functions 'io.syslog' consists of:
       closelog [1]
       openlog [1]
       setlogmask [1]
       syslog [1]
       vsyslog [2]
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
    Linux Standard Base Core Specification 3.1
    Copyright (c) 2004, 2005 Free Standards Group

        refers

    The Open Group Base Specifications Issue 6IEEE Std 1003.1,
    2004 EditionCopyright (c) 2001-2004 The IEEE and The Open Group,
    All Rights reserved.

    NAME

    closelog, openlog, setlogmask, syslog - control system log

    SYNOPSIS

    [XSI] #include <syslog.h>void closelog(void);void openlog(const char *
    ident, int logopt, int facility);int setlogmask(int maskpri);void syslog(int
    priority, const char *message, ... * arguments *);

    DESCRIPTION

    The syslog() function shall send a message to an implementation-defined logging
    facility, which may log it in an implementation-defined system log, write it to
    the system console, forward it to a list of users, or forward it to the logging
    facility on another host over the network. The logged message shall include a
    message header and a message body. The message header contains at least a
    timestamp and a tag string.

    The message body is generated from the message and following arguments in the
    same manner as if these were arguments to printf(), except that the additional
    conversion specification %m shall be recognized; it shall convert no arguments,
    shall cause the output of the error message string associated with the value of
    errno on entry to syslog(), and may be mixed with argument specifications of
    the "%n$" form. If a complete conversion specification with the m conversion
    specifier character is not just %m, the behavior is undefined. A trailing <
    newline> may be added if needed.

    Values of the priority argument are formed by OR'ing together a severity-level
    value and an optional facility value. If no facility value is specified, the
    current default facility value is used.

    Possible values of severity level include:

    LOG_EMERG A panic condition. LOG_ALERT A condition that should be
    corrected immediately, such as a corrupted system database. LOG_CRIT
    Critical conditions, such as hard device errors. LOG_ERR Errors.
    LOG_WARNING Warning messages. LOG_NOTICE Conditions that are not error
    conditions, but that may require special handling. LOG_INFO Informational
    messages. LOG_DEBUG Messages that contain information normally of use only
    when debugging a program.

    The facility indicates the application or system component generating the
    message. Possible facility values include:

    LOG_USER Messages generated by arbitrary processes. This is the default
    facility identifier if none is specified. LOG_LOCAL0 Reserved for local use.
    LOG_LOCAL1 Reserved for local use. LOG_LOCAL2 Reserved for local use.
    LOG_LOCAL3 Reserved for local use. LOG_LOCAL4 Reserved for local use.
    LOG_LOCAL5 Reserved for local use. LOG_LOCAL6 Reserved for local use.
    LOG_LOCAL7 Reserved for local use.

    The openlog() function shall set process attributes that affect subsequent
    calls to syslog(). The ident argument is a string that is prepended to every
    message. The logopt argument indicates logging options. Values for logopt are
    constructed by a bitwise-inclusive OR of zero or more of the following:

    LOG_PID Log the process ID with each message. This is useful for identifying
    specific processes.

    LOG_CONS Write messages to the system console if they cannot be sent to the
    logging facility. The syslog() function ensures that the process does not
    acquire the console as a controlling terminal in the process of writing the
    message. LOG_NDELAY Open the connection to the logging facility immediately.
    Normally the open is delayed until the first message is logged. This is useful
    for programs that need to manage the order in which file descriptors are
    allocated. LOG_ODELAY Delay open until syslog() is called. LOG_NOWAIT
    Do not wait for child processes that may have been created during the course of
    logging the message. This option should be used by processes that enable
    notification of child termination using SIGCHLD, since syslog() may otherwise
    block waiting for a child whose exit status has already been collected.

    The facility argument encodes a default facility to be assigned to all messages
    that do not have an explicit facility already encoded. The initial default
    facility is LOG_USER.

    The openlog() and syslog() functions may allocate a file descriptor. It is not
    necessary to call openlog() prior to calling syslog().

    The closelog() function shall close any open file descriptors allocated by
    previous calls to openlog() or syslog().

    The setlogmask() function shall set the log priority mask for the current
    process to maskpri and return the previous mask. If the maskpri argument is 0,
    the current log mask is not modified. Calls by the current process to syslog()
    with a priority not set in maskpri shall be rejected. The default log mask
    allows all priorities to be logged. A call to openlog() is not required prior
    to calling setlogmask().

    Symbolic constants for use as values of the logopt, facility, priority, and
    maskpri arguments are defined in the <syslog.h> header.

    RETURN VALUE

    The setlogmask() function shall return the previous log priority mask. The
    closelog(), openlog(), and syslog() functions shall not return a value.

    ERRORS

    No errors are defined.
*/

specification
void closelog_spec(CallContext context)
{
    pre
    {
        return true;
    }

    post
    {
        /*
         * The closelog() function shall close any open file descriptors allocated by
         * previous calls to openlog() or syslog().
         */
        REQ("closelog.01", "shall close descriptors", TODO_REQ());

        return true;
    }
}

specification
void openlog_spec(CallContext context, CString* ident, IntT logopt, IntT facility)
{
    pre
    {
        REQ("", "ident is not null", ident);

        return true;
    }

    coverage Ident
    {
        if(length_CString(ident))
            return { NormalString, "String size not 0" };

        return { EmptyString, "String size is 0" };
    }

    coverage Facility
    {
        switch(facility)
        {
        case SUT_LOG_LOCAL0: return { FacLogLoc0, "LOG_LOCAL0" };
        case SUT_LOG_LOCAL1: return { FacLogLoc1, "LOG_LOCAL1" };
        case SUT_LOG_LOCAL2: return { FacLogLoc2, "LOG_LOCAL2" };
        case SUT_LOG_LOCAL3: return { FacLogLoc3, "LOG_LOCAL3" };
        case SUT_LOG_LOCAL4: return { FacLogLoc4, "LOG_LOCAL4" };
        case SUT_LOG_LOCAL5: return { FacLogLoc5, "LOG_LOCAL5" };
        case SUT_LOG_LOCAL6: return { FacLogLoc6, "LOG_LOCAL6" };
        case SUT_LOG_LOCAL7: return { FacLogLoc7, "LOG_LOCAL7" };
        }
        /*case SUT_LOG_USER:*/ return { FacLogUser, "LOG_USER" };
    }

    post
    {
        /*
         * The facility indicates the application or system component generating the
         * message. Possible facility values include:
         *
         * LOG_USER Messages generated by arbitrary processes. This is the default
         * facility identifier if none is specified.
         * LOG_LOCAL0 Reserved for local use.
         * LOG_LOCAL1 Reserved for local use.
         * LOG_LOCAL2 Reserved for local use.
         * LOG_LOCAL3 Reserved for local use.
         * LOG_LOCAL4 Reserved for local use.
         * LOG_LOCAL5 Reserved for local use.
         * LOG_LOCAL6 Reserved for local use.
         * LOG_LOCAL7 Reserved for local use.
         */
        REQ("openlog.01.L0;openlog.01.L1;openlog.01.L2;openlog.01.L3;openlog.01.L4;"
            "openlog.01.L5;openlog.01.L6;openlog.01.L7;openlog.01.USR", "possible values", TODO_REQ());

        /*
         * The ident argument is a string that is prepended to every message.
         */
        REQ("?openlog.03", "the ident is prepended to every msg",
            equals(getSysLogIdent(context), ident));

        /*
         * The logopt argument indicates logging options.
         */
        REQ("", "shall set the logging options", getSysLogOptions(context) == logopt);

        /*
         * The logopt argument indicates logging options.
         *
         * Values for logopt are constructed by a bitwise-inclusive OR of zero or more of
         * the following:
         *
         * LOG_PID Log the process ID with each message. This is useful for identifying
         * specific processes.
         */
        REQ("openlog.04.01.PID", "possible value", TODO_REQ());

        /*
         * The logopt argument indicates logging options.
         *
         * Values for logopt are constructed by a bitwise-inclusive OR of zero or more of
         * the following:
         *
         * LOG_CONS Write messages to the system console if they cannot be sent to the
         * logging facility. The syslog() function ensures that the process does not
         * acquire the console as a controlling terminal in the process of writing the
         * message.
         *
         * Write messages to the system console if they cannot be sent to the logging
         * facility.
         */
        REQ("openlog.04.01.CON.01", "possible value, write msg to the sys console",
            TODO_REQ());

        /*
         * The logopt argument indicates logging options.
         *
         * Values for logopt are constructed by a bitwise-inclusive OR of zero or more of
         * the following:
         *
         * LOG_CONS Write messages to the system console if they cannot be sent to the
         * logging facility. The syslog() function ensures that the process does not
         * acquire the console as a controlling terminal in the process of writing the
         * message.
         *
         * The syslog() function ensures that the process does not acquire the console as
         * a controlling terminal in the process of writing the message.
         */
        REQ("openlog.04.01.CON.02", "possible value, process actions condition", TODO_REQ());

        /*
         * The logopt argument indicates logging options.
         *
         * Values for logopt are constructed by a bitwise-inclusive OR of zero or more of
         * the following:
         *
         * LOG_NDELAY Open the connection to the logging facility immediately. Normally
         * the open is delayed until the first message is logged. This is useful for
         * programs that need to manage the order in which file descriptors are allocated.
         */
        REQ("openlog.04.01.NDE", "possible value", TODO_REQ());

        /*
         * The logopt argument indicates logging options.
         *
         * Values for logopt are constructed by a bitwise-inclusive OR of zero or more of
         * the following:
         *
         * LOG_ODELAY Delay open until syslog() is called.
         */
        REQ("openlog.04.01.ODE", "possible value", TODO_REQ());

        /*
         * The logopt argument indicates logging options.
         *
         * Values for logopt are constructed by a bitwise-inclusive OR of zero or more of
         * the following:
         *
         * LOG_NOWAIT Do not wait for child processes that may have been created during
         * the course of logging the message. This option should be used by processes that
         * enable notification of child termination using SIGCHLD, since syslog() may
         * otherwise block waiting for a child whose exit status has already been
         * collected.
         */
        REQ("openlog.04.01.NOW", "possible value", TODO_REQ());

        /*
         * The facility argument encodes a default facility to be assigned to all messages
         * that do not have an explicit facility already encoded.
         */
        REQ("?openlog.05", "shall set the default facility",
            getSysLogFacility(context) == facility);

        /*
         * The openlog() and syslog() functions may allocate a file descriptor.
         */
        REQ_UNCHECKABLE("openlog.06", "it is very difficult to check");



        return true;
    }
}

void onOpenLog(CallContext context, CString* id, IntT logopt, IntT fac)
{
    SysLogState* syslogState = getSysLogState(context);

    syslogState->sIdent = clone(id);
    syslogState->LogOpt = logopt;
    syslogState->Facility = fac;

    syslogState->isOpenLogUp = true;
}

specification
IntT setlogmask_spec(CallContext context, IntT maskpri)
{
    pre
    {
        return true;
    }

    coverage MaskPri
    {
        if(maskpri) return { MaskNotZero, "Mask Isn't Zero" };
        return { MaskZero, "Mask Is Zero" };
    }

    post
    {
#ifdef NewCTesK
        if( MaskPri == MaskPri.MaskZero )
#else
        if(coverage(MaskPri) == MaskZero)
#endif
        {
            /*
             * If the maskpri argument is 0, the current log mask is not modified.
             */
            REQ("?setlogmask.02", "if the maskpri is 0",
                getSysLogMask(context) == @getSysLogMask(context));
        }
        else
        {
            /*
             * The setlogmask() function shall set the log priority mask for the current
             * process to maskpri and return the previous mask.
             */
            REQ("?setlogmask.01", "shall set the log priority mask",
                getSysLogMask(context) == maskpri);
        }

        if(isSysLogMaskUp(context))
        {
            /*
             * The setlogmask() function shall return the previous log priority mask.
             */
            REQ("?setlogmask.04", "shall return the previos log mask",
                setlogmask_spec == @getSysLogMask(context));
        }

        if(isSysLogOpenLogUp(context))
        {
            /*
             * A call to openlog() is not required prior to calling setlogmask().
             */
            REQ("setlogmask.03", "openlog() calling isn't required prior", true);
        }

        return true;
    }
}

void onSetLogMask(CallContext context, IntT maskpri)
{
    if(maskpri != 0) setSysLogMask(context, maskpri);
}

/*
 * The specification syslog_spec decribes requirements for syslog and vsyslog functions.
 * The parameter 'bv' specifies the function: if bv is true, syslog is used; if bv is false, vsyslog is used.
 */
specification
void syslog_spec(CallContext context, IntT priority, CString* message, List* args, bool bv)
{
    if(bv) FILTER("vsyslog");
    else FILTER("syslog");

    pre
    {
        REQ("", "message is not null", message);

        /*
         * If a complete conversion specification with the m conversion specifier
         * character is not just %m, the behavior is undefined.
         */
        REQ("app.vsyslog.04;app.syslog.04", "", TODO_REQ());

        return true;
    }

    coverage Func
    {
        if(!bv) return { SysLog, "syslog function" };
        return { vSysLog, "vsyslog function" };
    }

    post
    {
        /*
         * The logged message shall include a message header and a message body.
         *
         * The message header contains at least a timestamp and a tag string.
         */
        REQ("vsyslog.02.01;syslog.02.01", "", TODO_REQ());

        /*
         * The logged message shall include a message header and a message body.
         *
         * The message body is generated from the message and following arguments in the
         * same manner as if these were arguments to printf(),
         */
        REQ("vsyslog.02.02;syslog.02.02", "", TODO_REQ());

        /*
         * except that the additional conversion specification %m shall be recognized; it
         * shall convert no arguments, shall cause the output of the error message string
         * associated with the value of errno on entry to syslog(), and may be mixed with
         * argument specifications of the "%n$" form.
         */
        REQ("vsyslog.03;syslog.03", "", TODO_REQ());

        /*
         * A trailing <newline> may be added if needed.
         */
        REQ("vsyslog.05;syslog.05", "", TODO_REQ());

        if(!isSysLogOpenLogUp(context))
            /*
             * Values of the priority argument are formed by OR'ing together a severity-level
             * value and an optional facility value.
             *
             * If no facility value is specified, the current default facility value is used.
             */
            REQ("vsyslog.06.01;syslog.06.01", "the current default facility value is used",
                getSysLogFacility(context) == SUT_LOG_USER);

        /*
         * Possible values of severity level include:
         * LOG_EMERG A panic condition.
         */
        REQ("vsyslog.06.02.EME;syslog.06.02.EME", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_ALERT A condition that should be
         * corrected immediately, such as a corrupted system database.
         */
        REQ("vsyslog.06.02.ALE;syslog.06.02.ALE", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_CRIT Critical conditions, such as hard device errors.
         */
        REQ("vsyslog.06.02.CRI;syslog.06.02.CRI", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_ERR Errors.
         */
        REQ("vsyslog.06.02.ERR;syslog.06.02.ERR", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_WARNING Warning messages.
         */
        REQ("vsyslog.06.02.WAR;syslog.06.02.WAR", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_NOTICE Conditions that are not error
         * conditions, but that may require special handling.
         */
        REQ("vsyslog.06.02.NOT;syslog.06.02.NOT", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_INFO Informational messages.
         */
        REQ("vsyslog.06.02.INF;syslog.06.02.INF", "", TODO_REQ());

        /*
         * Possible values of severity level include:
         * LOG_DEBUG Messages that contain information normally of use only
         * when debugging a program.
         */
        REQ("vsyslog.06.02.DEB;syslog.06.02.DEB", "", TODO_REQ());

        if(!isSysLogOpenLogUp(context))
        {
            /*
             * The initial default facility is LOG_USER.
             */
            REQ("?vsyslog.07;syslog.07", "initial default facility",
                getSysLogFacility(context) == SUT_LOG_USER);


        }

        /*
         * The openlog() and syslog() functions may allocate a file descriptor.
         */
        REQ_UNCHECKABLE("vsyslog.08;syslog.08", "it is very difficult to check");

        /*
         * Calls by the current process to syslog() with a priority not set in maskpri
         * shall be rejected.
         */
        REQ("vsyslog.10;syslog.10", "", TODO_REQ());

        if(!isSysLogMaskUp(context))
        {
            /*
             * The default log mask allows all priorities to be logged.
             */
            REQ("vsyslog.11;syslog.11", "default log mask", TODO_REQ());
        }


        return true;
    }

    FILTER_CLEAN;
}

/********************************************************************/
/**                       Specification Types                      **/
/********************************************************************/

specification typedef struct SysLogState SysLogState = {};

SysLogState* create_SysLogStateDefault(void)
{
    return create(&type_SysLogState,
        NULL,
        0,
        0xFF,
        SUT_LOG_USER,
        false,
        false);
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

SysLogState* getSysLogState(CallContext context)
{
    registerProcessStaticData(context, _CS("SysLog"), create_SysLogStateDefault());

    return getProcessStaticData(context, _CS("SysLog"));
}

bool isSysLogMaskUp(CallContext context)
{
    SysLogState* syslogState = getSysLogState(context);

    return syslogState->isMaskUp;
}

IntT getSysLogMask(CallContext context)
{
    SysLogState* syslogState = getSysLogState(context);

    return syslogState->Mask;
}

IntT setSysLogMask(CallContext context, IntT maskpri)
{
    SysLogState* syslogState = getSysLogState(context);
    IntT preMask = syslogState->Mask;

    syslogState->Mask = maskpri;
    syslogState->isMaskUp = true;

    return preMask;
}

bool isSysLogOpenLogUp(CallContext context)
{
    SysLogState* syslogState = getSysLogState(context);

    return syslogState->isOpenLogUp;
}

CString* getSysLogIdent(CallContext context)
{
    SysLogState* syslogState = getSysLogState(context);

    return syslogState->sIdent;
}

IntT getSysLogOptions(CallContext context)
{
    SysLogState* syslogState = getSysLogState(context);

    return syslogState->LogOpt;
}

IntT getSysLogFacility(CallContext context)
{
    SysLogState* syslogState = getSysLogState(context);

    return syslogState->Facility;
}
