/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "common/common_media.seh"
#include "config/system_config.seh"
#include "data/embed_model.seh"
#include "data/errno_model.seh"
#include "io/term/term_media.seh"

/********************************************************************/
/**                 Deferred Reactions Processors                  **/
/********************************************************************/
static void close_tty_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        close_tty_return,
        create_CloseTTYReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void open_tty_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    FileDescId returned_value = WrongFileDescId;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value.system   = threadId.system;
    returned_value.process  = threadId.process;
    returned_value.filedesc = readInt_TSStream(stream);

    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        open_tty_return,
        create_OpenTTYReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void read_tty_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    SSizeT returned_value = -1;
    CByteArray *buf;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readSSize_TSStream(stream);
    buf = readCByteArray_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        read_tty_return,
        create_ReadTTYReturnType(threadId, returned_value, buf, errno),
        meta->timestamp
    );
}

static void tcdrain_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        tcdrain_return,
        create_TCReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void tcflow_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        tcflow_return,
        create_TCReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void tcflush_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        tcflush_return,
        create_TCReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void tcsendbreak_return_processor(ThreadId threadId, TSStream *stream,
                                         TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        tcsendbreak_return,
        create_TCReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void tcsetattr_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        tcsetattr_return,
        create_TCReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void tcsetpgrp_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    IntT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readInt_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        tcsetpgrp_return,
        create_TCReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

static void write_tty_return_processor(ThreadId threadId, TSStream *stream, TSMetaData *meta)
{
    SSizeT returned_value = -1;
    ErrorCode* errno = create_ErrorCode(SUT_EOK);

    returned_value = readSSize_TSStream(stream);
    *errno = readInt_TSStream(stream);

    registerReactionWithTimeInterval
    ( 
        getThreadChannelID(threadId),
        NULL,
        write_tty_return,
        create_WriteTTYReturnType(threadId, returned_value, errno),
        meta->timestamp
    );
}

/********************************************************************/
/**                          Formatters                            **/
/********************************************************************/
void writeTermIOS_TSStream(TSStream *stream, TermIOS *termios)
{
    CCTObj* ccobj;    
    
    assertion((stream != NULL),
        "writeTermIOS_TSStream: stream is NULL");
    assertion((termios != NULL),
        "writeTermIOS_TSStream: termios is NULL");

    writeTypeHeaderTSStream(stream, "termios");

    /* ispeed */
    writeUInt_TSStream(stream, termios->ispeed);

    /* ospeed */
    writeUInt_TSStream(stream, termios->ospeed);

    /* iflag */
    writeChar_TSStream(stream, termios->iflag->brkint ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->icrnl  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->ignbrk ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->igncr  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->ignpar ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->inlcr  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->inpck  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->istrip ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->ixany  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->ixoff  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->ixon   ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->iflag->parmrk ? '\xFF' : '\x00');

    /* oflag */
    writeChar_TSStream(stream, termios->oflag->opost  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->oflag->onlcr  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->oflag->ocrnl  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->oflag->onocr  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->oflag->onlret ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->oflag->ofill  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->oflag->ofdel  ? '\xFF' : '\x00');
    writeInt_TSStream(stream, termios->oflag->nldly);
    writeInt_TSStream(stream, termios->oflag->crdly);
    writeInt_TSStream(stream, termios->oflag->tbdly);
    writeInt_TSStream(stream, termios->oflag->bsdly);
    writeInt_TSStream(stream, termios->oflag->vtdly);
    writeInt_TSStream(stream, termios->oflag->ffdly);

    /* cflag */
    writeInt_TSStream(stream, termios->cflag->csize);
    writeChar_TSStream(stream, termios->cflag->cstopb ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->cflag->cread  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->cflag->parenb ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->cflag->parodd ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->cflag->hupcl  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->cflag->clocal ? '\xFF' : '\x00');

    /* lflag */
    writeChar_TSStream(stream, termios->lflag->echo   ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->echoe  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->echok  ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->echonl ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->icanon ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->iexten ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->isig   ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->noflsh ? '\xFF' : '\x00');
    writeChar_TSStream(stream, termios->lflag->tostop ? '\xFF' : '\x00');

    /* cc */
    ccobj = get_List(termios->cclist, SUT_VEOF);    writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VEOL);    writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VERASE);  writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VINTR);   writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VKILL);   writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VMIN);    writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VQUIT);   writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VSUSP);   writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VTIME);   writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VSTART);  writeUChar_TSStream(stream, *ccobj);
    ccobj = get_List(termios->cclist, SUT_VSTOP);   writeUChar_TSStream(stream, *ccobj);
}

static void termios_formatter(TSStream *stream, TermIOS *termios)
{
    VERIFY_TYPE(termios_formatter, &type_TermIOS, termios);

    writeTermIOS_TSStream(stream, termios);
}

void writeWinSize_TSStream(TSStream *stream, WinSize *winsize)
{
    assertion((stream != NULL),
        "writeWinSize_TSStream: stream is NULL");

    if(winsize == NULL)
    {
        writeTypeHeaderTSStream(stream, "null");
        return;
    }
    
    writeTypeHeaderTSStream(stream, "winsize");

    writeUShort_TSStream(stream, winsize->row);
    writeUShort_TSStream(stream, winsize->col);
    writeUShort_TSStream(stream, winsize->xpixel);
    writeUShort_TSStream(stream, winsize->ypixel);
}

static void winsize_formatter(TSStream *stream, WinSize *winsize)
{
    VERIFY_TYPE(winsize_formatter, &type_WinSize, winsize);

    writeWinSize_TSStream(stream, winsize);
}

/********************************************************************/
/**                    Initialization Function                     **/
/********************************************************************/
void initIoTermSubsystem(void)
{
    // Set up mediators
    set_mediator_settermios_spec(settermios_media);
    set_mediator_cfgetispeed_spec(cfgetispeed_media);
    set_mediator_cfgetospeed_spec(cfgetospeed_media);
    set_mediator_cfmakeraw_spec(cfmakeraw_media);
    set_mediator_cfsetispeed_spec(cfsetispeed_media);
    set_mediator_cfsetospeed_spec(cfsetospeed_media);
    set_mediator_cfsetspeed_spec(cfsetspeed_media);
    set_mediator_close_tty_spec(close_tty_media);
    set_mediator_close_tty_return(close_tty_return_media);
    set_mediator_ctermid_spec(ctermid_media);
    set_mediator_getlogin_spec(getlogin_media);
    set_mediator_getlogin_r_spec(getlogin_r_media);
    set_mediator_grantpt_spec(grantpt_media);
    set_mediator_isatty_spec(isatty_media);
    set_mediator_open_tty_spec(open_tty_media);
    set_mediator_open_tty_return(open_tty_return_media);
    set_mediator_openpty_spec(openpty_media);
    set_mediator_posix_openpt_spec(posix_openpt_media);
    set_mediator_ptsname_spec(ptsname_media);
    set_mediator_read_tty_spec(read_tty_media);
    set_mediator_read_tty_return(read_tty_return_media);
    set_mediator_tcdrain_spec(tcdrain_media);
    set_mediator_tcdrain_return(tcdrain_return_media);
    set_mediator_tcflow_spec(tcflow_media);
    set_mediator_tcflow_return(tcflow_return_media);
    set_mediator_tcflush_spec(tcflush_media);
    set_mediator_tcflush_return(tcflush_return_media);
    set_mediator_tcgetattr_spec(tcgetattr_media);
    set_mediator_tcgetpgrp_spec(tcgetpgrp_media);
    set_mediator_tcgetsid_spec(tcgetsid_media);
    set_mediator_tcsendbreak_spec(tcsendbreak_media);
    set_mediator_tcsendbreak_return(tcsendbreak_return_media);
    set_mediator_tcsetattr_spec(tcsetattr_media);
    set_mediator_tcsetattr_return(tcsetattr_return_media);
    set_mediator_tcsetpgrp_spec(tcsetpgrp_media);
    set_mediator_tcsetpgrp_return(tcsetpgrp_return_media);
    set_mediator_ttyio_TIOCGWINSZ_spec(ttyio_TIOCGWINSZ_media);
    set_mediator_ttyname_spec(ttyname_media);
    set_mediator_ttyname_r_spec(ttyname_r_media);
    set_mediator_unlockpt_spec(unlockpt_media);
    set_mediator_write_tty_spec(write_tty_media);
    set_mediator_write_tty_return(write_tty_return_media);

    set_mediator_login_tty_spec(login_tty_media);

    // Set up dr processors
    registerDRProcessor("close_tty_return", close_tty_return_processor);
    registerDRProcessor("open_tty_return", open_tty_return_processor);
    registerDRProcessor("read_tty_return", read_tty_return_processor);
    registerDRProcessor("tcdrain_return", tcdrain_return_processor);
    registerDRProcessor("tcflow_return", tcflow_return_processor);
    registerDRProcessor("tcflush_return", tcflush_return_processor);
    registerDRProcessor("tcsendbreak_return", tcsendbreak_return_processor);
    registerDRProcessor("tcsetattr_return", tcsetattr_return_processor);
    registerDRProcessor("tcsetpgrp_return", tcsetpgrp_return_processor);
    registerDRProcessor("write_tty_return", write_tty_return_processor);

    // Set up formatters
    registerTSFormatter("termios",(TSFormatterFuncType)termios_formatter);
    registerTSFormatter("winsize", (TSFormatterFuncType)winsize_formatter);
}

/********************************************************************/
/**                      Auxiliary Functions                       **/
/********************************************************************/

/** settermios_spec **/
mediator settermios_media for specification
void settermios_spec(CallContext context, TermIOSPtr termios_p, TermIOS *termios)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "settermios:$(ptr)$(termios)",
            create_VoidTPtrObj(termios_p), termios);
        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;

        destroy_TSCommand(&command);
    }
    state
    {
        if(isValidPointer(context, termios_p))
        {
            TermIOS *pre_termios = getTermIOS(termios_p);

            copy(termios, pre_termios);
        }
    }
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** cfgetispeed_spec **/
mediator cfgetispeed_media for specification
SpeedT cfgetispeed_spec(CallContext context, TermIOSPtr termios_p)
{
    call
    {
        TSCommand command = create_TSCommand();
        SpeedT res = (SpeedT)-1;
    
        format_TSCommand(&command, "cfgetispeed:$(ptr)",
            create_VoidTPtrObj(termios_p));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readUInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        mapTermIOSStateUp(context, termios_p);
    }
}

/** cfgetospeed_spec **/
mediator cfgetospeed_media for specification
SpeedT cfgetospeed_spec(CallContext context, TermIOSPtr termios_p)
{
    call
    {
        TSCommand command = create_TSCommand();
        SpeedT res = (SpeedT)-1;
    
        format_TSCommand(&command, "cfgetospeed:$(ptr)",
            create_VoidTPtrObj(termios_p));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readUInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        mapTermIOSStateUp(context, termios_p);
    }
}

/** cfmakeraw_spec **/
mediator cfmakeraw_media for specification
void cfmakeraw_spec(CallContext context, TermIOSPtr termios_p)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "cfmakeraw:$(ptr)",
            create_VoidTPtrObj(termios_p));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }
        
        destroy_TSCommand(&command);
    }
    state
    {
        mapTermIOSStateUp(context, termios_p);
    }
}

/** cfsetispeed_spec **/
mediator cfsetispeed_media for specification
IntT cfsetispeed_spec(CallContext context, TermIOSPtr termios_p, SpeedT speed,
                      ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "cfsetispeed:$(ptr)$(uint)",
            create_VoidTPtrObj(termios_p),
            create_UIntTObj(speed));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        mapTermIOSStateUp(context, termios_p);
    }
}

/** cfsetospeed_spec **/
mediator cfsetospeed_media for specification
IntT cfsetospeed_spec(CallContext context, TermIOSPtr termios_p, SpeedT speed,
                      ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "cfsetospeed:$(ptr)$(uint)",
            create_VoidTPtrObj(termios_p),
            create_UIntTObj(speed));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        mapTermIOSStateUp(context, termios_p);
    }
}

/** cfsetspeed_spec **/
mediator cfsetspeed_media for specification
IntT cfsetspeed_spec(CallContext context, TermIOSPtr t, SpeedT speed, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "cfsetspeed:$(ptr)$(uint)",
            create_VoidTPtrObj(t),
            create_UIntTObj(speed));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        mapTermIOSStateUp(context, t);
    }
}

/** close_tty_spec **/
mediator close_tty_media for specification
void close_tty_spec(CallContext context, FileDescId fildes)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "close_tty:$(int)",
            create_IntTObj(fildes.filedesc));

        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        destroy_TSCommand(&command);
    }
    state
    {
        onCloseTTY(context, fildes);
    }
}

/** close_tty_return **/
mediator close_tty_return_media for reaction
CloseTTYReturnType* close_tty_return(void)
{
    state
    {
        onCloseTTYReturn
        (
            close_tty_return->context,
            close_tty_return->returned_value,
            close_tty_return->errno
        );
    }
}

/** ctermid_spec **/
mediator ctermid_media for specification
CString* ctermid_spec(CallContext context, CString *s)
{
    call
    {
        TSCommand command = create_TSCommand();
        CString *res = NULL, *str;
    
        format_TSCommand(&command, "ctermid:$(str)", s);

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readCString_TSStream(&command.response);
            str = readCString_TSStream(&command.response);
            if(s != NULL) copy(str, s);
        }
        
        destroy_TSCommand(&command);
        
        return res; 
    }
}

/** getlogin_spec **/
mediator getlogin_media for specification
CString* getlogin_spec(CallContext context, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        CString *res = NULL;
    
        format_TSCommand(&command, "getlogin");

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readCString_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onGetLogin(context, errno, getlogin_spec);
    }
}

/** getlogin_r_spec **/
mediator getlogin_r_media for specification
IntT getlogin_r_spec(CallContext context, CString *name, SizeT namesize)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "getlogin_r:$(size)",
            create_SizeTObj(namesize));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            copy(readCString_TSStream(&command.response), name);
        }

        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onGetLoginR(context, name, namesize, getlogin_r_spec);
    }
}

/** grantpt_spec **/
mediator grantpt_media for specification
IntT grantpt_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "grantpt:$(int)",
            create_IntTObj(fildes.filedesc));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onGrantPT(context, fildes, errno, grantpt_spec);
    }
}

/** isatty_spec **/
mediator isatty_media for specification
IntT isatty_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "isatty:$(int)",
            create_IntTObj(fildes.filedesc));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onIsATTY(context, fildes, errno, isatty_spec);
    }
}

/** open_tty_spec **/
mediator open_tty_media for specification
void open_tty_spec(CallContext context, CString *path, OpenFlags oflag)
{
    call
    {
        TSCommand command = create_TSCommand();
        FileDescId res = WrongFileDescId;
    
        format_TSCommand(&command, "open_tty:$(str)$(openflags)",
            path, create_OpenFlagsObj(oflag));

        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        destroy_TSCommand(&command);
    }
    state
    {
        onOpenTTY(context, path, oflag);
    }
}

/** open_tty_return **/
mediator open_tty_return_media for reaction
OpenTTYReturnType* open_tty_return(void)
{
    state
    {
        onOpenTTYReturn
        (
            open_tty_return->context,
            open_tty_return->returned_value,
            open_tty_return->errno
        );
    }
}

/** openpty_spec **/
mediator openpty_media for specification
IntT openpty_spec(CallContext context, FileDescId *amaster, FileDescId *aslave,
                  CString *name, VoidTPtr termp, WinSize *winp, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;

        *amaster = *aslave = WrongFileDescId;
        amaster->system = aslave->system = context.system;
        amaster->process = aslave->process = context.process;
    
        format_TSCommand(&command, "openpty:$(int)$(ptr)$(winsize)",
            create_IntTObj(name != NULL ? 1 : 0),
            create_VoidTPtrObj(termp),
            winp);

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            amaster->filedesc = readInt_TSStream(&command.response);
            aslave->filedesc = readInt_TSStream(&command.response);
            if(name != NULL)
            {
                copy(readCString_TSStream(&command.response), name);
            }
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onOpenPTY(context, amaster, aslave, name, termp, winp, errno, openpty_spec);
    }
}

/** posix_openpt_spec **/
mediator posix_openpt_media for specification
FileDescId posix_openpt_spec(CallContext context, OpenFlags oflag,
                             ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        FileDescId res = WrongFileDescId;

        format_TSCommand(&command, "posix_openpt:$(openflags)",
            create_OpenFlagsObj(oflag));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;

            res.system   = context.system;
            res.process  = context.process;
            res.filedesc = readInt_TSStream(&command.response);

            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onPosixOpenPT(context, oflag, errno, posix_openpt_spec);
    }
}

/** ptsname_spec **/
mediator ptsname_media for specification
CString* ptsname_spec(CallContext context, FileDescId fildes)
{
    call
    {
        TSCommand command = create_TSCommand();
        CString *res = NULL;
    
        format_TSCommand(&command, "ptsname:$(int)",
            create_IntTObj(fildes.filedesc));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readCString_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onPTSName(context, fildes, ptsname_spec);
    }
}

/** read_tty_spec **/
mediator read_tty_media for specification
void read_tty_spec(CallContext context, FileDescId fildes, SizeT nbyte)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "read_tty:$(int)$(size)",
            create_IntTObj(fildes.filedesc),
            create_SizeTObj(nbyte));

        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        destroy_TSCommand(&command);
    }
    state
    {
        onReadTTY(context, fildes, nbyte);
    }
}

/** read_tty_return **/
mediator read_tty_return_media for reaction
ReadTTYReturnType* read_tty_return(void)
{
    state
    {
        onReadTTYReturn
        (
            read_tty_return->context,
            read_tty_return->returned_value,
            read_tty_return->buf,
            read_tty_return->errno,
            timestamp
        );
    }
}

/** tcdrain_spec **/
mediator tcdrain_media for specification
void tcdrain_spec(CallContext context, FileDescId fildes)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "tcdrain:$(int)",
            create_IntTObj(fildes.filedesc));

        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        destroy_TSCommand(&command);
    }
    state
    {
        onTCDrain(context, fildes);
    }
}

/** tcdrain_return **/
mediator tcdrain_return_media for reaction
TCReturnType* tcdrain_return(void)
{
    state
    {
        onTCDrainReturn(tcdrain_return->context,
            tcdrain_return->returned_value, tcdrain_return->errno);
    }
}

/** tcflow_spec **/
mediator tcflow_media for specification
void tcflow_spec(CallContext context, FileDescId fildes, Action action)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "tcflow:$(int)$(int)",
            create_IntTObj(fildes.filedesc),
            create_IntTObj(action));

        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;

        destroy_TSCommand(&command);
    }
    state
    {
        onTCFlow(context, fildes, action);
    }
}

/** tcflow_return **/
mediator tcflow_return_media for reaction
TCReturnType* tcflow_return(void)
{
    state
    {
        onTCFlowReturn
        (
            tcflow_return->context,
            tcflow_return->returned_value,
            tcflow_return->errno,
            timestamp
        );
    }
}

/** tcflush_spec **/
mediator tcflush_media for specification
void tcflush_spec(CallContext context, FileDescId fildes,
                  QueueSelector queue_selector)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "tcflush:$(int)$(int)",
            create_IntTObj(fildes.filedesc),
            create_IntTObj(queue_selector));
        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        
        destroy_TSCommand(&command);
    }
    state
    {
        onTCFlush(context, fildes, queue_selector);
    }
}

/** tcflush_return **/
mediator tcflush_return_media for reaction
TCReturnType* tcflush_return(void)
{
    state
    {
        onTCFlushReturn(tcflush_return->context,
            tcflush_return->returned_value, tcflush_return->errno);
    }
}

/** tcgetattr_spec **/
mediator tcgetattr_media for specification
IntT tcgetattr_spec(CallContext context, FileDescId fildes, VoidTPtr termios_p,
                    ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "tcgetattr:$(int)$(ptr)",
            create_IntTObj(fildes.filedesc),
            create_VoidTPtrObj(termios_p));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        if(tcgetattr_spec == 0)
        {
            Terminal *terminal = getTerminal_FileDescId(fildes);
            TermIOS *termios = getTermIOSState(context, termios_p);
            TermIOS *terminal_termios = clone(termios);

            terminal_termios->address = NULL_VoidTPtr;

            registerObjectInMemory(termios_p,
                sizeof_Type(context,"struct termios"), termios);

            if(terminal != NULL)
                setTermIOS_Terminal(terminal, terminal_termios);            
        }

        onTCGetAttr(context, fildes, termios_p, errno, tcgetattr_spec);
    }
}

/** tcgetpgrp_spec **/
mediator tcgetpgrp_media for specification
ProcessId tcgetpgrp_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        ProcessId res = WrongProcessId;

        format_TSCommand(&command, "tcgetpgrp:$(int)",
            create_IntTObj(fildes.filedesc));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res.system = context.system;
            res.process = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onTCGetPGrp(context, fildes, errno, tcgetpgrp_spec);
    }
}

/** tcgetsid_spec **/
mediator tcgetsid_media for specification
ProcessId tcgetsid_spec(CallContext context, FileDescId fildes,
                        ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        ProcessId res = WrongProcessId;

        format_TSCommand(&command, "tcgetsid:$(int)",
            create_IntTObj(fildes.filedesc));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res.system = context.system;
            res.process = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onTCGetSid(context, fildes, errno, tcgetsid_spec);
    }
}

/** tcsendbreak_spec **/
mediator tcsendbreak_media for specification
void tcsendbreak_spec(CallContext context, FileDescId fildes, IntT duration)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "tcsendbreak:$(int)$(int)",
            create_IntTObj(fildes.filedesc),
            create_IntTObj(duration));
        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;

        destroy_TSCommand(&command);
    }
    state
    {
        onTCSendBreak(context, fildes, duration);
    }
}

/** tcsendbreak_return **/
mediator tcsendbreak_return_media for reaction
TCReturnType* tcsendbreak_return(void)
{
    state
    {
        onTCSendBreakReturn
        (
            tcsendbreak_return->context,
            tcsendbreak_return->returned_value,
            tcsendbreak_return->errno,
            timestamp
        );
    }
}

/** tcsetattr_spec **/
mediator tcsetattr_media for specification
void tcsetattr_spec(CallContext context, FileDescId fildes,
                    OptionalActions optional_actions, TermIOSPtr termios_p)
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "tcsetattr:$(int)$(int)$(ptr)",
            create_IntTObj(fildes.filedesc),
            create_IntTObj(optional_actions),
            create_VoidTPtrObj(termios_p));
        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;

        destroy_TSCommand(&command);
    }
    state
    {
        onTCSetAttr(context, fildes, optional_actions, termios_p);
    }
}

/** tcsetattr_return **/
mediator tcsetattr_return_media for reaction
TCReturnType* tcsetattr_return(void)
{
    state
    {
        onTCSetAttrReturn(tcsetattr_return->context,
            tcsetattr_return->returned_value, tcsetattr_return->errno);
    }
}

/** tcsetpgrp_spec **/
mediator tcsetpgrp_media for specification
void tcsetpgrp_spec(CallContext context, FileDescId fildes, ProcessId pgid_id)
{
    call
    {
        TSCommand command = create_TSCommand();
            
        format_TSCommand(&command, "tcsetpgrp:$(int)$(int)",
            create_IntTObj(fildes.filedesc),
            create_IntTObj(pgid_id.process));
        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;

        destroy_TSCommand(&command);
    }
    state
    {
        onTCSetPGrp(context, fildes, pgid_id);
    }
}

/** tcsetpgrp_return **/
mediator tcsetpgrp_return_media for reaction
TCReturnType* tcsetpgrp_return(void)
{
    state
    {
        onTCSetPGrpReturn(tcsetpgrp_return->context,
            tcsetpgrp_return->returned_value, tcsetpgrp_return->errno);
    }
}

/** ttyio_TIOCGWINSZ_spec **/
mediator ttyio_TIOCGWINSZ_media for specification
IntT ttyio_TIOCGWINSZ_spec(CallContext context, FileDescId fd,
                           WinSize *argp, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
            
        format_TSCommand(&command, "ttyio_TIOCGWINSZ:$(int)$(int)",
            create_IntTObj(fd.filedesc),
            create_IntTObj(argp != NULL));
        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        
        res = readInt_TSStream(&command.response);

        if(argp != NULL)
        {
            argp->row = readUShort_TSStream(&command.response);
            argp->col = readUShort_TSStream(&command.response);
            argp->xpixel = readUShort_TSStream(&command.response);
            argp->ypixel = readUShort_TSStream(&command.response);
        }

        *errno = readInt_TSStream(&command.response);

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        onTTYIO_TIOCGWINSZ(context, fd, argp, errno, ttyio_TIOCGWINSZ_spec);
    }
}

/** ttyname_spec **/
mediator ttyname_media for specification
CString* ttyname_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        CString *res = NULL;
    
        format_TSCommand(&command, "ttyname:$(int)",
            create_IntTObj(fildes.filedesc));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readCString_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onTTYName(context, fildes, errno, ttyname_spec);
    }
}

/** ttyname_r_spec **/
mediator ttyname_r_media for specification
IntT ttyname_r_spec(CallContext context, FileDescId fildes, CString *name,
                    SizeT namesize)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "ttyname_r:$(int)$(size)",
            create_IntTObj(fildes.filedesc),
            create_SizeTObj(namesize));
        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            copy(readCString_TSStream(&command.response), name);
        }

        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onTTYNameR(context, fildes, name, namesize, ttyname_r_spec);
    }
}

/** unlockpt_spec **/
mediator unlockpt_media for specification
IntT unlockpt_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res = -1;
    
        format_TSCommand(&command, "unlockpt:$(int)",
            create_IntTObj(fildes.filedesc));

        executeCommandInContext(context, &command);

        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onUnlockPT(context, fildes, errno, unlockpt_spec);
    }
}

/** write_tty_spec **/
mediator write_tty_media for specification
void write_tty_spec(CallContext context, FileDescId fildes, CByteArray *buf,
                    SizeT nbyte)
{
    call
    {
        TSCommand command = create_TSCommand();
    
        format_TSCommand(&command, "write_tty:$(int)$(ba)",
            create_IntTObj(fildes.filedesc), buf);

        executeCommandInContext(context, &command);
        timestamp = command.meta.timestamp;
        destroy_TSCommand(&command);
    }
    state
    {
        onWriteTTY(context, fildes, buf, nbyte);
    }
}

/** write_tty_return **/
mediator write_tty_return_media for reaction
WriteTTYReturnType* write_tty_return(void)
{
    state
    {
        onWriteTTYReturn
        (
            write_tty_return->context,
            write_tty_return->returned_value,
            write_tty_return->errno,
            timestamp
        );
    }
}


/** login_tty_spec **/
mediator login_tty_media for specification
IntT login_tty_spec(CallContext context, FileDescId fdr, ErrorCode* errno)
{
    call
    {
        IntT res;
        TSCommand command = create_TSCommand();
        
        format_TSCommand(&command, "login_tty:$(int)",
            create_IntTObj(fdr.filedesc));
        
        executeCommandInContext(context, &command);
        
        if(!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno = readInt_TSStream(&command.response);
        }
        
        destroy_TSCommand(&command);
        
        return res;
    }
    state
    {
        onLoginTTY(context, fdr, login_tty_spec);
    }
}



TermIOS *getTermIOSState(CallContext context, TermIOSPtr termios_p)
{
    TSCommand command = create_TSCommand();

    int i;

    SpeedT ispeed;
    SpeedT ospeed;

    bool brkint, icrnl, ignbrk, igncr, ignpar, inlcr, inpck, istrip, ixany, ixoff, ixon, parmrk;        
    bool opost, onlcr, ocrnl, onocr, onlret, ofill, ofdel;
    bool cstopb, cread, parenb, parodd, hupcl, clocal;
    bool echo, echoe, echok, echonl, icanon, iexten, isig, noflsh, tostop;

    NLDelay nldly;
    CRDelay crdly;
    TBDelay tbdly;
    BSDelay bsdly;
    VTDelay vtdly;
    FFDelay ffdly;
    CSize csize;

    IFlag *iflag;
    OFlag *oflag;
    CFlag *cflag;
    LFlag *lflag;

    CCT cc[SUT_NCCS];

    TermIOS *termios;

    format_TSCommand(&command, "gettermios:$(ptr)",
        create_VoidTPtrObj(termios_p));
    executeCommandInContext(context, &command);

    ispeed = readUInt_TSStream(&command.response);
    ospeed = readUInt_TSStream(&command.response);

    /* iflag */
    brkint = readChar_TSStream(&command.response) != 0 ? true : false;
    icrnl  = readChar_TSStream(&command.response) != 0 ? true : false;
    ignbrk = readChar_TSStream(&command.response) != 0 ? true : false;
    igncr  = readChar_TSStream(&command.response) != 0 ? true : false;
    ignpar = readChar_TSStream(&command.response) != 0 ? true : false;
    inlcr  = readChar_TSStream(&command.response) != 0 ? true : false;
    inpck  = readChar_TSStream(&command.response) != 0 ? true : false;
    istrip = readChar_TSStream(&command.response) != 0 ? true : false;
    ixany  = readChar_TSStream(&command.response) != 0 ? true : false;
    ixoff  = readChar_TSStream(&command.response) != 0 ? true : false;
    ixon   = readChar_TSStream(&command.response) != 0 ? true : false;
    parmrk = readChar_TSStream(&command.response) != 0 ? true : false;

    /* oflag */
    opost  = readChar_TSStream(&command.response) != 0 ? true : false;
    onlcr  = readChar_TSStream(&command.response) != 0 ? true : false;
    ocrnl  = readChar_TSStream(&command.response) != 0 ? true : false;
    onocr  = readChar_TSStream(&command.response) != 0 ? true : false;
    onlret = readChar_TSStream(&command.response) != 0 ? true : false;
    ofill  = readChar_TSStream(&command.response) != 0 ? true : false;
    ofdel  = readChar_TSStream(&command.response) != 0 ? true : false;
    nldly  = readInt_TSStream(&command.response);
    crdly  = readInt_TSStream(&command.response);
    tbdly  = readInt_TSStream(&command.response);
    bsdly  = readInt_TSStream(&command.response);
    vtdly  = readInt_TSStream(&command.response);
    ffdly  = readInt_TSStream(&command.response);

    /* cflag */
    csize  = readInt_TSStream(&command.response);
    cstopb = readChar_TSStream(&command.response) != '\00' ? true : false;
    cread  = readChar_TSStream(&command.response) != '\00' ? true : false;
    parenb = readChar_TSStream(&command.response) != '\00' ? true : false;
    parodd = readChar_TSStream(&command.response) != '\00' ? true : false;
    hupcl  = readChar_TSStream(&command.response) != '\00' ? true : false;
    clocal = readChar_TSStream(&command.response) != '\00' ? true : false;

    /* lflag */
    echo   = readChar_TSStream(&command.response) != '\00' ? true : false;
    echoe  = readChar_TSStream(&command.response) != '\00' ? true : false;
    echok  = readChar_TSStream(&command.response) != '\00' ? true : false;
    echonl = readChar_TSStream(&command.response) != '\00' ? true : false;
    icanon = readChar_TSStream(&command.response) != '\00' ? true : false;
    iexten = readChar_TSStream(&command.response) != '\00' ? true : false;
    isig   = readChar_TSStream(&command.response) != '\00' ? true : false;
    noflsh = readChar_TSStream(&command.response) != '\00' ? true : false;
    tostop = readChar_TSStream(&command.response) != '\00' ? true : false;

    // cc
    for(i = 0; i < SUT_NCCS; i++) cc[i] = '\00';

    cc[SUT_VEOF]   = readUChar_TSStream(&command.response);
    cc[SUT_VEOL]   = readUChar_TSStream(&command.response);
    cc[SUT_VERASE] = readUChar_TSStream(&command.response);
    cc[SUT_VINTR]  = readUChar_TSStream(&command.response);
    cc[SUT_VKILL]  = readUChar_TSStream(&command.response);
    cc[SUT_VMIN]   = readUChar_TSStream(&command.response);
    cc[SUT_VQUIT]  = readUChar_TSStream(&command.response);
    cc[SUT_VSUSP]  = readUChar_TSStream(&command.response);
    cc[SUT_VTIME]  = readUChar_TSStream(&command.response);
    cc[SUT_VSTART] = readUChar_TSStream(&command.response);
    cc[SUT_VSTOP]  = readUChar_TSStream(&command.response);

    traceFormattedUserInfo("EOF=%d",   cc[SUT_VEOF]);
    traceFormattedUserInfo("EOL=%d",   cc[SUT_VEOL]);
    traceFormattedUserInfo("ERASE=%d", cc[SUT_VERASE]);
    traceFormattedUserInfo("INTR=%d",  cc[SUT_VINTR]);
    traceFormattedUserInfo("KILL=%d",  cc[SUT_VKILL]);
    traceFormattedUserInfo("MIN=%d",   cc[SUT_VMIN]);
    traceFormattedUserInfo("QUIT=%d",  cc[SUT_VQUIT]);
    traceFormattedUserInfo("SUSP=%d",  cc[SUT_VSUSP]);
    traceFormattedUserInfo("TIME=%d",  cc[SUT_VTIME]);
    traceFormattedUserInfo("START=%d", cc[SUT_VSTART]);
    traceFormattedUserInfo("STOP=%d",  cc[SUT_VSTOP]);

    iflag = create_IFlag
    (
        brkint,
        icrnl,
        ignbrk,
        igncr,
        ignpar,
        inlcr,
        inpck,
        istrip,
        ixany,
        ixoff,
        ixon,
        parmrk
    );

    oflag = create_OFlag
    (
        opost,
        onlcr,
        ocrnl,
        onocr,
        onlret,
        ofill,
        ofdel,
        nldly,
        crdly,
        tbdly,
        bsdly,
        vtdly,
        ffdly
    );

    cflag = create_CFlag
    (
        csize,
        cstopb,
        cread,
        parenb,
        parodd,
        hupcl,
        clocal
    );

    lflag = create_LFlag
    (
        echo,
        echoe,
        echok,
        echonl,
        icanon,
        iexten,
        isig,
        noflsh,
        tostop
    );

    termios = create_TermIOS
    (
        termios_p,
        ispeed,
        ospeed,
        iflag,
        oflag,
        cflag,
        lflag,
        cc
    );

    destroy_TSCommand(&command);

    return termios;
}

void setTermIOSState(CallContext context, TermIOSPtr termios_p, TermIOS *termios)
{
    TSCommand command = create_TSCommand();

    assertion((termios != NULL),
        "setTermIOSState: termios is NULL");

    format_TSCommand(&command, "settermios:$(ptr)$(termios)",
        create_VoidTPtrObj(termios_p), termios);
    executeCommandInContext(context, &command);

    destroy_TSCommand(&command);
}

static int count = 0;

void mapTermIOSStateUp(CallContext context, TermIOSPtr address)
{
    if(!isNULL_VoidTPtr(address))
    {
        TermIOS *pre_termios = getTermIOS(address);
        TermIOS *post_termios = getTermIOSState(context, address);

        copy(post_termios, pre_termios);
    }
}
