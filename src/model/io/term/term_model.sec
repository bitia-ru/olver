 /*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "io/file/file_config.h"

#include "config/interpretation.seh"
#include "io/term/term_config.h"
#include "config/system_config.seh"
#include "data/basis.seh"
#include "data/errno_model.seh"
#include "data/signal_model.seh"
#include "io/term/term_model.seh"
#include "fs/fs/fs_model.seh"
#include "process/process/process_model.seh"
#include "system/system/system_model.seh"

#pragma SEC subsystem term "io.term"

/* 
   The group of functions 'io.term' consists of: 
       cfgetispeed  [SUSv3]
       cfgetospeed  [SUSv3]
       cfmakeraw    [LSB]
       cfsetispeed  [SUSv3]
       cfsetospeed  [SUSv3]
       cfsetspeed   [LSB]
       ctermid      [SUSv3]
       close        [SUSv3]
       getlogin     [SUSv3]
       getlogin_r   [SUSv3]
       grantpt      [SUSv3]
       isatty       [SUSv3]
       open         [SUSv3]
       openpty      [LSB]
       posix_openpt [SUSv3]
       read         [SUSv3]
       ptsname      [SUSv3]
       tcdrain      [SUSv3]
       tcflow       [SUSv3]
       tcflush      [SUSv3]
       tcgetattr    [SUSv3]
       tcgetpgrp    [SUSv3]
       tcgetsid     [SUSv3]
       tcsendbreak  [SUSv3]
       tcsetattr    [SUSv3]
       tcsetpgrp    [SUSv3]
       ttyio        [LSB]
       ttyname      [SUSv3]
       ttyname_r    [SUSv3]
       unlockpt     [SUSv3]
       write        [SUSv3]
       login_tty    [SUSv3]
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    cfgetispeed - get input baud rate

SYNOPSIS

    #include <termios.h>

    speed_t cfgetispeed(const struct termios *termios_p);

DESCRIPTION

    The cfgetispeed() function shall extract the input baud rate from the
    termios structure to which the termios_p argument points.

    This function shall return exactly the value in the termios data structure,
    without interpretation.

RETURN VALUE

    Upon successful completion, cfgetispeed() shall return a value of type
    speed_t representing the input baud rate.

ERRORS

    No errors are defined.

RATIONALE

    The term "baud" is used historically here, but is not technically correct.
    This is properly "bits per second", which may not be the same as baud.
    However, the term is used because of the historical usage and
    understanding.

    The cfgetospeed(), cfgetispeed(), cfsetospeed(), and cfsetispeed()
    functions do not take arguments as numbers, but rather as symbolic names.
    There are two reasons for this:

       1. Historically, numbers were not used because of the way the rate was
          stored in the data structure. This is retained even though a function
          is now used.

       2. More importantly, only a limited set of possible rates is at all
          portable, and this constrains the application to that set.

    There is nothing to prevent an implementation accepting as an extension a
    number (such as 126), and since the encoding of the Bxxx symbols is not
    specified, this can be done to avoid introducing ambiguity.

    Setting the input baud rate to zero was a mechanism to allow for split baud
    rates. Clarifications in this volume of IEEE Std 1003.1-2001 have made it
    possible to determine whether split rates are supported and to support them
    without having to treat zero as a special case. Since this functionality is
    also confusing, it has been declared obsolescent. The 0 argument referred
    to is the literal constant 0, not the symbolic constant B0. This volume of
    IEEE Std 1003.1-2001 does not preclude B0 from being defined as the value
    0; in fact, implementations would likely benefit from the two being
    equivalent. This volume of IEEE Std 1003.1-2001 does not fully specify
    whether the previous cfsetispeed() value is retained after a tcgetattr() as
    the actual value or as zero. Therefore, conforming applications should
    always set both the input speed and output speed when setting either.

    In historical implementations, the baud rate information is traditionally
    kept in c_cflag-> Applications should be written to presume that this might
    be the case (and thus not blindly copy c_cflag), but not to rely on it in
    case it is in some other field of the structure. Setting the c_cflag field
    absolutely after setting a baud rate is a non-portable action because of
    this. In general, the unused parts of the flag fields might be used by the
    implementation and should not be blindly copied from the descriptions of
    one terminal device to another.
*/
specification
SpeedT cfgetispeed_spec(CallContext context, TermIOSPtr termios_p)
{
    TermIOS *pre_termios = clone(getTermIOS(termios_p));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "termios_p is valid pointer", isValidPointer(context, termios_p));

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME

        if(!isKnown_Speed(pre_termios->ispeed))
            return { UnknownInputSpeed, "Unknown input speed" };

#endif /* #if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME */

        DEFINED_TERM_SPEED_COVERAGE(pre_termios->ispeed);
    }
    post
    {
        TermIOS *post_termios = getTermIOS(termios_p);

        traceFormattedUserInfo("cfgetispeed_spec: ispeed=%u, ospeed=%u",
            post_termios->ispeed, post_termios->ospeed);

        /*
         * The cfgetispeed() function shall extract the input baud rate from
         * the termios structure to which the termios_p argument points.
         *
         * This function shall return exactly the value in the termios data
         * structure, without interpretation.
         */
        if (cfgetispeed_spec != pre_termios->ispeed)
        {
            VERBOSE("cfgetispeed_spec: %d, pre_termios->ispeed:  %d\n", cfgetispeed_spec, pre_termios->ispeed);
        }

        REQ("cfgetispeed.01", "cfgetispeed() shall return the input baud rate",
           (cfgetispeed_spec == pre_termios->ispeed));

        /* [cfgetispeed() shall not change termios structure] */
        REQ("", "cfgetispeed() shall not change termios structure",
            equals_TermIOS(pre_termios, post_termios));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    cfgetospeed - get output baud rate

SYNOPSIS

    #include <termios.h>

    speed_t cfgetospeed(const struct termios *termios_p);

DESCRIPTION

    The cfgetospeed() function shall extract the output baud rate from the
    termios structure to which the termios_p argument points.

    This function shall return exactly the value in the termios data structure,
    without interpretation.

RETURN VALUE

    Upon successful completion, cfgetospeed() shall return a value of type
    speed_t representing the output baud rate.

ERRORS

    No errors are defined.
*/
specification
SpeedT cfgetospeed_spec(CallContext context, TermIOSPtr termios_p)
{
    TermIOS *pre_termios = clone(getTermIOS(termios_p));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "termios_p is valid pointer",  isValidPointer(context, termios_p));

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME

        if(!isKnown_Speed(pre_termios->ospeed))
            return { UnknownOutputSpeed, "Unknown output speed" };

#endif /* #if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME */

        DEFINED_TERM_SPEED_COVERAGE(pre_termios->ospeed);
    }
    post
    {
        TermIOS *post_termios = getTermIOS(termios_p);

        traceFormattedUserInfo("cfgetospeed_spec: ispeed=%u, ospeed=%u",
            post_termios->ispeed, post_termios->ospeed);

        /*
         * The cfgetospeed() function shall extract the output baud rate from
         * the termios structure to which the termios_p argument points.
         *
         * This function shall return exactly the value in the termios data
         * structure, without interpretation.
         */
        REQ("cfgetospeed.01", "cfgetospeed() shall return the output baud rate",
           (cfgetospeed_spec == pre_termios->ospeed));

        /* [cfgetospeed() shall not change termios structure] */
        REQ("", "cfgetospeed() shall not change termios structure",
            equals_TermIOS(pre_termios, post_termios));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

Name

    cfmakeraw -- get and set terminal attributes

Synopsis

    #include <termios.h>

    void cfmakeraw(struct termios * termios_p);

Description

    The cfmakeraw() function shall set the attributes of the termios structure
    referenced by termios_p as follows:

        termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                              |INLCR|IGNCR|ICRNL|IXON);
        termios_p->c_oflag &= ~OPOST;
        termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
        termios_p->c_cflag &= ~(CSIZE|PARENB);
        termios_p->c_cflag |= CS8;

    termios_p shall point to a termios structure that contains the following
    members:

        tcflag_t c_iflag;
        tcflag_t c_oflag;
        tcflag_t c_cflag;
        tcflag_t c_lflag;
        cc_t c_cc[NCCS];
*/
specification
void cfmakeraw_spec(CallContext context, TermIOSPtr termios_p)
{
    TermIOS *pre_termios = clone(getTermIOS(termios_p));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "termios_p is valid pointer",  isValidPointer(context, termios_p));

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    coverage C_iflag
    {
        if(pre_termios->iflag->ignbrk || pre_termios->iflag->brkint ||
           pre_termios->iflag->parmrk || pre_termios->iflag->istrip ||
           pre_termios->iflag->inlcr  || pre_termios->iflag->igncr  ||
           pre_termios->iflag->icrnl  || pre_termios->iflag->ixon)
        {
            return { IFlagShallChange, "iflag shall be changed" };
        }
        else
        {
            return { IFlagShallNotChange, "iflag shall not be changed" };
        }
    }
    coverage C_oflag
    {
        if(pre_termios->oflag->opost)
        {
            return { OFlagShallChange, "oflag shall be changed" };
        }
        else
        {
            return { OFlagShallNotChange, "oflag shall not be changed" };
        }
    }
    coverage C_lflag
    {
        if(pre_termios->lflag->echo   || pre_termios->lflag->echonl ||
           pre_termios->lflag->icanon || pre_termios->lflag->isig   ||
           pre_termios->lflag->iexten)
        {
            return { LFlagShallChange, "lflag shall be changed" };
        }
        else
        {
            return { LFlagShallNotChange, "lflag shall not be changed" };
        }
    }
    coverage C_cflag
    {
        if(pre_termios->cflag->parenb || pre_termios->cflag->csize != CS8)
        {
            return { CFlagShallChange, "cflag shall not be changed" };
        }
        else
        {
            return { CFlagShallNotChange, "cflag shall not be changed" };
        }
    }
    post
    {
        TermIOS *post_termios = getTermIOS(termios_p);

        /*
         * The cfmakeraw() function shall set the attributes of the termios
         * structure referenced by termios_p as follows:
         *
         * termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
         *                         |INLCR|IGNCR|ICRNL|IXON);
         */
        REQ("cfmakeraw.01.01", "iflag IGNBRK shall reset",
           (post_termios->iflag->ignbrk == false));
        REQ("cfmakeraw.01.01", "iflag BRKINT shall reset",
           (post_termios->iflag->brkint == false));
        REQ("cfmakeraw.01.01", "iflag PARMRK shall reset",
           (post_termios->iflag->parmrk == false));
        REQ("cfmakeraw.01.01", "iflag ISTRIP shall reset",
           (post_termios->iflag->istrip == false));
        REQ("cfmakeraw.01.01", "iflag INLCR shall reset",
           (post_termios->iflag->inlcr == false));
        REQ("cfmakeraw.01.01", "iflag IGNCR shall reset",
           (post_termios->iflag->igncr == false));
        REQ("cfmakeraw.01.01", "iflag ICRNL shall reset",
           (post_termios->iflag->icrnl == false));
        REQ("cfmakeraw.01.01", "iflag IXON shall reset",
           (post_termios->iflag->ixon == false));
        REQ("cfmakeraw.01.01", "iflag IGNPAR shall not change",
           (post_termios->iflag->ignpar == pre_termios->iflag->ignpar));
        REQ("cfmakeraw.01.01", "iflag INPCK shall not change",
           (post_termios->iflag->inpck == pre_termios->iflag->inpck));
        REQ("cfmakeraw.01.01", "iflag IXANY shall not change",
           (post_termios->iflag->ixany == pre_termios->iflag->ixany));
        REQ("cfmakeraw.01.01", "iflag IXOFF shall not change",
           (post_termios->iflag->ixoff == pre_termios->iflag->ixoff));

        /* termios_p->c_oflag &= ~OPOST; */
        REQ("cfmakeraw.01.02", "oflag OPOST shall reset",
           (post_termios->oflag->opost == false));
        REQ("cfmakeraw.01.02", "oflag ONLCR shall not change",
           (post_termios->oflag->onlcr == pre_termios->oflag->onlcr));
        REQ("cfmakeraw.01.02", "oflag OCRNL shall not change",
           (post_termios->oflag->ocrnl == pre_termios->oflag->ocrnl));
        REQ("cfmakeraw.01.02", "oflag ONOCR shall not change",
           (post_termios->oflag->onocr == pre_termios->oflag->onocr));
        REQ("cfmakeraw.01.02", "oflag ONLRET shall not change",
           (post_termios->oflag->onlret == pre_termios->oflag->onlret));
        REQ("cfmakeraw.01.02", "oflag OFILL shall not change",
           (post_termios->oflag->ofill == pre_termios->oflag->ofill));
        REQ("cfmakeraw.01.02", "oflag NLDLY shall not change",
           (post_termios->oflag->nldly == pre_termios->oflag->nldly));
        REQ("cfmakeraw.01.02", "oflag CRDLY shall not change",
           (post_termios->oflag->crdly == pre_termios->oflag->crdly));
        REQ("cfmakeraw.01.02", "oflag TABDLY shall not change",
           (post_termios->oflag->tbdly == pre_termios->oflag->tbdly));
        REQ("cfmakeraw.01.02", "oflag BSDLY shall not change",
           (post_termios->oflag->bsdly == pre_termios->oflag->bsdly));
        REQ("cfmakeraw.01.02", "oflag VTDLY shall not change",
           (post_termios->oflag->vtdly == pre_termios->oflag->vtdly));
        REQ("cfmakeraw.01.02", "oflag FFDLY shall not change",
           (post_termios->oflag->ffdly == pre_termios->oflag->ffdly));

        /* termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN); */
        REQ("cfmakeraw.01.03", "lflag ECHO shall reset",
           (post_termios->lflag->echo == false));
        REQ("cfmakeraw.01.03", "lflag ECHONL shall reset",
           (post_termios->lflag->echonl == false));
        REQ("cfmakeraw.01.03", "lflag ICANON shall reset",
           (post_termios->lflag->icanon == false));
        REQ("cfmakeraw.01.03", "lflag ISIG shall reset",
           (post_termios->lflag->isig == false));
        REQ("cfmakeraw.01.03", "lflag IEXTEN",
           (post_termios->lflag->iexten == false));
        REQ("cfmakeraw.01.03", "lflag ECHOE shall not reset",
           (post_termios->lflag->echoe == pre_termios->lflag->echoe));
        REQ("cfmakeraw.01.03", "lflag ECHOK shall not reset",
           (post_termios->lflag->echok == pre_termios->lflag->echok));
        REQ("cfmakeraw.01.03", "lflag NOFLSH shall not reset",
           (post_termios->lflag->noflsh == pre_termios->lflag->noflsh));
        REQ("cfmakeraw.01.03", "lflag TOSTOP shall not reset",
           (post_termios->lflag->tostop == pre_termios->lflag->tostop));

        /* 
         * termios_p->c_cflag &= ~(CSIZE|PARENB);
         * termios_p->c_cflag |= CS8;
         */
        REQ("cfmakeraw.01.04", "cflag PARENTB shall reset",
           (post_termios->cflag->parenb == false));
        REQ("cfmakeraw.01.04", "cflag CSIZE shall set to CS8",
           (post_termios->cflag->csize == CS8));
        REQ("cfmakeraw.01.04", "cflag CSTOPB shall not change",
           (post_termios->cflag->cstopb == pre_termios->cflag->cstopb));
        REQ("cfmakeraw.01.04", "cflag CREAD shall not change",
           (post_termios->cflag->cread == pre_termios->cflag->cread));
        REQ("cfmakeraw.01.04", "cflag PADODD shall not change",
           (post_termios->cflag->parodd == pre_termios->cflag->parodd));
        REQ("cfmakeraw.01.04", "cflag HUPCL shall not change",
           (post_termios->cflag->hupcl == pre_termios->cflag->hupcl));
        REQ("cfmakeraw.01.04", "cflag CLOCAL shall not change",
           (post_termios->cflag->clocal == pre_termios->cflag->clocal));

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    cfsetispeed - set input baud rate

SYNOPSIS

    #include <termios.h>

    int cfsetispeed(struct termios *termios_p, speed_t speed);

DESCRIPTION

    The cfsetispeed() function shall set the input baud rate stored in the
    structure pointed to by termios_p to speed.

    There shall be no effect on the baud rates set in the hardware until a
    subsequent successful call to tcsetattr() with the same termios structure.
    Similarly, errors resulting from attempts to set baud rates not supported
    by the terminal device need not be detected until the tcsetattr() function
    is called.

RETURN VALUE

    Upon successful completion, cfsetispeed() shall return 0; otherwise, -1
    shall be returned, and errno may be set to indicate the error.

ERRORS

    The cfsetispeed() function may fail if:

    [EINVAL]
        The speed value is not a valid baud rate.
    [EINVAL]
        The value of speed is outside the range of possible speed values as
        specified in <termios.h>.
*/
specification
IntT cfsetispeed_spec(CallContext context, TermIOSPtr termios_p,
                      SpeedT speed, ErrorCode *errno)
{
    TermIOS *pre_termios = clone(getTermIOS(termios_p));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "termios_p is valid pointer",  isValidPointer(context, termios_p));

        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        if(POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME)
        {
            /*
             * The cfgetospeed(), cfgetispeed(), cfsetospeed(), and cfsetispeed()
             * functions do not take arguments as numbers, but rather as symbolic
             * names.
             */
            REQ("", "speed is defined as symbolic name", isKnown_Speed(speed));
        }

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME

        if(!isKnown_Speed(speed))
        {
            return { UnknownInputSpeed, "Unknown input speed" };
        }
        else

#endif /* #if POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME */

            DEFINED_TERM_SPEED_COVERAGE(speed);
    }
    post
    {
        TermIOS *post_termios = getTermIOS(termios_p);

        /* 
         * [On error,] -1 shall be returned, and errno may be set to indicate
         * the error.
         */
        if(cfsetispeed_spec == -1)
        {
            /* The cfsetispeed() function may fail if: */
            if(*errno == SUT_EOK || *errno == SUT_EINVAL)
            {
                /* 
                 * The speed value is not a valid baud rate.
                 *
                 * The value of speed is outside the range of possible speed
                 * values as specified in <termios.h>.
                 */
                if(!POSIX_CFSETISPEED_HAS_EXTRA_CONDITION_ON_EINVAL)
                {               
                    REQ("cfsetispeed.05.01", "speed is not a valid baud rate",
                       (isValid_InputSpeed(speed) != True_Bool3 || !isKnown_Speed(speed)));

                }else{
                    REQ("cfsetispeed.05.01",
                        "speed is not a valid baud rate or extra condition", true);
                }
            }
            else
            {
                if(!POSIX_CFSETISPEED_HAS_EXTRA_ERROR_CODES)
                {
                    /* [Unexpected error code] */
                    REQ("cfsetispeed.05", "Unexpected error code", false);
                }
            }

            /* [Implicit postcondition] */
            REQ("", "On error, termios_p shall not change",
                equals_TermIOS(post_termios, pre_termios));
        }
        else
        {
            /* Upon successful completion, cfsetispeed() shall return 0 */
            REQ("cfsetispeed.03", "On success, cfsetispeed() shall return 0",
               (cfsetispeed_spec == 0));

            if(POSIX_CFSETISPEED_FAILS_WITH_EINVAL)
            {
                REQ("cfsetispeed.05.01", "speed is valid baud rate",
                   (isValid_InputSpeed(speed) != False_Bool3 && isKnown_Speed(speed)));
            }

            traceFormattedUserInfo("cfsetispeed_spec: ispeed=%u, speed=%u",
                post_termios->ispeed, speed);

            /*
             * The cfsetispeed() function shall set the input baud rate stored
             * in the structure pointed to by termios_p to speed.
             */
            REQ("cfsetispeed.01", "cfsetispeed() shall set the input baud rate",
               (post_termios->ispeed == speed));

            /*
             * There shall be no effect on the baud rates set in the hardware
             * until a subsequent successful call to tcsetattr() with the same
             * termios structure. Similarly, errors resulting from attempts to
             * set baud rates not supported by the terminal device need not be
             * detected until the tcsetattr() function is called.
             */
            REQ("cfsetispeed.02", "There shall be no effect in the hardware", true);
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    cfsetospeed - set output baud rate

SYNOPSIS

    #include <termios.h>

    int cfsetospeed(struct termios *termios_p, speed_t speed);

DESCRIPTION

    The cfsetospeed() function shall set the output baud rate stored in the
    structure pointed to by termios_p to speed.

    There shall be no effect on the baud rates set in the hardware until a
    subsequent successful call to tcsetattr() with the same termios structure.
    Similarly, errors resulting from attempts to set baud rates not supported
    by the terminal device need not be detected until the tcsetattr() function
    is called.

RETURN VALUE

    Upon successful completion, cfsetospeed() shall return 0; otherwise, it
    shall return -1 and errno may be set to indicate the error.

ERRORS

    The cfsetospeed() function may fail if:

    [EINVAL]
        The speed value is not a valid baud rate.
    [EINVAL]
        The value of speed is outside the range of possible speed values as
        specified in <termios.h>.
*/
specification
IntT cfsetospeed_spec(CallContext context, TermIOSPtr termios_p, SpeedT speed,
                      ErrorCode *errno)
{
    TermIOS *pre_termios = clone(getTermIOS(termios_p));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "termios_p is valid pointer",  isValidPointer(context, termios_p));

        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        if(POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME)
        {
            /*
             * The cfgetospeed(), cfgetispeed(), cfsetospeed(), and cfsetispeed()
             * functions do not take arguments as numbers, but rather as symbolic
             * names.
             */
            REQ("", "speed is defined as symbolic name", isKnown_Speed(speed));
        }

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME

        if(!isKnown_Speed(speed))
        {
            return { UnknownOutputSpeed, "Unknown output speed" };
        }
        else

#endif /* #if !POSIX_TERMINAL_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME */

            DEFINED_TERM_SPEED_COVERAGE(speed);
    }
    post
    {
        TermIOS *post_termios = getTermIOS(termios_p);

        /*
         * [On error,] it shall return -1 and errno may be set to indicate the
         * error.
         */
        if(cfsetospeed_spec == -1)
        {
            /* The cfsetospeed() function may fail if: */
            if(*errno == SUT_EOK || *errno == SUT_EINVAL)
            {
                /*
                 * The speed value is not a valid baud rate.
                 *
                 * The value of speed is outside the range of possible speed
                 * values as specified in <termios.h>.
                 */
                if(!POSIX_CFSETOSPEED_HAS_EXTRA_CONDITION_ON_EINVAL)
                {
                    REQ("cfsetospeed.05.01", "speed is not a valid baud rate",
                       (isValid_OutputSpeed(speed) != True_Bool3 || !isKnown_Speed(speed)));

                }else{
                    REQ("cfsetospeed.05.01",
                        "speed is not a valid baud rate or extra condition", true);
                }
            }
            else
            {
                if(!POSIX_CFSETOSPEED_HAS_EXTRA_ERROR_CODES)
                {
                    /* [Unexpected error code] */
                    REQ("cfsetospeed.05", "Unexpected error code", false);
                }
            }

            /* [Implicit postcondition] */
            REQ("", "On error, termios_p shall not change",
                equals_TermIOS(post_termios, pre_termios));
        }
        else
        {
            /* Upon successful completion, cfsetospeed() shall return 0 */
            REQ("cfsetospeed.03", "On success, cfsetospeed() shall return 0",
               (cfsetospeed_spec == 0));

            if(POSIX_CFSETOSPEED_FAILS_WITH_EINVAL)
            {
                REQ("cfsetospeed.05", "speed is valid output baud rate",
                   (isValid_OutputSpeed(speed) != False_Bool3 && isKnown_Speed(speed)));            
            }

            traceFormattedUserInfo("cfsetospeed_spec: ospeed=%u, speed=%u",
                post_termios->ospeed, speed);

            /*
             * The cfsetospeed() function shall set the input baud rate stored
             * in the structure pointed to by termios_p to speed.
             */
            REQ("cfsetospeed.01", "cfsetospeed() shall set the input baud rate",
               (post_termios->ospeed == speed));

            /*
             * There shall be no effect on the baud rates set in the hardware
             * until a subsequent successful call to tcsetattr() with the same
             * termios structure. Similarly, errors resulting from attempts to
             * set baud rates not supported by the terminal device need not be
             * detected until the tcsetattr() function is called.
             */
            REQ("cfsetospeed.02", "The shall be no effect in the hardware", true);
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

Name

    cfsetspeed -- set terminal input and output data rate

Synopsis

    #include <termios.h>

    int cfsetspeed(struct termios *t, speed_t speed);

Description

    cfsetspeed() sets the baud rate values in the termios structure. The
    effects of the function on the terminal as described below do not become
    effective, nor are all errors detected, until the tcsetattr() function is
    called. Certain values for baud rates set in termios and passed to
    tcsetattr() have special meanings.

Getting and Setting the Baud Rate

    Input and output baud rates are found in the termios structure. The
    unsigned integer speed_t is typdef'd in the include file termios.h. The
    value of the integer corresponds directly to the baud rate being
    represented; however, the following symbolic values are defined.

        #define B0      0
        #define B50     50
        #define B75     75
        #define B110    110
        #define B134    134
        #define B150    150
        #define B200    200
        #define B300    300
        #define B600    600
        #define B1200   1200
        #define B1800   1800
        #define B2400   2400
        #define B4800   4800
        #define B9600   9600
        #define B19200  19200
        #define B38400  38400
        #ifndef _POSIX_SOURCE
        #define EXTA    19200
        #define EXTB    38400
        #endif

    cfsetspeed() sets both the input and output baud rates in the termios
    structure referenced by t to speed.

Return Value

    On success, 0 is returned. On error, -1 is returned and the global variable
    errno is set appropriately.

Errors

    EINVAL      

    Invalid speed argument
*/
specification
IntT cfsetspeed_spec(CallContext context, TermIOSPtr t, SpeedT speed,
                     ErrorCode *errno)
{
    TermIOS *pre_termios = clone(getTermIOS(t));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "t is valid pointer",  isValidPointer(context, t));

        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME

        if(!isKnown_Speed(speed))
        {
            return { UnknownSpeed, "Unknown speed" };
        }
        else

#endif /* #if !POSIX_IO_TERM_SPEED_MUST_BE_DEFINED_AS_SYMBOLIC_NAME */

            DEFINED_TERM_SPEED_COVERAGE(speed);
    }
    post
    {
        TermIOS *post_termios = getTermIOS(t);

        /* [Implicit postcondition] */
        REQ("", "On error, t shall not change",
           ((cfsetspeed_spec == -1) => equals_TermIOS(post_termios, pre_termios)));

        /*
         * On error, -1 is returned and the global variable errno is set
         * appropriately.
         */
        ERROR_BEGIN(LSB_CFSETSPEED, "cfsetspeed.02", (cfsetspeed_spec == -1), *errno);

           /*
            * [EINVAL]
            *
            * Invalid speed argument.
            */
            ERROR_MAY3(LSB_CFSETSPEED, EINVAL, "cfsetspeed.04.01",
                (isKnown_Speed(speed) ? False_Bool3 : not_Bool3(isValid_Speed(speed))));

        ERROR_END();

        /* On success, 0 is returned */
        REQ("cfsetspeed.03", "On success, 0 is returned", (cfsetspeed_spec == 0));

        traceFormattedUserInfo("cfsetspeed_spec: ispeed=%u, ospeed=%u, speed=%u",
            post_termios->ispeed, post_termios->ospeed, speed);

        /*
         * cfsetspeed() sets both the input and output baud rates in the
         * termios structure referenced by t to speed.
         */
        REQ("cfsetspeed.01", "cfsetspeed() shall set the input baud rate",
           (post_termios->ispeed == speed));
        REQ("cfsetspeed.01", "cfsetspeed() shall set the output baud rate",
           (post_termios->ospeed == speed));

        /*
         * The effects of the function on the terminal as described below do
         * not become effective, nor are all errors detected, until the
         * tcsetattr() function is called.
         */
        REQ("cfsetspeed.02", "The shall be no effect in the hardware", true);

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    close - close a file descriptor

    See io.file subsystem
*/
specification typedef struct CloseTTYCall CloseTTYCall = {};

CloseTTYCall* create_CloseTTYCall(CallContext context, FileDescId fildes)
{
    return create(&type_CloseTTYCall, context, fildes);
}

specification
void close_tty_spec(CallContext context, FileDescId fildes)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    pre
    {
        /* [The fildes is a terminal descriptor id] */
        REQ("", "The fildes is a terminal descriptor id", is_terminal);

        /* [The termios is not NULL] */
        REQ("", "The termios is not NULL", (termios != NULL));

        return true;
    }
    coverage C
    {
        Terminal *terminal = getTerminal_FileDescId(fildes);
        Map *file_descriptors = getAllFileDescriptors();
        FileDescriptor *file_descriptor = findFileDescriptor(file_descriptors, fildes);

        if(getFileDescriptorsCount(file_descriptors, file_descriptor->file) == 1)
        {
            if(isPTM_Terminal(terminal))
            {
                Terminal *pts = isConnected_Terminal(terminal) ?
                    getRemoteTerminal_Terminal(terminal) : NULL;

                if(pts != NULL && isControlling_Terminal(pts))
                {
                    return { LastClose_PTM_CTerm,
                        "Last close, PTM, controlling terminal" };
                }
                else if(pts != NULL && isNotControlling_Terminal(pts))
                {
                    return { LastClose_PTM_NotCTerm,
                        "Last close, PTM, not a controlling terminal" };
                }
                else
                {
                    return { LastClose_PTM_UnknownCTerm,
                        "Last close, PTM, unknown controlling status" };
                }
            }
            else
            {
                if(isControlling_Terminal(terminal))
                {
                    if(termios->cflag->hupcl && !termios->cflag->clocal)
                    {
                        NOT_PTM_TERM_TYPE_COVERAGE(LastClose_NotPTM_CTerm_HUPCL,
                            "Last close, not a PTM, controlling terminal, HUPCL", fildes);
                    }
                    else
                    {
                        NOT_PTM_TERM_TYPE_COVERAGE(LastClose_NotPTM_CTerm_NotHUPCL,
                            "Last close, not a PTM, controlling terminal, !HUPCL or CLOCAL",
                                fildes);
                    }
                }
                else if(isNotControlling_Terminal(terminal))
                {
                    NOT_PTM_TERM_TYPE_COVERAGE(LastClose_NotPTM_NotCTerm,
                        "Last close, not a PTM, not a controlling terminal", fildes);
                }
                else
                {
                    return { NotPTM_UnknownCTerm,
                        "Last close, not a PTM, unknown controlling status" };
                }
            }
        }
        else
        {
            TERM_TYPE_COVERAGE(NotLastClose, "Not a last close", fildes);
        }
    }
    post
    {
        /* [The close() function shall block] */
        REQ("", "close() shall block", equals(getBlockedCall(context),
            create_CloseTTYCall(context, fildes)));

        return true;
    }
}

void onCloseTTY(CallContext context, FileDescId fildes)
{
    startBlockedCall(context, create_CloseTTYCall(context, fildes));
    threadShouldBeRun(context);
}

specification typedef struct CloseTTYReturnType CloseTTYReturnType = {};

CloseTTYReturnType* create_CloseTTYReturnType
(
    CallContext context,
    IntT returned_value,
    ErrorCode *errno
)
{
    return create(&type_CloseTTYReturnType, context, returned_value, errno);
}

reaction
CloseTTYReturnType* close_tty_return(void)
{
    post
    {
        CallContext context = close_tty_return->context;
        IntT returned_value = close_tty_return->returned_value;
        ErrorCode *errno = close_tty_return->errno;

        CloseTTYCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;

        Map *pre_file_descriptors = @getAllFileDescriptors();
        
        FileDescriptor *pre_file_descriptor =
            findFileDescriptor(pre_file_descriptors, fildes);

        int file_descriptors_count =
            getFileDescriptorsCount(pre_file_descriptors, pre_file_descriptor->file);

        FileSystem *pre_file_system = findFileSystem(@getAllFileSystems(), context);
        FileSystem *post_file_system = getFileSystem(context);

        File *pre_file = getFile_FileId_Ext(pre_file_system, pre_file_descriptor->file);
        File *post_file = getFile_FileId_Ext(post_file_system, pre_file_descriptor->file);

        Terminal *pre_terminal = findTerminal(@getAllTerminals(), fildes);

        TermIOS *pre_termios = getTermIOS_Terminal(pre_terminal);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_CLOSE, "close.13.02", (returned_value == -1), *errno);

            /*
             * The close() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_CLOSE, EBADF, "close.14.01",
                (pre_file_descriptor == NULL));

            /*
             * The close() function shall fail if:
             *
             * [EINTR]
             *
             * The close() function was interrupted by a signal.
             */
            ERROR_SHALL(POSIX_CLOSE, EINTR, "close.14.01",
                isBlockedCallInterruptedBySignal(context));

            /*
             * The close() function may fail if:
             *
             * [EIO]
             *
             * An I/O error occurred while reading from or writing to the file
             * system.
             */
            ERROR_UNCHECKABLE(POSIX_CLOSE, EIO, "close.15.01",
                "don't know how to check");

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("close.13.01", "On success, close() shall return 0", (returned_value == 0));

        /*
         * The close() function shall deallocate the file descriptor indicated
         * by fildes.
         */
        REQ("?close.01", "close() shall deallocate the file descriptor",
            !isValid_FileDescId(fildes));

        /*
         * When all file descriptors associated with an open file description
         * have been closed, the open file description shall be freed.
         */
        REQ("close.04", "The open file description shall be freed", true);

        /*
         * If the link count of the file is 0, when all file descriptors
         * associated with the file are closed, the space occupied by the file
         * shall be freed and the file shall no longer be accessible.
         */
        REQ("close.05", "The file shall be freed", true);

        /* This is the last close */
        if(file_descriptors_count == 1)
        {
            /* If fildes refers to the master side of a pseudo-terminal */
            if(isPTM_Terminal(pre_terminal))
            {
                Terminal *pts = isConnected_Terminal(pre_terminal) ?
                    getRemoteTerminal_Terminal(pre_terminal) : NULL;

                /* Pseudo-terminal is the controlling terminal */
                if(pts != NULL && isControlling_Terminal(pts))
                {
                    ProcessIdObj *sessionid = getSessionId_Terminal(pts);

                    if(sessionid != NULL && !isWrong_ProcessId(*sessionid))
                    {
                        /*
                         * A SIGHUP signal shall be sent to the controlling
                         * process, if any, for which the slave side of the
                         * pseudo-terminal is the controlling terminal.
                         */
                        REQ("?close.08", "A SIGHUP signal shall be sent",
                            signalShouldBeSentToProcess(*sessionid, SUT_SIGHUP));
                    }
                }                    
            }
            else
            {
                /*
                 * If HUPCL is set in the control modes and communications
                 * ports supports a disconnect function.
                 */
                if(pre_termios->cflag->hupcl &&
                   getDisconnectSupport_Terminal(pre_terminal) == True_Bool3)
                {
                    /* The terminal device shall perform a disconnect */
                    REQ("?close.20", "The terminal shall perform a disconnect",
                        isDisconnected_Terminal(pre_terminal));

                    /*
                     * If a modem disconnect is detected by the terminal
                     * interface for a controlling terminal, and if CLOCAL is
                     * not set in the c_cflag field for the terminal.
                     */
                    if(isControlling_Terminal(pre_terminal) && !pre_termios->cflag->clocal)
                    {
                        ProcessIdObj *sessionid = getSessionId_Terminal(pre_terminal);

                        if(sessionid != NULL && !isWrong_ProcessId(*sessionid))
                        {
                            /*
                             * The SIGHUP signal shall be sent to the
                             * controlling process for which the terminal is
                             * the controlling terminal.
                             */
                            REQ("?close.21", "A SIGHUP signal shall be sent",
                                signalShouldBeSentToProcess(*sessionid, SUT_SIGHUP));
                        }
                    }
                }
            }
        }

        return true;
    }
}

void onCloseTTYReturn(CallContext context, IntT close_tty_return, ErrorCode *errno)
{
    CloseTTYCall *blocked_call = finishBlockedCall(context);

    if(close_tty_return == 0)
    {
        FileDescId fildes = blocked_call->fildes;

        Map *file_descriptors = getAllFileDescriptors();

        FileDescriptor *file_descriptor = findFileDescriptor(file_descriptors, fildes);

        Terminal *terminal = getTerminal_FileDescId(fildes);
        TermIOS *termios = getTermIOS_Terminal(terminal);

        int file_descriptors_count =
            getFileDescriptorsCount(file_descriptors, file_descriptor->file);

        unregisterFileDescriptor(fildes);

        if(file_descriptors_count == 1)
        {
            disconnect_Terminal(terminal);

            clear_TerminalQueue(getInputQueue_Terminal(terminal));
            clear_TerminalQueue(getOutputQueue_Terminal(terminal));

            if(isPTM_Terminal(terminal))
            {
                Terminal *pts = isConnected_Terminal(terminal) ?
                    getRemoteTerminal_Terminal(terminal) : NULL;

                if(pts != NULL && isControlling_Terminal(pts))
                {
                    ProcessIdObj *sessionid = getSessionId_Terminal(pts);

                    if(sessionid != NULL && !isWrong_ProcessId(*sessionid))
                    {
                        sendSignalToProcess(*sessionid, SUT_SIGHUP);
                    }
                }                    
            }
            else
            {
                if(termios->cflag->hupcl &&
                   getDisconnectSupport_Terminal(terminal) == True_Bool3)
                {
                    if(isControlling_Terminal(terminal) && !termios->cflag->clocal)
                    {
                        ProcessIdObj *sessionid = getSessionId_Terminal(terminal);

                        if(sessionid != NULL && !isWrong_ProcessId(*sessionid))
                        {
                            sendSignalToProcess(*sessionid, SUT_SIGHUP);
                        }
                    }
                }
            }
        }        
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    ctermid - generate a pathname for the controlling terminal

SYNOPSIS

    #include <stdio.h>

    char *ctermid(char *s);

DESCRIPTION

    The ctermid() function shall generate a string that, when used as a
    pathname, refers to the current controlling terminal for the current
    process. If ctermid() returns a pathname, access to the file is not
    guaranteed.

    If the application uses any of the _POSIX_THREAD_SAFE_FUNCTIONS or
    _POSIX_THREADS functions, it shall ensure that the ctermid() function
    is called with a non-NULL parameter.

RETURN VALUE

    If s is a null pointer, the string shall be generated in an area that may
    be static (and therefore may be overwritten by each call), the address of
    which shall be returned. Otherwise, s is assumed to point to a character
    array of at least L_ctermid bytes; the string is placed in this array and
    the value of s shall be returned. The symbolic constant L_ctermid is
    defined in <stdio.h>, and shall have a value greater than 0.

    The ctermid() function shall return an empty string if the pathname that
    would refer to the controlling terminal cannot be determined, or if the
    function is unsuccessful.

ERRORS

    No errors are defined.
*/
specification
CString* ctermid_spec(CallContext context, CString *s)
{
    ProcessId processid = getProcessId_CallContext(context);

    pre
    {
        if(s != NULL)
        {
            /*
             * s is assumed to point to a character array of at least L_ctermid
             * bytes.
             */
            REQ("app.ctermid.01", "s is array of at least L_ctermid", true);
        }

        return true;
    }
    coverage C
    {
        if(s == NULL)
        {
            CTERM_COVERAGE(Null, "s is NULL", processid);
        }
        else
        {
            CTERM_COVERAGE(NotNull, "s is not NULL", processid);
        }
    }
    post
    {
        if(s != NULL)
        {
            /* 
             * The string is placed in this array and the value of s shall be
             * returned.
             */
            REQ("ctermid.02", "ctermid() shall return the value of s",
                equals(ctermid_spec, s));
        }

        if(ctermid_spec == NULL)
        {
            /* [Unexpected returned value] */
            REQ("", "Unexpected returned value", false);
        }
        else if(length_CString(ctermid_spec) == 0)
        {
            /*
             * The ctermid() function shall return an empty string if the
             * pathname that would refer to the controlling terminal cannot be
             * determined, or if the function is unsuccessful.
             */
            REQ("ctermid.03", "Controlling terminal cannot be determined",
                !@hasControllingTerminal_ProcessId(processid));
        }
        else
        {
            /*
             * The ctermid() function shall generate a string that, when used
             * as a pathname, refers to the current controlling terminal for
             * the current process.
             */
            REQ("ctermid.01", "ctermid() shall return controlling terminal id",
                equals(ctermid_spec, getControllingTerminalName_ProcessId(processid)));
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    getlogin, getlogin_r - get login name

SYNOPSIS

    #include <unistd.h>

    char *getlogin(void);

    [TSF] int getlogin_r(char *name, size_t namesize); 

DESCRIPTION

    The getlogin() function shall return a pointer to a string containing the
    user name associated by the login activity with the controlling terminal of
    the current process. If getlogin() returns a non-null pointer, then that
    pointer points to the name that the user logged in under, even if there are
    several login names with the same user ID.

    The getlogin() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

    [TSF] The getlogin_r() function shall put the name associated by the login
    activity with the controlling terminal of the current process in the
    character array pointed to by name. The array is namesize characters long
    and should have space for the name and the terminating null character. The
    maximum size of the login name is {LOGIN_NAME_MAX}.

    If getlogin_r() is successful, name points to the name the user used at
    login, even if there are several login names with the same user ID. 

RETURN VALUE

    Upon successful completion, getlogin() shall return a pointer to the login
    name or a null pointer if the user's login name cannot be found. Otherwise,
    it shall return a null pointer and set errno to indicate the error.

    The return value from getlogin() may point to static data whose content is
    overwritten by each call.

    [TSF] If successful, the getlogin_r() function shall return zero;
    otherwise, an error number shall be returned to indicate the error. 

ERRORS

    The getlogin() and getlogin_r() functions may fail if:

    [EMFILE]
        {OPEN_MAX} file descriptors are currently open in the calling process.
    [ENFILE]
        The maximum allowable number of files is currently open in the system.
    [ENXIO]
        The calling process has no controlling terminal.

    The getlogin_r() function may fail if:

    [ERANGE]
        [TSF] The value of namesize is smaller than the length of the string to
        be returned including the terminating null character.
*/
specification
CString* getlogin_spec(CallContext context, ErrorCode *errno)
{
    ProcessId processid = getProcessId_CallContext(context);

    Terminal *pre_cterm = hasControllingTerminal_ProcessId(processid) ?
        clone(getControllingTerminal_ProcessId(processid)) : NULL;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        return true;
    }
    coverage C
    {
        CTERM_COVERAGE(getlogin, "getlogin()", processid);
    }
    post
    {
        /*
         * [On error,] it shall return a null pointer and set errno to indicate
         * the error.
         */
        ERROR_BEGIN(POSIX_GETLOGIN, "getlogin.04",
            (getlogin_spec == NULL && *errno != SUT_EOK), *errno);

            /*
             * The getlogin() and getlogin_r() functions may fail if:
             *
             * [EMFILE]
             *
             * {OPEN_MAX} file descriptors are currently open in the calling process.
             */
            ERROR_MAY3(POSIX_GETLOGIN, EMFILE, "getlogin.05.01",
                @isOpenFileDescNumberExceedMax(context));

            /*
             * The getlogin() and getlogin_r() functions may fail if:
             *
             * [ENFILE]
             *
             * The maximum allowable number of files is currently open in the system.
             */
            ERROR_UNCHECKABLE(POSIX_GETLOGIN, ENFILE, "getlogin.05.02",
                "don't know how to check");

            /*
             * The getlogin() and getlogin_r() functions may fail if:
             *
             * [ENXIO]
             *
             * The calling process has no controlling terminal.
             */
            ERROR_MAY(POSIX_GETLOGIN, ENXIO, "getlogin.05.03",
                @!hasControllingTerminal_ProcessId(processid));

        ERROR_END();

        /*
         * Upon successful completion, getlogin() shall return a pointer to the
         * login name or a null pointer if the user's login name cannot be
         * found.
         */
        REQ("getlogin.03", "On success, getlogin() shall not set errno, if it returns NULL",
           ((getlogin_spec == NULL) => (*errno == SUT_EOK)));

        /* If getlogin() returns a non-null pointer */
        if(getlogin_spec != NULL)
        {
            /* [The calling process has a controlling terminal] */
            REQ("", "The calling process has a controlling terminal",
                @hasControllingTerminal_ProcessId(processid));
        
            if(pre_cterm != NULL)
            {
                /* [The controlling terminal is a login terminal] */
                REQ("", "The controlling terminal is a login terminal",
                    !isNotLoginTTY_Terminal(pre_cterm));

                /*
                 * The getlogin() function shall return a pointer to a string
                 * containing the user name associated by the login activity
                 * with the controlling terminal of the current process.
                 */
                REQ("getlogin.01", "getlogin() shall return a login name",
                   ((isLoginTTY_Terminal(pre_cterm) &&
                     !equals(getLogin_Terminal(pre_cterm), NULL)) =>
                      equals(getlogin_spec, getLogin_Terminal(pre_cterm))));
            }

            /* The maximum size of the login name is {LOGIN_NAME_MAX} */
            REQ("getlogin.02", "The maximum size of the login name is {LOGIN_NAME_MAX}",
               (isCorrectLoginName(context, getlogin_spec) != False_Bool3));
        }

        return true;
    }
}

void onGetLogin(CallContext context, ErrorCode *errno, CString *getlogin_spec)
{
    ProcessId processid = getProcessId_CallContext(context);

    if(getlogin_spec != NULL && hasControllingTerminal_ProcessId(processid))
    {
        Terminal *cterm = getControllingTerminal_ProcessId(processid);

        if(cterm != NULL && !isNotLoginTTY_Terminal(cterm) &&
          (isLoginTTY_Terminal(cterm) => equals(getLogin_Terminal(cterm), NULL)))
        {
            login_Terminal(cterm, getlogin_spec);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

 See getlogin_spec
*/
specification
IntT getlogin_r_spec(CallContext context, CString *name, SizeT namesize)
{
    ProcessId processid = getProcessId_CallContext(context);

    Terminal *pre_cterm = hasControllingTerminal_ProcessId(processid) ?
        clone(getControllingTerminal_ProcessId(processid)) : NULL;

    pre
    {
        /* 
         * The array is namesize characters long and should have space for the
         * name and the terminating null character.
         */
        REQ("app.getlogin_r.01", "The array is not NULL", (name != NULL));

        REQ("app.getlogin_r.01", "The array should have space for login name",
           (isCorrectLoginNameSize(context, namesize) != False_Bool3));
    }
    coverage C
    {
        CTERM_COVERAGE(getlogin_r, "getlogin_r()", processid);
    }
    post
    {
        /*
         * [On error,] an error number shall be returned to indicate the error.
         */
        ERROR_BEGIN(POSIX_GETLOGIN_R, "getlogin_r.04", (getlogin_r_spec != 0),
            getlogin_r_spec);

            /*
             * The getlogin() and getlogin_r() functions may fail if:
             *
             * [EMFILE]
             *
             * {OPEN_MAX} file descriptors are currently open in the calling process.
             */
            ERROR_MAY3(POSIX_GETLOGIN, EMFILE, "getlogin_r.05.01",
                @isOpenFileDescNumberExceedMax(context));

            /*
             * The getlogin() and getlogin_r() functions may fail if:
             *
             * [ENFILE]
             *
             * The maximum allowable number of files is currently open in the system.
             */
            ERROR_UNCHECKABLE(POSIX_GETLOGIN, ENFILE, "getlogin_r.05.02",
                "don't know how to check");

            /*
             * The getlogin() and getlogin_r() functions may fail if:
             *
             * [ENXIO]
             *
             * The calling process has no controlling terminal.
             */
            ERROR_MAY(POSIX_GETLOGIN, ENXIO, "getlogin_r.05.03",
                @!hasControllingTerminal_ProcessId(processid));

            /*
             * The getlogin_r() function may fail if:
             *
             * [ERANGE]
             *
             * [TSF]
             * The value of namesize is smaller than the length of the string
             * to be returned including the terminating null character.
             */
            ERROR_MAY3(POSIX_GETLOGIN_R, ERANGE, "getlogin_r.05.04",
                @not_Bool3(isCorrectLoginNameSize(context, namesize)));

        ERROR_END();

        /* If successful, the getlogin_r() function shall return zero */
        REQ("getlogin_r.03", "On success, getlogin_r() shall return zero",
           (getlogin_r_spec == 0));

        /* [The calling process has a controlling terminal] */
        REQ("", "The calling process has a controlling terminal",
            @hasControllingTerminal_ProcessId(processid));
        
        if(pre_cterm != NULL)
        {
            /* [The controlling terminal is a login terminal] */
            REQ("", "The controlling terminal is a login terminal",
                !isNotLoginTTY_Terminal(pre_cterm));

            /*
             * getlogin_r() function shall put the name associated by the login
             * activity with the controlling terminal of the current process in
             * the character array pointed to by name.
             */
            REQ("getlogin_r.01", "getlogin_r() shall put login name to the name",
               ((isLoginTTY_Terminal(pre_cterm) &&
                 !equals(getLogin_Terminal(pre_cterm), NULL)) =>
                  equals(name, getLogin_Terminal(pre_cterm))));
        }

        /* The maximum size of the login name is {LOGIN_NAME_MAX} */
        REQ("getlogin_r.02", "The maximum size of the login name is {LOGIN_NAME_MAX}",
           (isCorrectLoginName(context, name) != False_Bool3));

        return true;
    }
}

void onGetLoginR(CallContext context, CString *name, SizeT namesize,
                 IntT getlogin_r_spec)
{
    ProcessId processid = getProcessId_CallContext(context);

    if(getlogin_r_spec == 0 && hasControllingTerminal_ProcessId(processid))
    {
        Terminal *cterm = getControllingTerminal_ProcessId(processid);

        if(cterm != NULL && !isNotLoginTTY_Terminal(cterm) &&
          (isLoginTTY_Terminal(cterm) => equals(getLogin_Terminal(cterm), NULL)))
        {
            login_Terminal(cterm, name);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    grantpt - grant access to the slave pseudo-terminal device

SYNOPSIS

    #include <stdlib.h>

    int grantpt(int fildes);

DESCRIPTION

    The grantpt() function shall change the mode and ownership of the slave
    pseudo-terminal device associated with its master pseudo-terminal
    counterpart. The fildes argument is a file descriptor that refers to a
    master pseudo-terminal device. The user ID of the slave shall be set to
    the real UID of the calling process and the group ID shall be set to an
    unspecified group ID. The permission mode of the slave pseudo-terminal
    shall be set to readable and writable by the owner, and writable by the
    group.

    The behavior of the grantpt() function is unspecified if the application
    has installed a signal handler to catch SIGCHLD signals.

RETURN VALUE

    Upon successful completion, grantpt() shall return 0; otherwise, it shall
    return -1 and set errno to indicate the error.

ERRORS

    The grantpt() function may fail if:

    [EBADF]
        The fildes argument is not a valid open file descriptor.
    [EINVAL]
        The fildes argument is not associated with a master pseudo-terminal
        device.
    [EACCES]
        The corresponding slave pseudo-terminal device could not be accessed.
*/
specification
IntT grantpt_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    ProcessId processid = getProcessId_CallContext(context);

    FileSystem *file_system = getFileSystem(context);

    bool is_ptm = isValid_FileDescId(fildes) &&
        isTerminal_FileDescId(fildes) && isPTM_FileDescId(fildes);

    CString *pts_name = is_ptm ? getPTSName_FileDescId(fildes) : NULL;

    File *pre_pts_file = pts_name != NULL ?
        getFile_FileSystem(file_system, pts_name) : NULL;

    FilePermissions *pre_pts_file_perms = pre_pts_file != NULL ?
        getPermissions_File(pre_pts_file) : NULL;

    bool does_pts_exist = pre_pts_file != NULL;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        /*
         * The behavior of the grantpt() function is unspecified if the
         * application has installed a signal handler to catch SIGCHLD signals.
         */
        REQ("app.grantpt.02", "The application has no SIGCHLD handler installed",
            !isSignalHandled_ProcessId(processid, SUT_SIGCHLD));

        if(POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM)
        {
            /*
             * The fildes argument is a file descriptor that refers to a master
             * pseudo-terminal device.
             */
            REQ("app.grantpt.01", "The fildes is PTM descriptor id", is_ptm);
        }

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM

            NOT_PTM_DETAIL_COVERAGE(grantpt, "grantpt()", fildes);

#endif /* #if !POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM */

        if(isWrong_FileDescId(getCPart_FileDescId(fildes)))
        {
            PTS_NAME_COVERAGE(PTSIsClosed, "PTS is closed", file_system, pts_name);
        }
        else
        {
            PTS_NAME_COVERAGE(PTSIsOpen, "PTS is open", file_system, pts_name);
        }
    }
    coverage C_owner { PERM_COVERAGE(owner, "owner", pre_pts_file_perms); }
    coverage C_group { PERM_COVERAGE(group, "group", pre_pts_file_perms); }
    coverage C_other { PERM_COVERAGE(other, "other", pre_pts_file_perms); }
    post
    {
        /*
         * [On error,] it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_GRANTPT, "grantpt.03", (grantpt_spec == -1), *errno);

           /*
            * The grantpt() function may fail if:
            *
            * [EBADF]
            *
            * The fildes argument is not a valid open file descriptor.
            */
            ERROR_MAY(POSIX_GRANTPT, EBADF, "grantpt.04.01",
                @!isValid_FileDescId(fildes));

           /*
            * The grantpt() function may fail if:
            *
            * [EINVAL]
            *
            * The fildes argument is not associated with a master
            * pseudo-terminal device.
            */
            ERROR_MAY(POSIX_GRANTPT, EINVAL, "grantpt.04.02", !is_ptm);

           /*
            * The grantpt() function may fail if:
            *
            * [EACCES]
            *
            * The corresponding slave pseudo-terminal device could not be
            * accessed.
            */
            ERROR_MAY3(POSIX_GRANTPT, EACCES, "grantpt.04.03",
            (
                pre_pts_file != NULL ? False_Bool3 : Unknown_Bool3
            ));

        ERROR_END();
         
        /* Upon successful completion, grantpt() shall return 0 */
        REQ("grantpt.02", "On success, grantpt() shall return 0", (grantpt_spec == 0));

        if(is_ptm && does_pts_exist)
        {
            File *pts_file = getFile_FileSystem(file_system, pts_name);
            FilePermissions *pts_file_perms = getPermissions_File(pts_file);

            /*
             * The user ID of the slave shall be set to the real UID of the
             * calling process.
             */
            REQ("?grantpt.01.01", "The user ID shall be set to the real UID of the process",
                equals(getUserId_File(pts_file), getRealUserId_ProcessId(processid)));

            /* The group ID shall be set to an unspecified group ID */
            REQ("grantpt.01.02", "The group ID shall be set to an unspecified group ID",
                true);

            /*
             * The permission mode of the slave pseudo-terminal shall be set to
             * readable and writable by the owner, and writable by the group.
             */
            REQ("?grantpt.01.03", "The PTS is readable by the owner", pts_file_perms->owner->read);
            REQ("?grantpt.01.03", "The PTS is writable by the owner", pts_file_perms->owner->write);
            REQ("?grantpt.01.03", "The PTS is writable by the group", pts_file_perms->group->write);

            /* [Implicit postcondition] */
            if(pre_pts_file_perms != NULL)
            {
                REQ("", "grantpt() shall not change owner x",
                    (pts_file_perms->owner->execute == pre_pts_file_perms->owner->execute));
                REQ("", "grantpt() shall not change group r",
                    (pts_file_perms->group->read == pre_pts_file_perms->group->read));
                REQ("", "grantpt() shall not change group x",
                    (pts_file_perms->group->execute == pre_pts_file_perms->group->execute));
                REQ("", "grantpt() shall not change other r",
                    (pts_file_perms->other->read == pre_pts_file_perms->other->read));
                REQ("", "grantpt() shall not change other w",
                    (pts_file_perms->other->write == pre_pts_file_perms->other->write));
                REQ("", "grantpt() shall not change other x",
                    (pts_file_perms->other->execute == pre_pts_file_perms->other->execute));
            }
        }

        return true;
    }
}

void onGrantPT(CallContext context, FileDescId fildes, ErrorCode *errno, IntT grantpt_spec)
{
    ProcessId processid = getProcessId_CallContext(context);

    FileSystem *file_system = getFileSystem(context);

    bool is_ptm = isValid_FileDescId(fildes) &&
        isTerminal_FileDescId(fildes) && isPTM_FileDescId(fildes);

    CString *pts_name = is_ptm ? getPTSName_FileDescId(fildes) : NULL;

    File *pts_file = pts_name != NULL ?
        getFile_FileSystem(file_system, pts_name) : NULL;

    if(grantpt_spec == 0 && pts_file != NULL)
    {
        FilePermissions *pts_file_perms = getPermissions_File(pts_file);

        if(pts_file_perms == NULL)
        {
            pts_file_perms = create_FilePermissions(NULL, NULL, NULL, Unknown_Bool3, Unknown_Bool3, Unknown_Bool3);
        }

        setUserId_File(pts_file, getRealUserId_ProcessId(processid));

        if(!pts_file_perms->owner)
            pts_file_perms->owner=create_FilePermission(1, 1, 1);
        if(!pts_file_perms->group)
            pts_file_perms->group=create_FilePermission(1, 1, 1);

        pts_file_perms->owner->read  = true;
        pts_file_perms->owner->write = true;
        pts_file_perms->group->write = true;

        setPermissions_File(pts_file, pts_file_perms);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    isatty - test for a terminal device

SYNOPSIS

    #include <unistd.h>

    int isatty(int fildes);

DESCRIPTION

    The isatty() function shall test whether fildes, an open file descriptor,
    is associated with a terminal device.

RETURN VALUE

    The isatty() function shall return 1 if fildes is associated with a
    terminal; otherwise, it shall return 0 and may set errno to indicate the
    error.

ERRORS

    The isatty() function may fail if:

    [EBADF]
        The fildes argument is not a valid open file descriptor.
    [ENOTTY]
        The fildes argument is not associated with a terminal.
*/
specification
IntT isatty_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        return true;
    }
    coverage C
    {
        FILE_TYPE_DETAIL_COVERAGE(isatty, "isatty()", fildes);
    }
    post
    {
        bool is_unknown  = isValid_FileDescId(fildes) &&
            getFileKind_FileDescId(fildes) == UnknownFileKind;

        bool is_terminal = isValid_FileDescId(fildes) &&
            isTerminal_FileDescId(fildes);

        
        /* The fildes argument is not a valid open file descriptor */
        if(!isValid_FileDescId(fildes))
        {
            /*
             * it shall return 0 and may set errno to indicate the error.
             */
            REQ("isatty.01.02", "If fildes is not a valid file descriptor id, "
                "isatty() shall return 0", (isatty_spec == 0));

            /*
             * The isatty() function may fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid open file descriptor.
             */
            REQ("isatty.01.02;isatty.02.01", "isatty() may set errno to EBADF",
               (*errno == SUT_EBADF || *errno == SUT_EOK));
        }
        /* [if file type is unknown] */
        else if(is_unknown)
        {
            /* [isatty() shall return 0 or 1] */
            REQ("isatty.01.01;isatty.01.02", "isatty() shall return 0 or 1",
               (isatty_spec == 0 || isatty_spec == 1));

            /* [isatty() may set errno to EBADF or ENOTTY] */
            REQ("isatty.01.01;isatty.01.02", "if isatty() returns 1, it shall not set errno",
               ((isatty_spec == 1) => (*errno == SUT_EOK)));

            REQ("isatty.01.01;isatty.01.02;isatty.02",
                "if isatty() returns 0, it may set errno to EBADF or ENOTTY",
               ((isatty_spec == 0) =>
                (*errno == SUT_EBADF || *errno == SUT_ENOTTY || *errno == SUT_EOK)));
        }
        /* if fildes is associated with a terminal */
        else if(is_terminal)
        {
            /* The isatty() function shall return 1 */
            REQ("isatty.01.01", "isatty() shall return 1", (isatty_spec == 1));

            /* [isatty() shall not set errno] */
            REQ("isatty.01.01", "isatty() shall not set errno", (*errno == SUT_EOK));
        }
        /* The fildes argument is not associated with a terminal */
        else
        {
            /* It shall return 0 and may set errno to indicate the error */
            REQ("isatty.01.02", "isatty() shall return 0", (isatty_spec == 0));

            /*
             * [ENOTTY]
             *     The fildes argument is not associated with a terminal.
             */
            REQ("isatty.01.02;isatty.02.02", "isatty() may set errno to ENOTTY",
                (*errno == SUT_ENOTTY || *errno == SUT_EOK));
        }

        return true;
    }
}

void onIsATTY(CallContext context, FileDescId fildes, ErrorCode *errno, IntT isatty_spec)
{
    if(isatty_spec == 1)
    {
        if(/*getFileKind_FileDescId(fildes) == UnknownFileKind ||
           getFileKind_FileDescId(fildes) == CharacterFile && */!isTerminal_FileDescId(fildes))
        {
            File *file = getFile_FileDescId(fildes);

            if(file != NULL)
            {
                file->descriptor = default_Terminal();
            }

            setFileKind_FileDescId(fildes, CharacterFile);
            setDescriptor_FileDescId(fildes, default_TerminalDescriptor());
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    open - open a file

    See io.file subsystem
*/
specification typedef struct OpenTTYCall OpenTTYCall = {};

OpenTTYCall* create_OpenTTYCall
(
    CallContext context,
    CString *path,
    OpenFlags oflag
)
{
    return create(&type_OpenTTYCall, context, path, oflag);
}

specification
void open_tty_spec(CallContext context, CString *path, OpenFlags oflag)
{
    ProcessId processid = getProcessId_CallContext(context);
    ProcessId sessionid = getSessionId_ProcessId(processid);

    FileSystem *file_system = getFileSystem(context);

    File *file = file_system != NULL ? getFile_FileSystem(file_system, path) : NULL;

    TermIOS *termios = file != NULL && isTerminal_File(file) ?
        getTermIOS_Terminal(file->descriptor) : NULL;

    pre
    {
        /* [The file exists in the file system] */
        REQ("", "The file exists in the file system", (file != NULL));

        /* [The path refers to a terminal device file] */
        REQ("", "The path refers to a terminal device file", isTerminal_File(file));

        /* [The termios structure is not NULL] */
        REQ("", "The termios structure is not NULL", (termios != NULL));

        /* [O_APPEND flag is not set] */
        REQ("", "O_APPEND flag is not set", !oflag.append);

        /* [O_CREAT flag is not set] */
        REQ("", "O_CREAT flag is not set", !oflag.creat);

        /* [O_EXCL flag is not set] */
        REQ("", "O_EXCL flag is not set", !oflag.excl);

        /* [O_TRUNC flag is not set] */
        REQ("", "O_TRUNC flag is not set", !oflag.trunc);

        /*
         * Conforming applications shall call unlockpt() before opening the
         * slave side.
         */
        REQ("app.open.18", "PTS shall be unlocked",
           (isPTS_Terminal(file->descriptor) => !isLocked_Terminal(file->descriptor)));

        return true;
    }
    coverage C
    {
        /*
         * The Open Group Base Specifications Issue 6
         * IEEE Std 1003.1, 2004 Edition
         * Copyright (c) 2001-2004 The IEEE and The Open Group,
         * All Rights reserved
         *
         *   
         *   See section 'Base Definitions /
         *     11. General Terminal Interface /
         *     11.1 Interface Characteristics /
         *     11.1.3 The Controlling Terminal'.
         */
        bool control_condition =
            /* session leader */
            equals_ProcessId(processid, sessionid) &&
            /* has no controlling terminal */
            !hasControllingTerminal_ProcessId(processid) &&
            /* without using the O_NOCTTY option */
            !oflag.noctty;

        if(control_condition)
        {
            TERM_OPEN_MODE_DETAIL_COVERAGE(MayOpenCTerm,
                "May open controlling terminal", context, path, oflag);
        }
        else
        {
            TERM_OPEN_MODE_DETAIL_COVERAGE(ShallNotOpenCTerm,
                "Shall not open controlling terminal", context, path, oflag);
        }
    }
    post
    {
        /* [The open() function shall block] */
        REQ("", "open() shall block", equals(getBlockedCall(context),
            create_OpenTTYCall(context, path, oflag)));

        return true;
    }
}

void onOpenTTY(CallContext context, CString *path, OpenFlags oflag)
{
    startBlockedCall(context, create_OpenTTYCall(context, path, oflag));
    threadShouldBeRun(context);
}

specification typedef struct OpenTTYReturnType OpenTTYReturnType = {};

OpenTTYReturnType* create_OpenTTYReturnType
(
    CallContext context,
    FileDescId fildes,
    ErrorCode *errno
)
{
    return create(&type_OpenTTYReturnType, context, fildes, errno);
}

reaction
OpenTTYReturnType* open_tty_return(void)
{
    post
    {
        CallContext context = open_tty_return->context;
        FileDescId returned_value = open_tty_return->returned_value;
        ErrorCode *errno = open_tty_return->errno;

        OpenTTYCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        CString *path = blocked_call->path;
        OpenFlags oflag = blocked_call->oflag;

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId sessionid = getSessionId_ProcessId(processid);

        ProcessState *pre_process_state = findProcessState(@getAllProcesses(), processid);

        FileSystem *pre_file_system = findFileSystem(@getAllFileSystems(), context);
        FileSystem *post_file_system = getFileSystem(context);

        File *pre_file = pre_file_system != NULL ?
            getFile_FileSystem(pre_file_system, path) : NULL;

        File *post_file = post_file_system != NULL ?
            getFile_FileSystem(post_file_system, path) : NULL;

        TermIOS *pre_termios = getTermIOS_Terminal(pre_file->descriptor);

        /*
         * The Open Group Base Specifications Issue 6
         * IEEE Std 1003.1, 2004 Edition
         * Copyright (c) 2001-2004 The IEEE and The Open Group,
         * All Rights reserved
         *
         *   
         *   See section 'Base Definitions /
         *     11. General Terminal Interface /
         *     11.1 Interface Characteristics /
         *     11.1.3 The Controlling Terminal'.
         */
        bool control_condition =
            /* session leader */
            equals_ProcessId(processid, sessionid) &&
            /* has no controlling terminal */
            pre_process_state->meta.cterm == NULL &&
            /* is not already associated with a session without */
            isNotControlling_Terminal(pre_file->descriptor) &&
            /* without using the O_NOCTTY option */
            !oflag.noctty;

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_OPEN, "open.30.02", isWrong_FileDescId(returned_value), *errno);

            /*
             * The open() function shall fail if:
             *
             * [EACCES]
             *
             * Search permission is denied on a component of the path prefix,
             * or the file exists and the permissions specified by oflag
             * are denied, or the file does not exist and write permission is
             * denied for the parent directory of the file to be created, or
             * O_TRUNC is specified and write permission is denied.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, EACCES, "open.31.01",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [EINTR]
             *
             * A signal was caught during open().
             */
            ERROR_SHALL(POSIX_OPEN, EINTR, "open.31.03",
                isBlockedCallInterruptedBySignal(context));

            /*
             * The open() function shall fail if:
             *
             * [EMFILE]
             *
             * {OPEN_MAX} file descriptors are currently open in the calling
             * process.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, EMFILE, "open.31.08",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [ENAMETOOLONG]
             *
             *
             * The length of the path argument exceeds {PATH_MAX} or a pathname
             * component is longer than {NAME_MAX}.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, ENAMETOOLONG, "open.31.09",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [ENFILE]
             *
             * The maximum allowable number of files is currently open in the
             * system.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, ENFILE, "open.31.10",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [ENOENT]
             *
             * O_CREAT is not set and the named file does not exist; or O_CREAT
             * is set and either the path prefix does not exist or the path
             * argument points to an empty string.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, ENOENT, "open.31.11",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [ENOTDIR]
             *
             * A component of the path prefix is not a directory.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, ENOTDIR, "open.31.14",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [ENXIO]
             *
             * The named file is a character special or block special file, and
             * the device associated with this special file does not exist.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, ENXIO, "open.31.16",
                "don't know how to check");

            /*
             * The open() function shall fail if:
             *
             * [EROFS]
             *
             * The named file resides on a read-only file system and either
             * O_WRONLY, O_RDWR, O_CREAT (if the file does not exist), or
             * O_TRUNC is set in the oflag argument.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, EROFS, "open.31.18",
                "don't know how to check");

            /*
             * The open() function may fail if:
             *
             * [EAGAIN]
             *
             * [XSI]
             * The path argument names the slave side of a pseudo-terminal
             * device that is locked.
             */
            ERROR_UNCHECKABLE(POSIX_OPEN, EAGAIN, "open.32.01",
                "don't know how to check");

        ERROR_END();

        /*
         * Upon successful completion, the function shall open the file and
         * return a non-negative integer representing the lowest numbered
         * unused file descriptor.
         */
        REQ("open.30.01", "On success, open() shall open file",
            isValid_FileDescId(returned_value));

        REQ("open.30.01", "On success, open() shall return  non-negative integer"
            "representing the lowest file descriptor id",
        (
            returned_value.filedesc >= 0 &&
            isLowestUnused_FileDescId(pre_process_state->file_descriptors, returned_value)
        ));

        /*
         * The file status flags and file access modes of the open file
         * description shall be set according to the value of oflag.
         */
        REQ("?open.04", "The file access mode is set according to the oflag",
           (getAccessMode_FileDescId(returned_value) == oflag.access_mode));

        REQ("?open.04", "The file blocking mode is set according to the oflag",
           (getBlockMode_FileDescId(returned_value) == oflag.block_mode));

        /*
         * As described in open(), opening a terminal device file with the
         * O_NONBLOCK flag clear shall cause the thread to block until the
         * terminal device is ready and available. If CLOCAL mode is not set,
         * this means blocking until a connection is established. If CLOCAL
         * mode is set in the terminal, or the O_NONBLOCK flag is specified in
         * the open(), the open() function shall return a file descriptor
         * without waiting for a connection to be established.
         */
        REQ("", "open() shall be blocking until a connection is established",
           ((!pre_termios->cflag->clocal && oflag.block_mode == Blocking) =>
              isConnected_Terminal(post_file->descriptor)));

        /*
         * If a session leader has no controlling terminal, and opens a
         * terminal device file that is not already associated with a session
         * without using the O_NOCTTY option
         */
        if(control_condition)
        {
            if( POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_BEHAVIOUR ==
                POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_SHALL_SET_CTERM )
            {
                ProcessIdObj *post_fpgroupid;
                ProcessIdObj *post_sessionid;

                /* [Terminal shall become the controlling terminal] */
                REQ("?open.40.01", "Terminal shall become the controlling terminal",
                   (getControllingStatus_Terminal(post_file->descriptor) == True_Bool3));

                post_fpgroupid = getForegroundPGroupId_Terminal(post_file->descriptor);
                post_sessionid = getSessionId_Terminal(post_file->descriptor);

                /* [Terminal shall become associated with a session] */
                REQ("?open.40.01", "Terminal shall become associated with a session",
                   (post_sessionid != NULL && equals_ProcessId(*post_sessionid, sessionid)));

                /*
                 * When a controlling terminal becomes associated with a session,
                 * its foreground process group shall be set to the process group
                 * of the session leader.
                 */
                REQ("?open.40.03", "Foreground process group shall be set to a session leader's",
                   (post_fpgroupid != NULL && equals_ProcessId(*post_fpgroupid, sessionid)));
            }
            else if( POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_BEHAVIOUR ==
                     POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_SHALL_NOT_SET_CTERM )
            {
                /* [Terminal shall not become the controlling terminal] */
                REQ("?open.40.01", "Terminal shall not become the controlling terminal",
                   (getControllingStatus_Terminal(post_file->descriptor) == False_Bool3));
            }
            else
            {
                /* [Terminal may become the controlling terminal] */
                REQ("", "Terminal may become the controlling terminal",
                   (getControllingStatus_Terminal(post_file->descriptor) == Unknown_Bool3));
            }
        }
        /*
         * If a process which is not a session leader opens a terminal file, or
         * the O_NOCTTY option is used on open().            
         */
        else if(!equals_ProcessId(processid, sessionid) || oflag.noctty)
        {                 
            /*
             * Terminal shall not become the controlling terminal of the
             * calling process.
             */
            REQ("?open.40.02", "Terminal shall not become the controlling terminal",
               (getControllingStatus_Terminal(post_file->descriptor) == False_Bool3));
        }

        /*
         * The default on the opening of a terminal file is that neither its
         * input nor its output are suspended.
         */
        REQ("?io.term.01", "Terminal input is not suspended",
            !isInputSuspended_Terminal(post_file->descriptor));

        REQ("?io.term.01", "Terminal output is not suspended",
            !isOutputSuspended_Terminal(post_file->descriptor));

        return true;
    }
}

void onOpenTTYReturn(CallContext context, FileDescId open_tty_return, ErrorCode *errno)
{
    if(!isWrong_FileDescId(open_tty_return))
    {
        FileSystem *file_system = getFileSystem(context);

        if(file_system != NULL)
        {
            OpenTTYCall *blocked_call = finishBlockedCall(context);
            CString *path = blocked_call->path;
            OpenFlags oflag = blocked_call->oflag;
            File *file = getFile_FileSystem(file_system, path);

            if(file == NULL)
            {
                file = registerFile(file_system, path);
            }
            if(file != NULL)
            {
                TermIOS *termios;
                ProcessId processid = getProcessId_CallContext(context);
                ProcessId sessionid = getSessionId_ProcessId(processid);

                /*
                 * The Open Group Base Specifications Issue 6
                 * IEEE Std 1003.1, 2004 Edition
                 * Copyright (c) 2001-2004 The IEEE and The Open Group,
                 * All Rights reserved
                 *
                 *   
                 *   See section 'Base Definitions /
                 *     11. General Terminal Interface /
                 *     11.1 Interface Characteristics /
                 *     11.1.3 The Controlling Terminal'.
                 */
                bool control_condition =
                    /* session leader */
                    equals_ProcessId(processid, sessionid) &&
                    /* has no controlling terminal */
                    !hasControllingTerminal_ProcessId(processid) &&
                    /* is not already associated with a session */
                    file->descriptor != NULL && isNotControlling_Terminal(file->descriptor) &&
                    /* without using the O_NOCTTY option */
                    !oflag.noctty;

                if(file->kind == UnknownFileKind)
                {
                    file->kind = CharacterFile;
                }

                if(file->descriptor == NULL)
                {
                    file->descriptor = default_Terminal();
                }

                if(isPTM_Terminal(file->descriptor))
                {
                    setPTMDescId_Terminal(file->descriptor, open_tty_return);
                    lock_Terminal(file->descriptor);
                }
                else if(isPTS_Terminal(file->descriptor))
                {
                    Terminal *ptm = getRemoteTerminal_Terminal(file->descriptor);

                    setCPart_FileDescId(open_tty_return, getPTMDescId_Terminal(ptm));
                    setCPart_FileDescId(getPTMDescId_Terminal(ptm), open_tty_return);
                }

                if((termios = getTermIOS_Terminal(file->descriptor)) != NULL &&
                   !termios->cflag->clocal && oflag.block_mode == Blocking)
                {
                    setConnectionStatus_Terminal(file->descriptor, True_Bool3);
                }

                if(control_condition)
                {
                    if( POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_BEHAVIOUR ==
                        POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_SHALL_SET_CTERM )
                    {
                        setControllingStatus_Terminal(file->descriptor, True_Bool3);

                        // TODO: what is `terminal`?!!
                        //setForegroundPGroupId_Terminal(terminal, create_ProcessIdObj(sessionid));
                        //setSessionId_Terminal(terminal, create_ProcessIdObj(sessionid));
                    }
                    else if( POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_BEHAVIOUR ==
                             POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_SHALL_NOT_SET_CTERM )
                    {
                        setControllingStatus_Terminal(file->descriptor, False_Bool3);
                    }
                    else
                    {
                        setControllingStatus_Terminal(file->descriptor, Unknown_Bool3);
                    }
                }
                else if(!equals_ProcessId(processid, sessionid) || oflag.noctty)
                {
                    setControllingStatus_Terminal(file->descriptor, False_Bool3);
                }

                registerFileDescriptor
                (
                    open_tty_return,             /* file_desc_id */
                    file->fileid,                /* file */
                    path,                        /* path */
                    oflag.access_mode,           /* access_mode */
                    oflag.block_mode,            /* block_mode */
                    CharacterFile,               /* kind */
                    false,                       /* fd_cloexec */
                    0,                           /* offset */
                    false,                       /* fdatasync */
                    false,                       /* is64bits */
                    default_TerminalDescriptor() /* descriptor */
                );
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

Name

    openpty -- find and open an available pseudo-terminal

Synopsis

    #include <pty.h>

    int openpty(int *amaster, int *aslave, char *name, struct termios *termp,
        struct winsize *winp);

Description

    The openpty() function shall find an available pseudo-terminal and return
    file descriptors for the master and slave devices in the locations
    referenced by amaster and aslave respectively. If name is not NULL, the
    filename of the slave shall be placed in the user supplied buffer
    referenced by name. If termp is not NULL, it shall point to a termios
    structure used to initialize the terminal parameters of the slave
    pseudo-terminal device. If winp is not NULL, it shall point to a winsize
    structure used to initialize the window size parameters of the slave
    pseudo-terminal device.

Return Value

    On success, zero is returned. On error, -1 is returned, and errno is set
    appropriately.

    Errors

        ENOENT      

        There are no available pseudo-terminals.
*/
specification
IntT openpty_spec(CallContext context, FileDescId *amaster, FileDescId *aslave,
                  CString *name, VoidTPtr termp, WinSize *winp, ErrorCode *errno)
{
    TermIOS *pre_termios = clone(getTermIOS(termp));

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        /* [Consistency of test suite] */
        REQ("", "if termp is not NULL, it is valid",
           (!isNULL_VoidTPtr(termp) => isValidPointer(context, termp)));

        /* [Implicit precondition] */
        REQ("", "amaster is not NULL", (amaster != NULL));

        /* [Implicit precondition] */
        REQ("", "aslave is not NULL", (aslave != NULL));

        return true;
    }
    coverage C_name  { NULL_COVERAGE(name, "name", name); }
    coverage C_termp { NULL_VOIDT_PTR_COVERAGE(termp, "termp", termp); }
    coverage C_winp  { NULL_COVERAGE(winp, "winp", winp); }
    post
    {
        TermIOS *post_termios = getTermIOS(termp);

        /* On error, -1 is returned */
        ERROR_BEGIN(LSB_OPENPTY, "openpty.06", (openpty_spec == -1), *errno);

            /*
             * On error, -1 is returned, and errno is set appropriately.
             *
             * [ENOENT] There are no available pseudo-terminals.
             */
            ERROR_UNCHECKABLE(LSB_OPENPTY, ENOENT, "openpty.06.01",
                "don't know how to check");

        ERROR_END();

        /* On success, zero is returned */
        REQ("openpty.05", "On success, openpty() shall return 0", (openpty_spec == 0));

        /*
         * The openpty() function shall find an available pseudo-terminal and
         * return file descriptors for the master and slave devices in the
         * locations referenced by amaster and aslave respectively.         
         */
        REQ("?openpty.01", "*amaster is a valid file descriptor id",
            isValid_FileDescId(*amaster));

        REQ("?openpty.01", "*amaster is refer to a terminal",
            isTerminal_FileDescId(*amaster));

        REQ("?openpty.01", "*amaster refers to a master pseudo-terminal",
            isPTM_FileDescId(*amaster));

        REQ("?openpty.01", "*aslave is a valid file descriptor id",
            isValid_FileDescId(*aslave));

        REQ("?openpty.01", "*aslave is refer to a terminal",
            isTerminal_FileDescId(*aslave));

        REQ("?openpty.01", "*aslave refers to slave pseudo-terminal",
            isPTS_FileDescId(*aslave));

        /*
         * If name is not NULL, the filename of the slave shall be placed in
         * the user supplied buffer referenced by name.
         */
        REQ("?openpty.02", "if name is not NULL, it shall contain PTS name",
           ((name != NULL) => equals(name, getPath_FileDescId(*aslave))));

        /*
         * If termp is not NULL, it shall point to a termios structure used to
         * initialize the terminal parameters of the slave pseudo-terminal
         * device.
         */
        REQ("?openpty.03", "if termp is not NULL, it shall contain to PTS termios",
           ((pre_termios != NULL) =>
             equals_TermIOS(pre_termios, getTermIOS_FileDescId(*aslave))));

        /*
         * If winp is not NULL, it shall point to a winsize structure used to
         * initialize the window size parameters of the slave pseudo-terminal
         * device.
         */
        REQ("?openpty.04", "if winp is not NULL, it shall contain PTS winsize",
           ((winp != NULL) =>
             equals(winp, getTerminalWinSize_FileDescId(*aslave))));

        /*
         * The default on the opening of a terminal file is that neither its
         * input nor its output are suspended.
         */
        REQ("?io.term.01", "PTM input is not suspended",
            !isTerminalInputSuspended_FileDescId(*amaster));

        REQ("?io.term.01", "PTM output is not suspended",
            !isTerminalOutputSuspended_FileDescId(*amaster));

        REQ("?io.term.01", "PTS input is not suspended",
            !isTerminalInputSuspended_FileDescId(*aslave));

        REQ("?io.term.01", "PTS input is not suspended",
            !isTerminalOutputSuspended_FileDescId(*amaster));

        return true;
    }
}

void onOpenPTY(CallContext context, FileDescId *amaster, FileDescId *aslave, CString *name,
               VoidTPtr termp, WinSize *winp, ErrorCode *errno, IntT openpty_spec)
{
    if(openpty_spec == 0)
    {
        FileSystem *file_system = getFileSystem(context);

        File *ptm_file = NULL;
        File *pts_file = NULL;

        FileId ptm_fileid = WrongFileId;
        FileId pts_fileid = WrongFileId;

        TerminalDescriptor *ptm_desc = default_TerminalDescriptor();
        TerminalDescriptor *pts_desc = default_TerminalDescriptor();

        TermIOS *termios = getTermIOS(termp);

        if((ptm_file = registerFile(file_system, NULL)) != NULL)
        {
            ptm_file->descriptor = default_Terminal();
            ptm_file->kind = CharacterFile;
            ptm_fileid = ptm_file->fileid;

            setType_Terminal(ptm_file->descriptor, PTM);
            setPTMDescId_Terminal(ptm_file->descriptor, *amaster);
            unlock_Terminal(ptm_file->descriptor);

            if(name != NULL)
            {
                setPTSName_Terminal(ptm_file->descriptor, name);
            }

            if(termios != NULL)
            {
                setTermIOS_Terminal(ptm_file->descriptor, termios);
            }
        }

        if((pts_file = registerFile(file_system, name)) != NULL)
        {
            pts_file->descriptor = default_Terminal();
            pts_file->kind = CharacterFile;
            pts_fileid = pts_file->fileid;

            setType_Terminal(pts_file->descriptor, PTS);
            setWinSize_Terminal(pts_file->descriptor, winp);
            unlock_Terminal(pts_file->descriptor);

            if(termios != NULL)
            {
                setTermIOS_Terminal(pts_file->descriptor, termios);
            }

            if(winp != NULL)
            {
                setWinSize_Terminal(pts_file->descriptor, winp);
            }        
        }

        setCPart_TerminalDescriptor(ptm_desc, *aslave);
        setCPart_TerminalDescriptor(pts_desc, *amaster);

        registerFileDescriptor
        (
           *amaster,                                    /* file_desc_id */
            ptm_fileid,                                 /* file */
            ( POSIX_IO_TERM_PTM_DEVICE_FILE_NAME 
              ? create_CString((char *)POSIX_IO_TERM_PTM_DEVICE_FILE_NAME)
              : NULL
            ),   /* path */
            ReadWrite,                                  /* access_mode */
            Blocking,                                   /* block_mode */
            CharacterFile,                              /* kind */
            false,                                      /* fd_cloexec */
            0,                                          /* offset */
            false,                                      /* fdatasync */
            false,                                      /* is64bits */
            ptm_desc                                    /* descriptor */
        );

        registerFileDescriptor
        (
           *aslave,                                     /* file_desc_id */
            pts_fileid,                                 /* file */
            name,                                       /* path */
            ReadWrite,                                  /* access_mode */
            Blocking,                                   /* block_mode */
            CharacterFile,                              /* kind */
            false,                                      /* fd_cloexec */
            0,                                          /* offset */
            false,                                      /* fdatasync */
            false,                                      /* is64bits */
            pts_desc                                    /* descriptor */
        );

        if(ptm_file != NULL && pts_file != NULL)
        {
            connect_Terminals
            (
                ptm_file->descriptor,
                pts_file->descriptor,
                POSIX_IO_TERM_PT_TRANSMISSION_TIME,
                POSIX_IO_TERM_PT_TRANSMISSION_TIME
            );
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    posix_openpt - open a pseudo-terminal device

SYNOPSIS

    #include <stdlib.h>
    #include <fcntl.h>

    int posix_openpt(int oflag);

DESCRIPTION

    The posix_openpt() function shall establish a connection between a master
    device for a pseudo-terminal and a file descriptor. The file descriptor is
    used by other I/O functions that refer to that pseudo-terminal.

    The file status flags and file access modes of the open file description
    shall be set according to the value of oflag.

    Values for oflag are constructed by a bitwise-inclusive OR of flags from
    the following list, defined in <fcntl.h>:

    O_RDWR
        Open for reading and writing.
    O_NOCTTY
        If set posix_openpt() shall not cause the terminal device to become the
        controlling terminal for the process.

    The behavior of other values for the oflag argument is unspecified.

RETURN VALUE

    Upon successful completion, the posix_openpt() function shall open a master
    pseudo-terminal device and return a non-negative integer representing the
    lowest numbered unused file descriptor. Otherwise, -1 shall be returned
    and errno set to indicate the error.

ERRORS

    The posix_openpt() function shall fail if:

    [EMFILE]
        {OPEN_MAX} file descriptors are currently open in the calling process.
    [ENFILE]
        The maximum allowable number of files is currently open in the system.

    The posix_openpt() function may fail if:

    [EINVAL]
        The value of oflag is not valid.
    [EAGAIN]
        Out of pseudo-terminal resources.
    [ENOSR]
        Out of STREAMS resources.
*/
specification
FileDescId posix_openpt_spec(CallContext context, OpenFlags oflag, ErrorCode *errno)
{
    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        /*
         * Values for oflag are constructed by a bitwise-inclusive OR of flags
         * from the following list, defined in <fcntl.h>:
         *
         * O_RDWR
         *     Open for reading and writing.
         * O_NOCTTY
         *     If set posix_openpt() shall not cause the terminal device to
         *     become the controlling terminal for the process.
         *
         * The behavior of other values for the oflag argument is unspecified.
         */
        REQ("app.posix_openpt.01", "flag O_WRONLY is not permited",
           (oflag.access_mode != WriteOnly));

        REQ("app.posix_openpt.01", "flag O_NONBLOCKING is not permited",
           (oflag.block_mode != Nonblocking));

        REQ("app.posix_openpt.01", "flag O_APPEND is not permited", !oflag.append);

        REQ("app.posix_openpt.01", "flag O_CREAT is not permited", !oflag.creat);

        REQ("app.posix_openpt.01", "flag O_EXCL is not permited", !oflag.excl);

        REQ("app.posix_openpt.01", "flag O_TRUNC is not permited", !oflag.trunc);

        return true;
    }
    coverage C
    {
        if(oflag.access_mode == ReadOnly)
        {
            if(oflag.noctty)
            {
                return { RDONLY_NOCTTY, "Read only, not controlling" };
            }
            else
            {
                return { RDONLY_CTTY, "Read only, controlling"};
            }
        }
        else
        {
            if(oflag.noctty)
            {
                return { RDWR_NOCTTY, "Read write, not controlling" };
            }
            else
            {
                return { RDWR_CTTY, "Read write, controlling" };
            }
        }
    }
    post
    {
        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_POSIX_OPENPT, "posix_openpt.04",
            isWrong_FileDescId(posix_openpt_spec), *errno);

            /*
             * The posix_openpt() function shall fail if:
             *
             * [EMFILE]
             *
             * {OPEN_MAX} file descriptors are currently open in the calling
             * process.
             */
            ERROR_SHALL3(POSIX_POSIX_OPENPT, EMFILE, "posix_openpt.05.01",
                @isOpenFileDescNumberExceedMax(context));

            /*
             * The posix_openpt() function shall fail if:
             *
             * [ENFILE]
             *
             * The maximum allowable number of files is currently open in the
             * system.
             */
            ERROR_UNCHECKABLE(POSIX_POSIX_OPENPT, ENFILE, "posix_openpt.05.02",
                "don't know how to check");

            /*
             * The posix_openpt() function may fail if:
             *
             * [EINVAL]
             *
             * The value of oflag is not valid.
             */
            ERROR_MAY(POSIX_POSIX_OPENPT, EINVAL, "posix_openpt.06.01",
            (
                oflag.access_mode == WriteOnly  ||
                oflag.block_mode == Nonblocking ||
                oflag.append                    ||
                oflag.creat                     ||
                oflag.excl                      ||
                oflag.trunc
            ));

            /*
             * The posix_openpt() function may fail if:
             *
             * [EAGAIN]
             *
             * Out of pseudo-terminal resources.
             */
            ERROR_UNCHECKABLE(POSIX_POSIX_OPENPT, EAGAIN, "posix_openpt.06.02",
                "don't know how to check");

            /*
             * The posix_openpt() function may fail if:
             *
             * [ENOSR]
             *
             * [XSR]
             * Out of STREAMS resources.
             */
            ERROR_UNCHECKABLE(POSIX_POSIX_OPENPT, ENOSR, "posix_openpt.06.02",
                "don't know how to check");

        ERROR_END();

        /*
         * Upon successful completion, the posix_openpt() function shall return
         * a non-negative integer representing the lowest numbered unused file
         * descriptor.
         */
        REQ("posix_openpt.03", "On success, posix_openpt() shall return a "
            "non-negative integer representing the lowest file descriptor id",
        (
            posix_openpt_spec.filedesc >= 0 &&
            isLowestUnused_FileDescId(@getFileDescriptors(context), posix_openpt_spec)
        ));

        /*
         * The posix_openpt() function shall establish a connection between a
         * master device for a pseudo-terminal and a file descriptor.
         */
        REQ("?posix_openpt.01", "posix_openpt() shall return a valid file descriptor id",
            isValid_FileDescId(posix_openpt_spec));

        REQ("?posix_openpt.01", "posix_openpt() shall return a terminal descriptor id",
            isTerminal_FileDescId(posix_openpt_spec));

        REQ("?posix_openpt.01", "posix_openpt() shall return a PTM descriptor id",
            isPTM_FileDescId(posix_openpt_spec));

        /*
         * The file status flags and file access modes of the open file
         * description shall be set according to the value of oflag.
         */
        REQ("?posix_openpt.02",
            "posix_openpt() shall set file access modes according to the oflag",
           (getAccessMode_FileDescId(posix_openpt_spec) == oflag.access_mode));

        REQ("?posix_openpt.02",
            "If O_NOCTTY is set, posix_openpt() shall not open a controlling terminal",
           (oflag.noctty => isNotControllingTerminal_FileDescId(posix_openpt_spec)));

        /*
         * The default on the opening of a terminal file is that neither its
         * input nor its output are suspended.
         */
        REQ("?io.term.01", "PTM input is not suspended",
            !isTerminalInputSuspended_FileDescId(posix_openpt_spec));

        REQ("?io.term.01", "PTM output is not suspended",
            !isTerminalOutputSuspended_FileDescId(posix_openpt_spec));

        return true;
    }
}

void onPosixOpenPT(CallContext context, OpenFlags oflag, ErrorCode *errno,
                   FileDescId posix_openpt_spec)
{
    if(!isWrong_FileDescId(posix_openpt_spec))
    {
        ProcessId processid = getProcessId_CallContext(context);
        ProcessId sessionid = getSessionId_ProcessId(processid);

        FileSystem *file_system = getFileSystem(context);
        File *ptm_file = registerFile(file_system, NULL);

        if(ptm_file != NULL)
        {
            /*
             * The Open Group Base Specifications Issue 6
             * IEEE Std 1003.1, 2004 Edition
             * Copyright (c) 2001-2004 The IEEE and The Open Group,
             * All Rights reserved
             *
             *   
             *   See section 'Base Definitions /
             *     11. General Terminal Interface /
             *     11.1 Interface Characteristics /
             *     11.1.3 The Controlling Terminal'.
             */
            bool control_condition =
                /* session leader */
                equals_ProcessId(processid, sessionid) &&
                /* has no controlling terminal */
                !hasControllingTerminal_ProcessId(processid) &&
                /* without using the O_NOCTTY option */
                !oflag.noctty;

            ptm_file->descriptor = default_Terminal();
            ptm_file->kind = CharacterFile;

            setType_Terminal(ptm_file->descriptor, PTM);
            setPTMDescId_Terminal(ptm_file->descriptor, posix_openpt_spec);

            if(control_condition)
            {
                if( POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_BEHAVIOUR ==
                    POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_SHALL_SET_CTERM )
                {
                    setControllingStatus_Terminal(ptm_file->descriptor, True_Bool3);
                    setForegroundPGroupId_Terminal(ptm_file->descriptor,
                        create_ProcessIdObj(sessionid));
                    setSessionId_Terminal(ptm_file->descriptor,
                        create_ProcessIdObj(sessionid));
                }
                else if( POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_BEHAVIOUR ==
                         POSIX_IO_TERM_OPEN_WITHOUT_NOCTTY_SHALL_NOT_SET_CTERM )
                {
                    setControllingStatus_Terminal(ptm_file->descriptor, False_Bool3);
                }
                else
                {
                    setControllingStatus_Terminal(ptm_file->descriptor, Unknown_Bool3);
                }
            }
            else
            {
                setControllingStatus_Terminal(ptm_file->descriptor, False_Bool3);
            }

            registerFileDescriptor
            (
                posix_openpt_spec,                  /* file_desc_id */
                ptm_file->fileid,                   /* file */
                ( POSIX_IO_TERM_PTM_DEVICE_FILE_NAME
                  ? create_CString((char *)POSIX_IO_TERM_PTM_DEVICE_FILE_NAME)
                  : NULL
                ), /* path */
                oflag.access_mode,                  /* access_mode */
                Blocking,                           /* block_mode */
                CharacterFile,                      /* kind */
                false,                              /* fd_cloexec */
                0,                                  /* offset */
                false,                              /* fdatasync */
                false,                              /* is64bits */
                default_TerminalDescriptor()        /* descriptor */
            );
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    ptsname - get name of the slave pseudo-terminal device

SYNOPSIS

    #include <stdlib.h>

    char *ptsname(int fildes);

DESCRIPTION

    The ptsname() function shall return the name of the slave pseudo-terminal
    device associated with a master pseudo-terminal device. The fildes
    argument is a file descriptor that refers to the master device. The
    ptsname() function shall return a pointer to a string containing the
    pathname of the corresponding slave device.

    The ptsname() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

RETURN VALUE

    Upon successful completion, ptsname() shall return a pointer to a string
    which is the name of the pseudo-terminal slave device. Upon failure,
    ptsname() shall return a null pointer. This could occur if fildes is an
    invalid file descriptor or if the slave device name does not exist in the
    file system.

ERRORS

    No errors are defined.
*/
specification
CString* ptsname_spec(CallContext context, FileDescId fildes)
{
    FileSystem *file_system = getFileSystem(context);

    bool is_ptm = isValid_FileDescId(fildes) &&
        isTerminal_FileDescId(fildes) && isPTM_FileDescId(fildes);

    CString *pts_name = is_ptm ? getPTSName_FileDescId(fildes) : NULL;

    Bool3 does_pts_exist = pts_name == NULL ? Unknown_Bool3 :
        doesFileExist_FileSystem(file_system, pts_name);

    pre
    {
        if(POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM)
        {
            /* fildes argument is a file descriptor that refers to the master */
            REQ("app.ptsname.01", "The fildes is PTM descriptor id", is_ptm);
        }
         
        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM

            NOT_PTM_COVERAGE(ptsname, "ptsname()", fildes);

#endif /* #if POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM */

        if(isWrong_FileDescId(getCPart_FileDescId(fildes)))
        {
            PTS_NAME_COVERAGE(PTSIsClosed, "PTS is closed", file_system, pts_name);
        }
        else
        {
            PTS_NAME_COVERAGE(PTSIsOpen, "PTS is open", file_system, pts_name);
        }
    }
    post
    {
        /* Upon failure, ptsname() shall return a null pointer */
        if(ptsname_spec == NULL)
        {
            /*
             * This could occur if fildes is an invalid file descriptor or if
             * the slave device name does not exist in the file system.
             */
            REQ("ptsname.02", "The fildes is invalid or PTS does not exist",
               (!is_ptm || does_pts_exist != True_Bool3));
        }
        else
        {
            /* Upon failure, ptsname() shall return a null pointer */
            REQ("ptsname.02.01", "The fildes is PTM descriptor id", is_ptm);
            REQ("ptsname.02.02", "The PTS exists in the file system",
               (does_pts_exist != False_Bool3));

            /*
             * Upon successful completion, ptsname() shall return a pointer to
             * a string which is the name of the pseudo-terminal slave device. 
             */
            REQ("ptsname.01", "ptsname() shall return PTS name",
               ((pts_name != NULL) => equals(ptsname_spec, pts_name)));
        }

        return true;
    }
}

void onPTSName(CallContext context, FileDescId fildes, CString *ptsname_spec)
{
    if(ptsname_spec != NULL)
    {
        FileSystem *file_system = getFileSystem(context);
        FileDescriptor *ptm_file_descriptor = getFileDescriptor(fildes);
        File *ptm_file = getFile_FileId(ptm_file_descriptor->file);
        File *pts_file = getFile_FileSystem(file_system, ptsname_spec);

        if(equals(getPTSName_Terminal(ptm_file->descriptor), NULL))
        {
            setPTSName_Terminal(ptm_file->descriptor, ptsname_spec);
        }

        if(pts_file == NULL)
        {
            pts_file = registerFile(file_system, ptsname_spec);
        }

        if(pts_file->descriptor == NULL)
        {
            setType_Terminal(pts_file->descriptor = default_Terminal(), PTS);
            lock_Terminal(pts_file->descriptor);

            connect_Terminals
            (
                ptm_file->descriptor,
                pts_file->descriptor,
                POSIX_IO_TERM_PT_TRANSMISSION_TIME,
                POSIX_IO_TERM_PT_TRANSMISSION_TIME
            );
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    pread, read - read from a file

    See io.file subsystem
*/
specification typedef struct ReadTTYCall ReadTTYCall = {};

ReadTTYCall* create_ReadTTYCall
(
    CallContext context,
    FileDescId fildes,
    SizeT nbyte
)
{
    return create(&type_ReadTTYCall, context, fildes, nbyte);
}

specification
void read_tty_spec(CallContext context, FileDescId fildes, SizeT nbyte)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    Terminal *terminal = is_terminal ? getTerminal_FileDescId(fildes) : NULL;

    TermIOS *termios = terminal != NULL ? getTermIOS_Terminal(terminal) : NULL;

    pre
    {
        /* [The fildes is a terminal descriptor id] */
        REQ("", "The fildes is a terminal descriptor id", is_terminal);

        /* [The termios is not NULL] */
        REQ("", "The termios is not NULL", (termios != NULL));

        /*
         * If the value of nbyte is greater than {SSIZE_MAX}, the result is
         * implementation-defined.
         */
        REQ("app.read.51", "nbyte is not greater than {SSIZE_MAX}",
           (nbyte <= (SizeT)max_SSizeT));

        /*
         * A special character is recognized not only by its value, but also by
         * its context; for example, an implementation may support multi-byte
         * sequences that have a meaning different from the meaning of the
         * bytes when considered individually. Implementations may also support
         * additional single-byte functions. These implementation-defined
         * multi-byte or single-byte functions shall be recognized only if the
         * IEXTEN flag is set; otherwise, data is received without
         * interpretation, except as required to recognize the special
         * characters defined in this section.
         */
        REQ("app.read.10", "IEXTEN flag is not set", !termios->lflag->iexten);

        /* Canonical Mode Input Processing */
        if(!isPTM_Terminal(terminal) && termios->lflag->icanon)
        {
            /*
             * If {MAX_CANON} is defined for this terminal device, it shall be
             * a limit on the number of bytes in a line. The behavior of the
             * system when this limit is exceeded is implementation-defined.
             * If {MAX_CANON} is not defined, there shall be no such limit;
             */
            REQ("app.read.11", "The {MAX_CANON} limit is not exceeded",
                !isMaxCanonLimitExceeded(context, fildes, terminal));
        }

        /*
         * If two or more special characters have the same value, the function
         * performed when that character is received is undefined.
         */
        REQ("app.read.12", "Special characters have different values", true);

        /*
         * The system may impose a limit, {MAX_INPUT}, on the number of bytes
         * that may be stored in the input queue. The behavior of the system
         * when this limit is exceeded is implementation-defined.
         *
         * If MIN is greater than {MAX_INPUT}, the response to the request is
         * undefined.
         */
        REQ("app.read.13;app.read.14", "The {MAX_INPUT} limit is not exceeded",
            !isMaxInputLimitExceeded(context, fildes, terminal));

        return true;
    }
    coverage C
    {
        AccessMode access_mode = getAccessMode_FileDescId(fildes);
        BlockMode block_mode = getBlockMode_FileDescId(fildes);
        Terminal *terminal = getTerminal_FileDescId(fildes);

        if(block_mode == Blocking)
        {
            switch(access_mode)
            {
            case ReadOnly:
                TERM_INPUT_MODE_DETAIL_COVERAGE(BLOCK_RDONLY,
                    "Blocking, read only", terminal);
                break;
            case ReadWrite:
                TERM_INPUT_MODE_DETAIL_COVERAGE(BLOCK_RDWR,
                    "Blocking, read write", terminal);
                break;
            default:
                TERM_INPUT_MODE_DETAIL_COVERAGE(BLOCK_WRONLY,
                    "Blocking, write only", terminal);
                break;
            }
        }
        else
        {
            switch(access_mode)
            {
            case ReadOnly:
                TERM_INPUT_MODE_DETAIL_COVERAGE(NONBLOCK_RDONLY,
                    "Nonblocking, read only", terminal);
                break;
            case ReadWrite:
                TERM_INPUT_MODE_DETAIL_COVERAGE(NONBLOCK_RDWR,
                    "Nonblocking, read write", terminal);
                break;
            default:
                TERM_INPUT_MODE_DETAIL_COVERAGE(NONBLOCK_WRONLY,
                    "Nonblocking, write only", terminal);
                break;
            }
        }
    }
    post
    {
        /* [The read() function shall block] */
        REQ("", "read() shall block", equals(getBlockedCall(context),
            create_ReadTTYCall(context, fildes, nbyte)));
    }
}

void onReadTTY(CallContext context, FileDescId fildes, SizeT nbyte)
{
    startBlockedCall(context, create_ReadTTYCall(context, fildes, nbyte));
    threadShouldBeRun(context);
}

specification typedef struct ReadTTYReturnType ReadTTYReturnType = {};

ReadTTYReturnType* create_ReadTTYReturnType
(
    CallContext context,
    SSizeT returned_value,
    CByteArray *buf,
    ErrorCode *errno
)
{
    return create(&type_ReadTTYReturnType, context, returned_value, buf, errno);
}

reaction
ReadTTYReturnType* read_tty_return(void)
{
    post
    {
        CallContext context = read_tty_return->context;
        SSizeT returned_value = read_tty_return->returned_value;
        CByteArray *buf = read_tty_return->buf;
        ErrorCode *errno = read_tty_return->errno;

        ReadTTYCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        SizeT nbyte = blocked_call->nbyte;

        Terminal *pre_terminal = findTerminal(@getAllTerminals(), fildes);
        Terminal *post_terminal = getTerminal_FileDescId(fildes);

        TimeInterval read_time = getReadTime_Terminal(post_terminal);

        TerminalQueue *pre_input_queue = getInputQueue_Terminal(pre_terminal);

        TermIOS *pre_termios = getTermIOS_Terminal(pre_terminal);
        AccessMode access_mode = getAccessMode_FileDescId(fildes);
        BlockMode block_mode = getBlockMode_FileDescId(fildes);

        CCT min = getControlCharacter_TermIOS(pre_termios, SUT_VMIN);
        CCT time = getControlCharacter_TermIOS(pre_termios, SUT_VTIME);

        Bool3 is_input_available_before_read_call = True_Bool3;
        Bool3 is_input_available_before_read_return = True_Bool3;
        Bool3 is_timer_expired_before_read_return = False_Bool3;

        bool is_timeout_correct = true;
                
        unsigned res = (unsigned)returned_value;

        /* [Process input queue] */
        processInputQueue_Terminal(pre_terminal);

        /*
         * The system may impose a limit, {MAX_INPUT}, on the number of bytes
         * that may be stored in the input queue. The behavior of the system
         * when this limit is exceeded is implementation-defined.
         *
         * If MIN is greater than {MAX_INPUT}, the response to the request is
         * undefined.
         */
        if(isMaxInputLimitExceeded(context, fildes, pre_terminal))
        {
            traceUserInfo("The {MAX_INPUT} limit is exceeded");
            return true;
        }

        /* Canonical Mode Input Processing */
        if(!isPTM_Terminal(pre_terminal) && pre_termios->lflag->icanon)
        {
            traceUserInfo("Canonical mode input processing");

            /*
             * This means that a read request shall not return until an entire
             * line has been typed or a signal has been received.
             */
            is_input_available_before_read_call =
                containsLineAtTime_Terminal(pre_terminal, read_time.minMark);

            is_input_available_before_read_return =
                containsLineAtTime_Terminal(pre_terminal, read_time.maxMark);

            /*
             * If {MAX_CANON} is defined for this terminal device, it shall be
             * a limit on the number of bytes in a line. The behavior of the
             * system when this limit is exceeded is implementation-defined.
             * If {MAX_CANON} is not defined, there shall be no such limit;
             */
            if(isMaxCanonLimitExceeded(context, fildes, pre_terminal))
            {
                traceUserInfo("The {MAX_CANON} limit is exceeded");
                return true;
            }
        }
        /* Non-Canonical Mode Input Processing / Case A: MIN>0, TIME>0 */
        else if(!isPTM_Terminal(pre_terminal) && min > 0 && time > 0)
        {
            unsigned i, size;
            unsigned minimum = (unsigned)(min < nbyte ? min : nbyte);

            TimeMark max_time = minTimeMark;
            TimeMark min_time = maxTimeMark;

            traceUserInfo("Non-Canonical Mode Input Processing / Case A");

            /*
             * If MIN bytes are received before the inter-byte timer expires
             * (remember that the timer is reset upon receipt of each byte),
             * the read shall be satisfied.
             */
            is_input_available_before_read_call = containsBytesAtTime_Terminal
                (pre_terminal, read_time.minMark, minimum);

            is_input_available_before_read_return = containsBytesAtTime_Terminal
                (pre_terminal, read_time.maxMark, minimum);

            is_timeout_correct = true;

            is_timer_expired_before_read_return = False_Bool3;

            size = size_TerminalQueue(pre_input_queue);
            for(i = 0; i < size; i++)
            {
                ByteT byte = getByte_TerminalQueue(pre_input_queue, i);
                TimeInterval item_time = getTime_TerminalQueue(pre_input_queue, i);

                if(!POSIX_IO_TERM_CONTROL_CHARACTERS_MUST_RESET_TIMER)
                {
                    if(isDiscardedControlCharacter_TermIOS(pre_termios, byte))
                        continue;
                }

                if(max_time.timemark == minTimeMark.timemark)
                {
                    if(item_time.minMark.timemark > read_time.minMark.timemark)
                        min_time = item_time.minMark;
                    else
                        min_time = read_time.minMark;

                    if(item_time.maxMark.timemark < read_time.minMark.timemark)
                        max_time = read_time.minMark;
                    else
                        max_time = item_time.maxMark;
                }
                else
                {
                    if(item_time.maxMark.timemark < read_time.minMark.timemark)
                        continue;

                    if(max_time.timemark < item_time.minMark.timemark)
                    {
                        is_timer_expired_before_read_return = True_Bool3;
                        break;
                    }

                    if(min_time.timemark < item_time.maxMark.timemark)
                        is_timer_expired_before_read_return = Unknown_Bool3;

                    min_time = item_time.minMark;                        
                    max_time = item_time.maxMark;
                }
                
                min_time.timemark += time * 100000000 - POSIX_IO_TERM_TTY_TIMER_ACCURACY;
                max_time.timemark += time * 100000000 + POSIX_IO_TERM_TTY_TIMER_ACCURACY;
            }

            if(size == 0)
            {
                is_timer_expired_before_read_return = False_Bool3;
            }
            else if(is_timer_expired_before_read_return == True_Bool3)
            {
                is_timeout_correct =
                    read_time.maxMark.timemark >= min_time.timemark &&
                    read_time.maxMark.timemark <= max_time.timemark;
            }
            else if(is_timer_expired_before_read_return == False_Bool3)
            {
                is_timer_expired_before_read_return =
                    not_Bool3(is_input_available_before_read_return);

                is_timeout_correct = read_time.maxMark.timemark <= max_time.timemark;
            }
            else
            {
                if(is_input_available_before_read_return == False_Bool3)
                    is_timer_expired_before_read_return = True_Bool3;
                else
                    is_timer_expired_before_read_return = Unknown_Bool3;

                is_timeout_correct = read_time.maxMark.timemark <= max_time.timemark;
            }
        }
        /* Non-Canonical Mode Input Processing / Case B: MIN>0, TIME=0 */
        else if(!isPTM_Terminal(pre_terminal) && min > 0 && time == 0)
        {
            unsigned minimum = (unsigned)(min < nbyte ? min : nbyte);

            traceUserInfo("Non-Canonical Mode Input Processing / Case B");

            /* The pending read shall block until MIN bytes are received */
            is_input_available_before_read_call = containsBytesAtTime_Terminal
                (pre_terminal, read_time.minMark, minimum);

            is_input_available_before_read_return = containsBytesAtTime_Terminal
                (pre_terminal, read_time.maxMark, minimum);
        }
        /* Non-Canonical Mode Input Processing / Case C: MIN=0, TIME>0 */
        else if(!isPTM_Terminal(pre_terminal) && min == 0 && time > 0)
        {
            TimeMark min_time, max_time;
         
            traceUserInfo("Non-Canonical Mode Input Processing / Case C");

            /*
             * A read shall be satisfied as soon as a single byte is received
             * or the read timer expires.
             */
            is_input_available_before_read_call = containsBytesAtTime_Terminal
                (pre_terminal, read_time.minMark, nbyte != 0 ? 1 : 0);

            is_input_available_before_read_return = containsBytesAtTime_Terminal
                (pre_terminal, read_time.maxMark, nbyte != 0 ? 1 : 0);

            min_time.timemark =
                /* [Start time of the read() call] */
                read_time.minMark.timemark +
                /* [Timer expiration time in nanoseconds] */
                time /* [0.1 s] */ * 100000000 /* [1 ns] */ -
                /* [Terminal timer accuracy in nanoseconds] */
                POSIX_IO_TERM_TTY_TIMER_ACCURACY;

            max_time.timemark =
                /* [Start time of the read() call] */
                read_time.minMark.timemark +
                /* [Timer expiration time in nanoseconds] */
                time /* [0.1 s] */ * 100000000 /* [1 ns] */ +
                /* [Terminal timer accuracy in nanoseconds] */
                POSIX_IO_TERM_TTY_TIMER_ACCURACY;

            if(is_input_available_before_read_return == False_Bool3)
            {
                traceFormattedUserInfo("read() call was blocked %I64u msecs",
                    (read_time.maxMark.timemark - read_time.minMark.timemark) / 1000000);

                is_timer_expired_before_read_return = True_Bool3;

                is_timeout_correct = 
                    read_time.maxMark.timemark >= min_time.timemark &&
                    read_time.maxMark.timemark <= max_time.timemark;
            }
            else
            {
                is_timer_expired_before_read_return =
                    is_input_available_before_read_return == True_Bool3 ?
                    False_Bool3 : Unknown_Bool3;

                is_timeout_correct =
                    read_time.maxMark.timemark <= max_time.timemark;
            }
        }
        /* Non-Canonical Mode Input Processing / Case D: MIN=0, TIME=0 */
        else
        {
            traceUserInfo("Non-Canonical Mode Input Processing / Case D");
        }

        /*
         * [On error,] the functions shall return -1 and set errno to indicate
         * the error.
         */
        ERROR_BEGIN(POSIX_READ, "read.41.02", (returned_value == -1), *errno);

            /*
             * The read() and [XSI] pread() functions shall fail
             * if:
             *
             * [EAGAIN]
             *
             * The O_NONBLOCK flag is set for the file descriptor and the
             * thread would be delayed.
             */

            /*
             * Also, if no data is available, read() may either return 0, or
             * return -1 with errno set to [EAGAIN].
             */
            ERROR_MAY(POSIX_READ, EAGAIN, "read.42.01",
            (
                !isDisconnected_Terminal(pre_terminal) &&
                 block_mode == Nonblocking &&
                 is_input_available_before_read_call != True_Bool3
            ));

            /*
             * The read() and [XSI] pread() functions shall fail
             * if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor open for
             * reading.
             */
            ERROR_SHALL(POSIX_READ, EBADF, "read.42.02",
            (
                !isDisconnected_Terminal(pre_terminal) &&
                 access_mode == WriteOnly
            ));

            /*
             * The read() and [XSI] pread() functions shall fail
             * if:
             *
             * [EINTR]
             *
             * The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_READ, EINTR, "read.42.04",
            (
                !isDisconnected_Terminal(pre_terminal) &&
                 isBlockedCallInterruptedBySignal(context)
            ));

            /*
             * The read() and [XSI] pread() functions shall fail
             * if:
             *
             * [EIO]
             *
             * The process is a member of a background process attempting to
             * read from its controlling terminal, the process is ignoring or
             * blocking the SIGTTIN signal, or the process group is orphaned.
             * This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_UNCHECKABLE(POSIX_READ, EIO, "read.42.07",
                "don't know how to check");

            /*
             * The read() and [XSI] pread() functions may fail
             * if:
             *
             * [EIO]
             *
             * A physical I/O error has occurred.
             */
            ERROR_UNCHECKABLE(POSIX_READ, EIO, "read.44.01",
                "don't know how to check");

            /*
             * The read() and [XSI] pread() functions may fail
             * if:
             *
             * [ENOBUFS]
             *
             * Insufficient resources were available in the system to perform
             * the operation.
             */
            ERROR_UNCHECKABLE(POSIX_READ, ENOBUFS, "read.44.02",
                "don't know how to check");

            /*
             * The read() and [XSI] pread() functions may fail
             * if:
             *
             * [ENOMEM]
             *
             * Insufficient memory was available to fulfill the request.
             */
            ERROR_UNCHECKABLE(POSIX_READ, ENOMEM, "read.44.03",
                "don't know how to check");

            /*
             * The read() and [XSI] pread() functions may fail
             * if:
             *
             * [ENXIO]
             *
             * A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_UNCHECKABLE(POSIX_READ, ENXIO, "read.44.04",
                "don't know how to check");

        ERROR_END();

        /*
         * Upon successful completion, read() and pread() shall return a
         * non-negative integer indicating the number of bytes actually read.
         */
        REQ("read.13.01", "On success, read() shall return a non-negative integer",
           (returned_value >= 0));
        
        if(isDisconnected_Terminal(pre_terminal))
        {
            /*
             * Any subsequent read from the terminal device shall return the
             * value of zero, indicating end-of-file.
             */
            REQ("read.55", "read() shall return the value of zero", (res == 0));

            return true;
        }

        /* [The read() shall return the number of bytes] */
        REQ("", "read() shall return the number of bytes", (res == size_CByteArray(buf)));

        /* [The read() shall not return more than nbytes] */
        REQ("", "read() shall not return more than nbytes", (res <= nbyte));

        /* [The read() shall return input prefix] */
        REQ("read.66;read.67;read.68;read.69;read.70;read.71;"
            "read.72;read.73;read.74;read.75;read.76;read.77",
            "read() shall return input prefix", isInputPrefix_Terminal(pre_terminal, buf));

        /* If the O_NONBLOCK flag is set */
        if(block_mode == Nonblocking)
        {
            /*
             * The read() shall complete successfully, having read as much data as
             * possible, and shall return the number of bytes it was able to read.
             */
            REQ("", "Input queue contained returned bytes at the time of call",
            (
                containsBytesAtTime_Terminal
                    (pre_terminal, read_time.minMark, res) != False_Bool3
            ));

            REQ("", "Input queue did not contain more bytes at the time of call",
            (
                (res < nbyte) => (containsBytesAtTime_Terminal
                    (pre_terminal, read_time.minMark, res + 1) != True_Bool3)
            ));
        }
        /* If the O_NONBLOCK flag is clear */
        else
        {
            /* [Input queue contained at least 1 byte at the time of call] */
            Bool3 contains_1     =
                containsBytesAtTime_Terminal(pre_terminal, read_time.minMark, 1U);                                                         

            /* [Input queue contained at least nbyte bytes] */
            Bool3 contains_nbyte =
                containsBytesAtTime_Terminal(pre_terminal, read_time.minMark, (unsigned)nbyte);

            /* [Input queue contained at least MIN bytes] */
            Bool3 contains_min   =
                containsBytesAtTime_Terminal(pre_terminal, read_time.minMark, (unsigned)min);

            /* [Input queue contained at least returned number bytes] */
            Bool3 contains_res   =
                containsBytesAtTime_Terminal(pre_terminal, read_time.minMark, res);
            
            /* [Input queue contained more than returned number of bytes] */
            Bool3 contains_res_1 =
                containsBytesAtTime_Terminal(pre_terminal, read_time.minMark, res + 1);

            SizeT minimum = min < nbyte ? min : nbyte;

            /* [Input queue contained returned number of bytes] */
            REQ("", "Input queue contained returned number of bytes",
            (
                containsBytesAtTime_Terminal
                    (pre_terminal, read_time.maxMark, res) != False_Bool3
            ));

            /*
             * If the O_NONBLOCK flag is clear, then the read request shall be
             * blocked until data is available or a signal has been received.
             */
            REQ("read.79", "read() shall be blocked "
                "until data is available or timer is expired",
            (
                is_input_available_before_read_return != False_Bool3 ||
                is_timer_expired_before_read_return != False_Bool3
            ));

            if( getTSTimeModel()!=NotUseTSTime)
            {
                /* [The read() shall be blocked during correct time] */
                REQ("", "read() shall be blocked during correct time", is_timeout_correct);
            }

            /* Canonical Mode Input Processing */
            if(!isPTM_Terminal(pre_terminal) && pre_termios->lflag->icanon)
            {
                int line_size = getLineSize_Terminal(pre_terminal);
 
                if(res < nbyte)
                {
                    /*
                     * Also, no matter how many bytes are requested in the
                     * read() call, at most one line shall be returned.
                     */
                    REQ("read.80.02", "read() shall return a line",
                        (res == (unsigned)line_size));
                }
                else
                {
                    /*
                     * Also, no matter how many bytes are requested in the
                     * read() call, at most one line shall be returned.
                     */
                    REQ("read.80.02", "read() shall return a line or a line prefix",
                       (line_size < 0 || res <= (unsigned)line_size));
                }
            }
            /* Non-Canonical Mode Input Processing / Case A: MIN>0, TIME>0 */
            else if(!isPTM_Terminal(pre_terminal) && min > 0 && time > 0)
            {
                if(contains_nbyte == True_Bool3)
                {
                    REQ("", "read() shall be satisfied", (res == nbyte));
                }
                else
                {
                    /*
                     * If MIN bytes are received before the inter-byte timer
                     * expires (remember that the timer is reset upon receipt
                     * of each byte)
                     */
                    if(contains_min == True_Bool3)
                    {
                        /* the read shall be satisfied */
                        REQ("read.82.03", "If input queue contains at least MIN bytes, "
                            "read() shall return all bytes recevied to that point",
                        (
                            res >= min &&
                            contains_res != False_Bool3 &&
                            contains_res_1 != True_Bool3
                        ));
                    }
                    else
                    {
                        /*
                         * If the timer expires before MIN bytes are received,
                         * the characters received to that point shall be
                         * returned to the user.
                         */
                        REQ("read.82.04", "If read() < min(MIN,nbytes), "
                            "timer is expired before bytes are received",
                        (
                            (res < minimum) =>
                                (is_timer_expired_before_read_return != False_Bool3)
                        ));

                        REQ("read.82.04", "If read() >= min(MIN,nbytes), "
                            "timer is not expired before bytes are received",
                        (
                            (res >= minimum) =>
                                (is_timer_expired_before_read_return != True_Bool3)
                        ));

                        /*
                         * if TIME expires at least one byte shall be returned
                         * because the timer would not have been enabled unless
                         * a byte was received.
                         */
                        REQ("read.82.05", "If timer expires, read() >= 1",
                        (
                            (is_timer_expired_before_read_return == True_Bool3) =>
                                (res >= 1)
                        ));
                    }
                }
            }
            /* Non-Canonical Mode Input Processing / Case B: MIN>0, TIME=0 */
            else if(!isPTM_Terminal(pre_terminal) && min > 0 && time == 0)
            {
                if(contains_nbyte == True_Bool3 || nbyte <= min)
                {
                    REQ("", "read() shall be satisfied", (res == nbyte));
                }
                else
                {
                    /*
                     * A pending read shall not be satisfied until MIN bytes
                     * are received (that is, the pending read shall block
                     * until MIN bytes are received), or a signal is received.
                     */
                    if(contains_min == True_Bool3)
                    {
                        REQ("read.83.01", "If input queue contains MIN bytes, "
                            "read() shall return all bytes recevied to than point",
                        (
                            res >= min &&
                            contains_res != False_Bool3 &&
                            contains_res_1 != True_Bool3
                        ));
                    }
                    else
                    {
                        REQ("read.83.01", "read() shall not be satisfied "
                            "until MIN bytes are received", (res >= min));
                    }
                }
            }
            /* Non-Canonical Mode Input Processing / Case C: MIN=0, TIME>0 */
            else if(!isPTM_Terminal(pre_terminal) && min == 0 && time > 0)
            {
                if(contains_nbyte == True_Bool3)
                {
                    REQ("", "read() shall be satisfied", (res == nbyte));
                }
                else
                {
                    if(contains_1 == True_Bool3)
                    {
                        REQ("", "If input queue contains at least 1 byte, "
                            "read() shall return all bytes recevied to that point",
                        (
                            res >= 1 &&
                            contains_res != False_Bool3 &&
                            contains_res_1 != True_Bool3
                        ));
                    }
                    else
                    {
                        /*
                         * A read shall be satisfied as soon as a single byte
                         * is received or the read timer expires.
                         */

                        /* if the timer expires, no bytes shall be returned */
                        REQ("read.84.02.01", "If timer expires, read() == 0",
                        (
                            (is_timer_expired_before_read_return == True_Bool3) =>
                                (res == 0)
                        ));

                        /*
                         * If the timer does not expire, the only way the read
                         * can be satisfied is if a byte is received.
                         */
                        REQ("read.84.02.02", "If timer does not expire, read() >= 1",
                        (
                            (is_timer_expired_before_read_return == False_Bool3) =>
                                (res >= 1)
                        ));

                        REQ("read.84.02", "If read() returns zero, "
                            "timer is expired before bytes are received",
                        (
                            (res == 0) =>
                                (is_timer_expired_before_read_return != False_Bool3)
                        ));

                        REQ("read.84.02", "If read() does not return zero, "
                            "timer is not expired before bytes are received",
                        (
                            (res >= 1) =>
                                (is_timer_expired_before_read_return != True_Bool3)
                        ));
                    }
                }
            }
            /* Non-Canonical Mode Input Processing / Case D: MIN=0, TIME=0 */
            else
            {
                REQ("read.85", "read() shall return all bytes recevied to that point",
                (
                    contains_res != False_Bool3 &&
                    contains_res_1 != True_Bool3
                ));
            }
        }

        return true;
    }
}

void onReadTTYReturn(CallContext context, SSizeT read_tty_return,
                     CByteArray *buf, ErrorCode *errno, TimeInterval time)
{
    ReadTTYCall *blocked_call = finishBlockedCall(context);
    FileDescId fildes = blocked_call->fildes;

    Terminal *terminal = getTerminal_FileDescId(fildes);

    traceFormattedUserInfo("read=%I64d", read_tty_return);

    if(read_tty_return >= 0)
    {
        unsigned res = (unsigned)read_tty_return;

        setReadTime_Terminal(terminal, time);
        processInputQueue_Terminal(terminal);
        read_Terminal(terminal, buf, res);
        echo_Terminal(terminal, buf, res);
        processOutputQueue_Terminal(terminal);
        transmit_Terminal(terminal, time.minMark);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcdrain - wait for transmission of output

SYNOPSIS

    #include <termios.h>

    int tcdrain(int fildes);

DESCRIPTION

    The tcdrain() function shall block until all output written to the object
    referred to by fildes is transmitted. The fildes argument is an open file
    descriptor associated with a terminal.

    Any attempts to use tcdrain() from a process which is a member of a
    background process group on a fildes associated with its controlling
    terminal, shall cause the process group to be sent a SIGTTOU signal. If the
    calling process is blocking or ignoring SIGTTOU signals, the process shall
    be allowed to perform the operation, and no signal is sent.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcdrain() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [EINTR]
        A signal interrupted tcdrain().
    [ENOTTY]
        The file associated with fildes is not a terminal.

    The tcdrain() function may fail if:

    [EIO]
        The process group of the writing process is orphaned, and the writing
        process is not ignoring or blocking SIGTTOU.
*/
specification typedef struct TCDrainCall TCDrainCall = {};

TCDrainCall* create_TCDrainCall(CallContext context, FileDescId fildes)
{
    return create(&type_TCDrainCall, context, fildes);
}

specification
void tcdrain_spec(CallContext context, FileDescId fildes)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    coverage C
    {
        FILE_TYPE_COVERAGE(tcdrain, "tcdrain()", fildes);
    }
    post
    {
        /* [The tcdrain() function shall block] */
        REQ("", "tcdrain() shall block", equals(getBlockedCall(context),
            create_TCDrainCall(context, fildes)));

        /*
         * Any attempts to use tcdrain() from a process which is a member of a
         * background process group on a fildes associated with its controlling
         * terminal, shall cause the process group to be sent a SIGTTOU signal.
         * If the calling process is blocking or ignoring SIGTTOU signals, the
         * process shall be allowed to perform the operation, and no signal is
         * sent.
         */
        REQ("?tcdrain.02", "SIGTTOU signal should be send to a process group",
           ((control_status == True_Bool3 && fpgroupid != NULL && termios != NULL) =>
            (signalShouldBeSentToProcessGroup(pgroupid, SUT_SIGTTOU) == signal_condition)));

        return true;
    }
}

void onTCDrain(CallContext context, FileDescId fildes)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    startBlockedCall(context, create_TCDrainCall(context, fildes));
    threadShouldBeRun(context);

    if(signal_condition)
    {
        sendSignalToProcessGroup(pgroupid, SUT_SIGTTOU);
    }
}

reaction TCReturnType* tcdrain_return(void)
{
    /*
     * This postcondition assumes that a set of open file descriptors, a
     * controlling terminal of the calling process and signal handlers do not
     * change during the tcdrain() function call.
     */
    post
    {
        TerminalQueue *output_queue;

        CallContext context = tcdrain_return->context;
        IntT returned_value = tcdrain_return->returned_value;
        ErrorCode *errno = tcdrain_return->errno;

        TCDrainCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

        bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCDRAIN, "tcdrain.04", (returned_value == -1), *errno);

            /*
             * The tcdrain() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCDRAIN, EBADF, "tcdrain.05.01",
                !isValid_FileDescId(fildes));

            /*
             * The tcdrain() function shall fail if:
             *
             * [EINTR]
             *
             * A signal interrupted tcdrain().
             */
            ERROR_SHALL(POSIX_TCDRAIN, EINTR, "tcdrain.05.02",
                isBlockedCallInterruptedBySignal(context));

            /*
             * The tcdrain() function shall fail if:
             *
             * [ENOTTY]
             *
             * The file associated with fildes is not a terminal.
             */
            ERROR_SHALL(POSIX_TCDRAIN, ENOTTY, "tcdrain.05.03", !is_terminal);

            /*
             * The tcdrain() function may fail if:
             *
             * [EIO]
             *
             * The process group of the writing process is orphaned, and the
             * writing process is not ignoring or blocking SIGTTOU.
             */
            ERROR_MAY3(POSIX_TCDRAIN, EIO, "tcdrain.06.01",
            (
                getSignalHandler_ProcessId(processid, SUT_SIGTTOU) == SUT_SIG_IGN ||
                isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) ?
                    False_Bool3 : isOrphanedProcessGroupId(pgroupid)
            ));

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("tcdrain.03", "On success, tcdrain() shall return 0", (returned_value == 0));
        
        output_queue = getOutputQueue_Terminal(getTerminal_FileDescId(fildes));

        /*
         * The tcdrain() function shall block until all output written to the
         * object referred to by fildes is transmitted.
         */
        REQ("?tcdrain.01", "tcdrain() shall block until all output is transmitted",
           ((output_queue != NULL) => isEmpty_TerminalQueue(output_queue)));

        return true;
    }
}

void onTCDrainReturn(CallContext context, IntT tcdrain_return, ErrorCode *errno)
{
    TCDrainCall *blocked_call = finishBlockedCall(context);

    if(tcdrain_return == 0)
    {
        FileDescId fildes = blocked_call->fildes;
        Terminal *terminal = getTerminal_FileDescId(fildes);

        /*
         * This specification assumes that all output is transmitted during the
         * write(), tcflow() or tcsendbreak function calls, so the output queue
         * is always empty here.
         */
        clear_TerminalQueue(getOutputQueue_Terminal(terminal));
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcflow - suspend or restart the transmission or reception of data

SYNOPSIS

    #include <termios.h>

    int tcflow(int fildes, int action);

DESCRIPTION

    The tcflow() function shall suspend or restart transmission or reception of
    data on the object referred to by fildes, depending on the value of action.
    The fildes argument is an open file descriptor associated with a terminal.

        * If action is TCOOFF, output shall be suspended.

        * If action is TCOON, suspended output shall be restarted.

        * If action is TCIOFF, the system shall transmit a STOP character,
          which is intended to cause the terminal device to stop transmitting
          data to the system.

        * If action is TCION, the system shall transmit a START character,
          which is intended to cause the terminal device to start transmitting
          data to the system.

    The default on the opening of a terminal file is that neither its input nor
    its output are suspended.

    Attempts to use tcflow() from a process which is a member of a background
    process group on a fildes associated with its controlling terminal, shall
    cause the process group to be sent a SIGTTOU signal. If the calling process
    is blocking or ignoring SIGTTOU signals, the process shall be allowed to
    perform the operation, and no signal is sent.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcflow() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [EINVAL]
        The action argument is not a supported value.
    [ENOTTY]
        The file associated with fildes is not a terminal.

    The tcflow() function may fail if:

    [EIO]
        The process group of the writing process is orphaned, and the writing
        process is not ignoring or blocking SIGTTOU.
*/
specification typedef struct TCFlowCall TCFlowCall = {};

TCFlowCall* create_TCFlowCall
(
    CallContext context,
    FileDescId fildes,
    Action action
)
{
    return create(&type_TCFlowCall, context, fildes, action);
}

specification
void tcflow_spec(CallContext context, FileDescId fildes, Action action)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    coverage C
    {
        switch(action)
        {
        case SUT_TCOOFF:
            FILE_TYPE_COVERAGE(TCOOFF, "action is TCOOFF", fildes);
            break;
        case SUT_TCOON:
            FILE_TYPE_COVERAGE(TCOON, "action is TCOOFF", fildes);
            break;
        case SUT_TCIOFF:
            FILE_TYPE_COVERAGE(TCIOFF, "action is TCOOFF", fildes);
            break;
        case SUT_TCION:
            FILE_TYPE_COVERAGE(TCION, "action is TCOOFF", fildes);
            break;
        default:
            FILE_TYPE_COVERAGE(UnknownAction, "action is unknown", fildes);
            break;
        }
    }
    post
    {
        /* [The tcflow() function shall block]*/
        REQ("", "tcflow() shall block", equals(getBlockedCall(context),
            create_TCFlowCall(context, fildes, action)));

        /*
         * Attempts to use tcflow() from a process which is a member of a
         * background process group on a fildes associated with its controlling
         * terminal, shall cause the process group to be sent a SIGTTOU signal.
         * If the calling process is blocking or ignoring SIGTTOU signals, the
         * process shall be allowed to perform the operation, and no signal is
         * sent.
         */
        REQ("?tcflow.02", "SIGTTOU signal should be send to a process group",
           ((control_status == True_Bool3 && fpgroupid != NULL && termios != NULL) =>
            (signalShouldBeSentToProcessGroup(pgroupid, SUT_SIGTTOU) == signal_condition)));
        
        return true;
    }
}

void onTCFlow(CallContext context, FileDescId fildes, Action action)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    startBlockedCall(context, create_TCFlowCall(context, fildes, action));
    threadShouldBeRun(context);

    if(signal_condition)
    {
        sendSignalToProcessGroup(pgroupid, SUT_SIGTTOU);
    }
}

specification typedef struct TCReturnType TCReturnType = {};

TCReturnType* create_TCReturnType(CallContext context, IntT returned_value,
                                  ErrorCode *errno)
{
    return create(&type_TCReturnType, context, returned_value, errno);
}

reaction
TCReturnType* tcflow_return(void)
{
    /*
     * This postcondition assumes that a set of open file descriptors, a
     * controlling terminal of the calling process and signal handlers do not
     * change during the tcflow() function call.
     */
    post
    {
        Terminal *terminal;
        TermIOS *termios;
        TerminalQueue *output_queue;

        CallContext context = tcflow_return->context;
        IntT returned_value = tcflow_return->returned_value;
        ErrorCode *errno = tcflow_return->errno;

        TCFlowCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        Action action = blocked_call->action;

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

        bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCFLOW, "tcflow.04",  (returned_value == -1), *errno);

            /*
             * The tcflow() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCFLOW, EBADF, "tcflow.05.01",
                !isValid_FileDescId(fildes));

            /*
             * The tcflow() function shall fail if:
             *
             * [EINVAL]
             *
             * The action argument is not a supported value.
             */
            ERROR_SHALL(POSIX_TCFLOW, EINVAL, "tcflow.05.02",
            (
                action != SUT_TCOOFF &&
                action != SUT_TCOON  &&
                action != SUT_TCIOFF &&
                action != SUT_TCION
            ));

            /*
             * The tcflow() function shall fail if:
             *
             * [ENOTTY]
             *
             * The file associated with fildes is not a terminal.
             */
            ERROR_SHALL(POSIX_TCFLOW, ENOTTY, "tcflow.05.03", !is_terminal);

            /*
             * The tcflow() function may fail if:
             *
             * [EIO]
             *
             * The process group of the writing process is orphaned, and the
             * writing process is not ignoring or blocking SIGTTOU.
             */
            ERROR_MAY3(POSIX_TCFLOW, EIO, "tcflow.06.01",
            (
                getSignalHandler_ProcessId(processid, SUT_SIGTTOU) == SUT_SIG_IGN ||
                isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) ?
                    False_Bool3 : isOrphanedProcessGroupId(pgroupid)
            ));

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("tcflow.03", "On success, tcflow() shall return 0", (returned_value == 0));

        terminal = getTerminal_FileDescId(fildes);

        /* If action is TCOOFF, output shall be suspended */
        REQ("?tcflow.01.01", "If action is TCOOFF, output shall be suspended",
           ((action == SUT_TCOOFF) => isOutputSuspended_Terminal(terminal)));

        /* If action is TCOON, suspended output shall be restarted */
        REQ("?tcflow.01.02", "If action is TCOON, output shall be restarted",
           ((action == SUT_TCOON) => !isOutputSuspended_Terminal(terminal)));

        /* 
         * If action is TCIOFF, the system shall transmit a STOP character,
         * which is intended to cause the terminal device to stop
         * transmitting data to the system.
         */
        REQ("tcflow.01.03", "If action is SUT_TCIOFF, input shall be suspended",
           ((action == SUT_TCIOFF) => true /* [STOP character is transmitted] */));

        /* 
         * If action is TCION, the system shall transmit a START character,
         * which is intended to cause the terminal device to start
         * transmitting data to the system.
         */
        REQ("tcflow.01.04", "If action is SUT_TCION, input shall be restarted",
           ((action == SUT_TCION) => true /* [START character is transmitted] */));

        return true;
    }
}

void onTCFlowReturn(CallContext context, IntT tcflow_return, ErrorCode *errno,
                    TimeInterval time)
{
    TCFlowCall *blocked_call = finishBlockedCall(context);

    if(tcflow_return == 0)
    {
        FileDescId fildes = blocked_call->fildes;
        Action action = blocked_call->action;
        Terminal *terminal = getTerminal_FileDescId(fildes);
        TermIOS *termios = getTermIOS_Terminal(terminal);
        TerminalQueue *output_queue = getOutputQueue_Terminal(terminal);

        if(action == SUT_TCOOFF)
        {
            suspendOutput_Terminal(terminal);
        }
        else if(action == SUT_TCOON)
        {
            restartOutput_Terminal(terminal);
        }
        else if(termios != NULL)
        {
            if(action == SUT_TCIOFF)
            {
                CCT stop = getControlCharacter_TermIOS(termios, SUT_VSTOP);

                appendByte_TerminalQueue(output_queue, stop, overallTimeInterval);
                transmit_Terminal(terminal, time.minMark);
            }
            else if(action == SUT_TCION)
            {
                CCT start = getControlCharacter_TermIOS(termios, SUT_VSTART);

                appendByte_TerminalQueue(output_queue, start, overallTimeInterval);
                transmit_Terminal(terminal, time.minMark);
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcflush - flush non-transmitted output data, non-read input data, or both

SYNOPSIS

    #include <termios.h>

    int tcflush(int fildes, int queue_selector);

DESCRIPTION

    Upon successful completion, tcflush() shall discard data written to the
    object referred to by fildes (an open file descriptor associated with a
    terminal) but not transmitted, or data received but not read, depending on
    the value of queue_selector:

        * If queue_selector is TCIFLUSH, it shall flush data received but not
          read.

        * If queue_selector is TCOFLUSH, it shall flush data written but not
          transmitted.

        * If queue_selector is TCIOFLUSH, it shall flush both data received but
          not read and data written but not transmitted.

    Attempts to use tcflush() from a process which is a member of a background
    process group on a fildes associated with its controlling terminal shall
    cause the process group to be sent a SIGTTOU signal. If the calling process
    is blocking or ignoring SIGTTOU signals, the process shall be allowed to
    perform the operation, and no signal is sent.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcflush() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [EINVAL]
        The queue_selector argument is not a supported value.
    [ENOTTY]
        The file associated with fildes is not a terminal.

    The tcflush() function may fail if:

    [EIO]
        The process group of the writing process is orphaned, and the writing
        process is not ignoring or blocking SIGTTOU.
*/
specification typedef struct TCFlushCall TCFlushCall = {};

TCFlushCall* create_TCFlushCall
(
    CallContext context,
    FileDescId fildes,
    QueueSelector queue_selector
)
{
    return create(&type_TCFlushCall, context, fildes, queue_selector);
}

specification
void tcflush_spec(CallContext context, FileDescId fildes, QueueSelector queue_selector)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    coverage C
    {
        switch(queue_selector)
        {
        case SUT_TCIFLUSH:
            FILE_TYPE_COVERAGE(TCIFLUSH, "Selector is TCIFLUSH", fildes);
            break;
        case SUT_TCOFLUSH:
            FILE_TYPE_COVERAGE(TCOFLUSH, "Selector is TCIFLUSH", fildes);
            break;
        case SUT_TCIOFLUSH:
            FILE_TYPE_COVERAGE(TCIOFLUSH, "Selector is TCIOFLUSH", fildes);
            break;
        default:
            FILE_TYPE_COVERAGE(UnknownSelector, "Selector is unknown", fildes);
            break;
        }
    }
    post
    {
        /* [The tcflush() function shall block] */
        REQ("", "tcflush() shall block", equals(getBlockedCall(context),
            create_TCFlushCall(context, fildes, queue_selector)));

        /*
         * Attempts to use tcflush() from a process which is a member of a
         * background process group on a fildes associated with its controlling
         * terminal shall cause the process group to be sent a SIGTTOU signal.
         * If the calling process is blocking or ignoring SIGTTOU signals, the
         * process shall be allowed to perform the operation, and no signal is
         * sent.
         */
        REQ("?tcflush.02", "SIGTTOU signal should be send to a process group",
           ((control_status == True_Bool3 && fpgroupid != NULL && termios != NULL) =>
            (signalShouldBeSentToProcessGroup(pgroupid, SUT_SIGTTOU) == signal_condition)));

        return true;
    }
}

void onTCFlush(CallContext context, FileDescId fildes, QueueSelector queue_selector)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    startBlockedCall(context, create_TCFlushCall(context, fildes, queue_selector));
    threadShouldBeRun(context);

    if(signal_condition)
    {
        sendSignalToProcessGroup(pgroupid, SUT_SIGTTOU);
    }
}

reaction
TCReturnType* tcflush_return(void)
{
    /*
     * This postcondition assumes that a set of open file descriptors, a
     * controlling terminal of the calling process and signal handlers do not
     * change during the tcflush() function call.
     */
    post
    {
        Terminal *terminal;
        TerminalQueue *input_queue, *output_queue;

        CallContext context = tcflush_return->context;
        IntT returned_value = tcflush_return->returned_value;
        ErrorCode *errno = tcflush_return->errno;

        TCFlushCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        QueueSelector queue_selector = blocked_call->queue_selector;

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

        bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCFLUSH, "tcflush.04", (returned_value == -1), *errno);

            /*
             * The tcflush() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCFLUSH, EBADF, "tcflush.05.01",
                !isValid_FileDescId(fildes));

            /*
             * The tcflush() function shall fail if:
             *
             * [EINVAL]
             *
             * The queue_selector argument is not a supported value.
             */
            ERROR_SHALL(POSIX_TCFLUSH, EINVAL, "tcflush.05.02",
            (
                queue_selector != SUT_TCIFLUSH  &&
                queue_selector != SUT_TCOFLUSH  &&
                queue_selector != SUT_TCIOFLUSH
            ));

            /*
             * The tcflush() function shall fail if:
             *
             * [ENOTTY]
             *
             * The file associated with fildes is not a terminal.
             */
            ERROR_SHALL(POSIX_TCFLUSH, ENOTTY, "tcflush.05.03", !is_terminal);

            /*
             * The tcflush() function may fail if:
             *
             * [EIO]
             *
             * The process group of the writing process is orphaned, and the
             * writing process is not ignoring or blocking SIGTTOU.
             */
            ERROR_MAY3(POSIX_TCFLUSH, EIO, "tcflush.06.01",
            (
                getSignalHandler_ProcessId(processid, SUT_SIGTTOU) == SUT_SIG_IGN ||
                isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) ?
                    False_Bool3 : isOrphanedProcessGroupId(pgroupid)
            ));

        ERROR_END();
        
        /* Upon successful completion, 0 shall be returned */
        REQ("tcflush.03", "On success, tcflush() shall return 0", (returned_value == 0));

        terminal = getTerminal_FileDescId(fildes);
        input_queue = getInputQueue_Terminal(terminal);
        output_queue = getOutputQueue_Terminal(terminal);

        /*
         * If queue_selector is TCIFLUSH, it shall flush data received but not
         * read.
         */
        REQ("?tcflush.01.01", "If selector is TCIFLUSH, tcflush() shall flush received data",
           ((queue_selector == SUT_TCIFLUSH) => isEmpty_TerminalQueue(input_queue)));

        /*
         * If queue_selector is TCOFLUSH, it shall flush data written but not
         * transmitted.
         */
        REQ("?tcflush.01.02", "If selector is TCOFLUSH, tcflush() shall flush send data",
           ((queue_selector == SUT_TCOFLUSH) => isEmpty_TerminalQueue(output_queue)));

        /*
         * If queue_selector is TCIOFLUSH, It shall flush both data received
         * but not read and data written but not transmitted.
         */
        REQ("?tcflush.01.03", "If selector is TCIOFLUSH, tcflush() shall flush received data",
           ((queue_selector == SUT_TCIOFLUSH) => isEmpty_TerminalQueue(input_queue)));

        REQ("?tcflush.01.03", "If selector is TCIOFLUSH, tcflush() shall flush send data",
           ((queue_selector == SUT_TCIOFLUSH) => isEmpty_TerminalQueue(output_queue)));

        return true;
    }
}

void onTCFlushReturn(CallContext context, IntT tcflush_return, ErrorCode *errno)
{
    TCFlushCall *blocked_call = finishBlockedCall(context);

    if(tcflush_return == 0)
    {
        FileDescId fildes = blocked_call->fildes;
        QueueSelector queue_selector = blocked_call->queue_selector;
        Terminal *terminal = getTerminal_FileDescId(fildes);
        TerminalQueue *input_queue = getInputQueue_Terminal(terminal);
        TerminalQueue *output_queue = getOutputQueue_Terminal(terminal);

        if(queue_selector == SUT_TCIFLUSH || queue_selector == SUT_TCIOFLUSH)
        {
            clear_TerminalQueue(input_queue);
        }

        if(queue_selector == SUT_TCOFLUSH || queue_selector == SUT_TCIOFLUSH)
        {
            clear_TerminalQueue(output_queue);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcgetattr - get the parameters associated with the terminal

SYNOPSIS

    #include <termios.h>

    int tcgetattr(int fildes, struct termios *termios_p);

DESCRIPTION

    The tcgetattr() function shall get the parameters associated with the
    terminal referred to by fildes and store them in the termios structure
    referenced by termios_p. The fildes argument is an open file descriptor
    associated with a terminal.

    The termios_p argument is a pointer to a termios structure.

    The tcgetattr() operation is allowed from any process.

    If the terminal device supports different input and output baud rates, the
    baud rates stored in the termios structure returned by tcgetattr() shall
    reflect the actual baud rates, even if they are equal. If differing baud
    rates are not supported, the rate returned as the output baud rate shall
    be the actual baud rate. If the terminal device does not support split
    baud rates, the input baud rate stored in the termios structure shall be
    the output rate (as one of the symbolic values).

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcgetattr() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [ENOTTY]
        The file associated with fildes is not a terminal.

RATIONALE

    Care must be taken when changing the terminal attributes. Applications
    should always do a tcgetattr(), save the termios structure values returned,
    and then do a tcsetattr(), changing only the necessary fields. The
    application should use the values saved from the tcgetattr() to reset the
    terminal state whenever it is done with the terminal. This is necessary
    because terminal attributes apply to the underlying port and not to each
    individual open instance; that is, all processes that have used the
    terminal see the latest attribute changes.

    A program that uses these functions should be written to catch all signals
    and take other appropriate actions to ensure that when the program
    terminates, whether planned or not, the terminal device's state is restored
    to its original state.

    Existing practice dealing with error returns when only part of a request
    can be honored is based on calls to the ioctl() function. In historical BSD
    and System V implementations, the corresponding ioctl() returns zero if the
    requested actions were semantically correct, even if some of the requested
    changes could not be made. Many existing applications assume this behavior
    and would no longer work correctly if the return value were changed from
    zero to -1 in this case.

    Note that either specification has a problem. When zero is returned, it
    implies everything succeeded even if some of the changes were not made.
    When -1 is returned, it implies everything failed even though some of the
    changes were made.

    Applications that need all of the requested changes made to work properly
    should follow tcsetattr() with a call to tcgetattr() and compare the
    appropriate field values.

Issue 6

    In the DESCRIPTION, the rate returned as the input baud rate shall be the
    output rate. Previously, the number zero was also allowed but was
    obsolescent.
*/
specification
IntT tcgetattr_spec(CallContext context, FileDescId fildes, VoidTPtr termios_p,
                    ErrorCode *errno)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    Terminal *terminal = is_terminal ? clone(getTerminal_FileDescId(fildes)) : NULL;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        /* The termios_p argument is a pointer to a termios structure */
        REQ("app.tcgetattr.01", "termios_p is valid pointer",
            isValidPointer(context, termios_p));

        return true;
    }
    coverage C
    {
        FILE_TYPE_COVERAGE(tcgetattr, "tcgetattr()", fildes);
    }
    post
    {
        TermIOS *termios;

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCGETATTR, "tcgetattr.03", (tcgetattr_spec == -1), *errno);

            /*
             * The tcgetattr() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCGETATTR, EBADF, "tcgetattr.04.01",
                @!isValid_FileDescId(fildes));

            /*
             * The tcgetattr() function shall fail if:
             *
             * [ENOTTY]
             *
             * The file associated with fildes is not a terminal.
             */
            ERROR_SHALL(POSIX_TCGETATTR, ENOTTY, "tcgetattr.04.02", !is_terminal);

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("tcgetattr.02", "On success, tcgetattr() shall return 0", (tcgetattr_spec == 0));

        termios = getTermIOS(termios_p);

        /*
         * The tcgetattr() function shall get the parameters associated with
         * the terminal referred to by fildes and store them in the termios
         * structure referenced by termios_p.
         */
        REQ("tcgetattr.01", "The termios rates shall reflect the actual rates",
            checkIOAttributes_TermIOS(termios, terminal));

        /*
         * If the terminal device supports different input and output baud
         * rates
         */
        if(isSplittedIO_Terminal(terminal))
        {           
            /*
             * The baud rates stored in the termios structure returned by
             * tcgetattr() shall reflect the actual baud rates, even if they
             * are equal.
             */
            REQ("tcgetattr.01.01", "The termios rates shall reflect the actual rates", true);
        }
        /* If the terminal device does not support split baud rates */
        else if(isNotSplittedIO_Terminal(terminal))
        {
            /*
             * The input baud rate stored in the termios structure shall be the
             * output rate (as one of the symbolic values).
             */
            REQ("tcgetattr.01.02", "The input rate shall be the output rate",
               (termios->ispeed == termios->ospeed));
        }

        return true;
    }
}

void onTCGetAttr(CallContext context, FileDescId fildes, VoidTPtr termios_p,
                 ErrorCode *errno, IntT tcgetattr_spec)
{
    if(tcgetattr_spec == 0)
    {
        TermIOS *termios = getTermIOS(termios_p);
        Terminal *terminal = getTerminal_FileDescId(fildes);

        if(terminal != NULL && termios->ispeed != termios->ospeed)
        {
            splitIO_Terminal(terminal);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcgetpgrp - get the foreground process group ID

SYNOPSIS

    #include <unistd.h>

    pid_t tcgetpgrp(int fildes);

DESCRIPTION

    The tcgetpgrp() function shall return the value of the process group ID of
    the foreground process group associated with the terminal.

    If there is no foreground process group, tcgetpgrp() shall return a value
    greater than 1 that does not match the process group ID of any existing
    process group.

    The tcgetpgrp() function is allowed from a process that is a member of a
    background process group; however, the information may be subsequently
    changed by a process that is a member of a foreground process group.

RETURN VALUE

    Upon successful completion, tcgetpgrp() shall return the value of the
    process group ID of the foreground process associated with the terminal.
    Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

    The tcgetpgrp() function s  hall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [ENOTTY]
        The calling process does not have a controlling terminal, or the file
        is not the controlling terminal.
*/
specification
ProcessId tcgetpgrp_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    ProcessId processid = getProcessId_CallContext(context);

    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    Bool3 control_status = is_terminal ? 
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool fpgroup_exists = fpgroupid != NULL && !isWrong_ProcessId(*fpgroupid);
    bool fpgroup_does_not_exist = fpgroupid != NULL && isWrong_ProcessId(*fpgroupid);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        return true;
    }
    coverage C
    {
        CTERM_PGROUP_COVERAGE(tcgetpgrp, "tcgetpgrp()", processid, fildes);
    }
    post
    {
        /*
         * [On error,] -1 shall be returned and errno set to indicate the error
         */
        ERROR_BEGIN(POSIX_TCGETPGRP, "tcgetpgrp.04", isWrong_ProcessId(tcgetpgrp_spec),
            *errno);

            /*
             * The tcgetpgrp() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCGETPGRP, EBADF, "tcgetpgrp.05.01",
                @!isValid_FileDescId(fildes));

            /*
             * The tcgetpgrp() function shall fail if:
             *
             * [ENOTTY]
             *
             * The calling process does not have a controlling terminal, or the
             * file is not the controlling terminal.
             */
            ERROR_SHALL3(POSIX_TCGETPGRP, ENOTTY, "tcgetpgrp.05.02",
            (
                @hasControllingTerminal_ProcessId(processid) ?
                    not_Bool3(control_status) : True_Bool3
            ));

        ERROR_END();

        /*
         * Upon successful completion, tcgetpgrp() shall return the value of
         * the process group ID of the foreground process associated with the
         * terminal.
         */
        REQ("tcgetpgrp.03", "tcgetpgrp() shall return process group id",
            !isWrong_ProcessId(tcgetpgrp_spec));

        /* [If foreground process group exists] */
        if(fpgroup_exists)
        {
            /*
             * tcgetpgrp() function shall return the value of the process
             * group ID of the foreground process group associated with the
             * terminal.
             */
            REQ("tcgetpgrp.01", "tcgetpgrp() shall return the foreground process group id",
                equals_ProcessId(tcgetpgrp_spec, *fpgroupid));
        }
        /* If there is no foreground process group */
        else if(fpgroup_does_not_exist)
        {
            /*
             * tcgetpgrp() shall return a value greater than 1 that does not
             * match the process group ID of any existing process group.
             */
            REQ("tcgetpgrp.02", "tcgetpgrp() shall return a value greater than 1",
               (tcgetpgrp_spec.process > 1));

            REQ("tcgetpgrp.02", "returned value does not match the process group id",
                !isValidProcessGroupId(tcgetpgrp_spec));
        }

        return true;
    }
}

void onTCGetPGrp(CallContext context, FileDescId fildes, ErrorCode *errno,
                 ProcessId tcgetpgrp_spec)
{
    if(!isWrong_ProcessId(tcgetpgrp_spec))
    {
        if(getControllingStatus_FileDescId(fildes) == Unknown_Bool3)
        {
            setControllingStatus_FileDescId(fildes, True_Bool3);
        }

        if(isControllingTerminal_FileDescId(fildes) &&
           equals(getForegroundPGroupId_FileDescId(fildes), NULL))
        {
            ProcessIdObj *fpgroupid = isValidProcessGroupId(tcgetpgrp_spec) ?
                create_ProcessIdObj(tcgetpgrp_spec) : create_ProcessIdObj(WrongProcessId);

            setForegroundPGroupId_FileDescId(fildes, fpgroupid);
        }
    }
    else
    {
        ProcessId processid = getProcessId_CallContext(context);

        if(isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes))
        {
            if(hasControllingTerminal_ProcessId(processid) &&
               getControllingStatus_FileDescId(fildes) == Unknown_Bool3)
            {
                setControllingStatus_FileDescId(fildes, False_Bool3);
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcgetsid - get the process group ID for the session leader for the
    controlling terminal

SYNOPSIS

    #include <termios.h>

    pid_t tcgetsid(int fildes);

DESCRIPTION

    The tcgetsid() function shall obtain the process group ID of the session
    for which the terminal specified by fildes is the controlling terminal.

RETURN VALUE

    Upon successful completion, tcgetsid() shall return the process group ID
    associated with the terminal. Otherwise, a value of (pid_t)-1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcgetsid() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [ENOTTY]
        The calling process does not have a controlling terminal, or the file
        is not the controlling terminal.
*/
specification
ProcessId tcgetsid_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    ProcessId processid = getProcessId_CallContext(context);

    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    Bool3 control_status = is_terminal ? 
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    ProcessIdObj *sessionid = control_status == True_Bool3 ?
        getSessionId_FileDescId(fildes) : NULL;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        return true;
    }
    coverage C
    {
        CTERM_PGROUP_COVERAGE(tcgetsid, "tcgetsid()", processid, fildes);
    }
    post
    {
        /*
         * [On error,] a value of (pid_t)-1 shall be returned and errno set to
         * indicate the error.
         */
        ERROR_BEGIN(POSIX_TCGETSID, "tcgetsid.03", isWrong_ProcessId(tcgetsid_spec), *errno);

            /*
             * The tcgetsid() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCGETSID, EBADF, "tcgetsid.04.01",
                @!isValid_FileDescId(fildes));

            /*
             * The tcgetsid() function shall fail if:
             *
             * [ENOTTY]
             *
             * The calling process does not have a controlling terminal, or the
             * file is not the controlling terminal.
             */
            ERROR_SHALL3(POSIX_TCGETSID, ENOTTY, "tcgetsid.04.02",
            (
                @hasControllingTerminal_ProcessId(processid) ?
                    not_Bool3(control_status) : True_Bool3
            ));

        ERROR_END();

        /*
         * Upon successful completion, tcgetsid() shall return the process
         * group ID associated with the terminal.
         */
        REQ("tcgetsid.02", "On success, tcgetsid() shall return the session id",
            !isWrong_ProcessId(tcgetsid_spec));
                
        /*
         * The tcgetsid() function shall obtain the process group ID of the
         * session for which the terminal specified by fildes is the
         * controlling terminal.
         */
        REQ("tcgetsid.01", "tcgetsid() shall return the session id",
           ((sessionid != NULL) => equals_ProcessId(tcgetsid_spec, *sessionid)));

        return true;
    }
}

void onTCGetSid(CallContext context, FileDescId fildes, ErrorCode *errno,
                ProcessId tcgetsid_spec)
{
    if(!isWrong_ProcessId(tcgetsid_spec))
    {
        if(getControllingStatus_FileDescId(fildes) == Unknown_Bool3)
        {
            setControllingStatus_FileDescId(fildes, True_Bool3);
        }

        if(isControllingTerminal_FileDescId(fildes) &&
           equals(getSessionId_FileDescId(fildes), NULL))
        {
            setSessionId_FileDescId(fildes, create_ProcessIdObj(tcgetsid_spec));
        }
    }
    else
    {
        ProcessId processid = getProcessId_CallContext(context);

        if(isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes))
        {
            if(hasControllingTerminal_ProcessId(processid) &&
               getControllingStatus_FileDescId(fildes) == Unknown_Bool3)
            {
                setControllingStatus_FileDescId(fildes, False_Bool3);
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcsendbreak - send a break for a specific duration

SYNOPSIS

    #include <termios.h>

    int tcsendbreak(int fildes, int duration);

DESCRIPTION

    If the terminal is using asynchronous serial data transmission,
    tcsendbreak() shall cause transmission of a continuous stream of
    zero-valued bits for a specific duration. If duration is 0, it shall cause
    transmission of zero-valued bits for at least 0.25 seconds, and not more
    than 0.5 seconds. If duration is not 0, it shall send zero-valued bits for
    an implementation-defined period of time.

    The fildes argument is an open file descriptor associated with a terminal.

    If the terminal is not using asynchronous serial data transmission, it is
    implementation-defined whether tcsendbreak() sends data to generate a break
    condition or returns without taking any action.

    Attempts to use tcsendbreak() from a process which is a member of a
    background process group on a fildes associated with its controlling
    terminal shall cause the process group to be sent a SIGTTOU signal. If the
    calling process is blocking or ignoring SIGTTOU signals, the process shall
    be allowed to perform the operation, and no signal is sent.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcsendbreak() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [ENOTTY]
        The file associated with fildes is not a terminal.

    The tcsendbreak() function may fail if:

    [EIO]
        The process group of the writing process is orphaned, and the writing
        process is not ignoring or blocking SIGTTOU.
*/
specification typedef struct TCSendBreakCall TCSendBreakCall = {};

TCSendBreakCall* create_TCSendBreakCall
(
    CallContext context,
    FileDescId fildes,
    IntT duration
)
{
    return create(&type_TCSendBreakCall, context, fildes, duration);
}

specification
void tcsendbreak_spec(CallContext context, FileDescId fildes, IntT duration)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    coverage C
    {
        if(duration == 0)
        {
            FILE_TYPE_COVERAGE(DurationIsZero, "duration is zero", fildes);
        }
        else
        {
            FILE_TYPE_COVERAGE(DurationIsNotZero, "duration is not zero", fildes);
        }
    }
    post
    {
        /* [The tcsendbreak() function shall block] */
        REQ("", "tcsendbreak() shall block", equals(getBlockedCall(context),
            create_TCSendBreakCall(context, fildes, duration)));

        /*
         * Attempts to use tcsendbreak() from a process which is a member of a
         * background process group on a fildes associated with its controlling
         * terminal, shall cause the process group to be sent a SIGTTOU signal.
         * If the calling process is blocking or ignoring SIGTTOU signals, the
         * process shall be allowed to perform the operation, and no signal is
         * sent.
         */
        REQ("?tcsendbreak.02", "SIGTTOU signal should be send to a process group",
           ((control_status == True_Bool3 && fpgroupid != NULL && termios != NULL) =>
            (signalShouldBeSentToProcessGroup(pgroupid, SUT_SIGTTOU) == signal_condition)));
        
        return true;
    }
}

void onTCSendBreak(CallContext context, FileDescId fildes, IntT duration)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    startBlockedCall(context, create_TCSendBreakCall(context, fildes, duration));
    threadShouldBeRun(context);

    if(signal_condition)
    {
        sendSignalToProcessGroup(pgroupid, SUT_SIGTTOU);
    }
}

reaction
TCReturnType* tcsendbreak_return(void)
{
    /*
     * This postcondition assumes that a set of open file descriptors, a
     * controlling terminal of the calling process and signal handlers do not
     * change during the tcsendbreak() function call.
     */
    post
    {
        Terminal *terminal;

        CallContext context = tcsendbreak_return->context;
        IntT returned_value = tcsendbreak_return->returned_value;
        ErrorCode *errno = tcsendbreak_return->errno;

        TCSendBreakCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        IntT duration = blocked_call->duration;

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

        bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCSENDBREAK, "tcsendbreak.04", (returned_value == -1), *errno);

            /*
             * The tcsendbreak() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCSENDBREAK, EBADF, "tcsendbreak.05.01",
                !isValid_FileDescId(fildes));

            /*
             * The tcsendbreak() function shall fail if:
             *
             * [ENOTTY]
             *
             * The file associated with fildes is not a terminal.
             */
            ERROR_SHALL(POSIX_TCSENDBREAK, ENOTTY, "tcsendbreak.05.02", !is_terminal);

            /*
             * The tcsendbreak() function may fail if:
             *
             * [EIO]
             *
             * The process group of the writing process is orphaned, and the
             * writing process is not ignoring or blocking SIGTTOU.
             */
            ERROR_MAY3(POSIX_TCSENDBREAK, EIO, "tcsendbreak.06.01",
            (
                getSignalHandler_ProcessId(processid, SUT_SIGTTOU) == SUT_SIG_IGN ||
                isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) ?
                    False_Bool3 : isOrphanedProcessGroupId(pgroupid)
            ));

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("tcsendbreak.03", "On success, tcsendbreak() shall return 0",
           (returned_value == 0));

        terminal = getTerminal_FileDescId(fildes);

        /* If the terminal is using asynchronous serial data transmission */
        if(terminal != NULL && terminal->mode == AsynchronousTransmission)
        {
            /*
             * tcsendbreak() shall cause transmission of a continuous stream of
             * zero-valued bits for a specific duration.
             */
            REQ("tcsendbreak.01", "tcsendbreak() shall send break condition", true);
        }

        return true;
    }
}

void onTCSendBreakReturn(CallContext context, IntT tcsendbreak_return,
                         ErrorCode *errno, TimeInterval time)
{
    TCSendBreakCall *blocked_call = finishBlockedCall(context);

    if(tcsendbreak_return == 0)
    {
        FileDescId fildes = blocked_call->fildes;
        IntT duration = blocked_call->duration;
        Terminal *terminal = getTerminal_FileDescId(fildes);
        TerminalQueue *output_queue = getOutputQueue_Terminal(terminal);

        appendBreakCondition_TerminalQueue(output_queue, overallTimeInterval);
        transmit_Terminal(terminal, time.minMark);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcsetattr - set the parameters associated with the terminal

SYNOPSIS

    #include <termios.h>

    int tcsetattr(int fildes, int optional_actions,
           const struct termios *termios_p);

DESCRIPTION

    The tcsetattr() function shall set the parameters associated with the
    terminal referred to by the open file descriptor fildes (an open file
    descriptor associated with a terminal) from the termios structure
    referenced by termios_p as follows:

        * If optional_actions is TCSANOW, the change shall occur immediately.

        * If optional_actions is TCSADRAIN, the change shall occur after all
          output written to fildes is transmitted. This function should be used
          when changing parameters that affect output.

        * If optional_actions is TCSAFLUSH, the change shall occur after all
          output written to fildes is transmitted, and all input so far
          received but not read shall be discarded before the change is made.

    If the output baud rate stored in the termios structure pointed to by
    termios_p is the zero baud rate, B0, the modem control lines shall no
    longer be asserted. Normally, this shall disconnect the line.

    If the input baud rate stored in the termios structure pointed to by
    termios_p is 0, the input baud rate given to the hardware is the same as
    the output baud rate stored in the termios structure.

    The tcsetattr() function shall return successfully if it was able to
    perform any of the requested actions, even if some of the requested
    actions could not be performed. It shall set all the attributes that the
    implementation supports as requested and leave all the attributes not
    supported by the implementation unchanged. If no part of the request can
    be honored, it shall return -1 and set errno to [EINVAL]. If the input and
    output baud rates differ and are a combination that is not supported,
    neither baud rate shall be changed. A subsequent call to tcgetattr() shall
    return the actual state of the terminal device (reflecting both the changes
    made and not made in the previous tcsetattr() call). The tcsetattr()
    function shall not change the values found in the termios structure under
    any circumstances.

    The effect of tcsetattr() is undefined if the value of the termios
    structure pointed to by termios_p was not derived from the result of a call
    to tcgetattr() on fildes; an application should modify only fields and
    flags defined by this volume of IEEE Std 1003.1-2001 between the call to
    tcgetattr() and tcsetattr(), leaving all other fields and flags unmodified.

    No actions defined by this volume of IEEE Std 1003.1-2001, other than a
    call to tcsetattr() or a close of the last file descriptor in the system
    associated with this terminal device, shall cause any of the terminal
    attributes defined by this volume of IEEE Std 1003.1-2001 to change.

    If tcsetattr() is called from a process which is a member of a background
    process group on a fildes associated with its controlling terminal:

        * If the calling process is blocking or ignoring SIGTTOU signals,
          the operation completes normally and no signal is sent.

        * Otherwise, a SIGTTOU signal shall be sent to the process group.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcsetattr() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [EINTR]
        A signal interrupted tcsetattr().
    [EINVAL]
        The optional_actions argument is not a supported value, or an attempt
        was made to change an attribute represented in the termios structure to
        an unsupported value.
    [ENOTTY]
        The file associated with fildes is not a terminal.

    The tcsetattr() function may fail if:

    [EIO]
        The process group of the writing process is orphaned, and the writing
        process is not ignoring or blocking SIGTTOU.

APPLICATION USAGE

    If trying to change baud rates, applications should call tcsetattr() then
    call tcgetattr() in order to determine what baud rates were actually
    selected.

RATIONALE

    The tcsetattr() function can be interrupted in the following situations:

        * It is interrupted while waiting for output to drain.

        * It is called from a process in a background process group and SIGTTOU
          is caught.

    See also the RATIONALE section in tcgetattr().

FUTURE DIRECTIONS

    Using an input baud rate of 0 to set the input rate equal to the output
    rate may not necessarily be supported in a future version of this volume of
    IEEE Std 1003.1-2001.
*/
specification typedef struct TCSetAttrCall TCSetAttrCall = {};

TCSetAttrCall* create_TCSetAttrCall
(
    CallContext context,
    FileDescId fildes,
    OptionalActions optional_actions,
    TermIOSPtr termios_p
)
{
    return create(&type_TCSetAttrCall, context, fildes, optional_actions, termios_p);
}

specification
void tcsetattr_spec(CallContext context, FileDescId fildes,
                    OptionalActions optional_actions, TermIOSPtr termios_p)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "termios_p is valid pointer", isValidPointer(context, termios_p));

        /*
         * The effect of tcsetattr() is undefined if the value of the termios
         * structure pointed to by termios_p was not derived from the result of
         * a call to tcgetattr() on fildes; an application should modify only
         * fields and flags defined by this volume of IEEE Std 1003.1-2001
         * between the call to tcgetattr() and tcsetattr(), leaving all other
         * fields and flags unmodified.
         */
        REQ("app.tcsetattr.01", "The termios was obtained by tcgetattr() call", true);

        return true;
    }
    coverage C
    {
        switch(optional_actions)
        {
        case SUT_TCSANOW:
            FILE_TYPE_COVERAGE(TCSANOW, "optional_action is TCSANOW", fildes);
            break;
        case SUT_TCSADRAIN:
            FILE_TYPE_COVERAGE(TCSADRAIN, "optional_action is TCSADRAIN", fildes);
            break;
        case SUT_TCSAFLUSH:
            FILE_TYPE_COVERAGE(TCSAFLUSH, "optional_action is TCSAFLUSH", fildes);
            break;
        default:
            FILE_TYPE_COVERAGE(UnknownOptionalAction, "optional_action is unknown" , fildes);
            break;
        }
    }
    coverage C_speed
    {
        TermIOS *termios = getTermIOS(termios_p);

        if(termios->ospeed == SUT_B0)
        {
            return { OutputRateIsB0, "Output rate is B0" };
        }
        else if(termios->ispeed == 0)
        {
            return { InputRateIsZero, "Input rate is zero" };
        }
        else
        {
            return { NormalRates, "Normal rates" };
        }
    }
    post
    {
        /* [The tcsetattr() function shall block] */
        REQ("", "tcsetattr() shall block", equals(getBlockedCall(context),
            create_TCSetAttrCall(context, fildes, optional_actions, termios_p)));

        /*
         * If tcsetattr() is called from a process which is a member of a
         * background process group on a fildes associated with its controlling
         * terminal:
         *
         *   * If the calling process is blocking or ignoring SIGTTOU signals,
         *     the operation completes normally and no signal is sent.
         *
         *   * Otherwise, a SIGTTOU signal shall be sent to the process group.
         */
        REQ("?tcsetattr.06", "SIGTTOU signal should be send to a process group",
           ((control_status == True_Bool3 && fpgroupid != NULL && termios != NULL) =>
            (signalShouldBeSentToProcessGroup(pgroupid, SUT_SIGTTOU) == signal_condition)));

        return true;
    }
}

void onTCSetAttr(CallContext context, FileDescId fildes,
                 OptionalActions optional_actions, TermIOSPtr termios_p)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    startBlockedCall(context,
        create_TCSetAttrCall(context, fildes, optional_actions, termios_p));

    threadShouldBeRun(context);

    if(signal_condition)
    {
        sendSignalToProcessGroup(pgroupid, SUT_SIGTTOU);
    }
}

reaction
TCReturnType* tcsetattr_return(void)
{
    /*
     * This postcondition assumes that a set of open file descriptors, a
     * controlling terminal of the calling process, signal handlers and
     * termios structure referenced by termios_p do not change during the
     * tcsetattr() function call.
     */
    post
    {
        Terminal *terminal;
        TerminalQueue *input_queue, *output_queue;

        CallContext context = tcsetattr_return->context;
        IntT returned_value = tcsetattr_return->returned_value;
        ErrorCode *errno = tcsetattr_return->errno;

        TCSetAttrCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        OptionalActions optional_actions = blocked_call->optional_actions;
        TermIOS *termios = getTermIOS(blocked_call->termios_p);

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

        bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCSETATTR, "tcsetattr.09", (returned_value == -1), *errno);

            /*
             * The tcsetattr() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCSETATTR, EBADF, "tcsetattr.10.01",
                !isValid_FileDescId(fildes));

            /*
             * The tcsetattr() function shall fail if:
             *
             * [EINTR]
             *
             * A signal interrupted tcsetattr().
             */
            ERROR_SHALL(POSIX_TCSETATTR, EINTR, "tcsetattr.10.02",
                isBlockedCallInterruptedBySignal(context));

            /*
             * The tcsetattr() function shall fail if:
             *
             * [EINVAL]
             *
             * The optional_actions argument is not a supported value, or an
             * attempt was made to change an attribute represented in the
             * termios structure to an unsupported value.
             */
            ERROR_UNCHECKABLE(POSIX_TCSETATTR, EINVAL, "tcsetattr.10.03",
                "don't know how to check");

            /*
             * The tcsetattr() function shall fail if:
             *
             * [ENOTTY]
             *
             * The file associated with fildes is not a terminal.
             */
            ERROR_SHALL(POSIX_TCSETATTR, ENOTTY, "tcsetattr.10.04", !is_terminal);

            /*
             * The tcsetattr() function may fail if:
             *
             * [EIO]
             *
             * The process group of the writing process is orphaned, and the
             * writing process is not ignoring or blocking SIGTTOU.
             */
            ERROR_MAY3(POSIX_TCSETATTR, EIO, "tcsetattr.11.01",
            (
                getSignalHandler_ProcessId(processid, SUT_SIGTTOU) == SUT_SIG_IGN ||
                isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) ?
                    False_Bool3 : isOrphanedProcessGroupId(pgroupid)
            ));

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("tcsetattr.08", "On success, tcsetattr() shall return 0", (returned_value == 0));

        terminal = getTerminal_FileDescId(fildes);
        input_queue = getInputQueue_Terminal(terminal);
        output_queue = getOutputQueue_Terminal(terminal);

        switch(optional_actions)
        {
        /* If optional_actions is TCSANOW */
        case SUT_TCSANOW:
            /* The change shall occur immediately */
            REQ("tcsetattr.01.01", "Change shall occur immediately", true);
            break;
        /* If optional_actions is TCSADRAIN */
        case SUT_TCSADRAIN:
            /* 
             * The change shall occur after all output written to fildes is
             * transmitted.
             */
            REQ("?tcsetattr.01.02", "Change shall occur after all output is transmitted",
                isEmpty_TerminalQueue(output_queue));
            break;
        /* If optional_actions is TCSAFLUSH */
        case SUT_TCSAFLUSH:
            /*
             * The change shall occur after all output written to fildes is
             * transmitted, and all input so far received but not read shall be
             * discarded before the change is made.
             */
            REQ("?tcsetattr.01.03", "Change shall occur after all output is transmitted",
                isEmpty_TerminalQueue(output_queue));
            REQ("?tcsetattr.01.03", "Change shall occur after all input is discarded",
                isEmpty_TerminalQueue(input_queue));
            break;
        }

        /*
         * If the output baud rate stored in the termios structure pointed to
         * by termios_p is the zero baud rate, B0.
         */
        if(termios->ospeed == SUT_B0)
        {
            /* 
             * The modem control lines shall no longer be asserted. Normally,
             * this shall disconnect the line.
             */
            REQ("?tcsetattr.02", "Line shall be disconnected",
               ((!termios->cflag->clocal && isReal_Terminal(terminal)) =>
                  isDisconnected_Terminal(terminal)));
        }
        /*
         * If the input baud rate stored in the termios structure pointed to by
         * termios_p is 0.
         */
        else if(termios->ispeed == 0)
        {
            TermIOS *last = clone(termios);
            last->ispeed = last->ospeed;

            /*
             * The input baud rate given to the hardware is the same as the
             * output baud rate stored in the termios structure.
             */
            REQ("?tcsetattr.03;tcsetattr.04;tcsetattr.05",
                "Input rate is the same as output rate",
                equals_TermIOS(last, getLastTermIOS_Terminal(terminal)));
        }
        else
        {
            /*
             * The tcsetattr() function shall set the parameters associated
             * with the terminal.
             */
            REQ("?tcsetattr.01;tcsetattr.04;tcsetattr.05",
                "tcsetattr() shall set the parameters",
                equals_TermIOS(termios, getLastTermIOS_Terminal(terminal)));
        }

        /*
         * The tcsetattr() function shall not change the values found in the
         * termios structure under any circumstances.
         */
        REQ("tcsetattr.06", "tcsetattr() shall not change termios structure", true);

        if(isPT_Terminal(terminal))
        {
            Terminal *remote = getRemoteTerminal_Terminal(terminal);
            
            /* [PTM and PTS have the same termios structure] */
            REQ("", "PTM and PTS have the same termios",
               ((remote != NULL) => equals(getLastTermIOS_Terminal(terminal),
                                           getLastTermIOS_Terminal(remote))));
        }

        return true;
    }
}

void onTCSetAttrReturn(CallContext context, IntT tcsetattr_return,
                       ErrorCode *errno)
{
    TCSetAttrCall *blocked_call = finishBlockedCall(context);
    FileDescId fildes = blocked_call->fildes;

    if(isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes))
    {
        OptionalActions optional_actions = blocked_call->optional_actions;

        TermIOS *termios = getTermIOS(blocked_call->termios_p);
        TermIOS *terminal_termios = clone(termios);

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId sessionid = getSessionId_ProcessId(processid);

        Terminal *terminal = getTerminal_FileDescId(fildes);

        if(tcsetattr_return == 0)
        {
            TerminalQueue *input_queue = getInputQueue_Terminal(terminal);
            TerminalQueue *output_queue = getOutputQueue_Terminal(terminal);

            switch(optional_actions)
            {
            case SUT_TCSADRAIN:
                /*
                 * This specification assumes that all output is transmitted
                 * during the write(), tcflow() or tcsendbreak function calls,
                 * so the output queue is always empty here.
                 */
                clear_TerminalQueue(output_queue);
                break;
            case SUT_TCSAFLUSH:
                /*
                 * This specification assumes that all output is transmitted
                 * during the write(), tcflow() or tcsendbreak function calls,
                 * so the output queue is always empty here.
                 */
                clear_TerminalQueue(output_queue);
                clear_TerminalQueue(input_queue);
                break;
            }

            if(termios->ospeed == SUT_B0 && !termios->cflag->clocal &&
               isReal_Terminal(terminal))
            {
                disconnect_Terminal(terminal);
            }

            if(termios->ispeed == 0)
            {
                terminal_termios->ispeed = terminal_termios->ospeed;
            }
        }

        terminal_termios->address = NULL_VoidTPtr;
        addTermIOS_Terminal(terminal, terminal_termios);

        if(isPT_Terminal(terminal))
        {
            Terminal *remote = getRemoteTerminal_Terminal(terminal);

            if(remote != NULL)
            {
                /* [PTM and PTS have the same termios structure] */
                addTermIOS_Terminal(remote, clone(terminal_termios));
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    tcsetpgrp - set the foreground process group ID

SYNOPSIS

    #include <unistd.h>

    int tcsetpgrp(int fildes, pid_t pgid_id);

DESCRIPTION

    If the process has a controlling terminal, tcsetpgrp() shall set the
    foreground process group ID associated with the terminal to pgid_id. The
    application shall ensure that the file associated with fildes is the
    controlling terminal of the calling process and the controlling terminal is
    currently associated with the session of the calling process. The
    application shall ensure that the value of pgid_id matches a process group
    ID of a process in the same session as the calling process.

    Attempts to use tcsetpgrp() from a process which is a member of a
    background process group on a fildes associated with its controlling
    terminal shall cause the process group to be sent a SIGTTOU signal. If the
    calling process is blocking or ignoring SIGTTOU signals, the process shall
    be allowed to perform the operation, and no signal is sent.

RETURN VALUE

    Upon successful completion, 0 shall be returned. Otherwise, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The tcsetpgrp() function shall fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [EINVAL]
        This implementation does not support the value in the pgid_id argument.
    [ENOTTY]
        The calling process does not have a controlling terminal, or the file
        is not the controlling terminal, or the controlling terminal is no
        longer associated with the session of the calling process.
    [EPERM]
        The value of pgid_id is a value supported by the implementation, but
        does not match the process group ID of a process in the same session
        as the calling process.
*/
specification typedef struct TCSetPGrpCall TCSetPGrpCall = {};

TCSetPGrpCall* create_TCSetPGrpCall
(
    CallContext context,
    FileDescId fildes,
    ProcessId pgid_id
)
{
    return create(&type_TCSetPGrpCall, context, fildes, pgid_id);
}

specification
void tcsetpgrp_spec(CallContext context, FileDescId fildes, ProcessId pgid_id)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?        
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ?
        getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    coverage C
    {
        CTERM_PGROUP_COVERAGE(tcsetpgrp, "tcsetpgrp()", processid, fildes);
    }
    post
    {
        /* [The tcsetpgrp() function shall block] */
        REQ("", "tcsetpgrp() shall block", equals(getBlockedCall(context),
            create_TCSetPGrpCall(context, fildes, pgid_id)));

        /*
         * Attempts to use tcsetpgrp() from a process which is a member of a
         * background process group on a fildes associated with its controlling
         * terminal shall cause the process group to be sent a SIGTTOU signal.
         * If the calling process is blocking or ignoring SIGTTOU signals, the
         * process shall be allowed to perform the operation, and no signal is
         * sent.
         */  
        REQ("?tcsetpgrp.02", "SIGTTOU signal should be send to a process group",
           ((control_status == True_Bool3 && fpgroupid != NULL && termios != NULL) =>
            (signalShouldBeSentToProcessGroup(pgroupid, SUT_SIGTTOU) == signal_condition)));

        return true;
    }
}

void onTCSetPGrp(CallContext context, FileDescId fildes, ProcessId pgid_id)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);

    ProcessId processid = getProcessId_CallContext(context);
    ProcessId pgroupid = getProcessGroupId_ProcessId(processid);

    Bool3 control_status = is_terminal ?        
        getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

    TermIOS *termios = is_terminal ? getTermIOS_FileDescId(fildes) : NULL;

    ProcessIdObj *fpgroupid = control_status == True_Bool3 ?
        getForegroundPGroupId_FileDescId(fildes) : NULL;

    bool signal_condition =
        /* [TOSTOP flag is set] */
        termios != NULL && termios->lflag->tostop &&
        /* [Foreground process group is known] */
        fpgroupid != NULL &&
        /* [Process is a member of a background process group] */
        !equals_ProcessId(pgroupid, *fpgroupid) &&
        /* [Process is not blocking the SIGTTOU signal] */
        !isSignalBlocked_ProcessId(processid, SUT_SIGTTOU) &&
        /* [Process is not ignoring the SIGTTOU signal] */
        getSignalHandler_ProcessId(processid, SUT_SIGTTOU) != SUT_SIG_IGN;

    startBlockedCall(context, create_TCSetPGrpCall(context, fildes, pgid_id));
    threadShouldBeRun(context);

    if(signal_condition)
    {
        sendSignalToProcessGroup(pgroupid, SUT_SIGTTOU);
    }
}

reaction
TCReturnType* tcsetpgrp_return(void)
{
    /*
     * This postcondition assumes that a set of open file descriptors and a
     * controlling terminal of the calling process do not change during the
     * tcsetpgrp() function call.
     */
    post
    {
        ProcessIdObj *fpgroupid;

        CallContext context = tcsetpgrp_return->context;
        IntT returned_value = tcsetpgrp_return->returned_value;
        ErrorCode *errno = tcsetpgrp_return->errno;

        TCSetPGrpCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        ProcessId pgid_id = blocked_call->pgid_id;

        ProcessId processid = getProcessId_CallContext(context);
        ProcessId sessionid = getSessionId_ProcessId(processid);

        Bool3 control_status = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes) ? 
            getControllingStatus_FileDescId(fildes) : Unknown_Bool3;

        ProcessIdObj *cterm_sessionid = control_status == True_Bool3 ?
            getSessionId_FileDescId(fildes) : NULL;

        Bool3 session_status = cterm_sessionid == NULL ? Unknown_Bool3 :
            (equals_ProcessId(*cterm_sessionid, sessionid) ? True_Bool3 : False_Bool3);

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_TCSETPGRP, "tcsetpgrp.01", (returned_value == -1), *errno);

            /*
             * The tcsetpgrp() function shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_SHALL(POSIX_TCSETPGRP, EBADF, "tcsetpgrp.05.01",
                !isValid_FileDescId(fildes));

            /*
             * The tcsetpgrp() function shall fail if:
             *
             * [EINVAL]
             *
             * This implementation does not support the value in the pgid_id
             * argument.
             */
            ERROR_UNCHECKABLE(POSIX_TCSETPGRP, EINVAL, "tcsetpgrp.05.02",
                "don't know how to check");

            /*
             * The tcsetpgrp() function shall fail if:
             *
             * [ENOTTY]
             *
             * The calling process does not have a controlling terminal, or the
             * file is not the controlling terminal, or the controlling
             * terminal is no longer associated with the session of the calling
             * process.
             */
            ERROR_SHALL3(POSIX_TCSETPGRP, ENOTTY, "tcsetpgrp.05.03",
            (
                !hasControllingTerminal_ProcessId(processid) ? True_Bool3 :
                    or_Bool3(not_Bool3(control_status), not_Bool3(session_status))
            ));

            /*
             * The tcsetpgrp() function shall fail if:
             *
             * [EPERM]
             *
             * The value of pgid_id is a value supported by the implementation,
             * but does not match the process group ID of a process in the same
             * session as the calling process.
             */
            ERROR_SHALL(POSIX_TCSETPGRP, EPERM, "tcsetpgrp.05.04",
                !isValidProcessGroupIdInSession(pgid_id, sessionid));

        ERROR_END();

        /* Upon successful completion, 0 shall be returned */
        REQ("tcsetpgrp.03", "On success, tcsetpgrp() shall return 0", (returned_value == 0));

        /* 
         * tcsetpgrp() shall set the foreground process group ID associated
         * with the terminal to pgid_id.
         */
        fpgroupid = getForegroundPGroupId_FileDescId(fildes);

        REQ("?tcsetpgrp.01", "tcsetpgrp() shall set foreground process group ID",
           (fpgroupid != NULL));

        REQ("?tcsetpgrp.01", "tcsetpgrp() shall set foreground process group ID to pgid_id",
            equals_ProcessId(*fpgroupid, pgid_id));

        return true;
    }
}

void onTCSetPGrpReturn(CallContext context, IntT tcsetpgrp_return, ErrorCode *errno)
{
    TCSetPGrpCall *blocked_call = finishBlockedCall(context);
    
    if(tcsetpgrp_return == 0)
    {
        FileDescId fildes = blocked_call->fildes;
        ProcessId processid = getProcessId_CallContext(context);
        ProcessId pgid_id = blocked_call->pgid_id;
        ProcessId sessionid = getSessionId_ProcessId(processid);

        if(getControllingStatus_FileDescId(fildes) == Unknown_Bool3)
        {
            setControllingStatus_FileDescId(fildes, True_Bool3);
        }

        if(isControllingTerminal_FileDescId(fildes))
        {
            if(equals(getForegroundPGroupId_FileDescId(fildes), NULL))
            {
                setForegroundPGroupId_FileDescId(fildes, create_ProcessIdObj(pgid_id));
            }

            if(equals(getSessionId_FileDescId(fildes), NULL))
            {
                setSessionId_FileDescId(fildes, create_ProcessIdObj(sessionid));
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

Name

    ttyio -- tty ioctl commands

Synopsis

    #include <sys/ioctl.h>
    #include <fcntl.h>

    int ioctl(int fd, unsigned long request, int * argp);

Description

    Tty ioctl commands are a subset of the ioctl() calls, which can perform a
    variety of functions on tty devices. fd shall be an open file descriptor
    referring to a terminal device.

    The following ioctl()s are provided:

    TIOCGWINSZ

        Get the size attributes of the terminal or pseudo-terminal identified
        by fd. On entry, argp shall reference a winsize structure. On return,
        the structure will have ws_row set to the number of rows of text (i.e.
        lines of text) that can be viewed on the device, and ws_col set to the
        number of columns (i.e. text width).

        Note: The number of columns stored in ws_col assumes that the terminal
        device is using a mono-spaced font.

Return Value

    On success, 0 is returned. On error, -1 is returned and the global variable
    errno is set appropriately.

Errors

    EBADF
        fd is not a valid descriptor.
    EFAULT
        argp references an inaccessible memory area.
    EINVAL
        request and argp are not valid.
*/
specification
IntT ttyio_TIOCGWINSZ_spec(CallContext context, FileDescId fd, WinSize *argp,
                           ErrorCode *errno)
{
    bool is_terminal = isValid_FileDescId(fd) && isTerminal_FileDescId(fd);

    Terminal *pre_terminal = is_terminal ? clone(getTerminal_FileDescId(fd)) : NULL;

    WinSize *pre_winsize = pre_terminal != NULL ? getWinSize_Terminal(pre_terminal) : NULL;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        /* On entry, argp shall reference a winsize structure */
        REQ("app.ttyio_TIOCGWINSZ.01", "argp shall reference a winsize structure", true);

        return true;
    }
    coverage C
    {
        NOT_TERM_DETAIL_COVERAGE(ttyio_TIOCGWINSZ, "ttyio_TIOCGWINSZ", fd);

        if(argp == NULL)
        {
            return { ArgpIsNull, "The argp is NULL" };
        }
        if(pre_winsize == NULL)
        {
            return { UnknownTerminalWinSize, "The winsize is unknown" };
        }
        else
        {
            TERM_TYPE_COVERAGE(ttyio_TIOCGWINSZ, "ttyio_TIOCGWINSZ", fd);
        }
    }
    post
    {
        /* On error, -1 is returned and the global variable errno is set appropriately */
        ERROR_BEGIN(LSB_TTYIO_TIOCGWINSZ, "ttyio_TIOCGWINSZ.03",
            (ttyio_TIOCGWINSZ_spec == -1), *errno);

            /* [EBADF] fd is not a valid descriptor */
            ERROR_SHALL(LSB_TTYIO_TIOCGWINSZ, EBADF, "ttyio_TIOCGWINSZ.03.01;ioctl.03.01",
                @!isValid_FileDescId(fd));

            /* [EFAULT] argp references an inaccessible memory area */
            ERROR_SHALL(LSB_TTYIO_TIOCGWINSZ, EFAULT, "ttyio_TIOCGWINSZ.03.02;ioctl.03.02",
                (argp == NULL));

            /* [EINVAL] request and argp are not valid */
            ERROR_SHALL(LSB_TTYIO_TIOCGWINSZ, EINVAL, "ttyio_TIOCGWINSZ.03.03;ioctl.03.05",
                (argp == NULL));

        ERROR_END();

        /* On success, 0 is returned */
        REQ("ttyio_TIOCGWINSZ.02", "On success, 0 is returned", (ttyio_TIOCGWINSZ_spec == 0));

        /* [The fd is a terminal descriptor id] */
        REQ("", "The fd is a terminal descriptor id", is_terminal);

        /* [The argp is not NULL] */
        REQ("", "The argp is not NULL", (argp != NULL));

        if(pre_winsize != NULL)
        {
            /*
             * On return, the structure will have ws_row set to the number of
             * rows of text (i.e. lines of text) that can be viewed on the
             * device, and ws_col set to the number of columns (i.e. text
             * width).
             */
            REQ("ttyio_TIOCGWINSZ.01.01", "ttyio shall set ws_row field",
               (argp->row == pre_winsize->row));
            REQ("ttyio_TIOCGWINSZ.01.02", "ttyio shall set ws_col field",
               (argp->col == pre_winsize->col));
        }

       /*
         * The ioctl() function shall manipulate the underlying device parameters of
         * special files.
         */
        REQ("ioctl.01", "", TODO_REQ());

        /*
         * On success, 0 is returned. An ioctl() may use the return value as an output
         * parameter and return a non-negative value on success.
         */
        REQ("ioctl.02", "", TODO_REQ());

        return true;
    }
}

void onTTYIO_TIOCGWINSZ(CallContext context, FileDescId fd, WinSize *argp,
                        ErrorCode *errno, IntT ttyio_TIOCGWINSZ_spec)
{
    if(ttyio_TIOCGWINSZ_spec == 0)
    {
        Terminal *terminal = getTerminal_FileDescId(fd);

        if(terminal == NULL)
        {
            setTerminal_FileDescId(fd, terminal = default_Terminal());
        }

        if(equals(getWinSize_Terminal(terminal), NULL))
        {
            setWinSize_Terminal(terminal, argp);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    ttyname - find the pathname of a terminal

SYNOPSIS

    #include <unistd.h>

    char *ttyname(int fildes);

DESCRIPTION

    The ttyname() function shall return a pointer to a string containing a
    null-terminated pathname of the terminal associated with file descriptor
    fildes. The return value may point to static data whose content is
    overwritten by each call.

    The ttyname() function need not be reentrant. A function that is not
    required to be reentrant is not required to be thread-safe.

RETURN VALUE

    Upon successful completion, ttyname() shall return a pointer to a string.
    Otherwise, a null pointer shall be returned and errno set to indicate the
    error.

ERRORS

    The ttyname() function may fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [ENOTTY]
        The fildes argument does not refer to a terminal.

RATIONALE

    The term ''terminal'' is used instead of the historical term
    ''terminal device'' in order to avoid a reference to an undefined term.

    The thread-safe version places the terminal name in a user-supplied buffer
    and returns a non-zero value if it fails. The non-thread-safe version
    may return the name in a static data area that may be overwritten by each
    call.
*/
specification
CString* ttyname_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);
    CString *path = is_terminal ? getPath_FileDescId(fildes) : NULL;

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        if(POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_TERMINAL)
        {
            /* [Implicit precondition] */
            REQ("", "The fildes is a terminal descriptor id", is_terminal);
        }

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_TERMINAL

            NOT_TERM_DETAIL_COVERAGE(ttyname, "ttyname()", fildes);

#endif /* #if POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_TERMINAL */

        TERM_TYPE_COVERAGE(ttyname, "ttyname()", fildes);
    }
    post
    {
        /*
         * [On error,] a null pointer shall be returned and errno set to
         * indicate the error.
         */
        ERROR_BEGIN(POSIX_TTYNAME, "ttyname.04", (ttyname_spec == NULL), *errno);

            /*
             * The ttyname() function may fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_MAY(POSIX_TTYNAME, EBADF, "ttyname.05.01",
                @!isValid_FileDescId(fildes));

            /*
             * The ttyname() function may fail if:
             *
             * [ENOTTY]
             *
             * The fildes argument does not refer to a terminal.
             */
            ERROR_MAY(POSIX_TTYNAME, ENOTTY, "ttyname.05.02", !is_terminal);

        ERROR_END();

        /*
         * Upon successful completion, ttyname() shall return a pointer to a
         * string.
         */
        REQ("ttyname.03", "On success, ttyname() shall return non-NULL pointer",
           (ttyname_spec != NULL));

        if(is_terminal)
        {
            /*
             * The ttyname() function shall return a pointer to a string
             * containing a null-terminated pathname of the terminal associated
             * with file descriptor fildes.
             */
            REQ("ttyname.01", "ttyname() shall return pathname of the terminal",
               ((path != NULL) => (equals(ttyname_spec, path))));

            /*
             * The maximum length of the terminal name shall be {TTY_NAME_MAX}.
             */
            REQ("ttyname.02", "The maximum pathname length shall be {TTY_NAME_MAX}",
               (isCorrectTerminalName(context, ttyname_spec) != False_Bool3));
        }

        return true;
    }
}

void onTTYName(CallContext context, FileDescId fildes, ErrorCode *errno,
               CString *ttyname_spec)
{
    if(ttyname_spec != NULL && isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes))
    {
        if(equals(getPath_FileDescId(fildes), NULL))
            setPath_FileDescId(fildes, ttyname_spec);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    ttyname_r - find the pathname of a terminal

SYNOPSIS

    #include <unistd.h>

    int ttyname_r(int fildes, char *name, size_t namesize);

DESCRIPTION

    The ttyname_r() function shall store the null-terminated pathname of the
    terminal associated with the file descriptor fildes in the character array
    referenced by name. The array is namesize characters long and should have
    space for the name and the terminating null character. The maximum length
    of the terminal name shall be {TTY_NAME_MAX}.

RETURN VALUE

    If successful, the ttyname_r() function shall return zero. Otherwise, an
    error number shall be returned to indicate the error.

ERRORS

    The ttyname_r() function may fail if:

    [EBADF]
        The fildes argument is not a valid file descriptor.
    [ENOTTY]
        The fildes argument does not refer to a terminal.
    [ERANGE]
        The value of namesize is smaller than the length of the string to be
        returned including the terminating null character.
*/
specification
IntT ttyname_r_spec(CallContext context, FileDescId fildes, CString *name, SizeT namesize)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);
    CString *path = is_terminal ? getPath_FileDescId(fildes) : NULL;

    pre
    {
        if(POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_TERMINAL)
        {
            /* [Implicit precondition] */
            REQ("", "The fildes is a terminal descriptor id", is_terminal);

            /* 
             * The array is namesize characters long and should have space for the
             * name and the terminating null character.
             */
            REQ("app.ttyname_r.01", "The array is not NULL", (name != NULL));
            REQ("app.ttyname_r.01", "The array should have space for the terminal name",
               (isCorrectTerminalNameSize(context, fildes, namesize) == True_Bool3));
        }

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_TERMINAL

            NOT_TERM_DETAIL_COVERAGE(ttyname_r, "ttyname_r()", fildes);

#endif /* #if POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_TERMINAL */

        if(path == NULL)
        {
            return { UnknownTermName, "Unknown terminal name" };
        }
        else if(namesize == length_CString(path) + 1)
        {
            TERM_TYPE_COVERAGE(ExactSpace, "Exact space", fildes);
        }
        else
        {
            TERM_TYPE_COVERAGE(OversizeSpace, "Oversize space", fildes);
        }
    }
    post
    {
        /*
         * [On error,] an error number shall be returned to indicate the error.
         */
        ERROR_BEGIN(POSIX_TTYNAME_R, "ttyname_r.04", (ttyname_r_spec != 0), ttyname_r_spec);

            /*
             * The ttyname_r() function may fail if:
             *
             * [EBADF]
             *
             * [TSF]
             * The fildes argument is not a valid file descriptor.
             */
            ERROR_MAY(POSIX_TTYNAME_R, EBADF, "ttyname_r.05.01",
                @!isValid_FileDescId(fildes));

            /*
             * The ttyname_r() function may fail if:
             *
             * [ENOTTY]
             *
             * [TSF]
             * The fildes argument does not refer to a terminal.
             */
            ERROR_MAY(POSIX_TTYNAME_R, ENOTTY, "ttyname_r.05.02", !is_terminal);

            /*
             * The ttyname_r() function may fail if:
             *
             * [ERANGE]
             *
             * [TSF]
             * The value of namesize is smaller than the length of the string
             * to be returned including the terminating null character.
             */
            ERROR_MAY3(POSIX_TTYNAME_R, ERANGE, "ttyname_r.05.03", (is_terminal ?
                not_Bool3(isCorrectTerminalNameSize(context, fildes, namesize)) : False_Bool3));

        ERROR_END();
        
        /* If successful, the ttyname_r() function shall return zero */
        REQ("ttyname_r.03", "ttyname_r() shall return zero", (ttyname_r_spec == 0));

        if(is_terminal && isCorrectTerminalNameSize(context, fildes, namesize) == True_Bool3)
        {
            /*
             * The ttyname_r() function shall store the null-terminated
             * pathname of the terminal associated with the file descriptor
             * fildes in the character array referenced by name.
             */
            REQ("ttyname_r.01", "ttyname_r() shall store the pathname of the terminal",
                equals(name, getPath_FileDescId(fildes)));

            /* The maximum length of the terminal name shall be {TTY_NAME_MAX} */
            REQ("ttyname_r.02", "The maximum pathname length shall be {TTY_NAME_MAX}",
               (isCorrectTerminalName(context, name) != False_Bool3));
        }

        return true;
    }
}

void onTTYNameR(CallContext context, FileDescId fildes, CString *name,
                SizeT namesize, IntT ttyname_r_spec)
{
    if(ttyname_r_spec == 0 && isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes))
    {
        if(equals(getPath_FileDescId(fildes), NULL))
            setPath_FileDescId(fildes, name);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    unlockpt - unlock a pseudo-terminal master/slave pair

SYNOPSIS

    #include <stdlib.h>

    int unlockpt(int fildes);

DESCRIPTION

    The unlockpt() function shall unlock the slave pseudo-terminal device
    associated with the master to which fildes refers.

    Conforming applications shall ensure that they call unlockpt() before
    opening the slave side of a pseudo-terminal device.

RETURN VALUE

    Upon successful completion, unlockpt() shall return 0. Otherwise, it shall
    return -1 and set errno to indicate the error.

ERRORS

    The unlockpt() function may fail if:

    [EBADF]
        The fildes argument is not a file descriptor open for writing.
    [EINVAL]
        The fildes argument is not associated with a master pseudo-terminal
        device.
*/
specification
IntT unlockpt_spec(CallContext context, FileDescId fildes, ErrorCode *errno)
{
    bool is_invalid_or_read_only = !isValid_FileDescId(fildes) ||
        getAccessMode_FileDescId(fildes) == ReadOnly;

    bool is_ptm = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes) &&
        isPTM_FileDescId(fildes);

    pre
    {
        /* [Consistency of test suite] */
        REQ("", "errno is not NULL", (errno != NULL));

        if(POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM)
        {
            /* [The fildes is PTM descriptor id] */
            REQ("", "The fildes is PTM descriptor id", is_ptm);
        }

        return true;
    }
    coverage C
    {
#if !POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM

            NOT_PTM_COVERAGE(unlockpt, "unlockpt()", fildes);

#endif /* #if POSIX_IO_TERM_FILE_DESC_ID_MUST_REFER_TO_PTM */

        if(getAccessMode_FileDescId(fildes) == ReadOnly)
        {
            if(isTerminalLocked_FileDescId(fildes))
            {
                return { PTM_ReadOnly_Locked, "PTM descriptor id, read only, locked" };
            }
            else
            {
                return { PTM_ReadOnly_Unlocked, "PTM descriptor id, read only, unlocked" };
            }
        }
        else
        {
            if(isTerminalLocked_FileDescId(fildes))
            {
                return { PTM_Write_Locked, "PTM descriptor id, write, locked" };
            }
            else
            {
                return { PTM_Write_Unlocked, "PTM descriptor id, write, unlocked" };
            }
        }
    }
    post
    {
        /*
         * [On error,] it shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN(POSIX_UNLOCKPT, "unlockpt.03", (unlockpt_spec == -1), *errno);

            /*
             * The unlockpt() function may fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a file descriptor open for writing.
             */
            ERROR_MAY(POSIX_UNLOCKPT, EBADF, "unlockpt.04.01", is_invalid_or_read_only);

            /*
             * The unlockpt() function may fail if:
             *
             * [EINVAL]
             *
             * The fildes argument is not associated with a master
             * pseudo-terminal device.
             */
            ERROR_MAY(POSIX_UNLOCKPT, EINVAL, "unlockpt.04.02", !is_ptm);

        ERROR_END();

        /* Upon successful completion, unlockpt() shall return 0 */
        REQ("unlockpt.02", "On success, unlockpt() shall return 0", (unlockpt_spec == 0));

        /*
         * The unlockpt() function shall unlock the slave pseudo-terminal
         * device associated with the master to which fildes refers.
         */
        REQ("?unlockpt.01", "unlockpt() shall unlock the PTS",
           (is_ptm => !isTerminalLocked_FileDescId(fildes)));

        return true;
    }
}

void onUnlockPT(CallContext context, FileDescId fildes, ErrorCode *errno, IntT unlockpt_spec)
{
    if(unlockpt_spec == 0 && isValid_FileDescId(fildes) &&
       isTerminal_FileDescId(fildes) && isPTM_FileDescId(fildes))
    {
        Terminal *ptm = getTerminal_FileDescId(fildes);
        Terminal *pts = isConnected_Terminal(ptm) ? getRemoteTerminal_Terminal(ptm) : NULL;

        unlock_Terminal(ptm);

        if(pts != NULL)
        {
            unlock_Terminal(pts);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

 refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved

NAME

    pwrite, write - write on a file

    See io.file subsystem
*/
specification typedef struct WriteTTYCall WriteTTYCall = {};

WriteTTYCall* create_WriteTTYCall
(
    CallContext context,
    FileDescId fildes,
    CByteArray *buf,
    SizeT nbyte
)
{
    return create(&type_WriteTTYCall, context, fildes, buf, nbyte);
}

specification
void write_tty_spec(CallContext context, FileDescId fildes, CByteArray *buf, SizeT nbyte)
{
    bool is_terminal = isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes);
    
    Terminal *terminal = is_terminal ? getTerminal_FileDescId(fildes) : NULL;

    TermIOS *termios = terminal != NULL ? getTermIOS_Terminal(terminal) : NULL;

    pre
    {
        /* [The fildes is a terminal descriptor id] */
        REQ("", "The fildes is a terminal descriptor id", is_terminal);

        /* [The termios is not NULL] */
        REQ("", "The termios is not NULL", (termios != NULL));

        /*
         * If the value of nbyte is greater than {SSIZE_MAX}, the result is
         * implementation-defined.
         */
        REQ("app.write.13", "nbyte is not greater than {SSIZE_MAX}",
           (nbyte <= (SizeT)max_SSizeT));

        return true;
    }
    coverage C
    {
        AccessMode access_mode = getAccessMode_FileDescId(fildes);
        BlockMode block_mode = getBlockMode_FileDescId(fildes);
        Terminal *terminal = getTerminal_FileDescId(fildes);

        if(block_mode == Blocking)
        {
            switch(access_mode)
            {
            case ReadOnly:
                TERM_OUTPUT_MODE_DETAIL_COVERAGE(BLOCK_RDONLY,
                    "Blocking, read only", terminal);
                break;
            case ReadWrite:
                TERM_OUTPUT_MODE_DETAIL_COVERAGE(BLOCK_RDWR,
                    "Blocking, read write", terminal);
                break;
            default:
                TERM_OUTPUT_MODE_DETAIL_COVERAGE(BLOCK_WRONLY,
                    "Blocking, write only", terminal);
                break;
            }
        }
        else
        {
            switch(access_mode)
            {
            case ReadOnly:
                TERM_OUTPUT_MODE_DETAIL_COVERAGE(NONBLOCK_RDONLY,
                    "Nonblocking, read only", terminal);
                break;
            case ReadWrite:
                TERM_OUTPUT_MODE_DETAIL_COVERAGE(NONBLOCK_RDWR,
                    "Nonblocking, read write", terminal);
                break;
            default:
                TERM_OUTPUT_MODE_DETAIL_COVERAGE(NONBLOCK_WRONLY,
                    "Nonblocking, write only", terminal);
                break;
            }
        }
    }
    post
    {
        /* [The write() function shall block] */
        REQ("", "write() shall block", equals(getBlockedCall(context),
            create_WriteTTYCall(context, fildes, buf, nbyte)));

        return true;
    }
}

void onWriteTTY(CallContext context, FileDescId fildes, CByteArray *buf, SizeT nbyte)
{
    startBlockedCall(context, create_WriteTTYCall(context, fildes, buf, nbyte));
    threadShouldBeRun(context);
}

/********************************************************************/
/**                       Specification Types                      **/
/********************************************************************/

specification typedef struct WriteTTYReturnType WriteTTYReturnType = {};

WriteTTYReturnType* create_WriteTTYReturnType
(
    CallContext context,
    SSizeT returned_value,
    ErrorCode *errno
)
{
    return create(&type_WriteTTYReturnType, context, returned_value, errno);
}

reaction
WriteTTYReturnType* write_tty_return(void)
{
    post
    {
        CallContext context = write_tty_return->context;
        SSizeT returned_value = write_tty_return->returned_value;
        ErrorCode *errno = write_tty_return->errno;

        WriteTTYCall *blocked_call = findBlockedCall(@getBlockedCalls(), context);

        FileDescId fildes = blocked_call->fildes;
        CByteArray *buf = blocked_call->buf;
        SizeT nbyte = blocked_call->nbyte;

        Terminal *pre_terminal = findTerminal(@getAllTerminals(), fildes);
        Terminal *post_terminal = getTerminal_FileDescId(fildes);

        TerminalQueue *pre_output_queue = getOutputQueue_Terminal(pre_terminal);
        TerminalQueue *post_output_queue = getOutputQueue_Terminal(post_terminal);

        TermIOS *termios = getTermIOS_Terminal(pre_terminal);

        AccessMode access_mode = getAccessMode_FileDescId(fildes);
        BlockMode block_mode = getBlockMode_FileDescId(fildes);

        Terminal *remote_terminal = isConnected_Terminal(pre_terminal) ?
            getRemoteTerminal_Terminal(pre_terminal) : NULL;

        TermIOS *remote_termios = remote_terminal != NULL ?
            getTermIOS_Terminal(remote_terminal) : NULL;

        /*
         * [On error,] -1 shall be returned and errno set to indicate the
         * error.
         */
        ERROR_BEGIN(POSIX_WRITE, "write.40.03", (returned_value == -1), *errno);

            /*
             * The write() and [XSI] pwrite() functions shall fail if:
             *
             * [EAGAIN]
             *
             * The O_NONBLOCK flag is set for the file descriptor and the
             * thread would be delayed in the write() operation.
             */
            ERROR_SHALL(POSIX_WRITE, EAGAIN, "write.41.01",
                (!isDisconnected_Terminal(pre_terminal) && block_mode == Nonblocking));

            /*
             * The write() and [XSI] pwrite() functions shall fail if:
             *
             * [EBADF]
             *
             * The fildes argument is not a valid file descriptor open for
             * writing.
             */
            ERROR_SHALL(POSIX_WRITE, EBADF, "write.41.02",
                (!isDisconnected_Terminal(pre_terminal) && access_mode == ReadOnly));

            /*
             * The write() and [XSI] pwrite() functions shall fail if:
             *
             * [EFBIG]
             *
             * The file is a regular file, nbyte is greater than 0, and the
             * starting position is greater than or equal to the offset maximum
             * established in the open file description associated with fildes.
             */
            ERROR_NEVER(POSIX_WRITE, EFBIG, "write.41.04");

            /*
             * The write() and [XSI] pwrite() functions shall fail if:
             *
             * [EINTR]
             *
             * The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_WRITE, EINTR, "write.41.05",
            (
                !isDisconnected_Terminal(pre_terminal) &&
                isBlockedCallInterruptedBySignal(context)
            ));

            /*
             * The write() and [XSI] pwrite() functions shall fail if:
             *
             * [EIO]
             *
             * The process is a member of a background process group attempting
             * to write to its controlling terminal, TOSTOP is set, the process
             * is neither ignoring nor blocking SIGTTOU, and the process group
             * of the process is orphaned. This error may also be returned
             * under implementation-defined conditions.
             */
            ERROR_UNCHECKABLE(POSIX_WRITE, EIO, "write.41.06",
                "don't know how to check");

            /*
             * The write() and [XSI] pwrite() functions may fail if:
             *
             * [ENOBUFS]
             *
             * Insufficient resources were available in the system to perform
             * the operation.
             */
            ERROR_UNCHECKABLE(POSIX_WRITE, ENOBUFS, "write.43.03",
                "don't know how to check");

            /*
             * The write() and [XSI] pwrite() functions shall fail if:
             *
             * [ENOSPC]
             *
             * There was no free space remaining on the device containing the
             * file.
             */
            ERROR_UNCHECKABLE(POSIX_WRITE, ENOSPC, "write.41.07",
                "don't know how to check");

            /*
             * The write() and [XSI] pwrite() functions may fail if:
             *
             * [ENXIO]
             *
             * A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_UNCHECKABLE(POSIX_WRITE, ENXIO, "write.43.04",
                "don't know how to check");

        ERROR_END();

        /*
         * Upon successful completion, write() and pwrite() shall return the
         * number of bytes actually written to the file associated with fildes.
         */
        REQ("write.22.01", "On success, write() shall return the number of bytes",
           (returned_value >= 0));

        /* This number shall never be greater than nbyte */
        REQ("write.22.02", "Returned value shall never be greater than nbyte",
           ((SizeT)returned_value <= nbyte));

        /*
         * Any subsequent write() to the [disconnected] terminal device shall
         * return -1, with errno set to [EIO], until the device is closed.
         */
        REQ("write.40", "Terminal is not disconnected",
            !isDisconnected_Terminal(pre_terminal));

        if(remote_termios != NULL)
        {
            unsigned k;

            CCT intr  = getControlCharacter_TermIOS(remote_termios, SUT_VINTR);
            CCT quit  = getControlCharacter_TermIOS(remote_termios, SUT_VQUIT);
            CCT start = getControlCharacter_TermIOS(remote_termios, SUT_VSTART); 
            CCT stop  = getControlCharacter_TermIOS(remote_termios, SUT_VSTOP); 
            CCT susp  = getControlCharacter_TermIOS(remote_termios, SUT_VSUSP);

            bool find_any   = false;
            bool find_brk   = false;
            bool find_intr  = false;
            bool find_quit  = false;
            bool find_start = false;
            bool find_stop  = false;
            bool find_susp  = false;

            write_Terminal(pre_terminal, buf, (unsigned)returned_value);

            processOutputQueue_Terminal(pre_terminal);

            for(k = 0; k < size_TerminalQueue(pre_output_queue); k++)
            {
                TerminalDataItem *item = getItem_TerminalQueue(pre_output_queue, k);

                if(isBreakCondition_TerminalDataItem(item))
                {
                    if(!remote_termios->iflag->ignbrk && remote_termios->iflag->brkint)
                    {
                        find_brk = true;
                    }
                }
                else
                {
                    ByteT c = getByte_TerminalDataItem(item);

                    if(remote_termios->iflag->ixany)
                    {
                        if(POSIX_IO_TERM_CONTROL_CHARACTERS_MUST_RESTART_OUTPUT)
                        {
                            find_any = true;
                        }
                        else
                        {
                            if(!isDiscardedControlCharacter_TermIOS(remote_termios, c))
                            {
                                find_any = true;
                            }
                        }
                    }

                    if(remote_termios->iflag->ixon)
                    {
                        if(c == start) find_start = true;
                        if(c == stop)  find_stop  = true;
                    }

                    if(remote_termios->lflag->isig)
                    {
                        if(c == intr)  find_intr  = true;
                        if(c == quit)  find_quit  = true; 
                        if(c == susp)  find_susp  = true;
                    }
                }
            }

            /*
             * If IGNBRK is not set and BRKINT is set, the break condition
             * shall flush the input and output queues.
             */
            REQ("?read.60.02.01", "Break condition shall flush the input queue",
               (find_brk && !remote_termios->lflag->noflsh =>
                 isEmpty_TerminalQueue(getInputQueue_Terminal(remote_terminal))));

            REQ("?read.60.02.01", "Break condition shall flush the output queue",
               (find_brk && !remote_termios->lflag->noflsh =>
                 isEmpty_TerminalQueue(getOutputQueue_Terminal(remote_terminal))));

            /* if the terminal is the controlling terminal */
            if(isControlling_Terminal(remote_terminal))
            {
                ProcessIdObj *fpgroupid = getForegroundPGroupId_Terminal(remote_terminal);

                if(fpgroupid != NULL && !isWrong_ProcessId(*fpgroupid))
                {
                    /*
                     * the break condition shall generate a single SIGINT signal
                     * to that foreground process group.
                     */
                    REQ("?read.60.02.02", "Break condition generates a SIGINT signal",
                       (find_brk => signalShouldBeSentToProcessGroup(*fpgroupid, SUT_SIGINT)));

                    /* 
                     * Generates a SIGINT signal which is sent to all processes
                     * in the foreground process group for which the terminal
                     * is the controlling terminal.
                     */
                    REQ("?read.61.01", "INTR generates a SIGINT signal",
                       (find_intr => signalShouldBeSentToProcessGroup(*fpgroupid, SUT_SIGINT)));

                    /*
                     * Generates a SIGQUIT signal which is sent to all
                     * processes in the foreground process group for which
                     * the terminal is the controlling terminal.
                     */
                    REQ("?read.62.01", "QUIT generates a SIGQUIT signal",
                       (find_quit => signalShouldBeSentToProcessGroup(*fpgroupid, SUT_SIGQUIT)));                

                    /*
                     * Receipt of the SUSP character shall cause a SIGTSTP
                     * signal to be sent to all processes in the foreground
                     * process group for which the terminal is the
                     * controlling terminal.
                     */
                    REQ("?read.63.01", "SUSP generates a SIGTSTP signal",
                       (find_susp => signalShouldBeSentToProcessGroup(*fpgroupid, SUT_SIGTSTP)));
                }
            }

            /* A received input character shall restart output */
            REQ("?read.77", "Input character shall restart output",
               (find_any => !isOutputSuspended_Terminal(remote_terminal)));

            /* A received START character shall restart output */
            REQ("?read.65.01", "START character shall restart output",
               (find_start => !isOutputSuspended_Terminal(remote_terminal)));

            /* A received STOP character shall suspend output */
            REQ("?read.64.01", "STOP character shall suspend output",
               (find_stop => isOutputSuspended_Terminal(remote_terminal)));
        }

        return true;
    }
}

void onWriteTTYReturn(CallContext context, SSizeT write_tty_return,
                      ErrorCode *errno, TimeInterval time)
{
    WriteTTYCall *blocked_call = finishBlockedCall(context);

    if(write_tty_return > 0)
    {
        unsigned res = (unsigned)write_tty_return;
        FileDescId fildes = blocked_call->fildes;
        CByteArray *buf = blocked_call->buf;
        Terminal *terminal = getTerminal_FileDescId(fildes);

        write_Terminal(terminal, buf, res);
        processOutputQueue_Terminal(terminal);
        transmit_Terminal(terminal, time.minMark);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    login_tty -- Prepare a terminal for login

SYNOPSIS

    #include <utmp.h> 
    int login_tty (int fdr);

DESCRIPTION

    The login_tty() function shall prepare the terminal device referenced by 
    the file descriptor fdr. This function shall create a new session, make the
    terminal the controlling terminal for the current process, and set the 
    standard input, output, and error streams of the current process to the 
    terminal. If fdr is not the standard input, output or error stream, then 
    login_tty() shall close fdr.

RETURN VALUE

    On success, login_tty() shall return zero;otherwise -1 is returned, and 
    errno shall be set appropriately.

ERRORS

    [ENOTTY]   
    fdr does not refer to a terminal device.
*/

specification
IntT login_tty_spec(CallContext context, FileDescId fdr, ErrorCode* errno)
{
    bool is_terminal = isValid_FileDescId(fdr) && isTerminal_FileDescId(fdr);

    pre
    {

        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        /*
         * otherwise -1 is returned, and errno shall be set appropriately.
         */
        ERROR_BEGIN(LSB_LOGIN_TTY, "login_tty.04.02", login_tty_spec==-1, *errno)

        /*
         * [ENOTTY] fdr does not refer to a terminal device.
         */
        ERROR_SHALL(LSB_LOGIN_TTY, ENOTTY, "login_tty.05.01", !is_terminal)

        ERROR_END()

        /*
         * On success, login_tty() shall return zero;
         */
        REQ("login_tty.04.01", "Function shall return zero", login_tty_spec==0);




        return true;
    }

}


void login_tty_model(CallContext context, FileDescId fdr)
{
    /*
     * This function
     *
     * shall create a new session,
     */
    IMPLEMENT_REQ("login_tty.02.01");

    /*
     * This function
     *
     * make the terminal the controlling terminal for the current process,
     */
    IMPLEMENT_REQ("login_tty.02.02");


    /*
     * This function
     *
     * and set the standard input, output, and error streams of the current process to 
     * the terminal
     */
    IMPLEMENT_REQ("login_tty.02.03");

    /*
     * If fdr is not the standard input, output or error stream, then login_tty() 
     * shall close fdr.
     */
    IMPLEMENT_REQ("login_tty.03");

}

void onLoginTTY(CallContext context, FileDescId fdr, IntT login_tty_spec)
{
    if (login_tty_spec==0)
    {
        login_tty_model(context, fdr);
    }

}

/*
 * Returns true, iff speed value is equal to one of the values defined above.
 */
bool isKnown_Speed(SpeedT speed)
{
    switch(speed)
    {
    case SUT_B0:
    case SUT_B50:
    case SUT_B75:
    case SUT_B110:
    case SUT_B134:
    case SUT_B150:
    case SUT_B200:
    case SUT_B300:
    case SUT_B600:
    case SUT_B1200:
    case SUT_B1800:
    case SUT_B2400:
    case SUT_B4800:
    case SUT_B9600:
    case SUT_B19200:
    case SUT_B38400:
        return true;
    }
    return false;
}

/*
 * Implementation-defined checks of the input/output speed.
 */
Bool3 isValid_InputSpeed(SpeedT speed)
{
    /* [Implementation-defined check of the input speed] */
    return Unknown_Bool3;
}

Bool3 isValid_OutputSpeed(SpeedT speed)
{
    /* [Implementation-defined check of the output speed] */
    return Unknown_Bool3;
}

Bool3 isValid_Speed(SpeedT speed)
{
    /* [Implementation-defined check of the input and output speeds] */
    return Unknown_Bool3;
}

/*
 * This type represents input modes
 *   The Open Group Base Specifications Issue 6
 *   IEEE Std 1003.1, 2004 Edition
 *   Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved
 *   
 *   See section 'Base Definitions / 11. General Terminal Interface /
 *     11.2 Parameters that Can be Set / 11.2.2 Input Modes'.
 */
specification typedef struct IFlag IFlag = {};

IFlag* create_IFlag
(
    bool brkint,        /* Signal interrupt on break */
    bool icrnl,         /* Map CR to NL on input */
    bool ignbrk,        /* Ignore break condition */
    bool igncr,         /* Ignore CR */
    bool ignpar,        /* Ignore characters with parity errors */
    bool inlcr,         /* Map NL to CR on input */
    bool inpck,         /* Enable input parity check */
    bool istrip,        /* Strip character */
    bool ixany,         /* Enable any character to restart output */
    bool ixoff,         /* Enable start/stop input control */
    bool ixon,          /* Enable start/stop output control */
    bool parmrk         /* Mark parity errors */
)
{
    return create(&type_IFlag,
        brkint, icrnl, ignbrk, igncr, ignpar, inlcr,
        inpck, istrip, ixany, ixoff, ixon, parmrk);
}

IFlag* default_IFlag(void)
{
    return create_IFlag
    (
        false,          /* brkint */
        false,          /* icrnl  */
        false,          /* ignbrk */
        false,          /* igncr  */
        false,          /* ignpar */
        false,          /* inlcr  */
        false,          /* inpck  */
        false,          /* istrip */
        false,          /* ixany  */
        false,          /* ixoff  */
        false,          /* ixon   */
        false           /* parmrk */
    );
}

/*
 * This type represents output modes
 *   The Open Group Base Specifications Issue 6
 *   IEEE Std 1003.1, 2004 Edition
 *   Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved
 *   
 *   See section 'Base Definitions / 11. General Terminal Interface /
 *     11.2 Parameters that Can be Set / 11.2.3 Output Modes'.
 */
specification typedef struct OFlag OFlag = {};

OFlag* create_OFlag
(
    bool opost,         /* Post-process output */
    bool onlcr,         /* Map NL to CR-NL on output */
    bool ocrnl,         /* Map CR to NL on output */
    bool onocr,         /* No CR output at column 0 */
    bool onlret,        /* NL performs CR function */
    bool ofill,         /* Use fill characters for delay */
    bool ofdel,         /* Fill is DEL else NULL */
    NLDelay nldly,      /* Select newline delays */
    CRDelay crdly,      /* Select carriage-return delays */
    TBDelay tbdly,      /* Select horizontal-tab delays */
    BSDelay bsdly,      /* Select backspace delays */
    VTDelay vtdly,      /* Select vertical-tab delays */
    FFDelay ffdly       /* Select form-feed delays */
)
{
    return create(&type_OFlag,
        opost, onlcr, ocrnl, onocr, onlret, ofill, ofdel,
        nldly, crdly, tbdly, bsdly, vtdly, ffdly);
}

OFlag* default_OFlag(void)
{
    return create_OFlag
    (
        false,          /* opost  */
        false,          /* onlcr  */
        false,          /* ocrnl  */
        false,          /* onocr  */
        false,          /* onlret */
        false,          /* ofill  */
        false,          /* ofdel  */
        NL0,            /* nldly  */
        CR0,            /* crdly  */
        TAB0,           /* tbdly  */
        BS0,            /* bsdly  */
        VT0,            /* vtdly  */
        FF0             /* ffdly  */
    );
}

/*
 * This type represents control modes
 *   The Open Group Base Specifications Issue 6
 *   IEEE Std 1003.1, 2004 Edition
 *   Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved
 *   
 *   See section 'Base Definitions / 11. General Terminal Interface /
 *     11.2 Parameters that Can be Set / 11.2.4 Control Modes'.
 */
specification typedef struct CFlag CFlag = {};

CFlag* create_CFlag
(
    CSize csize,        /* Character size */
    bool cstopb,        /* Send two stop bits, else one */
    bool cread,         /* Enable receiver */
    bool parenb,        /* Parity enable */
    bool parodd,        /* Odd parity, else even */
    bool hupcl,         /* Hang up on last close */
    bool clocal         /* Ignore modem status lines */
)
{
    return create(&type_CFlag,
        csize, cstopb, cread, parenb, parodd, hupcl, clocal);
}

CFlag* default_CFlag(void)
{
    return create_CFlag
    (
        CS8,            /* csize   */
        false,          /* cstopb  */
        false,          /* cread   */
        false,          /* parentb */
        false,          /* parodd  */
        false,          /* hupcl   */
        false           /* clocal  */
    );
}

/*
 * This type represents local modes
 *   The Open Group Base Specifications Issue 6
 *   IEEE Std 1003.1, 2004 Edition
 *   Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved
 *   
 *   See section 'Base Definitions / 11. General Terminal Interface /
 *     11.2 Parameters that Can be Set / 11.2.5 Local Modes'.
 */
specification typedef struct LFlag LFlag = {};

LFlag* create_LFlag
(
    bool echo,          /* Enable echo */
    bool echoe,         /* Echo erase character as error-correcting backspace */
    bool echok,         /* Echo KILL */
    bool echonl,        /* Echo NL */
    bool icanon,        /* Canonical input (erase and kill processing) */
    bool iexten,        /* Enable extended input character processing */
    bool isig,          /* Enable signals */
    bool noflsh,        /* Disable flush after interrupt or quit */
    bool tostop         /* Send SIGTTOU for background output */
)
{
    return create(&type_LFlag,
        echo, echoe, echok, echonl, icanon, iexten, isig, noflsh, tostop);
}

LFlag* default_LFlag(void)
{
    return create_LFlag
    (
        false,          /* echo   */
        false,          /* echoe  */
        false,          /* echok  */
        false,          /* echonl */
        false,          /* icanon */
        false,          /* iexten */
        false,          /* isig   */
        false,          /* noflsh */
        false           /* tostop */
    );
}

/* 
 * This type represents cc_t type
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'termios.h'.
 */
specification typedef CCT  CCTObj = {}; 

CCTObj* create_CCTObj(CCT value)
{
  return create(&type_CCTObj, value);
}

/*
 * Returns true, iff cc value is equal to one of the CC values defined above.
 */
bool isKnown_CC(unsigned cc)
{
    switch(cc)
    {
    case SUT_VEOF:
    case SUT_VEOL:
    case SUT_VERASE:
    case SUT_VINTR:
    case SUT_VKILL:
    case SUT_VMIN:
    case SUT_VQUIT:
    case SUT_VSUSP:
    case SUT_VTIME:
    case SUT_VSTART:
    case SUT_VSTOP:
        return true;
    }
    return false;
}

/* 
 * This type represents struct termios
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'termios.h'.
 */
specification typedef struct TermIOS TermIOS = {};

TermIOS* create_TermIOS
(
    TermIOSPtr address,
    SpeedT ispeed,          /* Input baud rate */      
    SpeedT ospeed,          /* Output baud rate */
    IFlag *iflag,           /* Input modes */
    OFlag *oflag,           /* Output modes */
    CFlag *cflag,           /* Control modes */
    LFlag *lflag,           /* Local modes */
    CCT *cc                 /* Control characters */
)
{
    int i;
    TermIOS *termios = NULL;
        
    List* cclist = create_List(&type_CCTObj);
        
    for(i = 0; i < SUT_NCCS; i++)
        append_List(cclist, create_CCTObj(cc != NULL ? cc[i] : (CCT)0));
            
    termios = create(&type_TermIOS,
        address, ispeed, ospeed, iflag, oflag, cflag, lflag, cclist);

    return termios;
}

TermIOS* default_TermIOS(void)
{
    return create_TermIOS
    (
        NULL_VoidTPtr,      /* address */
        0,                  /* ispeed  */
        0,                  /* ospeed  */
        default_IFlag(),    /* iflag   */
        default_OFlag(),    /* oflag   */
        default_CFlag(),    /* cflag   */
        default_LFlag(),    /* lflag   */
        NULL                /* cc      */
    );
}

bool equals_TermIOS(TermIOS *lhs, TermIOS *rhs)
{
    int i;
    bool equals_cc = true;
    CCTObj* cct_lhs = NULL;
    CCTObj* cct_rhs = NULL;

    if(lhs == NULL || rhs == NULL)
        return lhs == rhs;

    for(i = 0; i < SUT_NCCS; i++)
    {
        cct_lhs = get_List(lhs->cclist, i);
        cct_rhs = get_List(rhs->cclist, i);        
        if(!(equals_cc = *cct_lhs == *cct_rhs)) break;
    }

    return equals_cc
        && lhs->ispeed == rhs->ispeed
        && lhs->ospeed == rhs->ospeed
        && equals(lhs->iflag, rhs->iflag)
        && equals(lhs->oflag, rhs->oflag)
        && equals(lhs->cflag, rhs->cflag)
        && equals(lhs->lflag, rhs->lflag);
}

CCT getControlCharacter_TermIOS(TermIOS *termios, CC cc)
{
    CCTObj* ccobj = NULL;
    
    assertion((termios != NULL),
        "getControlCharacter_TermIOS: termios is NULL");
    assertion((cc < SUT_NCCS),
        "getControlCharacter_TermIOS: cc is out of range");

    ccobj = get_List(termios->cclist, cc);    

    return *ccobj;
}

void setControlCharacter_TermIOS(TermIOS *termios, CC cc, CCT value)
{
    assertion((termios != NULL),
        "setControlCharacter_TermIOS: termios is NULL");
    assertion((cc < SUT_NCCS),
        "setControlCharacter_TermIOS: cc is out of range");

    set_List(termios->cclist, cc, create_CCTObj(value));
}

bool isDiscardedControlCharacter_TermIOS(TermIOS *termios, CCT value)
{
    assertion((termios != NULL),
        "isDiscardedControlCharacter_TermIOS: termios is NULL");

    if(termios->lflag->isig)
    {
        if(value == getControlCharacter_TermIOS(termios, SUT_VINTR))
            return true;
        if(value == getControlCharacter_TermIOS(termios, SUT_VQUIT))
            return true;
        if(value == getControlCharacter_TermIOS(termios, SUT_VSUSP))
            return true;
    }

    if(termios->lflag->icanon)
    {
        if(value == getControlCharacter_TermIOS(termios, SUT_VERASE))
            return true;
        if(value == getControlCharacter_TermIOS(termios, SUT_VKILL))
            return true;
        if(value == getControlCharacter_TermIOS(termios, SUT_VEOF))
            return true;
    }

    if(termios->iflag->ixon)
    {
        if(value == getControlCharacter_TermIOS(termios, SUT_VSTOP))
            return true;
        if(value == getControlCharacter_TermIOS(termios, SUT_VSTART))
            return true;
    }

    return false;
}

static bool isUniqueValue_CC(TermIOS *termios, CC cc)
{
    if(cc == SUT_VMIN || cc == SUT_VTIME)
        return false;

    if(!termios->lflag->icanon)
    {
        if(cc == SUT_VEOL || cc == SUT_VEOF || cc == SUT_VERASE || cc == SUT_VKILL)
            return false;
    }

    return true;
}

bool checkControlCharactersUniqueness_TermIOS(TermIOS *termios)
{
    unsigned i, j;

    assertion((termios != NULL),
        "checkControlCharactersUniqueness_TermIOS: termios is NULL");

    for(i = 0; i < SUT_NCCS; i++)
    for(j = 0; j < i; j++)
    {
        CCTObj* cciobj = get_List(termios->cclist, i);    
        CCTObj* ccjobj = get_List(termios->cclist, j);    

        CCT cci = *cciobj;
        CCT ccj = *ccjobj;

        if(isKnown_CC(i) && isKnown_CC(j) && cci == ccj)
        {
            if(isUniqueValue_CC(termios, i) && isUniqueValue_CC(termios, j))
            {
                traceFormattedUserInfo("cc[%d]==cc[%d]==%d", i, j, cci);
                return false;
            }
        }
    }

    return true;
}

TermIOS* getTermIOS(TermIOSPtr address)
{
    return getObjectInMemory(address);
}

/* 
 * This type represents struct winsize
 *   Linux Standard Base Core Specification 3.1
 *   Copyright (c) 2004, 2005 Free Standards Group
 *
 *   See section 'Data Definitions for libc', header file 'sys/ioctl.h'.
 */
specification typedef struct WinSize WinSize = {};

WinSize* create_WinSize
(
    UShortT row,
    UShortT col,
    UShortT xpixel,
    UShortT ypixel
)
{
    return create(&type_WinSize, row, col, xpixel, ypixel);
}

WinSize* default_WinSize(void)
{
    return create_WinSize(0, 0, 0, 0);
}

/********************************************************************/
/**                   Terminal descriptor model                    **/
/********************************************************************/

specification typedef struct TerminalDescriptor TerminalDescriptor = {};

TerminalDescriptor* create_TerminalDescriptor(FileDescId cpart)
{
    return create(&type_TerminalDescriptor, cpart);
}

TerminalDescriptor *default_TerminalDescriptor(void)
{
    return create_TerminalDescriptor(WrongFileDescId);
}

FileDescId getCPart_TerminalDescriptor(TerminalDescriptor *term_desc)
{
    assertion((term_desc != NULL),
        "getCPart_TerminalDescriptor: term_desc is NULL");

    return term_desc->cpart;
}

void setCPart_TerminalDescriptor(TerminalDescriptor *term_desc, FileDescId cpart)
{
    assertion((term_desc != NULL),
        "setCPart_TerminalDescriptor: term_desc is NULL");

    term_desc->cpart = cpart;
}

/********************************************************************/
/**                   Terminal data item model                     **/
/********************************************************************/

specification typedef struct TerminalDataItem TerminalDataItem = {};

TerminalDataItem* create_TerminalDataItem(ByteT byte, bool brk, TimeInterval time)
{
    return create(&type_TerminalDataItem, byte, brk, false, time);
}

TerminalDataItem* create_Byte(ByteT byte, TimeInterval time)
{
    return create_TerminalDataItem(byte, false, time);
}

TerminalDataItem* create_BreakCondition(TimeInterval time)
{
    return create_TerminalDataItem(0, true, time);
}

bool isBreakCondition_TerminalDataItem(TerminalDataItem *item)
{
    assertion((item != NULL),
        "isBreakCondition_TerminalDataItem: item is NULL");

    return item->brk;
}

bool isByte_TerminalDataItem(TerminalDataItem *item)
{
    assertion((item != NULL),
        "isByte_TerminalDataItem: item is NULL");

    return !item->brk;
}

ByteT getByte_TerminalDataItem(TerminalDataItem *item)
{
    assertion((item != NULL),
        "getByte_TerminalDataItem: item is NULL");
    assertion(isByte_TerminalDataItem(item),
        "getByte_TerminalDataItem: item is break condition");

    return item->byte;
}

void setByte_TerminalDataItem(TerminalDataItem *item, ByteT byte)
{
    assertion((item != NULL),
        "setByte_TerminalDataItem: item is NULL");

    item->brk  = false;
    item->byte = byte;
}

TimeInterval getTime_TerminalDataItem(TerminalDataItem *item)
{
    assertion((item != NULL),
        "getTime_TerminalDataItem: item is NULL");

    return item->time;
}

void setTime_TerminalDataItem(TerminalDataItem *item, TimeInterval time)
{
    assertion((item != NULL),
        "setTime_TerminalDataItem: item is NULL");

    item->time = time;
}

bool isProcessed_TerminalDataItem(TerminalDataItem *item)
{
    assertion((item != NULL),
        "isProcessed_TerminalDataItem: item is NULL");

    return item->processed;
}

void setProcessStatus_TerminalDataItem(TerminalDataItem *item, bool processed)
{
    assertion((item != NULL),
        "setProcessStatus_TerminalDataItem: item is NULL");

    item->processed = processed;
}

/********************************************************************/
/**                     Terminal queue model                       **/
/********************************************************************/

TerminalQueue* create_TerminalQueue(void)
{
    return create_List(&type_TerminalDataItem);
}

unsigned size_TerminalQueue(TerminalQueue *queue)
{
    assertion((queue != NULL),
        "size_TerminalQueue: queue is NULL");

    return size_List(queue);
}

bool isEmpty_TerminalQueue(TerminalQueue *queue)
{
    assertion((queue != NULL),
        "isEmpty_TerminalQueue: queue is NULL");

    return isEmpty_List(queue);
}

bool isBreakCondition_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);

    return item->brk;
}

bool isByte_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);

    return !item->brk;
}

bool isInputPrefix_Terminal(Terminal *terminal, CByteArray *array)
{
    unsigned k, l, size1, size2;
    ByteT c;
    TermIOS *termios;
    TerminalQueue *queue;
    CByteArray *prefix;

    assertion((terminal != NULL),
        "isInputPrefix_Terminal: terminal is NULL");
    assertion((array != NULL),
        "isInputPrefix_Terminal: array is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "isInputPrefix_Terminal: termios is NULL");

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "isInputPrefix_Terminal: queue is NULL");

    if((size1 = size_CByteArray(array)) == 0)
        return true;

    if((size2 = size_TerminalQueue(queue)) < size1)
        return false;

    for(k = l = 0; k < size2; k++)
    {
        if(isBreakCondition_TerminalQueue(queue, k))
            continue;

        c = getByte_TerminalQueue(queue, k);

        if(isDiscardedControlCharacter_TermIOS(termios, c))
            continue;

        if(byteAt_CByteArray(array, l) != c)
            return false;

        if(++l == size1)
            return true;
    }

    return false;
}

TerminalDataItem* getItem_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    assertion((queue != NULL),
        "getItem_TerminalQueue: queue is NULL");
    assertion((i < size_TerminalQueue(queue)),
        "getItem_TerminalQueue: index i is out of range");

    return get_List(queue, i);
}

ByteT getByte_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);
    
    assertion(isByte_TerminalDataItem(item),
        "getByte_TerminalQueue: break condition was found");

    return item->byte;
}

void setByte_TerminalQueue(TerminalQueue *queue, unsigned i, ByteT byte)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);
    
    setByte_TerminalDataItem(item, byte);
}

bool isProcessed_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);

    return isProcessed_TerminalDataItem(item);
}

void setProcessStatus_TerminalQueue(TerminalQueue *queue, unsigned i, bool processed)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);

    setProcessStatus_TerminalDataItem(item, processed);
}

CByteArray* getByteArray_TerminalQueue(TerminalQueue *queue, unsigned i, unsigned j)
{
    unsigned k, size;
    CByteArray *array;

    assertion((queue != NULL),
        "getByteArray_TerminalQueue: queue is NULL");
    assertion((i <= j),
        "getByteArray_TerminalQueue: index i is greater than j");
    assertion((j < size_TerminalQueue(queue)),
        "getByteArray_TerminalQueue: index j is out of range");

    size = j - i + 1;
    array = create_CByteArray(NULL, size);

    for(k = 0; k < size; k++)
    {
        TerminalDataItem *item = getItem_TerminalQueue(queue, i + k);

        assertion(!isBreakCondition_TerminalDataItem(item),
            "getByteArray_TerminalQueue: break condition was found");
       
        setByteAt_CByteArray(array, k, getByte_TerminalDataItem(item));
    }

    return array;
}

TimeInterval getTime_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);

    return item->time;
}

void setTime_TerminalQueue(TerminalQueue *queue, unsigned i, TimeInterval time)
{
    TerminalDataItem *item = getItem_TerminalQueue(queue, i);

    item->time = time;
}

void appendAll_TerminalQueue(TerminalQueue *to, TerminalQueue *from)
{
    assertion((to != NULL),
        "appendAll_TerminalQueue: to is NULL");
    assertion((from != NULL),
        "appendAll_TerminalQueue: from is NULL");

    appendAll_List(to, from);
}

void appendItem_TerminalQueue(TerminalQueue *queue, TerminalDataItem *item)
{
    assertion((queue != NULL),
        "appendItem_TerminalQueue: queue is NULL");
    assertion((item != NULL),
        "appendItem_TerminalQueue: item is NULL");

    append_List(queue, item);
}

void appendBreakCondition_TerminalQueue(TerminalQueue *queue, TimeInterval time)
{
    appendItem_TerminalQueue(queue, create_BreakCondition(time));
}

void appendByte_TerminalQueue(TerminalQueue *queue, ByteT byte, TimeInterval time)
{
    appendItem_TerminalQueue(queue, create_Byte(byte, time));
}

void appendByteArray_TerminalQueue(TerminalQueue *queue, CByteArray *array, TimeInterval time)
{
    unsigned k;

    assertion((queue != NULL),
        "appendByteArray_TerminalQueue: queue is NULL");
    assertion((array != NULL),
        "appendByteArray_TerminalQueue: array is NULL");

    for(k = 0; k < size_CByteArray(array); k++)
        appendByte_TerminalQueue(queue, byteAt_CByteArray(array, k), time);
}

void insertItem_TerminalQueue(TerminalQueue *queue, unsigned i, TerminalDataItem *item)
{
    assertion((queue != NULL),
        "insertItem_TerminalQueue: queue is NULL");
    assertion((i <= size_TerminalQueue(queue)),
        "insertItem_TerminalQueue: index i is out of range");
    assertion((item != NULL),
        "insertItem_TerminalQueue: item is NULL");

    add_List(queue, i, item);
}

void insertBreakCondition_TerminalQueue(TerminalQueue *queue, unsigned i, TimeInterval time)
{
    insertItem_TerminalQueue(queue, i, create_BreakCondition(time));
}

void insertByte_TerminalQueue(TerminalQueue *queue, unsigned i, ByteT byte, TimeInterval time)
{
    insertItem_TerminalQueue(queue, i, create_Byte(byte, time));
}

void removeItems_TerminalQueue(TerminalQueue *queue, unsigned i, unsigned j)
{
    unsigned k;

    assertion((queue != NULL),
        "removeItems_TerminalQueue: queue is NULL");
    assertion((i <= j),
        "removeItems_TerminalQueue: index i is greater than j");
    assertion((j < size_TerminalQueue(queue)),
        "removeItems_TerminalQueue: index j is out of range");

    for(k = i; k <= j; k++) remove_List(queue, i);
}

void removeItem_TerminalQueue(TerminalQueue *queue, unsigned i)
{
    assertion((queue != NULL),
        "removeItem_TerminalQueue: queue is NULL");
    assertion((i < size_TerminalQueue(queue)),
        "removeItem_TerminalQueue: index i is out of range");

    remove_List(queue, i);
}

void clear_TerminalQueue(TerminalQueue *queue)
{
    assertion((queue != NULL),
        "clear_TerminalQueue: queue is NULL");

    clear_List(queue);
}

/********************************************************************/
/**                  Terminal connection model                     **/
/********************************************************************/

specification typedef struct TerminalConnection TerminalConnection = {};

TerminalConnection* create_TerminalConnection
(
    Bool3 status,                       /* Connection status */
    Bool3 disconnect,                   /* Supports disconnection function */
    Object *remote,                     /* Remote terminal */
    TimeUnit time                       /* Transmission time */
)
{
    return create(&type_TerminalConnection, status, disconnect, remote, time);
}

TerminalConnection* default_TerminalConnection(void)
{
    return create_TerminalConnection
    (
        False_Bool3,                    /* Connection status */
        Unknown_Bool3,                  /* Supports disconnection function */
        NULL,                           /* Remote terminal */
        0                               /* Transmission time */
    );
}

/********************************************************************/
/**                        Terminal model                          **/
/********************************************************************/

specification typedef struct Terminal Terminal = {};

Terminal* create_Terminal
(
    TerminalType type,                  /* Terminal type */
    TransmissionMode mode,              /* Transmission mode */
    Bool3 split_io_status,              /* Split I/O status */
    Bool3 control_status,               /* Controlling status */
    Bool3 login_status,                 /* Login status */
    CString *login,                     /* Login name */
    ProcessIdObj *sessionid,            /* Session id */
    ProcessIdObj *fpgroupid,            /* Foreground process group id */
    List *termios_list,                 /* I/O attributes list */
    WinSize *wsize,                     /* Window size */
    FileDescId ptm_desc_id,             /* PTM descriptor id */
    CString *pts_name,                  /* PTS name */
    bool locked,                        /* Locked */
    TerminalQueue *input_queue,         /* Input queue */
    TerminalQueue *output_queue,        /* Output queue */
    unsigned column,                    /* Column */
    TimeInterval read_time,             /* Read time interval */
    bool input_suspended,               /* Input suspension status */
    bool output_suspended,              /* Output suspension status */
    TerminalConnection *connection      /* Terminal connection */
)
{
    return create(&type_Terminal,
        type, mode, split_io_status, control_status, login_status, login,
        sessionid, fpgroupid, termios_list, wsize, ptm_desc_id, pts_name,
        locked, input_queue, output_queue, column, read_time, input_suspended,
        output_suspended, connection);
}

Terminal* default_Terminal(void)
{
    return create_Terminal
    (
        UnknownTerminalType,            /* Terminal type */
        UnknownTransmissionMode,        /* Transmission mode */
        Unknown_Bool3,                  /* Split I/O status */
        Unknown_Bool3,                  /* Controlling status */
        Unknown_Bool3,                  /* Login status */
        NULL,                           /* Login name */
        NULL,                           /* Session id */
        NULL,                           /* Foreground process group id*/
        create_List(&type_TermIOS),     /* IO attributes list */
        NULL,                           /* Window size */
        WrongFileDescId,                /* PTM descriptor id */
        NULL,                           /* PTS name */
        true,                           /* Locked */
        create_TerminalQueue(),         /* Input queue */
        create_TerminalQueue(),         /* Output queue */
        0,                              /* Column */
        overallTimeInterval,            /* Read time interval */
        false,                          /* Input suspension status */
        false,                          /* Output suspension status */
        default_TerminalConnection()    /* Terminal connection */
    );
}

bool isReal_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isReal_Terminal: terminal is NULL");

    return terminal->type == TTY;
}

bool isPT_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isPT_Terminal: terminal is NULL");

    return terminal->type == PTM || terminal->type == PTS;
}

bool isPTM_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isPTM_Terminal: terminal is NULL");

    return terminal->type == PTM;
}

bool isPTS_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isPTS_Terminal: terminal is NULL");

    return terminal->type == PTS;
}

void setType_Terminal(Terminal *terminal, TerminalType type)
{
    assertion((terminal != NULL),
        "setType_Terminal: terminal is NULL");

    terminal->type = type;
}

Terminal* getControllingTerminal_ProcessId(ProcessId processid)
{
    int i, size;
    ProcessId sessionid = getSessionId_ProcessId(processid);
    FileSystem *file_system = getFileSystem_SystemId(processid.system);
    CString *cterm = getControllingTerminalName_ProcessId(processid);

    if(file_system == NULL || cterm == NULL)
        return NULL;

    size = size_Map(file_system->files);
    for(i = 0; i < size; i++)
    {
        File *file = get_Map(file_system->files, key_Map(file_system->files, i));
        if(isTerminal_File(file))
        {
            Terminal *terminal = file->descriptor;

            if(isControlling_Terminal(terminal))
            {
                ProcessIdObj *cterm_sessionid = getSessionId_Terminal(terminal);

                if(cterm_sessionid != NULL && equals_ProcessId(*cterm_sessionid, sessionid))
                    return terminal;
            }
        }
    }

    return NULL;
}

Bool3 getSplitIOStatus_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getSplitIOStatus_Terminal: terminal is NULL");

    return terminal->split_io_status;
}

void setSplitIOStatus_Terminal(Terminal *terminal, Bool3 split_io_status)
{
    assertion((terminal != NULL),
        "setSplitIOStatus_Terminal: terminal is NULL");

    terminal->split_io_status = split_io_status;
}

bool isSplittedIO_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isSplittedIO_Terminal: terminal is NULL");

    return terminal->split_io_status == True_Bool3;
}

bool isNotSplittedIO_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isNotSplittedIO_Terminal: terminal is NULL");

    return terminal->split_io_status == False_Bool3;
}

void splitIO_Terminal(Terminal *terminal)
{
    setSplitIOStatus_Terminal(terminal, True_Bool3);
}

void mergeIO_Terminal(Terminal *terminal)
{
    setSplitIOStatus_Terminal(terminal, False_Bool3);
}

Bool3 getConnectionStatus_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getConnectionStatus_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "getConnectionStatus_Terminal: terminal->connection is NULL");

    return terminal->connection->status;
}

bool isConnected_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isConnected_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "isConnected_Terminal: terminal->connection is NULL");
    
    return terminal->connection->status == True_Bool3;
}

bool isDisconnected_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isDisconnected_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "isDisconnected_Terminal: terminal->connection is NULL");
    
    return terminal->connection->status == False_Bool3;
}

void setConnectionStatus_Terminal(Terminal *terminal, Bool3 status)
{
    assertion((terminal != NULL),
        "setConnectionStatus_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "setConnectionStatus_Terminal: terminal->connection is NULL");

    terminal->connection->status = status;
}

Bool3 getDisconnectSupport_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getDisconnectSupport_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "getDisconnectSupport_Terminal: terminal->connection is NULL");

    return terminal->connection->disconnect;
}

void setDisconnectSupport_Terminal(Terminal *terminal, Bool3 disconnect)
{
    assertion((terminal != NULL),
        "getDisconnectSupport_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "getDisconnectSupport_Terminal: terminal->connection is NULL");

    terminal->connection->disconnect = disconnect;
}

TimeUnit getTransmissionTime_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getTransmissionTime_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "getTransmissionTime_Terminal: terminal->connection is NULL");
    assertion((terminal->connection->status == True_Bool3),
        "getTransmissionTime_Terminal: terminal is not connected");

    return terminal->connection->time;
}

void setTransmissionTime_Terminal(Terminal *terminal, TimeUnit time)
{
    assertion((terminal != NULL),
        "setTransmissionTime_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "setTransmissionTime_Terminal: terminal->connection is NULL");

    terminal->connection->time = time;
}

Terminal* getRemoteTerminal_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getRemoteTerminal_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "getRemoteTerminal_Terminal: terminal->connection is NULL");
    assertion((terminal->connection->status == True_Bool3),
        "getRemoteTerminal_Terminal: terminal is not connected");

    return terminal->connection->remote;
}

void setRemoteTerminal_Terminal(Terminal *terminal, Terminal *remote)
{
    assertion((terminal != NULL),
        "setRemoteTerminal_Terminal: terminal is NULL");
    assertion((terminal->connection != NULL),
        "setRemoteTerminal_Terminal: terminal->connection is NULL");

    terminal->connection->remote = remote;
}

void connect_Terminals(Terminal *terminal1, Terminal *terminal2,
                       TimeUnit time12, TimeUnit time21)
{
    setConnectionStatus_Terminal(terminal1, True_Bool3);
    setConnectionStatus_Terminal(terminal2, True_Bool3);
    setRemoteTerminal_Terminal(terminal1, terminal2);
    setRemoteTerminal_Terminal(terminal2, terminal1);
    setTransmissionTime_Terminal(terminal1, time12);
    setTransmissionTime_Terminal(terminal2, time21);
}

void disconnect_Terminal(Terminal *terminal)
{
    TermIOS *termios;

    assertion((terminal != NULL),
        "disconnect_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "disconnect_Terminal: termios is NULL");
   
    if(!termios->cflag->clocal)
    {
        setConnectionStatus_Terminal(terminal, False_Bool3);
        setRemoteTerminal_Terminal(terminal, NULL);
        setTransmissionTime_Terminal(terminal, 0);
    }
}

Bool3 getControllingStatus_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getControllingStatus_Terminal: terminal is NULL");

    return terminal->control_status;
}

void setControllingStatus_Terminal(Terminal *terminal, Bool3 control_status)
{
    assertion((terminal != NULL),
        "setControllingStatus_Terminal: terminal is NULL");

    terminal->control_status = control_status;
}

bool isControlling_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isControlling_Terminal: terminal is NULL");

    return terminal->control_status == True_Bool3;
}

bool isNotControlling_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isNotControlling_Terminal: terminal is NULL");

    return terminal->control_status == False_Bool3;
}

Bool3 getLoginStatus_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getLoginStatus_Terminal: terminal is NULL");

    return terminal->login_status;
}

void setLoginStatus_Terminal(Terminal *terminal, Bool3 login_status)
{
    assertion((terminal != NULL),
        "setLoginStatus_Terminal: terminal is NULL");

    terminal->login_status = login_status;
}

bool isLoginTTY_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isLoginTTY_Terminal: terminal is NULL");

    return terminal->login_status == True_Bool3;
}

bool isNotLoginTTY_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isNotLoginTTY_Terminal: terminal is NULL");

    return terminal->login_status == False_Bool3;
}

CString *getLogin_Terminal(Terminal *terminal)
{
    assertion(isControlling_Terminal(terminal),
        "getLogin_Terminal: terminal does not refer to a controlling terminal");

    return terminal->login;
}

void setLogin_Terminal(Terminal *terminal, CString *login)
{
    assertion(isControlling_Terminal(terminal),
        "setLogin_Terminal: terminal does not refer to a controlling terminal");

    terminal->login = login;
}

void login_Terminal(Terminal *terminal, CString *login)
{
    setLoginStatus_Terminal(terminal, True_Bool3);
    setLogin_Terminal(terminal, login);
}

void logout_Terminal(Terminal *terminal)
{
    setLoginStatus_Terminal(terminal, False_Bool3);
}

ProcessIdObj* getSessionId_Terminal(Terminal *terminal)
{
    assertion(isControlling_Terminal(terminal),
        "getSessionId_Terminal: "
        "terminal does not refer to a controlling terminal");

    return terminal->sessionid;
}

void setSessionId_Terminal(Terminal *terminal, ProcessIdObj *sessionid)
{
    assertion(isControlling_Terminal(terminal),
        "setSessionId_Terminal: "
        "terminal does not refer to a controlling terminal");

    terminal->sessionid = sessionid;
}

ProcessIdObj* getForegroundPGroupId_Terminal(Terminal *terminal)
{
    assertion(isControlling_Terminal(terminal),
        "getForegroundPGroupId_Terminal: "
        "terminal does not refer to controlling terminal");

    return terminal->fpgroupid;
}

void setForegroundPGroupId_Terminal(Terminal *terminal, ProcessIdObj* fpgroupid)
{
    assertion(isControlling_Terminal(terminal),
        "setForegroundPGroupId_Terminal: "
        "terminal does not refer to controlling terminal");

    terminal->fpgroupid = fpgroupid;
}

TermIOS* getTermIOS_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getTermIOS_Terminal: terminal is NULL");
    assertion((terminal->termios_list != NULL),
        "getTermIOS_Terminal: terminal->termios_list is NULL");
    
    if(isEmpty_List(terminal->termios_list) ||
        size_List(terminal->termios_list) > 1)
        return NULL;

    return get_List(terminal->termios_list, 0);
}

TermIOS* getLastTermIOS_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getTermIOS_Terminal: terminal is NULL");
    assertion((terminal->termios_list != NULL),
        "getTermIOS_Terminal: terminal->termios_list is NULL");
    
    if(isEmpty_List(terminal->termios_list))
        return NULL;

    return get_List(terminal->termios_list, size_List(terminal->termios_list) - 1);
}

void setTermIOS_Terminal(Terminal *terminal, TermIOS *termios)
{
    assertion((terminal != NULL),
        "setTermIOS_Terminal: terminal is NULL");
    assertion((termios != NULL),
        "setTermIOS_Terminal: termios is NULL");
    assertion((terminal->termios_list != NULL),
        "setTermIOS_Terminal: terminal->termios_list is NULL");
    
    clear_List(terminal->termios_list);
    append_List(terminal->termios_list, termios);
}

void addTermIOS_Terminal(Terminal *terminal, TermIOS *termios)
{
    assertion((terminal != NULL),
        "addTermIOS_Terminal: terminal is NULL");
    assertion((termios != NULL),
        "addTermIOS_Terminal: termios is NULL");
    assertion((terminal->termios_list != NULL),
        "addTermIOS_Terminal: terminal->termios_list is NULL");
    
    append_List(terminal->termios_list, termios);
}

WinSize* getWinSize_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getWinSize_Terminal: terminal is NULL");

    return terminal->wsize;
}

void setWinSize_Terminal(Terminal *terminal, WinSize *wsize)
{
    assertion((terminal != NULL),
        "setWinSize_Terminal: terminal is NULL");

    terminal->wsize = wsize;
}

FileDescId getPTMDescId_Terminal(Terminal *terminal)
{
    assertion(isPTM_Terminal(terminal),
        "getPTMDescId_Terminal: terminal is not PTM");

    return terminal->ptm_desc_id;
}

void setPTMDescId_Terminal(Terminal *terminal, FileDescId ptm_desc_id)
{
    assertion(isPTM_Terminal(terminal),
        "setPTMDescId_Terminal: terminal is not PTM");

    terminal->ptm_desc_id = ptm_desc_id;
}

CString* getPTSName_Terminal(Terminal *terminal)
{
    assertion(isPTM_Terminal(terminal),
        "getPTSName_Terminal: terminal is not PTM");

    return terminal->pts_name;
}

void setPTSName_Terminal(Terminal *terminal, CString *pts_name)
{
    assertion(isPTM_Terminal(terminal),
        "setPTSName_Terminal: terminal is not PTM");

    terminal->pts_name = pts_name;
}

bool isLocked_Terminal(Terminal *terminal)
{
    assertion(isPT_Terminal(terminal),
        "isLocked_Terminal: terminal is not PT");

    return terminal->locked;
}

void lock_Terminal(Terminal *terminal)
{
    assertion(isPT_Terminal(terminal),
        "lock_Terminal: terminal is not PT");

    terminal->locked = true;
}

void unlock_Terminal(Terminal *terminal)
{
    assertion(isPT_Terminal(terminal),
        "unlock_Terminal: terminal is not PT");

    terminal->locked = false;
}

TerminalQueue* getInputQueue_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getInputQueue_Terminal: terminal is NULL");

    return terminal->input_queue;
}

void setInputQueue_Terminal(Terminal *terminal, TerminalQueue *queue)
{
    assertion((terminal != NULL),
        "setInputQueue_Terminal: terminal is NULL");

    terminal->input_queue = queue;
}

TerminalQueue* getOutputQueue_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getOutputQueue_Terminal: terminal is NULL");

    return terminal->output_queue;
}

void setOutputQueue_Terminal(Terminal *terminal, TerminalQueue *queue)
{
    assertion((terminal != NULL),
        "setOutputQueue_Terminal: terminal is NULL");

    terminal->output_queue = queue;
}

bool isInputSuspended_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isInputSuspended_Terminal: terminal is NULL");

    return terminal->input_suspended;
}

void suspendInput_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "suspendInput_Terminal: terminal is NULL");

    terminal->input_suspended = true;
}

void restartInput_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "restartInput_Terminal: terminal is NULL");

    terminal->input_suspended = false;
}

bool isOutputSuspended_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "isOutputSuspended_Terminal: terminal is NULL");

    return terminal->output_suspended;
}

void suspendOutput_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "suspendOutput_Terminal: terminal is NULL");

    terminal->output_suspended = true;
}

void restartOutput_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "restartOutput_Terminal: terminal is NULL");

    terminal->output_suspended = false;
}

int getLineSize_Terminal(Terminal *terminal)
{
    unsigned k, l, size;
    CCT eol, eof;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "getLineSize_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "getLineSize_Terminal: termios is NULL");
    
    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "getLineSize_Terminal: queue is NULL");

    eol = getControlCharacter_TermIOS(termios, SUT_VEOL);
    eof = getControlCharacter_TermIOS(termios, SUT_VEOF);

    size = size_TerminalQueue(queue);
    for(k = l = 0; k < size; k++)
    {
        ByteT c = getByte_TerminalQueue(queue, k);

        if(c == '\n' || c == eol)
            return l + 1;

        if(c == eof)
            return l;

        if(!isDiscardedControlCharacter_TermIOS(termios, c))
            l++;
    }

    return -1;
}

TimeInterval getReadTime_Terminal(Terminal *terminal)
{
    assertion((terminal != NULL),
        "getReadTime_Terminal: terminal is NULL");

    return terminal->read_time;
}

void setReadTime_Terminal(Terminal *terminal, TimeInterval read_time)
{
    assertion((terminal != NULL),
        "setReadTime_Terminal: terminal is NULL");

    terminal->read_time = read_time;
}

/*
 * The tcsetattr() function shall return successfully if it was able to perform
 * any of the requested actions, even if some of the requested actions could
 * not be performed. It shall set all the attributes that the implementation
 * supports as requested and leave all the attributes not supported by the
 * implementation unchanged.
 */
bool checkIOAttributes_TermIOS(TermIOS *termios, Terminal *terminal)
{
    int i, j, size;
    bool find_cc, find_ispeed, find_ospeed, find_iflag,
        find_oflag, find_cflag, find_lflag;

    assertion((termios != NULL),
        "checkIOAttributes_TermIOS: termios is NULL");
    assertion((terminal != NULL),
        "checkIOAttributes_TermIOS: terminal is NULL");
    assertion((terminal->termios_list != NULL),
        "checkIOAttributes_TermIOS: terminal->termios_list is NULL");

    if(isEmpty_List(terminal->termios_list))
        return true;

    find_ispeed = find_ospeed = find_iflag = find_oflag = find_cflag = find_lflag = false;

    size = size_List(terminal->termios_list);
    for(i = 0; i < size; i++)
    {
        TermIOS *find_termios = get_List(terminal->termios_list, i);

        find_ispeed = find_ispeed || termios->ispeed == find_termios->ispeed;
        find_ospeed = find_ospeed || termios->ospeed == find_termios->ospeed;

        /*
         * If the input and output baud rates differ and are a combination that
         * is not supported, neither baud rate shall be changed.
         */
        if(termios->ispeed != termios->ospeed && find_ispeed != find_ospeed)
            return false;

        find_iflag  = find_iflag  || equals(termios->iflag, find_termios->iflag);
        find_oflag  = find_oflag  || equals(termios->oflag, find_termios->oflag);
        find_cflag  = find_cflag  || equals(termios->cflag, find_termios->cflag);
        find_lflag  = find_lflag  || equals(termios->lflag, find_termios->lflag);

        if(!find_cc)
        {
            for(j = 0; j < SUT_NCCS; j++)
            {
                CCTObj* ccobj = get_List(termios->cclist, j);                    
                CCTObj* find_ccobj = get_List(find_termios->cclist, j);    
                
                if(!(find_cc = *ccobj == *find_ccobj))
                    break;
            }
        }

        if(find_cc && find_ispeed && find_ospeed && find_iflag && find_oflag && find_cflag && find_lflag)
           return true;

    }

    return false;
}

void processInputQueue_Terminal(Terminal *terminal)
{
    int k, l;
    CCT c, eof, eol, erase, kill;
    TimeInterval time;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "processInputQueue_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "processInputQueue_Terminal: termios is NULL");

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "processInputQueue_Terminal: queue is NULL");

    eof   = getControlCharacter_TermIOS(termios, SUT_VEOF);
    eol   = getControlCharacter_TermIOS(termios, SUT_VEOL);
    erase = getControlCharacter_TermIOS(termios, SUT_VERASE);
    kill  = getControlCharacter_TermIOS(termios, SUT_VKILL);

    /* [Implicit requirement] */
    if(isPTM_Terminal(terminal))
        return;

    for(k = l = 0; k < size_TerminalQueue(queue);)
    {
        TerminalDataItem *item = getItem_TerminalQueue(queue, k);

        if(isProcessed_TerminalDataItem(item))
        {
            k++;
            continue;
        }

        time = getTime_TerminalDataItem(item);

        if(isBreakCondition_TerminalDataItem(item))
        {
            /* If IGNBRK is set */
            if(termios->iflag->ignbrk)
            {
                /*
                 * A break condition detected on input shall be ignored; that
                 * is not put on the input queue and therefore not read by any
                 * process.
                 */
                IMPLEMENT_REQ("read.60.01");

                removeItem_TerminalQueue(queue, k);
                continue; /* [Do not increment k] */
            }
            /* If IGNBRK is not set and BRKINT is set */
            else if(termios->iflag->brkint)
            {
                /* a break condition shall generate a single SIGINT signal */
                IMPLEMENT_REQ("read.60.02.01");

                removeItem_TerminalQueue(queue, k);
                continue; /* [Do not increment k] */
            }
            /* If neither IGNBRK nor BRKINT is set */
            else
            {
                /*
                 * a break condition shall be read as a single 0x00, or if
                 * PARMRK is set, as 0xff 0x00 0x00.
                 */
                IMPLEMENT_REQ("read.60.03");

                /* If INPCK is set */
                if(termios->iflag->inpck)
                {
                    /*
                     * input parity checking shall be enabled
                     */
                    IMPLEMENT_REQ("read.74");

                    /* If PARMRK is set */
                    if(termios->iflag->parmrk)
                    {
                        insertByte_TerminalQueue(queue, k, 0xFF, time);
                        setProcessStatus_TerminalQueue(queue, k++, true);

                        insertByte_TerminalQueue(queue, k, 0x00, time);
                        setProcessStatus_TerminalQueue(queue, k++, true);
                    }
                }

                setByte_TerminalQueue(queue, k, 0x00);

                /* [Do not process] */
                setProcessStatus_TerminalQueue(queue, k++, true);
                continue;
            }
        }
        else /* [Not a break condition] */
        {
            c = getByte_TerminalDataItem(item);

            /* If INPCK is set */
            if(termios->iflag->inpck)
            {
                /*
                 * input parity checking shall be enabled
                 */
                IMPLEMENT_REQ("read.74");

                /* Framing or parity error */
                if(!checkParity_Terminal(terminal, c))
                {
                    /* If IGNPAR is set */
                    if(termios->iflag->ignpar)
                    {
                        /*
                         * a byte with a framing or parity error (other than
                         * break) shall be ignored.
                         */
                        IMPLEMENT_REQ("read.72");

                        removeItem_TerminalQueue(queue, k);
                        continue; /* [Do not increment k] */
                    }
                    /* If PARMRK is set, and IGNPAR is not set */
                    else if(termios->iflag->parmrk)
                    {
                        /*
                         * a byte with a framing or parity error (other than
                         * break) shall be given to the application as the
                         * three-byte sequence 0xff 0x00 X.
                         */
                        IMPLEMENT_REQ("read.73.01");

                        insertByte_TerminalQueue(queue, k, 0xFF, time);
                        setProcessStatus_TerminalQueue(queue, k++, true);

                        insertByte_TerminalQueue(queue, k, 0x00, time);
                        setProcessStatus_TerminalQueue(queue, k++, true);

                        /* [Do not process] */
                        setProcessStatus_TerminalQueue(queue, k++, true);
                        continue;
                    }
                    /* If neither PARMRK nor IGNPAR is set */
                    else
                    {
                        /*
                         * a framing or parity error (other than break) shall
                         * be given to the application as a single byte 0x00.
                         */
                        IMPLEMENT_REQ("read.73.03");

                        setByte_TerminalQueue(queue, k, 0x00);

                        /* [Do not process] */
                        setProcessStatus_TerminalQueue(queue, k++, true);
                        continue;
                    }
                }
            }
        }

        /* Canonical input */
        if(termios->lflag->icanon)
        {
            /* CR */
            if(c == '\r')
            {
                /* If IGNCR is set */
                if(termios->iflag->igncr)
                {
                    /*
                     * CR character shall be ignored (not read)
                     */
                    IMPLEMENT_REQ("read.76.02");

                    removeItem_TerminalQueue(queue, k);
                    continue; /* [Do not increment k] */
                }
                /* If IGNCR is not set and ICRNL is set */
                else if(termios->iflag->icrnl)
                {
                    /*
                     * CR character shall be translated into an NL character
                     */
                    IMPLEMENT_REQ("read.71.02");

                    setByte_TerminalQueue(queue, k, '\n');
                    l = k + 1;
                }
            }
            /* NL */
            else if(c == '\n')
            {
                /* If INLCR is set */
                if(termios->iflag->inlcr)
                {
                    /*
                     * NL character shall be translated into a CR character
                     */
                    IMPLEMENT_REQ("read.76.01");

                    setByte_TerminalQueue(queue, k, '\r');
                }
                else
                {
                    /*
                     * Special character on input, which is recognized if the
                     * ICANON flag is set. It is the line delimiter newline.
                     */
                    IMPLEMENT_REQ("read.69");

                    l = k + 1;
                }
            }
            /* EOL */
            else if(c == eol)
            {
                /*
                 * Special character on input, which is recognized if the
                 * ICANON flag is set. It is an additional line delimiter, like
                 * NL.
                 */
                IMPLEMENT_REQ("read.70");

                l = k + 1;
            }
            /* EOF */
            else if(c == eof)
            {
                /*
                 * Special character on input, which is recognized if the
                 * ICANON flag is set. When received, all the bytes waiting to
                 * be read are immediately passed to the process without
                 * waiting for a newline, and the EOF is discarded. Thus, if
                 * there are no bytes waiting (that is, the EOF occurred at the
                 * beginning of a line), a byte count of zero shall be returned
                 * from the read(), representing an end-of-file indication. If
                 * ICANON is set, the EOF character shall be discarded when
                 * processed.
                 */
                IMPLEMENT_REQ("read.68");

                removeItem_TerminalQueue(queue, l = k--);
            }
            /* ERASE */
            else if(c == erase)
            {
                if(k > l)
                {
                    /*
                     * Special character on input, which is recognized if the
                     * ICANON flag is set. Erases the last character in the
                     * current line; see Canonical Mode Input Processing. It
                     * shall not erase beyond the start of a line, as delimited
                     * by an NL, EOF, or EOL character. If ICANON is set, the
                     * ERASE character shall be discarded when processed.
                     */
                    IMPLEMENT_REQ("read.66");

                    removeItems_TerminalQueue(queue, k - 1, k);
                    k--;
                    continue;
                }
            }
            /* KILL */
            else if(c == kill)
            {
                if(k > l)
                {
                    /*
                     * Special character on input, which is recognized if the
                     * ICANON flag is set. Deletes the entire line, as
                     * delimited by an NL, EOF, or EOL character. If ICANON is
                     * set, the KILL character shall be discarded when
                     * processed.
                     */
                    IMPLEMENT_REQ("read.67");

                    removeItems_TerminalQueue(queue, l, k);
                    k = l;
                    continue;
                }
            }
        }

        /* If ISTRIP is set */
        if(termios->iflag->istrip)
        {
            /*
             * the value of all but the 7 low-order bits shall be zero
             */
            IMPLEMENT_REQ("read.75");

            setByte_TerminalQueue(queue, k, c & 0x7F);
        }
        else if(c == 0xFF && termios->iflag->parmrk && !termios->iflag->ignpar)
        {
            /*
             * a valid byte 0xFF is given to the application as 0xFF 0xFF
             */
            IMPLEMENT_REQ("read.73.02");

            insertByte_TerminalQueue(queue, k, 0xFF, time);
            setProcessStatus_TerminalQueue(queue, k++, true);
        }

        setProcessStatus_TerminalQueue(queue, k++, true);
    }
}

static unsigned processNLDelay(TerminalQueue *queue, TermIOS *termios,
                               unsigned k, TimeInterval time)
{
    ByteT fill;

    /* If OFDEL is set */
    if(termios->oflag->ofdel)
    {
        /* the fill character shall be DEL */
        IMPLEMENT_REQ("write.62.04.01");

        fill = '\x7F';
    }
    /* otherwise */
    else
    {
        /* NUL */
        IMPLEMENT_REQ("write.62.04.02");

        fill = '\x00';
    }

    if(termios->oflag->nldly == NL0)
    {
        /* In all cases a value of 0 shall indicate no delay */
        IMPLEMENT_REQ("write.62.02");
    }
    /* If OFILL is set */
    else if(termios->oflag->ofill)
    {
        /*
         * fill characters shall be transmitted for delay instead of a timed
         * delay.
         */
        IMPLEMENT_REQ("write.62.03");

        /* two fill characters shall be transmitted */
        IMPLEMENT_REQ("write.61.01.02.02");

        insertByte_TerminalQueue(queue, k + 1, fill, time);
        setProcessStatus_TerminalQueue(queue, ++k, true);

        insertByte_TerminalQueue(queue, k + 1, fill, time);
        setProcessStatus_TerminalQueue(queue, ++k, true);
    }
    else
    {
        /* Newline delay shall last about 0.10 seconds */
        IMPLEMENT_REQ("write.61.01.02.01");

        /* The actual delays depend on line speed and system load */
        IMPLEMENT_REQ("write.62");
    }

    return k;
}

static unsigned processCRDelay(TerminalQueue *queue, TermIOS *termios,
                               unsigned k, TimeInterval time)
{
    ByteT fill;

    /* If OFDEL is set */
    if(termios->oflag->ofdel)
    {
        /* the fill character shall be DEL */
        IMPLEMENT_REQ("write.62.04.01");

        fill = '\x7F';
    }
    /* otherwise */
    else
    {
        /* NUL */
        IMPLEMENT_REQ("write.62.04.02");

        fill = '\x00';
    }

    if(termios->oflag->crdly == CR0)
    {
        /* In all cases a value of 0 shall indicate no delay */
        IMPLEMENT_REQ("write.62.02");
    }
    /* If OFILL is set */
    else if(termios->oflag->ofill)
    {
        /*
         * fill characters shall be transmitted for delay instead of a timed
         * delay.
         */
        IMPLEMENT_REQ("write.62.03");

        if(termios->oflag->crdly == CR1)
        {
            /* delay type 1 shall transmit two fill characters */
            IMPLEMENT_REQ("write.61.01.03.04.01");

            insertByte_TerminalQueue(queue, k + 1, fill, time);
            setProcessStatus_TerminalQueue(queue, ++k, true);

            insertByte_TerminalQueue(queue, k + 1, fill, time);
            setProcessStatus_TerminalQueue(queue, ++k, true);
        }
        else if(termios->oflag->crdly == CR2)
        {
            /* and type 2 four fill characters */
            IMPLEMENT_REQ("write.61.01.03.04.02");

            insertByte_TerminalQueue(queue, k + 1, fill, time);
            setProcessStatus_TerminalQueue(queue, ++k, true);

            insertByte_TerminalQueue(queue, k + 1, fill, time);
            setProcessStatus_TerminalQueue(queue, ++k, true);

            insertByte_TerminalQueue(queue, k + 1, fill, time);
            setProcessStatus_TerminalQueue(queue, ++k, true);

            insertByte_TerminalQueue(queue, k + 1, fill, time);
            setProcessStatus_TerminalQueue(queue, ++k, true);
        }
    }
    else
    {
        if(termios->oflag->crdly == CR1)
        {
            /*
             * Carriage-return delay type 1 shall be dependent on the current
             * column position,
             */
            IMPLEMENT_REQ("write.61.01.03.01");
        }
        else if(termios->oflag->crdly == CR2)
        {
            /* type 2 shall be about 0.10 seconds */
            IMPLEMENT_REQ("write.61.01.03.02");
        }
        else if(termios->oflag->crdly == CR3)
        {
            /* and type 3 shall be about 0.15 seconds */
            IMPLEMENT_REQ("write.61.01.03.03");
        }

        /* The actual delays depend on line speed and system load */
        IMPLEMENT_REQ("write.62");
    }

    return k;
}

static unsigned processFFDelay(TerminalQueue *queue, TermIOS *termios,
                               unsigned k, TimeInterval time)
{
    if(termios->oflag->ffdly == FF0)
    {
        /* In all cases a value of 0 shall indicate no delay */
        IMPLEMENT_REQ("write.62.02");        
    }
    else if(termios->oflag->ofill)
    {
        /*
         * fill characters shall be transmitted for delay instead of a timed
         * delay.
         */
        IMPLEMENT_REQ("write.62.03");

        /* TODO: Incomplete requirements in SUSv3 */
    }
    else
    {
        /*
         * If a form-feed or vertical-tab delay is specified, it shall last for
         * about 2 seconds.
         */
        IMPLEMENT_REQ("write.62.01.01.01");
    }

    return k;
}

static unsigned processVTDelay(TerminalQueue *queue, TermIOS *termios,
                               unsigned k, TimeInterval time)
{
    if(termios->oflag->vtdly == FF0)
    {
        /* In all cases a value of 0 shall indicate no delay */
        IMPLEMENT_REQ("write.62.02");        
    }
    else if(termios->oflag->ofill)
    {
        /*
         * fill characters shall be transmitted for delay instead of a timed
         * delay.
         */
        IMPLEMENT_REQ("write.62.03");

        /* TODO: Incomplete requirements in SUSv3 */
    }
    else
    {
        /*
         * If a form-feed or vertical-tab delay is specified, it shall last for
         * about 2 seconds.
         */
        IMPLEMENT_REQ("write.62.01.01.02");
    }

    return k;
}

static unsigned processTBDelay(TerminalQueue *queue, TermIOS *termios,
                               unsigned k, TimeInterval time)
{
    ByteT fill;

    /* If OFDEL is set */
    if(termios->oflag->ofdel)
    {
        /* the fill character shall be DEL */
        IMPLEMENT_REQ("write.62.04.01");

        fill = '\x7F';
    }
    /* otherwise */
    else
    {
        /* NUL */
        IMPLEMENT_REQ("write.62.04.02");

        fill = '\x00';
    }

    if(termios->oflag->tbdly == TAB0)
    {
        /* In all cases a value of 0 shall indicate no delay */
        IMPLEMENT_REQ("write.62.02");        
    }
    /* If OFILL is set */
    else if(termios->oflag->ofill)
    {
        /*
         * fill characters shall be transmitted for delay instead of a timed
         * delay.
         */
        IMPLEMENT_REQ("write.62.03");

        /* two fill characters shall be transmitted for any delay */
        IMPLEMENT_REQ("write.61.01.04.04");

        insertByte_TerminalQueue(queue, k + 1, fill, time);
        setProcessStatus_TerminalQueue(queue, ++k, true);

        insertByte_TerminalQueue(queue, k + 1, fill, time);
        setProcessStatus_TerminalQueue(queue, ++k, true);
    }
    else
    {
        if(termios->oflag->tbdly == TAB1)
        {
            /*
             * Horizontal-tab delay type 1 shall be dependent on the current
             * column position.
             */
            IMPLEMENT_REQ("write.61.01.04.01");
        }
        else if(termios->oflag->tbdly == TAB2)
        {
            /* Type 2 shall be about 0.10 seconds */
            IMPLEMENT_REQ("write.61.01.04.02");
        }

        /* The actual delays depend on line speed and system load */
        IMPLEMENT_REQ("write.62");
    }

    return k;
}

static unsigned processBSDelay(TerminalQueue *queue, TermIOS *termios,
                               unsigned k, TimeInterval time)
{
    ByteT fill;

    /* If OFDEL is set */
    if(termios->oflag->ofdel)
    {
        /* the fill character shall be DEL */
        IMPLEMENT_REQ("write.62.04.01");

        fill = '\x7F';
    }
    /* otherwise */
    else
    {
        /* NUL */
        IMPLEMENT_REQ("write.62.04.02");

        fill = '\x00';
    }

    if(termios->oflag->bsdly == BS0)
    {
        /* In all cases a value of 0 shall indicate no delay */
        IMPLEMENT_REQ("write.62.02");        
    }
    /* If OFILL is set */
    else if(termios->oflag->ofill)
    {
        /*
         * fill characters shall be transmitted for delay instead of a timed
         * delay.
         */
        IMPLEMENT_REQ("write.62.03");

        /* one fill character shall be transmitted */
        insertByte_TerminalQueue(queue, k + 1, fill, time);
        setProcessStatus_TerminalQueue(queue, ++k, true);

        IMPLEMENT_REQ("write.61.01.05.02");
    }
    else
    {
        /* Backspace delay shall last about 0.05 seconds */
        IMPLEMENT_REQ("write.61.01.05.01");

        /* The actual delays depend on line speed and system load */
        IMPLEMENT_REQ("write.62");
    }

    return k;
}

void processOutputQueue_Terminal(Terminal *terminal)
{
    unsigned k;
    CCT c;
    TimeInterval time;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "processOutputQueue_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((terminal != NULL),
        "processOutputQueue_Terminal: termios is NULL");

    queue = getOutputQueue_Terminal(terminal);

    assertion((terminal != NULL),
        "processOutputQueue_Terminal: queue is NULL");

    /* [Implicit requirement] */
    if(isPTM_Terminal(terminal))
        return;

    /* If OPOST is set */
    if(termios->oflag->opost)
    {
        /*
         * output data shall be post-processed as described below, so that
         * lines of text are modified to appear appropriately on the terminal
         * device
         */
        IMPLEMENT_REQ("write.60.01");
    }
    /* otherwise */
    else
    {
        /* characters shall be transmitted without change */
        IMPLEMENT_REQ("write.60.02");

        return;
    }

    for(k = 0; k < (unsigned)size_TerminalQueue(queue); k++)
    {
        if(isProcessed_TerminalQueue(queue, k))
            continue;

        setProcessStatus_TerminalQueue(queue, k, true);

        if(isBreakCondition_TerminalQueue(queue, k))
            continue;

        c = getByte_TerminalQueue(queue, k);
        time = getTime_TerminalQueue(queue, k);

        switch(c)
        {
        case '\n':
            /* If ONLCR is set */
            if(termios->oflag->onlcr)
            {
                /*
                 * the NL character shall be transmitted as the CR-NL character
                 * pair
                 */
                IMPLEMENT_REQ("write.61.01");

                insertByte_TerminalQueue(queue, k, '\r', time);
                setProcessStatus_TerminalQueue(queue, k, true);

                /*
                 * The column pointer shall also be set to 0 if the CR
                 * character is actually transmitted.
                 */
                IMPLEMENT_REQ("write.61.06");

                k = processCRDelay(queue, termios, k, time);
                terminal->column = 0;

                k++;
            }
            /* If ONLRET is set */
            if(termios->oflag->onlret)
            {
                /*
                 * the NL character is assumed to do the carriage-return
                 * function; the column pointer shall be set to 0 and the
                 * delays specified for CR shall be used.
                 */
                IMPLEMENT_REQ("write.61.04.01;write.61.04.02");

                /*
                 * The column pointer shall also be set to 0 if the CR
                 * character is actually transmitted.
                 */
                IMPLEMENT_REQ("write.61.06");

                k = processCRDelay(queue, termios, k, time);
                terminal->column = 0;
            }
            /* Otherwise */
            else
            {
                /*
                 * the NL character is assumed to do just the line-feed
                 * function; the column pointer remains unchanged.
                 */
                IMPLEMENT_REQ("write.61.05");

                k = processNLDelay(queue, termios, k, time);
            }
            break;
        case '\r':
            traceFormattedUserInfo("column=%u", terminal->column);

            /* If ONOCR is set */
            if(termios->oflag->onocr && terminal->column == 0)
            {
                /*
                 * no CR character shall be transmitted when at column 0
                 * (first position).
                 */
                IMPLEMENT_REQ("write.61.03");
                
                /* No CR character shall be transmitted when at column 0 */
                removeItem_TerminalQueue(queue, k--);
                continue;
            }
            /* If OCRNL is set */
            if(termios->oflag->ocrnl)
            {
                /* the CR character shall be transmitted as the NL character */
                IMPLEMENT_REQ("write.61.02");
                
                /* CR character shall be transmitted as the NL character */
                setByte_TerminalQueue(queue, k, '\n');

                /* If ONLRET is set */
                if(termios->oflag->onlret)
                {
                    /*
                     * the NL character is assumed to do the carriage-return
                     * function; the column pointer shall be set to 0 and the
                     * delays specified for CR shall be used.
                     */
                    IMPLEMENT_REQ("write.61.04.01;write.61.04.02");

                    k = processCRDelay(queue, termios, k, time);
                    terminal->column = 0;
                }
                /* Otherwise */
                else
                {
                    /*
                     * the NL character is assumed to do just the line-feed
                     * function; the column pointer remains unchanged.
                     */
                    IMPLEMENT_REQ("write.61.05");

                    k = processNLDelay(queue, termios, k, time);
                }
            }
            else
            {
                /*
                 * The column pointer shall also be set to 0 if the CR
                 * character is actually transmitted.
                 */
                IMPLEMENT_REQ("write.61.06");

                k = processCRDelay(queue, termios, k, time);
                terminal->column = 0;
            }
            break;
        case '\a':
            /* [Implicit] */
            break;
        case '\b':
            /* [Implicit] */
            if(terminal->column > 0) terminal->column--;
            break;
        case '\f':
            k = processFFDelay(queue, termios, k, time);
            break;
        case '\t':
            terminal->column += POSIX_IO_TERM_TAB_SIZE - 
                (terminal->column % POSIX_IO_TERM_TAB_SIZE);
            
            if(termios->oflag->tbdly == TAB3)
            {
                unsigned l;

                /* Type 3 specifies that tabs shall be expanded into spaces */
                IMPLEMENT_REQ("write.61.01.04.03");

                setByte_TerminalQueue(queue, k, ' ');

                for(l = 0; l < POSIX_IO_TERM_TAB_SIZE - 1; l++)
                {
                    insertByte_TerminalQueue(queue, k, ' ', time);
                    setProcessStatus_TerminalQueue(queue, k++, true);
                }
            }
            k = processTBDelay(queue, termios, k, time);
            break;
        case '\v':
            k = processVTDelay(queue, termios, k, time);
            break;
        case ' ':
            k = processBSDelay(queue, termios, k, time);
            terminal->column++;
            break;
        default:
            terminal->column++;
            break;
        }
    }
}

Bool3 containsLineAtTime_Terminal(Terminal *terminal, TimeMark time)
{
    unsigned k, size;
    CCT eol, eof;
    CByteArray *array;
    TerminalQueue *queue;
    TermIOS *termios;

    assertion((terminal != NULL),
        "containsLineAtTime_Terminal: terminal is NULL");

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "containsLineAtTime_Terminal: queue is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "containsLineAtTime_Terminal: termios is NULL");

    eol = getControlCharacter_TermIOS(termios, SUT_VEOL);
    eof = getControlCharacter_TermIOS(termios, SUT_VEOF);

    if((size = size_TerminalQueue(queue)) == 0)
        return False_Bool3;

    for(k = 0; k < size; k++)
    {
        ByteT byte = getByte_TerminalQueue(queue, k);
        TimeInterval item_time = getTime_TerminalQueue(queue, k);

        if(item_time.minMark.timemark > time.timemark) return False_Bool3;

        if(byte == '\n' || byte == eol || byte == eof)
        {
            return item_time.maxMark.timemark <= time.timemark ?
                True_Bool3 : Unknown_Bool3;
        }
    }

    return False_Bool3;
}

Bool3 containsBytesAtTime_Terminal(Terminal *terminal, TimeMark time, unsigned n)
{
    unsigned k, l, size;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "containsBytesAtTime_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "containsBytesAtTime_Terminal: termios is NULL");

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "containsBytesAtTime_Terminal: queue is NULL");

    if(n == 0)
        return True_Bool3;

    if((size = size_TerminalQueue(queue)) < n)
        return False_Bool3;

    for(k = l = 0; k < size; k++)
    {
        ByteT byte = getByte_TerminalQueue(queue, k);
        TimeInterval item_time = getTime_TerminalQueue(queue, k);

        if(isDiscardedControlCharacter_TermIOS(termios, byte))
            continue;

        if(item_time.minMark.timemark > time.timemark)
            return False_Bool3;

        if(++l == n)
        {
            return item_time.maxMark.timemark <= time.timemark ?
                True_Bool3 : Unknown_Bool3;
        }
    }

    return False_Bool3;
}

void transmit_Terminal(Terminal *terminal, TimeMark time)
{
    unsigned k, size;

    CCT intr, quit, start, stop, susp;

    bool find_any, find_brk, find_intr, find_quit,
        find_start, find_stop, find_susp;

    bool is_controlling;

    ProcessIdObj *fpgroupid;

    TimeInterval time_interval;
    TerminalQueue *from_queue, *to_queue;

    Terminal *remote_terminal = NULL;
    TermIOS  *remote_termios  = NULL;

    assertion(!isDisconnected_Terminal(terminal),
        "transmit_Terminal: terminal is disconnected");

    /* If the remote terminal or remote input modes are unknown */
    if(!isConnected_Terminal(terminal) ||
      (remote_terminal = getRemoteTerminal_Terminal(terminal)) == NULL ||
      (remote_termios  = getTermIOS_Terminal(remote_terminal)) == NULL)
    {
        assertion((remote_terminal == NULL || remote_termios != NULL),
            "transmit_Terminal: remote_terminal is not NULL, remote_termios is NULL");

        /* Clear terminal output queue without transmission */
        clear_TerminalQueue(from_queue);

        return;
    }

    /* The remote terminal and remote input modes are known */
    from_queue = getOutputQueue_Terminal(terminal);
    to_queue   = getInputQueue_Terminal(remote_terminal);

    time_interval.minMark = time_interval.maxMark = time;
    time_interval.maxMark.timemark += getTransmissionTime_Terminal(terminal);

    intr  = getControlCharacter_TermIOS(remote_termios, SUT_VINTR);
    quit  = getControlCharacter_TermIOS(remote_termios, SUT_VQUIT);
    start = getControlCharacter_TermIOS(remote_termios, SUT_VSTART); 
    stop  = getControlCharacter_TermIOS(remote_termios, SUT_VSTOP); 
    susp  = getControlCharacter_TermIOS(remote_termios, SUT_VSUSP);

    find_any   = false;
    find_brk   = false;
    find_intr  = false;
    find_quit  = false;
    find_start = false;
    find_stop  = false;
    find_susp  = false;

    fpgroupid = isControlling_Terminal(remote_terminal) ?
        getForegroundPGroupId_Terminal(remote_terminal) : NULL;

    is_controlling = fpgroupid != NULL && !isWrong_ProcessId(*fpgroupid);

    size = size_TerminalQueue(from_queue);
    for(k = 0; k < size; k++)
    {
        TerminalDataItem *item = getItem_TerminalQueue(from_queue, k);

        if(isBreakCondition_TerminalDataItem(item))
        {
            if(is_controlling && !remote_termios->iflag->ignbrk &&
               remote_termios->iflag->brkint)
            {
                sendSignalToProcessGroup(*fpgroupid, SUT_SIGINT);

                if(!remote_termios->lflag->noflsh)
                {
                    clear_TerminalQueue(getInputQueue_Terminal(remote_terminal));
                    clear_TerminalQueue(getOutputQueue_Terminal(remote_terminal));
                }
            }
        }
        else
        {
            ByteT c = getByte_TerminalDataItem(item);

            if(remote_termios->iflag->ixany)
            {
                if(POSIX_IO_TERM_CONTROL_CHARACTERS_MUST_RESTART_OUTPUT)
                {
                    restartOutput_Terminal(remote_terminal);
                }
                else
                {
                    if(!isDiscardedControlCharacter_TermIOS(remote_termios, c))
                    {
                        restartOutput_Terminal(remote_terminal);
                    }
                }
            }

            if(remote_termios->iflag->ixon)
            {
                if(c == start)
                {
                    restartOutput_Terminal(remote_terminal);
                }

                if(c == stop)
                {
                    suspendOutput_Terminal(remote_terminal);
                }
            }

            if(is_controlling && remote_termios->lflag->isig)
            {
                if(c == intr)
                {
                    sendSignalToProcessGroup(*fpgroupid, SUT_SIGINT);

                    if(!remote_termios->lflag->noflsh)
                    {
                        clear_TerminalQueue(getInputQueue_Terminal(remote_terminal));
                        clear_TerminalQueue(getOutputQueue_Terminal(remote_terminal));
                    }
                }
                if(c == quit)
                {
                    sendSignalToProcessGroup(*fpgroupid, SUT_SIGQUIT);

                    if(!remote_termios->lflag->noflsh)
                    {
                        clear_TerminalQueue(getInputQueue_Terminal(remote_terminal));
                        clear_TerminalQueue(getOutputQueue_Terminal(remote_terminal));
                    }
                }
                if(c == susp)
                {
                    sendSignalToProcessGroup(*fpgroupid, SUT_SIGTSTP);

                    if(!remote_termios->lflag->noflsh)
                    {
                        clear_TerminalQueue(getInputQueue_Terminal(remote_terminal));
                        clear_TerminalQueue(getOutputQueue_Terminal(remote_terminal));
                    }
                }
            }
        }

        setTime_TerminalDataItem(item, time_interval);
        appendItem_TerminalQueue(to_queue, item);
    }

    clear_TerminalQueue(from_queue);
}

void read_Terminal(Terminal *terminal, CByteArray *buf, unsigned nbyte)
{
    unsigned k, l, size;
    CCT eol, eof, c;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "read_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "read_Terminal: termios is NULL");

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "read_Terminal: queue is NULL");

    eol = getControlCharacter_TermIOS(termios, SUT_VEOL);
    eof = getControlCharacter_TermIOS(termios, SUT_VEOF);

    size = size_TerminalQueue(queue);
    for(k = l = 0; k < size; k++)
    {
        if(l == nbyte)
            break;

        if(isBreakCondition_TerminalQueue(queue, k))
            continue;

        c = getByte_TerminalQueue(queue, k);

        if(!isDiscardedControlCharacter_TermIOS(termios, c))
        {
            l++;
        }
    }

    if(k > 0)
    {
        removeItems_TerminalQueue(queue, 0, k - 1);
    }
}

void write_Terminal(Terminal *terminal, CByteArray *buf, unsigned nbyte)
{
    unsigned k;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "write_Terminal: terminal is NULL");
    assertion(((buf == NULL) => (nbyte == 0)),
        "write_Terminal: buf is NULL, but nbyte is not zero");
    assertion(((buf != NULL) => (nbyte <= size_CByteArray(buf))),
        "write_Terminal: nbyte is out of range");

    traceFormattedUserInfo("write %u bytes to terminal", nbyte);

    queue = getOutputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "write_Terminal: queue is NULL");

    for(k = 0; k < nbyte; k++)
        appendByte_TerminalQueue(queue, byteAt_CByteArray(buf, k), overallTimeInterval);
}

void echo_Terminal(Terminal *terminal, CByteArray *buf, unsigned nbyte)
{
    unsigned k;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "echo_Terminal: terminal is NULL");
    assertion(((buf == NULL) => (nbyte == 0)),
        "echo_Terminal: buf is NULL, but nbyte is not zero");
    assertion(((buf != NULL) => (nbyte <= size_CByteArray(buf))),
        "echo_Terminal: nbyte is out of range");
    
    /* [Implicit requirement] */
    if(isPTM_Terminal(terminal))
        return;

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "echo_Terminal: termios is NULL");

    queue = getOutputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "echo_Terminal: queue is NULL");

    for(k = 0; k < nbyte; k++)
    {
        ByteT c = byteAt_CByteArray(buf, k);

        if(c == '\n' && (termios->lflag->echo || termios->lflag->echonl &&
           termios->lflag->icanon) || c != '\n' && (termios->lflag->echo))
        {
           appendByte_TerminalQueue(queue, c, overallTimeInterval);
        }
    }
}

bool checkParity_Terminal(Terminal *terminal, ByteT byte)
{
    TermIOS *termios;
    ByteT mask;
    bool odd = false;

    assertion((terminal != NULL),
        "checkParity_Terminal: terminal is NULL");

    termios = getTermIOS_Terminal(terminal);    

    assertion((termios != NULL),
        "checkParity_Terminal: termios is NULL");

    if(!termios->cflag->parenb)
        return true;
    
    for(mask = 0x01; mask <= 0x10; mask = mask << 1)
    {
        if((byte & mask) != 0) odd = !odd;
    }

    return odd != termios->cflag->parodd;
}

bool isMaxCanonLimitExceeded(CallContext context, FileDescId fildes, Terminal *terminal)
{
    unsigned k, l, size;
    CCT eol, eof;
    LongT max_canon;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "isMaxCanonLimitExceeded: terminal is NULL");
    assertion((isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes)),
        "isMaxCanonLimitExceeded: fildes is not a terminal");

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "isMaxCanonLimitExceeded: termios is NULL");

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "isMaxCanonLimitExceeded: queue is NULL");

    max_canon =
        getFileDescSystemConfigurationValue(context, fildes, SUT_PC_MAX_CANON);

    if(max_canon == SC_VALUE_UNKNOWN || max_canon == SC_VALUE_NO_LIMIT)
        return false;

    if((size = size_TerminalQueue(queue)) < max_canon)
        return false;

    eol = getControlCharacter_TermIOS(termios, SUT_VEOL);
    eof = getControlCharacter_TermIOS(termios, SUT_VEOF);

    for(k = l = 0; k < size; k++)
    {
        ByteT c = getByte_TerminalQueue(queue, k);

        if(c == '\n' || c == eol)
            return l + 1 > max_canon;
        
        if(c == eof)
            return l > max_canon;

        if(!isDiscardedControlCharacter_TermIOS(termios, c)) l++;
    }

    return l > max_canon;
}

bool isMaxInputLimitExceeded(CallContext context, FileDescId fildes,
                             Terminal *terminal)
{
    CCT min;
    LongT max_input;
    TermIOS *termios;
    TerminalQueue *queue;

    assertion((terminal != NULL),
        "isMaxInputLimitExceeded: terminal is NULL");
    assertion((isValid_FileDescId(fildes) && isTerminal_FileDescId(fildes)),
        "isMaxInputLimitExceeded: fildes is not a terminal");

    max_input = getFileDescSystemConfigurationValue(context, fildes, SUT_PC_MAX_INPUT);

    if(max_input == SC_VALUE_UNKNOWN || max_input == SC_VALUE_NO_LIMIT)
        return false;

    queue = getInputQueue_Terminal(terminal);

    assertion((queue != NULL),
        "isMaxInputLimitExceeded: queue is NULL");

    if(size_TerminalQueue(queue) > max_input)
        return true;

    termios = getTermIOS_Terminal(terminal);

    assertion((termios != NULL),
        "isMaxInputLimitExceeded: termios is NULL");

    min = getControlCharacter_TermIOS(termios, SUT_VMIN);

    if(!isPTM_Terminal(terminal) && !termios->lflag->icanon && min > max_input)
        return false;

    return true;
}

/********************************************************************/
/**               Auxiliary Specification Functions                **/
/********************************************************************/

/** settermios_spec **/
specification
void settermios_spec(CallContext context, TermIOSPtr termios_p, TermIOS *termios)
{
    pre        { return true;}
    coverage C { return { TheOnlyBranch, "The only branch" }; }
    post       { return true; }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

/** FileDescId -m-> Terminal */
Map* getAllTerminals(void)
{
    int i, j, k, size1, size2, size3;
    Map *res = create_Map(&type_FileDescIdObj, &type_Terminal);

    size1 = size_Map(systems);
    for(i = 0; i < size1; i++)
    {
        SystemState *system_state = get_Map(systems, key_Map(systems, i));

        size2 = size_Map(system_state->processes);
        for(j = 0; j < size2; j++)
        {
            ProcessState *process_state = get_Map(system_state->processes,
                key_Map(system_state->processes, j));

            size3 = size_Map(process_state->file_descriptors);
            for(k = 0; k < size3; k++)
            {
                FileDescriptor* file_descriptor = get_Map(process_state->file_descriptors,
                    key_Map( process_state->file_descriptors, k));
                Terminal *terminal = getTerminal_FileDescId(file_descriptor->file_desc_id);
                
                put_Map(res, create_FileDescIdObj(file_descriptor->file_desc_id), terminal);
            }
        }
    }

    return res;
}

Terminal* findTerminal(Map *terminals, FileDescId file_desc_id)
{
    assertion((terminals != NULL),
        "getTerminal: terminal is NULL");

    return get_Map(terminals, create_FileDescIdObj(file_desc_id));
}

/**
 * Returns/sets state of the terminal device referenced by the file_desc_id
 * argument. If the file_desc_id is a valid file descriptor id or it does not
 * refer to a terminal device (real or pseudo), the result is undefined.
 */
Terminal* getTerminal_FileDescId(FileDescId file_desc_id)
{
    File *file;
    FileDescriptor *file_desc;

    assertion(isValid_FileDescId(file_desc_id),
        "getTerminal_FileDescId: invalid file descriptor id");
    assertion(isTerminal_FileDescId(file_desc_id),
        "getTerminal_FileDescId: not a terminal descriptor id");

    file_desc = getFileDescriptor(file_desc_id);

    assertion((file_desc != NULL),
        "getTerminal_FileDescId: file_desc is NULL");

    if(isWrong_FileId(file_desc->file))
        return NULL;

    file = getFile_FileId(file_desc->file);

    assertion((file != NULL),
        "getTerminal_FileDescId: file is NULL");

    return file->descriptor;
}

void setTerminal_FileDescId(FileDescId file_desc_id, Terminal *terminal)
{
    File *file;
    FileDescriptor *file_desc;

    assertion(isValid_FileDescId(file_desc_id),
        "setTerminal_FileDescId: invalid file descriptor id");
    assertion(isTerminal_FileDescId(file_desc_id),
        "setTerminal_FileDescId: not a terminal descriptor id");

    file_desc = getFileDescriptor(file_desc_id);

    assertion((file_desc != NULL),
        "setTerminal_FileDescId: file_desc is NULL");
    assertion(!isWrong_FileId(file_desc->file),
        "setTerminal_FileDescId: file_desc->file is wrong");

    file = getFile_FileId(file_desc->file);

    assertion((file != NULL),
        "getTerminal_FileDescId: file is NULL");

    file->descriptor = terminal;
}

TerminalDescriptor* getTerminalDescriptor_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor *file_desc;

    assertion(isTerminal_FileDescId(file_desc_id),
        "getTerminalDescriptor_FileDescId: not a terminal descriptor id");

    file_desc = getFileDescriptor(file_desc_id);

    return file_desc->description->descriptor;
}

void setTerminalDescriptor_FileDescId(FileDescId file_desc_id, TerminalDescriptor *term_desc)
{
    FileDescriptor *file_desc;

    assertion(isTerminal_FileDescId(file_desc_id),
        "setTerminalDescriptor_FileDescId: not a terminal descriptor id");

    file_desc = getFileDescriptor(file_desc_id);

    file_desc->description->descriptor = term_desc;
}

bool isTerminal_FileDescId(FileDescId file_desc_id)
{
    Object *descriptor = getDescriptor_FileDescId(file_desc_id);

    return getFileKind_FileDescId(file_desc_id) == CharacterFile
        && descriptor != NULL
        && type(descriptor) == &type_TerminalDescriptor;
}

bool isRealTerminal_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isRealTerminal_FileDescId: terminal is NULL");

    return isReal_Terminal(terminal);
}

bool isPT_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isPT_FileDescId: terminal is NULL");

    return isPT_Terminal(terminal);
}

bool isPTM_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isPTM_FileDescId: terminal is NULL");

    return isPTM_Terminal(terminal);
}

bool isPTS_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isPTS_FileDescId: terminal is NULL");

    return isPTS_Terminal(terminal);
}

void setTerminalType_FileDescId(FileDescId file_desc_id, TerminalType type)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setTerminalType_FileDescId: terminal is NULL");

    setType_Terminal(terminal, type);
}

TermIOS* getTermIOS_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "getTermIOS_FileDescId: terminal is NULL");

    return getTermIOS_Terminal(terminal);
}

void setTermIOS_FileDescId(FileDescId file_desc_id, TermIOS *termios)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setTermIOS_FileDescId: terminal is NULL");

    setTermIOS_Terminal(terminal, termios);
}

void addTermIOS_FileDescId(FileDescId file_desc_id, TermIOS *termios)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "addTermIOS_FileDescId: terminal is NULL");

    addTermIOS_Terminal(terminal, termios);
}

FileDescId getCPart_FileDescId(FileDescId file_desc_id)
{
    TerminalDescriptor *term_desc =
        getTerminalDescriptor_FileDescId(file_desc_id);

    assertion((term_desc != NULL),
        "getCPart_FileDescId: term_desc is NULL");

    return getCPart_TerminalDescriptor(term_desc);
}

void setCPart_FileDescId(FileDescId file_desc_id, FileDescId cpart)
{
    TerminalDescriptor *term_desc =
        getTerminalDescriptor_FileDescId(file_desc_id);

    assertion((term_desc != NULL),
        "setCPart_FileDescId: term_desc is NULL");

    setCPart_TerminalDescriptor(term_desc, cpart);
}

CString* getPTSName_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "getPTSName_FileDescId: terminal is NULL");

    return getPTSName_Terminal(terminal);
}

void setPTSName_FileDescId(FileDescId file_desc_id, CString *ptsname)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setPTSName_FileDescId: terminal is NULL");

    setPTSName_Terminal(terminal, ptsname);
}

Bool3 getControllingStatus_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "getControllingStatus_FileDescId: terminal is NULL");

    return getControllingStatus_Terminal(terminal);
}

void setControllingStatus_FileDescId(FileDescId file_desc_id, Bool3 control_status)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setControllingStatus_FileDescId: terminal is NULL");

    setControllingStatus_Terminal(terminal, control_status);
}

bool isControllingTerminal_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isControllingTerminal_FileDescId: terminal is NULL");

    return isControlling_Terminal(terminal);
}

bool isNotControllingTerminal_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isNotControllingTerminal_FileDescId: terminal is NULL");

    return isNotControlling_Terminal(terminal);
}

ProcessIdObj* getSessionId_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "getSessionId_FileDescId: terminal is NULL");

    return getSessionId_Terminal(terminal);
}

void setSessionId_FileDescId(FileDescId file_desc_id, ProcessIdObj *sessionid)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setSessionId_FileDescId: terminal is NULL");

    setSessionId_Terminal(terminal, sessionid);
}

ProcessIdObj* getForegroundPGroupId_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "getForegroundPGroupId_FileDescId: terminal is NULL");

    return getForegroundPGroupId_Terminal(terminal);
}

void setForegroundPGroupId_FileDescId(FileDescId file_desc_id, ProcessIdObj *fpgroupid)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setForegroundPGroupId_FileDescId: terminal is NULL");

    setForegroundPGroupId_Terminal(terminal, fpgroupid);
}

WinSize* getTerminalWinSize_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "getTerminalWinSize_FileDescId: terminal is NULL");

    return getWinSize_Terminal(terminal);
}

void setTerminalWinSize_FileDescId(FileDescId file_desc_id, WinSize *wsize)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "setTerminalWinSize_FileDescId: terminal is NULL");

    setWinSize_Terminal(terminal, wsize);
}

bool isTerminalLocked_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isTerminalLocked_FileDescId: terminal is NULL");

    return isLocked_Terminal(terminal);
}

void lockTerminal_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "lockTerminal_FileDescId: terminal is NULL");
    
    lock_Terminal(terminal);
}

void unlockTerminal_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "unlockTerminal_FileDescId: terminal is NULL");
    
    unlock_Terminal(terminal);
}

bool isTerminalInputSuspended_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isTerminalInputSuspended_FileDescId: terminal is NULL");

    return isInputSuspended_Terminal(terminal);
}

void suspendTerminalInput_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "suspendTerminalInput_FileDescId: terminal is NULL");

    suspendInput_Terminal(terminal);
}

void restartTerminalInput_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "restartTerminalInput_FileDescId: terminal is NULL");

    restartInput_Terminal(terminal);
}

bool isTerminalOutputSuspended_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "isTerminalOutputSuspended_FileDescId: terminal is NULL");

    return isOutputSuspended_Terminal(terminal);
}

void suspendTerminalOutput_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "suspendTerminalOutput_FileDescId: terminal is NULL");

    suspendOutput_Terminal(terminal);
}

void restartTerminalOutput_FileDescId(FileDescId file_desc_id)
{
    Terminal *terminal = getTerminal_FileDescId(file_desc_id);

    assertion((terminal != NULL),
        "restartTerminalOutput_FileDescId: terminal is NULL");

    restartOutput_Terminal(terminal);
}

bool isTerminal_FileDescriptor(FileDescriptor *file_descriptor)
{
    assertion((file_descriptor != NULL),
        "isTerminal_FileDescriptor: file_descriptor is NULL");

    return file_descriptor->description->kind == CharacterFile
        && file_descriptor->description->descriptor != NULL
        && type(file_descriptor->description->descriptor) == &type_TerminalDescriptor;
}

bool isTerminal_File(File *file)
{
    assertion((file != NULL),
        "isTerminal_File: file is NULL");

    return file->kind == CharacterFile
        && file->descriptor != NULL
        && type(file->descriptor) == &type_Terminal;
}

Bool3 isCorrectLoginName(CallContext context, CString *name)
{
    LongT login_name_max =
        getSystemConfigurationValue(context, SUT_SC_LOGIN_NAME_MAX);

    if(name == NULL)
        return False_Bool3;

    if(login_name_max == SC_VALUE_NO_LIMIT)
        return Unknown_Bool3;
        
    if(login_name_max == SC_VALUE_UNKNOWN)
        return Unknown_Bool3;

    return length_CString(name) <= (SizeT)login_name_max ?
        True_Bool3 : False_Bool3;
}

Bool3 isCorrectTerminalName(CallContext context, CString *name)
{
    LongT tty_name_max =
        getSystemConfigurationValue(context, SUT_SC_TTY_NAME_MAX);

    if(name == NULL)
        return False_Bool3;

    if(tty_name_max == SC_VALUE_NO_LIMIT)
        return Unknown_Bool3;
        
    if(tty_name_max == SC_VALUE_UNKNOWN)
        return Unknown_Bool3;

    return length_CString(name) <= (SizeT)tty_name_max ?
        True_Bool3 : False_Bool3;
}

Bool3 isCorrectTerminalNameSize(CallContext context, FileDescId fildes, SizeT namesize)
{
    CString *name = getPath_FileDescId(fildes);
    LongT tty_name_max = getSystemConfigurationValue(context,
        SUT_SC_TTY_NAME_MAX);

    if(name != NULL)
        return namesize >= length_CString(name) + 1 ? True_Bool3 : False_Bool3;

    if(tty_name_max == SC_VALUE_NO_LIMIT)
        return Unknown_Bool3;

    if(tty_name_max == SC_VALUE_UNKNOWN)
        return Unknown_Bool3;

    return namesize >= (SizeT)tty_name_max ? True_Bool3 : Unknown_Bool3;
}

Bool3 isCorrectLoginNameSize(CallContext context, SizeT namesize)
{
    ProcessId processid = getProcessId_CallContext(context);

    LongT login_name_max = getSystemConfigurationValue(context,
        SUT_SC_LOGIN_NAME_MAX);
    
    Terminal *cterm = hasControllingTerminal_ProcessId(processid) ?
        getControllingTerminal_ProcessId(processid) : NULL;

    CString *name = cterm != NULL ? getLogin_Terminal(cterm) : NULL;

    if(name != NULL)
        return namesize >= length_CString(name) + 1 ? True_Bool3 : False_Bool3;

    if(login_name_max == SC_VALUE_NO_LIMIT)
        return Unknown_Bool3;

    if(login_name_max == SC_VALUE_UNKNOWN)
        return Unknown_Bool3;

    return namesize >= (SizeT)login_name_max ? True_Bool3 : Unknown_Bool3;
}

/*
 * Returns true iff the process identified by the processid
 * is a controlling process. 
 *
 * IEEE Std 1003.1, 2004 Edition defines controlling process as follows:
 *   Section 3. Definitions
 *    3.113 Controlling Process
 *    The session leader that established the connection to the controlling
 *    terminal. If the terminal subsequently ceases to be a controlling terminal
 *    for this session, the session leader ceases to be the controlling process.
 *
 * Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
 */
Bool3 isControllingProcess_ProcessId(ProcessId processid)
{
    return equals_ProcessId(processid, getSessionId_ProcessId(processid)) &&
        hasControllingTerminal_ProcessId(processid) ? True_Bool3 : False_Bool3;
}

/*
 * Disassociate the controlling terminal from the session containing the
 * process identified by the processid.
 */
void disassociateControllingTerminal(ProcessId processid)
{
    Terminal *cterm = getControllingTerminal_ProcessId(processid);

    if(cterm != NULL)
    {
        setSessionId_Terminal(cterm, create_ProcessIdObj(WrongProcessId));
        setControllingStatus_Terminal(cterm, False_Bool3);
    }
}
