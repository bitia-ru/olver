/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "common/coverages.seh"
#include "config/interpretation.seh"
#include "io/fstream/buffer_config.h"
#include "io/fstream/buffer_model.seh"
#include "locale/ctype/ctype_model.seh"
#include "math/math/math_data.seh"

#pragma SEC subsystem fstream "io.fstream"

/*
   The group of functions 'io.fstream.buffer' consists of:
       setbuf [2]
       setbuffer [1]
       setvbuf [2]
 */

coverage CoverageForBufferingType( BufferingType bt ) {
    switch ( bt ) {
        case SUT_IOFBF: return { FullyBuffered, "fully buffered" };
        case SUT_IOLBF: return { LineBuffered , "line buffered"  };
        case SUT_IONBF: return { Unbuffered   , "unbuffered"     };
    }
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    setbuf - assign buffering to a stream

SYNOPSIS

    #include <stdio.h>
    void setbuf(FILE *restrict stream, char *restrict buf);


DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    Except that it returns no value, the function call:

       setbuf(stream, buf)


    shall be equivalent to:

        setvbuf(stream, buf, _IOFBF, BUFSIZ)


    if buf is not a null pointer, or to:

        setvbuf(stream, buf, _IONBF, BUFSIZ)

    if buf is a null pointer.

RETURN VALUE

    The setbuf() function shall not return a value.

ERRORS

    No errors are defined.
*/
specification
void setbuf_spec( CallContext context, FILETPtr stream, VoidTPtr buf )
{
    pre
    {
        /*
        * The setvbuf() function may be used after the stream pointed to by stream is
        * associated with an open file but before any other operation (other than an
        * unsuccessful call to setvbuf()) is performed on the stream.
        */
        REQ("app.setbuf.setvbuf.01", "", TODO_REQ());

        return true;
    }
    coverage setbuf_coverage = CoverageForFILETPtr( stream ) * CoverageForPointer( buf );
    post
    {
        if ( setbuf_coverage[ 1 ] == CoverageForPointer.NullPointer )
        {
            /*
             * setvbuf(stream, buf, _IONBF, BUFSIZ)
             *
             * if buf is a null pointer.
             */
            REQ("setbuf.02", "", TODO_REQ());

            /*
             * {_IONBF} shall cause input/output to be unbuffered.
             */
            REQ("setbuf.setvbuf.02.03", "", TODO_REQ());

            /*
             * otherwise, size may determine the size of a buffer allocated by the setvbuf()
             * function.
             */
            REQ("setbuf.setvbuf.03.02", "", TODO_REQ());
        }
        else
        {
            /*
             * Except that it returns no value, the function call: setbuf(stream, buf)
             *
             * shall be equivalent to: setvbuf(stream, buf, _IOFBF, BUFSIZ)
             *
             * if buf is not a null pointer, or to:
             */
            REQ("setbuf.01", "", TODO_REQ());

            /*
             * {_IOFBF} shall cause input/output to be fully buffered.
             */
            REQ("setbuf.setvbuf.02.01", "", TODO_REQ());

            /*
             * If buf is not a null pointer, the array it points to may be used instead of a
             * buffer allocated by setvbuf() and the argument size specifies the size of the
             * array;
             */
            REQ("setbuf.setvbuf.03.01", "", TODO_REQ());

            /*
             * The contents of the array at any time are unspecified.
             */
            REQ( "setbuf.setvbuf.04", "The contents of the array at any time are unspecified", true );
        }

        /*
         * The setbuf() function shall not return a value.
         */
        REQ( "setbuf.03", "setbuf() shall not return a value", true );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    setbuffer -- stream buffering operation

SYNOPSIS

    #include <stdio.h>
    void setbuffer(FILE * stream, char * buf, size_t size);

DESCRIPTION

    setbuffer() is an alias for the call to setvbuf(). It works the same,
    except that the size of the buffer in setbuffer() is up to the caller,
    rather than being determined by the default BUFSIZ.
*/
specification
void setbuffer_spec( CallContext context, FILETPtr stream, VoidTPtr buf, SizeT size, ErrorCode * errno )
{
    StreamState * preStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        /*
        * The setvbuf() function may be used after the stream pointed to by stream is
        * associated with an open file but before any other operation (other than an
        * unsuccessful call to setvbuf()) is performed on the stream.
        */
        REQ("app.setbuffer.setvbuf.01", "", TODO_REQ());

        /*
         * If buf is not a null pointer, the array it points to may be used instead of a
         * buffer allocated by setvbuf() and the argument size specifies the size of the
         * array;
         */
        REQ("app.setbuffer.setvbuf.03.01", "", TODO_REQ());

        return true;
    }
    coverage setbuffer_coverage = CoverageForFILETPtr            ( stream                      ) *
                                  CoverageForPointer             ( buf                         ) *
                                  CoverageForInteger_MinMiddleMax( size   , 0, 10, SUT_INT_MAX );
    post
    {
        /*
         * may set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_SETBUFFER, "setbuffer.05.02", * errno != SUT_EOK, * errno )
            /*
             * The setvbuf() function may fail if:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not valid.
             */
            ERROR_MAY(POSIX_SETBUFFER, EBADF, "setbuffer.06.01", preStreamState == NULL )
        ERROR_END()

        if ( setbuffer_coverage[ 1 ] == CoverageForPointer.NullPointer )
        {
            /*
             * otherwise, size may determine the size of a buffer allocated by the setvbuf()
             * function.
             */
            REQ("setbuffer.setvbuf.03.02", "", TODO_REQ());
        }
        else
        {
            /*
             * If buf is not a null pointer, the array it points to may be used instead of a
             * buffer allocated by setvbuf() and the argument size specifies the size of the
             * array;
             */
            REQ("setbuffer.setvbuf.03.01", "", TODO_REQ());

            /*
             * The contents of the array at any time are unspecified.
             */
            REQ( "setbuffer.setvbuf.04", "The contents of the array at any time are unspecified", true );
        }

        /*
         * setbuffer() is an alias for the call to setvbuf(). It works the same, except
         * that the size of the buffer in setbuffer() is up to the caller, rather than
         * being determined by the default BUFSIZ.
         */
        REQ( "setbuffer.01", "setbuffer() is an alias for the call to setvbuf()", true );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    setvbuf - assign buffering to a stream

SYNOPSIS

    #include <stdio.h>
    int setvbuf(FILE *restrict stream, char *restrict buf, int type,
        size_t size);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The setvbuf() function may be used after the stream pointed to by stream is
    associated with an open file but before any other operation (other than an
    unsuccessful call to setvbuf()) is performed on the stream. The argument
    type determines how stream shall be buffered, as follows:

    {_IOFBF} shall cause input/output to be fully buffered.

    {_IOLBF} shall cause input/output to be line buffered.

    {_IONBF} shall cause input/output to be unbuffered.

    If buf is not a null pointer, the array it points to may be used instead of
    a buffer allocated by setvbuf() and the argument size specifies the size of
    the array; otherwise, size may determine the size of a buffer allocated by
    the setvbuf() function. The contents of the array at any time are
    unspecified.

    For information about streams, see Standard I/O Streams.

RETURN VALUE
    Upon successful completion, setvbuf() shall return 0. Otherwise, it shall
    return a non-zero value if an invalid value is given for type or if the
    request cannot be honored, [CX]   and may set errno to indicate the error.

ERRORS

    The setvbuf() function may fail if:

    [EBADF]
    [CX]  The file descriptor underlying stream is not valid.
*/
specification
IntT setvbuf_spec( CallContext context, FILETPtr stream, VoidTPtr buf, IntT type, SizeT size, ErrorCode * errno )
{
    StreamState * preStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        /*
        * The setvbuf() function may be used after the stream pointed to by stream is
        * associated with an open file but before any other operation (other than an
        * unsuccessful call to setvbuf()) is performed on the stream.
        */
        REQ("app.setvbuf.01", "", TODO_REQ());

        /*
         * If buf is not a null pointer, the array it points to may be used instead of a
         * buffer allocated by setvbuf() and the argument size specifies the size of the
         * array;
         */
        REQ( "app.setvbuf.03.01", "", TODO_REQ());

        return true;
    }
    coverage setvbuf_coverage = CoverageForFILETPtr            ( stream                      ) *
                                CoverageForPointer             ( buf                         ) *
                                CoverageForBufferingType       ( type                        ) *
                                CoverageForInteger_MinMiddleMax( size   , 0, 10, SUT_INT_MAX );
    post
    {
        /*
         * Otherwise, it shall return a non-zero value if an invalid value is given for
         * type or if the request cannot be honored, [CX] and may set errno to indicate
         * the error.
         */
        ERROR_BEGIN( POSIX_SETVBUF, "setvbuf.05.02", setvbuf_spec != 0, * errno )
            /*
             * The setvbuf() function may fail if:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not valid.
             */
            ERROR_MAY(POSIX_SETVBUF, EBADF, "setvbuf.06.01", preStreamState == NULL )
        ERROR_END()

        switch ( setvbuf_coverage[ 2 ] )
        {
            case CoverageForBufferingType.FullyBuffered:
                /*
                 * The argument type determines how stream shall be buffered, as follows:
                 *
                 * {_IOFBF} shall cause input/output to be fully buffered.
                 */
                REQ("setvbuf.02.01", "", TODO_REQ());
                break;

            case CoverageForBufferingType.LineBuffered:
                /*
                 * The argument type determines how stream shall be buffered, as follows:
                 *
                 * {_IOLBF} shall cause input/output to be line buffered.
                 */
                REQ("setvbuf.02.02", "", TODO_REQ());
                break;

            case CoverageForBufferingType.Unbuffered:
                /*
                 * The argument type determines how stream shall be buffered, as follows:
                 *
                 * {_IONBF} shall cause input/output to be unbuffered.
                 */
                REQ("setvbuf.02.03", "", TODO_REQ());
                break;
        }

        if ( setvbuf_coverage[ 1 ] == CoverageForPointer.NullPointer )
        {
            /*
             * otherwise, size may determine the size of a buffer allocated by the setvbuf()
             * function.
             */
            REQ("setvbuf.03.02", "", TODO_REQ());
        }
        else
        {
            /*
             * If buf is not a null pointer, the array it points to may be used instead of a
             * buffer allocated by setvbuf() and the argument size specifies the size of the
             * array;
             */
            REQ("setvbuf.03.01", "", TODO_REQ());

            /*
             * The contents of the array at any time are unspecified.
             */
            REQ( "setvbuf.04", "The contents of the array at any time are unspecified", true );
        }

        /*
         * Upon successful completion, setvbuf() shall return 0.
         */
        REQ( "setvbuf.05.01", "setvbuf() shall return 0", setvbuf_spec == 0 );

        return true;
    }
}
