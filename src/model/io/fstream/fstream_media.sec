/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common/common_media.seh"
#include "data/stdio_model.seh"
#include "io/file/file_model.seh"
#include "io/fstream/fstream_media.seh"
#include "io/fstream/fstream_model.seh"
#include "system/system/system_model.seh"

/********************************************************************/
/**                    Initialization Function                     **/
/********************************************************************/

void initIoFstreamSubsystem(void)
{
  // Set up mediators
    set_mediator__IO_feof_spec  ( _IO_feof_media   );
    set_mediator__IO_getc_spec  ( _IO_getc_media   );
    set_mediator__IO_putc_spec  ( _IO_putc_media   );
    set_mediator__IO_puts_spec(_IO_puts_media);
    set_mediator___fpending_spec( __fpending_media );
    set_mediator_clearerr_spec(clearerr_media);
    set_mediator_fclose_spec    ( fclose_media     );
    set_mediator_fdopen_spec    ( fdopen_media     );
    set_mediator_feof_spec      ( feof_media       );
    set_mediator_ferror_spec    ( ferror_media     );
    set_mediator_fflush_spec    ( fflush_media     );
    set_mediator_fgetc_spec     ( fgetc_media      );
    set_mediator_fgetpos_spec(fgetpos_media);
    set_mediator_fgets_spec     ( fgets_media      );
 // set_mediator_fgetwc_unlocked_spec(fgetwc_unlocked_media);
    set_mediator_fileno_spec    ( fileno_media     );
    set_mediator_fopen_spec     ( fopen_media      );
    set_mediator_fputc_spec     ( fputc_media      );
    set_mediator_fputs_spec     ( fputs_media      );
    set_mediator_fread_spec     ( fread_media      );
    set_mediator_freopen_spec   ( freopen_media    );
    set_mediator_fseek_spec     ( fseek_media      );
    set_mediator_fsetpos_spec(fsetpos_media);
    set_mediator_ftell_spec     ( ftell_media      );
    set_mediator_fwrite_spec    ( fwrite_media     );
    set_mediator_getw_spec      ( getw_media       );
    set_mediator_puts_spec(puts_media);
    set_mediator_putw_spec      ( putw_media       );
    set_mediator_rewind_spec    ( rewind_media     );
    set_mediator_ungetc_spec(ungetc_media);
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** _IO_feof_spec **/
mediator _IO_feof_media for specification
IntT _IO_feof_spec( CallContext context, FILETPtr __fp )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "_IO_feof:$(ptr)",
            create_VoidTPtrObj(__fp)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** _IO_getc_spec **/
mediator _IO_getc_media for specification
IntT _IO_getc_spec( CallContext context, FILETPtr __fp )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "_IO_getc:$(ptr)",
            create_VoidTPtrObj(__fp)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( _IO_getc_spec != SUT_EOF ) { onFgetc( context, __fp, _IO_getc_spec ); }
    }
}

/** _IO_putc_spec **/
mediator _IO_putc_media for specification
IntT _IO_putc_spec( CallContext context, IntT __c, FILETPtr __fp )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "_IO_putc:$(int)$(ptr)",
            create_IntTObj(__c),
            create_VoidTPtrObj(__fp)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( _IO_putc_spec == __c ) { onFputc( context, __fp, __c ); }
    }
}

/** _IO_puts_spec **/
mediator _IO_puts_media for specification
IntT _IO_puts_spec( CallContext context, CString * __c )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "_IO_puts:$(str)",
            __c
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** __fpending_spec **/
mediator __fpending_media for specification
SizeT __fpending_spec( CallContext context, FILETPtr stream )
{
    call
    {
        TSCommand command = create_TSCommand();
        SizeT res=-1;

        format_TSCommand(&command, "__fpending:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readSize_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** clearerr_spec **/
mediator clearerr_media for specification
void clearerr_spec( CallContext context, FILETPtr stream )
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "clearerr:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
        }

        destroy_TSCommand(&command);

        return;
  }
}

/** fclose_spec **/
mediator fclose_media for specification
IntT fclose_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    FileDescId fileId = a_fileno( context, stream );

    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "fclose:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        SystemState * systemState;
        onClose( context, fileId, fclose_spec );
        unregisterObjectInMemory( stream );
        systemState = getSystemState_CallContext( context );
        remove_Map( systemState->streams, create_FILETPtrObj( stream ) );
    }
}

/** fdopen_spec **/
mediator fdopen_media for specification
FILETPtr fdopen_spec( CallContext context, FileDescId fildes, CString * mode, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        FILETPtr res=NULL_VoidTPtr;

        format_TSCommand(&command, "fdopen:$(int)$(str)",
            create_IntTObj(fildes.filedesc),
            mode
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readPointer_TSStream(context, &command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( ! isNULL_VoidTPtr( fdopen_spec ) ) {
            SystemState * systemState;
            applyModeToFile( fildes, mode );
            systemState = getSystemState_CallContext( context );
            put_Map
                ( systemState->streams, create_FILETPtrObj( fdopen_spec ), construct_StreamState( context, fdopen_spec ) );
        }
    }
}

/** feof_spec **/
mediator feof_media for specification
IntT feof_spec( CallContext context, FILETPtr stream )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "feof:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** ferror_spec **/
mediator ferror_media for specification
IntT ferror_spec( CallContext context, FILETPtr stream )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "ferror:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** fflush_spec **/
//This mediator refers to: fflush, fflush_unlocked
mediator fflush_media for specification
IntT fflush_spec( CallContext context, FILETPtr stream, ErrorCode * errno, bool unlocked )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        if (unlocked)
        {
            format_TSCommand(&command, "fflush_unlocked:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        else
        {
            format_TSCommand(&command, "fflush:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** fgetc_spec **/
//This mediator refers to: fgetc, getc, getchar, getchar_unlocked, getc_unlocked
mediator fgetc_media for specification
IntT fgetc_spec( CallContext context, FILETPtr stream, ErrorCode * errno,
                 IntT getc_type, CString * input, CString * stdinAsFile
               )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        if (getc_type==F_Type)
        {
            format_TSCommand(&command, "fgetc:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        else if (getc_type==Macro_Type)
        {
            format_TSCommand(&command, "getc:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        else if (getc_type==Macro_Unlocked_Type)
        {
            format_TSCommand(&command, "getc_unlocked:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        else if (getc_type==Char_Type)
        {
            format_TSCommand( & command, "getchar:$(str)$(str)", input, stdinAsFile );
        }
        else
        {
            format_TSCommand( & command, "getchar_unlocked:$(str)$(str)", input, stdinAsFile );
        }

        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( getc_type != Char_Type && getc_type != Char_Unlocked_Type ) {
            if ( fgetc_spec != SUT_EOF ) { onFgetc( context, stream, fgetc_spec ); }
        }
    }
}

/** fgetpos_spec **/
//This mediator refers to: fgetpos, fgetpos64
mediator fgetpos_media for specification
IntT fgetpos_spec( CallContext context, FILETPtr stream, FPosTPtr pos, ErrorCode * errno, bool is64bits )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        if (!is64bits)
        {
            format_TSCommand(&command, "fgetpos:$(ptr)$(ptr)",
                create_VoidTPtrObj(stream),
                create_VoidTPtrObj(pos)
                );
        }
        else
        {
            format_TSCommand(&command, "fgetpos64:$(ptr)$(ptr)",
                create_VoidTPtrObj(stream),
                create_VoidTPtrObj(pos)
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** fgets_spec **/
mediator fgets_media for specification
CString * fgets_spec( CallContext context, IntT n, FILETPtr stream, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        CString* res=NULL;
        bool notNULL;

        format_TSCommand(&command, "fgets:$(ptr)$(int)",
            create_VoidTPtrObj(stream),
            create_IntTObj(n)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            notNULL = readInt_TSStream(&command.response);
            if (notNULL)
            {
                res=readCString_TSStream(&command.response);
            }
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( fgets_spec != NULL ) { onFgets( context, stream, fgets_spec ); }
    }
}

/** fileno_spec **/
mediator fileno_media for specification
IntT fileno_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "fileno:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** fopen_spec **/
//This mediator refers to: fopen, fopen64
mediator fopen_media for specification
FILETPtr fopen_spec( CallContext context, CString * filename, CString * mode, ErrorCode * errno, bool is64bits )
{
    call
    {
        TSCommand command = create_TSCommand();
        FILETPtr res=NULL_VoidTPtr;

        if (!is64bits)
        {
            format_TSCommand(&command, "fopen:$(str)$(str)",
                filename,
                mode
                );
        }
        else
        {
            format_TSCommand(&command, "fopen64:$(str)$(str)",
                filename,
                mode
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readPointer_TSStream( context, & command.response );
            * errno = readInt_TSStream( & command.response );
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        // verbose( "fopen_media, state : * errno is %d\n", * errno );
        if ( ! isNULL_VoidTPtr( fopen_spec ) ) {
            FileDescId        fileId = a_fileno       ( context, fopen_spec );
            OpenFlags         oflags = convertToOflag (          mode       );
            FilePermissions * perm   = currentFilePerm( context             );
            SystemState * systemState;
            onOpen( context, filename, oflags, perm, fileId, is64bits );
            registerObjectInMemory( fopen_spec, 0, create_FILET( fopen_spec, fileId ) );
            systemState = getSystemState_CallContext( context );
            put_Map
                ( systemState->streams, create_FILETPtrObj( fopen_spec ), construct_StreamState( context, fopen_spec ) );
        }
    }
}

/** fputc_spec **/
//This mediator refers to: fputc, putc, putc_unlocked, putchar, putchar_unlocked
mediator fputc_media for specification
IntT fputc_spec( CallContext context, IntT c, FILETPtr stream, ErrorCode * errno, IntT putc_type )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;
        if (putc_type==F_Type)
        {
            format_TSCommand(&command, "fputc:$(ptr)$(int)",
                create_VoidTPtrObj(stream),
                create_IntTObj(c)
                );
        }
        else if (putc_type==Macro_Type)
        {
            format_TSCommand(&command, "putc:$(ptr)$(int)",
                create_VoidTPtrObj(stream),
                create_IntTObj(c)
                );
        }
        else if (putc_type==Macro_Unlocked_Type)
        {
            format_TSCommand(&command, "putc_unlocked:$(ptr)$(int)",
                create_VoidTPtrObj(stream),
                create_IntTObj(c)
                );
        }
        else if (putc_type==Char_Type)
        {
            format_TSCommand(&command, "putchar:$(int)",
                create_IntTObj(c)
                );
        }
        else
        {
            format_TSCommand(&command, "putchar_unlocked:$(int)",
                create_IntTObj(c)
                );
        }

        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( putc_type != Char_Type && putc_type != Char_Unlocked_Type ) {
            if ( fputc_spec == c ) { onFputc( context, stream, c ); }
        }
    }
}

/** fputs_spec **/
mediator fputs_media for specification
IntT fputs_spec( CallContext context, CString * s, FILETPtr stream, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "fputs:$(ptr)$(str)",
            create_VoidTPtrObj(stream),
            s
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( fputs_spec >= 0 ) { onFputs( context, stream, s ); }
    }
}

/** fread_spec **/
mediator fread_media for specification
SizeT fread_spec( CallContext context, VoidTPtr ptr, SizeT size, SizeT nitems, FILETPtr stream, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        SizeT res;

        format_TSCommand(&command, "fread:$(ptr)$(ptr)$(size)$(size)",
            create_VoidTPtrObj(stream),
            create_VoidTPtrObj(ptr),
            create_SizeTObj(size),
            create_SizeTObj(nitems)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readSize_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( size != 0 && nitems != 0 ) {
            FileDescId fileId = a_fileno( context, stream );
            onRead( context, fileId, ptr, size * nitems, size * fread_spec );
        }
    }
}

/** freopen_spec **/
//This mediator refers to: freopen, freopen64
mediator freopen_media for specification
FILETPtr freopen_spec
             ( CallContext context, CString * filename, CString * mode, FILETPtr stream, ErrorCode * errno, bool is64bits )
{
    FileDescId preFileId = a_fileno( context, stream );

    call
    {
        TSCommand command = create_TSCommand();
        FILETPtr res=NULL_VoidTPtr;

        if (!is64bits)
        {
            format_TSCommand(&command, "freopen:$(str)$(str)$(ptr)",
                filename,
                mode,
                create_VoidTPtrObj(stream)
                );
        }
        else
        {
            format_TSCommand(&command, "freopen64:$(str)$(str)$(ptr)",
                filename,
                mode,
                create_VoidTPtrObj(stream)
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readPointer_TSStream(context, &command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( ! isNULL_VoidTPtr( freopen_spec ) ) {
            FileDescId postFileId = a_fileno( context, freopen_spec );
            SystemState * systemState;
            if ( filename == NULL ) {
                applyModeToFile( postFileId, mode );
            } else {
                OpenFlags         oflags = convertToOflag ( mode    );
                FilePermissions * perm   = currentFilePerm( context );
                onClose( context, preFileId, 0 );
                onOpen( context, filename, oflags, perm, postFileId, is64bits );
            }
            systemState = getSystemState_CallContext( context );
            remove_Map( systemState->streams, create_FILETPtrObj( stream ) );
            put_Map( systemState->streams,
                     create_FILETPtrObj( freopen_spec ), construct_StreamState( context, freopen_spec )
                   );
        }
    }
}

/** fseek_spec **/
//This mediator refers to: fseek, fseeko, fseeko64
mediator fseek_media for specification
IntT fseek_spec( CallContext context, FILETPtr stream, OffT offset, IntT whence, IntT offsetType, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        if (offsetType==LongType)
        {
            format_TSCommand(&command, "fseek:$(ptr)$(llong)$(int)",
                create_VoidTPtrObj(stream),
                create_LLongTObj(offset),
                create_IntTObj(whence)
                );
        }
        else if (offsetType==OffType)
        {
            format_TSCommand(&command, "fseeko:$(ptr)$(llong)$(int)",
                create_VoidTPtrObj(stream),
                create_LLongTObj(offset),
                create_IntTObj(whence)
                );
        }
        else
        {
            format_TSCommand(&command, "fseeko64:$(ptr)$(llong)$(int)",
                create_VoidTPtrObj(stream),
                create_LLongTObj(offset),
                create_IntTObj(whence)
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( fseek_spec == 0 ) {
            FileDescId fileId = a_fileno( context, stream );
            File * file = getFile_FileDescId( fileId );
            FileDescriptor * fdesc = getFileDescriptor( fileId );
            fdesc->offset = calculateOffset( fdesc, whence, offset, file->size );
        }
    }
}

/** fsetpos_spec **/
//This mediator refers to: fsetpos, fsetpos64
mediator fsetpos_media for specification
IntT fsetpos_spec( CallContext context, FILETPtr stream, FPosTPtr pos, bool is64bits, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        if (!is64bits)
        {
            format_TSCommand(&command, "fsetpos:$(ptr)$(ptr)",
                create_VoidTPtrObj(stream),
                create_VoidTPtrObj(pos)
                );
        }
        else
        {
            format_TSCommand(&command, "fsetpos64:$(ptr)$(ptr)",
                create_VoidTPtrObj(stream),
                create_VoidTPtrObj(pos)
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** ftell_spec **/
//This mediator refers to: ftell, ftello, ftello64
mediator ftell_media for specification
OffT ftell_spec( CallContext context, FILETPtr stream, ErrorCode * errno, IntT offsetType )
{
    call
    {
        TSCommand command = create_TSCommand();
        OffT res=-1;

        if (offsetType==LongType)
        {
            format_TSCommand(&command, "ftell:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        else if (offsetType==OffType)
        {
            format_TSCommand(&command, "ftello:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        else
        {
            format_TSCommand(&command, "ftello64:$(ptr)",
                create_VoidTPtrObj(stream)
                );
        }
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readLLong_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** fwrite_spec **/
mediator fwrite_media for specification
SizeT fwrite_spec( CallContext context, FILETPtr stream, VoidTPtr ptr, SizeT size, SizeT nitems, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        SizeT res;

        format_TSCommand(&command, "fwrite:$(ptr)$(ptr)$(size)$(size)",
            create_VoidTPtrObj(stream),
            create_VoidTPtrObj(ptr),
            create_SizeTObj(size),
            create_SizeTObj(nitems)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readSize_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( size != 0 && nitems != 0 ) {
            FileDescId fileId = a_fileno( context, stream );
            onWrite( context, fileId, ptr, size * nitems, size * fwrite_spec );
        }
    }
}

/** getw_spec **/
mediator getw_media for specification
IntT getw_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "getw:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( getw_spec != SUT_EOF ) {
            FileDescId fileId = a_fileno( context, stream );
            VoidTPtr buf = allocateMemoryBlock( context, sizeof( IntT ) );
            assertion( writeInt_VoidTPtr( buf, getw_spec ), "getw_media : writeInt_VoidTPtr" );
            onRead( context, fileId, buf, sizeof( IntT ), sizeof( IntT ) );
            deallocateMemoryBlock( context, buf );
        }
    }
}

/** puts_spec **/
mediator puts_media for specification
IntT puts_spec( CallContext context, CString * s, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "puts:$(str)",
            s
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}

/** putw_spec **/
mediator putw_media for specification
IntT putw_spec( CallContext context, FILETPtr stream, IntT w, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "putw:$(ptr)$(int)",
            create_VoidTPtrObj(stream),
            create_IntTObj(w)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
    state
    {
        if ( putw_spec == 0 ) {
            FileDescId fileId = a_fileno( context, stream );
            VoidTPtr buf = allocateMemoryBlock( context, sizeof( IntT ) );
            assertion( writeInt_VoidTPtr( buf, w ), "putw_media : writeInt_VoidTPtr" );
            onWrite( context, fileId, buf, sizeof( IntT ), sizeof( IntT ) );
            deallocateMemoryBlock( context, buf );
        }
    }
}

/** rewind_spec **/
mediator rewind_media for specification
void rewind_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    call
    {
        TSCommand command = create_TSCommand();

        format_TSCommand(&command, "rewind:$(ptr)",
            create_VoidTPtrObj(stream)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            *errno=readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return;
    }
    state
    {
        // verbose( "rewind_media, state : * errno is %d\n", * errno );
        if ( * errno == SUT_EOK ) {
            FileDescId fileId = a_fileno( context, stream );
            File * file = getFile_FileDescId( fileId );
            FileDescriptor * fdesc = getFileDescriptor( fileId );
            fdesc->offset = calculateOffset( fdesc, SEEK_SET, 0, file->size );
            // verbose( "rewind_media, state : fdesc->offset is %d\n", (int)fdesc->offset );
        }
    }
}

/** ungetc_spec **/
mediator ungetc_media for specification
IntT ungetc_spec( CallContext context, FILETPtr stream, IntT c, bool toStdIn )
{
    call
    {
        TSCommand command = create_TSCommand();
        IntT res=-1;

        format_TSCommand(&command, "ungetc:$(ptr)$(int)$(int)",
            create_VoidTPtrObj(stream),
            create_IntTObj(c),
            create_IntTObj(toStdIn)
            );
        executeCommandInContext(context, &command);
        if (!isBadVerdict())
        {
            timestamp = command.meta.timestamp;
            res = readInt_TSStream(&command.response);
        }

        destroy_TSCommand(&command);

        return res;
    }
}
