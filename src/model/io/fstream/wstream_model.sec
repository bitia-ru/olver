/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "common/coverages.seh"
#include "config/interpretation.seh"
#include "data/wchar_model.seh"
#include "io/fstream/wstream_config.h"
#include "io/fstream/wstream_model.seh"
#include "math/math/math_data.seh"
#include "process/process/process_common.seh"

#pragma SEC subsystem fstream "io.fstream"

/*
   The group of functions 'io.fstream.wstream' consists of:
       fgetwc [2]
       fgetws [2]
       fgetwc_unlocked [2]
       fputwc [2]
       fputws [2]
       fwide [2]
       getwc [2]
       getwchar [2]
       putwc [2]
       putwchar [2]
       ungetwc [2]
 */

coverage CoverageForIntTAsWCharT( IntT i ) {
    if      ( i <  -128 ) { return { Between_MInf_M128, "( -inf, -128 )" }; }
    else if ( i == -128 ) { return { Exactly_M128     , "-128"           }; }
    else if ( i <     0 ) { return { Between_M128_0   , "( -128,    0 )" }; }
    else if ( i ==    0 ) { return { Exactly_0        , "   0"           }; }
    else if ( i <   127 ) { return { Between_0_127    , "(    0,  127 )" }; }
    else if ( i ==  127 ) { return { Exactly_127      , " 127"           }; }
                     else { return { Between_127_Inf  , "(  127, +inf )" }; }
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fgetwc - get a wide-character code from a stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    wint_t fgetwc(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fgetwc() function shall obtain the next character (if present) from the
    input stream pointed to by stream, convert that to the corresponding
    wide-character code, and advance the associated file position indicator for
    the stream (if defined).

    If an error occurs, the resulting value of the file position indicator for
    the stream is unspecified.

    [CX] The fgetwc() function may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fgetwc(),
    fgetws(), fread(), fscanf(), getc(), getchar(), gets(), or scanf() using
    stream that returns data not supplied by a prior call to ungetc() or
    ungetwc().

RETURN VALUE

    Upon successful completion, the fgetwc() function shall return the
    wide-character code of the character read from the input stream pointed to
    by stream converted to a type wint_t. If the stream is at end-of-file, the
    end-of-file indicator for the stream shall be set and fgetwc() shall return
    WEOF. If a read error occurs, the error indicator for the stream shall be
    set, fgetwc() shall return WEOF, [CX]   and shall set errno to indicate the
    error. If an encoding error occurs, the error indicator for the stream
    shall be set, fgetwc() shall return WEOF, and shall set errno to indicate
    the error.

ERRORS
    The fgetwc() function shall fail if data needs to be read and:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor underlying
        stream and the thread would be delayed in the fgetwc() operation.

        [EBADF]
        [CX]  The file descriptor underlying stream is not a valid file
        descriptor open for reading.

        [EILSEQ]
        The data obtained from the input stream does not form a valid
        character.

        [EINTR]
        [CX]  The read operation was terminated due to the receipt of a signal,
        and no data was transferred.

        [EIO]
        [CX]  A physical I/O error has occurred, or the process is in a
        background process group attempting to read from its controlling
        terminal, and either the process is ignoring or blocking the SIGTTIN
        signal or the process group is orphaned. This error may also be
        generated for implementation-defined reasons.

        [EOVERFLOW]
        [CX]  The file is a regular file and an attempt was made to read at or
        beyond the offset maximum associated with the corresponding stream.

    The fgetwc() function may fail if:

        [ENOMEM]
        [CX]  Insufficient storage space is available.

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

-------------------------------------------------------------------------------

NAME

    fgetwc_unlocked -- non thread safe fgetwc

DESCRIPTION

    fgetwc_unlocked() is the same as fgetwc() except that it need not be
    thread safe. That is, it may only be invoked in the ways which are legal
    for getc_unlocked().
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getwc - get a wide character from a stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    wint_t getwc(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The getwc() function shall be equivalent to fgetwc(), except that if it is
    implemented as a macro it may evaluate stream more than once, so the
    argument should never be an expression with side effects.

RETURN VALUE

    Refer to fgetwc().

ERRORS

    Refer to fgetwc().
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers


The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getwchar - get a wide character from a stdin stream

SYNOPSIS

    #include <wchar.h>
    wint_t getwchar(void);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The getwchar() function shall be equivalent to getwc(stdin).

RETURN VALUE

    Refer to fgetwc().

ERRORS

    Refer to fgetwc().
*/

//This specification refers to: fgetwc, fgetwc_unlocked, getwc, getwchar
specification
WIntT fgetwc_spec( CallContext context, FILETPtr stream, ErrorCode * errno,
                   IntT getwc_type, WString * input, CString * stdinAsFile
                 )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fgetwc_coverage = CoverageForFILETPtr( stream );
    post
    {
        postStreamState = construct_StreamState( context, stream );
        verbose( "fgetwc_spec is %d\n", (int)fgetwc_spec );
        print_StreamState( preStreamState , "preStreamState is "  );
        print_StreamState( postStreamState, "postStreamState is " );

        /*
         * If an encoding error occurs, the error indicator for the stream shall be set,
         * fgetwc() shall return WEOF, and shall set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FGETWC,
                     "fgetwc.08;fgetwc_unlocked.fgetwc.08;getwc.fgetwc.08;getwchar.fgetwc.08",
                     fgetwc_spec == SUT_WEOF && * errno != SUT_EOK,
                     * errno
                   )
            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the fgetwc() operation.
             */
            ERROR_SHALL(POSIX_FGETWC, EAGAIN, "fgetwc.09.01;fgetwc_unlocked.fgetwc.09.01;getwc.fgetwc.09.01;getwchar.fgetwc.09.01", TODO_ERR(EAGAIN))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for reading.
             */
            ERROR_SHALL( POSIX_FGETWC, EBADF,
                         "fgetwc.09.02;fgetwc_unlocked.fgetwc.09.02;getwc.fgetwc.09.02;getwchar.fgetwc.09.02",
                         preStreamState == NULL || ! isAllowReading_StreamState( preStreamState )
                       )

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EILSEQ] The data obtained from the input stream does not form a valid
             * character.
             */
            ERROR_SHALL(POSIX_FGETWC, EILSEQ, "fgetwc.09.03;fgetwc_unlocked.fgetwc.09.03;getwc.fgetwc.09.03;getwchar.fgetwc.09.03", TODO_ERR(EILSEQ))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EINTR] [CX] The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FGETWC, EINTR, "fgetwc.09.04;fgetwc_unlocked.fgetwc.09.04;getwc.fgetwc.09.04;getwchar.fgetwc.09.04", TODO_ERR(EINTR))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is in a
             * background process group attempting to read from its controlling terminal, and
             * either the process is ignoring or blocking the SIGTTIN signal or the process
             * group is orphaned. This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_SHALL(POSIX_FGETWC, EIO, "fgetwc.09.05;fgetwc_unlocked.fgetwc.09.05;getwc.fgetwc.09.05;getwchar.fgetwc.09.05", TODO_ERR(EIO))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EOVERFLOW] [CX] The file is a regular file and an attempt was made to read
             * at or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FGETWC, EOVERFLOW, "fgetwc.09.06;fgetwc_unlocked.fgetwc.09.06;getwc.fgetwc.09.06;getwchar.fgetwc.09.06", TODO_ERR(EOVERFLOW))

            /*
             * The fgetwc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FGETWC, ENOMEM, "fgetwc.10.01;fgetwc_unlocked.fgetwc.10.01;getwc.fgetwc.10.01;getwchar.fgetwc.10.01", TODO_ERR(ENOMEM))

            /*
             * The fgetwc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FGETWC, ENXIO, "fgetwc.10.02;fgetwc_unlocked.fgetwc.10.02;getwc.fgetwc.10.02;getwchar.fgetwc.10.02", TODO_ERR(ENXIO))

            if ( fgetwc_spec == SUT_WEOF )
            {
                /*
                 * If an error occurs, the resulting value of the file position indicator for the
                 * stream is unspecified.
                 */
                REQ( "fgetwc.02;fgetwc_unlocked.fgetwc.02;getwc.fgetwc.02;getwchar.fgetwc.02",
                     "the resulting value of the file position indicator is unspecified", true
                   );

                /*
                 * If a read error occurs, the error indicator for the stream shall be set, fgetwc(
                 * ) shall return WEOF, [CX] and shall set errno to indicate the error.
                 */
                REQ( "fgetwc.07;fgetwc_unlocked.fgetwc.07;getwc.fgetwc.07;getwchar.fgetwc.07", "read error occurs", true );
            }
        ERROR_END()

        if ( getwc_type != Char_Type ) {
            if ( isEof_StreamState( preStreamState ) )
            {
                /*
                 * If the stream is at end-of-file, the end-of-file indicator for the stream shall
                 * be set and fgetwc() shall return WEOF.
                 */
                REQ( "fgetwc.06;fgetwc_unlocked.fgetwc.06;getwc.fgetwc.06;getwchar.fgetwc.06", "fgetwc() shall return WEOF",
                                                                                               fgetwc_spec == SUT_WEOF
                   );
            }
            else
            {
                /*
                 * The fgetwc() function shall obtain the next character (if present) from the
                 * input stream pointed to by stream,
                 */
                bool checkResult = ( fgetwc_spec == getCurrentWChar_StreamState( preStreamState ) );
                REQ( "fgetwc.01.01;fgetwc_unlocked.fgetwc.01.01;getwc.fgetwc.01.01;getwchar.fgetwc.01.01",
                     "fgetwc() shall obtain the next character from the stream",
                     checkResult
                   );

                /*
                 * convert that to the corresponding wide-character code,
                 */
                REQ( "fgetwc.01.02;fgetwc_unlocked.fgetwc.01.02;getwc.fgetwc.01.02;getwchar.fgetwc.01.02",
                     "convert that to the corresponding wide-character",
                     true
                   );

                /*
                 * and advance the associated file position indicator for the stream (if defined).
                 */
                REQ( "fgetwc.01.03;fgetwc_unlocked.fgetwc.01.03;getwc.fgetwc.01.03;getwchar.fgetwc.01.03",
                     "advance the associated file position indicator for the stream",
                     getOffset_StreamState( preStreamState ) < getOffset_StreamState( postStreamState )
                   );

                /*
                 * The fgetwc() function may mark the st_atime field of the file associated with
                 * stream for update.
                 */
                REQ( "fgetwc.03;fgetwc_unlocked.fgetwc.03;getwc.fgetwc.03;getwchar.fgetwc.03",
                     "fgetwc() may mark the st_atime field",
                     true
                   );

                /*
                 * The st_atime field shall be marked for update by the first successful execution
                 * of fgetc(), fgets(), fgetwc(), fgetws(), fread(), fscanf(), getc(), getchar(),
                 * gets(), or scanf() using stream that returns data not supplied by a prior call
                 * to ungetc() or ungetwc().
                 */
                REQ("fgetwc.04;fgetwc_unlocked.fgetwc.04;getwc.fgetwc.04;getwchar.fgetwc.04", "", TODO_REQ());

                /*
                 * Upon successful completion, the fgetwc() function shall return the wide-
                 * character code of the character read from the input stream pointed to by stream
                 * converted to a type wint_t.
                 */
                REQ( "fgetwc.05;fgetwc_unlocked.fgetwc.05;getwc.fgetwc.05;getwchar.fgetwc.05",
                     "fgetwc() shall return the wide-character from the stream",
                     checkResult
                   );
            }
        }

        if ( getwc_type == Macro_Type ) {
            /*
             * The getwc() function shall be equivalent to fgetwc(), except that if it is
             * implemented as a macro it may evaluate stream more than once, so the argument
             * should never be an expression with side effects.
             */
            REQ( "getwc.01", "getwc() shall be equivalent to fgetwc()", true );
        }

        if ( getwc_type == Char_Type ) {
            /*
             * The getwchar() function shall be equivalent to getwc(stdin).
             */
            REQ( "getwchar.01", "getwchar() shall be equivalent to getwc(stdin)", true );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fgetws - get a wide-character string from a stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    wchar_t *fgetws(wchar_t *restrict ws, int n, FILE *restrict stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fgetws() function shall read characters from the stream, convert these
    to the corresponding wide-character codes, place them in the wchar_t array
    pointed to by ws, until n-1 characters are read, or a <newline> is read,
    converted, and transferred to ws, or an end-of-file condition is
    encountered. The wide-character string, ws, shall then be terminated with
    a null wide-character code.

    If an error occurs, the resulting value of the file position indicator for
    the stream is unspecified.

    [CX] The fgetws() function may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fgetwc(),
    fgetws(), fread(), fscanf(), getc(), getchar(), gets(), or scanf() using
    stream that returns data not supplied by a prior call to ungetc() or
    ungetwc().

RETURN VALUE

    Upon successful completion, fgetws() shall return ws. If the stream is at
    end-of-file, the end-of-file indicator for the stream shall be set and
    fgetws() shall return a null pointer. If a read error occurs, the error
    indicator for the stream shall be set, fgetws() shall return a null
    pointer, [CX]   and shall set errno to indicate the error.

ERRORS

    Refer to fgetwc().

*/
specification
WString * fgetws_spec( CallContext context, IntT n, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fgetws_coverage = CoverageForFILETPtr( stream ) * CoverageForInteger_MinMiddleMax( n, 0, 10, SUT_INT_MAX );
    post
    {
        verbose( "fgetws_spec\n" );
        print_StreamState( preStreamState, "preStreamState is " );

        /*
         * If a read error occurs, the error indicator for the stream shall be set,
         * fgetws() shall return a null pointer, [CX] and shall set errno to indicate the error.
         *
         */
        ERROR_BEGIN( POSIX_FGETWS, "fgetws.08", fgetws_spec == NULL && * errno != SUT_EOK, * errno )
            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the fgetwc() operation.
             */
            ERROR_SHALL(POSIX_FGETWS, EAGAIN, "fgetws.09.01", TODO_ERR(EAGAIN))

            /*
            * The fgetwc() function shall fail if data needs to be read and:
            *
            * [EBADF] [CX] The file descriptor underlying stream is not a valid file
            * descriptor open for reading.
            */
            ERROR_SHALL( POSIX_FGETWS, EBADF, "fgetws.09.02", preStreamState == NULL                         ||
                                                              ! isAllowReading_StreamState( preStreamState )
                       )

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EILSEQ] The data obtained from the input stream does not form a valid
             * character.
             */
            ERROR_SHALL(POSIX_FGETWS, EILSEQ, "fgetws.09.03", TODO_ERR(EILSEQ))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EINTR] [CX] The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FGETWS, EINTR, "fgetws.09.04", TODO_ERR(EINTR))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is in a
             * background process group attempting to read from its controlling terminal, and
             * either the process is ignoring or blocking the SIGTTIN signal or the process
             * group is orphaned. This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_SHALL(POSIX_FGETWS, EIO, "fgetws.09.05", TODO_ERR(EIO))

            /*
             * The fgetwc() function shall fail if data needs to be read and:
             *
             * [EOVERFLOW] [CX] The file is a regular file and an attempt was made to read
             * at or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FGETWS, EOVERFLOW, "fgetws.09.06", TODO_ERR(EOVERFLOW))

            /*
             * The fgetwc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FGETWS, ENOMEM, "fgetws.10.01", TODO_ERR(ENOMEM))

            /*
             * The fgetwc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FGETWS, ENXIO, "fgetws.10.02", TODO_ERR(ENXIO))

            if ( fgetws_spec == NULL )
            {
                /*
                 * If an error occurs, the resulting value of the file position indicator for the
                 * stream is unspecified.
                 */
                REQ( "fgetws.03", "the resulting value of the file position indicator is unspecified", true );
            }
        ERROR_END()

        if ( isEof_StreamState( preStreamState ) )
        {
            /*
             * If the stream is at end-of-file, the end-of-file indicator for the stream shall
             * be set and fgetws() shall return a null pointer.
             */
            bool checkResult = ( fgetws_spec == NULL );
            REQ( "fgetws.07", "fgetws() shall return a null pointer", checkResult );

            /*
             * converted, and transferred to ws, or an end-of-file condition is encountered.
             */
            REQ( "fgetws.01.04", "end-of-file condition is encountered", checkResult );
        }
        else
        {
            /*
             * The fgetws() function shall read characters from the stream,
             */
            bool checkResult = equals( getCurrentWString_StreamState( preStreamState, n ), fgetws_spec );
            printW_String( "getCurrentWString is ", getCurrentWString_StreamState( preStreamState, n ) );
            printW_String( "fgetws_spec       is ", fgetws_spec                                        );
            REQ( "fgetws.01.01", "fgetws() shall read characters", checkResult );

            /*
             * convert these to the corresponding wide-character codes,
             */
            REQ( "fgetws.01.02", "convert these to the corresponding wide-character codes", checkResult );

            /*
             * place them in the wchar_t array pointed to by ws, until n-1 characters are read,
             * or a <newline> is read,
             */
            REQ( "fgetws.01.03", "place them in ws", checkResult );

            /*
             * he wide-character string, ws, shall then be terminated with a null wide-
             * character code.
             */
            REQ( "fgetws.02", "ws shall then be terminated with a null wide-character code", true );

            /*
             * Upon successful completion, fgetws() shall return ws.
             */
            REQ( "fgetws.06", "fgetws() shall return ws", checkResult );

            /*
             * The fgetws() function may mark the st_atime field of the file associated with
             * stream for update.
             */
            REQ( "fgetws.04", "fgetws() may mark the st_atime field", true );

            /*
             * The st_atime field shall be marked for update by the first successful execution
             * of fgetc(), fgets(), fgetwc(), fgetws(), fread(), fscanf(), getc(), getchar(),
             * gets(), or scanf() using stream that returns data not supplied by a prior call
             * to ungetc() or ungetwc().
             */
            REQ("fgetws.05", "", TODO_REQ());
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fputwc - put a wide-character code on a stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    wint_t fputwc(wchar_t wc, FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fputwc() function shall write the character corresponding to the
    wide-character code wc to the output stream pointed to by stream, at the
    position indicated by the associated file-position indicator for the stream
    (if defined), and advances the indicator appropriately.If the file cannot
    support positioning requests, or if the stream was opened with append mode,
    the character is appended to the output stream. If an error occurs while
    writing the character, the shift state of the output file is left in an
    undefined state.

    [CX]  The st_ctime and st_mtime fields of the file shall be marked for
    update between the successful execution of fputwc() and the next successful
    completion of a call to fflush() or fclose() on the same stream or a call
    to exit() or abort().

RETURN VALUE

    Upon successful completion, fputwc() shall return wc. Otherwise, it shall
    return WEOF, the error indicator for the stream shall be set, [CX]   and
    errno shall be set to indicate the error.

ERRORS
    The fputwc() function shall fail if either the stream is unbuffered or data in the stream's buffer needs to be written, and:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor underlying
        stream and the thread would be delayed in the write operation.

        [EBADF]
        [CX]  The file descriptor underlying stream is not a valid file
        descriptor open for writing.

        [EFBIG]
        [CX]  An attempt was made to write to a file that exceeds the maximum
        file size or the process' file size limit.

        [EFBIG]
        [CX]  The file is a regular file and an attempt was made to write at or
        beyond the offset maximum associated with the corresponding stream.

        [EILSEQ]
        The wide-character code wc does not correspond to a valid character.

        [EINTR]
        [CX]  The write operation was terminated due to the receipt of a
        signal, and no data was transferred.

        [EIO]
        [CX]  A physical I/O error has occurred, or the process is a member of
        a background process group attempting to write to its controlling
        terminal, TOSTOP is set, the process is neither ignoring nor blocking
        SIGTTOU, and the process group of the process is orphaned. This error
        may also be returned under implementation-defined conditions.

        [ENOSPC]
        [CX]  There was no free space remaining on the device containing the
        file.

        [EPIPE]
        [CX]  An attempt is made to write to a pipe or FIFO that is not open
        for reading by any process. A SIGPIPE signal shall also be sent to the
        thread.

    The fputwc() function may fail if:

        [ENOMEM]
        [CX]  Insufficient storage space is available.

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    putwc - put a wide character on a stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    wint_t putwc(wchar_t wc, FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The putwc() function shall be equivalent to fputwc(), except that if it is
    implemented as a macro it may evaluate stream more than once, so the
    argument should never be an expression with side effects.

RETURN VALUE

    Refer to fputwc().

ERRORS

    Refer to fputwc().
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    putwchar - put a wide character on a stdout stream

SYNOPSIS

    #include <wchar.h>
    wint_t putwchar(wchar_t wc);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The function call putwchar(wc) shall be equivalent to putwc(wc,stdout).

RETURN VALUE

    Refer to fputwc().

ERRORS

    Refer to fputwc().
*/

//This specification refers to: fputwc, putwc, putwchar
specification
WIntT fputwc_spec( CallContext context, WCharT wc, FILETPtr stream, ErrorCode * errno, IntT putwc_type )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fputwc_coverage = CoverageForFILETPtr( stream ) * CoverageForIntTAsWCharT( wc );
    post
    {
        postStreamState = construct_StreamState( context, stream );
        verbose( "fputwc_spec is %d\n", (int)fputwc_spec );

        /*
         * Otherwise, it shall return WEOF, the error indicator for the stream shall be
         * set, [CX] and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FPUTWC,
                     "fputwc.05.02;putwc.fputwc.05.02;putwchar.fputwc.05.02",
                     fputwc_spec == SUT_WEOF && * errno != SUT_EOK,
                     * errno
                   )
            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FPUTWC, EAGAIN, "fputwc.06.01;putwc.fputwc.06.01;putwchar.fputwc.06.01", TODO_ERR(EAGAIN))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL( POSIX_FPUTWC, EBADF, "fputwc.06.02;putwc.fputwc.06.02;putwchar.fputwc.06.02",
                                              preStreamState == NULL || ! isAllowWriting_StreamState( preStreamState )
                       )

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size or the process' file size limit.
             */
            ERROR_SHALL(POSIX_FPUTWC, EFBIG, "fputwc.06.03;putwc.fputwc.06.03;putwchar.fputwc.06.03", TODO_ERR(EFBIG))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FPUTWC, EFBIG, "fputwc.06.04;putwc.fputwc.06.04;putwchar.fputwc.06.04", TODO_ERR(EFBIG))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EILSEQ] The wide-character code wc does not correspond to a valid character.
             */
            ERROR_SHALL(POSIX_FPUTWC, EILSEQ, "fputwc.06.05;putwc.fputwc.06.05;putwchar.fputwc.06.05", TODO_ERR(EILSEQ))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FPUTWC, EINTR, "fputwc.06.06;putwc.fputwc.06.06;putwchar.fputwc.06.06", TODO_ERR(EINTR))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FPUTWC, EIO, "fputwc.06.07;putwc.fputwc.06.07;putwchar.fputwc.06.07", TODO_ERR(EIO))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FPUTWC, ENOSPC, "fputwc.06.08;putwc.fputwc.06.08;putwchar.fputwc.06.08", TODO_ERR(ENOSPC))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FPUTWC, EPIPE, "fputwc.06.09;putwc.fputwc.06.09;putwchar.fputwc.06.09", TODO_ERR(EPIPE))

            /*
             * The fputwc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FPUTWC, ENOMEM, "fputwc.07.01;putwc.fputwc.07.01;putwchar.fputwc.07.01", TODO_ERR(ENOMEM))

            /*
             * The fputwc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FPUTWC, ENXIO, "fputwc.07.02;putwc.fputwc.07.02;putwchar.fputwc.07.02", TODO_ERR(ENXIO))

            if ( fputwc_spec == SUT_WEOF )
            {
                /*
                 * If an error occurs while writing the character, the shift state of the output
                 * file is left in an undefined state.
                 */
                REQ( "fputwc.03;putwc.fputwc.03;putwchar.fputwc.03",
                     "the shift state of the output file is left in an undefined state", true
                   );
            }
        ERROR_END()

        /*
         * The fputwc() function shall write the character corresponding to the wide-
         * character code wc to the output stream pointed to by stream, at the position
         * indicated by the associated file-position indicator for the stream (if defined),
         */
        if ( putwc_type != Char_Type ) {
            setCurrentWChar_StreamState( preStreamState, wc );
        }
        REQ( "fputwc.01.01;putwc.fputwc.01.01;putwchar.fputwc.01.01",
             "fputwc() shall write wc to stream",
             isEqualsTo_StreamState( preStreamState, postStreamState )
           );

        /*
         * and advances the indicator appropriately.
         */
        REQ( "fputwc.01.02;putwc.fputwc.01.02;putwchar.fputwc.01.02",
             "advances the indicator appropriately",
             getOffset_StreamState( preStreamState ) == getOffset_StreamState( postStreamState )
           );

        /*
         * If the file cannot support positioning requests, or if the stream was opened
         * with append mode, the character is appended to the output stream.
         */
        REQ( "fputwc.02;putwc.fputwc.02;putwchar.fputwc.02", "the character is appended to the output stream",
                                                             isEqualsTo_StreamState( preStreamState, postStreamState )
           );

        /*
         * The st_ctime and st_mtime fields of the file shall be marked for update between
         * the successful execution of fputwc() and the next successful completion of a
         * call to fflush() or fclose() on the same stream or a call to exit() or abort().
         */
        REQ("fputwc.04;putwc.fputwc.04;putwchar.fputwc.04", "", TODO_REQ());

        /*
         * Upon successful completion, fputwc() shall return wc.
         */
        REQ( "fputwc.05.01;putwc.fputwc.05.01;putwchar.fputwc.05.01", "fputwc() shall return wc", fputwc_spec == wc );

        if ( putwc_type == Macro_Type ) {
            /*
             * The putwc() function shall be equivalent to fputwc(), except that if it is
             * implemented as a macro it may evaluate stream more than once, so the argument
             * should never be an expression with side effects.
             */
            REQ( "putwc.01", "putwc() shall be equivalent to fputwc()", true );
        }

        if ( putwc_type == Char_Type ) {
            /*
             * The function call putwchar(wc) shall be equivalent to putwc(wc,stdout).
             */
            REQ( "putwchar.01", "putwchar(wc) shall be equivalent to putwc(wc,stdout)", true );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fputws - put a wide-character string on a stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    int fputws(const wchar_t *restrict ws, FILE *restrict stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fputws() function shall write a character string corresponding to the
    (null-terminated) wide-character string pointed to by ws to the stream
    pointed to by stream. No character corresponding to the terminating null
    wide-character code shall be written.

    [CX]  The st_ctime and st_mtime fields of the file shall be marked for
    update between the successful execution of fputws() and the next successful
    completion of a call to fflush() or fclose() on the same stream or a call
    to exit() or abort().

RETURN VALUE

    Upon successful completion, fputws() shall return a non-negative number.
    Otherwise, it shall return -1, set an error indicator for the stream, [CX]
    and set errno to indicate the error.

ERRORS

    Refer to fputwc().
*/
specification
IntT fputws_spec( CallContext context, WString * ws, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fputws_coverage = CoverageForFILETPtr( stream ) * CoverageForNotNullWString( ws );
    post
    {
        bool checkResult;
        postStreamState = construct_StreamState( context, stream );
        verbose( "fputws_spec\n" );
        // verbose( "fputws_spec is %d\n", (int)fputws_spec );
        print_StreamState( preStreamState , "preStreamState is "  );
        print_StreamState( postStreamState, "postStreamState is " );

        /*
         * Otherwise, it shall return -1, set an error indicator for the stream, [CX]
         * and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FPUTWS, "fputws.04.02", fputws_spec == -1, * errno )
            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FPUTWS, EAGAIN, "fputws.06.01", TODO_ERR(EAGAIN))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL( POSIX_FPUTWS, EBADF, "fputws.06.02", preStreamState == NULL                         ||
                                                              ! isAllowWriting_StreamState( preStreamState )
                       )

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size or the process' file size limit.
             */
            ERROR_SHALL(POSIX_FPUTWS, EFBIG, "fputws.06.03", TODO_ERR(EFBIG))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FPUTWS, EFBIG, "fputws.06.04", TODO_ERR(EFBIG))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EILSEQ] The wide-character code wc does not correspond to a valid character.
             */
            ERROR_SHALL(POSIX_FPUTWS, EILSEQ, "fputws.06.05", TODO_ERR(EILSEQ))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FPUTWS, EINTR, "fputws.06.06", TODO_ERR(EINTR))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FPUTWS, EIO, "fputws.06.07", TODO_ERR(EIO))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FPUTWS, ENOSPC, "fputws.06.08", TODO_ERR(ENOSPC))

            /*
             * The fputwc() function shall fail if either the stream is unbuffered or data in
             * the stream's buffer needs to be written, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FPUTWS, EPIPE, "fputws.06.09", TODO_ERR(EPIPE))

            /*
             * The fputwc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FPUTWS, ENOMEM, "fputws.07.01", TODO_ERR(ENOMEM))

            /*
             * The fputwc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FPUTWS, ENXIO, "fputws.07.02", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * The fputws() function shall write a character string corresponding to the (null-
         * terminated) wide-character string pointed to by ws to the stream pointed to by
         * stream.
         */
        printW_String( "ws is ", ws );
        setCurrentWString_StreamState( preStreamState, ws );
        print_StreamState( preStreamState , "modified preStreamState is "  );
        checkResult = isEqualsTo_StreamState( preStreamState, postStreamState );
        REQ( "fputws.01", "fputws() shall write wide-character string pointed to by ws", checkResult );

        /*
         * No character corresponding to the terminating null wide-character code shall be
         * written.
         */
        REQ( "fputws.02", "No terminating null wide-character code shall be written", checkResult );

        /*
         * The st_ctime and st_mtime fields of the file shall be marked for update between
         * the successful execution of fputws() and the next successful completion of a
         * call to fflush() or fclose() on the same stream or a call to exit() or abort().
         */
        REQ("fputws.03", "", TODO_REQ());

        /*
         * Upon successful completion, fputws() shall return a non-negative number.
         */
        REQ( "fputws.04.01", "fputws() shall return a non-negative number", fputws_spec >= 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fwide - set stream orientation

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    int fwide(FILE *stream, int mode);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fwide() function shall determine the orientation of the stream pointed
    to by stream. If mode is greater than zero, the function first attempts to
    make the stream wide-oriented. If mode is less than zero, the function
    first attempts to make the stream byte-oriented. Otherwise, mode is zero
    and the function does not alter the orientation of the stream.

    If the orientation of the stream has already been determined, fwide() shall
    not change it.

    [CX] Since no return value is reserved to indicate an error, an application
    wishing to check for error situations should set errno to 0, then call
    fwide(), then check errno, and if it is non-zero, assume an error has
    occurred.

RETURN VALUE

    The fwide() function shall return a value greater than zero if, after the
    call, the stream has wide-orientation,a value less than zero if the stream
    has byte-orientation,or zero if the stream has no orientation.

ERRORS

    The fwide() function may fail if:

    [EBADF]
    [CX]  The stream argument is not a valid stream.
*/
specification
IntT fwide_spec( CallContext context, FILETPtr stream, IntT mode, ErrorCode * errno )
{
    StreamState * preStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fwide_coverage =
             CoverageForFILETPtr( stream ) * CoverageForInteger_Middle( mode, SUT_INT_MIN, 0, SUT_INT_MAX );
    post
    {
        /*
         * Since no return value is reserved to indicate an error, an application wishing
         * to check for error situations should set errno to 0, then call fwide(), then
         * check errno, and if it is non-zero, assume an error has occurred.
         */
        ERROR_BEGIN( POSIX_FWIDE, "fwide.04", * errno != SUT_EOK, * errno )
            /*
             * The fwide() function may fail if:
             *
             * [EBADF] [CX] The stream argument is not a valid stream.
             */
            ERROR_MAY( POSIX_FWIDE, EBADF, "fwide.06.01", preStreamState == NULL )
        ERROR_END()

        /*
         * The fwide() function shall determine the orientation of the stream pointed to
         * by stream.
         */
        REQ("fwide.01", "", TODO_REQ());

        /*
         * If mode is greater than zero, the function first attempts to make the stream
         * wide-oriented.
         */
        REQ("fwide.02.01", "", TODO_REQ());

        /*
         * If mode is less than zero, the function first attempts to make the stream byte-
         * oriented.
         */
        REQ("fwide.02.02", "", TODO_REQ());

        /*
         * Otherwise, mode is zero and the function does not alter the orientation of the
         * stream.
         */
        REQ("fwide.02.03", "", TODO_REQ());

        /*
         * If the orientation of the stream has already been determined, fwide() shall not
         * change it.
         */
        REQ("fwide.03", "", TODO_REQ());

        /*
         * The fwide() function shall return a value greater than zero if, after the call,
         * the stream has wide-orientation,
         */
        REQ("fwide.05.01", "", TODO_REQ());

        /*
         * a value less than zero if the stream has byte-orientation,
         */
        REQ("fwide.05.02", "", TODO_REQ());

        /*
         * or zero if the stream has no orientation.
         */
        REQ("fwide.05.03", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    ungetwc - push wide-character code back into the input stream

SYNOPSIS

    #include <stdio.h>
    #include <wchar.h>

    wint_t ungetwc(wint_t wc, FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The ungetwc() function shall push the character corresponding to the
    wide-character code specified by wc back onto the input stream pointed to
    by stream. The pushed-back characters shall be returned by subsequent
    reads on that stream in the reverse order of their pushing. A successful
    intervening call (with the stream pointed to by stream) to a
    file-positioning function ( fseek(), fsetpos(), or rewind()) discards any
    pushed-back characters for the stream. The external storage corresponding
    to the stream is unchanged.

    At least one character of push-back shall be provided. If ungetwc() is
    called too many times on the same stream without an intervening read or
    file-positioning operation on that stream, the operation may fail.

    If the value of wc equals that of the macro WEOF, the operation shall fail
    and the input stream shall be left unchanged.

    A successful call to ungetwc() shall clear the end-of-file indicator for
    the stream. The value of the file-position indicator for the stream after
    reading or discarding all pushed-back characters shall be the same as it
    was before the characters were pushed back. The file-position indicator is
    decremented (by one or more) by each successful call to ungetwc(); if its
    value was 0 before a call, its value is unspecified after the call.

RETURN VALUE

    Upon successful completion, ungetwc() shall return the wide-character code
    corresponding to the pushed-back character. Otherwise, it shall return WEOF.

ERRORS

    The ungetwc() function may fail if:

    [EILSEQ]
    [CX]  An invalid character sequence is detected, or a wide-character code
    does not correspond to a valid character.

*/
specification
WIntT ungetwc_spec( CallContext context, WIntT wc, FILETPtr stream, ErrorCode * errno, bool toStdin )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage ungetwc_coverage = CoverageForFILETPtr( stream ) * CoverageForIntTAsWCharT( wc );
    post
    {
        postStreamState = construct_StreamState( context, stream );

        /*
         * Otherwise, it shall return WEOF.
         */
        ERROR_BEGIN( POSIX_UNGETWC, "ungetwc.09.02", ungetwc_spec == SUT_WEOF, * errno )
            /*
             * The ungetwc() function may fail if:
             *
             * [EILSEQ] [CX] An invalid character sequence is detected, or a wide-character
             * code does not correspond to a valid character.
             */
            ERROR_MAY(POSIX_UNGETWC, EILSEQ, "ungetwc.10.01", TODO_ERR(EILSEQ))

            if ( wc == SUT_WEOF )
            {
                /*
                 * If the value of wc equals that of the macro WEOF, the operation shall fail and
                 * the input stream shall be left unchanged.
                 */
                REQ( "ungetwc.06", "the operation shall fail and the input stream shall be left unchanged",
                                   ungetwc_spec == SUT_WEOF && isEqualsTo_StreamState( preStreamState, postStreamState )
                   );
            }
        ERROR_END()

        /*
         * The ungetwc() function shall push the character corresponding to the wide-
         * character code specified by wc back onto the input stream pointed to by stream.
         */
        REQ("ungetwc.01", "", TODO_REQ());

        /*
         * The pushed-back characters shall be returned by subsequent reads on that stream
         * in the reverse order of their pushing.
         */
        REQ("ungetwc.02", "", TODO_REQ());

        /*
         * A successful intervening call (with the stream pointed to by stream) to a file-
         * positioning function ( fseek(), fsetpos(), or rewind()) discards any pushed-
         * back characters for the stream.
         */
        REQ("ungetwc.03", "", TODO_REQ());

        /*
         * The external storage corresponding to the stream is unchanged.
         */
        REQ("ungetwc.04", "", TODO_REQ());

        /*
         * At least one character of push-back shall be provided. If ungetwc() is called
         * too many times on the same stream without an intervening read or file-
         * positioning operation on that stream, the operation may fail.
         */
        REQ("ungetwc.05", "", TODO_REQ());

        /*
         * A successful call to ungetwc() shall clear the end-of-file indicator for the
         * stream.
         */
        REQ("ungetwc.07", "", TODO_REQ());

        /*
         * The value of the file-position indicator for the stream after reading or
         * discarding all pushed-back characters shall be the same as it was before the
         * characters were pushed back.
         *
         * The file-position indicator is decremented (by one or more) by each successful
         * call to ungetwc();
         */
        REQ("ungetwc.08.01", "", TODO_REQ());

        /*
         * The value of the file-position indicator for the stream after reading or
         * discarding all pushed-back characters shall be the same as it was before the
         * characters were pushed back.
         *
         * if its value was 0 before a call, its value is unspecified after the call.
         */
        REQ("ungetwc.08.02", "", TODO_REQ());

        /*
         * Upon successful completion, ungetwc() shall return the wide-character code
         * corresponding to the pushed-back character.
         */
        REQ( "ungetwc.09.01", "ungetwc() shall return the pushed-back character", ungetwc_spec == wc );

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

void onFputwc( CallContext context, FILETPtr stream, WCharT wc ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, sizeof( WCharT ) );
    assertion( writeWChar_VoidTPtr( buf, wc ), "onFputwc : writeWChar_VoidTPtr" );
    onWrite( context, fileId, buf, sizeof( WCharT ), sizeof( WCharT ) );
    deallocateMemoryBlock( context, buf );
}

void onFputws( CallContext context, FILETPtr stream, WString * ws ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, ( length_WString( ws ) + 1 ) * sizeof( WCharT ) );
    assertion( writeWString_VoidTPtr( buf, ws ), "onFputws : writeWString_VoidTPtr" );
    onWrite( context, fileId, buf, length_WString( ws ) * sizeof( WCharT ), length_WString( ws ) * sizeof( WCharT ) );
    deallocateMemoryBlock( context, buf );
}

void onFgetwc( CallContext context, FILETPtr stream, WCharT wc ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, sizeof( WCharT ) );
    assertion( writeWChar_VoidTPtr( buf, wc ), "onFgetwc : writeWChar_VoidTPtr" );
    onRead( context, fileId, buf, sizeof( WCharT ), sizeof( WCharT ) );
    deallocateMemoryBlock( context, buf );
}

void onFgetws( CallContext context, FILETPtr stream, WString * ws ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, ( length_WString( ws ) + 1 ) * sizeof( WCharT ) );
    assertion( writeWString_VoidTPtr( buf, ws ), "onFgetws : writeWString_VoidTPtr" );
    onRead( context, fileId, buf, length_WString( ws ) * sizeof( WCharT ), length_WString( ws ) * sizeof( WCharT ) );
    deallocateMemoryBlock( context, buf );
}
