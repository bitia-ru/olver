/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from the Single UNIX Specification Version 2, Copyright (C) 1997 by The Open
 * Group. In the event of any discrepancy between this version and the original
 * document from the Open Group, the Open Group document is the referee document.
 * The original document can be obtained online at http://www.unix.org/version2/online.html.
 */

#include "common/common_media.seh"
#include "common/coverages.seh"
#include "config/interpretation.seh"
#include "io/fstream/fstream_config.h"
#include "io/fstream/fstream_model.seh"
#include "locale/ctype/ctype_model.seh"
#include "math/math/math_data.seh"
#include "process/process/process_common.seh"

#pragma SEC subsystem fstream "io.fstream"

/*
   The group of functions 'io.fstream.fstream' consists of:
       _IO_feof [1]
       _IO_getc [1]
       _IO_putc [1]
       _IO_puts [1]
       __fpending [2]
       clearerr [2]
       fclose [2]
       fdopen [2]
       feof [2]
       ferror [2]
       fflush [2]
       fflush_unlocked [1]
       fgetc [2]
       fgetpos [2]
       fgetpos64 [2]
       fgets [2]
       fileno [2]
       fopen [1]
       fopen64 [2]
       fputc [2]
       fputs [2]
       fread [2]
       freopen [1]
       freopen64 [2]
       fseek [2]
       fseeko [2]
       fseeko64 [2]
       fsetpos [2]
       fsetpos64 [2]
       ftell [2]
       ftello [2]
       ftello64 [2]
       fwrite [2]
       getc [2]
       getc_unlocked [2]
       getchar [2]
       getchar_unlocked [2]
       getw [3]
       putc [2]
       putc_unlocked [2]
       putchar [2]
       putchar_unlocked [2]
       puts [2]
       putw [3]
       rewind [2]
       ungetc [2]
 */

specification typedef FILETPtr FILETPtrObj = {};

FILETPtrObj * create_FILETPtrObj( FILETPtr ptr ) {
    return create( & type_FILETPtrObj, ptr.system, ptr.process, ptr.address );
}

specification typedef struct FILET FILET = {};

FILET * create_FILET( FILETPtr address, FileDescId fileId ) { return create( & type_FILET, address, fileId ); }

FILET * getFILET( FILETPtr address ) { return getObjectInMemory( address ); }

coverage CoverageForIntTAsUCharT( IntT i ) {
    if      ( i <  -128 ) { return { Between_MInf_M128, "( -inf, -128 )" }; }
    else if ( i == -128 ) { return { Exactly_M128     , "-128"           }; }
    else if ( i <     0 ) { return { Between_M128_0   , "( -128,    0 )" }; }
    else if ( i ==    0 ) { return { Exactly_0        , "   0"           }; }
    else if ( i <   127 ) { return { Between_0_127    , "(    0,  127 )" }; }
    else if ( i ==  127 ) { return { Exactly_127      , " 127"           }; }
                     else { return { Between_127_Inf  , "(  127, +inf )" }; }
}

coverage CoverageForIntTAsWhence( IntT i ) {
    if      ( i == SEEK_SET ) { return { SeekSet, "SEEK_SET" }; }
    else if ( i == SEEK_CUR ) { return { SeekCur, "SEEK_CUR" }; }
    else if ( i == SEEK_END ) { return { SeekEnd, "SEEK_END" }; }
                         else { return { Unknown, "unknown"  }; }
}

coverage CoverageForIntTAsOffsetType( IntT i ) {
    if      ( i == LongType ) { return { CallTo_fseek   , "call to fseek"    }; }
    else if ( i == OffType  ) { return { CallTo_fseeko  , "call to fseeko"   }; }
                         else { return { CallTo_fseeko64, "call to fseeko64" }; }
}

coverage CoverageForCStringAsMode( CString * m ) {
    if      ( equalsToCreatedFrom2C_String( m, "r" , "rb"         ) ) { return { rMode      , "r(b) mode"    }; }
    else if ( equalsToCreatedFrom2C_String( m, "w" , "wb"         ) ) { return { wMode      , "w(b) mode"    }; }
    else if ( equalsToCreatedFrom2C_String( m, "a" , "ab"         ) ) { return { aMode      , "a(b) mode"    }; }
    else if ( equalsToCreatedFrom3C_String( m, "r+", "rb+", "r+b" ) ) { return { rpMode     , "r(b)+ mode"   }; }
    else if ( equalsToCreatedFrom3C_String( m, "w+", "wb+", "w+b" ) ) { return { wpMode     , "w(b)+ mode"   }; }
    else if ( equalsToCreatedFrom3C_String( m, "a+", "ab+", "a+b" ) ) { return { apMode     , "a(b)+ mode"   }; }
                                                                 else { return { UnknownMode, "unknown mode" }; }
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    _IO_feof -- alias for feof

SYNOPSIS

    int _IO_feof(_IO_FILE * __fp);

DESCRIPTION

    _IO_feof() tests the end-of-file indicator for the stream pointed to by
    __fp, returning a non-zero value if it is set.

    _IO_feof() is not in the source standard; it is only in the binary
    standard.
*/

specification
IntT _IO_feof_spec( CallContext context, FILETPtr __fp )
{
    pre
    {
        return true;
    }
    coverage _IO_feof_coverage = CoverageForFILETPtr( __fp );
    post
    {
        StreamState * streamState = construct_StreamState( context, __fp );

        /*
         * _IO_feof() tests the end-of-file indicator for the stream pointed to by __fp,
         * returning a non-zero value if it is set.
         */
        REQ( "_IO_feof.01", "_IO_feof() return a non-zero value if the end-of-file for the stream indicator is set",
             ( _IO_feof_spec == 0 ) || isEof_StreamState( streamState )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    NAME

        _IO_getc -- alias for getc

    SYNOPSIS

        int _IO_getc(_IO_FILE * __fp);

    DESCRIPTION

        _IO_getc() reads the next character from __fp and returns it as an
        unsigned char cast to an int, or EOF on end-of-file or error.

        _IO_getc() is not in the source standard; it is only in the binary
        standard.
*/
specification
IntT _IO_getc_spec( CallContext context, FILETPtr __fp )
{
    StreamState * preStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, __fp );

        return true;
    }
    coverage _IO_getc_coverage = CoverageForFILETPtr( __fp );
    post
    {
        verbose( "_IO_getc_spec is %d\n", (int)_IO_getc_spec );
        print_StreamState( preStreamState, "preStreamState is " );
        if ( isEof_StreamState( preStreamState ) )
        {
            /*
             * or EOF on end-of-file or error.
             */
            REQ( "_IO_getc.01.02", "EOF on end-of-file or error", _IO_getc_spec == SUT_EOF );
        }
        else
        {
            /*
             * _IO_getc() reads the next character from __fp and returns it as an unsigned
             * char cast to an int,
             */
            REQ( "_IO_getc.01.01", "next character from __fp as int",
                                   _IO_getc_spec == getCurrentChar_StreamState( preStreamState )
               );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    NAME

        _IO_putc -- alias for putc

    SYNOPSIS

        int _IO_putc(int __c, _IO_FILE * __fp);

    DESCRIPTION

        _IO_putc() writes the character __c, cast to an unsigned char, to __fp.

        _IO_putc() is not in the source standard; it is only in the binary
        standard.
*/
specification
IntT _IO_putc_spec( CallContext context, IntT __c, FILETPtr __fp )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, __fp );

        return true;
    }
    coverage _IO_putc_coverage = CoverageForFILETPtr( __fp ) * CoverageForIntTAsUCharT( __c );
    post
    {
        postStreamState = construct_StreamState( context, __fp );
        verbose( "_IO_putc_spec is %d\n", (int)_IO_putc_spec );
        print_StreamState( preStreamState, "preStreamState is " );

        /*
         * _IO_putc() writes the character __c, cast to an unsigned char, to __fp.
         */
        setCurrentChar_StreamState( preStreamState, __c );
        print_StreamState( preStreamState, "edited preStreamState is " );
        print_StreamState( postStreamState, "postStreamState is " );
        REQ( "_IO_putc.01", "_IO_putc() writes __c to __fp", isEqualsTo_StreamState( preStreamState, postStreamState ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    _IO_puts -- alias for puts

SYNOPSIS

    int _IO_puts(const char * __c);

DESCRIPTION

    _IO_puts() writes the string __s and a trailing newline to stdout.

    _IO_puts() is not in the source standard; it is only in the binary
    standard.
*/
specification
IntT _IO_puts_spec( CallContext context, CString * __c )
{
    pre
    {
        return true;
    }
    coverage _IO_puts_coverage = CoverageForCString( __c );
    post
    {
        /*
        * _IO_puts() writes the string __s and a trailing newline to stdout.
        */
        REQ("_IO_puts.01", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __fpending -- returns in bytes the amount of output pending on a stream

SYNOPSIS

    size_t __fpending(FILE * stream);

DESCRIPTION

    __fpending() returns the amount of output in bytes pending on a stream.

    __fpending() is not in the source standard; it is only in the binary
    standard.

*/
specification
SizeT __fpending_spec( CallContext context, FILETPtr stream )
{
    pre
    {
        return true;
    }
    coverage __fpending_coverage = CoverageForFILETPtr( stream );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );
        /*
         * __fpending() returns the amount of output in bytes pending on a stream.
         */
        REQ( "__fpending.01", "__fpending() returns the amount of output in bytes pending on a stream",
                              0 <= __fpending_spec && __fpending_spec <= size_StreamState( streamState )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    clearerr - clear indicators on a stream

SYNOPSIS

    #include <stdio.h>
    void clearerr(FILE *stream);

DESCRIPTION
    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE
    Std 1003.1-2001 defers to the ISO C standard.

    The clearerr() function shall clear the end-of-file and error indicators
    for the stream to which stream points.

RETURN VALUE

    The clearerr() function shall not return a value.

ERRORS

    No errors are defined.
*/
specification
void clearerr_spec( CallContext context, FILETPtr stream )
{
    pre
    {
        return true;
    }
    coverage clearerr_coverage = CoverageForFILETPtr( stream );
    post
    {
        /*
        * The clearerr() function shall clear the end-of-file and error indicators for
        * the stream to which stream points.
        */
        REQ( "clearerr.01", "clear the end-of-file and error indicators", true );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fclose - close a stream

SYNOPSIS

    #include <stdio.h>
    int fclose(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fclose() function shall cause the stream pointed to by stream to be
    flushed and the associated file to be closed. Any unwritten buffered data
    for the stream shall be written to the file; any unread buffered data shall
    be discarded.Whether or not the call succeeds, the stream shall be
    disassociated from the file and any buffer set by the setbuf() or
    setvbuf() function shall be disassociated from the stream. If the
    associated buffer was automatically allocated, it shall be deallocated.

    [CX]  The fclose() function shall mark for update the st_ctime and st_mtime
    fields of the underlying file, if the stream was writable, and if buffered
    data remains that has not yet been written to the file. The fclose()
    function shall perform the equivalent of a close() on the file descriptor
    that is associated with the stream pointed to by stream.

    After the call to fclose(), any use of stream results in undefined
    behavior.

RETURN VALUE

    Upon successful completion, fclose() shall return 0; otherwise, it shall
    return EOF [CX]   and set errno to indicate the error.

ERRORS

    The fclose() function shall fail if:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor underlying
        stream and the thread would be delayed in the write operation.

        [EBADF]
        [CX]  The file descriptor underlying stream is not valid.

        [EFBIG]
        [CX]  An attempt was made to write a file that exceeds the maximum
        file size.

        [EFBIG]
        [XSI]  An attempt was made to write a file that exceeds the process'
        file size limit.

        [EFBIG]
        [CX]  The file is a regular file and an attempt was made to write at
        or beyond the offset maximum associated with the corresponding stream.

        [EINTR]
        [CX]  The fclose() function was interrupted by a signal.

        [EIO]
        [CX]  The process is a member of a background process group attempting
        to write to its controlling terminal, TOSTOP is set, the process is
        neither ignoring nor blocking SIGTTOU, and the process group of the
        process is orphaned. This error may also be returned under
        implementation-defined conditions.

        [ENOSPC]
        [CX]  There was no free space remaining on the device containing the
        file.

        [EPIPE]
        [CX]  An attempt is made to write to a pipe or FIFO that is not open
        for reading by any process. A SIGPIPE signal shall also be sent to
        the thread.

    The fclose() function may fail if:

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.

*/
specification
IntT fclose_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;
    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fclose_coverage = CoverageForFILETPtr( stream );
    post
    {
        postStreamState = construct_StreamState( context, stream );

        /*
         * otherwise, it shall return EOF [CX] and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FCLOSE, "fclose.08.02", fclose_spec == SUT_EOF && * errno != SUT_EOK, * errno )
            /*
             * The fclose() function shall fail if:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FCLOSE, EAGAIN, "fclose.09.01", TODO_ERR(EAGAIN))

            /*
             * The fclose() function shall fail if:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not valid.
             */
            ERROR_SHALL( POSIX_FCLOSE, EBADF, "fclose.09.02", preStreamState == NULL )

            /*
             * The fclose() function shall fail if:
             *
             * [EFBIG] [CX] An attempt was made to write a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FCLOSE, EFBIG, "fclose.09.03", TODO_ERR(EFBIG))

            /*
             * The fclose() function shall fail if:
             *
             * [EFBIG] [XSI] An attempt was made to write a file that exceeds the process'
             * file size limit.
             */
            ERROR_SHALL(POSIX_FCLOSE, EFBIG, "fclose.09.04", TODO_ERR(EFBIG))

            /*
             * The fclose() function shall fail if:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FCLOSE, EFBIG, "fclose.09.05", TODO_ERR(EFBIG))

            /*
             * The fclose() function shall fail if:
             *
             * [EINTR] [CX] The fclose() function was interrupted by a signal.
             */
            ERROR_SHALL(POSIX_FCLOSE, EINTR, "fclose.09.06", TODO_ERR(EINTR))

            /*
             * The fclose() function shall fail if:
             *
             * [EIO] [CX] The process is a member of a background process group attempting
             * to write to its controlling terminal, TOSTOP is set, the process is neither
             * ignoring nor blocking SIGTTOU, and the process group of the process is orphaned.
             * This error may also be returned under implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FCLOSE, EIO, "fclose.09.07", TODO_ERR(EIO))

            /*
             * The fclose() function shall fail if:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FCLOSE, ENOSPC, "fclose.09.08", TODO_ERR(ENOSPC))

            /*
             * The fclose() function shall fail if:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FCLOSE, EPIPE, "fclose.09.09", TODO_ERR(EPIPE))

            /*
             * The fclose() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FCLOSE, ENXIO, "fclose.10.01", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * The fclose() function shall cause the stream pointed to by stream to be flushed
         * and the associated file to be closed.
         */
        REQ( "fclose.01", "fclose() cause the stream to be flushed and the associated file to be closed",
                          postStreamState == NULL
           );

        if ( isAllowWriting_StreamState( preStreamState ) )
        {
            /*
             * Any unwritten buffered data for the stream shall be written to the file;
             */
            REQ( "fclose.02.01", "unwritten buffered data for the stream shall be written to the file", true );
        }

        if ( isAllowReading_StreamState( preStreamState ) )
        {
            /*
             * any unread buffered data shall be discarded.
             */
            REQ( "fclose.02.02", "unread buffered data shall be discarded", true );
        }

        /*
         * Whether or not the call succeeds, the stream shall be disassociated from the
         * file and any buffer set by the setbuf() or setvbuf() function shall be
         * disassociated from the stream.
         */
        REQ("fclose.03", "", TODO_REQ());

        /*
         * If the associated buffer was automatically allocated, it shall be deallocated.
         */
        REQ("fclose.04", "", TODO_REQ());

        /*
         * The fclose() function shall mark for update the st_ctime and st_mtime fields of
         * the underlying file, if the stream was writable, and if buffered data remains
         * that has not yet been written to the file.
         */
        REQ("fclose.05", "", TODO_REQ());

        /*
         * The fclose() function shall perform the equivalent of a close() on the file
         * descriptor that is associated with the stream pointed to by stream
         */
        REQ( "fclose.06", "fclose() shall perform the equivalent of a close() on the file descriptor",
                          postStreamState == NULL
           );

        /*
         * After the call to fclose(), any use of stream results in undefined behavior.
         */
        REQ( "fclose.07", "After the call to fclose(), any use of stream results in undefined behavior", true );

        /*
        * Upon successful completion, fclose() shall return 0;
        */
        REQ( "fclose.08.01", "Upon successful completion, fclose() shall return 0", fclose_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    fdopen - associate a stream with a file descriptor

SYNOPSIS

    [CX]  #include <stdio.h>

    FILE *fdopen(int fildes, const char *mode);

DESCRIPTION

    The fdopen() function shall associate a stream with a file descriptor.

    The mode argument is a character string having one of the following values:

        r or rb
        Open a file for reading.
        w or wb
        Open a file for writing.
        a or ab
        Open a file for writing at end-of-file.
        r+ or rb+ or r+b
        Open a file for update (reading and writing).
        w+ or wb+ or w+b
        Open a file for update (reading and writing).
        a+ or ab+ or a+b
        Open a file for update (reading and writing) at end-of-file.

    The meaning of these flags is exactly as specified in fopen(), except that
    modes beginning with w shall not cause truncation of the file.

    Additional values for the mode argument may be supported by an
    implementation.

    The application shall ensure that the mode of the stream as expressed by
    the mode argument is allowed by the file access mode of the open file
    description to which fildes refers. The file position indicator associated
    with the new stream is set to the position indicated by the file offset
    associated with the file descriptor.

    The error and end-of-file indicators for the stream shall be cleared. The
    fdopen() function may cause the st_atime field of the underlying file to
    be marked for update.

    If fildes refers to a shared memory object, the result of the fdopen()
    function is unspecified.

    If fildes refers to a typed memory object, the result of the fdopen()
    function is unspecified.

    The fdopen() function shall preserve the offset maximum previously set for
    the open file description corresponding to fildes.

RETURN VALUE

    Upon successful completion, fdopen() shall return a pointer to a stream;
    otherwise, a null pointer shall be returned and errno set to indicate the
    error.

ERRORS

    The fdopen() function may fail if:

        [EBADF]
        The fildes argument is not a valid file descriptor.

        [EINVAL]
        The mode argument is not a valid mode.

        [EMFILE]
        {FOPEN_MAX} streams are currently open in the calling process.

        [EMFILE]
        {STREAM_MAX} streams are currently open in the calling process.

        [ENOMEM]
        Insufficient space to allocate a buffer.
*/
specification
FILETPtr fdopen_spec( CallContext context, FileDescId fildes, CString * mode, ErrorCode * errno )
{
    pre
    {
        /*
         * If fildes refers to a shared memory object, the result of the fdopen() function
         * is unspecified.
         */
        REQ("app.fdopen.09", "", TODO_REQ());

        /*
         * If fildes refers to a typed memory object, the result of the fdopen() function
         * is unspecified.
         */
        REQ("app.fdopen.10", "", TODO_REQ());

        return true;
    }
    coverage fdopen_coverage = CoverageForCStringAsMode( mode );
    post
    {
        StreamState * streamState = construct_StreamState( context, fdopen_spec );

        /*
         * otherwise, a null pointer shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FDOPEN, "fdopen.12.02", isNULL_VoidTPtr( fdopen_spec ) && * errno != SUT_EOK, * errno )
            /*
             * The fdopen() function may fail if:
             *
             * [EBADF] The fildes argument is not a valid file descriptor.
             */
            ERROR_MAY( POSIX_FDOPEN, EBADF, "fdopen.13.01", getFile_FileDescId( fildes ) == NULL )

            /*
             * The fdopen() function may fail if:
             *
             * [EINVAL] The mode argument is not a valid mode.
             */
            ERROR_MAY(POSIX_FDOPEN, EINVAL, "fdopen.13.02", fdopen_coverage == CoverageForCStringAsMode.UnknownMode )

            /*
             * The fdopen() function may fail if:
             *
             * [EMFILE] {FOPEN_MAX} streams are currently open in the calling process.
             */
            ERROR_MAY(POSIX_FDOPEN, EMFILE, "fdopen.13.03", TODO_ERR(EMFILE))

            /*
             * The fdopen() function may fail if:
             *
             * [EMFILE] {STREAM_MAX} streams are currently open in the calling process.
             */
            ERROR_MAY(POSIX_FDOPEN, EMFILE, "fdopen.13.04", TODO_ERR(EMFILE))

            /*
             * The fdopen() function may fail if:
             *
             * [ENOMEM] Insufficient space to allocate a buffer.
             */
            ERROR_MAY(POSIX_FDOPEN, ENOMEM, "fdopen.13.05", TODO_ERR(ENOMEM))
        ERROR_END()

        /*
         * The fdopen() function shall associate a stream with a file descriptor.
         */
        REQ( "fdopen.01", "fdopen() shall associate a stream with a file descriptor", streamState != NULL );

        if ( fdopen_coverage == CoverageForCStringAsMode.rMode )
        {
            /*
             * The mode argument is a character string having one of the following values:
             *
             * r or rb Open a file for reading.
             */
            REQ( "fdopen.02.01", "Open a file for reading", isAllowReading_StreamState( streamState ) );
        }
        else if ( fdopen_coverage == CoverageForCStringAsMode.wMode )
        {
            /*
             * The mode argument is a character string having one of the following values:
             *
             * w or wb Open a file for writing.
             */
            REQ( "fdopen.02.02", "Open a file for writing", isAllowWriting_StreamState( streamState ) );
        }
        else if ( fdopen_coverage == CoverageForCStringAsMode.aMode )
        {
            /*
             * The mode argument is a character string having one of the following values:
             *
             * a or ab Open a file for writing at end-of-file.
             */
            REQ( "fdopen.02.03", "Open a file for writing at end-of-file",
                                 isAllowWriting_StreamState( streamState ) && isEof_StreamState( streamState )
               );
        }
        else if ( fdopen_coverage == CoverageForCStringAsMode.rpMode )
        {
            /*
             * The mode argument is a character string having one of the following values:
             *
             * r+ or rb+ or r+b Open a file for update (reading and writing).
             */
            REQ( "fdopen.02.04", "Open a file for update (reading and writing)",
                                 isAllowReading_StreamState( streamState ) && isAllowWriting_StreamState( streamState )
               );
        }
        else if ( fdopen_coverage == CoverageForCStringAsMode.wpMode )
        {
            /*
             * The mode argument is a character string having one of the following values:
             *
             * w+ or wb+ or w+b Open a file for update (reading and writing).
             */
            REQ( "fdopen.02.05", "Open a file for update (reading and writing)",
                                 isAllowReading_StreamState( streamState ) && isAllowWriting_StreamState( streamState )
               );
        }
        else if ( fdopen_coverage == CoverageForCStringAsMode.apMode )
        {
            /*
             * The mode argument is a character string having one of the following values:
             *
             * a+ or ab+ or a+b Open a file for update (reading and writing) at end-of-file.
             */
            REQ( "fdopen.02.06", "Open a file for update (reading and writing) at end-of-file",
                                 isAllowReading_StreamState( streamState ) && isAllowWriting_StreamState( streamState ) &&
                                 isEof_StreamState( streamState )
               );
        }
        else
        {
            /*
             * Additional values for the mode argument may be supported by an implementation.
             */
            REQ( "fdopen.04", "Additional values for the mode argument may be supported", true );
        }

        /*
         * The meaning of these flags is exactly as specified in fopen(), except that
         * modes beginning with w shall not cause truncation of the file.
         */
        REQ("fdopen.03", "", TODO_REQ());

        /*
         * The application shall ensure that the mode of the stream as expressed by the
         * mode argument is allowed by the file access mode of the open file description
         * to which fildes refers.
         */
        REQ("fdopen.05", "", TODO_REQ());

        /*
         * The file position indicator associated with the new stream is set to the
         * position indicated by the file offset associated with the file descriptor.
         */
        REQ( "fdopen.06", "file position is set to position ndicated by the file offset", true );

        /*
         * The error and end-of-file indicators for the stream shall be cleared.
         */
        REQ("fdopen.07", "", TODO_REQ());

        /*
         * The fdopen() function may cause the st_atime field of the underlying file to be
         * marked for update.
         */
        REQ( "fdopen.08", "fdopen() may cause the st_atime field to be marked for update", true );

        /*
         * The fdopen() function shall preserve the offset maximum previously set for the
         * open file description corresponding to fildes.
         */
        REQ("fdopen.11", "", TODO_REQ());

        /*
         * Upon successful completion, fdopen() shall return a pointer to a stream;
         */
        REQ( "fdopen.12.01", "fdopen() shall return a pointer to a stream", streamState != NULL );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    feof - test end-of-file indicator on a stream

SYNOPSIS

    #include <stdio.h>
    int feof(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE
    Std 1003.1-2001 defers to the ISO C standard.

    The feof() function shall test the end-of-file indicator for the stream
    pointed to by stream.

RETURN VALUE

    The feof() function shall return non-zero if and only if the end-of-file
    indicator is set for stream.

ERRORS

    No errors are defined.
*/

specification
IntT feof_spec( CallContext context, FILETPtr stream )
{
    pre
    {
        return true;
    }
    coverage feof_coverage = CoverageForFILETPtr( stream );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );

        /*
         * The feof() function shall test the end-of-file indicator for the stream pointed
         * to by stream.
         */
        REQ( "feof.01", "feof() function shall test the end-of-file indicator for the stream", true );

        /*
         * The feof() function shall return non-zero if and only if the end-of-file
         * indicator is set for stream.
         */
        REQ( "feof.02", "feof() function shall return non-zero if and only if the end-of-file indicator is set for stream",
             ( feof_spec == 0 ) || isEof_StreamState( streamState )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    ferror - test error indicator on a stream

SYNOPSIS

    #include <stdio.h>
    int ferror(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE
    Std 1003.1-2001 defers to the ISO C standard.

    The ferror() function shall test the error indicator for the stream pointed
    to by stream.

RETURN VALUE

    The ferror() function shall return non-zero if and only if the error
    indicator is set for stream.

ERRORS

    No errors are defined.
*/
specification
IntT ferror_spec( CallContext context, FILETPtr stream )
{
    pre
    {
        return true;
    }
    coverage ferror_coverage = CoverageForFILETPtr( stream );
    post
    {
        /*
         * The ferror() function shall test the error indicator for the stream pointed to
         * by stream.
         */
        REQ("ferror.01", "", TODO_REQ());

        /*
         * The ferror() function shall return non-zero if and only if the error indicator
         * is set for stream.
         */
        REQ("ferror.02", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fflush - flush a stream

SYNOPSIS

    #include <stdio.h>
    int fflush(FILE *stream);


DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    If stream points to an output stream or an update stream in which the most
    recent operation was not input, fflush() shall cause any unwritten data for
    that stream to be written to the file, [CX]   and the st_ctime and st_mtime
    fields of the underlying file shall be marked for update.

    If stream is a null pointer, fflush() shall perform this flushing action on
    all streams for which the behavior is defined above.

RETURN VALUE

    Upon successful completion, fflush() shall return 0; otherwise, it shall
    set the error indicator for the stream, return EOF, [CX]   and set errno
    to indicate the error.

ERRORS

    The fflush() function shall fail if:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor underlying
        stream and the thread would be delayed in the write operation.

        [EBADF]
        [CX]  The file descriptor underlying stream is not valid.

        [EFBIG]
        [CX]  An attempt was made to write a file that exceeds the maximum file
        size.

        [EFBIG]
        [XSI]  An attempt was made to write a file that exceeds the process'
        file size limit.

        [EFBIG]
        [CX]  The file is a regular file and an attempt was made to write at or
        beyond the offset maximum associated with the corresponding stream.

        [EINTR]
        [CX]  The fflush() function was interrupted by a signal.

        [EIO]
        [CX]  The process is a member of a background process group attempting
        to write to its controlling terminal, TOSTOP is set, the process is
        neither ignoring nor blocking SIGTTOU, and the process group of the
        process is orphaned. This error may also be returned under
        implementation-defined conditions.

        [ENOSPC]
        [CX]  There was no free space remaining on the device containing the
        file.

        [EPIPE]
        [CX]  An attempt is made to write to a pipe or FIFO that is not open
        for reading by any process. A SIGPIPE signal shall also be sent to the
        thread.

    The fflush() function may fail if:

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    fflush_unlocked -- non thread safe fflush

DESCRIPTION

    fflush_unlocked() is the same as fflush() except that it need not be
    thread safe. That is, it may only be invoked in the ways which are legal
    for getc_unlocked().
*/

//This specification refers to: fflush, fflush_unlocked
specification
IntT fflush_spec( CallContext context, FILETPtr stream, ErrorCode * errno, bool unlocked )
{
    pre
    {
        return true;
    }
    coverage fflush_coverage = CoverageForFILETPtr( stream );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );

        /*
         * otherwise, it shall set the error indicator for the stream, return EOF, [CX]
         * and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FFLUSH, "fflush.04.02;fflush_unlocked.fflush.04.02",
                     fflush_spec == SUT_EOF && * errno != SUT_EOK, * errno
                   )
            /*
             * The fflush() function shall fail if:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FFLUSH, EAGAIN, "fflush.05.01;fflush_unlocked.fflush.05.01", TODO_ERR(EAGAIN))

            /*
             * The fflush() function shall fail if:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not valid.
             */
            ERROR_SHALL( POSIX_FFLUSH, EBADF, "fflush.05.02;fflush_unlocked.fflush.05.02", streamState == NULL )

            /*
             * The fflush() function shall fail if:
             *
             * [EFBIG] [CX] An attempt was made to write a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FFLUSH, EFBIG, "fflush.05.03;fflush_unlocked.fflush.05.03", TODO_ERR(EFBIG))

            /*
             * The fflush() function shall fail if:
             *
             * [EFBIG] [XSI] An attempt was made to write a file that exceeds the process'
             * file size limit.
             */
            ERROR_SHALL(POSIX_FFLUSH, EFBIG, "fflush.05.04;fflush_unlocked.fflush.05.04", TODO_ERR(EFBIG))

            /*
             * The fflush() function shall fail if:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FFLUSH, EFBIG, "fflush.05.05;fflush_unlocked.fflush.05.05", TODO_ERR(EFBIG))

            /*
             * The fflush() function shall fail if:
             *
             * [EINTR] [CX] The fflush() function was interrupted by a signal.
             */
            ERROR_SHALL(POSIX_FFLUSH, EINTR, "fflush.05.06;fflush_unlocked.fflush.05.06", TODO_ERR(EINTR))

            /*
             * The fflush() function shall fail if:
             *
             * [EIO] [CX] The process is a member of a background process group attempting
             * to write to its controlling terminal, TOSTOP is set, the process is neither
             * ignoring nor blocking SIGTTOU, and the process group of the process is orphaned.
             * This error may also be returned under implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FFLUSH, EIO, "fflush.05.07;fflush_unlocked.fflush.05.07", TODO_ERR(EIO))

            /*
             * The fflush() function shall fail if:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FFLUSH, ENOSPC, "fflush.05.08;fflush_unlocked.fflush.05.08", TODO_ERR(ENOSPC))

            /*
             * The fflush() function shall fail if:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FFLUSH, EPIPE, "fflush.05.09;fflush_unlocked.fflush.05.09", TODO_ERR(EPIPE))

            /*
             * The fflush() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FFLUSH, ENXIO, "fflush.06.01;fflush_unlocked.fflush.06.01", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * If stream points to an output stream or an update stream in which the most
         * recent operation was not input, fflush() shall cause any unwritten data for
         * that stream to be written to the file,
         */
        REQ("fflush.01;fflush_unlocked.fflush.01", "", TODO_REQ());

        /*
         * and the st_ctime and st_mtime fields of the underlying file shall be marked for
         * update.
         */
        REQ("fflush.02;fflush_unlocked.fflush.02", "", TODO_REQ());

        /*
         * If stream is a null pointer, fflush() shall perform this flushing action on all
         * streams for which the behavior is defined above.
         */
        REQ("fflush.03;fflush_unlocked.fflush.03", "", TODO_REQ());

        /*
         * Upon successful completion, fflush() shall return 0;
         */
        REQ( "fflush.04.01;fflush_unlocked.fflush.04.01", "fflush() shall return 0", fflush_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    fgetc - get a byte from a stream

SYNOPSIS

    #include <stdio.h>
    int fgetc(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std 1003.1-2001
    defers to the ISO C standard.

    If the end-of-file indicator for the input stream pointed to by stream is
    not set and a next byte is present, the fgetc() function shall obtain the
    next byte as an unsigned char converted to an int, from the input stream
    pointed to by stream, and advance the associated file position indicator
    for the stream (if defined). Since fgetc() operates on bytes, reading a
    character consisting of multiple bytes (or "a multi-byte character") may
    require multiple calls to fgetc().

    [CX]  The fgetc() function may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fgetwc(),
    fgetws(), fread(), fscanf(), getc(), getchar(), gets(), or scanf() using
    stream that returns data not supplied by a prior call to ungetc() or
    ungetwc().

RETURN VALUE

    Upon successful completion, fgetc() shall return the next byte from the
    input stream pointed to by stream. If the end-of-file indicator for the
    stream is set, or if the stream is at end-of-file, the end-of-file
    indicator for the stream shall be set and fgetc() shall return EOF. If a
    read error occurs, the error indicator for the stream shall be set,
    fgetc() shall return EOF, [CX]   and shall set errno to indicate the error.

ERRORS

    The fgetc() function shall fail if data needs to be read and:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor underlying
        stream and the thread would be delayed in the fgetc() operation.

        [EBADF]
        [CX]  The file descriptor underlying stream is not a valid file
        descriptor open for reading.

        [EINTR]
        [CX]  The read operation was terminated due to the receipt of a signal,
        and no data was transferred.

        [EIO]
        [CX]  A physical I/O error has occurred, or the process is in a
        background process group attempting to read from its controlling
        terminal, and either the process is ignoring or blocking the SIGTTIN
        signal or the process group is orphaned. This error may also be
        generated for implementation-defined reasons.

        [EOVERFLOW]
        [CX]  The file is a regular file and an attempt was made to read at or
        beyond the offset maximum associated with the corresponding stream.

    The fgetc() function may fail if:

        [ENOMEM]
        [CX]  Insufficient storage space is available.

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getc - get a byte from a stream

SYNOPSIS

    #include <stdio.h>
    int getc(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The getc() function shall be equivalent to fgetc() , except that if it is
    implemented as a macro it may evaluate stream more than once, so the
    argument should never be an expression with side effects.

RETURN VALUE

    Refer to fgetc().

ERRORS

    Refer to fgetc().
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getchar - get a byte from a stdin stream

SYNOPSIS

    #include <stdio.h>
    int getchar(void);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The getchar() function shall be equivalent to getc(stdin).

RETURN VALUE

    Refer to fgetc().

ERRORS

    Refer to fgetc().
*/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - stdio
    with explicit client locking

SYNOPSIS

    [TSF]  #include <stdio.h>

    int getc_unlocked(FILE *stream);
    int getchar_unlocked(void);
    int putc_unlocked(int c, FILE *stream);
    int putchar_unlocked(int c);

DESCRIPTION

    Versions of the functions getc(), getchar(), putc(), and putchar()
    respectively named getc_unlocked(), getchar_unlocked(), putc_unlocked(),
    and putchar_unlocked() shall be provided which are functionally equivalent
    to the original versions, with the exception that they are not required to
    be implemented in a thread-safe manner. They may only safely be used within
    a scope protected by flockfile() (or ftrylockfile()) and funlockfile().
    These functions may safely be used in a multi-threaded program if and only
    if they are called while the invoking thread owns the ( FILE *) object, as
    is the case after a successful call to the flockfile() or ftrylockfile()
    functions.

RETURN VALUE

    See getc() , getchar() , putc() , and putchar().

ERRORS

    See getc() , getchar() , putc() , and putchar().
*/

//This specification refers to: fgetc, getc, getchar, getchar_unlocked, getc_unlocked
specification
IntT fgetc_spec( CallContext context, FILETPtr stream, ErrorCode * errno,
                 IntT getc_type, CString * input, CString * stdinAsFile
               )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fgetc_coverage = CoverageForFILETPtr( stream );
    post
    {
        postStreamState = construct_StreamState( context, stream );
        verbose( "fgetc_spec is %d\n", (int)fgetc_spec );
        print_StreamState( preStreamState , "preStreamState is "  );
        print_StreamState( postStreamState, "postStreamState is " );

        /*
         * If a read error occurs, the error indicator for the stream shall be set, fgetc()
         * shall return EOF, [CX] and shall set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FGETC,
                     "fgetc.07;getc.fgetc.07;getchar.fgetc.07;getchar_unlocked.fgetc.07;getc_unlocked.fgetc.07",
                     fgetc_spec == SUT_EOF && * errno != SUT_EOK,
                     * errno
                   )
            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the fgetc() operation.
             */
            ERROR_SHALL(POSIX_FGETC, EAGAIN, "fgetc.08.01;getc.fgetc.08.01;getchar.fgetc.08.01;getchar_unlocked.fgetc.08.01;getc_unlocked.fgetc.08.01", TODO_ERR(EAGAIN))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for reading.
             */
            ERROR_SHALL( POSIX_FGETC, EBADF,
                         "fgetc.08.02;getc.fgetc.08.02;getchar.fgetc.08.02;getchar_unlocked.fgetc.08.02;getc_unlocked.fgetc.08.02",
                         preStreamState == NULL || ! isAllowReading_StreamState( preStreamState )
                       )

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EINTR] [CX] The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FGETC, EINTR, "fgetc.08.03;getc.fgetc.08.03;getchar.fgetc.08.03;getchar_unlocked.fgetc.08.03;getc_unlocked.fgetc.08.03", TODO_ERR(EINTR))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is in a
             * background process group attempting to read from its controlling terminal, and
             * either the process is ignoring or blocking the SIGTTIN signal or the process
             * group is orphaned. This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_SHALL(POSIX_FGETC, EIO, "fgetc.08.04;getc.fgetc.08.04;getchar.fgetc.08.04;getchar_unlocked.fgetc.08.04;getc_unlocked.fgetc.08.04", TODO_ERR(EIO))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EOVERFLOW] [CX] The file is a regular file and an attempt was made to read
             * at or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FGETC, EOVERFLOW, "fgetc.08.05;getc.fgetc.08.05;getchar.fgetc.08.05;getchar_unlocked.fgetc.08.05;getc_unlocked.fgetc.08.05", TODO_ERR(EOVERFLOW))

            /*
             * The fgetc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FGETC, ENOMEM, "fgetc.09.01;getc.fgetc.09.01;getchar.fgetc.09.01;getchar_unlocked.fgetc.09.01;getc_unlocked.fgetc.09.01", TODO_ERR(ENOMEM))

            /*
             * The fgetc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FGETC, ENXIO, "fgetc.09.02;getc.fgetc.09.02;getchar.fgetc.09.02;getchar_unlocked.fgetc.09.02;getc_unlocked.fgetc.09.02", TODO_ERR(ENXIO))
        ERROR_END()

        if ( getc_type != Char_Type && getc_type != Char_Unlocked_Type ) {
            if ( isEof_StreamState( preStreamState ) )
            {
                /*
                 * If the end-of-file indicator for the stream is set, or if the stream is at end-
                 * of-file, the end-of-file indicator for the stream shall be set and fgetc()
                 * shall return EOF.
                 */
                REQ( "fgetc.06;getc.fgetc.06;getchar.fgetc.06;getchar_unlocked.fgetc.06;getc_unlocked.fgetc.06",
                     "fgetc() shall return EOF", fgetc_spec == SUT_EOF
                   );
            }
            else
            {
                /*
                 * If the end-of-file indicator for the input stream pointed to by stream is not
                 * set and a next byte is present, the fgetc() function shall obtain the next byte
                 * as an unsigned char converted to an int, from the input stream pointed to by
                 * stream
                 */
                bool checkResult = ( fgetc_spec == getCurrentChar_StreamState( preStreamState ) );
                REQ( "fgetc.01.01;getc.fgetc.01.01;getchar.fgetc.01.01;getchar_unlocked.fgetc.01.01;getc_unlocked.fgetc.01.01",
                     "the fgetc() function shall obtain the next byte as an unsigned char converted to an int",
                     checkResult
                   );

                /*
                 * and advance the associated file position indicator for the stream (if defined).
                 */
                REQ( "fgetc.01.02;getc.fgetc.01.02;getchar.fgetc.01.02;getchar_unlocked.fgetc.01.02;getc_unlocked.fgetc.01.02",
                     "advance the associated file position indicator for the stream",
                     getOffset_StreamState( preStreamState ) < getOffset_StreamState( postStreamState )
                   );

                /*
                 * Since fgetc() operates on bytes, reading a character consisting of multiple
                 * bytes (or "a multi-byte character") may require multiple calls to fgetc().
                 */
                REQ( "fgetc.02;getc.fgetc.02;getchar.fgetc.02;getchar_unlocked.fgetc.02;getc_unlocked.fgetc.02",
                     "reading a character consisting of multiple bytes may require multiple calls to fgetc()",
                     true
                   );

                /*
                 * The fgetc() function may mark the st_atime field of the file associated with
                 * stream for update.
                 */
                REQ( "fgetc.03;getc.fgetc.03;getchar.fgetc.03;getchar_unlocked.fgetc.03;getc_unlocked.fgetc.03",
                     "function may mark the st_atime field of the file",
                     true
                   );

                /*
                 * The st_atime field shall be marked for update by the first successful execution
                 * of fgetc(), fgets(), fgetwc(), fgetws(), fread(), fscanf(), getc(), getchar(),
                 * gets(), or scanf() using stream that returns data not supplied by a prior call
                 * to ungetc() or ungetwc().
                 */
                REQ("fgetc.04;getc.fgetc.04;getchar.fgetc.04;getchar_unlocked.fgetc.04;getc_unlocked.fgetc.04", "", TODO_REQ());

                /*
                 * Upon successful completion, fgetc() shall return the next byte from the input
                 * stream pointed to by stream.
                 */
                REQ( "fgetc.05;getc.fgetc.05;getchar.fgetc.05;getchar_unlocked.fgetc.05;getc_unlocked.fgetc.05",
                     "fgetc() shall return the next byte from the input stream pointed to by stream",
                     checkResult
                   );
            }
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fgetpos - get current file position information

SYNOPSIS

    #include <stdio.h>
    int fgetpos(FILE *restrict stream, fpos_t *restrict pos);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fgetpos() function shall store the current values of the parse state
    (if any) and file position indicator for the stream pointed to by stream
    in the object pointed to by pos. The value stored contains unspecified
    information usable by fsetpos() for repositioning the stream to its
    position at the time of the call to fgetpos().

RETURN VALUE

    Upon successful completion, fgetpos() shall return 0; otherwise, it shall
    return a non-zero value and set errno to indicate the error.

ERRORS

    The fgetpos() function shall fail if:

        [EOVERFLOW]
        [CX]  The current value of the file position cannot be represented
        correctly in an object of type fpos_t.

    The fgetpos() function may fail if:

        [EBADF]
        [CX]  The file descriptor underlying stream is not valid.

        [ESPIPE]
        [CX]  The file descriptor underlying stream is associated with a pipe,
        FIFO, or socket.
*/

//This specification refers to: fgetpos, fgetpos64
specification
IntT fgetpos_spec( CallContext context, FILETPtr stream, FPosTPtr pos, ErrorCode * errno, bool is64bits )
{
    pre
    {
        return true;
    }
    coverage fgetpos_coverage = CoverageForFILETPtr( stream );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );

        /*
         * otherwise, it shall return a non-zero value and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FGETPOS, "fgetpos.03.02;fgetpos64.03.02", fgetpos_spec != 0 && * errno != SUT_EOK, * errno )
            /*
             * The fgetpos() function shall fail if:
             *
             * [EOVERFLOW] [CX] The current value of the file position cannot be
             * represented correctly in an object of type fpos_t.
             */
            ERROR_SHALL(POSIX_FGETPOS, EOVERFLOW, "fgetpos.04.01;fgetpos64.04.01", TODO_ERR(EOVERFLOW))

            /*
             * The fgetpos() function may fail if:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not valid.
             */
            ERROR_MAY( POSIX_FGETPOS, EBADF, "fgetpos.05.01;fgetpos64.05.01", streamState == NULL )

            /*
             * The fgetpos() function may fail if:
             *
             * [ESPIPE] [CX] The file descriptor underlying stream is associated with a
             * pipe, FIFO, or socket.
             */
            ERROR_MAY(POSIX_FGETPOS, ESPIPE, "fgetpos.05.02;fgetpos64.05.02", TODO_ERR(ESPIPE))
        ERROR_END()

        /*
         * The fgetpos() function shall store the current values of the parse state (if
         * any) and file position indicator for the stream pointed to by stream in the
         * object pointed to by pos.
         */
        REQ("fgetpos.01;fgetpos64.01", "", TODO_REQ());

        /*
         * The value stored contains unspecified information usable by fsetpos() for
         * repositioning the stream to its position at the time of the call to fgetpos().
         */
        REQ("fgetpos.02;fgetpos64.02", "", TODO_REQ());

        /*
         * Upon successful completion, fgetpos() shall return 0;
         */
        REQ( "fgetpos.03.01;fgetpos64.03.01", "fgetpos() shall return 0", fgetpos_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fgets - get a string from a stream

SYNOPSIS

    #include <stdio.h>
    char *fgets(char *restrict s, int n, FILE *restrict stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fgets() function shall read bytes from stream into the array pointed
    to by s, until n-1 bytes are read, or a <newline> is read and transferred
    to s, or an end-of-file condition is encountered. The string is then
    terminated with a null byte.

    [CX]  The fgets() function may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked for
    update by the first successful execution of fgetc(), fgets(), fgetwc(),
    fgetws(), fread(), fscanf(), getc(), getchar(), gets(), or scanf() using
    stream that returns data not supplied by a prior call to ungetc() or
    ungetwc().

RETURN VALUE

    Upon successful completion, fgets() shall return s. If the stream is at
    end-of-file, the end-of-file indicator for the stream shall be set and
    fgets() shall return a null pointer. If a read error occurs, the error
    indicator for the stream shall be set, fgets() shall return a null pointer,
    [CX]   and shall set errno to indicate the error.

ERRORS

    Refer to fgetc().
*/
specification
CString * fgets_spec( CallContext context, IntT n, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fgets_coverage = CoverageForFILETPtr( stream ) * CoverageForInteger_MinMiddleMax( n, 0, 10, SUT_INT_MAX );
    post
    {
        verbose( "fgets_spec\n" );
        print_StreamState( preStreamState, "preStreamState is " );
        /*
         * If a read error occurs, the error indicator for the stream shall be set, fgets()
         * shall return a null pointer, [CX] and shall set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FGETS, "fgets.07", fgets_spec == NULL && * errno != SUT_EOK, * errno )
            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the fgetc() operation.
             */
            ERROR_SHALL(POSIX_FGETS, EAGAIN, "fgets.08.01", TODO_ERR(EAGAIN))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for reading.
             */
            ERROR_SHALL( POSIX_FGETS, EBADF, "fgets.08.02", preStreamState == NULL                         ||
                                                            ! isAllowReading_StreamState( preStreamState )
                       )

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EINTR] [CX] The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FGETS, EINTR, "fgets.08.03", TODO_ERR(EINTR))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is in a
             * background process group attempting to read from its controlling terminal, and
             * either the process is ignoring or blocking the SIGTTIN signal or the process
             * group is orphaned. This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_SHALL(POSIX_FGETS, EIO, "fgets.08.04", TODO_ERR(EIO))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EOVERFLOW] [CX] The file is a regular file and an attempt was made to read
             * at or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FGETS, EOVERFLOW, "fgets.08.05", TODO_ERR(EOVERFLOW))

            /*
             * The fgetc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FGETS, ENOMEM, "fgets.09.01", TODO_ERR(ENOMEM))

            /*
             * The fgetc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FGETS, ENXIO, "fgets.09.02", TODO_ERR(ENXIO))
        ERROR_END()

        if ( isEof_StreamState( preStreamState ) )
        {
            /*
             * If the stream is at end-of-file, the end-of-file indicator for the stream shall
             * be set and fgets() shall return a null pointer.
             */
            REQ( "fgets.06", "fgets() shall return a null pointer", fgets_spec == NULL );
        }
        else
        {
            /*
             * The fgets() function shall read bytes from stream into the array pointed to by
             * s, until n-1 bytes are read, or a <newline> is read and transferred to s, or
             * an end-of-file condition is encountered.
             */
            printC_String( "getCurrentString is ", getCurrentString_StreamState( preStreamState, n ) );
            printC_String( "fgets_spec       is ", fgets_spec                                        );
            REQ( "fgets.01", "fgets() shall read bytes into s",
                             equals( getCurrentString_StreamState( preStreamState, n ), fgets_spec )
               );

            /*
             * The string is then terminated with a null byte.
             */
            REQ( "fgets.02", "The string is then terminated with a null byte", true );

            /*
             * The fgets() function may mark the st_atime field of the file associated with
             * stream for update.
             */
            REQ( "fgets.03", "fgets() may mark the st_atime field of the file for update", true );

            /*
             * The st_atime field shall be marked for update by the first successful execution
             * of fgetc(), fgets(), fgetwc(), fgetws(), fread(), fscanf(), getc(), getchar(),
             * gets(), or scanf() using stream that returns data not supplied by a prior call
             * to ungetc() or ungetwc().
             */
            REQ("fgets.04", "", TODO_REQ());

            /*
             * Upon successful completion, fgets() shall return s.
             */
            REQ( "fgets.05", "Upon successful completion, fgets() shall return s", true );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fileno - map a stream pointer to a file descriptor

SYNOPSIS

    [CX]  #include <stdio.h>
    int fileno(FILE *stream);

DESCRIPTION

    The fileno() function shall return the integer file descriptor associated
    with the stream pointed to by stream.

RETURN VALUE

    Upon successful completion, fileno() shall return the integer value of the
    file descriptor associated with stream. Otherwise, the value -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The fileno() function may fail if:
        [EBADF]
        The stream argument is not a valid stream.
*/
specification
IntT fileno_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    pre
    {
        return true;
    }
    coverage fileno_coverage = CoverageForFILETPtr( stream );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );
        FileDescId fileId;
        bool checkResult;

        /*
         * Otherwise, the value -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FILENO, "fileno.02.02", fileno_spec == -1 && * errno != SUT_EOK, * errno )
            /*
             * The fileno() function may fail if:
             *
             * [EBADF] The stream argument is not a valid stream.
             */
            ERROR_MAY( POSIX_FILENO, EBADF, "fileno.03.01", streamState == NULL )
        ERROR_END()

        /*
         * The fileno() function shall return the integer file descriptor associated with
         * the stream pointed to by stream.
         */
        fileId = a_fileno( context, stream );
        checkResult = ( fileno_spec == fileId.filedesc );
        REQ( "fileno.01", "fileno() shall return the integer file descriptor", checkResult );

        /*
         * Upon successful completion, fileno() shall return the integer value of the file
         * descriptor associated with stream.
         */
        REQ( "fileno.02.01", "fileno() shall return the integer value of the file descriptor", checkResult );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fopen - open a stream

SYNOPSIS

    #include <stdio.h>
    FILE *fopen(const char *restrict filename, const char *restrict mode);


DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fopen() function shall open the file whose pathname is the string
    pointed to by filename, and associates a stream with it.

    The mode argument points to a string. If the string is one of the
    following, the file shall be opened in the indicated mode. Otherwise, the
    behavior is undefined.

        r or rb
        Open file for reading.
        w or wb
        Truncate to zero length or create file for writing.
        a or ab
        Append; open or create file for writing at end-of-file.
        r+ or rb+ or r+b
        Open file for update (reading and writing).
        w+ or wb+ or w+b
        Truncate to zero length or create file for update.
        a+ or ab+ or a+b
        Append; open or create file for update, writing at end-of-file.

    [CX]  The character 'b' shall have no effect, but is allowed for ISO C
    standard conformance.  Opening a file with read mode (r as the first
    character in the mode argument) shall fail if the file does not exist
    or cannot be read.

    Opening a file with append mode (a as the first character in the mode
    argument) shall cause all subsequent writes to the file to be forced to
    the then current end-of-file, regardless of intervening calls to fseek().

    When a file is opened with update mode ( '+' as the second or third
    character in the mode argument), both input and output may be performed on
    the associated stream. However, the application shall ensure that output
    is not directly followed by input without an intervening call to fflush()
    or to a file positioning function ( fseek(), fsetpos(), or rewind()), and
    input is not directly followed by output without an intervening call to a
    file positioning function, unless the input operation encounters
    end-of-file.

    When opened, a stream is fully buffered if and only if it can be determined
    not to refer to an interactive device. The error and end-of-file indicators
    for the stream shall be cleared.

    [CX] If mode is w, wb, a, ab, w+, wb+, w+b, a+, ab+, or a+b, and the file
    did not previously exist, upon successful completion, the fopen() function
    shall mark for update the st_atime, st_ctime, and st_mtime fields of the
    file and the st_ctime and st_mtime fields of the parent directory.

    If mode is w, wb, w+, wb+, or w+b, and the file did previously exist, upon
    successful completion, fopen() shall mark for update the st_ctime and
    st_mtime fields of the file. The fopen() function shall allocate a file
    descriptor as open() does.

    After a successful call to the fopen() function, the orientation of the
    stream shall be cleared, [XSI]   the encoding rule shall be cleared,  and
    the associated mbstate_t object shall be set to describe an initial
    conversion state.

    [CX]  The largest value that can be represented correctly in an object of
    type off_t shall be established as the offset maximum in the open file
    description.

RETURN VALUE

    Upon successful completion, fopen() shall return a pointer to the object
    controlling the stream. Otherwise, a null pointer shall be returned, [CX]
    and errno shall be set to indicate the error.

ERRORS

    The fopen() function shall fail if:

        [EACCES]
        [CX]  Search permission is denied on a component of the path prefix,
        or the file exists and the permissions specified by mode are denied,
        or the file does not exist and write permission is denied for the
        parent directory of the file to be created.

        [EINTR]
        [CX]  A signal was caught during fopen().

        [EISDIR]
        [CX]  The named file is a directory and mode requires write access.

        [ELOOP]
        [CX]  A loop exists in symbolic links encountered during resolution of
        the path argument.

        [EMFILE]
        [CX]  {OPEN_MAX} file descriptors are currently open in the calling
        process.

        [ENAMETOOLONG]
        [CX]
        The length of the filename argument exceeds {PATH_MAX} or a pathname
        component is longer than {NAME_MAX}.

        [ENFILE]
        [CX]  The maximum allowable number of files is currently open in the
        system.

        [ENOENT]
        [CX]  A component of filename does not name an existing file or
        filename is an empty string.

        [ENOSPC]
        [CX]  The directory or file system that would contain the new file
        cannot be expanded, the file does not exist, and the file was to be
        created.

        [ENOTDIR]
        [CX]  A component of the path prefix is not a directory.

        [ENXIO]
        [CX]  The named file is a character special or block special file, and
        the device associated with this special file does not exist.

        [EOVERFLOW]
        [CX]  The named file is a regular file and the size of the file cannot
        be represented correctly in an object of type off_t.

        [EROFS]
        [CX]  The named file resides on a read-only file system and mode
        requires write access.

    The fopen() function may fail if:

        [EINVAL]
        [CX]  The value of the mode argument is not valid.

        [ELOOP]
        [CX]  More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path argument.

        [EMFILE]
        [CX]  {FOPEN_MAX} streams are currently open in the calling process.

        [EMFILE]
        [CX]  {STREAM_MAX} streams are currently open in the calling process.

        [ENAMETOOLONG]
        [CX]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.

        [ENOMEM]
        [CX]  Insufficient storage space is available.

        [ETXTBSY]
        [CX]  The file is a pure procedure (shared text) file that is being
        executed and mode requires write access.
*/

//This specification refers to: fopen, fopen64
specification
FILETPtr fopen_spec( CallContext context, CString * filename, CString * mode, ErrorCode * errno, bool is64bits )
{
    pre
    {
        /*
        * Otherwise, the behavior is undefined.
        */
        REQ("app.fopen.03", "", TODO_REQ());

        return true;
    }
    coverage fopen_coverage = CoverageForNotNullCString( filename ) * CoverageForCStringAsMode( mode );
    post
    {
        StreamState * streamState = construct_StreamState( context, fopen_spec );
        verbose( "fopen_spec is %sNULL\n", isNULL_VoidTPtr( fopen_spec ) ? "" : "not " );
        if ( streamState != NULL ) { print_StreamState( streamState, "streamState is " ); }

        /*
         * Otherwise, a null pointer shall be returned, [CX] and errno shall be set to
         * indicate the error.
         */
        ERROR_BEGIN
            ( POSIX_FOPEN, "fopen.14.02;fopen64.14.02", isNULL_VoidTPtr( fopen_spec ) && * errno != SUT_EOK, * errno )
            /*
             * The fopen() function shall fail if:
             *
             * [EACCES] [CX] Search permission is denied on a component of the path prefix,
             * or the file exists and the permissions specified by mode are denied, or the
             * file does not exist and write permission is denied for the parent directory of
             * the file to be created.
             */
            ERROR_SHALL(POSIX_FOPEN, EACCES, "fopen.15.01;fopen64.15.01", TODO_ERR(EACCES))

            /*
             * The fopen() function shall fail if:
             *
             * [EINTR] [CX] A signal was caught during fopen().
             */
            ERROR_SHALL(POSIX_FOPEN, EINTR, "fopen.15.02;fopen64.15.02", TODO_ERR(EINTR))

            /*
             * The fopen() function shall fail if:
             *
             * [EISDIR] [CX] The named file is a directory and mode requires write access.
             */
            ERROR_SHALL(POSIX_FOPEN, EISDIR, "fopen.15.03;fopen64.15.03", TODO_ERR(EISDIR))

            /*
             * The fopen() function shall fail if:
             *
             * [ELOOP] [CX] A loop exists in symbolic links encountered during resolution
             * of the path argument.
             */
            ERROR_SHALL(POSIX_FOPEN, ELOOP, "fopen.15.04;fopen64.15.04", TODO_ERR(ELOOP))

            /*
             * The fopen() function shall fail if:
             *
             * [EMFILE] [CX] {OPEN_MAX} file descriptors are currently open in the calling
             * process.
             */
            ERROR_SHALL(POSIX_FOPEN, EMFILE, "fopen.15.05;fopen64.15.05", TODO_ERR(EMFILE))

            /*
             * The fopen() function shall fail if:
             *
             * [ENAMETOOLONG] [CX] The length of the filename argument exceeds {PATH_MAX}
             * or a pathname component is longer than {NAME_MAX}.
             */
            ERROR_SHALL(POSIX_FOPEN, ENAMETOOLONG, "fopen.15.06;fopen64.15.06", TODO_ERR(ENAMETOOLONG))

            /*
             * The fopen() function shall fail if:
             *
             * [ENFILE] [CX] The maximum allowable number of files is currently open in the
             * system.
             */
            ERROR_SHALL(POSIX_FOPEN, ENFILE, "fopen.15.07;fopen64.15.07", TODO_ERR(ENFILE))

            /*
             * The fopen() function shall fail if:
             *
             * [ENOENT] [CX] A component of filename does not name an existing file or
             * filename is an empty string.
             */
            ERROR_SHALL( POSIX_FOPEN, ENOENT,
                         "fopen.15.08;fopen64.15.08",
                         ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.rMode  && * errno == SUT_ENOENT ) ||
                         ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.rpMode && * errno == SUT_ENOENT ) ||
                         fopen_coverage[ 0 ] == CoverageForNotNullCString.EmptyString
                       )

            /*
             * The fopen() function shall fail if:
             *
             * [ENOSPC] [CX] The directory or file system that would contain the new file
             * cannot be expanded, the file does not exist, and the file was to be created.
             */
            ERROR_SHALL(POSIX_FOPEN, ENOSPC, "fopen.15.09;fopen64.15.09", TODO_ERR(ENOSPC))

            /*
             * The fopen() function shall fail if:
             *
             * [ENOTDIR] [CX] A component of the path prefix is not a directory.
             */
            ERROR_SHALL(POSIX_FOPEN, ENOTDIR, "fopen.15.10;fopen64.15.10", TODO_ERR(ENOTDIR))

            /*
             * The fopen() function shall fail if:
             *
             * [ENXIO] [CX] The named file is a character special or block special file,
             * and the device associated with this special file does not exist.
             */
            ERROR_SHALL(POSIX_FOPEN, ENXIO, "fopen.15.11;fopen64.15.11", TODO_ERR(ENXIO))

            /*
             * The fopen() function shall fail if:
             *
             * [EOVERFLOW] [CX] The named file is a regular file and the size of the file
             * cannot be represented correctly in an object of type off_t.
             */
            ERROR_SHALL(POSIX_FOPEN, EOVERFLOW, "fopen.15.12;fopen64.15.12", TODO_ERR(EOVERFLOW))

            /*
             * The fopen() function shall fail if:
             *
             * [EROFS] [CX] The named file resides on a read-only file system and mode
             * requires write access.
             */
            ERROR_SHALL(POSIX_FOPEN, EROFS, "fopen.15.13;fopen64.15.13", TODO_ERR(EROFS))

            /*
             * The fopen() function may fail if:
             *
             * [EINVAL] [CX] The value of the mode argument is not valid.
             */
            ERROR_MAY( POSIX_FOPEN, EINVAL, "fopen.16.01;fopen64.16.01",
                                            fopen_coverage[ 1 ] == CoverageForCStringAsMode.UnknownMode
                     )

            /*
             * The fopen() function may fail if:
             *
             * [ELOOP] [CX] More than {SYMLOOP_MAX} symbolic links were encountered during
             * resolution of the path argument.
             */
            ERROR_MAY(POSIX_FOPEN, ELOOP, "fopen.16.02;fopen64.16.02", TODO_ERR(ELOOP))

            /*
             * The fopen() function may fail if:
             *
             * [EMFILE] [CX] {FOPEN_MAX} streams are currently open in the calling process.
             *
             */
            ERROR_MAY(POSIX_FOPEN, EMFILE, "fopen.16.03;fopen64.16.03", TODO_ERR(EMFILE))

            /*
             * The fopen() function may fail if:
             *
             * [EMFILE] [CX] {STREAM_MAX} streams are currently open in the calling process.
             *
             */
            ERROR_MAY(POSIX_FOPEN, EMFILE, "fopen.16.04;fopen64.16.04", TODO_ERR(EMFILE))

            /*
             * The fopen() function may fail if:
             *
             * [ENAMETOOLONG] [CX] Pathname resolution of a symbolic link produced an
             * intermediate result whose length exceeds {PATH_MAX}.
             */
            ERROR_MAY(POSIX_FOPEN, ENAMETOOLONG, "fopen.16.05;fopen64.16.05", TODO_ERR(ENAMETOOLONG))

            /*
             * The fopen() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FOPEN, ENOMEM, "fopen.16.06;fopen64.16.06", TODO_ERR(ENOMEM))

            /*
             * The fopen() function may fail if:
             *
             * [ETXTBSY] [CX] The file is a pure procedure (shared text) file that is being
             * executed and mode requires write access.
             */
            ERROR_MAY(POSIX_FOPEN, ETXTBSY, "fopen.16.07;fopen64.16.07", TODO_ERR(ETXTBSY))
        ERROR_END()

        /*
         * The fopen() function shall open the file whose pathname is the string pointed
         * to by filename, and associates a stream with it.
         */
        REQ( "fopen.01;fopen64.01", "fopen() shall open the file and associates a stream with it", streamState != NULL );

        if ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.rMode )
        {
            /*
             * The mode argument points to a string. If the string is one of the following,
             * the file shall be opened in the indicated mode
             *
             * r or rb Open file for reading.
             */
            REQ( "fopen.02.01;fopen64.02.01", "Open file for reading", isAllowReading_StreamState( streamState ) );
        }
        else if ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.wMode )
        {
            /*
             * The mode argument points to a string. If the string is one of the following,
             * the file shall be opened in the indicated mode
             *
             * w or wb Truncate to zero length or create file for writing.
             */
            REQ( "fopen.02.02;fopen64.02.02",
                 "Truncate to zero length or create file for writing",
                 size_StreamState( streamState ) == 0 && isAllowWriting_StreamState( streamState )
               );
        }
        else if ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.aMode )
        {
            /*
             * The mode argument points to a string. If the string is one of the following,
             * the file shall be opened in the indicated mode
             *
             * a or ab Append; open or create file for writing at end-of-file.
             */
            REQ( "fopen.02.03;fopen64.02.03",
                 "open or create file for writing at end-of-file",
                 isAllowWriting_StreamState( streamState ) && isEof_StreamState( streamState )
               );
        }
        else if ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.rpMode )
        {
            /*
             * The mode argument points to a string. If the string is one of the following,
             * the file shall be opened in the indicated mode
             *
             * r+ or rb+ or r+b Open file for update (reading and writing).
             */
            REQ( "fopen.02.04;fopen64.02.04",
                 "Open file for update (reading and writing)",
                 isAllowReading_StreamState( streamState ) && isAllowWriting_StreamState( streamState )
               );
        }
        else if ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.wpMode )
        {
            /*
             * The mode argument points to a string. If the string is one of the following,
             * the file shall be opened in the indicated mode
             *
             * w+ or wb+ or w+b Truncate to zero length or create file for update.
             */
            REQ( "fopen.02.05;fopen64.02.05", "Truncate to zero length or create file for update",
                                              size_StreamState( streamState ) == 0      &&
                                              isAllowReading_StreamState( streamState ) &&
                                              isAllowWriting_StreamState( streamState )
                );
        }
        else if ( fopen_coverage[ 1 ] == CoverageForCStringAsMode.apMode )
        {
            /*
             * The mode argument points to a string. If the string is one of the following,
             * the file shall be opened in the indicated mode
             *
             * a+ or ab+ or a+b Append; open or create file for update, writing at end-of-
             * file.
             */
            REQ( "fopen.02.06;fopen64.02.06",
                 "open or create file for update, writing at end-of-file",
                 isAllowWriting_StreamState( streamState ) && isEof_StreamState( streamState )
               );
        }

        /*
         * The character 'b' shall have no effect, but is allowed for ISO C standard
         * conformance.
         */
        REQ( "fopen.04;fopen64.04", "character 'b' shall have no effect", true );

        /*
         * Opening a file with read mode (r as the first character in the mode argument)
         * shall fail if the file does not exist or cannot be read.
         */
        REQ("fopen.05;fopen64.05", "", TODO_REQ());

        /*
         * Opening a file with append mode (a as the first character in the mode argument)
         * shall cause all subsequent writes to the file to be forced to the then current
         * end-of-file, regardless of intervening calls to fseek().
         */
        REQ("fopen.06;fopen64.06", "", TODO_REQ());

        /*
         * When a file is opened with update mode ( '+' as the second or third character
         * in the mode argument), both input and output may be performed on the associated
         * stream.
         */
        REQ("fopen.07;fopen64.07", "", TODO_REQ());

        /*
         * However, the application shall ensure that output is not directly followed by
         * input without an intervening call to fflush() or to a file positioning function
         * ( fseek(), fsetpos(), or rewind()), and input is not directly followed by
         * output without an intervening call to a file positioning function, unless the
         * input operation encounters end-of-file.
         */
        REQ("fopen.08;fopen64.08", "", TODO_REQ());

        /*
         * When opened, a stream is fully buffered if and only if it can be determined not
         * to refer to an interactive device.
         */
        REQ("fopen.09;fopen64.09", "", TODO_REQ());

        /*
         * The error and end-of-file indicators for the stream shall be cleared.
         */
        REQ("fopen.10;fopen64.10", "", TODO_REQ());

        /*
         * If mode is w, wb, a, ab, w+, wb+, w+b, a+, ab+, or a+b, and the file did not
         * previously exist, upon successful completion, the fopen() function shall mark
         * for update the st_atime, st_ctime, and st_mtime fields of the file and the
         * st_ctime and st_mtime fields of the parent directory.
         *
         * If mode is w, wb, w+, wb+, or w+b, and the file did previously exist, upon
         * successful completion, fopen() shall mark for update the st_ctime and st_mtime
         * fields of the file.
         */
        REQ("fopen.11.01;fopen64.11.01", "", TODO_REQ());

        /*
         * If mode is w, wb, a, ab, w+, wb+, w+b, a+, ab+, or a+b, and the file did not
         * previously exist, upon successful completion, the fopen() function shall mark
         * for update the st_atime, st_ctime, and st_mtime fields of the file and the
         * st_ctime and st_mtime fields of the parent directory.
         *
         * The fopen() function shall allocate a file descriptor as open() does.
         */
        REQ("fopen.11.02;fopen64.11.02", "", TODO_REQ());

        /*
         * After a successful call to the fopen() function, the orientation of the stream
         * shall be cleared,
         */
        REQ("fopen.12.01;fopen64.12.01", "", TODO_REQ());

        /*
         * the encoding rule shall be cleared,
         */
        REQ("fopen.12.02;fopen64.12.02", "", TODO_REQ());

        /*
         * and the associated mbstate_t object shall be set to describe an initial
         * conversion state.
         */
        REQ("fopen.12.03;fopen64.12.03", "", TODO_REQ());

        /*
         * The largest value that can be represented correctly in an object of type off_t
         * shall be established as the offset maximum in the open file description.
         */
        REQ("fopen.13;fopen64.13", "", TODO_REQ());

        /*
         * Upon successful completion, fopen() shall return a pointer to the object
         * controlling the stream.
         */
        REQ( "fopen.14.01;fopen64.14.01", "fopen() shall return a pointer to stream", streamState != NULL );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fputc - put a byte on a stream

SYNOPSIS

    #include <stdio.h>
    int fputc(int c, FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fputc() function shall write the byte specified by c (converted to an
    unsigned char) to the output stream pointed to by stream, at the position
    indicated by the associated file-position indicator for the stream (if
    defined), and shall advance the indicator appropriately. If the file cannot
    support positioning requests, or if the stream was opened with append mode,
    the byte shall be appended to the output stream.

    [CX]  The st_ctime and st_mtime fields of the file shall be marked for
    update between the successful execution of fputc() and the next successful
    completion of a call to fflush() or fclose() on the same stream or a call
    to exit() or abort().

RETURN VALUE

    Upon successful completion, fputc() shall return the value it has written.
    Otherwise, it shall return EOF, the error indicator for the stream shall be
    set, [CX]   and errno shall be set to indicate the error.

ERRORS

    The fputc() function shall fail if either the stream is unbuffered or the stream's buffer needs to be flushed, and:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor underlying
        stream and the thread would be delayed in the write operation.

        [EBADF]
        [CX]  The file descriptor underlying stream is not a valid file
        descriptor open for writing.

        [EFBIG]
        [CX]  An attempt was made to write to a file that exceeds the maximum
        file size.

        [EFBIG]
        [XSI]  An attempt was made to write to a file that exceeds the process'
        file size limit.

        [EFBIG]
        [CX]  The file is a regular file and an attempt was made to write at or
        beyond the offset maximum.

        [EINTR]
        [CX]  The write operation was terminated due to the receipt of a
        signal, and no data was transferred.

        [EIO]
        [CX]  A physical I/O error has occurred, or the process is a member of
        a background process group attempting to write to its controlling
        terminal, TOSTOP is set, the process is neither ignoring nor blocking
        SIGTTOU, and the process group of the process is orphaned. This error
        may also be returned under implementation-defined conditions.

        [ENOSPC]
        [CX]  There was no free space remaining on the device containing the
        file.

        [EPIPE]
        [CX]  An attempt is made to write to a pipe or FIFO that is not open
        for reading by any process. A SIGPIPE signal shall also be sent to the
        thread.

    The fputc() function may fail if:

        [ENOMEM]
        [CX]  Insufficient storage space is available.

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.
*/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    putc - put a byte on a stream

SYNOPSIS

    #include <stdio.h>
    int putc(int c, FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The putc() function shall be equivalent to fputc(), except that if it is
    implemented as a macro it may evaluate stream more than once, so the
    argument should never be an expression with side effects.

RETURN VALUE

    Refer to fputc().

ERRORS

    Refer to fputc().
*/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    putchar - put a byte on a stdout stream

SYNOPSIS

    #include <stdio.h>
    int putchar(int c);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The function call putchar(c) shall be equivalent to putc(c,stdout).

RETURN VALUE

    Refer to fputc().

ERRORS

    Refer to fputc().
*/

//This specification refers to: fputc, putc, putc_unlocked, putchar, putchar_unlocked
specification
IntT fputc_spec( CallContext context, IntT c, FILETPtr stream, ErrorCode * errno, IntT putc_type )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fputc_coverage = CoverageForFILETPtr( stream ) * CoverageForIntTAsUCharT( c );
    post
    {
        postStreamState = construct_StreamState( context, stream );
        verbose( "fputc_spec is %d\n", (int)fputc_spec );

        /*
         * Otherwise, it shall return EOF, the error indicator for the stream shall be set,
         * [CX] and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FPUTC, "fputc.04.02;putc.04.02;putc_unlocked.04.02;putchar.04.02;putchar_unlocked.04.02",
                     fputc_spec == SUT_EOF, * errno
                   )
            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FPUTC, EAGAIN, "fputc.05.01;putc.05.01;putc_unlocked.05.01;putchar.05.01;putchar_unlocked.05.01", TODO_ERR(EAGAIN))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL( POSIX_FPUTC, EBADF,
                         "fputc.05.02;putc.05.02;putc_unlocked.05.02;putchar.05.02;putchar_unlocked.05.02",
                         preStreamState == NULL || ! isAllowWriting_StreamState( preStreamState )
                       )

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FPUTC, EFBIG, "fputc.05.03;putc.05.03;putc_unlocked.05.03;putchar.05.03;putchar_unlocked.05.03", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [XSI] An attempt was made to write to a file that exceeds the
             * process' file size limit.
             */
            ERROR_SHALL(POSIX_FPUTC, EFBIG, "fputc.05.04;putc.05.04;putc_unlocked.05.04;putchar.05.04;putchar_unlocked.05.04", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum.
             */
            ERROR_SHALL(POSIX_FPUTC, EFBIG, "fputc.05.05;putc.05.05;putc_unlocked.05.05;putchar.05.05;putchar_unlocked.05.05", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FPUTC, EINTR, "fputc.05.06;putc.05.06;putc_unlocked.05.06;putchar.05.06;putchar_unlocked.05.06", TODO_ERR(EINTR))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FPUTC, EIO, "fputc.05.07;putc.05.07;putc_unlocked.05.07;putchar.05.07;putchar_unlocked.05.07", TODO_ERR(EIO))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FPUTC, ENOSPC, "fputc.05.08;putc.05.08;putc_unlocked.05.08;putchar.05.08;putchar_unlocked.05.08", TODO_ERR(ENOSPC))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FPUTC, EPIPE, "fputc.05.09;putc.05.09;putc_unlocked.05.09;putchar.05.09;putchar_unlocked.05.09", TODO_ERR(EPIPE))

            /*
             * The fputc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FPUTC, ENOMEM, "fputc.06.01;putc.06.01;putc_unlocked.06.01;putchar.06.01;putchar_unlocked.06.01", TODO_ERR(ENOMEM))

            /*
             * The fputc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FPUTC, ENXIO, "fputc.06.02;putc.06.02;putc_unlocked.06.02;putchar.06.02;putchar_unlocked.06.02", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * The fputc() function shall write the byte specified by c (converted to an
         * unsigned char) to the output stream pointed to by stream, at the position
         * indicated by the associated file-position indicator for the stream (if defined),
         */
        if ( putc_type != Char_Type && putc_type != Char_Unlocked_Type ) {
            setCurrentChar_StreamState( preStreamState, c );
        }
        REQ( "fputc.01.01;putc.01.01;putc_unlocked.01.01;putchar.01.01;putchar_unlocked.01.01",
             "fputc() function shall write the byte specified by c to the output stream pointed to by stream",
             isEqualsTo_StreamState( preStreamState, postStreamState )
           );

        /*
         * and shall advance the indicator appropriately.
         */
        REQ( "fputc.01.02;putc.01.02;putc_unlocked.01.02;putchar.01.02;putchar_unlocked.01.02",
             "fputc() function shall advance the indicator appropriately",
             getOffset_StreamState( preStreamState ) == getOffset_StreamState( postStreamState )
           );

        /*
         * If the file cannot support positioning requests, or if the stream was opened
         * with append mode, the byte shall be appended to the output stream.
         */
        REQ( "fputc.02;putc.02;putc_unlocked.02;putchar.02;putchar_unlocked.02",
             "byte shall be appended to the output stream",
             isEqualsTo_StreamState( preStreamState, postStreamState )
           );

        /*
         * The st_ctime and st_mtime fields of the file shall be marked for update between
         * the successful execution of fputc() and the next successful completion of a
         * call to fflush() or fclose() on the same stream or a call to exit() or abort().
         */
        REQ("fputc.03;putc.03;putc_unlocked.03;putchar.03;putchar_unlocked.03", "", TODO_REQ());

        /*
         * Upon successful completion, fputc() shall return the value it has written.
         */
        REQ( "fputc.04.01;putc.04.01;putc_unlocked.04.01;putchar.04.01;putchar_unlocked.04.01",
             "Upon successful completion, fputc() shall return the value it has written",
             fputc_spec == c
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fputs - put a string on a stream

SYNOPSIS

    #include <stdio.h>
    int fputs(const char *restrict s, FILE *restrict stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fputs() function shall write the null-terminated string pointed to by s
    to the stream pointed to by stream. The terminating null byte shall not be
    written.

    [CX]  The st_ctime and st_mtime fields of the file shall be marked for
    update between the successful execution of fputs() and the next successful
    completion of a call to fflush() or fclose() on the same stream or a call
    to exit() or abort().

RETURN VALUE

    Upon successful completion, fputs() shall return a non-negative number.
    Otherwise, it shall return EOF, set an error indicator for the stream,
    [CX]   and set errno to indicate the error.

ERRORS

    Refer to fputc().
*/
specification
IntT fputs_spec( CallContext context, CString * s, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fputs_coverage = CoverageForFILETPtr( stream ) * CoverageForNotNullCString( s );
    post
    {
        bool checkResult;
        postStreamState = construct_StreamState( context, stream );
        verbose( "fputs_spec\n" );
        // verbose( "fputs_spec is %d\n", (int)fputs_spec );
        print_StreamState( preStreamState , "preStreamState is "  );
        print_StreamState( postStreamState, "postStreamState is " );

        /*
         * Otherwise, it shall return EOF, set an error indicator for the stream, [CX]
         * and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FPUTS, "fputs.04.02", fputs_spec == SUT_EOF && * errno != SUT_EOK, * errno )
            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FPUTS, EAGAIN, "fputs.05.01", TODO_ERR(EAGAIN))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL( POSIX_FPUTS, EBADF, "fputs.05.02", preStreamState == NULL                         ||
                                                            ! isAllowWriting_StreamState( preStreamState )
                       )

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FPUTS, EFBIG, "fputs.05.03", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [XSI] An attempt was made to write to a file that exceeds the
             * process' file size limit.
             */
            ERROR_SHALL(POSIX_FPUTS, EFBIG, "fputs.05.04", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum.
             */
            ERROR_SHALL(POSIX_FPUTS, EFBIG, "fputs.05.05", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FPUTS, EINTR, "fputs.05.06", TODO_ERR(EINTR))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FPUTS, EIO, "fputs.05.07", TODO_ERR(EIO))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FPUTS, ENOSPC, "fputs.05.08", TODO_ERR(ENOSPC))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FPUTS, EPIPE, "fputs.05.09", TODO_ERR(EPIPE))

            /*
             * The fputc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FPUTS, ENOMEM, "fputs.06.01", TODO_ERR(ENOMEM))

            /*
             * The fputc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FPUTS, ENXIO, "fputs.06.02", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * The fputs() function shall write the null-terminated string pointed to by s to
         * the stream pointed to by stream.
         */
        printC_String( "s is ", s );
        setCurrentString_StreamState( preStreamState, s );
        print_StreamState( preStreamState , "modified preStreamState is "  );
        checkResult = isEqualsTo_StreamState( preStreamState, postStreamState );
        REQ( "fputs.01", "fputs() shall write the null-terminated string s to the stream", checkResult );

        /*
         * The terminating null byte shall not be written.
         */
        REQ( "fputs.02", "The terminating null byte shall not be written", checkResult );

        /*
        * The st_ctime and st_mtime fields of the file shall be marked for update between
        * the successful execution of fputs() and the next successful completion of a
        * call to fflush() or fclose() on the same stream or a call to exit() or abort().
        */
        REQ("fputs.03", "", TODO_REQ());

        /*
        * Upon successful completion, fputs() shall return a non-negative number.
        */
        REQ( "fputs.04.01", "fputs() shall return a non-negative number", fputs_spec >= 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fread - binary input

SYNOPSIS

    #include <stdio.h>
    size_t fread(void *restrict ptr, size_t size, size_t nitems,
        FILE *restrict stream);


DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fread() function shall read into the array pointed to by ptr up to
    nitems elements whose size is specified by size in bytes, from the stream
    pointed to by stream. For each object, size calls shall be made to the
    fgetc() function and the results stored, in the order read, in an array of
    unsigned char exactly overlaying the object. The file position indicator
    for the stream (if defined) shall be advanced by the number of bytes
    successfully read. If an error occurs, the resulting value of the file
    position indicator for the stream is unspecified. If a partial element is
    read, its value is unspecified.

    [CX]  The fread() function may mark the st_atime field of the file
    associated with stream for update. The st_atime field shall be marked
    for update by the first successful execution of fgetc(), fgets(), fgetwc(),
    fgetws(), fread(), fscanf(), getc(), getchar(), gets(), or scanf() using
    stream that returns data not supplied by a prior call to ungetc() or
    ungetwc().

RETURN VALUE

    Upon successful completion, fread() shall return the number of elements
    successfully read which is less than nitems only if a read error or
    end-of-file is encountered. If size or nitems is 0, fread() shall return
    0 and the contents of the array and the state of the stream remain
    unchanged. Otherwise, if a read error occurs, the error indicator for the
    stream shall be set, [CX]   and errno shall be set to indicate the error.

ERRORS

    Refer to fgetc().
*/

specification
SizeT fread_spec( CallContext context, VoidTPtr ptr, SizeT size, SizeT nitems, FILETPtr stream, ErrorCode * errno )
{
    StreamState         * preStreamState;    StreamState         * postStreamState;
    List /* ByteTObj */ * preDataFromPtr;    List /* ByteTObj */ * postDataFromPtr;

    pre
    {
        preStreamState = construct_StreamState( context, stream );
        preDataFromPtr = readByteList_VoidTPtr( ptr, size * nitems == 0 ? 1 : size * nitems );

        return true;
    }
    coverage fread_coverage = CoverageForFILETPtr( stream ) * CoverageForInteger_Min( size  , 0, SUT_INT_MAX ) *
                                                              CoverageForInteger_Min( nitems, 0, SUT_INT_MAX );
    post
    {
        postStreamState = construct_StreamState( context, stream );
        postDataFromPtr = readByteList_VoidTPtr( ptr, size * nitems == 0 ? 1 : size * nitems );
        // verbose( "fread_spec is %d\n", (int)fread_spec );
        // print_StreamState( preStreamState , "preStreamState is "  );
        // print_StreamState( postStreamState, "postStreamState is " );

        /*
         * Otherwise, if a read error occurs, the error indicator for the stream shall be
         * set, [CX] and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FREAD, "fread.08.03", * errno != SUT_EOK, * errno )
            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the fgetc() operation.
             */
            ERROR_SHALL(POSIX_FREAD, EAGAIN, "fread.fgetc.08.01", TODO_ERR(EAGAIN))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for reading.
             */
            ERROR_SHALL( POSIX_FREAD, EBADF, "fread.fgetc.08.02", preStreamState == NULL                         ||
                                                                  ! isAllowReading_StreamState( preStreamState )
                       );

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EINTR] [CX] The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FREAD, EINTR, "fread.fgetc.08.03", TODO_ERR(EINTR))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is in a
             * background process group attempting to read from its controlling terminal, and
             * either the process is ignoring or blocking the SIGTTIN signal or the process
             * group is orphaned. This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_SHALL(POSIX_FREAD, EIO, "fread.fgetc.08.04", TODO_ERR(EIO))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EOVERFLOW] [CX] The file is a regular file and an attempt was made to read
             * at or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FREAD, EOVERFLOW, "fread.fgetc.08.05", TODO_ERR(EOVERFLOW))

            /*
             * The fgetc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FREAD, ENOMEM, "fread.fgetc.09.01", TODO_ERR(ENOMEM))

            /*
             * The fgetc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FREAD, ENXIO, "fread.fgetc.09.02", TODO_ERR(ENXIO))

            if ( * errno != SUT_EOK ) {
                /*
                 * If an error occurs, the resulting value of the file position indicator for the
                 * stream is unspecified.
                 */
                REQ( "fread.04", "If an error occurs, the resulting value of the file position is unspecified", true );

                /*
                 * If a partial element is read, its value is unspecified.
                 */
                REQ( "fread.05", "If a partial element is read, its value is unspecified", true );

                /*
                 * which is less than nitems only if a read error or end-of-file is encountered.
                 */
                REQ( "fread.08.02", "read error is encountered", fread_spec <= nitems );
            }
        ERROR_END()

        if ( size == 0 || nitems == 0 )
        {
            /*
             * If size or nitems is 0, fread() shall return 0 and the contents of the array
             * and the state of the stream remain unchanged.
             */
            REQ( "fread.09",
                 "fread() shall return 0 and the contents of the array and the state of the stream remain unchanged",
                 T( fread_spec == 0                                           ) &&
                 T( equals( preDataFromPtr, postDataFromPtr )                 ) &&
                 T( isEqualsTo_StreamState( preStreamState, postStreamState ) )
               );
        }
        else
        {
            /*
             * The fread() function shall read into the array pointed to by ptr up to nitems
             * elements whose size is specified by size in bytes, from the stream pointed to
             * by stream.
             */
            // print_ListByteTObj( "postDataFromPtr is ", postDataFromPtr );
            // print_ListByteTObj( "getCurrentBytes is ", getCurrentBytes_StreamState( preStreamState, fread_spec * size ) );
            REQ( "fread.01", "fread() shall read into the array up to nitems elements whose size is specified by size",
                             equals( postDataFromPtr, getCurrentBytes_StreamState( preStreamState, fread_spec * size ) )
               );

            /*
             * For each object, size calls shall be made to the fgetc() function and the
             * results stored, in the order read, in an array of unsigned char exactly
             * overlaying the object.
             */
            REQ("fread.02", "", TODO_REQ());

            /*
             * The file position indicator for the stream (if defined) shall be advanced by
             * the number of bytes successfully read.
             */
            REQ( "fread.03",
                 "The file position indicator shall be advanced by the number of bytes successfully read",
                 getOffset_StreamState( preStreamState ) + fread_spec * size == getOffset_StreamState( postStreamState )
               );

            /*
             * The fread() function may mark the st_atime field of the file associated with
             * stream for update.
             */
            REQ( "fread.06", "fread() may mark the st_atime field for update", true );

            /*
             * The st_atime field shall be marked for update by the first successful execution
             * of fgetc(), fgets(), fgetwc(), fgetws(), fread(), fscanf(), getc(), getchar(),
             * gets(), or scanf() using stream that returns data not supplied by a prior call
             * to ungetc() or ungetwc().
             */
            REQ("fread.07", "", TODO_REQ());
        }

        /*
         * Upon successful completion, fread() shall return the number of elements
         * successfully read
         */
        REQ( "fread.08.01", "fread() shall return the number of elements successfully read",
                            fread_spec * size == size_List( postDataFromPtr )
           );

        /*
         * which is less than nitems only if a read error or end-of-file is encountered.
         */
        REQ( "fread.08.02", "less than nitems only if end-of-file is encountered",
                            ! fread_spec < nitems || isEof_StreamState( postStreamState )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

--------------------------------------------------------------------------------

NAME

    freopen - open a stream

SYNOPSIS

    #include <stdio.h>
    FILE *freopen(const char *restrict filename, const char *restrict mode,
        FILE *restrict stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The freopen() function shall first attempt to flush the stream and close
    any file descriptor associated with stream. Failure to flush or close the
    file descriptor successfully shall be ignored. The error and end-of-file
    indicators for the stream shall be cleared.

    The freopen() function shall open the file whose pathname is the string
    pointed to by filename and associate the stream pointed to by stream with
    it. The mode argument shall be used just as in fopen().

    The original stream shall be closed regardless of whether the subsequent
    open succeeds.

    If filename is a null pointer, the freopen() function shall attempt to
    change the mode of the stream to that specified by mode, as if the name
    of the file currently associated with the stream had been used. In this
    case, the file descriptor associated with the stream need not be closed
    if the call to freopen() succeeds. It is implementation-defined which
    changes of mode are permitted (if any), and under what circumstances.

    After a successful call to the freopen() function, the orientation of the
    stream shall be cleared, [XSI]   the encoding rule shall be cleared,  and
    the associated mbstate_t object shall be set to describe an initial
    conversion state.

    [CX] The largest value that can be represented correctly in an object of
    type off_t shall be established as the offset maximum in the open file
    description.

RETURN VALUE

    Upon successful completion, freopen() shall return the value of stream.
    Otherwise, a null pointer shall be returned, [CX]   and errno shall be set
    to indicate the error.

ERRORS

    The freopen() function shall fail if:

        [EACCES]
        [CX]  Search permission is denied on a component of the path prefix, or
        the file exists and the permissions specified by mode are denied, or
        the file does not exist and write permission is denied for the parent
        directory of the file to be created.

        [EBADF]
        [CX]  The file descriptor underlying the stream is not a valid file
        descriptor when filename is a null pointer.

        [EINTR]
        [CX]  A signal was caught during freopen().

        [EISDIR]
        [CX]  The named file is a directory and mode requires write access.

        [ELOOP]
        [CX]  A loop exists in symbolic links encountered during resolution of
        the path argument.

        [EMFILE]
        [CX]  {OPEN_MAX} file descriptors are currently open in the calling
        process.

        [ENAMETOOLONG]
        [CX]
        The length of the filename argument exceeds {PATH_MAX} or a pathname
        component is longer than {NAME_MAX}.

        [ENFILE]
        [CX]  The maximum allowable number of files is currently open in the
        system.

        [ENOENT]
        [CX]  A component of filename does not name an existing file or
        filename is an empty string.

        [ENOSPC]
        [CX]  The directory or file system that would contain the new file
        cannot be expanded, the file does not exist, and it was to be created.

        [ENOTDIR]
        [CX]  A component of the path prefix is not a directory.

        [ENXIO]
        [CX]  The named file is a character special or block special file, and
        the device associated with this special file does not exist.

        [EOVERFLOW]
        [CX]  The named file is a regular file and the size of the file cannot
        be represented correctly in an object of type off_t.

        [EROFS]
        [CX]  The named file resides on a read-only file system and mode
        requires write access.

    The freopen() function may fail if:

        [EBADF]
        [CX]  The mode with which the file descriptor underlying the stream was
        opened does not support the requested mode when filename is a null
        pointer.

        [EINVAL]
        [CX]  The value of the mode argument is not valid.

        [ELOOP]
        [CX]  More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path argument.

        [ENAMETOOLONG]
        [CX]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.

        [ENOMEM]
        [CX]  Insufficient storage space is available.

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.

        [ETXTBSY]
        [CX]  The file is a pure procedure (shared text) file that is being
        executed and mode requires write access.
*/

//This specification refers to: freopen, freopen64
specification
FILETPtr freopen_spec
             ( CallContext context, CString * filename, CString * mode, FILETPtr stream, ErrorCode * errno, bool is64bits )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage freopen_coverage =
                 CoverageForCString( filename ) * CoverageForCStringAsMode( mode ) * CoverageForFILETPtr( stream );
    post
    {
        bool isRMode, isWMode, isAMode, isRPMode, isWPMode, isAPMode, isAllowReading, isAllowWriting, isEmpty, isEof;
        postStreamState = construct_StreamState( context, stream );

        /*
         * Otherwise, a null pointer shall be returned, [CX] and errno shall be set to
         * indicate the error.
         */
        ERROR_BEGIN( POSIX_FREOPEN, "freopen.12.02", isNULL_VoidTPtr( freopen_spec ) && * errno != SUT_EOK, * errno )
            /*
             * The freopen() function shall fail if:
             *
             * [EACCES] [CX] Search permission is denied on a component of the path prefix,
             * or the file exists and the permissions specified by mode are denied, or the
             * file does not exist and write permission is denied for the parent directory of
             * the file to be created.
             */
            ERROR_SHALL(POSIX_FREOPEN, EACCES, "freopen.13.01", TODO_ERR(EACCES))

            /*
             * The freopen() function shall fail if:
             *
             * [EBADF] [CX] The file descriptor underlying the stream is not a valid file
             * descriptor when filename is a null pointer.
             */
            ERROR_SHALL( POSIX_FREOPEN, EBADF, "freopen.13.02", preStreamState == NULL                                 &&
                                                                freopen_coverage[ 0 ] == CoverageForCString.NullString
                       )

            /*
             * The freopen() function shall fail if:
             *
             * [EINTR] [CX] A signal was caught during freopen().
             */
            ERROR_SHALL(POSIX_FREOPEN, EINTR, "freopen64.13.03", TODO_ERR(EINTR))

            /*
             * The freopen() function shall fail if:
             *
             * [EISDIR] [CX] The named file is a directory and mode requires write access.
             */
            ERROR_SHALL(POSIX_FREOPEN, EISDIR, "freopen.13.04", TODO_ERR(EISDIR))

            /*
             * The freopen() function shall fail if:
             *
             * [ELOOP] [CX] A loop exists in symbolic links encountered during resolution
             * of the path argument.
             */
            ERROR_SHALL(POSIX_FREOPEN, ELOOP, "freopen64.13.05", TODO_ERR(ELOOP))

            /*
             * The freopen() function shall fail if:
             *
             * [EMFILE] [CX] {OPEN_MAX} file descriptors are currently open in the calling
             * process.
             */
            ERROR_SHALL(POSIX_FREOPEN, EMFILE, "freopen.13.06", TODO_ERR(EMFILE))

            /*
             * The freopen() function shall fail if:
             *
             * [ENAMETOOLONG] [CX] The length of the filename argument exceeds {PATH_MAX}
             * or a pathname component is longer than {NAME_MAX}.
             */
            ERROR_SHALL(POSIX_FREOPEN, ENAMETOOLONG, "freopen64.13.07", TODO_ERR(ENAMETOOLONG))

            /*
             * The freopen() function shall fail if:
             *
             * [ENFILE] [CX] The maximum allowable number of files is currently open in the
             * system.
             */
            ERROR_SHALL(POSIX_FREOPEN, ENFILE, "freopen.13.08", TODO_ERR(ENFILE))

            /*
             * The freopen() function shall fail if:
             *
             * [ENOENT] [CX] A component of filename does not name an existing file or
             * filename is an empty string.
             */
            ERROR_SHALL( POSIX_FREOPEN, ENOENT, "freopen64.13.09",
                                                freopen_coverage[ 0 ] == CoverageForNotNullCString.EmptyString
                       )

            /*
             * The freopen() function shall fail if:
             *
             * [ENOSPC] [CX] The directory or file system that would contain the new file
             * cannot be expanded, the file does not exist, and it was to be created.
             */
            ERROR_SHALL(POSIX_FREOPEN, ENOSPC, "freopen.13.10", TODO_ERR(ENOSPC))

            /*
             * The freopen() function shall fail if:
             *
             * [ENOTDIR] [CX] A component of the path prefix is not a directory.
             */
            ERROR_SHALL(POSIX_FREOPEN, ENOTDIR, "freopen64.13.11", TODO_ERR(ENOTDIR))

            /*
             * The freopen() function shall fail if:
             *
             * [ENXIO] [CX] The named file is a character special or block special file,
             * and the device associated with this special file does not exist.
             */
            ERROR_SHALL(POSIX_FREOPEN, ENXIO, "freopen.13.12", TODO_ERR(ENXIO))

            /*
             * The freopen() function shall fail if:
             *
             * [EOVERFLOW] [CX] The named file is a regular file and the size of the file
             * cannot be represented correctly in an object of type off_t.
             */
            ERROR_SHALL(POSIX_FREOPEN, EOVERFLOW, "freopen64.13.13", TODO_ERR(EOVERFLOW))

            /*
             * The freopen() function shall fail if:
             *
             * [EROFS] [CX] The named file resides on a read-only file system and mode
             * requires write access.
             */
            ERROR_SHALL(POSIX_FREOPEN, EROFS, "freopen.13.14", TODO_ERR(EROFS))

            /*
             * The freopen() function may fail if:
             *
             * [EBADF] [CX] The mode with which the file descriptor underlying the stream
             * was opened does not support the requested mode when filename is a null pointer.
             *
             */
            ERROR_MAY( POSIX_FREOPEN, EBADF, "freopen.14.01", freopen_coverage[ 0 ] == CoverageForCString.NullString )

            /*
             * The freopen() function may fail if:
             *
             * [EINVAL] [CX] The value of the mode argument is not valid.
             */
            ERROR_MAY( POSIX_FREOPEN, EINVAL, "freopen.14.02",
                                              freopen_coverage[ 1 ] == CoverageForCStringAsMode.UnknownMode
                     )

            /*
             * The freopen() function may fail if:
             *
             * [ELOOP] [CX] More than {SYMLOOP_MAX} symbolic links were encountered during
             * resolution of the path argument.
             */
            ERROR_MAY(POSIX_FREOPEN, ELOOP, "freopen.14.03", TODO_ERR(ELOOP))

            /*
             * The freopen() function may fail if:
             *
             * [ENAMETOOLONG] [CX] Pathname resolution of a symbolic link produced an
             * intermediate result whose length exceeds {PATH_MAX}.
             */
            ERROR_MAY(POSIX_FREOPEN, ENAMETOOLONG, "freopen.14.04", TODO_ERR(ENAMETOOLONG))

            /*
             * The freopen() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FREOPEN, ENOMEM, "freopen.14.05", TODO_ERR(ENOMEM))

            /*
             * The freopen() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FREOPEN, ENXIO, "freopen.14.06", TODO_ERR(ENXIO))

            /*
             * The freopen() function may fail if:
             *
             * [ETXTBSY] [CX] The file is a pure procedure (shared text) file that is being
             * executed and mode requires write access.
             */
            ERROR_MAY(POSIX_FREOPEN, ETXTBSY, "freopen.14.07", TODO_ERR(ETXTBSY))
        ERROR_END()

        /*
         * The freopen() function shall first attempt to flush the stream and close any
         * file descriptor associated with stream.
         */
        REQ("freopen.01;freopen64.01", "", TODO_REQ());

        /*
         * Failure to flush or close the file descriptor successfully shall be ignored.
         */
        REQ("freopen.02;freopen64.02", "", TODO_REQ());

        /*
         * The error and end-of-file indicators for the stream shall be cleared.
         */
        REQ("freopen.03;freopen64.03", "", TODO_REQ());

        /*
         * The freopen() function shall open the file whose pathname is the string pointed
         * to by filename and associate the stream pointed to by stream with it.
         */
        REQ( "freopen.04;freopen64.04", "freopen() shall open the file and associate the stream with it",
                                        postStreamState != NULL
           );

        /*
         * The mode argument shall be used just as in fopen().
         */
        isRMode  = ( freopen_coverage[ 1 ] == CoverageForCStringAsMode.rMode  );
        isWMode  = ( freopen_coverage[ 1 ] == CoverageForCStringAsMode.wMode  );
        isAMode  = ( freopen_coverage[ 1 ] == CoverageForCStringAsMode.aMode  );
        isRPMode = ( freopen_coverage[ 1 ] == CoverageForCStringAsMode.rpMode );
        isWPMode = ( freopen_coverage[ 1 ] == CoverageForCStringAsMode.wpMode );
        isAPMode = ( freopen_coverage[ 1 ] == CoverageForCStringAsMode.apMode );
        isAllowReading = isAllowReading_StreamState( postStreamState );
        isAllowWriting = isAllowWriting_StreamState( postStreamState );
        isEmpty = ( size_StreamState( postStreamState ) == 0 );
        isEof = isEof_StreamState( postStreamState );
        REQ( "freopen.05;freopen64.05",
             "The mode argument shall be used just as in fopen()",
             ( ! isRMode  || (            isAllowReading                            ) ) &&
             ( ! isWMode  || ( isEmpty &&                   isAllowWriting          ) ) &&
             ( ! isAMode  || (                              isAllowWriting && isEof ) ) &&
             ( ! isRPMode || (            isAllowReading && isAllowWriting          ) ) &&
             ( ! isWPMode || ( isEmpty && isAllowReading && isAllowWriting          ) ) &&
             ( ! isAPMode || (                              isAllowWriting && isEof ) )
           );

        /*
         * The original stream shall be closed regardless of whether the subsequent open
         * succeeds.
         */
        REQ("freopen.06;freopen64.06", "", TODO_REQ());

        if ( filename == NULL )
        {
            /*
             * If filename is a null pointer, the freopen() function shall attempt to change
             * the mode of the stream to that specified by mode, as if the name of the file
             * currently associated with the stream had been used.
             */
            REQ("freopen.07;freopen64.07", "", TODO_REQ());

            /*
             * In this case, the file descriptor associated with the stream need not be closed
             * if the call to freopen() succeeds.
             */
            REQ( "freopen.08;freopen64.08", "file descriptor need not be closed",
                                            equals_VoidTPtr( freopen_spec, stream )
               );
        }

        /*
         * It is implementation-defined which changes of mode are permitted (if any), and
         * under what circumstances.
         */
        REQ( "freopen.09;freopen64.09", "It is implementation-defined which changes of mode are permitted", true );

        /*
         * After a successful call to the freopen() function, the orientation of the
         * stream shall be cleared,
         */
        REQ("freopen.10.01;freopen64.10.01", "", TODO_REQ());

        /*
         * the encoding rule shall be cleared,
         */
        REQ("freopen.10.02;freopen64.10.02", "", TODO_REQ());

        /*
         * and the associated mbstate_t object shall be set to describe an initial
         * conversion state.
         */
        REQ("freopen.10.03;freopen64.10.03", "", TODO_REQ());

        /*
         * The largest value that can be represented correctly in an object of type off_t
         * shall be established as the offset maximum in the open file description.
         */
        REQ("freopen.11;freopen64.11", "", TODO_REQ());

        /*
         * Upon successful completion, freopen() shall return the value of stream.
         */
        REQ( "freopen.12.01;freopen64.12.01", "freopen() shall return the value of stream", postStreamState != NULL );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fseek, fseeko - reposition a file-position indicator in a stream

SYNOPSIS

    #include <stdio.h>
    int fseek(FILE *stream, long offset, int whence);
[CX]  int fseeko(FILE *stream, off_t offset, int whence);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fseek() function shall set the file-position indicator for the stream
    pointed to by stream. If a read or write error occurs, the error indicator
    for the stream shall be set and fseek() fails.

    The new position, measured in bytes from the beginning of the file, shall
    be obtained by adding offset to the position specified by whence. The
    specified point is the beginning of the file for SEEK_SET, the current
    value of the file-position indicator for SEEK_CUR, or end-of-file for
    SEEK_END.

    If the stream is to be used with wide-character input/output functions,
    the application shall ensure that offset is either 0 or a value returned
    by an earlier call to ftell() on the same stream and whence is SEEK_SET.

    A successful call to fseek() shall clear the end-of-file indicator for the
    stream and undo any effects of ungetc() and ungetwc() on the same stream.
    After an fseek() call, the next operation on an update stream may be either
    input or output.

    [CX]  If the most recent operation, other than ftell(), on a given stream
    is fflush(), the file offset in the underlying open file description shall
    be adjusted to reflect the location specified by fseek().

    The fseek() function shall allow the file-position indicator to be set
    beyond the end of existing data in the file. If data is later written at
    this point, subsequent reads of data in the gap shall return bytes with
    the value 0 until data is actually written into the gap.

    The behavior of fseek() on devices which are incapable of seeking is
    implementation-defined. The value of the file offset associated with such
    a device is undefined.

    If the stream is writable and buffered data had not been written to the
    underlying file, fseek() shall cause the unwritten data to be written to
    the file and shall mark the st_ctime and st_mtime fields of the file for
    update.

    In a locale with state-dependent encoding, whether fseek() restores the
    stream's shift state is implementation-defined.

    The fseeko() function shall be equivalent to the fseek() function except
    that the offset argument is of type off_t.

RETURN VALUE
    The fseek() [CX]   and fseeko()  functions shall return 0 if they succeed.

    [CX] Otherwise, they shall return -1 and set errno to indicate the error.

ERRORS

    The fseek() [CX]   and fseeko()   functions shall fail if, [CX]   either
    the stream is unbuffered or the stream's buffer needed to be flushed, and
    the call to fseek() or fseeko() causes an underlying lseek() or write() to
    be invoked, and:

        [EAGAIN]
        [CX]  The O_NONBLOCK flag is set for the file descriptor and the thread
        would be delayed in the write operation.

        [EBADF]
        [CX]  The file descriptor underlying the stream file is not open for
        writing or the stream's buffer needed to be flushed and the file is not
        open.

        [EFBIG]
        [CX]  An attempt was made to write a file that exceeds the maximum file
        size.

        [EFBIG]
        [XSI]  An attempt was made to write a file that exceeds the process'
        file size limit.

        [EFBIG]
        [CX]  The file is a regular file and an attempt was made to write at or
        beyond the offset maximum associated with the corresponding stream.

        [EINTR]
        [CX]  The write operation was terminated due to the receipt of a
        signal, and no data was transferred.

        [EINVAL]
        [CX]  The whence argument is invalid. The resulting file-position
        indicator would be set to a negative value.

        [EIO]
        [CX]  A physical I/O error has occurred, or the process is a member of
        a background process group attempting to perform a write() to its
        controlling terminal, TOSTOP is set, the process is neither ignoring
        nor blocking SIGTTOU, and the process group of the process is orphaned.
        This error may also be returned under implementation-defined
        conditions.

        [ENOSPC]
        [CX]  There was no free space remaining on the device containing the
        file.

        [ENXIO]
        [CX]  A request was made of a nonexistent device, or the request was
        outside the capabilities of the device.

        [EOVERFLOW]
        [CX]  For fseek(), the resulting file offset would be a value which
        cannot be represented correctly in an object of type long.

        [EOVERFLOW]
        [CX]  For fseeko(), the resulting file offset would be a value which
        cannot be represented correctly in an object of type off_t.

        [EPIPE]
        [CX]  An attempt was made to write to a pipe or FIFO that is not open
        for reading by any process; a SIGPIPE signal shall also be sent to the
        thread.

        [ESPIPE]
        [CX]  The file descriptor underlying stream is associated with a pipe
        or FIFO.
*/

//This specification refers to: fseek, fseeko, fseeko64
specification
IntT fseek_spec( CallContext context, FILETPtr stream, OffT offset, IntT whence, IntT offsetType, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fseek_coverage = CoverageForFILETPtr        ( stream                                  ) *
                              CoverageForInteger_Middle  ( offset    , SUT_INT_MIN, 0, SUT_INT_MAX ) *
                              CoverageForIntTAsWhence    ( whence                                  ) *
                              CoverageForIntTAsOffsetType( offsetType                              );
    post
    {
        bool checkResult;
        postStreamState = construct_StreamState( context, stream );

        /*
         * Otherwise, they shall return -1 and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FSEEK, "fseek.14.02;fseeko.14.02;fseeko64.14.02",
                     fseek_spec == -1 && * errno != SUT_EOK, * errno
                   )
            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor and the
             * thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FSEEK, EAGAIN, "fseek.15.01;fseeko.15.01;fseeko64.15.01", TODO_ERR(EAGAIN))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EBADF] [CX] The file descriptor underlying the stream file is not open for
             * writing or the stream's buffer needed to be flushed and the file is not open.
             */
            ERROR_SHALL(POSIX_FSEEK, EBADF, "fseek.15.02;fseeko.15.02;fseeko64.15.02", TODO_ERR(EBADF))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EFBIG] [CX] An attempt was made to write a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FSEEK, EFBIG, "fseek.15.03;fseeko.15.03;fseeko64.15.03", TODO_ERR(EFBIG))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EFBIG] [XSI] An attempt was made to write a file that exceeds the process'
             * file size limit.
             */
            ERROR_SHALL(POSIX_FSEEK, EFBIG, "fseek.15.04;fseeko.15.04;fseeko64.15.04", TODO_ERR(EFBIG))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FSEEK, EFBIG, "fseek.15.05;fseeko.15.05;fseeko64.15.05", TODO_ERR(EFBIG))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FSEEK, EINTR, "fseek.15.06;fseeko.15.06;fseeko64.15.06", TODO_ERR(EINTR))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EINVAL] [CX] The whence argument is invalid. The resulting file-position
             * indicator would be set to a negative value.
             */
            ERROR_SHALL( POSIX_FSEEK, EINVAL, "fseek.15.07;fseeko.15.07;fseeko64.15.07",
                                              fseek_coverage[ 2 ] == CoverageForIntTAsWhence.Unknown
                       )

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to perform a write() to its controlling
             * terminal, TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU,
             * and the process group of the process is orphaned. This error may also be
             * returned under implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FSEEK, EIO, "fseek.15.08;fseeko.15.08;fseeko64.15.08", TODO_ERR(EIO))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FSEEK, ENOSPC, "fseek.15.09;fseeko.15.09;fseeko64.15.09", TODO_ERR(ENOSPC))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_SHALL(POSIX_FSEEK, ENXIO, "fseek.15.10;fseeko.15.10;fseeko64.15.10", TODO_ERR(ENXIO))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EOVERFLOW] [CX] For fseek(), the resulting file offset would be a value
             * which cannot be represented correctly in an object of type long.
             */
            ERROR_SHALL(POSIX_FSEEK, EOVERFLOW, "fseek.15.11;fseeko.15.11;fseeko64.15.11", TODO_ERR(EOVERFLOW))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EOVERFLOW] [CX] For fseeko(), the resulting file offset would be a value
             * which cannot be represented correctly in an object of type off_t.
             */
            ERROR_SHALL(POSIX_FSEEK, EOVERFLOW, "fseek.15.12;fseeko.15.12;fseeko64.15.12", TODO_ERR(EOVERFLOW))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EPIPE] [CX] An attempt was made to write to a pipe or FIFO that is not open
             * for reading by any process; a SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FSEEK, EPIPE, "fseek.15.13;fseeko.15.13;fseeko64.15.13", TODO_ERR(EPIPE))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [ESPIPE] [CX] The file descriptor underlying stream is associated with a
             * pipe or FIFO.
             */
            ERROR_SHALL(POSIX_FSEEK, ESPIPE, "fseek.15.14;fseeko.15.14;fseeko64.15.14", TODO_ERR(ESPIPE))

            if ( fseek_spec == -1 )
            {
                /*
                 * If a read or write error occurs, the error indicator for the stream shall be
                 * set and fseek() fails.
                 */
                REQ("fseek.02;fseeko.02;fseeko64.02", "", TODO_REQ());
            }
        ERROR_END()

        /*
         * The fseek() function shall set the file-position indicator for the stream
         * pointed to by stream.
         */
        switch ( fseek_coverage[ 2 ] ) {
            case CoverageForIntTAsWhence.SeekSet:
                checkResult = ( getOffset_StreamState( postStreamState ) == offset );
                break;
            case CoverageForIntTAsWhence.SeekCur:
                checkResult = ( getOffset_StreamState( postStreamState ) == getOffset_StreamState( preStreamState ) +
                                                                            offset
                              );
                break;
            case CoverageForIntTAsWhence.SeekEnd:
                checkResult = ( getOffset_StreamState( postStreamState ) == size_StreamState( postStreamState ) + offset );
                break;
            default: assertion( false, "fseek_spec : fseek_coverage[ 2 ] is %d", fseek_coverage[ 2 ] ); break;
        }
        REQ( "fseek.01;fseeko.01;fseeko64.01", "fseek() shall set the file-position indicator", checkResult );

        /*
         * The new position, measured in bytes from the beginning of the file, shall be
         * obtained by adding offset to the position specified by whence.
         */
        REQ( "fseek.03;fseeko.03;fseeko64.03", "new position", checkResult );

        /*
         * The specified point is the beginning of the file for SEEK_SET, the current
         * value of the file-position indicator for SEEK_CUR, or end-of-file for SEEK_END.
         */
        REQ( "fseek.04;fseeko.04;fseeko64.04", "specified point", checkResult );

        /*
         * If the stream is to be used with wide-character input/output functions, the
         * application shall ensure that offset is either 0 or a value returned by an
         * earlier call to ftell() on the same stream and whence is SEEK_SET.
         */
        REQ("fseek.05;fseeko.05;fseeko64.05", "", TODO_REQ());

        /*
         * A successful call to fseek() shall clear the end-of-file indicator for the
         * stream and undo any effects of ungetc() and ungetwc() on the same stream.
         */
        REQ("fseek.06;fseeko.06;fseeko64.06", "", TODO_REQ());

        /*
         * After an fseek() call, the next operation on an update stream may be either
         * input or output.
         */
        REQ("fseek.07;fseeko.07;fseeko64.07", "", TODO_REQ());

        /*
         * If the most recent operation, other than ftell(), on a given stream is fflush(),
         * the file offset in the underlying open file description shall be adjusted to
         * reflect the location specified by fseek().
         */
        REQ("fseek.08;fseeko.08;fseeko64.08", "", TODO_REQ());

        /*
         * The fseek() function shall allow the file-position indicator to be set beyond
         * the end of existing data in the file.
         */
        REQ( "fseek.09;fseeko.09;fseeko64.09",
             "fseek() shall allow the file-position indicator to be set beyond the end of existing data in the file",
             checkResult
           );

        /*
         * If data is later written at this point, subsequent reads of data in the gap
         * shall return bytes with the value 0 until data is actually written into the gap.
         */
        REQ("fseek.10;fseeko.10;fseeko64.10", "", TODO_REQ());

        /*
         * The behavior of fseek() on devices which are incapable of seeking is
         * implementation-defined. The value of the file offset associated with such a
         * device is undefined.
         */
        REQ( "fseek.11;fseeko.11;fseeko64.11",
             "The behavior of fseek() on devices which are incapable of seeking is implementation-defined",
             true
           );

        /*
         * If the stream is writable and buffered data had not been written to the
         * underlying file, fseek() shall cause the unwritten data to be written to the
         * file
         */
        REQ("fseek.12.01;fseeko.12.01;fseeko64.12.01", "", TODO_REQ());

        /*
         * and shall mark the st_ctime and st_mtime fields of the file for update.
         */
        REQ("fseek.12.02;fseeko.12.02;fseeko64.12.02", "", TODO_REQ());

        /*
         * In a locale with state-dependent encoding, whether fseek() restores the stream'
         * s shift state is implementation-defined.
         */
        REQ("fseek.13;fseeko.13;fseeko64.13", "", TODO_REQ());

        /*
         * The fseek() [CX] and fseeko() functions shall return 0 if they succeed.
         */
        REQ( "fseek.14.01;fseeko.14.01;fseeko64.14.01", "fseek() and fseeko() shall return 0", fseek_spec == 0 );

        /*
         * The fseeko() function shall be equivalent to the fseek() function except that
         * the offset argument is of type off_t.
         */
        REQ( "fseeko.16", "fseeko() function shall be equivalent to the fseek()", GENERAL_REQ( "fseeko.*" ) );
        /*
         * The fseeko[64]() function shall be equivalent to the fseek() function except that
         * the offset argument is of type [l]off_t.
         */
        REQ( "fseeko64.16", "fseeko64() function shall be equivalent to the fseek()", GENERAL_REQ( "fseeko64.*" ) );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fsetpos - set current file position

SYNOPSIS

    #include <stdio.h>
    int fsetpos(FILE *stream, const fpos_t *pos);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fsetpos() function shall set the file position and state indicators for
    the stream pointed to by stream according to the value of the object
    pointed to by pos, which the application shall ensure is a value obtained
    from an earlier call to fgetpos() on the same stream. If a read or write
    error occurs, the error indicator for the stream shall be set and fsetpos()
    fails.

    A successful call to the fsetpos() function shall clear the end-of-file
    indicator for the stream and undo any effects of ungetc() on the same
    stream. After an fsetpos() call, the next operation on an update stream may
    be either input or output.

    [CX]  The behavior of fsetpos() on devices which are incapable of seeking
    is implementation-defined. The value of the file offset associated with
    such a device is undefined.

RETURN VALUE

    The fsetpos() function shall return 0 if it succeeds; otherwise, it shall
    return a non-zero value and set errno to indicate the error.

ERRORS
    The fsetpos() function shall fail if, [CX]   either the stream is
    unbuffered or the stream's buffer needed to be flushed, and the call to
    fsetpos() causes an underlying lseek() or write() to be invoked, and:

    [EAGAIN]
    [CX]  The O_NONBLOCK flag is set for the file descriptor and the thread
    would be delayed in the write operation.

    [EBADF]
    [CX]  The file descriptor underlying the stream file is not open for
    writing or the stream's buffer needed to be flushed and the file is not
    open.

    [EFBIG]
    [CX]  An attempt was made to write a file that exceeds the maximum file
    size.

    [EFBIG]
    [XSI]  An attempt was made to write a file that exceeds the process' file
    size limit.

    [EFBIG]
    [CX]  The file is a regular file and an attempt was made to write at or
    beyond the offset maximum associated with the corresponding stream.

    [EINTR]
    [CX]  The write operation was terminated due to the receipt of a signal,
    and no data was transferred.

    [EIO]
    [CX]  A physical I/O error has occurred, or the process is a member of a
    background process group attempting to perform a write() to its controlling
    terminal, TOSTOP is set, the process is neither ignoring nor blocking
    SIGTTOU, and the process group of the process is orphaned. This error may
    also be returned under implementation-defined conditions.

    [ENOSPC]
    [CX]  There was no free space remaining on the device containing the file.

    [ENXIO]
    [CX]  A request was made of a nonexistent device, or the request was
    outside the capabilities of the device.

    [EPIPE]
    [CX]  The file descriptor underlying stream is associated with a pipe or
    FIFO.

    [EPIPE]
    [CX]  An attempt was made to write to a pipe or FIFO that is not open for
    reading by any process; a SIGPIPE signal shall also be sent to the thread.
*/

//This specification refers to: fsetpos, fsetpos64
specification
IntT fsetpos_spec( CallContext context, FILETPtr stream, FPosTPtr pos, bool is64bits, ErrorCode * errno )
{
    pre
    {
        /*
         * The behavior of fsetpos() on devices which are incapable of seeking is
         * implementation-defined. The value of the file offset associated with such a
         * device is undefined.
         */
        REQ("app.fsetpos.05;app.fsetpos64.05", "", TODO_REQ());

        return true;
    }
    coverage fsetpos_coverage = CoverageForFILETPtr( stream );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );

        /*
         * otherwise, it shall return a non-zero value and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FSETPOS, "fsetpos.06.02;fsetpos64.06.02", fsetpos_spec != 0 && * errno != SUT_EOK, * errno )
            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor and the
             * thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FSETPOS, EAGAIN, "fsetpos.07.01;fsetpos64.07.01", TODO_ERR(EAGAIN))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EBADF] [CX] The file descriptor underlying the stream file is not open for
             * writing or the stream's buffer needed to be flushed and the file is not open.
             */
            ERROR_SHALL(POSIX_FSETPOS, EBADF, "fsetpos.07.02;fsetpos64.07.02", TODO_ERR(EBADF))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EFBIG] [CX] An attempt was made to write a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FSETPOS, EFBIG, "fsetpos.07.03;fsetpos64.07.03", TODO_ERR(EFBIG))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EFBIG] [XSI] An attempt was made to write a file that exceeds the process'
             * file size limit.
             */
            ERROR_SHALL(POSIX_FSETPOS, EFBIG, "fsetpos.07.04;fsetpos64.07.04", TODO_ERR(EFBIG))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_FSETPOS, EFBIG, "fsetpos.07.05;fsetpos64.07.05", TODO_ERR(EFBIG))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FSETPOS, EINTR, "fsetpos.07.06;fsetpos64.07.06", TODO_ERR(EINTR))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to perform a write() to its controlling
             * terminal, TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU,
             * and the process group of the process is orphaned. This error may also be
             * returned under implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FSETPOS, EIO, "fsetpos.07.07;fsetpos64.07.07", TODO_ERR(EIO))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FSETPOS, ENOSPC, "fsetpos.07.08;fsetpos64.07.08", TODO_ERR(ENOSPC))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_SHALL(POSIX_FSETPOS, ENXIO, "fsetpos.07.09;fsetpos64.07.09", TODO_ERR(ENXIO))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EPIPE] [CX] The file descriptor underlying stream is associated with a pipe
             * or FIFO.
             */
            ERROR_SHALL(POSIX_FSETPOS, EPIPE, "fsetpos.07.10;fsetpos64.07.10", TODO_ERR(EPIPE))

            /*
             * The fsetpos() function shall fail if, [CX] either the stream is unbuffered or
             * the stream's buffer needed to be flushed, and the call to fsetpos() causes an
             * underlying lseek() or write() to be invoked, and:
             *
             * [EPIPE] [CX] An attempt was made to write to a pipe or FIFO that is not open
             * for reading by any process; a SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FSETPOS, EPIPE, "fsetpos.07.11;fsetpos64.07.11", TODO_ERR(EPIPE))
        ERROR_END()

        /*
         * The fsetpos() function shall set the file position and state indicators for the
         * stream pointed to by stream according to the value of the object pointed to by
         * pos, which the application shall ensure is a value obtained from an earlier
         * call to fgetpos() on the same stream.
         */
        REQ("fsetpos.01;fsetpos64.01", "", TODO_REQ());

        /*
         * If a read or write error occurs, the error indicator for the stream shall be
         * set and fsetpos() fails.
         */
        REQ("fsetpos.02;fsetpos64.02", "", TODO_REQ());

        /*
         * A successful call to the fsetpos() function shall clear the end-of-file
         * indicator for the stream and undo any effects of ungetc() on the same stream.
         */
        REQ("fsetpos.03;fsetpos64.03", "", TODO_REQ());

        /*
         * After an fsetpos() call, the next operation on an update stream may be either
         * input or output.
         */
        REQ("fsetpos.04;fsetpos64.04", "", TODO_REQ());

        /*
         * The fsetpos() function shall return 0 if it succeeds;
         */
        REQ( "fsetpos.06.01;fsetpos64.06.01", "fsetpos() shall return 0", fsetpos_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    ftell, ftello - return a file offset in a stream

SYNOPSIS

    #include <stdio.h>
    long ftell(FILE *stream);
    [CX]  off_t ftello(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The ftell() function shall obtain the current value of the file-position
    indicator for the stream pointed to by stream.

    [CX]  The ftello() function shall be equivalent to ftell(), except that
    the return value is of type off_t.

RETURN VALUE

    Upon successful completion, ftell() [CX]   and ftello()   shall return the
    current value of the file-position indicator for the stream measured in
    bytes from the beginning of the file.

    Otherwise, ftell() [CX]   and ftello()  shall return -1, cast to long and
    off_t respectively, and set errno to indicate the error.

ERRORS

    The ftell() [CX]   and ftello()  functions shall fail if:

        [EBADF]
        [CX]  The file descriptor underlying stream is not an open file
        descriptor.

        [EOVERFLOW]
        [CX]  For ftell(), the current file offset cannot be represented
        correctly in an object of type long.

        [EOVERFLOW]
        [CX]  For ftello(), the current file offset cannot be represented
        correctly in an object of type off_t.

        [ESPIPE]
        [CX]  The file descriptor underlying stream is associated with a
        pipe or FIFO.

    The ftell() function may fail if:

        [ESPIPE]
        [CX]  The file descriptor underlying stream is associated with a
        socket.
*/

//This specification refers to: ftell, ftello, ftello64
specification
OffT ftell_spec( CallContext context, FILETPtr stream, ErrorCode * errno, IntT offsetType )
{
    pre
    {
        return true;
    }
    coverage ftell_coverage = CoverageForFILETPtr( stream ) * CoverageForIntTAsOffsetType( offsetType );
    post
    {
        StreamState * streamState = construct_StreamState( context, stream );
        bool checkResult;
        verbose( "ftell_spec is %d\n", (int)ftell_spec );
        // print_StreamState( streamState, "streamState is " );

        /*
         * Otherwise, ftell() [CX] and ftello() shall return -1, cast to long and off_t
         * respectively, and set errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_FTELL, "ftell.03.02;ftello.03.02;ftello64.ftell.03.02",
                     ftell_spec == -1 && * errno != SUT_EOK, * errno
                   )
            /*
             * The ftell() [CX] and ftello() functions shall fail if:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not an open file
             * descriptor.
             */
            ERROR_SHALL( POSIX_FTELL, EBADF, "ftell.04.01;ftello.04.01;ftello64.ftell.04.01", streamState == NULL )

            /*
             * The ftell() [CX] and ftello() functions shall fail if:
             *
             * [EOVERFLOW] [CX] For ftell(), the current file offset cannot be represented
             * correctly in an object of type long.
             */
            ERROR_SHALL(POSIX_FTELL, EOVERFLOW, "ftell.04.02;ftello.04.02;ftello64.ftell.04.02", TODO_ERR(EOVERFLOW))

            /*
             * The ftell() [CX] and ftello() functions shall fail if:
             *
             * [EOVERFLOW] [CX] For ftello(), the current file offset cannot be represented
             * correctly in an object of type off_t.
             */
            ERROR_SHALL(POSIX_FTELL, EOVERFLOW, "ftell.04.03;ftello.04.03;ftello64.ftell.04.03", TODO_ERR(EOVERFLOW))

            /*
             * The ftell() [CX] and ftello() functions shall fail if:
             *
             * [ESPIPE] [CX] The file descriptor underlying stream is associated with a
             * pipe or FIFO.
             */
            ERROR_SHALL(POSIX_FTELL, ESPIPE, "ftell.04.04;ftello.04.04;ftello64.ftell.04.04", TODO_ERR(ESPIPE))

            /*
             * The ftell() function may fail if:
             *
             * [ESPIPE] [CX] The file descriptor underlying stream is associated with a
             * socket.
             */
            ERROR_MAY(POSIX_FTELL, ESPIPE, "ftell.05.01;ftello.05.01;ftello64.ftell.05.01", TODO_ERR(ESPIPE))
        ERROR_END()

        /*
         * The ftell() function shall obtain the current value of the file-position
         * indicator for the stream pointed to by stream.
         */
        checkResult = ( ftell_spec == getOffset_StreamState( streamState ) );
        REQ( "ftell.01;ftello.01;ftello64.ftell.01", "ftell() shall obtain the file-position", checkResult );

        /*
         * The ftello() function shall be equivalent to ftell(), except that the return
         * value is of type off_t.
         */
        REQ( "ftell.02;ftello.02;ftello64.ftell.02", "ftello() shall be equivalent to ftell(), excepttype off_t", true );

        /*
         * Upon successful completion, ftell() [CX] and ftello() shall return the
         * current value of the file-position indicator for the stream measured in bytes
         * from the beginning of the file.
         */
        REQ( "ftell.03.01;ftello.03.01;ftello64.ftell.03.01", "ftell() and ftello() shall return the file-position",
                                                              checkResult
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    fwrite - binary output

SYNOPSIS

    #include <stdio.h>
    size_t fwrite(const void *restrict ptr, size_t size, size_t nitems,
        FILE *restrict stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The fwrite() function shall write, from the array pointed to by ptr, up to
    nitems elements whose size is specified by size, to the stream pointed to
    by stream. For each object, size calls shall be made to the fputc()
    function, taking the values (in order) from an array of unsigned char
    exactly overlaying the object. The file-position indicator for the stream
    (if defined) shall be advanced by the number of bytes successfully written.
    If an error occurs, the resulting value of the file-position indicator for
    the stream is unspecified.

    [CX]  The st_ctime and st_mtime fields of the file shall be marked for
    update between the successful execution of fwrite() and the next successful
    completion of a call to fflush() or fclose() on the same stream, or a call
    to exit() or abort().

RETURN VALUE

    The fwrite() function shall return the number of elements successfully
    written, which may be less than nitems if a write error is encountered. If
    size or nitems is 0, fwrite() shall return 0 and the state of the stream
    remains unchanged. Otherwise, if a write error occurs, the error indicator
    for the stream shall be set, [CX]   and errno shall be set to indicate the
    error.

ERRORS

    Refer to fputc().
*/
specification
SizeT fwrite_spec( CallContext context, FILETPtr stream, VoidTPtr ptr, SizeT size, SizeT nitems, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage fwrite_coverage = CoverageForFILETPtr( stream ) * CoverageForInteger_Min( size  , 0, SUT_INT_MAX ) *
                                                               CoverageForInteger_Min( nitems, 0, SUT_INT_MAX );
    post
    {
        List /* ByteTObj */ * dataFromPtr = readByteList_VoidTPtr( ptr, size * nitems );
        bool checkResult;
        postStreamState = construct_StreamState( context, stream );
        // verbose( "fwrite_spec is %d\n", (int)fwrite_spec );
        // print_StreamState( preStreamState , "preStreamState is "  );
        // print_StreamState( postStreamState, "postStreamState is " );

        /*
         * Otherwise, if a write error occurs, the error indicator for the stream shall be
         * set, [CX] and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_FWRITE, "fwrite.10", * errno != SUT_EOK, * errno )
            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_FWRITE, EAGAIN, "fwrite.05.01", TODO_ERR(EAGAIN))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL( POSIX_FWRITE, EBADF, "fwrite.05.02", preStreamState == NULL                         ||
                                                              ! isAllowWriting_StreamState( preStreamState )
                       )

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_FWRITE, EFBIG, "fwrite.05.03", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [XSI] An attempt was made to write to a file that exceeds the
             * process' file size limit.
             */
            ERROR_SHALL(POSIX_FWRITE, EFBIG, "fwrite.05.04", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum.
             */
            ERROR_SHALL(POSIX_FWRITE, EFBIG, "fwrite.05.05", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_FWRITE, EINTR, "fwrite.05.06", TODO_ERR(EINTR))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_FWRITE, EIO, "fwrite.05.07", TODO_ERR(EIO))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_FWRITE, ENOSPC, "fwrite.05.08", TODO_ERR(ENOSPC))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_FWRITE, EPIPE, "fwrite.05.09", TODO_ERR(EPIPE))

            /*
             * The fputc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_FWRITE, ENOMEM, "fwrite.06.01", TODO_ERR(ENOMEM))

            /*
             * The fputc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_FWRITE, ENXIO, "fwrite.06.02", TODO_ERR(ENXIO))

            if ( * errno != SUT_EOK ) {
                /*
                 * If an error occurs, the resulting value of the file-position indicator for the
                 * stream is unspecified.
                 */
                REQ("fwrite.04", "", TODO_REQ());

                /*
                 * which may be less than nitems if a write error is encountered.
                 */
                REQ( "fwrite.08.02", "may be less than nitems", fwrite_spec <= nitems );
            }
        ERROR_END()

        if ( size == 0 || nitems == 0 )
        {
            /*
             * If size or nitems is 0, fwrite() shall return 0 and the state of the stream
             * remains unchanged.
             */
            REQ( "fwrite.09", "fwrite() shall return 0 and the state of the stream remains unchanged",
                              T( fwrite_spec == 0 ) && T( isEqualsTo_StreamState( preStreamState, postStreamState ) )
               );
        }
        else
        {
            /*
             * The fwrite() function shall write, from the array pointed to by ptr, up to
             * nitems elements whose size is specified by size, to the stream pointed to by
             * stream.
             */
            setCurrentBytes_StreamState( preStreamState, dataFromPtr );
            checkResult = isEqualsTo_StreamState( preStreamState, postStreamState );
            REQ( "fwrite.01", "fwrite() shall write from the array pointed to by ptr to the stream", checkResult );

            /*
             * For each object, size calls shall be made to the fputc() function, taking the
             * values (in order) from an array of unsigned char exactly overlaying the object.
             */
            REQ("fwrite.02", "", TODO_REQ());

            /*
             * The file-position indicator for the stream (if defined) shall be advanced by
             * the number of bytes successfully written.
             */
            REQ( "fwrite.03", "The file-position indicator for the stream (if defined) shall be advanced", checkResult );

            /*
             * The st_ctime and st_mtime fields of the file shall be marked for update between
             * the successful execution of fwrite() and the next successful completion of a
             * call to fflush() or fclose() on the same stream, or a call to exit() or abort().
             *
             */
            REQ("fwrite.07", "", TODO_REQ());
        }

        /*
         * The fwrite() function shall return the number of elements successfully written,
         */
        REQ( "fwrite.08.01", "fwrite() shall return the number of elements successfully written",
                             fwrite_spec * size == size_List( dataFromPtr )
           );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Single UNIX  Specification, Version 2
Copyright (c) 1997 The Open Group

--------------------------------------------------------------------------------

NAME

    getw - get a word from a stream (LEGACY)

SYNOPSIS

    #include <stdio.h>
    int getw(FILE *stream);

DESCRIPTION

    The getw() function reads the next word from the stream. The size of a word
    is the size of an int and may vary from machine to machine. The getw()
    function presumes no special alignment in the file.

    The getw() function may mark the st_atime field of the file associated with
    stream for update. The st_atime field will be marked for update by the
    first successful execution of fgetc(), fgets(), fread(), getc(), getchar(),
    gets(), fscanf() or scanf() using stream that returns data not supplied by
    a prior call to ungetc().

    This interface need not be reentrant.

RETURN VALUE

    Upon successful completion, getw() returns the next word from the input
    stream pointed to by stream.If the stream is at end-of-file, the
    end-of-file indicator for the stream is set and getw() returns EOF.If a
    read error occurs, the error indicator for the stream is set, getw()
    returns EOF and sets errno to indicate the error.

ERRORS

    Refer to fgetc().
*/
specification
IntT getw_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage getw_coverage = CoverageForFILETPtr( stream );
    post
    {
        postStreamState = construct_StreamState( context, stream );
        verbose( "getw_spec is %d\n", (int)getw_spec );
        print_StreamState( preStreamState , "preStreamState is "  );
        print_StreamState( postStreamState, "postStreamState is " );

        /*
         * If a read error occurs, the error indicator for the stream is set, getw()
         * returns EOF and sets errno to indicate the error.
         */
        ERROR_BEGIN( POSIX_GETW, "getw.05.03", getw_spec == SUT_EOF && * errno != SUT_EOK, * errno )
            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the fgetc() operation.
             */
            ERROR_SHALL(POSIX_GETW, EAGAIN, "getw.08.01", TODO_ERR(EAGAIN))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for reading.
             */
            ERROR_SHALL( POSIX_GETW, EBADF, "getw.08.02", preStreamState == NULL                         ||
                                                          ! isAllowReading_StreamState( preStreamState )
                       )

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EINTR] [CX] The read operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_GETW, EINTR, "getw.08.03", TODO_ERR(EINTR))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is in a
             * background process group attempting to read from its controlling terminal, and
             * either the process is ignoring or blocking the SIGTTIN signal or the process
             * group is orphaned. This error may also be generated for implementation-defined
             * reasons.
             */
            ERROR_SHALL(POSIX_GETW, EIO, "getw.08.04", TODO_ERR(EIO))

            /*
             * The fgetc() function shall fail if data needs to be read and:
             *
             * [EOVERFLOW] [CX] The file is a regular file and an attempt was made to read
             * at or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_GETW, EOVERFLOW, "getw.08.05", TODO_ERR(EOVERFLOW))

            /*
             * The fgetc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_GETW, ENOMEM, "getw.09.01", TODO_ERR(ENOMEM))

            /*
             * The fgetc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_GETW, ENXIO, "getw.09.02", TODO_ERR(ENXIO))
        ERROR_END()

        if ( isEof_StreamState( preStreamState ) )
        {
            /*
             * If the stream is at end-of-file, the end-of-file indicator for the stream is
             * set and getw() returns EOF
             */
            REQ("getw.05.02", "", getw_spec == SUT_EOF );
        }
        else
        {
            /*
             * The getw() function reads the next word from the stream.
             */
            bool checkResult = ( getw_spec == getCurrentWord_StreamState( preStreamState ) );
            REQ( "getw.01", "getw() reads the next word", checkResult );

            /*
             * he size of a word is the size of an int and may vary from machine to machine.
             */
            REQ("getw.02", "", TODO_REQ());

            /*
             * The getw() function presumes no special alignment in the file.
             */
            REQ("getw.03", "", TODO_REQ());

            /*
             * The getw() function may mark the st_atime field of the file associated with
             * stream for update. The st_atime field will be marked for update by the first
             * successful execution of fgetc(), fgets(), fread(), getc(), getchar(), gets(),
             * fscanf() or scanf() using stream that returns data not supplied by a prior call
             * to ungetc().
             */
            REQ( "getw.04", "getw() may mark the st_atime field", true );

            /*
             * Upon successful completion, getw() returns the next word from the input stream
             * pointed to by stream.
             */
            REQ( "getw.05.01", "getw() returns the next word", checkResult );
        }

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    puts - put a string on standard output

SYNOPSIS

    #include <stdio.h>
    int puts(const char *s);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The puts() function shall write the string pointed to by s, followed by a
    <newline>, to the standard output stream stdout. The terminating null byte
    shall not be written.

    [CX]  The st_ctime and st_mtime fields of the file shall be marked for
    update between the successful execution of puts() and the next successful
    completion of a call to fflush() or fclose() on the same stream or a call
    to exit() or abort().

RETURN VALUE

    Upon successful completion, puts() shall return a non-negative number.
    Otherwise, it shall return EOF, shall set an error indicator for the
    stream, [CX]   and errno shall be set to indicate the error.

ERRORS

    Refer to fputc().
*/
specification
IntT puts_spec( CallContext context, CString * s, ErrorCode * errno )
{
    pre
    {
        return true;
    }
    coverage puts_coverage = CoverageForCString( s );
    post
    {
        /*
         * Otherwise, it shall return EOF, shall set an error indicator for the stream, [
         * CX] and errno shall be set to indicate the error.
         */
        ERROR_BEGIN( POSIX_PUTS, "puts.04.02", puts_spec == SUT_EOF && * errno != SUT_EOK, * errno )
            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_PUTS, EAGAIN, "puts.05.01", TODO_ERR(EAGAIN))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL(POSIX_PUTS, EBADF, "puts.05.02", TODO_ERR(EBADF))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_PUTS, EFBIG, "puts.05.03", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [XSI] An attempt was made to write to a file that exceeds the
             * process' file size limit.
             */
            ERROR_SHALL(POSIX_PUTS, EFBIG, "puts.05.04", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum.
             */
            ERROR_SHALL(POSIX_PUTS, EFBIG, "puts.05.05", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_PUTS, EINTR, "puts.05.06", TODO_ERR(EINTR))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_PUTS, EIO, "puts.05.07", TODO_ERR(EIO))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_PUTS, ENOSPC, "puts.05.08", TODO_ERR(ENOSPC))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_PUTS, EPIPE, "puts.05.09", TODO_ERR(EPIPE))

            /*
             * The fputc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_PUTS, ENOMEM, "puts.06.01", TODO_ERR(ENOMEM))

            /*
             * The fputc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_PUTS, ENXIO, "puts.06.02", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * The puts() function shall write the string pointed to by s, followed by a <
         * newline>, to the standard output stream stdout.
         */
        REQ("puts.01", "", TODO_REQ());

        /*
         * The terminating null byte shall not be written.
         */
        REQ("puts.02", "", TODO_REQ());

        /*
         * The st_ctime and st_mtime fields of the file shall be marked for update between
         * the successful execution of puts() and the next successful completion of a call
         * to fflush() or fclose() on the same stream or a call to exit() or abort().
         */
        REQ("puts.03", "", TODO_REQ());

        /*
         * Upon successful completion, puts() shall return a non-negative number.
         */
        REQ( "puts.04.01", "puts() shall return a non-negative number", puts_spec >= 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Single UNIX  Specification, Version 2
Copyright (c) 1997 The Open Group

-------------------------------------------------------------------------------

NAME

    putw - put a word on a stream (LEGACY)

SYNOPSIS

    #include <stdio.h>
    int putw(int w, FILE *stream);

DESCRIPTION

    The putw() function writes the word (that is, type int) w to the output
    stream (at the position at which the file offset, if defined, is pointing).
    The size of a word is the size of a type int and varies from machine to
    machine. The putw() function neither assumes nor causes special alignment
    in the file.

    The st_ctime and st_mtime fields of the file will be marked for update
    between the successful execution of putw() and the next successful
    completion of a call to fflush() or fclose() on the same stream or a call
    to exit() or abort().

    This interface need not be reentrant.

RETURN VALUE

    Upon successful completion, putw() returns 0. Otherwise, a non-zero value
    is returned, the error indicators for the stream are set, and errno is set
    to indicate the error.

ERRORS

    Refer to fputc().
*/
specification
IntT putw_spec( CallContext context, FILETPtr stream, IntT w, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage putw_coverage = CoverageForFILETPtr( stream )                                     *
                             CoverageForInteger_MinMiddleMax( w, SUT_INT_MIN, 0, SUT_INT_MAX );
    post
    {
        postStreamState = construct_StreamState( context, stream );

        /*
         * Otherwise, a non-zero value is returned, the error indicators for the stream
         * are set, and errno is set to indicate the error.
         */
        ERROR_BEGIN( POSIX_PUTW, "putw.05.02", putw_spec != 0 && * errno != SUT_EOK, * errno )
            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor underlying
             * stream and the thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_PUTW, EAGAIN, "putw.fputc.05.01", TODO_ERR(EAGAIN))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EBADF] [CX] The file descriptor underlying stream is not a valid file
             * descriptor open for writing.
             */
            ERROR_SHALL( POSIX_PUTW, EBADF, "putw.fputc.05.02", preStreamState == NULL                         ||
                                                                ! isAllowWriting_StreamState( preStreamState )
                       )

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] An attempt was made to write to a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_PUTW, EFBIG, "putw.fputc.05.03", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [XSI] An attempt was made to write to a file that exceeds the
             * process' file size limit.
             */
            ERROR_SHALL(POSIX_PUTW, EFBIG, "putw.fputc.05.04", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum.
             */
            ERROR_SHALL(POSIX_PUTW, EFBIG, "putw.fputc.05.05", TODO_ERR(EFBIG))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_PUTW, EINTR, "putw.fputc.05.06", TODO_ERR(EINTR))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to write to its controlling terminal,
             * TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU, and the
             * process group of the process is orphaned. This error may also be returned under
             * implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_PUTW, EIO, "putw.fputc.05.07", TODO_ERR(EIO))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_PUTW, ENOSPC, "putw.fputc.05.08", TODO_ERR(ENOSPC))

            /*
             * The fputc() function shall fail if either the stream is unbuffered or the
             * stream's buffer needs to be flushed, and:
             *
             * [EPIPE] [CX] An attempt is made to write to a pipe or FIFO that is not open
             * for reading by any process. A SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_PUTW, EPIPE, "putw.fputc.05.09", TODO_ERR(EPIPE))

            /*
             * The fputc() function may fail if:
             *
             * [ENOMEM] [CX] Insufficient storage space is available.
             */
            ERROR_MAY(POSIX_PUTW, ENOMEM, "putw.fputc.06.01", TODO_ERR(ENOMEM))

            /*
             * The fputc() function may fail if:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_MAY(POSIX_PUTW, ENXIO, "putw.fputc.06.02", TODO_ERR(ENXIO))
        ERROR_END()

        /*
         * The putw() function writes the word (that is, type int) w to the output stream (
         * at the position at which the file offset, if defined, is pointing).
         */
        setCurrentWord_StreamState( preStreamState, w );
        REQ( "putw.01", "putw() writes w to the stream", isEqualsTo_StreamState( preStreamState, postStreamState ) );

        /*
         * The size of a word is the size of a type int and varies from machine to machine.
         */
        REQ("putw.02", "", TODO_REQ());

        /*
         * The putw() function neither assumes nor causes special alignment in the file.
         */
        REQ("putw.03", "", TODO_REQ());

        /*
         * The st_ctime and st_mtime fields of the file will be marked for update between
         * the successful execution of putw() and the next successful completion of a call
         * to fflush() or fclose() on the same stream or a call to exit() or abort().
         */
        REQ("putw.04", "", TODO_REQ());

        /*
         * Upon successful completion, putw() returns 0.
         */
        REQ( "putw.05.01", "putw() returns 0", putw_spec == 0 );

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    rewind - reset the file position indicator in a stream

SYNOPSIS

    #include <stdio.h>
    void rewind(FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The call:

        rewind(stream)

    shall be equivalent to:

        (void) fseek(stream, 0L, SEEK_SET)

    except that rewind() shall also clear the error indicator.

    [CX]  Since rewind() does not return a value, an application wishing to
    detect errors should clear errno, then call rewind(), and if errno is
    non-zero, assume an error has occurred.

RETURN VALUE

    The rewind() function shall not return a value.

ERRORS

    [CX]  Refer to fseek() with the exception of [EINVAL] which does not apply.
*/
specification
void rewind_spec( CallContext context, FILETPtr stream, ErrorCode * errno )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage rewind_coverage = CoverageForFILETPtr( stream );
    post
    {
        bool checkResult;
        postStreamState = construct_StreamState( context, stream );
        // verbose( "rewind_spec\n" );
        // print_StreamState( preStreamState , "preStreamState is "  );
        // print_StreamState( postStreamState, "postStreamState is " );

        /*
         * Since rewind() does not return a value, an application wishing to detect errors
         * should clear errno, then call rewind(), and if errno is non-zero, assume an
         * error has occurred.
         */
        ERROR_BEGIN( POSIX_REWIND, "rewind.03", * errno != SUT_EOK, * errno )
            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EAGAIN] [CX] The O_NONBLOCK flag is set for the file descriptor and the
             * thread would be delayed in the write operation.
             */
            ERROR_SHALL(POSIX_REWIND, EAGAIN, "rewind.fseek.15.01", TODO_ERR(EAGAIN))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EBADF] [CX] The file descriptor underlying the stream file is not open for
             * writing or the stream's buffer needed to be flushed and the file is not open.
             */
            ERROR_SHALL(POSIX_REWIND, EBADF, "rewind.fseek.15.02", TODO_ERR(EBADF))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EFBIG] [CX] An attempt was made to write a file that exceeds the maximum
             * file size.
             */
            ERROR_SHALL(POSIX_REWIND, EFBIG, "rewind.fseek.15.03", TODO_ERR(EFBIG))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EFBIG] [XSI] An attempt was made to write a file that exceeds the process'
             * file size limit.
             */
            ERROR_SHALL(POSIX_REWIND, EFBIG, "rewind.fseek.15.04", TODO_ERR(EFBIG))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EFBIG] [CX] The file is a regular file and an attempt was made to write at
             * or beyond the offset maximum associated with the corresponding stream.
             */
            ERROR_SHALL(POSIX_REWIND, EFBIG, "rewind.fseek.15.05", TODO_ERR(EFBIG))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EINTR] [CX] The write operation was terminated due to the receipt of a
             * signal, and no data was transferred.
             */
            ERROR_SHALL(POSIX_REWIND, EINTR, "rewind.fseek.15.06", TODO_ERR(EINTR))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EIO] [CX] A physical I/O error has occurred, or the process is a member of
             * a background process group attempting to perform a write() to its controlling
             * terminal, TOSTOP is set, the process is neither ignoring nor blocking SIGTTOU,
             * and the process group of the process is orphaned. This error may also be
             * returned under implementation-defined conditions.
             */
            ERROR_SHALL(POSIX_REWIND, EIO, "rewind.fseek.15.08", TODO_ERR(EIO))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [ENOSPC] [CX] There was no free space remaining on the device containing the
             * file.
             */
            ERROR_SHALL(POSIX_REWIND, ENOSPC, "rewind.fseek.15.09", TODO_ERR(ENOSPC))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [ENXIO] [CX] A request was made of a nonexistent device, or the request was
             * outside the capabilities of the device.
             */
            ERROR_SHALL(POSIX_REWIND, ENXIO, "rewind.fseek.15.10", TODO_ERR(ENXIO))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EOVERFLOW] [CX] For fseek(), the resulting file offset would be a value
             * which cannot be represented correctly in an object of type long.
             */
            ERROR_SHALL(POSIX_REWIND, EOVERFLOW, "rewind.fseek.15.11", TODO_ERR(EOVERFLOW))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EOVERFLOW] [CX] For fseeko(), the resulting file offset would be a value
             * which cannot be represented correctly in an object of type off_t.
             */
            ERROR_SHALL(POSIX_REWIND, EOVERFLOW, "rewind.fseek.15.12", TODO_ERR(EOVERFLOW))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [EPIPE] [CX] An attempt was made to write to a pipe or FIFO that is not open
             * for reading by any process; a SIGPIPE signal shall also be sent to the thread.
             */
            ERROR_SHALL(POSIX_REWIND, EPIPE, "rewind.fseek.15.13", TODO_ERR(EPIPE))

            /*
             * The fseek() [CX] and fseeko() functions shall fail if, [CX] either the
             * stream is unbuffered or the stream's buffer needed to be flushed, and the call
             * to fseek() or fseeko() causes an underlying lseek() or write() to be invoked,
             * and:
             *
             * [ESPIPE] [CX] The file descriptor underlying stream is associated with a
             * pipe or FIFO.
             */
            ERROR_SHALL(POSIX_REWIND, ESPIPE, "rewind.fseek.15.14", TODO_ERR(ESPIPE))

            if ( * errno != SUT_EOK )
            {
                /*
                 * If a read or write error occurs, the error indicator for the stream shall be
                 * set and fseek() fails.
                 */
                REQ("rewind.fseek.02", "", TODO_REQ());
            }
        ERROR_END()

        /*
         * The call: rewind(stream)
         *
         * shall be equivalent to: (void) fseek(stream, 0L, SEEK_SET)
         */
        checkResult = ( getOffset_StreamState( postStreamState ) == 0 );
        REQ( "rewind.01", "rewind(stream) shall be equivalent to (void)fseek(stream, 0L, SEEK_SET)", checkResult );

        /*
         * rewind() shall also clear the error indicator.
         */
        REQ("rewind.02", "", TODO_REQ());

        /*
         * The fseek() function shall set the file-position indicator for the stream
         * pointed to by stream.
         */
        REQ( "rewind.fseek.01", "function shall set the file-position indicator for the stream", checkResult );

        /*
         * If the stream is to be used with wide-character input/output functions, the
         * application shall ensure that offset is either 0 or a value returned by an
         * earlier call to ftell() on the same stream and whence is SEEK_SET.
         */
        REQ("rewind.fseek.05", "", TODO_REQ());

        /*
         * A successful call to fseek() shall clear the end-of-file indicator for the
         * stream and undo any effects of ungetc() and ungetwc() on the same stream.
         */
        REQ("rewind.fseek.06", "", TODO_REQ());

        /*
         * After an fseek() call, the next operation on an update stream may be either
         * input or output.
         */
        REQ("rewind.fseek.07", "", TODO_REQ());

        /*
         * If the most recent operation, other than ftell(), on a given stream is fflush(),
         * the file offset in the underlying open file description shall be adjusted to
         * reflect the location specified by fseek().
         */
        REQ("rewind.fseek.08", "", TODO_REQ());

        /*
         * The behavior of fseek() on devices which are incapable of seeking is
         * implementation-defined. The value of the file offset associated with such a
         * device is undefined.
         */
        REQ( "rewind.fseek.11", "The behavior on devices which are incapable of seeking is implementation-defined", true );

        /*
         * If the stream is writable and buffered data had not been written to the
         * underlying file, fseek() shall cause the unwritten data to be written to the
         * file
         */
        REQ("rewind.fseek.12.01", "", TODO_REQ());

        /*
         * and shall mark the st_ctime and st_mtime fields of the file for update.
         */
        REQ("rewind.fseek.12.02", "", TODO_REQ());

        /*
         * In a locale with state-dependent encoding, whether fseek() restores the stream'
         * s shift state is implementation-defined.
         */
        REQ("rewind.fseek.13", "", TODO_REQ());

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    ungetc - push byte back into input stream

SYNOPSIS

    #include <stdio.h>
    int ungetc(int c, FILE *stream);

DESCRIPTION

    [CX]  The functionality described on this reference page is aligned with
    the ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    The ungetc() function shall push the byte specified by c (converted to an
    unsigned char) back onto the input stream pointed to by stream. The
    pushed-back bytes shall be returned by subsequent reads on that stream in
    the reverse order of their pushing. A successful intervening call (with the
    stream pointed to by stream) to a file-positioning function ( fseek(),
    fsetpos(), or rewind()) shall discard any pushed-back bytes for the stream.
    The external storage corresponding to the stream shall be unchanged.

    One byte of push-back shall be provided. If ungetc() is called too many
    times on the same stream without an intervening read or file-positioning
    operation on that stream, the operation may fail.

    If the value of c equals that of the macro EOF, the operation shall fail
    and the input stream shall be left unchanged.

    A successful call to ungetc() shall clear the end-of-file indicator for
    the stream. The value of the file-position indicator for the stream after
    reading or discarding all pushed-back bytes shall be the same as it was
    before the bytes were pushed back. The file-position indicator is
    decremented by each successful call to ungetc(); if its value was 0 before
    a call, its value is unspecified after the call.

RETURN VALUE

    Upon successful completion, ungetc() shall return the byte pushed back
    after conversion. Otherwise, it shall return EOF.

ERRORS

    No errors are defined.
*/
specification
IntT ungetc_spec( CallContext context, FILETPtr stream, IntT c, bool toStdIn )
{
    StreamState * preStreamState ;
    StreamState * postStreamState;

    pre
    {
        preStreamState = construct_StreamState( context, stream );

        return true;
    }
    coverage ungetc_coverage = CoverageForFILETPtr( stream ) * CoverageForIntTAsUCharT( c );
    post
    {
        postStreamState = construct_StreamState( context, stream );

        if ( c == SUT_EOF )
        {
            /*
             * If the value of c equals that of the macro EOF, the operation shall fail and
             * the input stream shall be left unchanged.
             */
            REQ( "ungetc.06", "the operation shall fail and the input stream shall be left unchanged",
                              ungetc_spec == SUT_EOF && isEqualsTo_StreamState( preStreamState, postStreamState )
               );
        }
        else if ( ungetc_spec == SUT_EOF )
        {
            /*
             * Otherwise, it shall return EOF.
             */
            REQ( "ungetc.10.02", "Otherwise, it shall return EOF", ungetc_spec == SUT_EOF );
        }
        else
        {
            /*
             * The ungetc() function shall push the byte specified by c (converted to an
             * unsigned char) back onto the input stream pointed to by stream.
             */
            REQ("ungetc.01", "", TODO_REQ());

            /*
             * The pushed-back bytes shall be returned by subsequent reads on that stream in
             * the reverse order of their pushing.
             */
            REQ("ungetc.02", "", TODO_REQ());

            /*
             * A successful intervening call (with the stream pointed to by stream) to a file-
             * positioning function ( fseek(), fsetpos(), or rewind()) shall discard any
             * pushed-back bytes for the stream.
             */
            REQ("ungetc.03", "", TODO_REQ());

            /*
             * The external storage corresponding to the stream shall be unchanged.
             */
            REQ("ungetc.04", "", TODO_REQ());

            /*
             * One byte of push-back shall be provided.
             */
            REQ("ungetc.05.01", "", TODO_REQ());

            /*
             * If ungetc() is called too many times on the same stream without an intervening
             * read or file-positioning operation on that stream, the operation may fail.
             */
            REQ("ungetc.05.02", "", TODO_REQ());

            /*
             * A successful call to ungetc() shall clear the end-of-file indicator for the
             * stream.
             */
            REQ("ungetc.07", "", TODO_REQ());

            /*
             * The value of the file-position indicator for the stream after reading or
             * discarding all pushed-back bytes shall be the same as it was before the bytes
             * were pushed back.
             */
            REQ("ungetc.08", "", TODO_REQ());

            /*
             * The file-position indicator is decremented by each successful call to ungetc();
             */
            REQ("ungetc.09.01", "", TODO_REQ());

            /*
             * if its value was 0 before a call, its value is unspecified after the call.
             */
            REQ("ungetc.09.02", "", TODO_REQ());

            /*
             * Upon successful completion, ungetc() shall return the byte pushed back after
             * conversion.
             */
            REQ( "ungetc.10.01", "ungetc() shall return the byte pushed back after conversion", ungetc_spec == (UCharT)c );
        }

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

/*
 * call to fileno and create FileDescId
 * can be used in specification and mediator
 */
FileDescId a_fileno( CallContext context, FILETPtr stream ) {
    FileDescId res = { context.system, context.process, -1 };
    TSCommand command = create_TSCommand();
    format_TSCommand( & command, "a_fileno:$(ptr)", create_VoidTPtrObj( stream ) );
    executeCommandInContext( context, & command );
    if ( ! isBadVerdict() ) {
        res.filedesc = readInt_TSStream( & command.response );
                       readInt_TSStream( & command.response ); // unused ErrorCode * errno
    }
    destroy_TSCommand( & command );
    return res;
}

/* some operations with List of ByteTObj */

bool isEquals_ListByteTObj( /* const */ List /* ByteTObj */ * a, /* const */ List /* ByteTObj */ * b ) {
    int i;
    if ( a == NULL ) { return b == NULL; }
    if ( size_List( a ) != size_List( b ) ) { return false; }
    for ( i = 0; i < size_List( a ); i++ ) {
        ByteTObj * byteAObj = get_List( a, i );
        ByteTObj * byteBObj = get_List( b, i );
        if ( * byteAObj != * byteBObj ) { return false; }
    }
    return true;
}

String * toString_ListByteTObj( /* const */ List /* ByteTObj */ * list ) {
    if ( list == NULL ) {
        return  create_String( "NULL" );
    } else {
        int i;
        String * res = valueOfInt_String( size_List( list ) );
        res = concat_String( res, create_String( " : < " ) );
        for ( i = 0; i < size_List( list ); i++ ) {
            ByteTObj * cur = get_List( list, i );
            res = concat_String( res, format_String( "%X", * cur ) );
            if ( i != size_List( list ) - 1 ) { res = concat_String( res, create_String( ", " ) ); }
        } // for i
        res = concat_String( res, create_String( " >" ) );
        return res;
    }
}

void print_ListByteTObj( const char * prefix, /* const */ List /* ByteTObj */ * list ) {
    String * tmp = toString_ListByteTObj( list );
    verbose( "%s%s\n", prefix == NULL ? "" : prefix, toCharArray_String( tmp ) );
}

List /* ByteTObj */ * fromBytes_ListByteTObj( const char * bytesPtr, int n ) {
    List /* ByteTObj */ * res = create_List( & type_ByteTObj );
    int i;
    for ( i = 0; i < n; i++ ) { append_List( res, create_ByteTObj( * ( bytesPtr + i ) ) ); }
    return res;
}

void toBytes_ListByteTObj( /* const */ List /* ByteTObj */ * list, char * bytesPtr, int n ) {
    int i;
    assertion( size_List( list ) == n, "toBytes_ListByteTObj : size_List( list ) is %d, n is %d", size_List( list ), n );
    for ( i = 0; i < n; i++ ) {
        ByteTObj * byteTObj = get_List( list, i );
        * ( bytesPtr + i ) = * byteTObj;
    }
}

// struct StreamLocks

specification typedef struct StreamLocks StreamLocks = {};

/* quasi constructor */
StreamLocks * create_StreamLocks( ThreadIdObj * threadIdObj, int lockCount ) {
    return create( & type_StreamLocks, threadIdObj, lockCount );
}

// static StreamLocks * StreamLocks::construct( const ThreadId * threadIdPtr )
StreamLocks * construct_StreamLocks( const ThreadId * threadIdPtr ) {
    if ( threadIdPtr == NULL ) { return create_StreamLocks( NULL                               , 0 ); }
                               { return create_StreamLocks( create_ThreadIdObj( * threadIdPtr ), 1 ); }
}

// void StreamLocks::increase( void )
void increase_StreamLocks( StreamLocks * thisStreamLocks ) {
    assertion( thisStreamLocks != NULL, "StreamLocks::increase : this is NULL\n" );
    thisStreamLocks->lockCount++;
}

// void StreamLocks::decrease( void )
void decrease_StreamLocks( StreamLocks * thisStreamLocks ) {
    assertion( thisStreamLocks != NULL, "StreamLocks::decrease : this is NULL\n" );
    assertion( thisStreamLocks->lockCount >= 1, "StreamLocks::decrease : lockCount is %d\n", thisStreamLocks->lockCount );
    thisStreamLocks->lockCount--;
    if ( thisStreamLocks->lockCount == 0 ) { thisStreamLocks->threadId = NULL; }
}

// const ThreadIdObj * StreamLocks::locker( void ) const
/* const */ ThreadIdObj * locker_StreamLocks( /* const */ StreamLocks * thisStreamLocks ) {
    assertion( thisStreamLocks != NULL, "StreamLocks::locker : this is NULL\n" );
    return thisStreamLocks->threadId;
}

// int StreamLocks::count( void ) const
int count_StreamLocks( /* const */ StreamLocks * thisStreamLocks ) {
    assertion( thisStreamLocks != NULL, "StreamLocks::count : this is NULL\n" );
    return thisStreamLocks->lockCount;
}

// struct StreamState

specification typedef struct StreamState StreamState = {};

/* quasi constructor */
StreamState * create_StreamState( FILETPtr stream, List /* ByteTObj */ * data, OffT offset,
                                  bool allowRead, bool allowWrite, StreamLocks * lock
                                ) {
    return create( & type_StreamState, stream, data, offset, allowRead, allowWrite, lock );
}

// bool StreamState::isDataEqualsTo( const List /* ByteTObj */ * data ) const
bool isDataEqualsTo_StreamState( /* const */ StreamState * thisStreamState, /* const */ List /* ByteTObj */ * data ) {
    assertion( thisStreamState != NULL, "StreamState::isDataEqualsTo : this is NULL\n" );
    return isEquals_ListByteTObj( thisStreamState->data, data );
}

// String * StreamState::streamAsString( void ) const
String * streamAsString_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::streamAsString : this is NULL\n" );
    return format_String( "<stream>%li, %li, %p</stream>", (long)thisStreamState->stream.system,
                                                           (long)thisStreamState->stream.process,
                                                           thisStreamState->stream.address
                        );
}

// String * StreamState::dataAsString( void ) const
String * dataAsString_StreamState( /* const */ StreamState * thisStreamState ) {
    String * res;
    assertion( thisStreamState != NULL, "StreamState::dataAsString : this is NULL\n" );
    res = create_String( "<data>" );
    res = concat_String( res, toString_ListByteTObj( thisStreamState->data ) );
    res = concat_String( res, create_String( "</data>" ) );
    return res;
}

// bool StreamState::checkForGet( OffT index ) const
bool checkForGet_OffT_StreamState( /* const */ StreamState * thisStreamState, OffT index ) {
    if ( thisStreamState == NULL ) {
        verbose( "StreamState::checkForGet : this is NULL\n" );
        return false;
    } else if ( ! thisStreamState->allowRead ) {
        verbose( "StreamState::checkForGet : allowRead is false\n" );
        return false;
    } else if ( index >= size_StreamState( thisStreamState ) ) {
        verbose
            ( "StreamState::checkForGet : index is %d, size() is %d\n", (int)index, size_StreamState( thisStreamState ) );
        return false;
    } else {
        return true;
    }
}

// bool StreamState::checkForSet( OffT index ) const
bool checkForSet_OffT_StreamState( /* const */ StreamState * thisStreamState, OffT index ) {
    if ( thisStreamState == NULL ) {
        verbose( "StreamState::checkForSet : this is NULL\n" );
        return false;
    } else if ( ! thisStreamState->allowWrite ) {
        verbose( "StreamState::checkForSet : allowWrite is false\n" );
        return false;
    } else if ( index > size_StreamState( thisStreamState ) ) {
        verbose
            ( "StreamState::checkForSet : index is %d, size() is %d\n", (int)index, size_StreamState( thisStreamState ) );
        return false;
    } else {
        return true;
    }
}

// bool StreamState::checkForGet( void ) const
bool checkForGet_StreamState( /* const */ StreamState * thisStreamState ) {
    return checkForGet_OffT_StreamState( thisStreamState, thisStreamState == NULL ? -1 : thisStreamState->offset );
}

// bool StreamState::checkForSet( void ) const
bool checkForSet_StreamState( /* const */ StreamState * thisStreamState ) {
    return checkForSet_OffT_StreamState( thisStreamState, thisStreamState == NULL ? -1 : thisStreamState->offset );
}

// ByteT StreamState::getByte( OffT index ) const
ByteT getByte_StreamState( /* const */ StreamState * thisStreamState, OffT index ) {
    ByteTObj * byteTObj;
    assertion( checkForGet_OffT_StreamState( thisStreamState, index ), "StreamState::getByte : checkForGet() is false\n" );
    byteTObj = get_List( thisStreamState->data, index );
    return * byteTObj;
}

// void StreamState::setByte( OffT index, ByteT byte )
void setByte_StreamState( StreamState * thisStreamState, OffT index, ByteT byte ) {
    assertion( checkForSet_OffT_StreamState( thisStreamState, index ), "StreamState::setByte : checkForSet() is false\n" );
    if ( index == size_StreamState( thisStreamState ) ) {
        // error in set_List
        append_List( thisStreamState->data, create_ByteTObj( byte ) );
    } else {
        set_List( thisStreamState->data, index, create_ByteTObj( byte ) );
    }
}

// List /* ByteTObj */ * StreamState::getBytes( OffT index, IntT n ) const
List /* ByteTObj */ * getBytes_StreamState( /* const */ StreamState * thisStreamState, OffT index, IntT n ) {
    List * res = create_List( & type_ByteTObj );
    int i;
    assertion
        ( checkForGet_OffT_StreamState( thisStreamState, index ), "StreamState::getBytes : checkForGet() is false\n" );
    assertion( index + n - 1 < size_StreamState( thisStreamState ),
               "StreamState::getBytes : index is %d, n is %d, size() is %d\n",
               (int)index, (int)n, size_StreamState( thisStreamState )
             );
    for ( i = 0; i < n; i++ ) { append_List( res, create_ByteTObj( getByte_StreamState( thisStreamState, index + i ) ) ); }
    return res;
}

// void StreamState::setBytes( OffT index, const List /* ByteTObj */ * bytes )
void setBytes_StreamState( StreamState * thisStreamState, OffT index, /* const */ List /* ByteTObj */ * bytes ) {
    int i;
    assertion
        ( checkForSet_OffT_StreamState( thisStreamState, index ), "StreamState::setBytes : checkForSet() is false\n" );
    for ( i = 0; i < size_List( bytes ); i++ ) {
        ByteTObj * byteTObj = get_List( bytes, i );
        setByte_StreamState( thisStreamState, index + i, * byteTObj );
    }
}

// CharT StreamState::getChar( OffT index ) const
CharT getChar_StreamState( /* const */ StreamState * thisStreamState, OffT index ) {
    assertion( sizeof( CharT ) == sizeof( ByteT ), "StreamState::getChar : sizeof( CharT ) != sizeof( ByteT )\n" );
    assertion( checkForGet_OffT_StreamState( thisStreamState, index ), "StreamState::getChar : checkForGet() is false\n" );
    return getByte_StreamState( thisStreamState, index );
}

// void StreamState::setChar( OffT index, CharT c )
void setChar_StreamState( StreamState * thisStreamState, OffT index, CharT c ) {
    assertion( sizeof( CharT ) == sizeof( ByteT ), "StreamState::setChar : sizeof( CharT ) != sizeof( ByteT )\n" );
    assertion( checkForSet_OffT_StreamState( thisStreamState, index ), "StreamState::setChar : checkForSet() is false\n" );
    setByte_StreamState( thisStreamState, index, c );
}

// WCharT StreamState::getWChar( OffT index ) const
WCharT getWChar_StreamState( /* const */ StreamState * thisStreamState, OffT index ) {
    WCharT res;
    List /* ByteTObj */ * byteList;
    assertion
        ( checkForGet_OffT_StreamState( thisStreamState, index ), "StreamState::getWChar : checkForGet() is false\n" );
    byteList = getBytes_StreamState( thisStreamState, index, sizeof( WCharT ) );
    toBytes_ListByteTObj( byteList, (char *)& res, sizeof( WCharT ) );
    return res;
}

// void StreamState::setWChar( OffT index, WCharT wc )
void setWChar_StreamState( /* const */ StreamState * thisStreamState, OffT index, WCharT wc ) {
    List /* ByteTObj */ * byteList = fromBytes_ListByteTObj( (char *)& wc, sizeof( WCharT ) );
    assertion
        ( checkForSet_OffT_StreamState( thisStreamState, index ), "StreamState::setWChar : checkForSet() is false\n" );
    setBytes_StreamState( thisStreamState, index, byteList );
}

// static StreamState * StreamState::construct( CallContext context, FILETPtr stream )
StreamState * construct_StreamState( CallContext context, FILETPtr stream ) {
    FileDescId fileId;
    RegularFileDescriptor * descr;
    File                  * file ;
    FileDescriptor        * fdesc;
    List /* ByteTObj */ * data = create_List( & type_ByteTObj );
    OffT i;
    AccessMode accessMode;
    bool allowRead ;
    bool allowWrite;
    StreamLocks * lock;
    if ( isNULL_VoidTPtr( stream ) ) { return NULL; }
    fileId = a_fileno( context, stream );
    if ( fileId.filedesc == -1 ) { return NULL; }
    descr = getDescriptor_FileDescId( fileId );
    file  = getFile_FileDescId      ( fileId );
    fdesc = getFileDescriptor       ( fileId );
    if ( descr == NULL || file == NULL || fdesc == NULL ) { return NULL; }
    if ( file->size != NULL ) { // consider file->size == NULL as * file->size == 0
        for ( i = 0; i < * file->size; i++ ) {
            IntTObj * found = create_IntTObj( 0 );
            ByteT curByte = getByteAtPos( descr->dataChunks, i, found );
            if ( equals( found, create_IntTObj( false ) ) ) { return NULL; }
            append_List( data, create_ByteTObj( curByte ) );
        }
    }
    accessMode = fdesc->description->access_mode;
    allowRead  = ( accessMode == ReadWrite || accessMode == ReadOnly  );
    allowWrite = ( accessMode == ReadWrite || accessMode == WriteOnly );
    lock = construct_StreamLocks( NULL );
    return create_StreamState( stream, data, fdesc->offset, allowRead, allowWrite, lock );
} // StreamState::construct

// bool StreamState::isEqualsTo( const StreamState * streamState ) const
bool isEqualsTo_StreamState( /* const */ StreamState * thisStreamState, /* const */ StreamState * streamState ) {
    assertion( thisStreamState != NULL, "StreamState::isEqualsTo : this is NULL\n" );
    return equals_VoidTPtr( thisStreamState->stream, streamState->stream )  &&
           isDataEqualsTo_StreamState( thisStreamState, streamState->data ) &&
           thisStreamState->offset     == streamState->offset               &&
           thisStreamState->allowRead  == streamState->allowRead            &&
           thisStreamState->allowWrite == streamState->allowWrite           ;
}

// String * StreamState::toString( void ) const
String * toString_StreamState( /* const */ StreamState * thisStreamState ) {
    String * streamAsString;
    String * dataAsString  ;
    String * res;
    assertion( thisStreamState != NULL, "StreamState::toString : this is NULL\n" );
    streamAsString = streamAsString_StreamState( thisStreamState );
    dataAsString   = dataAsString_StreamState  ( thisStreamState );
    res = create_String( "<StreamState>\n" );
    res = concat_String( res, format_String( "    %s\n", toCharArray_String( streamAsString ) ) );
    res = concat_String( res, format_String( "    %s\n", toCharArray_String( dataAsString   ) ) );
    res = concat_String( res, format_String( "    <offset>%li</offset>\n", (long)thisStreamState->offset ) );
    res = concat_String
              ( res, format_String( "    <allowRead>%s</allowRead>\n", thisStreamState->allowRead ? "true" : "false" ) );
    res = concat_String( res, format_String
                                  ( "    <allowWrite>%s</allowWrite>\n", thisStreamState->allowWrite ? "true" : "false" )
                       );
    res = concat_String( res, create_String( "</StreamState>" ) );
    return res;
}

// void StreamState::print( const char * prefix ) const
void print_StreamState( /* const */ StreamState * thisStreamState, const char * prefix ) {
    String * tmp;
    assertion( thisStreamState != NULL, "StreamState::print : this is NULL\n" );
    tmp = toString_StreamState( thisStreamState );
    verbose( "%s%s\n", prefix == NULL ? "" : prefix, toCharArray_String( tmp ) );
}

// bool StreamState::size( void ) const
int size_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::size : this is NULL\n" );
    if ( thisStreamState->data == NULL ) { return -1                                ; }
                                    else { return size_List( thisStreamState->data ); }
}

// bool StreamState::isEof( void ) const
bool isEof_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::isEof : this is NULL\n" );
    assertion( thisStreamState->offset <= size_StreamState( thisStreamState ),
               "StreamState::isEof : offset is %d, size() is %d\n",
               (int)thisStreamState->offset, size_StreamState( thisStreamState )
             );
    return size_StreamState( thisStreamState ) == thisStreamState->offset;
}

// OffT StreamState::getOffset( void ) const
OffT getOffset_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::getOffset : this is NULL\n" );
    return thisStreamState->offset;
}

// bool StreamState::isAllowReading( void ) const
bool isAllowReading_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::isAllowReading : this is NULL\n" );
    return thisStreamState->allowRead;
}

// bool StreamState::isAllowWriting( void ) const
bool isAllowWriting_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::isAllowWriting : this is NULL\n" );
    return thisStreamState->allowWrite;
}

// CharT StreamState::getCurrentChar( void ) const
CharT getCurrentChar_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( checkForGet_StreamState( thisStreamState ), "StreamState::getCurrentChar : checkForGet() is false\n" );
    return getChar_StreamState( thisStreamState, thisStreamState->offset );
}

// void StreamState::setCurrentChar( CharT c )
void setCurrentChar_StreamState( StreamState * thisStreamState, CharT c ) {
    assertion( checkForSet_StreamState( thisStreamState ), "StreamState::setCurrentChar : checkForSet() is false\n" );
    setChar_StreamState( thisStreamState, thisStreamState->offset, c );
    thisStreamState->offset += sizeof( CharT );
}

// WCharT StreamState::getCurrentWChar( void ) const
WCharT getCurrentWChar_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( checkForGet_StreamState( thisStreamState ), "StreamState::getCurrentWChar : checkForGet() is false\n" );
    return getWChar_StreamState( thisStreamState, thisStreamState->offset );
}

// void StreamState::setCurrentWChar( WCharT wc )
void setCurrentWChar_StreamState( /* const */ StreamState * thisStreamState, WCharT wc ) {
    assertion( checkForSet_StreamState( thisStreamState ), "StreamState::setCurrentWChar : checkForSet() is false\n" );
    setWChar_StreamState( thisStreamState, thisStreamState->offset, wc );
    thisStreamState->offset += sizeof( WCharT );
}

// CString * StreamState::getCurrentString( IntT n ) const
CString * getCurrentString_StreamState( /* const */ StreamState * thisStreamState, IntT n ) {
    CString * res = create_CString( "" );
    int i;
    assertion( checkForGet_StreamState( thisStreamState ), "StreamState::getCurrentString : checkForGet() is false\n" );
    for ( i = 0; i < n - 1 && thisStreamState->offset + i * sizeof( CharT ) < size_StreamState( thisStreamState ); i++ ) {
        CharT c = getChar_StreamState( thisStreamState, thisStreamState->offset + i * sizeof( CharT ) );
        res = concat_CString( res, valueOfCharC_String( c ) );
        if ( c == '\n' ) { break; }
    }
	return res;
}

// void StreamState::setCurrentString( const CString * s )
void setCurrentString_StreamState( StreamState * thisStreamState, /* const */ CString * s ) {
    int i;
    assertion( checkForSet_StreamState( thisStreamState ), "StreamState::setCurrentString : checkForSet() is false\n" );
    for ( i = 0; i < length_CString( s ); i++ ) {
        setChar_StreamState( thisStreamState, thisStreamState->offset + i * sizeof( CharT ), charAt_CString( s, i ) );
    }
    thisStreamState->offset += length_CString( s ) * sizeof( CharT );
}

// WString * StreamState::getCurrentWString( IntT n ) const
WString * getCurrentWString_StreamState( /* const */ StreamState * thisStreamState, IntT n ) {
    WString * res = createW_String( "" );
    int i;
    assertion( checkForGet_StreamState( thisStreamState ), "StreamState::getCurrentWString : checkForGet() is false\n" );
    for ( i = 0; i < n - 1 && thisStreamState->offset + i * sizeof( WCharT ) < size_StreamState( thisStreamState ); i++ ) {
        WCharT wc = getWChar_StreamState( thisStreamState, thisStreamState->offset + i * sizeof( WCharT ) );
        res = concat_WString( res, valueOfWCharW_String( wc ) );
        if ( wc == '\n' ) { break; } // ???
    }
    return res;
}

// void StreamState::setCurrentWString( const WString * ws )
void setCurrentWString_StreamState( StreamState * thisStreamState, /* const */ WString * ws ) {
    int i;
    assertion( checkForSet_StreamState( thisStreamState ), "StreamState::setCurrentWString : checkForSet() is false\n" );
    for ( i = 0; i < length_WString( ws ); i++ ) {
        setWChar_StreamState( thisStreamState, thisStreamState->offset + i * sizeof( WCharT ), wcharAt_WString( ws, i ) );
    }
    thisStreamState->offset += length_WString( ws ) * sizeof( WCharT );
}

// List /* ByteTObj */ * StreamState::getCurrentBytes( IntT n ) const
List /* ByteTObj */ * getCurrentBytes_StreamState( /* const */ StreamState * thisStreamState, IntT n ) {
    int unreadBytes;
    assertion( checkForGet_StreamState( thisStreamState ), "StreamState::getCurrentBytes : checkForGet() is false\n" );
    unreadBytes = size_StreamState( thisStreamState ) - thisStreamState->offset;
    return getBytes_StreamState( thisStreamState, thisStreamState->offset, n <= unreadBytes ? n : unreadBytes );
}

// void StreamState::setCurrentBytes( const List /* ByteTObj */ * bytes )
void setCurrentBytes_StreamState( StreamState * thisStreamState, /* const */ List /* ByteTObj */ * bytes ) {
    int i;
    assertion( checkForSet_StreamState( thisStreamState ), "StreamState::setCurrentBytes : checkForSet() is false\n" );
    setBytes_StreamState( thisStreamState, thisStreamState->offset, bytes );
    thisStreamState->offset += size_List( bytes );
}

// IntT StreamState::getCurrentWord( void ) const
IntT getCurrentWord_StreamState( /* const */ StreamState * thisStreamState ) {
    IntT res;
    List /* ByteTObj */ * byteList;
    assertion( checkForGet_StreamState( thisStreamState ), "StreamState::getCurrentWord : checkForGet() is false\n" );
    byteList = getCurrentBytes_StreamState( thisStreamState, sizeof( IntT ) );
    toBytes_ListByteTObj( byteList, (char *)& res, sizeof( IntT ) );
    return res;
}

// void StreamState::setCurrentWord( IntT word )
void setCurrentWord_StreamState( StreamState * thisStreamState, IntT word ) {
    List /* ByteTObj */ * byteList = fromBytes_ListByteTObj( (char *)& word, sizeof( IntT ) );
    assertion( checkForSet_StreamState( thisStreamState ), "StreamState::setCurrentWord : checkForSet() is false\n" );
    setCurrentBytes_StreamState( thisStreamState, byteList );
}

// void StreamState::lock( const ThreadId * threadIdPtr )
void lock_StreamState( StreamState * thisStreamState, const ThreadId * threadIdPtr ) {
    assertion( thisStreamState != NULL, "StreamState::lock : this is NULL\n" );
    if ( locker_StreamState( thisStreamState ) == NULL ) {
        thisStreamState->lock = construct_StreamLocks( threadIdPtr );
    } else {
        assertion( equals( locker_StreamState( thisStreamState ), create_ThreadIdObj( * threadIdPtr ) ),
                   "StreamState::lock : not equals( locker(), create_ThreadIdObj( * threadIdPtr ) )\n"
                 );
        increase_StreamLocks( thisStreamState->lock );
    }
}

// void StreamState::unlock( const ThreadId * threadIdPtr )
void unlock_StreamState( StreamState * thisStreamState, const ThreadId * threadIdPtr ) {
    assertion( thisStreamState != NULL, "StreamState::unlock : this is NULL\n" );
    assertion( equals( locker_StreamState( thisStreamState ), create_ThreadIdObj( * threadIdPtr ) ),
               "StreamState::unlock : not equals( locker(), create_ThreadIdObj( * threadIdPtr ) )\n"
             );
    decrease_StreamLocks( thisStreamState->lock );
}

// const ThreadIdObj * StreamState::locker( void ) const
/* const */ ThreadIdObj * locker_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::locker : this is NULL\n" );
    return locker_StreamLocks( thisStreamState->lock );
}

// int StreamState::lockCount( void ) const
int lockCount_StreamState( /* const */ StreamState * thisStreamState ) {
    assertion( thisStreamState != NULL, "StreamState::lockCount : this is NULL\n" );
    return count_StreamLocks( thisStreamState->lock );
}

// Functions

/* convert mode to OpenFlags */
enum FileModeCode { rCode, wCode, aCode, rpCode, wpCode, apCode };

OpenFlags convertToOflag( CString * mode ) {
    OpenFlags res;
    enum FileModeCode modeCode;
    if      ( equalsToCreatedFrom2C_String( mode, "r" , "rb"         ) ) { modeCode = rCode ; }
    else if ( equalsToCreatedFrom2C_String( mode, "w" , "wb"         ) ) { modeCode = wCode ; }
    else if ( equalsToCreatedFrom2C_String( mode, "a" , "ab"         ) ) { modeCode = aCode ; }
    else if ( equalsToCreatedFrom3C_String( mode, "r+", "rb+", "r+b" ) ) { modeCode = rpCode; }
    else if ( equalsToCreatedFrom3C_String( mode, "w+", "wb+", "w+b" ) ) { modeCode = wpCode; }
    else if ( equalsToCreatedFrom3C_String( mode, "a+", "ab+", "a+b" ) ) { modeCode = apCode; }
    else {
        assertion( false, "convertToOflag : unknown mode" );
    }
    switch ( modeCode ) {
        case rCode : res.access_mode = ReadOnly ; res.append = false; res.creat = false; res.trunc = false; break;
        case wCode : res.access_mode = WriteOnly; res.append = false; res.creat = true ; res.trunc = true ; break;
        case aCode : res.access_mode = WriteOnly; res.append = true ; res.creat = true ; res.trunc = false; break;
        case rpCode: res.access_mode = ReadWrite; res.append = false; res.creat = false; res.trunc = false; break;
        case wpCode: res.access_mode = ReadWrite; res.append = false; res.creat = true ; res.trunc = true ; break;
        case apCode: res.access_mode = ReadWrite; res.append = true ; res.creat = true ; res.trunc = false; break;
    }
    res.block_mode = Blocking;
    res.excl       = false   ;
    res.noctty     = false   ;
    res.large_file = false   ;
    return res;
} // convertToOflag

/* get current permissions for file creation */
FilePermissions * currentFilePerm( CallContext context ) {
    FilePermission * owner = create_FilePermission( true, true, false );
    FilePermission * group = create_FilePermission( true, true, false );
    FilePermission * other = create_FilePermission( true, true, false );
    FilePermissions * perms = create_FilePermissions( owner, group, other, Unknown_Bool3, Unknown_Bool3, Unknown_Bool3 );
    return perms;
}

/* used in fdopen, freopen */
void applyModeToFile( FileDescId fildes, CString * mode ) {
    FileDescriptor * fdesc;
    FileDescription * description;
    OpenFlags oflags;
    assertion( ! isWrong_FileDescId( fildes ), "applyModeToFile : wrong fildes " );
    fdesc = getFileDescriptor( fildes );
    description = fdesc->description;
    oflags = convertToOflag( mode );
    description->access_mode = oflags.access_mode;
    if ( oflags.append ) {
        File * file = getFile_FileDescId( fildes );
        fdesc->offset = * file->size;
    }
}

void onFputc( CallContext context, FILETPtr stream, IntT c ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, 1 );
    assertion( writeChar_VoidTPtr( buf, c ), "onFputc : writeChar_VoidTPtr" );
    onWrite( context, fileId, buf, 1, 1 );
    deallocateMemoryBlock( context, buf );
}

void onFputs( CallContext context, FILETPtr stream, CString * s ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, length_CString( s ) + 1 );
    assertion( writeCString_VoidTPtr( buf, s ), "onFputs : writeCString_VoidTPtr" );
    onWrite( context, fileId, buf, length_CString( s ), length_CString( s ) );
    deallocateMemoryBlock( context, buf );
}

void onFgetc( CallContext context, FILETPtr stream, IntT c ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, 1 );
    assertion( writeChar_VoidTPtr( buf, c ), "onFgetc : writeChar_VoidTPtr" );
    onRead( context, fileId, buf, 1, 1 );
    deallocateMemoryBlock( context, buf );
}

void onFgets( CallContext context, FILETPtr stream, CString * s ) {
    FileDescId fileId = a_fileno( context, stream );
    VoidTPtr buf = allocateMemoryBlock( context, length_CString( s ) + 1 );
    assertion( writeCString_VoidTPtr( buf, s ), "onFgets : writeCString_VoidTPtr" );
    onRead( context, fileId, buf, length_CString( s ), length_CString( s ) );
    deallocateMemoryBlock( context, buf );
}
