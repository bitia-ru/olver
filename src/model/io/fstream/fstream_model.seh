/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef IO_FSTREAM_MODEL_SEH
#define IO_FSTREAM_MODEL_SEH

#include "common/common_model.seh"
#include "data/sys/types_model.seh"
#include "io/file/file_model.seh"

typedef VoidTPtr FILETPtr;

specification typedef FILETPtr FILETPtrObj;

FILETPtrObj * create_FILETPtrObj( FILETPtr ptr );

specification typedef struct FILET { FILETPtr   address;
                                     FileDescId fileId ;
                                   } FILET;

FILET * create_FILET( FILETPtr address, FileDescId fileId );

FILET * getFILET( FILETPtr address );

typedef VoidTPtr FPosTPtr;
typedef enum FseekOffsetType
{
        LongType,
        OffType,
        Off64Type
} FseekOffsetType;

typedef enum GetcPutcFunctionType { F_Type    , F_Unlocked_Type    ,
                                    Macro_Type, Macro_Unlocked_Type,
                                    Char_Type , Char_Unlocked_Type
                                  } GetcPutcFunctionType;

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/** _IO_feof_spec **/
specification
IntT _IO_feof_spec( CallContext context, FILETPtr __fp );

/** _IO_getc_spec **/
specification
IntT _IO_getc_spec( CallContext context, FILETPtr __fp );

/** _IO_putc_spec **/
specification
IntT _IO_putc_spec( CallContext context, IntT __c, FILETPtr __fp );

/** _IO_puts_spec **/
specification
IntT _IO_puts_spec( CallContext context, CString * __c );

/** __fpending_spec **/
specification
SizeT __fpending_spec( CallContext context, FILETPtr stream );

/** clearerr_spec **/
specification
void clearerr_spec( CallContext context, FILETPtr stream );

/** fclose_spec **/
specification
IntT fclose_spec( CallContext context, FILETPtr stream, ErrorCode * errno );

/** fdopen_spec **/
specification
FILETPtr fdopen_spec( CallContext context, FileDescId fildes, CString * mode, ErrorCode * errno );

/** feof_spec **/
specification
IntT feof_spec( CallContext context, FILETPtr stream );

/** ferror_spec **/
specification
IntT ferror_spec( CallContext context, FILETPtr stream );

/** fflush_spec **/
//This specification refers to: fflush, fflush_unlocked
specification
IntT fflush_spec( CallContext context, FILETPtr stream, ErrorCode * errno, bool unlocked );

/** fgetc_spec **/
//This specification refers to: fgetc, getc, getchar, getchar_unlocked, getc_unlocked
specification
IntT fgetc_spec( CallContext context, FILETPtr stream, ErrorCode * errno,
                 IntT getc_type, CString * input, CString * stdinAsFile
               );

/** fgetpos_spec **/
//This specification refers to: fgetpos, fgetpos64
specification
IntT fgetpos_spec( CallContext context, FILETPtr stream, FPosTPtr pos, ErrorCode * errno, bool is64bits );

/** fgets_spec **/
specification
CString * fgets_spec( CallContext context, IntT n, FILETPtr stream, ErrorCode * errno );

/** fgetwc_unlocked_spec **/
//specification
//ReturnType fgetwc_unlocked_spec( CallContext context, ... );

/** fileno_spec **/
specification
IntT fileno_spec( CallContext context, FILETPtr stream, ErrorCode * errno );

/** fopen_spec **/
//This specification refers to: fopen, fopen64
specification
FILETPtr fopen_spec( CallContext context, CString * filename, CString * mode, ErrorCode * errno, bool is64bits );

/** fputc_spec **/
//This specification refers to: fputc, putc, putc_unlocked, putchar, putchar_unlocked
specification
IntT fputc_spec( CallContext context, IntT c, FILETPtr stream, ErrorCode * errno, IntT putc_type );

/** fputs_spec **/
specification
IntT fputs_spec( CallContext context, CString * s, FILETPtr stream, ErrorCode * errno );

/** fread_spec **/
specification
SizeT fread_spec( CallContext context, VoidTPtr ptr, SizeT size, SizeT nitems, FILETPtr stream, ErrorCode * errno );

/** freopen_spec **/
//This specification refers to: freopen, freopen64
specification
FILETPtr freopen_spec( CallContext context,
                       CString * filename, CString * mode, FILETPtr stream, ErrorCode * errno, bool is64bits
                     );

/** fseek_spec **/
//This specification refers to: fseek, fseeko, fseeko64
specification
IntT fseek_spec( CallContext context, FILETPtr stream, OffT offset, IntT whence, IntT offsetType, ErrorCode * errno );

/** fsetpos_spec **/
//This specification refers to: fsetpos, fsetpos64
specification
IntT fsetpos_spec( CallContext context, FILETPtr stream, FPosTPtr pos, bool is64bits, ErrorCode * errno );

/** ftell_spec **/
//This specification refers to: ftell, ftello, ftello64
specification
OffT ftell_spec( CallContext context, FILETPtr stream, ErrorCode * errno, IntT offsetType );

/** fwrite_spec **/
specification
SizeT fwrite_spec( CallContext context, FILETPtr stream, VoidTPtr ptr, SizeT size, SizeT nitems, ErrorCode * errno );

/** getw_spec **/
specification
IntT getw_spec( CallContext context, FILETPtr stream, ErrorCode * errno );

/** puts_spec **/
specification
IntT puts_spec( CallContext context, CString * s, ErrorCode * errno );

/** putw_spec **/
specification
IntT putw_spec( CallContext context, FILETPtr stream, IntT w, ErrorCode * errno );

/** rewind_spec **/
specification
void rewind_spec( CallContext context, FILETPtr stream, ErrorCode * errno );

/** ungetc_spec **/
specification
IntT ungetc_spec( CallContext context, FILETPtr stream, IntT c, bool toStdIn );

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

/*
 * call to fileno and create FileDescId
 * can be used in specification and mediator
 */
FileDescId a_fileno( CallContext context, FILETPtr stream );

/********************************************************************/
/**                          Stream State                          **/
/********************************************************************/

specification typedef struct StreamLocks { // private:
    ThreadIdObj * threadId;
    int lockCount;
#if 0 // for avoid too many "// "
public:
    static StreamLocks * construct( const ThreadId * threadIdPtr );
    void increase( void );
    void decrease( void );
    const ThreadIdObj * locker( void ) const;
    int count( void ) const;
#endif // 0 for avoid too many "// "
} StreamLocks;

/* quasi constructor */
StreamLocks * create_StreamLocks( ThreadIdObj * threadIdObj, int lockCount );
StreamLocks * construct_StreamLocks( const ThreadId * threadIdPtr );
void increase_StreamLocks( StreamLocks * thisStreamLocks );
void decrease_StreamLocks( StreamLocks * thisStreamLocks );
/* const */ ThreadIdObj * locker_StreamLocks( /* const */ StreamLocks * thisStreamLocks );
int count_StreamLocks( /* const */ StreamLocks * thisStreamLocks );

/* some operations with List of ByteTObj */
bool isEquals_ListByteTObj( /* const */ List /* ByteTObj */ * a, /* const */ List /* ByteTObj */ * b );
String * toString_ListByteTObj( /* const */ List /* ByteTObj */ * list );
void print_ListByteTObj( const char * prefix, /* const */ List /* ByteTObj */ * list );
List /* ByteTObj */ * fromBytes_ListByteTObj( const char * bytesPtr, int n );
void toBytes_ListByteTObj( /* const */ List /* ByteTObj */ * list, char * bytesPtr, int n );

/*
 * stream state
 * (cpp style)
 */
specification typedef struct StreamState { // private:
    FILETPtr              stream    ;
    List /* ByteTObj */ * data      ;
    OffT                  offset    ;
    bool                  allowRead ;
    bool                  allowWrite;
    StreamLocks         * lock      ;
#if 0 // for avoid too many "// "
    StreamState();
    StreamState * create_StreamState( FILETPtr stream, List /* ByteTObj */ * data, OffT offset,
                                      bool allowRead, bool allowWrite, StreamLocks * lock
                                    );
    bool isDataEqualsTo( const List /* ByteTObj */ * data ) const;
    String * streamAsString( void ) const;
    String * dataAsString( void ) const;
    bool checkForGet( OffT index ) const;
    bool checkForSet( OffT index ) const;
    bool checkForGet( void ) const;
    bool checkForSet( void ) const;
    // get, set for byte and bytes
    ByteT getByte( OffT index ) const;
    void setByte( OffT index, ByteT byte );
    List /* ByteTObj */ * getBytes( OffT index, IntT n ) const;
    void setBytes( OffT index, const List /* ByteTObj */ * bytes );
    // get, set for char and wchar_t
    CharT getChar( OffT index ) const;
    void setChar( OffT index, CharT c );
    WCharT getWChar( OffT index ) const;
    void setWChar( OffT index, WCharT wc );
public:
    static StreamState * construct( CallContext context, FILETPtr stream );
    bool isEqualsTo( const StreamState * streamState ) const;
    String * toString( void ) const;
    void print( const char * prefix ) const;
    int size( void ) const;
    bool isEof( void ) const;
    OffT getOffset( void ) const;
    bool isAllowReading( void ) const;
    bool isAllowWriting( void ) const;
    // get, set for current char and wchar_t
    CharT getCurrentChar( void ) const; // return char at offset
    void setCurrentChar( CharT c );
    WCharT getCurrentWChar( void ) const; // return wchar_t at offset
    void setCurrentWChar( WCharT wc );
    // get, set for current string and wide-string
    CString * getCurrentString( IntT n ) const; // return n chars from offset to newline (included) or end as string
    void setCurrentString( const CString * s );
    WString * getCurrentWString( IntT n ) const; // return n bytes from offset to newline (included) or end as string
    void setCurrentWString( const WString * ws );
    // get, set for current bytes
    List /* ByteTObj */ * getCurrentBytes( IntT n ) const; // return n bytes from offset to end
    void setCurrentBytes( const List /* ByteTObj */ * bytes );
    // get, set for word
    IntT getCurrentWord( void ) const; // return word at offset
    void setCurrentWord( IntT word );
    // lock, unlock
    void lock( const ThreadId * threadIdPtr );
    void unlock( const ThreadId * threadIdPtr );
    const ThreadIdObj * locker( void ) const;
    int lockCount( void ) const;
#endif // 0 for avoid too many "// "
} StreamState;

/* quasi constructor */
StreamState * create_StreamState( FILETPtr stream, List /* ByteTObj */ * data, OffT offset,
                                  bool allowRead, bool allowWrite, StreamLocks * lock
                                );
bool isDataEqualsTo_StreamState( /* const */ StreamState * thisStreamState, /* const */ List /* ByteTObj */ * data );
String * streamAsString_StreamState( /* const */ StreamState * thisStreamState );
String * dataAsString_StreamState( /* const */ StreamState * thisStreamState );
bool checkForGet_OffT_StreamState( /* const */ StreamState * thisStreamState, OffT index );
bool checkForSet_OffT_StreamState( /* const */ StreamState * thisStreamState, OffT index );
bool checkForGet_StreamState( /* const */ StreamState * thisStreamState );
bool checkForSet_StreamState( /* const */ StreamState * thisStreamState );
ByteT getByte_StreamState( /* const */ StreamState * thisStreamState, OffT index );
void setByte_StreamState( StreamState * thisStreamState, OffT index, ByteT byte );
List /* ByteTObj */ * getBytes_StreamState( /* const */ StreamState * thisStreamState, OffT index, IntT n );
void setBytes_StreamState( StreamState * thisStreamState, OffT index, /* const */ List /* ByteTObj */ * bytes );
CharT getChar_StreamState( /* const */ StreamState * thisStreamState, OffT index );
void setChar_StreamState( StreamState * thisStreamState, OffT index, CharT c );
WCharT getWChar_StreamState( /* const */ StreamState * thisStreamState, OffT index );
void setWChar_StreamState( /* const */ StreamState * thisStreamState, OffT index, WCharT wc );
StreamState * construct_StreamState( CallContext context, FILETPtr stream );
bool isEqualsTo_StreamState( /* const */ StreamState * thisStreamState, /* const */ StreamState * streamState );
String * toString_StreamState( /* const */ StreamState * thisStreamState );
void print_StreamState( /* const */ StreamState * thisStreamState, const char * prefix );
int size_StreamState( /* const */ StreamState * thisStreamState );
bool isEof_StreamState( /* const */ StreamState * thisStreamState );
OffT getOffset_StreamState( /* const */ StreamState * thisStreamState );
bool isAllowReading_StreamState( /* const */ StreamState * thisStreamState );
bool isAllowWriting_StreamState( /* const */ StreamState * thisStreamState );
CharT getCurrentChar_StreamState( /* const */ StreamState * thisStreamState );
void setCurrentChar_StreamState( StreamState * thisStreamState, CharT c );
WCharT getCurrentWChar_StreamState( /* const */ StreamState * thisStreamState );
void setCurrentWChar_StreamState( /* const */ StreamState * thisStreamState, WCharT wc );
CString * getCurrentString_StreamState( /* const */ StreamState * thisStreamState, IntT n );
void setCurrentString_StreamState( StreamState * thisStreamState, /* const */ CString * s );
WString * getCurrentWString_StreamState( /* const */ StreamState * thisStreamState, IntT n );
void setCurrentWString_StreamState( StreamState * thisStreamState, /* const */ WString * ws );
List /* ByteTObj */ * getCurrentBytes_StreamState( /* const */ StreamState * thisStreamState, IntT n );
void setCurrentBytes_StreamState( StreamState * thisStreamState, /* const */ List /* ByteTObj */ * bytes );
IntT getCurrentWord_StreamState( /* const */ StreamState * thisStreamState );
void setCurrentWord_StreamState( StreamState * thisStreamState, IntT word );
void lock_StreamState( StreamState * thisStreamState, const ThreadId * threadIdPtr );
void unlock_StreamState( StreamState * thisStreamState, const ThreadId * threadIdPtr );
/* const */ ThreadIdObj * locker_StreamState( /* const */ StreamState * thisStreamState );
int lockCount_StreamState( /* const */ StreamState * thisStreamState );

/* convert mode to OpenFlags */
OpenFlags convertToOflag( CString * mode );

/* get current permissions for file creation */
FilePermissions * currentFilePerm( CallContext context );

/* used in fdopen, freopen */
void applyModeToFile( FileDescId fildes, CString * mode );

void onFputc( CallContext context, FILETPtr stream, IntT c );

void onFputs( CallContext context, FILETPtr stream, CString * s );

void onFgetc( CallContext context, FILETPtr stream, IntT c );

void onFgets( CallContext context, FILETPtr stream, CString * s );

#endif
