/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef IO_FILE_MODEL_SEH
#define IO_FILE_MODEL_SEH

#include "common/common_model.seh"
#include "fs/fs/fs_model.seh"

extern int SKIP_OPEN_CHECK;

/********************************************************************/
/**                           Access Mode                          **/
/********************************************************************/
typedef enum AccessMode
{
    ReadOnly,
        WriteOnly,
        ReadWrite
} AccessMode;


/********************************************************************/
/**                          Block Mode                            **/
/********************************************************************/
typedef enum BlockMode
{
    Blocking,
        Nonblocking
} BlockMode;


/********************************************************************/
/**                          Open Flags                            **/
/********************************************************************/
typedef struct OpenFlags
{
    AccessMode access_mode;
    BlockMode  block_mode;
    bool       append;
    bool       creat;
    bool       excl;
    bool       trunc;
    bool       noctty;
    bool       large_file;
} OpenFlags;


specification typedef OpenFlags OpenFlagsObj;

OpenFlagsObj* create_OpenFlagsObj( OpenFlags oflag );

/********************************************************************/
/**                           Flock Structure                      **/
/********************************************************************/

typedef enum LockType
{
    SUT_F_RDLCK,
    SUT_F_WRLCK,
    SUT_F_UNLCK
} LockType;


typedef enum FlockTypes
{
    SUT_LOCK_SH = 1,
    SUT_LOCK_EX = 2,
    SUT_LOCK_UN    = 4
} FlockTypes;

specification typedef struct Flock
{
    LockType  l_type    ; // Type of lock; F_RDLCK, F_WRLCK, F_UNLCK.
    IntT  l_whence      ; // Flag for starting offset.
    OffT   l_start      ; // Relative offset in bytes.
    OffT   l_len        ; // Size; if 0 then until EOF.
    PidT  l_pid         ; // Process ID of the process holding the lock; returned with F_GETLK.
} Flock;

Flock * create_Flock(
    LockType  l_type,
    IntT  l_whence,
    OffT   l_start,
    OffT   l_len,
    PidT  l_pid
    );

specification typedef struct FcntlArgument
{
    IntT   intArg;
    Flock* ptrArg;
    bool   isIntArg;
} FcntlArgument;

FcntlArgument * create_FcntlArgument(
    IntT   intArg,
    Flock* ptrArg,
    bool   isIntArg
    );

specification typedef struct IOvec
{
    VoidTPtr   iov_base ; // Base address of a memory region for input or output.
    SizeT      iov_len  ; // The size of the memory pointed to by iov_base.
} IOvec;

IOvec * create_IOvec(
    VoidTPtr   iov_base,
    SizeT      iov_len
    );

specification typedef struct FcntlSETLKWCall
{
    Flock* lock;
    FileDescId  fildes;
    Flock*         blockingLock;
} FcntlSETLKWCall;

FcntlSETLKWCall * create_FcntlSETLKWCall(
    Flock* lock,
    FileDescId  fildes,
    Flock*  blockingLock
    );

specification typedef struct fcntlSETLKWReturnType
{
    CallContext context;
    IntT functionResult;
    ErrorCode* errno;
} fcntlSETLKWReturnType;

fcntlSETLKWReturnType * create_fcntlSETLKWReturnType(
    CallContext context,
    IntT functionResult,
    ErrorCode* errno
    );

specification typedef struct  Fcntl_F_GETLCKReturnType
{
    IntT res;
    Flock* lock;
}Fcntl_F_GETLCKReturnType;

Fcntl_F_GETLCKReturnType * create_Fcntl_F_GETLCKReturnType(
    IntT res,
    Flock* lock
);

specification typedef struct Lockf_F_LOCKCall
{
    FileDescId  fildes;
    OffT size;
    bool is64bits;
    List* oldLocks;
} Lockf_F_LOCKCall;

Lockf_F_LOCKCall * create_Lockf_F_LOCKCall(
    FileDescId  fildes,
    OffT size,
    bool is64bits,
    List* oldLocks
);

specification typedef struct Lockf_F_LOCKReturnType
{
    CallContext context;
    IntT functionResult;
    ErrorCode* errno;
} Lockf_F_LOCKReturnType;

Lockf_F_LOCKReturnType * create_Lockf_F_LOCKReturnType(
    CallContext context,
    IntT functionResult,
    ErrorCode* errno
);

specification typedef struct FlockCall
{
    FileDescId  fildes;
    IntT        operation;
    IntT        block;
    Flock*      blockingLock;
} FlockCall;

FlockCall * create_FlockCall(
    FileDescId  fildes,
    IntT        operation,
    IntT        block,
    Flock*      blockingLock
);

specification typedef struct FlockReturnType
{
    CallContext context;
    IntT        functionResult;
    ErrorCode*  errno;
} FlockReturnType;

FlockReturnType * create_FlockReturnType(
    CallContext context,
    IntT        functionResult,
    ErrorCode*  errno
);

typedef enum Fcntl_cmd
{
    SUT_F_DUPFD, // Duplicate file descriptor.
    SUT_F_GETFD, // Get file descriptor flags.
    SUT_F_SETFD, // Set file descriptor flags.
    SUT_F_GETFL, // Get file status flags and file access modes.
    SUT_F_SETFL, // Set file status flags.
    SUT_F_GETLK, // Get record locking information.
    SUT_F_SETLK, // Set record locking information.
    SUT_F_SETLKW, // Set record locking information; wait if blocked.
    SUT_F_GETOWN, // Get process or process group ID to receive SIGURG signals.
    SUT_F_SETOWN // Set process or process group ID to receive SIGURG signals.
} Fcntl_cmd;

typedef enum Lockf_cmd
{
    SUT_F_ULOCK,    // Unlock locked sections.
    SUT_F_LOCK,     // Lock a section for exclusive use.
    SUT_F_TLOCK,    // Test and lock a section for exclusive use.
    SUT_F_TEST      // Test a section for locks by other processes.
} Lockf_cmd;

/********************************************************************/
/**                         File Desciptors                        **/
/********************************************************************/

specification typedef struct DataChunk
{
    CallContext process;
    OffT        offset;
    CByteArray* data;
} DataChunk;

DataChunk * create_DataChunk(
    CallContext process,
    OffT        offset,
    CByteArray* data
);

specification typedef struct RegularFileDescriptor
{
    bool  append;
    List* locks;
    List* lockfLocks;
    List* dataChunks;
    List* waitLocks;
    List* waitLockfLocks;
    bool  notExternallyModified;
}RegularFileDescriptor;

RegularFileDescriptor * create_RegularFileDescriptor(
    bool  append,
    List* locks,
    List* lockfLocks,
    List* dataChunks,
    List* waitLocks,
    List* waitLockfLocks,
    bool  notExternallyModified
    );

RegularFileDescriptor* create_DefaultRegularFileDescriptor();



specification typedef struct FIFOFileDescriptor
{
    CByteArray* data;
} FIFOFileDescriptor;

FIFOFileDescriptor * create_FIFOFileDescriptor(
    CByteArray* data
    );

specification typedef struct FileDescription
{
    AccessMode  access_mode;
    BlockMode   block_mode;
    FileKind    kind;
    bool        fdatasync;
    bool        is64bits;
    Object*     descriptor;
} FileDescription;

FileDescription * create_FileDescription(
    AccessMode  access_mode,
    BlockMode   block_mode,
    FileKind    kind,
    bool        fdatasync,
    bool        is64bits,
    Object*     descriptor
    );

specification typedef struct FileDescriptor
{
  FileDescId  file_desc_id;
  FileId      file;
  CString*    path; // Temporary
  bool        fd_cloexec;
  OffT        offset;
  FileDescription* description;
} FileDescriptor;

FileDescriptor* create_FileDescriptor(
                                      FileDescId file_desc_id,
                                      FileId     file,
                                      CString*   path,
                                      AccessMode access_mode,
                                      BlockMode  block_mode,
                                      FileKind   kind,
                                      bool       fd_cloexec,
                                      OffT       offset,
                                      bool       fdatasync,
                                      bool       is64bits,
                                      Object*    descriptor
                                      );

FileDescriptor* registerFileDescriptor(
                                       FileDescId file_desc_id,
                                       FileId     file,
                                       CString*   path,
                                       AccessMode access_mode,
                                       BlockMode  block_mode,
                                       FileKind   kind,
                                       bool       fd_cloexec,
                                       OffT       offset,
                                       bool       fdatasync,
                                       bool       is64bits,
                                       Object*    descriptor
                                       );

FileDescriptor* registerFileDescriptor_FromDescription(
                                                       FileDescId file_desc_id,
                                                       FileId     file,
                                                       CString*   path,
                                                       bool       fd_cloexec,
                                                       FileDescription* description
                                                       );

void unregisterFileDescriptor( FileDescId file_desc_id );

FilePermissions* ANDPermissions(FilePermissions* umask, FilePermissions* mode);
FileDescriptor* getFileDescriptor_File(CallContext context, File* file);
Bool3 isO_NONBLOCKset(FileDescId fildes);
SSizeT sumIOVecMembers(List* iov);

/********************************************************************/
/**                     File Descriptors Storage                   **/
/********************************************************************/
FileDescriptor* getFileDescriptor( FileDescId file_desc_id );
FileDescriptor* findFileDescriptor( Map* file_descriptors, FileDescId file_desc_id );

int getFileDescriptorsCount(Map *file_descriptors, FileId fileid);

Bool3 isOpenFileDescNumberExceedMax(CallContext context);
/********************************************************************/
/**                 File Descriptor Helper Functions               **/
/********************************************************************/

/*
 * Returns true iff file_desc_id is a valid open file descriptor in the
 * file_desc_id.process process.
 */
bool isValid_FileDescId(FileDescId file_desc_id);

/*
 * Returns true iff file_desc_id is a lowest unused file descriptor in the
 * file_descriptors
 */
bool isLowestUnused_FileDescId(Map* file_descriptors, FileDescId file_desc_id);

/*
 * Returns/sets path of a valid open file descriptor filedes.
 */
CString* getPath_FileDescId(FileDescId file_desc_id);
void setPath_FileDescId(FileDescId file_desc_id, CString *path);

/*
 * Returns/sets fd_cloexec flag of a valid open file descriptor filedes.
 */
bool getFD_CLOEXEC_FileDescId(FileDescId file_desc_id);
void setFD_CLOEXEC_FileDescId(FileDescId file_desc_id, bool fd_cloexec);

/*
 * Returns/sets is64bits flag of a valid open file descriptor filedes.
 */
bool getIs64bits_FileDescId(FileDescId file_desc_id);
void setIs64bits_FileDescId(FileDescId file_desc_id, bool value);


/*
 * Returns/sets access mode of a valid open file descriptor filedes.
 */
AccessMode getAccessMode_FileDescId(FileDescId file_desc_id);
void setAccessMode_FileDescId(FileDescId file_desc_id, AccessMode access_mode);

/*
 * Returns/sets block mode of a valid open file descriptor filedes.
 */
BlockMode getBlockMode_FileDescId(FileDescId file_desc_id);
void setBlockMode_FileDescId(FileDescId file_desc_id, BlockMode block_mode);

/*
 * Returns/sets file kind of a valid open file descriptor filedes.
 */
FileKind getFileKind_FileDescId(FileDescId file_desc_id);
void setFileKind_FileDescId(FileDescId file_desc_id, FileKind kind);

/*
 * Returns/sets descriptor of a valid open file descriptor filedes.
 */
Object* getDescriptor_FileDescId(FileDescId file_desc_id);
void setDescriptor_FileDescId(FileDescId file_desc_id, Object *descriptor);

/*
 * Returns/sets description of a valid open file descriptor filedes.
 */
FileDescription* getDescription_FileDescId(FileDescId file_desc_id);
void setDescription_FileDescId(FileDescId file_desc_id, FileDescription *description);

/*
 * Returns/sets fdatasync flag of a valid open file descriptor filedes.
 */
bool getFdataSync_FileDescId(FileDescId file_desc_id);
void setFdataSync_FileDescId(FileDescId file_desc_id, bool fdatasync);

/*
 * Returns file of a valid open file descriptor id file_desc_id.
 */
File* getFile_FileDescId(FileDescId file_desc_id);



specification typedef struct Fcntl_F_GETFL_ReturnType
{
    AccessMode access_mode;
    BlockMode  block_mode;
    bool       append_flag;
    IntT       retVal;
}Fcntl_F_GETFL_ReturnType;

Fcntl_F_GETFL_ReturnType * create_Fcntl_F_GETFL_ReturnType(
    AccessMode access_mode,
    BlockMode  block_mode,
    bool       append_flag,
    IntT       retVal
    );

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/


/** close_spec **/
specification
IntT close_spec( CallContext context,  FileDescId  fildes, ErrorCode* errno);

void onClose( CallContext context,  FileDescId  fildes, IntT close_spec);


/** creat_spec **/
//This specification refers to: creat64, creat
specification
FileDescId creat_spec(CallContext context, CString* path, FilePermissions* mode,
                ErrorCode* errno, bool is64bits);

void onCreat( CallContext context, CString* path, FilePermissions* mode, FileDescId creat_spec, bool is64bits  );


/** dup_spec **/
specification
FileDescId dup_spec( CallContext context, FileDescId  fildes, ErrorCode* errno);

/** dup2_spec **/
specification
FileDescId dup2_spec(CallContext context, FileDescId  fildes, FileDescId  fildes2,
               ErrorCode* errno);

/** fcntl_spec **/
specification
FileDescId fcntl_F_DUPFD_spec(CallContext context, FileDescId  fildes,
                              FileDescId arg3, ErrorCode* errno);

specification
IntT fcntl_F_GETFD_spec(CallContext context, FileDescId  fildes, ErrorCode* errno);

specification
IntT fcntl_F_SETFD_spec(CallContext context, FileDescId  fildes, bool fd_cloexec, ErrorCode* errno);

specification
Fcntl_F_GETFL_ReturnType* fcntl_F_GETFL_spec(CallContext context, FileDescId  fildes, ErrorCode* errno);


specification
IntT fcntl_F_SETFL_spec(CallContext context, FileDescId  fildes,
                        BlockMode block_mode, bool append_flag, ErrorCode* errno);

specification
IntT fcntl_F_GETOWN_spec(CallContext context, FileDescId  fildes, ErrorCode* errno);


specification
IntT fcntl_F_SETOWN_spec(CallContext context, FileDescId  fildes, IntT thirdArg, ErrorCode* errno);

specification
Fcntl_F_GETLCKReturnType* fcntl_F_GETLCK_spec(CallContext context, FileDescId  fildes, Flock* lock, ErrorCode* errno);


specification
IntT fcntl_F_SETLCK_spec(CallContext context, FileDescId  fildes, Flock* lock, ErrorCode* errno);
void onFcntl_F_SETLCK_spec(CallContext context, FileDescId  fildes, Flock* lock, IntT fcntl_F_SETLCK_spec);

specification
void fcntl_F_SETLKW_spec(CallContext context, FileDescId  fildes, Flock* lock, ErrorCode* errno);
void onFcntlSETLKW(CallContext context, Flock* lock, FileDescId  fildes);
void onFcntlSETLKWReturn(CallContext context, IntT fcntl_SETLKW_return_value);
reaction fcntlSETLKWReturnType* fcntl_F_SETLKW_return(void);



/** fdatasync_spec **/
specification
IntT fdatasync_spec( CallContext context, FileDescId  fildes, ErrorCode* errno);

/** flock_spec **/
specification
void flock_spec(CallContext context, FileDescId  fildes, IntT operation, IntT block,
                ErrorCode* errno);

void onFlock(CallContext context, FileDescId  fildes, IntT operation, IntT block);
void onFlockReturn(CallContext context, IntT flock_return_value);
reaction FlockReturnType* flock_return(void);


/** fsync_spec **/
specification
IntT fsync_spec( CallContext context, FileDescId  fildes, ErrorCode* errno);

/** ftruncate_spec **/
//This specification refers to: ftruncate, ftruncate64
specification
IntT ftruncate_spec(CallContext context, FileDescId  fildes,
                    OffT length, ErrorCode* errno, bool is64bits);

void onFtruncate(CallContext context, FileDescId  fildes,
                      OffT length, IntT ftruncate_spec);

/** lockf_spec **/
//This specification refers to: lockf64, lockf
specification
IntT lockf_F_TLOCK_spec(CallContext context, FileDescId  fildes, OffT size,
                        ErrorCode* errno, bool is64bits);

void onLockf_F_TLOCK(CallContext context, FileDescId  fildes, OffT size, bool is64bits,
                     IntT lockf_F_TLOCK_spec);

//This specification refers to: lockf64, lockf
specification
IntT lockf_F_UNLOCK_spec(CallContext context, FileDescId  fildes, OffT size,
                        ErrorCode* errno, bool is64bits);

void onLockf_F_UNLOCK(CallContext context, FileDescId  fildes, OffT size, bool is64bits,
                      IntT lockf_F_UNLOCK_spec);

//This specification refers to: lockf64, lockf
specification
IntT lockf_F_TEST_spec(CallContext context, FileDescId  fildes, OffT size,
                       ErrorCode* errno, bool is64bits);

//This specification refers to: lockf64, lockf
specification
void lockf_F_LOCK_spec(CallContext context, FileDescId  fildes, OffT size,
                       ErrorCode* errno, bool is64bits);

void onLockf_F_LOCK(CallContext context, FileDescId  fildes, OffT size, bool is64bits);

void onLockf_F_LOCKReturn(CallContext context, IntT lockf_F_LOCK_return_value);

reaction Lockf_F_LOCKReturnType* lockf_F_LOCK_return(void);

/** lseek_spec **/
//This specification refers to: lseek64, lseek
specification
OffT lseek_spec(CallContext context, FileDescId  fildes,
                OffT offset,  IntT whence, ErrorCode* errno, bool is64bits);

void onLseek(CallContext context, FileDescId  fildes, OffT offset,
             IntT whence, OffT lseek_spec);

/** open_spec **/
//This specification refers to: open64, open
specification
FileDescId open_spec(CallContext context, CString* path, OpenFlags oflag,
               FilePermissions* mode, ErrorCode* errno, bool is64bits );

void onOpen( CallContext context, CString* path, OpenFlags oflag,
            FilePermissions* mode, FileDescId open_spec, bool is64bits );

/** pread_spec **/
//This specification refers to: pread64, pread
specification
SSizeT pread_spec(CallContext context, FileDescId fildes, VoidTPtr buf,
                  SizeT nbyte, OffT offset, ErrorCode* errno, bool is64bits);

void onPread(CallContext context, FileDescId fildes, VoidTPtr buf,
             SizeT nbyte, OffT offset, SSizeT pread_spec);

/** pwrite_spec **/
//This specification refers to: pwrite64, pwrite
specification
SSizeT pwrite_spec(CallContext context, FileDescId fildes,
                   VoidTPtr buf, SizeT nbyte, OffT offset, ErrorCode* errno,
                   bool is64bits);

void onPwrite(CallContext context, FileDescId fildes,
                   VoidTPtr buf, SizeT nbyte, OffT offset,
                   SSizeT pwrite_spec);

/** read_spec **/
specification
SSizeT read_spec(CallContext context, FileDescId fildes, VoidTPtr buf,
                 SizeT nbyte, ErrorCode* errno);

void onRead(CallContext context, FileDescId fildes, VoidTPtr buf,
            SizeT nbyte, SSizeT read_spec);

/** readv_spec **/
specification
SSizeT readv_spec(CallContext context, FileDescId fildes, List* iov,
                  ErrorCode* errno);

void onReadv(CallContext context, FileDescId fildes, List* iov,
             SSizeT readv_spec);

/** sync_spec **/
specification
void sync_spec(CallContext context);

/** truncate_spec **/
//This specification refers to: truncate, truncate64
specification
IntT truncate_spec(CallContext context, CString* path, OffT length,
                   ErrorCode* errno, bool is64bits);

void onTruncate(CallContext context, CString* path, OffT length, IntT truncate_spec);

/** write_spec **/
specification
SSizeT write_spec(CallContext context, FileDescId fildes, VoidTPtr buf,
                  SizeT nbyte, ErrorCode* errno);

void onWrite(CallContext context, FileDescId fildes,
                  VoidTPtr buf, SizeT nbyte,
                  SSizeT write_spec);

/** writev_spec **/
specification
SSizeT writev_spec(CallContext context, FileDescId fildes, List* iov,
                   ErrorCode* errno);

void onWritev(CallContext context, FileDescId fildes, List* iov,
                   SSizeT writev_spec);

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

Bool3 isEACCES_io_file_open(CallContext context, FileSystem *fs, CString *path, bool fileExists, OpenFlags oflags);
Bool3 isEACCES_io_file_creat(CallContext context, FileSystem *fs, CString *path, bool fileExists);

bool isLowestUnused_FileDescId_Greater(Map *file_descriptors, FileDescId desc, FileDescId greaterThan);
List* getBlockingLocks(Flock* lock, List* locks);
bool isLockInvalid(Flock*  lock);
bool isOneTypeOfLock(List* locks);
Flock* getBlockingLock(Flock* lock, FileDescId fildes);
Flock* normalizeLock(CallContext context, FileDescId  fildes, Flock* lock);
void processFileLocking(List* locks, Flock* toAddLock);
bool isFlockDeadLock(List* waitList, List* locks, Flock* lock);
List* truncateChunksList(List* chunks, OffT size, CallContext context);
bool isSectionLocked(CallContext context, FileDescId fildes, List* lockfLocks, OffT offset, SizeT size, bool is64bits);
Flock* createNormalizedLockfLock(CallContext context, FileDescriptor* fdesc, OffT size, bool is64bits);
void unlockRegions(List* locks, Flock* toAddLock);
OffT calculateOffset(FileDescriptor* fdesc, IntT whence, OffT offset, OffTObj* file_size);
bool checkDataRead(CallContext context, FileDescId fildes, VoidTPtr buf, SizeT nbyte, OffT offset);
List* reorderChunksList(List* chunks, CallContext context);
bool isLockfDeadLock(CallContext context, RegularFileDescriptor* fdesc, FileDescriptor* fildes, OffT size, bool is64bits);

ByteT getByteAtPos(List* chunks, OffT curPos, IntTObj* found);

#endif
