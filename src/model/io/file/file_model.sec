/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */



#include "config/system_config.seh"
#include "io/file/file_config.h"
#include "common/common_model.seh"
#include "io/file/file_model.seh"
#include "system/system/system_model.seh"
#include "process/process/process_model.seh"
#include "fs/fs/fs_model.seh"
#include "fs/dir/dir_config.h"
#include "fs/dir/dir_model.seh"
#include "fs/meta/meta_model.seh"

#pragma SEC subsystem file "io.file"

/*
   The group of functions 'io.file' consists of:
       close [2]                +
       creat [1]                +
       creat64 [2]              +
       dup [2]                  +
       dup2 [2]                 +
       fcntl [1]                +
       fdatasync [2]            +
       flock [1]                +
       fsync [2]                +
       ftruncate [2]            +
       ftruncate64 [2]          +
       lockf [2]                +
       lockf64 [2]              +
       lseek [2]                +
       lseek64 [1]              +
       open [1]                 +
       open64 [1]               +
       pread [2]                +
       pread64 [1]              +
       pwrite [2]               +
       pwrite64 [1]             +
       read [2]                 +
       readv [2]                +
       sync [2]                 +
       truncate [2]             +
       truncate64 [2]           +
       write [2]                +
       writev [2]               +
*/

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    close - close a file descriptor

SYNOPSIS

    #include <unistd.h>
    int close(int fildes);

DESCRIPTION

    The close() function shall deallocate the file descriptor indicated by
    fildes. To deallocate means to make the file descriptor available for
    return by subsequent calls to open() or other functions that allocate file
    descriptors. All outstanding record locks owned by the process on the
    file associated with the file descriptor shall be removed
    (that is, unlocked).

    If close() is interrupted by a signal that is to be caught, it shall
    return -1 with errno set to [EINTR] and the state of fildes is
    unspecified. If an I/O error occurred while reading from or writing to the
    file system during close(), it may return -1 with errno set to [EIO]; if
    this error is returned, the state of fildes is unspecified.

    When all file descriptors associated with a pipe or FIFO special file are
    closed, any data remaining in the pipe or FIFO shall be discarded.

    When all file descriptors associated with an open file description have
    been closed, the open file description shall be freed.

    If the link count of the file is 0, when all file descriptors associated
    with the file are closed, the space occupied by the file shall be freed
    and the file shall no longer be accessible.

    If a STREAMS-based fildes is closed and the calling process was previously
    registered to receive a SIGPOLL signal for events associated with that
    STREAM, the calling process shall be unregistered for events associated
    with the STREAM. The last close() for a STREAM shall cause the STREAM
    associated with fildes to be dismantled. If O_NONBLOCK is not set and
    there have been no signals posted for the STREAM, and if there is data on
    the module's write queue, close() shall wait for an unspecified time
    (for each module and driver) for any output to drain before dismantling
    the STREAM. The time delay can be changed via an I_SETCLTIME ioctl()
    request. If the O_NONBLOCK flag is set, or if there are any pending
    signals, close() shall not wait for output to drain, and shall
    dismantle the STREAM immediately.

    If the implementation supports STREAMS-based pipes, and fildes is
    associated with one end of a pipe, the last close() shall cause a
    hangup to occur on the other end of the pipe. In addition, if the other
    end of the pipe has been named by fattach(), then the last close() shall
    force the named end to be detached by fdetach(). If the named end has no
    open file descriptors associated with it and gets detached, the STREAM
    associated with that end shall also be dismantled.

    If fildes refers to the master side of a pseudo-terminal, and this is the
    last close, a SIGHUP signal shall be sent to the controlling process, if
    any, for which the slave side of the pseudo-terminal is the controlling
    terminal. It is unspecified whether closing the master side of the
    pseudo-terminal flushes all queued input and output.

    If fildes refers to the slave side of a STREAMS-based pseudo-terminal, a
    zero-length message may be sent to the master.

    When there is an outstanding cancelable asynchronous I/O operation against
    fildes when close() is called, that I/O operation may be canceled. An I/O
    operation that is not canceled completes as if the close() operation had
    not yet occurred. All operations that are not canceled shall complete as
    if the close() blocked until the operations completed. The close()
    operation itself need not block awaiting such I/O completion. Whether
    any I/O operation is canceled, and which I/O operation may be canceled
    upon close(), is implementation-defined.

    If a shared memory object or a memory mapped file remains referenced at
    the last close (that is, a process has it mapped), then the entire
    contents of the memory object shall persist until the memory object
    becomes unreferenced. If this is the last close of a shared memory
    object or a memory mapped file and the close results in the memory object
    becoming unreferenced, and the memory object has been unlinked, then the
    memory object shall be removed.

    If fildes refers to a socket, close() shall cause the socket to be
    destroyed. If the socket is in connection-mode, and the SO_LINGER option
    is set for the socket with non-zero linger time, and the socket has
    untransmitted data, then close() shall block for up to the current linger
    interval until all data is transmitted.

RETURN VALUE

    Upon successful completion, 0 shall be returned; otherwise, -1 shall
    be returned and errno set to indicate the error.

ERRORS

    The close() function shall fail if:

        [EBADF]
        The fildes argument is not a valid file descriptor.

        [EINTR]
        The close() function was interrupted by a signal.

    The close() function may fail if:

        [EIO]
        An I/O error occurred while reading from or writing to the file system.
*/
specification
IntT close_spec( CallContext context,  FileDescId  fildes, ErrorCode* errno)
{
    FileDescriptor* fd=getFileDescriptor(fildes);

    pre
    {
        return true;
    }
    post
    {
        /*
         * otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_CLOSE, "close.13.02", close_spec==-1, *errno )
        /*
        * The close() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid file descriptor.
        */
        ERROR_SHALL(POSIX_CLOSE, EBADF, "close.14.01", fd==NULL)

        /*
        * The close() function shall fail if:
        *
        * [EINTR]
        *
        * The close() function was interrupted by a signal.
        */
        ERROR_SHALL(POSIX_CLOSE, EINTR, "close.14.02", TODO_ERR(EINTR))

        /*
        * The close() function may fail if:
        *
        * [EIO]
        *
        * An I/O error occurred while reading from or writing to the file system.
        */
        ERROR_UNCHECKABLE(POSIX_CLOSE, EIO, "close.15.01", "Can not check IO errors")

        ERROR_END()

        /*
         * Upon successful completion, 0 shall be returned;
         */
        REQ("close.13.01",
            "Upon successful completion, 0 shall be returned",
            close_spec==0);

        /*
         * The close() function shall deallocate the file descriptor indicated by fildes.
         * To deallocate means to make the file descriptor available for return by
         * subsequent calls to open() or other functions that allocate file descriptors.
         */
        REQ("?close.01", "File descriptor shall be deallocated",
            getFileDescriptor(fildes)==NULL);

        /*
         * If an I/O error occurred while reading from or writing to the file system
         * during close(), it may return -1 with errno set to [EIO]; if this error is
         * returned, the state of fildes is unspecified.
         */
        REQ_UNCHECKABLE("close.16.02", "Can't check IO errors");

        /*
         * If close() is interrupted by a signal that is to be caught, it shall return -1
         * with errno set to [EINTR] and the state of fildes is unspecified.
         */
        REQ("close.16.01", "", TODO_REQ());

        /*
         * All outstanding record locks owned by the process on the file associated with
         * the file descriptor shall be removed (that is, unlocked).
         */
        REQ("close.02", "", TODO_REQ());


        /*
         * When all file descriptors associated with an open file description have been
         * closed, the open file description shall be freed.
         */
        REQ_UNCHECKABLE("close.04", "Can not check weather file description is freed");

        /*
         * If the link count of the file is 0, when all file descriptors associated with
         * the file are closed, the space occupied by the file shall be freed and the file
         * shall no longer be accessible.
         */
        REQ("close.05", "", TODO_REQ());

        /*
         * When there is an outstanding cancelable asynchronous I/O operation against
         * fildes when close() is called, that I/O operation may be canceled.
         */
        REQ_UNCHECKABLE("close.10.01", "AIO");

        /*
         * An I/O operation that is not canceled completes as if the close() operation had
         * not yet occurred.
         */
        REQ_UNCHECKABLE("close.10.02", "AIO");

        /*
         * All operations that are not canceled shall complete as if the close() blocked
         * until the operations completed.
         */
        REQ_UNCHECKABLE("close.10.03", "AIO");

        /*
         * The close() operation itself need not block awaiting such I/O completion.
         */
        REQ_UNCHECKABLE("close.10.04", "AIO");

        /*
         * If a shared memory object or a memory mapped file remains referenced at the
         * last close (that is, a process has it mapped), then the entire contents of the
         * memory object shall persist until the memory object becomes unreferenced.
         */
        REQ("close.11.01", "", TODO_REQ());

        /*
         * If this is the last close of a shared memory object or a memory mapped file and
         * the close results in the memory object becoming unreferenced, and the
         * memory object has been unlinked, then the memory object shall be removed.
         */
        REQ("close.11.02", "", TODO_REQ());

        return true;
  }
}

void onClose( CallContext context,  FileDescId  fildes, IntT close_spec)
{
    if (close_spec==0)
    {
        unregisterFileDescriptor(fildes);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    creat - create a new file or rewrite an existing one

SYNOPSIS

    #include <sys/stat.h>
    #include <fcntl.h>
    int creat(const char *path, mode_t mode);

DESCRIPTION

    The function call:

        creat(path, mode)

    shall be equivalent to:

        open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)

RETURN VALUE

    Refer to open().

ERRORS

    Refer to open().
*/

//This specification refers to: creat64, creat
specification
FileDescId creat_spec(CallContext context, CString* path, FilePermissions* mode,
                ErrorCode* errno, bool is64bits)
{
    File*           openedFile;
    FileDescriptor* openedFileDesc;
    ProcessState*   ps=getProcessState_CallContext(context);
    RegularFileDescriptor *desc;
    Bool3 isELOOP;
    CString *absPath = resolvePath_Ext(context, getFileSystem(context), path, &isELOOP);
    Bool3 fileExists=doesFileExist_FileSystem( getFileSystem(context), absPath);
    FileSystem *pre_fs = clone(getFileSystem(context));
    File* oldFile=NULL;

    if (is64bits)
        FILTER("creat64");
    else
        FILTER("creat");

    pre
    {

        if (fileExists==True_Bool3)
        {
           oldFile=clone(getFile_FileSystem(getFileSystem(context), absPath));
        }

        /*
        * When bits other than the file permission bits are set, the effect is
        * unspecified.
        *
        */
        REQ("app.creat.open.06.06;app.creat64.open.06.06", "Model inhibits invalid flag values", true);

        return true;
    }
    post
    {
        if (creat_spec.filedesc==-1)
        {
            if (fileExists==False_Bool3)
            {
                /*
                * No files shall be created or modified if the function returns -1.
                *
                */
                REQ("?creat.open.30.03;creat64.open.30.03", "File shall not be created",
                    doesFileExist_FileSystem(getFileSystem(context), absPath)==False_Bool3);
            }
        }


        /*
        * Otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_CREAT, "creat.open.30.02;creat64.open.30.02", creat_spec.filedesc==-1, *errno )

        /*
         * The open() function shall fail if:
         *
         * [EACCES]
         *
         * Search permission is denied on a component of the path prefix, or the file
         * exists and the permissions specified by oflag are denied, or the file does not
         * exist and write permission is denied for the parent directory of the file to be
         * created, or O_TRUNC is specified and write permission is denied.
         */
        ERROR_SHALL3(POSIX_CREAT, EACCES, "creat.open.31.01;creat64.open.31.01",
            isEACCES_io_file_creat(context, pre_fs, absPath, fileExists))

         /*
         * The open() function shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during open().
         */
        ERROR_SHALL(POSIX_CREAT, EINTR, "creat.open.31.03;creat64.open.31.03", TODO_ERR(EINTR))

        /*
         * The open() function shall fail if:
         *
         * [EINVAL]
         *
         * [SIO] The implementation does not support synchronized I/O for this file.
         */
        ERROR_SHALL(POSIX_CREAT, EINVAL, "creat.open.31.04;creat64.open.31.04", TODO_ERR(EINVAL))

        /*
         * The open() function shall fail if:
         *
         * [EIO]
         *
         * [XSR] The path argument names a STREAMS file and a hangup or error occurred
         * during the open().
         */
        ERROR_SHALL(POSIX_CREAT, EIO, "creat.open.31.05;creat64.open.31.05", TODO_ERR(EIO))

        /*
         * The open() function shall fail if:
         *
         * [EISDIR]
         *
         * The named file is a directory and oflag includes O_WRONLY or O_RDWR.
         */
         ERROR_SHALL(POSIX_CREAT, EISDIR, "creat.open.31.06;creat64.open.31.06",
            fileExists==True_Bool3 && oldFile->kind==DirectoryFile)

        /*
         * The open() function shall fail if:
         *
         * [ELOOP]
         *
         * A loop exists in symbolic links encountered during resolution of the path
         * argument.
         */
        ERROR_SHALL3(POSIX_CREAT, ELOOP, "creat.open.31.07;creat64.open.31.07", isELOOP)

        /*
         * The open() function shall fail if:
         *
         * [EMFILE]
         *
         * {OPEN_MAX} file descriptors are currently open in the calling process.
         */
        ERROR_SHALL3(POSIX_CREAT, EMFILE, "creat.open.31.08;creat64.open.31.08",
            @isOpenFileDescNumberExceedMax(context))

        /*
         * The open() function shall fail if:
         *
         * [ENAMETOOLONG]
         *
         * The length of the path argument exceeds {PATH_MAX} or a pathname component is
         * longer than {NAME_MAX}.
         */
        ERROR_SHALL3(POSIX_CREAT, ENAMETOOLONG, "creat.open.31.09;creat64.open.31.09", isENAMETOOLONG(context, path))

        /*
         * The open() function shall fail if:
         *
         * [ENFILE]
         *
         * The maximum allowable number of files is currently open in the system.
         */
        ERROR_UNCHECKABLE(POSIX_CREAT, ENFILE, "creat.open.31.10;creat64.open.31.10", "Can not check ENFILE error")

        /*
         * The open() function shall fail if:
         *
         * [ENOENT]
         *
         * O_CREAT is not set and the named file does not exist; or O_CREAT is set and
         * either the path prefix does not exist or the path argument points to an empty
         * string.
         */
        ERROR_SHALL3(POSIX_CREAT, ENOENT, "creat.open.31.11;creat64.open.31.11", isENOENT_dir(context, pre_fs, getParentDir_Path(absPath)))

        /*
         * The open() function shall fail if:
         *
         * [ENOSR]
         *
         * [XSR] The path argument names a STREAMS-based file and the system is unable to
         * allocate a STREAM.
         */
        ERROR_SHALL(POSIX_CREAT, ENOSR, "creat.open.31.12;creat64.open.31.12", TODO_ERR(ENOSR))

        /*
         * The open() function shall fail if:
         *
         * [ENOSPC]
         *
         * The directory or file system that would contain the new file cannot be expanded,
         * the file does not exist, and O_CREAT is specified.
         */
        ERROR_SHALL(POSIX_CREAT, ENOSPC, "creat.open.31.13;creat64.open.31.13", TODO_ERR(ENOSPC))

        /*
         * The open() function shall fail if:
         *
         * [ENOTDIR]
         *
         * A component of the path prefix is not a directory.
         */
        ERROR_SHALL3(POSIX_CREAT, ENOTDIR, "creat.open.31.14;creat64.open.31.14", isENOTDIR_dir(context, pre_fs, getParentDir_Path(absPath)))

        /*
         * The open() function shall fail if:
         *
         * [ENXIO]
         *
         * O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no process
         * has the file open for reading.
         */
        ERROR_SHALL(POSIX_CREAT, ENXIO, "creat.open.31.15;creat64.open.31.15", TODO_ERR(ENXIO))

        /*
         * The open() function shall fail if:
         *
         * [ENXIO]
         *
         * The named file is a character special or block special file, and the device
         * associated with this special file does not exist.
         */
        ERROR_SHALL(POSIX_CREAT, ENXIO, "creat.open.31.16;creat64.open.31.16", TODO_ERR(ENXIO))

        /*
         * The open() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * The named file is a regular file and the size of the file cannot be represented
         * correctly in an object of type off_t.
         */
        ERROR_SHALL(POSIX_CREAT, EOVERFLOW, "creat.open.31.17;creat64.open.31.17", TODO_ERR(EOVERFLOW))

        /*
         * The open() function shall fail if:
         *
         * [EROFS]
         *
         * The named file resides on a read-only file system and either O_WRONLY, O_RDWR,
         * O_CREAT (if the file does not exist), or O_TRUNC is set in the oflag argument.
         */
        ERROR_SHALL(POSIX_CREAT, EROFS, "creat.open.31.18;creat64.open.31.18", TODO_ERR(EROFS))

        /*
         * The open() function may fail if:
         *
         * [EAGAIN]
         *
         * [XSI] The path argument names the slave side of a pseudo-terminal device that
         * is locked.
         */
        ERROR_MAY(POSIX_CREAT, EAGAIN, "creat.open.32.01;creat64.open.32.01", TODO_ERR(EAGAIN))

        /*
         * The open() function may fail if:
         *
         * [ELOOP]
         *
         * More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
         * the path argument.
         */
        ERROR_MAY3(POSIX_CREAT, ELOOP, "creat.open.32.03;creat64.open.32.03", isELOOP)

        /*
         * The open() function may fail if:
         *
         * [ENAMETOOLONG]
         *
         * As a result of encountering a symbolic link in resolution of the path argument,
         * the length of the substituted pathnamestring exceeded {PATH_MAX}.
         */
        ERROR_MAY3(POSIX_CREAT, ENAMETOOLONG, "creat.open.32.04;creat64.open.32.04", isENAMETOOLONG(context, absPath))

        /*
         * The open() function may fail if:
         *
         * [ENOMEM]
         *
         * [XSR] The path argument names a STREAMS file and the system is unable to
         * allocate resources.
         */
        ERROR_MAY(POSIX_CREAT, ENOMEM, "creat.open.32.05;creat64.open.32.05", TODO_ERR(ENOMEM))

        /*
         * The open() function may fail if:
         *
         * [ETXTBSY]
         *
         * The file is a pure procedure (shared text) file that is being executed and
         * oflag is O_WRONLY or O_RDWR.
         */
        ERROR_MAY(POSIX_CREAT, ETXTBSY, "creat.open.32.06;creat64.open.32.06", TODO_ERR(ETXTBSY))

        ERROR_END()

        /*
        * The open() function shall establish the connection between a file and a file
        * descriptor. It shall create an open file description that refers to a file and
        * a file descriptor that refers to that open file description.
        */
        REQ("creat.open.01;creat64.open.01", "This is checked in this specification", true);

        openedFile=getFile_FileDescId(creat_spec);
        openedFileDesc=getFileDescriptor(creat_spec);

        /*
        * The open() function shall establish the connection between a file and a file
        * descriptor. It shall create an open file description that refers to a file and
        * a file descriptor that refers to that open file description.
        */
        REQ("?creat.open.01", "File descriptor shall not be NULL", openedFileDesc!=NULL);

        desc=getDescriptor_FileDescId(creat_spec);

        /*
         * Upon successful completion, the function shall open the file and return a non-
         * negative integer representing the lowest numbered unused file descriptor.
         *
         */
        /*
         * The open() function shall return a file descriptor for the named file that is
         * the lowest file descriptor not currently open for that process.
         *
         */
        REQ("creat.open.30.01;creat.open.02.01;creat64.open.02.01", "Descriptor shall be lowest",
            isLowestUnused_FileDescId(ps->file_descriptors, creat_spec));

        /*
         * The open file description is new, and therefore the file descriptor shall not
         * share it with any other process in the system.
         *
         */
        REQ_UNCHECKABLE("creat.open.02.02;creat64.open.02.02", "Can not detect file sharing");

        /*
         * The FD_CLOEXEC file descriptor flag associated with the new file descriptor
         * shall be cleared.
         */
        REQ("?creat.open.02.03;creat64.open.02.03", "FD_CLOEXEC flag shall be cleared",
             getFD_CLOEXEC_FileDescId(creat_spec)==false);

        if (fileExists==True_Bool3)
        {
            /*
            * If the file exists and is a regular file, and the file is successfully opened
            * O_RDWR or O_WRONLY, its length shall be truncated to 0, and the mode and owner
            * shall be unchanged.
            *
            */
            REQ("?creat.open.13.01;creat64.open.13.01", "File parameters shall be unchanged",
                *(openedFile->size)==0 && equals(openedFile->permissions, oldFile->permissions)
                && equals(openedFile->uid, oldFile->uid));

            /*
             * If O_TRUNC is set and the file did previously exist, upon successful completion,
             * open() shall mark for update the st_ctime and st_mtime fields of the file.
             *
             */
            REQ("?creat.open.15;creat64.open.15", "File time shall be updated", openedFile->ctime_updated==false &&
                    openedFile->mtime_updated==false);
        }

        /*
         * The file offset used to mark the current position within the file shall be set
         * to the beginning of the file.
         *
         */
        REQ("?creat.open.03;creat64.open.03", "The file offset shall be set to the beginning of the file",
                openedFileDesc->offset==0);

        /*
         * The file status flags and file access modes of the open file description shall
         * be set according to the value of oflag.
         */
        REQ("?creat.open.04;creat64.open.04", "Access mode shall be valid", getAccessMode_FileDescId(creat_spec)
            ==WriteOnly);

        if (fileExists==False_Bool3)
        {
            /*
             * Otherwise, the file shall be created;
             *
             */
            REQ("?creat.open.06.02;creat64.open.06.02", "File shall be created", openedFile!=NULL);

            /*
             * the user ID of the file shall be set to the effective user ID of the process;
             *
            */
            REQ("?creat.open.06.03;creat64.open.06.03", "User ID of the file shall be valid",
                equals(openedFile->uid, create_UidTObj(ps->meta.effective_userid)));
            {
                /*
                * the group ID of the file shall be set to the group ID of the file's parent
                * directory or to the effective group ID of the process;
                *
                */
                CString* parPath=getParentDir_Path(absPath);
                File* parentDir=getFile_FileSystem(getFileSystem(context), parPath);

                REQ("?creat.open.06.04;creat64.open.06.04", "Group ID shall be valid",
                    equals(openedFile->gid, create_GidTObj(ps->meta.effective_groupid)) ||
                    equals(openedFile->gid, parentDir->gid));
            }

            /*
            * and the access permission bits (see <sys/stat.h>) of the file mode shall be
            * set to the value of the third argument taken as type mode_t modified as follows:
            * a bitwise AND is performed on the file-mode bits and the corresponding bits in
            * the complement of the process' file mode creation mask. Thus, all bits in the
            * file mode whose corresponding bit in the file mode creation mask is set are
            * cleared.
            *
            */
            REQ("?creat.open.06.05;creat64.open.06.05", "Permissions shall be valid", equals(openedFile->permissions,
                ANDPermissions(ps->meta.umask, mode)));

            /*
            * If O_CREAT is set and the file did not previously exist, upon successful
            * completion, open() shall mark for update the st_atime, st_ctime, and st_mtime
            * fields of the file and the st_ctime and st_mtime fields of the parent directory.
            *
            */
            REQ("?creat.open.14;creat64.open.14", "Time shall be marked for update", openedFile->atime_updated==false &&
                openedFile->ctime_updated==false && openedFile->mtime_updated==false);
        }

        return true;
  }
  FILTER_CLEAN;
}


void onCreat( CallContext context, CString* path, FilePermissions* mode, FileDescId creat_spec, bool is64bits )
{
    ProcessState* ps=getProcessState_CallContext(context);
    FileSystem*   file_system = getFileSystem(context);
    Bool3         eloop;
    CString*      resolved=resolvePath_Ext(context, file_system, path, &eloop);
    CString*      parPath=getParentDir_Path(resolved);
    Bool3         fileExists=doesFileExist_FileSystem(file_system, resolved);
    File*         file = getFile_FileSystem( file_system, resolved );
    File*         parentDir=getFile_FileSystem(getFileSystem(context), parPath);

    if (creat_spec.filedesc >= 0)
    {
        if (fileExists==True_Bool3)
        {
            updateCtimePath(context, file_system, resolved);
            updateMtimePath(context, file_system, resolved);
        }
        if (fileExists==False_Bool3)
        {
            updateAtimePath(context, file_system, resolved);
            updateCtimePath(context, file_system, resolved);
            updateMtimePath(context, file_system, resolved);

            updateCtimePath(context, file_system, parPath);
            updateMtimePath(context, file_system, parPath);
        }

        if (file == NULL)
        {
            file = registerFile( file_system, path );
        }
        if (file != NULL)
        {
            RegularFileDescriptor* descr=create_DefaultRegularFileDescriptor();

            file->size=create_OffTObj(0);
            file->kind=RegularFile;

            if (fileExists==False_Bool3)
            {
                registerFileDescriptor( creat_spec, file->fileid, path, WriteOnly,
                    Blocking, RegularFile, false, (OffT)0, true, is64bits, descr);
                file->permissions=ANDPermissions(ps->meta.umask, mode);
                file->uid=create_UidTObj(ps->meta.effective_userid);
                if(FILE_IO_OPEN_SETS_GID_TO_PROCESS_GID)
                {
                    file->gid=create_GidTObj(ps->meta.effective_groupid);
                }else{
                    if (parentDir!=NULL && parentDir->gid!=NULL)
                    {
                        file->gid=clone(parentDir->gid);
                    }
                }
                file->descriptor=descr;

            }
            else if (fileExists==True_Bool3)
            {
                if (file->descriptor==NULL)
                {
                    if (file->kind==RegularFile)
                    {
                        registerFileDescriptor( creat_spec, file->fileid, path, WriteOnly,
                            Blocking, RegularFile, false, 0, true, is64bits, descr);
                        file->descriptor=descr;
                    }
                    else
                    {
                        registerFileDescriptor( creat_spec, file->fileid, path, WriteOnly,
                            Blocking, file->kind, false, 0, true, is64bits, file->descriptor);
                    }
                }
                else
                {
                    registerFileDescriptor( creat_spec, file->fileid, path, WriteOnly,
                        Blocking, file->kind, false, 0, true, is64bits, file->descriptor);
                }
            }
            else
            {
                registerFileDescriptor( creat_spec, file->fileid, path, WriteOnly,
                    Blocking, UnknownFileKind, false, 0, true, is64bits, file->descriptor);
            }
        }
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    dup, dup2 - duplicate an open file descriptor

SYNOPSIS

    #include <unistd.h>
    int dup(int fildes);
    int dup2(int fildes, int fildes2);

DESCRIPTION

    The dup() and dup2() functions provide an alternative interface to the
    service provided by fcntl() using the F_DUPFD command. The call:

        fid = dup(fildes);

    shall be equivalent to:

        fid = fcntl(fildes, F_DUPFD, 0);

    The call:

        fid = dup2(fildes, fildes2);

    shall be equivalent to:

        close(fildes2);
        fid = fcntl(fildes, F_DUPFD, fildes2);

except for the following:

* If fildes2 is less than 0 or greater than or equal to {OPEN_MAX}, dup2()
  shall return -1 with errno set to [EBADF].
* If fildes is a valid file descriptor and is equal to fildes2, dup2() shall
  return fildes2 without closing it.
* If fildes is not a valid file descriptor, dup2() shall return -1 and shall
  not close fildes2.
* The value returned shall be equal to the value of fildes2 upon successful
  completion, or -1 upon failure.

RETURN VALUE

    Upon successful completion a non-negative integer, namely the file
    descriptor, shall be returned; otherwise, -1 shall be returned and errno
    set to indicate the error.

ERRORS

    The dup() function shall fail if:

        [EBADF]
        The fildes argument is not a valid open file descriptor.

        [EMFILE]
        The number of file descriptors in use by this process would exceed
        {OPEN_MAX}.

The dup2() function shall fail if:

        [EBADF]
        The fildes argument is not a valid open file descriptor or the argument
        fildes2 is negative or greater than or equal to {OPEN_MAX}.

        [EINTR]
        The dup2() function was interrupted by a signal.
*/
specification
FileDescId dup_spec( CallContext context, FileDescId  fildes, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    ProcessState* ps = getProcessState_CallContext(context);
    RegularFileDescriptor *desc;
    FileDescriptor* oldDesc;
    FileDescriptor* newDesc;

    pre
    {
        if (file!=NULL)
        {
            /*
            * If fildes refers to a typed memory object, the result of the fcntl()
            * function is unspecified.
            */
            REQ("app.dup.fcntl.27", "File type shall not be typed memory object",
                file->kind!=TypedMemoryObject);
        }
        return true;
    }
    post
    {
        /*
        * otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_DUP, "dup.06.02", dup_spec.filedesc==-1, *errno)

        /*
        * The dup() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid open file descriptor.
        */
        ERROR_SHALL(POSIX_DUP, EBADF, "dup.07.01", file==NULL)

        /*
        * The dup() function shall fail if:
        *
        * [EMFILE]
        *
        * The number of file descriptors in use by this process would exceed
        * {OPEN_MAX}.
        */
        ERROR_SHALL3(POSIX_DUP, EMFILE, "dup.07.02", @isOpenFileDescNumberExceedMax(context))

        ERROR_END()

        /*
        * The dup() and dup2() functions provide an alternative interface to
        * the service
        * provided by fcntl() using the F_DUPFD command. The call:
        *
        * fid = dup(fildes);
        *
        * shall be equivalent to:
        *
        * fid = fcntl(fildes, F_DUPFD, 0);
        */
        REQ("dup.01", "Further REQ's check this equivalence", true);

        /*
        * Upon successful completion a non-negative integer, namely the file
        * descriptor, shall be returned;
        */
        REQ("dup.06.01", "Result shall be non negative",
            dup_spec.filedesc>=0);

        /*
        * Return a new file descriptor which shall be the lowest numbered
        * available (that is, not already open) file descriptor greater than or
        * equal to the third argument, arg, taken as an integer of type int.
        */
        REQ("dup.fcntl.01.01.01", "Descriptor shall be lowest",
            isLowestUnused_FileDescId(ps->file_descriptors, dup_spec));

        oldDesc=getFileDescriptor(fildes);
        newDesc=getFileDescriptor(dup_spec);

        REQ("", "Descriptors shall not be NULL", oldDesc!=NULL && newDesc!=NULL);

        /*
        * The new file descriptor shall refer to the same open file
        * description as the
        * original file descriptor, and shall share any locks.
        */
        REQ("?dup.fcntl.01.01.02", "Descriptions shall be the same",
            getDescriptor_FileDescId(fildes) == getDescriptor_FileDescId(dup_spec));

        /*
        * The FD_CLOEXEC flag associated with the new file descriptor shall be
        * cleared to keep the file open across calls to one of the exec
        * functions.
        */
        REQ("?dup.fcntl.01.01.03", "FD_CLOEXEC file shall be cleared",
            getFD_CLOEXEC_FileDescId(dup_spec)==false);

        return true;
    }
}

void onDup(CallContext context, FileDescId fildes, FileDescId dup_spec)
{
    FileDescriptor* oldFd=getFileDescriptor(fildes);

    if (dup_spec.filedesc>=0)
    {
        if (oldFd!=NULL)
        {
            registerFileDescriptor( dup_spec, oldFd->file, getPath_FileDescId(fildes), getAccessMode_FileDescId(fildes),
                getBlockMode_FileDescId(fildes), getFileKind_FileDescId(fildes), false, oldFd->offset, getFdataSync_FileDescId(fildes),
                getIs64bits_FileDescId(fildes),
                getDescriptor_FileDescId(fildes));
        }
    }
}


specification
FileDescId dup2_spec(CallContext context, FileDescId  fildes, FileDescId  fildes2,
               ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    ProcessState* ps = getProcessState_CallContext(context);
    RegularFileDescriptor *desc;
    FileDescriptor* oldDesc;
    FileDescriptor* newDesc;
    LongT open_max = getSystemConfigurationValue(context, SUT_SC_OPEN_MAX);

    pre
    {
        if (file!=NULL)
        {
            /*
            * If fildes refers to a typed memory object, the result of the fcntl()
            * function is unspecified.
            */
            REQ("app.dup2.fcntl.27", "File type shall not be typed memory object",
                file->kind!=TypedMemoryObject);
        }

        return true;
    }
    post
    {
        /*
        * otherwise, -1 shall be returned and errno set to indicate the error.
        */
        /*
        * or -1 upon failure.
        */
        ERROR_BEGIN(POSIX_DUP2, "dup2.06.02;dup2.05.02", dup2_spec.filedesc==-1, *errno)

        /*
        * The dup2() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid open file descriptor or the
        * argument fildes2
        * is negative or greater than orequal to {OPEN_MAX}.
        */
        ERROR_SHALL(POSIX_DUP2, EBADF, "dup2.07.01", file==NULL || fildes2.filedesc<0 ||
            (open_max!=SC_VALUE_UNKNOWN && open_max!=SC_VALUE_NO_LIMIT && fildes2.filedesc>open_max))

        /*
        * The dup2() function shall fail if:
        *
        * [EINTR]
        *
        * The dup2() function was interrupted by a signal.
        */
        ERROR_SHALL(POSIX_DUP2, EINTR, "dup2.07.02", TODO_ERR(EINTR))

        ERROR_END()

        /*
        * Upon successful completion a non-negative integer, namely the file
        * descriptor, shall be returned;
        */
        REQ("dup2.06.01", "Returned value shall be non negative",
            dup2_spec.filedesc>=0);

        /*
        * The call:
        *
        * fid = dup2(fildes, fildes2);
        *
        * shall be equivalent to:
        *
        * close(fildes2);
        * fid = fcntl(fildes, F_DUPFD, fildes2);
        */
        REQ("dup2.01", "Further REQ's check this eqivavalence", true);

        /*
        * If fildes2 is less than 0 or greater than or equal to {OPEN_MAX},
        * dup2() shall return -1 with errno set to[EBADF].
        */
        REQ("dup2.02", "Already checked in errors", true);

        if (file!=NULL && fildes.filedesc==fildes2.filedesc)
        {
            /*
            * If fildes is a valid file descriptor and is equal to fildes2,
            * dup2() shall return fildes2 without closing it.
            */
            REQ("dup2.03", "DUP2() shall return fildes2",
                dup2_spec.filedesc==fildes2.filedesc);
        }

        /*
        * If fildes is not a valid file descriptor, dup2() shall return -1 and
        * shall not close fildes2.
        */
        REQ("dup2.04", "Already checked in errors", true);

        /*
        * The value returned shall be equal to the value of fildes2 upon
        * successful completion,
        */
        REQ("dup2.05.01", "Returned value shall be equal to fildes2",
            dup2_spec.filedesc==fildes2.filedesc);

        oldDesc=getFileDescriptor(fildes);
        newDesc=getFileDescriptor(dup2_spec);

        REQ("", "Descriptors shall not be NULL", oldDesc!=NULL && newDesc!=NULL);

        /*
        * The new file descriptor shall refer to the same open file
        * description as the
        * original file descriptor, and shall share any locks.
        */
        REQ("dup2.fcntl.01.01.02", "Descriptions shall be the same",
            getDescriptor_FileDescId(fildes) == getDescriptor_FileDescId(dup2_spec));

        /*
        * The FD_CLOEXEC flag associated with the new file descriptor shall be
        * cleared to keep the file open across calls to one of the exec
        * functions.
        */
        REQ("?dup2.fcntl.01.01.03", "FD_CLOEXEC file shall be cleared",
            getFD_CLOEXEC_FileDescId(dup2_spec)==false);

        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    fcntl -- file control

DESCRIPTION

    fcntl() is as specified in ISO POSIX (2003), but with differences as listed
    below.

    Implementation may set O_LARGEFILE

    According to ISO POSIX (2003), only an application sets fcntl() flags, for
    example O_LARGEFILE. However, this specification also allows an implementation
    to set the O_LARGEFILE flag in the case where the programming environment is
    one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
    See getconf and c99 in ISO POSIX (2003) for a description of these environments.
    Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
    as flags explicitly set by the application in the case that both the
    implementation and the application support an off_t of at least 64 bits.
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers


The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    fcntl - file control

SYNOPSIS

    #include <unistd.h>
    #include <fcntl.h>
    int fcntl(int fildes, int cmd, ...);

DESCRIPTION

    The fcntl() function shall perform the operations described below on open
    files. The fildes argument is a file descriptor.

    The available values for cmd are defined in <fcntl.h> and are as follows:

    F_DUPFD
        Return a new file descriptor which shall be the lowest numbered
        available (that is, not already open) file descriptor greater than or
        equal to the third argument, arg, taken as an integer of type int. The
        new file descriptor shall refer to the same open file description as
        the original file descriptor, and shall share any locks. The
        FD_CLOEXEC flag associated with the new file descriptor shall be
        cleared to keep the file open across calls to one of the exec
        functions.

    F_GETFD
        Get the file descriptor flags defined in <fcntl.h> that are associated
        with the file descriptor fildes. File descriptor flags are associated
        with a single file descriptor and do not affect other file descriptors
        that refer to the same file.

    F_SETFD
        Set the file descriptor flags defined in <fcntl.h>, that are
        associated with fildes, to the third argument, arg, taken as type int.
        If the FD_CLOEXEC flag in the third argument is 0, the file shall
        remain open across the exec functions; otherwise, the file shall be
        closed upon successful execution of one of the exec functions.

    F_GETFL
        Get the file status flags and file access modes, defined in <fcntl.h>,
        for the file description associated with fildes. The file access modes
        can be extracted from the return value using the mask O_ACCMODE,
        which is defined in <fcntl.h>. File status flags and file access modes
        are associated with the file description and do not affect other file
        descriptors that refer to the same file with different open file
        descriptions.

    F_SETFL
        Set the file status flags, defined in <fcntl.h>, for the file
        description associated with fildes from the corresponding bits in the
        third argument, arg, taken as type int. Bits corresponding to the file
        access mode and the file creation flags, as defined in <fcntl.h>, that
        are set in arg shall be ignored. If any bits in arg other than those
        mentioned here are changed by the application, the result is
        unspecified.

    F_GETOWN
        If fildes refers to a socket, get the process or process group ID
        specified to receive SIGURG signals when out-of-band data is available.
        Positive values indicate a process ID; negative values, other than -1,
        indicate a process group ID. If fildes does not refer to a socket, the
        results are unspecified.

    F_SETOWN
        If fildes refers to a socket, set the process or process group ID
        specified to receive SIGURG signals when out-of-band data is available,
        using the value of the third argument, arg, taken as type int.
        Positive values indicate a process ID; negative values, other than -1,
        indicate a process group ID. If fildes does not refer to a socket, the
        results are unspecified.

    The following values for cmd are available for advisory record locking.
    Record locking shall be supported for regular files, and may be supported
    for other files.

    F_GETLK
        Get the first lock which blocks the lock description pointed to by the
        third argument, arg, taken as a pointer to type struct flock, defined
        in <fcntl.h>. The information retrieved shall overwrite the
        information passed to fcntl() in the structure flock. If no lock is
        found that would prevent this lock from being created, then the
        structure shall be left unchanged except for the lock type which
        shall be set to F_UNLCK.

    F_SETLK
        Set or clear a file segment lock according to the lock description
        pointed to by the third argument, arg, taken as a pointer to type
        struct flock, defined in <fcntl.h>. F_SETLK can establish shared
        (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as
        well as to remove either type of lock (F_UNLCK). F_RDLCK, F_WRLCK, and
        F_UNLCK are defined in <fcntl.h>. If a shared or exclusive lock cannot
        be set, fcntl() shall return immediately with a return value of -1.

    F_SETLKW
        This command shall be equivalent to F_SETLK except that if a shared or
        exclusive lock is blocked by other locks, the thread shall wait until
        the request can be satisfied. If a signal that is to be caught is
        received while fcntl() is waiting for a region, fcntl() shall be
        interrupted. Upon return from the signal handler, fcntl() shall
        return -1 with errno set to [EINTR], and the lock operation shall
        not be done.

    Additional implementation-defined values for cmd may be defined in
    <fcntl.h>. Their names shall start with F_.

    When a shared lock is set on a segment of a file, other processes shall be
    able to set shared locks on that segment or a portion of it. A shared lock
    prevents any other process from setting an exclusive lock on any portion of
    the protected area. A request for a shared lock shall fail if the file
    descriptor was not opened with read access.

    An exclusive lock shall prevent any other process from setting a shared
    lock or an exclusive lock on any portion of the protected area. A request
    for an exclusive lock shall fail if the file descriptor was not opened
    with write access.

    The structure flock describes the type ( l_type), starting offset
    ( l_whence), relative offset ( l_start), size ( l_len), and process ID
    ( l_pid) of the segment of the file to be affected.

    The value of l_whence is SEEK_SET, SEEK_CUR, or SEEK_END, to indicate that
    the relative offset l_start bytes shall be measured from the start of the
    file, current position, or end of the file, respectively. The value of
    l_len is the number of consecutive bytes to be locked. The value of
    l_len may be negative (where the definition of off_t permits negative
    values of l_len). The l_pid field is only used with F_GETLK to return the
    process ID of the process holding a blocking lock. After a successful
    F_GETLK request, when a blocking lock is found, the values returned in
    the flock structure shall be as follows:

    l_type
        Type of blocking lock found.
    l_whence
        SEEK_SET.
    l_start
        Start of the blocking lock.
    l_len
        Length of the blocking lock.
    l_pid
        Process ID of the process that holds the blocking lock.

    If the command is F_SETLKW and the process must wait for another process
    to release a lock, then the range of bytes to be locked shall be
    determined before the fcntl() function blocks. If the file size or file
    descriptor seek offset change while fcntl() is blocked, this shall not
    affect the range of bytes locked.

    If l_len is positive, the area affected shall start at l_start and end at
    l_start+ l_len-1. If l_len is negative, the area affected shall start at
    l_start+ l_len and end at l_start-1. Locks may start and extend beyond the
    current end of a file, but shall not extend before the beginning of the
    file. A lock shall be set to extend to the largest possible value of the
    file offset for that file by setting l_len to 0. If such a lock also has
    l_start set to 0 and l_whence is set to SEEK_SET, the whole file shall be
    locked.

    There shall be at most one type of lock set for each byte in the file.
    Before a successful return from an F_SETLK or an F_SETLKW request when
    the calling process has previously existing locks on bytes in the region
    specified by the request, the previous lock type for each byte in the
    specified region shall be replaced by the new lock type. As specified above
    under the descriptions of shared locks and exclusive locks, an F_SETLK or
    an F_SETLKW request (respectively) shall fail or block when another process
    has existing locks on bytes in the specified region and the type of any of
    those locks conflicts with the type specified in the request.

    All locks associated with a file for a given process shall be removed when
    a file descriptor for that file is closed by that process or the process
    holding that file descriptor terminates. Locks are not inherited by a child
    process.

    A potential for deadlock occurs if a process controlling a locked region is
    put to sleep by attempting to lock another process' locked region. If the
    system detects that sleeping until a locked region is unlocked would cause
    a deadlock, fcntl() shall fail with an [EDEADLK] error.

    An unlock (F_UNLCK) request in which l_len is non-zero and the offset of
    the last byte of the requested segment is the maximum value for an object
    of type off_t, when the process has an existing lock in which l_len is 0
    and which includes the last byte of the requested segment, shall be treated
    as a request to unlock from the start of the requested segment with an
    l_len equal to 0. Otherwise, an unlock (F_UNLCK) request shall attempt to
    unlock only the requested segment.

    [SHM] [Option Start] When the file descriptor fildes refers to a shared
    memory object, the behavior of fcntl() shall be the same as for a regular
    file except the effect of the following values for the argument cmd shall
    be unspecified: F_SETFL, F_GETLK, F_SETLK, and F_SETLKW.[Option End]

    [TYM] [Option Start] If fildes refers to a typed memory object, the result
    of the fcntl() function is unspecified. [Option End]

RETURN VALUE

    Upon successful completion, the value returned shall depend on cmd as
    follows:

    F_DUPFD
        A new file descriptor.
    F_GETFD
        Value of flags defined in <fcntl.h>. The return value shall not be
        negative.
    F_SETFD
        Value other than -1.
    F_GETFL
        Value of file status flags and access modes. The return value is not
        negative.
    F_SETFL
        Value other than -1.
    F_GETLK
        Value other than -1.
    F_SETLK
        Value other than -1.
    F_SETLKW
        Value other than -1.
    F_GETOWN
        Value of the socket owner process or process group; this will not be -1.
    F_SETOWN
        Value other than -1.

    Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

    The fcntl() function shall fail if:

    [EACCES] or [EAGAIN]
        The cmd argument is F_SETLK; the type of lock ( l_type) is a shared
        (F_RDLCK) or exclusive (F_WRLCK) lock and the segment of a file to be
        locked is already exclusive-locked by another process, or the type is
        an exclusive lock and some portion of the segment of a file to be
        locked is already shared-locked or exclusive-locked by another process.

    [EBADF]
        The fildes argument is not a valid open file descriptor, or the
        argument cmd is F_SETLK or F_SETLKW, the type of lock, l_type, is a
        shared lock (F_RDLCK), and fildes is not a valid file descriptor open
        for reading, or the type of lock, l_type, is an exclusive lock
        (F_WRLCK), and fildes is not a valid file descriptor open for writing.

    [EINTR]
        The cmd argument is F_SETLKW and the function was interrupted by a
        signal.

    [EINVAL]
        The cmd argument is invalid, or the cmd argument is F_DUPFD and arg is
        negative or greater than or equal to {OPEN_MAX}, or the cmd argument
        is F_GETLK, F_SETLK, or F_SETLKW and the data pointed to by arg is not
        valid, or fildes refers to a file that does not support locking.

    [EMFILE]
        The argument cmd is F_DUPFD and {OPEN_MAX} file descriptors are
        currently open in the calling process, or no file descriptors greater
        than or equal to arg are available.

    [ENOLCK]
        The argument cmd is F_SETLK or F_SETLKW and satisfying the lock or
        unlock request would result in the number of locked regions in the
        system exceeding a system-imposed limit.

    [EOVERFLOW]
        One of the values to be returned cannot be represented correctly.

    [EOVERFLOW]
        The cmd argument is F_GETLK, F_SETLK, or F_SETLKW and the smallest or,
        if l_len is non-zero, the largest offset of any byte in the requested
        segment cannot be represented correctly in an object of type off_t.

    The fcntl() function may fail if:

    [EDEADLK]
        The cmd argument is F_SETLKW, the lock is blocked by a lock from
        another process, and putting the calling process to sleep to wait
        for that lock to become free would cause a deadlock.
*/

specification typedef struct FcntlArgument FcntlArgument = {};


specification
FileDescId fcntl_F_DUPFD_spec(CallContext context, FileDescId  fildes,
                FileDescId arg3, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    ProcessState* ps=getProcessState_CallContext(context);
    LongT open_max = getSystemConfigurationValue(context, SUT_SC_OPEN_MAX);

    pre
    {
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);
        }
        return true;

    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_DUPFD_spec.filedesc==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EINVAL]
         *
         * The cmd argument is invalid, or the cmd argument is F_DUPFD and arg is negative
         * or greater than or equal to {OPEN_MAX}, or the cmd argument is F_GETLK, F_SETLK,
         * or F_SETLKW and the data pointed to by arg is not valid, or fildes refers to a
         * file that does not support locking.
         */
        ERROR_SHALL(POSIX_FCNTL, EINVAL, "fcntl.30.04", (open_max!=SC_VALUE_UNKNOWN &&
            open_max!=SC_VALUE_NO_LIMIT && arg3.filedesc>open_max) ||  arg3.filedesc<0)

        /*
        * The fcntl() function shall fail if:
        *
        * [EMFILE]
        *
        * The argument cmd is F_DUPFD and {OPEN_MAX} file descriptors are currently open
        * in the calling process,
        */
        ERROR_SHALL3(POSIX_FCNTL, EMFILE, "fcntl.30.05.01", @isOpenFileDescNumberExceedMax(context))

        /*
        * The fcntl() function shall fail if:
        *
        * [EMFILE]
        *
        * or no file descriptors greater than or equal to arg are available.
        */
        ERROR_SHALL(POSIX_FCNTL, EMFILE, "fcntl.30.05.02", TODO_ERR(EMFILE))

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        ERROR_END()

        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_DUPFD A new file descriptor.
         */
        REQ("fcntl.28.01", "Return value shall not be -1", fcntl_F_DUPFD_spec.filedesc!=-1);

         /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_DUPFD
         *
         * Return a new file descriptor which shall be the lowest numbered available (that
         * is, not already open) file descriptor greater than or equal to the third
         * argument, arg, taken as an integer of type int.
         */
        REQ("fcntl.01.01.01", "Descriptor shall be lowest",
            isLowestUnused_FileDescId_Greater(ps->file_descriptors, fcntl_F_DUPFD_spec, arg3));

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_DUPFD
         *
         * The new file descriptor shall refer to the same open file description as the
         * original file descriptor, and shall share any locks.
         */
        REQ("?fcntl.01.01.02", "Descriptions shall be the same", getDescriptor_FileDescId(fildes)
            ==getDescriptor_FileDescId(fcntl_F_DUPFD_spec));

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_DUPFD
         *
         * The FD_CLOEXEC flag associated with the new file descriptor shall be cleared to
         * keep the file open across calls to one of the exec functions.
         */
        REQ("?fcntl.01.01.03", "FD_CLOEXEC file shall be cleared",
            getFD_CLOEXEC_FileDescId(fcntl_F_DUPFD_spec)==false);

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());

        return true;

    }

}

specification
IntT fcntl_F_GETFD_spec(CallContext context, FileDescId  fildes, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);

    pre
    {
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);
        }
        return true;

    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_GETFD_spec==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        ERROR_END()

        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_GETFD Value of flags defined in <fcntl.h>. The return value shall not be
         * negative.
         */
        REQ("fcntl.28.02", "The return value shall be not negative", fcntl_F_GETFD_spec>=0);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETFD
         *
         * Get the file descriptor flags defined in <fcntl.h> that are associated with
         * the file descriptor fildes.
         */
        REQ("fcntl.01.02.01", "Valid flag value shall be returned",
            getFD_CLOEXEC_FileDescId(fildes)==fcntl_F_GETFD_spec);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETFD
         *
         * File descriptor flags are associated with a single file descriptor and do not
         * affect other file descriptors that refer to the same file.
         */
        REQ("fcntl.01.02.02", "This REQ is caused by model", true);

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());


        return true;
    }
}


specification
IntT fcntl_F_SETFD_spec(CallContext context, FileDescId  fildes, bool fd_cloexec, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);

    pre
    {
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);
        }
        return true;
    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_SETFD_spec==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        ERROR_END()

        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_SETFD Value other than -1.
         */
        REQ("fcntl.28.03", "Function shall not return -1", fcntl_F_SETFD_spec!=-1);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_SETFD
         *
         * Set the file descriptor flags defined in <fcntl.h>, that are associated with
         * fildes, to the third argument, arg, taken as type int.
         */
        REQ("?fcntl.01.03.01", "Flag value shall be valid",
            getFD_CLOEXEC_FileDescId(fildes)==fd_cloexec);

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());

        return true;
    }
}


specification typedef struct Fcntl_F_GETFL_ReturnType Fcntl_F_GETFL_ReturnType = {};

specification
Fcntl_F_GETFL_ReturnType* fcntl_F_GETFL_spec(CallContext context, FileDescId  fildes, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);

    pre
    {
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);
        }
        return true;

    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_GETFL_spec->retVal==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        ERROR_END()


        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_GETFL Value of file status flags and access modes. The return value is not
         * negative.
         */
        REQ("fcntl.28.04", "The return value shall not be negative", fcntl_F_GETFL_spec->retVal>=0);


        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETFL
         *
         * Get the file status flags and file access modes, defined in <fcntl.h>, for
         * the file description associated with fildes.
         */
        REQ("fcntl.01.04.01", "Access mode and status flags shall be valid",
            fcntl_F_GETFL_spec->access_mode == getAccessMode_FileDescId(fildes)
            && fcntl_F_GETFL_spec->block_mode == getBlockMode_FileDescId(fildes));

        if (getDescriptor_FileDescId(fildes)!=NULL)
        {
            RegularFileDescriptor*desc=getDescriptor_FileDescId(fildes);
            REQ("", "Append flag shall be valid",
                fcntl_F_GETFL_spec->append_flag==desc->append);
        }

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETFL
         *
         * The file access modes can be extracted from the return value using the mask
         * O_ACCMODE, which is defined in <fcntl.h>.
         */
        REQ("fcntl.01.04.02", "This is done in agent", true);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETFL
         *
         * File status flags and file access modes are associated with the file
         * description and do not affect other file descriptors that refer to the same
         * file with different open file descriptions.
         */
        REQ("fcntl.01.04.03", "This REQ is caused by model", true);

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());


        return true;
    }
}


specification
IntT fcntl_F_SETFL_spec(CallContext context, FileDescId  fildes,
                        BlockMode block_mode, bool append_flag, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);

    pre
    {
         /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_SETFL
         *
         * If any bits in arg other than those mentioned here are changed by the
         * application, the result is unspecified.
         */
        REQ("app.fcntl.01.05.03", "This is inhibited by model", true);

        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);

            /*
            * [SHM] When the file descriptor fildes refers to a shared memory object, the
            * behavior of fcntl() shall be the same as for a regular file except the effect
            * of the following values for the argument cmd shall be unspecified: F_SETFL,
            * F_GETLK, F_SETLK, and F_SETLKW.
            */
            REQ("app.fcntl.26",
                "When the file descriptor fildes refers to a shared memory "
                "object",
                file->kind!=SharedMemoryObject);
        }
        return true;

    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_SETFL_spec==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        ERROR_END()


         /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_SETFL Value other than -1.
         */
        REQ("fcntl.28.05", "Function shall not return -1", fcntl_F_SETFL_spec!=-1);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_SETFL
         *
         * Set the file status flags, defined in <fcntl.h>, for the file description
         * associated with fildes from the corresponding bits in the third argument, arg,
         * taken as type int.
         */
        REQ("?fcntl.01.05.01", "Block mode shall be valid", getBlockMode_FileDescId(fildes)==block_mode);
        if (getDescriptor_FileDescId(fildes)!=NULL)
        {
            RegularFileDescriptor* desc = getDescriptor_FileDescId(fildes);
            REQ("", "Append flag shall be valid",
                desc->append==append_flag);
        }

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_SETFL
         *
         * Bits corresponding to the file access mode and the file creation flags, as
         * defined in <fcntl.h>, that are set in arg shall be ignored.
         */
        REQ("fcntl.01.05.02", "This REQ is true due to model", true);

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());


        return true;
    }
}

specification
IntT fcntl_F_GETOWN_spec(CallContext context, FileDescId  fildes, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);

    pre
    {

        if (file!=NULL)
        {
             /*
             * The fcntl() function shall perform the operations described below on open files.
             * The fildes argument is a file descriptor. The available values for cmd are
             * defined in <fcntl.h> and are as follows:
             *
             * F_GETOWN
             *
             * If fildes does not refer to a socket, the results are unspecified.
             */
            REQ("app.fcntl.01.06.03", "File kind shall be socket",
                file->kind==Socket);
        }

        return true;

    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_GETOWN_spec==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))


        ERROR_END()


        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_GETOWN Value of the socket owner process or process group; this will not be
         * -1.
         */
        REQ("fcntl.28.09", "Function shall not return -1", fcntl_F_GETOWN_spec!=-1);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETOWN
         *
         * If fildes refers to a socket, get the process or process group ID specified to
         * receive SIGURG signals when out-of-band data is available.
         */
        REQ("fcntl.01.06.01", "", TODO_REQ());

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_GETOWN
         *
         * Positive values indicate a process ID; negative values, other than -1, indicate
         * a process group ID.
         */
        REQ("fcntl.01.06.02", "", TODO_REQ());

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());

        return true;
    }
}


specification
IntT fcntl_F_SETOWN_spec(CallContext context, FileDescId  fildes, IntT thirdArg, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);

    pre
    {

        if (file!=NULL)
        {
            /*
            * The fcntl() function shall perform the operations described below on open files.
            * The fildes argument is a file descriptor. The available values for cmd are
            * defined in <fcntl.h> and are as follows:
            *
            * F_SETOWN
            *
            * If fildes does not refer to a socket, the results are unspecified.
            */
            REQ("app.fcntl.01.07.03", "File kind shall be socket",
                file->kind==Socket);
        }

        return true;

    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_SETOWN_spec==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        ERROR_END()

        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_SETOWN Value other than -1.
         */
        REQ("fcntl.28.10", "Function shll not return -1", fcntl_F_SETOWN_spec!=-1);

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_SETOWN
         *
         * If fildes refers to a socket, set the process or process group ID specified to
         * receive SIGURG signals when out-of-band data is available, using the value of
         * the third argument, arg, taken as type int.
         */
        REQ("fcntl.01.07.01", "", TODO_REQ());

        /*
         * The fcntl() function shall perform the operations described below on open files.
         * The fildes argument is a file descriptor. The available values for cmd are
         * defined in <fcntl.h> and are as follows:
         *
         * F_SETOWN
         *
         * Positive values indicate a process ID; negative values, other than -1, indicate
         * a process group ID.
         */
        REQ("fcntl.01.07.02", "", TODO_REQ());

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());

        return true;
    }
}


specification typedef struct  Fcntl_F_GETLCKReturnType Fcntl_F_GETLCKReturnType = {};


specification
Fcntl_F_GETLCKReturnType* fcntl_F_GETLCK_spec(CallContext context, FileDescId  fildes, Flock* lock, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    Flock* oldLock=clone(lock);
    Flock* blockingLock=getBlockingLock(lock, fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);

    pre
    {
        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (regdesc!=NULL)
            {
                /*
                 * [fcntl() shall not be used with lockf()]
                 *
                 */
                REQ("", "Only one type of locks shall be used", size_List(regdesc->lockfLocks)==0);
            }
        }
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);

            /*
            * [SHM] When the file descriptor fildes refers to a shared memory object, the
            * behavior of fcntl() shall be the same as for a regular file except the effect
            * of the following values for the argument cmd shall be unspecified: F_SETFL,
            * F_GETLK, F_SETLK, and F_SETLKW.
            */
            REQ("app.fcntl.26",
                "When the file descriptor fildes refers to a shared memory "
                "object",
                file->kind!=SharedMemoryObject);
        }

        return true;
    }
    post
    {
        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_GETLCK_spec->res==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         *
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EINVAL]
         *
         * The cmd argument is invalid, or the cmd argument is F_DUPFD and arg is negative
         * or greater than or equal to {OPEN_MAX}, or the cmd argument is F_GETLK, F_SETLK,
         * or F_SETLKW and the data pointed to by arg is not valid, or fildes refers to a
         * file that does not support locking.
         */
        ERROR_SHALL(POSIX_FCNTL, EINVAL, "fcntl.30.04", (file!=NULL && file->kind != RegularFile && file->kind != UnknownFileKind)
            || isLockInvalid(oldLock))


        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * The cmd argument is F_GETLK, F_SETLK, or F_SETLKW and the smallest or, if l_len
         * is non-zero, the largest offset of any byte in the requested segment cannot be
         * represented correctly in an object of type off_t.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.08", TODO_ERR(EOVERFLOW))

        ERROR_END()

        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_GETLK Value other than -1.
         */
        REQ("fcntl.28.06", "Function shall not return -1", fcntl_F_GETLCK_spec->res!=-1);


        if (blockingLock!=NULL)
        {
            /*
             * The following values for cmd are available for advisory record locking. Record
             * locking shall be supported for regular files, and may be supported for other
             * files.
             *
             * F_GETLK
             *
             * Get the first lock which blocks the lock description pointed to by the third
             * argument, arg, taken as a pointer to type struct flock, defined in <fcntl.h>.
             */
            REQ("fcntl.02.01.01", "Futher REQ's check this", true);

            /*
             * The following values for cmd are available for advisory record locking. Record
             * locking shall be supported for regular files, and may be supported for other
             * files.
             *
             * F_GETLK
             *
             * The information retrieved shall overwrite the information passed to fcntl() in
             * the structure flock.
             */
            REQ("fcntl.02.01.02", "This is checked in agent", true);

            /*
             * After a successful F_GETLK request, when a blocking lock is found, the values
             * returned in the flock structure shall be as follows:
             *
             * l_type Type of blocking lock found.
             */
            REQ("fcntl.11.01", "Type of the blocking lock shall be valid", blockingLock->l_type==fcntl_F_GETLCK_spec->lock->l_type);

            /*
             * After a successful F_GETLK request, when a blocking lock is found, the values
             * returned in the flock structure shall be as follows:
             *
             * l_whence SEEK_SET.
             */
            REQ("fcntl.11.02", "Flock shall be SEEK_SET", fcntl_F_GETLCK_spec->lock->l_whence==SEEK_SET && blockingLock->l_whence==SEEK_SET);

            /*
             * After a successful F_GETLK request, when a blocking lock is found, the values
             * returned in the flock structure shall be as follows:
             *
             * l_start Start of the blocking lock.
             */
            REQ("fcntl.11.03", "Start of the blocking lock shall be valid",
                blockingLock->l_start==fcntl_F_GETLCK_spec->lock->l_start);

            /*
             * After a successful F_GETLK request, when a blocking lock is found, the values
             * returned in the flock structure shall be as follows:
             *
             * l_len Length of the blocking lock.
             */
            REQ("fcntl.11.04", "Length shall be valid", blockingLock->l_len==fcntl_F_GETLCK_spec->lock->l_len);

            /*
             * After a successful F_GETLK request, when a blocking lock is found, the values
             * returned in the flock structure shall be as follows:
             *
             * l_pid Process ID of the process that holds the blocking lock.
             */
            /*
             * The l_pid field is only used with F_GETLK to return the process ID of the
             * process holding a blocking lock.
             */
            REQ("fcntl.10;fcntl.11.05", "PID shall be valid", blockingLock->l_pid==fcntl_F_GETLCK_spec->lock->l_pid);
        }
        else
        {
            /*
             * The following values for cmd are available for advisory record locking. Record
             * locking shall be supported for regular files, and may be supported for other
             * files.
             *
             * F_GETLK
             *
             * If no lock is found that would prevent this lock from being created, then the
             * structure shall be left unchanged except for the lock type which shall be set
             * to F_UNLCK.
             */
            REQ("fcntl.02.01.03", "Lock type shall be SUT_F_UNLCK", fcntl_F_GETLCK_spec->lock->l_type==SUT_F_UNLCK);
            oldLock->l_type=SUT_F_UNLCK;
            REQ("fcntl.02.01.03", "Lock structure shall not be changed", equals(oldLock, fcntl_F_GETLCK_spec->lock));
        }

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());

        return true;
    }
}


specification
IntT fcntl_F_SETLCK_spec(CallContext context, FileDescId  fildes, Flock* lock, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    Flock* oldLock=clone(lock);
    Flock* blockingLock=getBlockingLock(lock, fildes);
    RegularFileDescriptor* fdesc=getDescriptor_FileDescId(fildes);

    pre
    {
        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (fdesc!=NULL)
            {
                /*
                 * [fcntl() shall not be used with lockf()]
                 *
                 */
                REQ("", "Only one type of locks shall be used", size_List(fdesc->lockfLocks)==0);
            }
        }
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);

            /*
            * [SHM] When the file descriptor fildes refers to a shared memory object, the
            * behavior of fcntl() shall be the same as for a regular file except the effect
            * of the following values for the argument cmd shall be unspecified: F_SETFL,
            * F_GETLK, F_SETLK, and F_SETLKW.
            */
            REQ("app.fcntl.26",
                "When the file descriptor fildes refers to a shared memory "
                "object",
                file->kind!=SharedMemoryObject);
        }

        return true;

    }
    post
    {
        if (blockingLock!=NULL)
        {
            /*
             * The following values for cmd are available for advisory record locking. Record
             * locking shall be supported for regular files, and may be supported for other
             * files.
             *
             * F_SETLK
             *
             * If a shared or exclusive lock cannot be set, fcntl() shall return immediately
             * with a return value of -1.
             */
            REQ("fcntl.02.02.03", "Function shall return -1", fcntl_F_SETLCK_spec==-1);
        }


        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_SETLCK_spec==-1, *errno)

        /*
         * The fcntl() function shall fail if:
         *
         * [EACCES] or [EAGAIN]
         *
         * The cmd argument is F_SETLK; the type of lock ( l_type) is a shared (F_RDLCK)
         * or exclusive (F_WRLCK) lock and the segment of a file to be locked is already
         * exclusive-locked by another process, or the type is an exclusive lock and some
         * portion of the segment of a file to be locked is already shared-locked or
         * exclusive-locked by another process.
         */
        /*
         * As specified above under the descriptions of shared locks and exclusive locks,
         * an F_SETLK or an F_SETLKW request (respectively) shall fail or block when
         * another process has existing locks on bytes in the specified region and the
         * type of any of those locks conflicts with the type specified in the request.
         */
        /*
         * When a shared lock is set on a segment of a file, other processes shall be able
         * to set shared locks on that segment or a portion of it.
         */
        /*
         * A shared lock prevents any other process from setting an exclusive lock on any
         * portion of the protected area.
         */
        /*
        * An exclusive lock shall prevent any other process from setting a shared lock or
        * an exclusive lock on any portion of the protected area.
        */
        ERROR_SHALL(POSIX_FCNTL, EACCES, "fcntl.30.01;fcntl.21;fcntl.03;fcntl.04;fcntl.06", blockingLock!=NULL)
        ERROR_SHALL(POSIX_FCNTL, EAGAIN, "fcntl.30.01;fcntl.21;fcntl.03;fcntl.04;fcntl.06", blockingLock!=NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * or the argument cmd is F_SETLK or F_SETLKW, the type of lock, l_type, is a
         * shared lock (F_RDLCK), and fildes is not a valid file descriptor open for
         * reading,
         */
        /*
         * A request for a shared lock shall fail if the file descriptor was not opened
         * with read access.
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.02;fcntl.05", file!=NULL &&
         (lock->l_type==SUT_F_RDLCK && getAccessMode_FileDescId(fildes)==WriteOnly))

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * or the type of lock, l_type, is an exclusive lock (F_WRLCK), and fildes is not
         * a valid file descriptor open for writing.
         */
        /*
         * A request for an exclusive lock shall fail if the file descriptor was not
         * opened with write access.
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.03;fcntl.07", file!=NULL &&
         (lock->l_type==SUT_F_WRLCK && getAccessMode_FileDescId(fildes)==ReadOnly))

        /*
         * The fcntl() function shall fail if:
         *
         * [EINVAL]
         *
         * The cmd argument is invalid, or the cmd argument is F_DUPFD and arg is negative
         * or greater than or equal to {OPEN_MAX}, or the cmd argument is F_GETLK, F_SETLK,
         * or F_SETLKW and the data pointed to by arg is not valid, or fildes refers to a
         * file that does not support locking.
         */
         ERROR_SHALL(POSIX_FCNTL, EINVAL, "fcntl.30.04", (file!=NULL && file->kind != RegularFile && file->kind != UnknownFileKind)
            || isLockInvalid(oldLock))

        /*
         * The fcntl() function shall fail if:
         *
         * [ENOLCK]
         *
         * The argument cmd is F_SETLK or F_SETLKW and satisfying the lock or unlock
         * request would result in the number of locked regions in the system exceeding a
         * system-imposed limit.
         */
        ERROR_UNCHECKABLE(POSIX_FCNTL, ENOLCK, "fcntl.30.06", "Too implemention dependent")

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * The cmd argument is F_GETLK, F_SETLK, or F_SETLKW and the smallest or, if l_len
         * is non-zero, the largest offset of any byte in the requested segment cannot be
         * represented correctly in an object of type off_t.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.08", TODO_ERR(EOVERFLOW))

        ERROR_END()


        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_SETLK Value other than -1.
         */
        REQ("fcntl.28.07", "Function shall not return -1", fcntl_F_SETLCK_spec!=-1);


        if (fdesc!=NULL)
        {
            /*
            * There shall be at most one type of lock set for each byte in the file.
            */
            REQ("fcntl.19", "There shall be at most one type of lock set for each byte in the file",
                isOneTypeOfLock(fdesc->locks));

        }

        /*
         * The following values for cmd are available for advisory record locking. Record
         * locking shall be supported for regular files, and may be supported for other
         * files.
         *
         * F_SETLK
         *
         * F_SETLK can establish shared (or read) locks (F_RDLCK) or exclusive (or write)
         * locks (F_WRLCK), as well as to remove either type of lock (F_UNLCK). F_RDLCK,
         * F_WRLCK, and F_UNLCK are defined in <fcntl.h>.
         */
        REQ("fcntl.02.02.02", "This shall be checked in scenario", true);

        /*
        * but shall not extend before the beginning of the file.
        */
        REQ("fcntl.16.02", "", TODO_REQ());

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());


        return true;
    }
}


void onFcntl_F_SETLCK_spec(CallContext context, FileDescId  fildes, Flock* lock, IntT fcntl_F_SETLCK_spec)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* desc=getDescriptor_FileDescId(fildes);
    Flock* toAddLock;

    if (fcntl_F_SETLCK_spec!=-1 && desc!=NULL && file!=NULL)
    {
        List* locks=desc->locks;

        toAddLock=normalizeLock(context, fildes, lock);

        /*
         * If the file size or file descriptor seek offset change while fcntl() is blocked,
         * this shall not affect the range of bytes locked.
         */
        IMPLEMENT_REQ("fcntl.13");

        /*
         * Before a successful return from an F_SETLK or an F_SETLKW request when the
         * calling process has previously existing locks on bytes in the region specified
         * by the request, the previous lock type for each byte in the specified region
         * shall be replaced by the new lock type.
         */
        IMPLEMENT_REQ("fcntl.20");

        /*
         * An unlock (F_UNLCK) request in which l_len is non-zero and the offset of the
         * last byte of the requested segment is the maximum value for an object of type
         * off_t, when the process has an existing lock in which l_len is 0 and which
         * includes the last byte of the requested segment, shall be treated as a request
         * to unlock from the start of the requested segment with an l_len equal to 0.
         */
        IMPLEMENT_REQ("fcntl.24");

        /*
         * Otherwise, an unlock (F_UNLCK) request shall attempt to unlock only the
         * requested segment.
         */
        IMPLEMENT_REQ("fcntl.25");

        /*
         * The following values for cmd are available for advisory record locking. Record
         * locking shall be supported for regular files, and may be supported for other
         * files.
         *
         * F_SETLK
         *
         * Set or clear a file segment lock according to the lock description pointed to
         * by the third argument, arg, taken as a pointer to type struct flock, defined in
         * <fcntl.h>.
         */
        IMPLEMENT_REQ("fcntl.02.02.01");

        processFileLocking(locks, toAddLock);
    }
}


specification
void fcntl_F_SETLKW_spec(CallContext context, FileDescId  fildes, Flock* lock, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);

    pre
    {
        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (regdesc!=NULL)
            {
                /*
                 * [fcntl() shall not be used with lockf()]
                 *
                 */
                REQ("", "Only one type of locks shall be used", size_List(regdesc->lockfLocks)==0);
            }
        }
        if (file!=NULL)
        {
            /*
             * If fildes refers to a typed memory object, the result of the fcntl() function
             * is unspecified.
             */
            REQ("app.fcntl.27", "File kind shall not be typed memory object",
                file->kind!=TypedMemoryObject);

            /*
            * [SHM] When the file descriptor fildes refers to a shared memory object, the
            * behavior of fcntl() shall be the same as for a regular file except the effect
            * of the following values for the argument cmd shall be unspecified: F_SETFL,
            * F_GETLK, F_SETLK, and F_SETLKW.
            */
            REQ("app.fcntl.26",
                "When the file descriptor fildes refers to a shared memory "
                "object",
                file->kind!=SharedMemoryObject);
        }

        return true;

    }
    post
    {
        return true;
    }
}


specification typedef struct FcntlSETLKWCall FcntlSETLKWCall = {};


void onFcntlSETLKW(CallContext context, Flock* lock, FileDescId  fildes)
{
    RegularFileDescriptor* fdesc=getDescriptor_FileDescId(fildes);
    if (fdesc!=NULL)
    {
        append_List(fdesc->waitLocks, clone(lock));
    }

    startBlockedCall(context, create_FcntlSETLKWCall(lock, fildes, getBlockingLock(lock, fildes)));
}


void onFcntlSETLKWReturn(CallContext context, IntT fcntl_SETLKW_return_value)
{
    FcntlSETLKWCall* blocked_call=finishBlockedCall(context);
    RegularFileDescriptor* fdesc=getDescriptor_FileDescId(blocked_call->fildes);
    if (fdesc!=NULL)
    {
        remove_List(fdesc->waitLocks, indexOf_List(fdesc->waitLocks, blocked_call->lock));
    }

    onFcntl_F_SETLCK_spec(context, blocked_call->fildes, blocked_call->lock,  fcntl_SETLKW_return_value);
}

specification typedef struct fcntlSETLKWReturnType fcntlSETLKWReturnType= {};


reaction fcntlSETLKWReturnType* fcntl_F_SETLKW_return(void)
{
  post
  {
        CallContext    context=fcntl_F_SETLKW_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        FcntlSETLKWCall* fcntlCall= findBlockedCall(@getBlockedCalls(), context);
        Flock*         blockingLock=fcntlCall->blockingLock;
        RegularFileDescriptor* fdesc=getDescriptor_FileDescId(fcntlCall->fildes);
        Flock* lock=fcntlCall->lock;
        FileDescId fildes=fcntlCall->fildes;
        File* file=getFile_FileDescId(fildes);


        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_FCNTL, "fcntl.29", fcntl_F_SETLKW_return->functionResult==-1, *(fcntl_F_SETLKW_return->errno))

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid open file descriptor,
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.01", file==NULL)

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * or the argument cmd is F_SETLK or F_SETLKW, the type of lock, l_type, is a
         * shared lock (F_RDLCK), and fildes is not a valid file descriptor open for
         * reading,
         */
        /*
         * A request for a shared lock shall fail if the file descriptor was not opened
         * with read access.
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.02;fcntl.05", file!=NULL &&
         (lock->l_type==SUT_F_RDLCK && getAccessMode_FileDescId(fildes)==WriteOnly))

        /*
         * The fcntl() function shall fail if:
         *
         * [EBADF]
         *
         * or the type of lock, l_type, is an exclusive lock (F_WRLCK), and fildes is not
         * a valid file descriptor open for writing.
         */
        /*
         * A request for an exclusive lock shall fail if the file descriptor was not
         * opened with write access.
         */
        ERROR_SHALL(POSIX_FCNTL, EBADF, "fcntl.30.02.03;fcntl.07", file!=NULL &&
         (lock->l_type==SUT_F_WRLCK && getAccessMode_FileDescId(fildes)==ReadOnly))

        /*
         * The fcntl() function shall fail if:
         *
         * [EINTR]
         *
         * The cmd argument is F_SETLKW and the function was interrupted by a signal.
         */
        ERROR_SHALL(POSIX_FCNTL, EINTR, "fcntl.30.03", TODO_ERR(EINTR))

        /*
         * The fcntl() function shall fail if:
         *
         * [EINVAL]
         *
         * The cmd argument is invalid, or the cmd argument is F_DUPFD and arg is negative
         * or greater than or equal to {OPEN_MAX}, or the cmd argument is F_GETLK, F_SETLK,
         * or F_SETLKW and the data pointed to by arg is not valid, or fildes refers to a
         * file that does not support locking.
         */
         ERROR_SHALL(POSIX_FCNTL, EINVAL, "fcntl.30.04", (file!=NULL && file->kind !=RegularFile && file->kind !=UnknownFileKind)
            || isLockInvalid(lock))

        /*
         * The fcntl() function shall fail if:
         *
         * [ENOLCK]
         *
         * The argument cmd is F_SETLK or F_SETLKW and satisfying the lock or unlock
         * request would result in the number of locked regions in the system exceeding a
         * system-imposed limit.
         */
        ERROR_UNCHECKABLE(POSIX_FCNTL, ENOLCK, "fcntl.30.06", "This is implemention dependent")

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * One of the values to be returned cannot be represented correctly.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.07", TODO_ERR(EOVERFLOW))

        /*
         * The fcntl() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * The cmd argument is F_GETLK, F_SETLK, or F_SETLKW and the smallest or, if l_len
         * is non-zero, the largest offset of any byte in the requested segment cannot be
         * represented correctly in an object of type off_t.
         */
        ERROR_SHALL(POSIX_FCNTL, EOVERFLOW, "fcntl.30.08", TODO_ERR(EOVERFLOW))

        /*
         * The fcntl() function may fail if:
         *
         * [EDEADLK]
         *
         * The cmd argument is F_SETLKW, the lock is blocked by a lock from another
         * process, and putting the calling process to sleep to wait for that lock to
         * become free would cause a deadlock.
         */
        /*
         * A potential for deadlock occurs if a process controlling a locked region is put
         * to sleep by attempting to lock another process' locked region. If the system
         * detects that sleeping until a locked region is unlocked would cause a deadlock,
         * fcntl() shall fail with an [EDEADLK] error.
         */
        ERROR_MAY(POSIX_FCNTL, EDEADLK, "fcntl.31.01;fcntl.23.02", fdesc!=NULL && isFlockDeadLock(fdesc->waitLocks, fdesc->locks, lock))

        ERROR_END()

        /*
         * Upon successful completion, the value returned shall depend on cmd as follows:
         *
         * F_SETLKW Value other than -1.
         */
        REQ("fcntl.28.08", "Function shall not return -1", fcntl_F_SETLKW_return->functionResult!=-1);


        /*
         * The following values for cmd are available for advisory record locking. Record
         * locking shall be supported for regular files, and may be supported for other
         * files.
         *
         * F_SETLK
         *
         * F_SETLK can establish shared (or read) locks (F_RDLCK) or exclusive (or write)
         * locks (F_WRLCK), as well as to remove either type of lock (F_UNLCK). F_RDLCK,
         * F_WRLCK, and F_UNLCK are defined in <fcntl.h>.
         */
        REQ("fcntl.02.02.02", "This shall be checked in scenario", true);


        /*
         * The following values for cmd are available for advisory record locking. Record
         * locking shall be supported for regular files, and may be supported for other
         * files.
         *
         * F_SETLKW
         *
         * This command shall be equivalent to F_SETLK except that if a shared or
         * exclusive lock is blocked by other locks, the thread shall wait until the
         * request can be satisfied.
         */
        REQ("fcntl.02.03.01", "All other REQ's check this", true);

        /*
         * The following values for cmd are available for advisory record locking. Record
         * locking shall be supported for regular files, and may be supported for other
         * files.
         *
         * F_SETLKW
         *
         * If a signal that is to be caught is received while fcntl() is waiting for a
         * region, fcntl() shall be interrupted.
         */
        REQ("fcntl.02.03.02", "", TODO_REQ());

        /*
         * The following values for cmd are available for advisory record locking. Record
         * locking shall be supported for regular files, and may be supported for other
         * files.
         *
         * F_SETLKW
         *
         * Upon return from the signal handler, fcntl() shall return -1 with errno set to [
         * EINTR], and the lock operation shall not be done.
         */
        REQ("fcntl.02.03.03", "", TODO_REQ());

        /*
         * If the command is F_SETLKW and the process must wait for another process to
         * release a lock, then the range of bytes to be locked shall be determined before
         * the fcntl() function blocks.
         */
        REQ_UNCHECKABLE("fcntl.12", "Can't find out when this range was determined");

        /*
         * According to ISO POSIX (2003), only an application sets fcntl() flags, for
         * example O_LARGEFILE. However, this specification also allows an implementation
         * to set the O_LARGEFILE flag in the case where the programming environment is
         * one of _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, _POSIX_V6_LPBIG_OFFBIG.
         * See getconf and c99 in ISO POSIX (2003) for a description of these environments.
         * Thus, calling fcntl() with the F_GETFL command may return O_LARGEFILE as well
         * as flags explicitly set by the application in the case that both the
         * implementation and the application support an off_t of at least 64 bits.
         */
        REQ("fcntl.60", "", TODO_REQ());

  }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    fdatasync - synchronize the data of a file (REALTIME)

SYNOPSIS

    #include <unistd.h>
    int fdatasync(int fildes);

DESCRIPTION

    The fdatasync() function shall force all currently queued I/O operations
    associated with the file indicated by file descriptor fildes to the
    synchronized I/O completion state.

    The functionality shall be equivalent to fsync() with the symbol
    _POSIX_SYNCHRONIZED_IO defined, with the exception that all I/O operations
    shall be completed as defined for synchronized I/O data integrity
    completion.

RETURN VALUE

    If successful, the fdatasync() function shall return the value 0;
    otherwise, the function shall return the value -1 and set errno to
    indicate the error. If the fdatasync() function fails, outstanding I/O
    operations are not guaranteed to have been completed.

ERRORS

    The fdatasync() function shall fail if:

        [EBADF]
        The fildes argument is not a valid file descriptor open for writing.

        [EINVAL]
        This implementation does not support synchronized I/O for this file.

    In the event that any of the queued I/O operations fail, fdatasync() shall
    return the error conditions defined for read() and write().
*/
specification
IntT fdatasync_spec( CallContext context, FileDescId  fildes, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        /*
        * otherwise, the function shall return the value -1 andset errno to indicate the
        * error.
        */
        ERROR_BEGIN(POSIX_FDATASYNC, "fdatasync.03.02", fdatasync_spec==-1, *errno)
        /*
        * The fdatasync() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid file descriptor open for writing.
        */
        ERROR_SHALL(POSIX_FDATASYNC, EBADF, "fdatasync.05.01", TODO_ERR(EBADF))

        /*
        * The fdatasync() function shall fail if:
        *
        * [EINVAL]
        *
        * This implementation does not support synchronized I/O for this file.
        */
        ERROR_SHALL(POSIX_FDATASYNC, EINVAL, "fdatasync.05.02", TODO_ERR(EINVAL))

        ERROR_END()

        /*
        * If successful, the fdatasync() function shall return the value 0;
        */
        REQ("fdatasync.03.01",
            "If successful, the fdatasync() function shall return the value 0",
            fdatasync_spec==0);

        /*
        * The fdatasync() function shall force all currently queued I/O operations
        * associated with the file indicated by file descriptor fildes to the synchronized
        * I/O completion state.
        */
        REQ("fdatasync.01", "", TODO_REQ());

        /*
        * The functionality shall be equivalent to fsync()with the
        * symbol_POSIX_SYNCHRONIZED_IO defined, with the exception that all I/O operations
        * shall be completed as defined for synchronized I/O data integrity completion.
        */
        REQ("fdatasync.02", "", TODO_REQ());

        /*
        * If the fdatasync() function fails, outstanding I/O operations are not
        * guaranteed to have been completed.
        */
        REQ("fdatasync.04", "", TODO_REQ());

        /*
        * In the event that any of the queued I/O operations fail, fdatasync() shall
        * return the error conditions defined for read() and write().
        */
        REQ("fdatasync.06", "", TODO_REQ());


        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

Linux Standard Base Core Specification 3.1


NAME

    flock -- apply or remove an advisory lock on an open file

SYNOPSIS

    int flock(int fd, int operation);

DESCRIPTION

    flock() applies or removes an advisory lock on the open file fd. Valid
    operation types are:

        LOCK_SH
        Shared lock. More than one process may hold a shared lock for a given
        file at a given time.

        LOCK_EX
        Exclusive lock. Only one process may hold an exclusive lock for a given
        file at a given time.

        LOCK_UN
        Unlock.

        LOCK_NB
        Don't block when locking. May be specified (by oring) along with one
        of the other operations.

    A single file may not simultaneously have both shared and exclusive locks.

RETURN VALUE

    On success, 0 is returned. On error, -1 is returned and the global variable
    errno is set appropriately.

ERRORS

    [EWOULDBLOCK]
    The file is locked and the LOCK_NB flag was selected.
*/
specification
void flock_spec(CallContext context, FileDescId  fildes, IntT operation, IntT block,
                ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);

    pre
    {
        if (file!=NULL)
        {
            /*
             * [File shall be regular]
             */
            REQ("", "File kind shall be regular", file->kind==RegularFile);

        }
    }
    post
    {

        return true;
    }
}


specification typedef struct FlockCall FlockCall = {};


void onFlock(CallContext context, FileDescId  fildes, IntT operation, IntT block)
{
    Flock* lock=create_Flock(operation, SEEK_SET, 0, 0, context.process);
    Flock* blockingLock=NULL;
    File* file=getFile_FileDescId(fildes);

    if (file!=0 && file->size!=NULL)
    {
        lock->l_len=*(file->size);
        blockingLock=getBlockingLock(lock, fildes);
    }

    startBlockedCall(context, create_FlockCall(fildes, operation, block, blockingLock));
}


void onFlockReturn(CallContext context, IntT flock_return_value)
{
    FlockCall* blocked_call=finishBlockedCall(context);
    Flock* lock=create_Flock( blocked_call->operation, SEEK_SET, 0, 0, context.process);

    /*
    * flock() applies or removes an advisory lock on the open file fd.
    */
    IMPLEMENT_REQ("flock.01");

    /*
    *
    * LOCK_SH
    *
    * Shared lock. More than one process may hold a shared lock for a given file at a
    * given time.
    */
    IMPLEMENT_REQ("flock.02");

    /*
    *
    * LOCK_EX
    *
    * Exclusive lock. Only one process may hold an exclusive lock for a given file at
    * a given time.
    */
    IMPLEMENT_REQ("flock.03");

    /*
    * A single file may not simultaneously have both shared and exclusive locks.
    */
    IMPLEMENT_REQ("flock.04");

    /*
    *
    * LOCK_UN
    *
    * Unlock.
    */
    IMPLEMENT_REQ("flock.07");

    onFcntl_F_SETLCK_spec(context, blocked_call->fildes, lock,  flock_return_value);
}

specification typedef struct FlockReturnType FlockReturnType= {};


reaction FlockReturnType* flock_return(void)
{
    post
    {

        CallContext            context=flock_return->context;
        ProcessState*          ps=getProcessState_CallContext(context);
        FlockCall*             flCall= findBlockedCall(@getBlockedCalls(), context);
        RegularFileDescriptor* fdesc=getDescriptor_FileDescId(flCall->fildes);
        FileDescId             fildes=flCall->fildes;
        File*                  file=getFile_FileDescId(fildes);
        IntT                   operation=flCall->operation;
        IntT                   block=flCall->block;
        Flock*                 blockingLock=flCall->blockingLock;

        if (block && blockingLock!=NULL)
        {
            /*
            *
            * LOCK_NB
            *
            * Don't block when locking. May be specified (by oring) along with one of the
            * other operations.
            */
            REQ("flock.08", "Function shall wait for unblocking", flock_return->functionResult!=SUT_EWOULDBLOCK);
        }


        /*
        * On error, -1 is returned and the global variable errno is set appropriately.
        */
        ERROR_BEGIN(POSIX_FLOCK, "flock.05.02", flock_return->functionResult==-1, *(flock_return->errno))

        /*
        * [EWOULDBLOCK]
        *
        * The file is locked and the LOCK_NB flag was selected.
        *
        */
        ERROR_SHALL(POSIX_FLOCK, EWOULDBLOCK, "flock.06", file!=NULL && fdesc!=NULL && !block && blockingLock!=NULL)

        ERROR_END()

        /*
        * On success, 0 is returned.
        */
        REQ("flock.05.01",
            "On success, 0 is returned",
            flock_return->functionResult==0);

        return true;

    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers


The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    fsync - synchronize changes to a file

SYNOPSIS

    #include <unistd.h>
    int fsync(int fildes);

DESCRIPTION

    The fsync() function shall request that all data for the open file
    descriptor named by fildes is to be transferred to the storage device
    associated with the file described by fildes. The nature of the transfer
    is implementation-defined. The fsync() function shall not return until the
    system has completed that action or until an error is detected.

    If _POSIX_SYNCHRONIZED_IO is defined, the fsync() function shall force all
    currently queued I/O operations associated with the file indicated by file
    descriptor fildes to the synchronized I/O completion state. All I/O
    operations shall be completed as defined for synchronized I/O file
    integrity completion.

RETURN VALUE

    Upon successful completion, fsync() shall return 0. Otherwise, -1 shall
    be returned and errno set to indicate the error. If the fsync() function
    fails, outstanding I/O operations are not guaranteed to have been
    completed.

ERRORS

    The fsync() function shall fail if:

        [EBADF]
        The fildes argument is not a valid descriptor.

        [EINTR]
        The fsync() function was interrupted by a signal.

        [EINVAL]
        The fildes argument does not refer to a file on which this operation
        is possible.

        [EIO]
        An I/O error occurred while reading from or writing to the file system.

    In the event that any of the queued I/O operations fail, fsync() shall
    return the error conditions defined for read() and write().
*/

specification
IntT fsync_spec( CallContext context, FileDescId  fildes, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        /*
        * Otherwise, -1 shall be returned and errno set to indicate theerror.
        */
        ERROR_BEGIN(POSIX_FSYNC, "fsync.05.02", fsync_spec==-1, *errno)
        /*
        * The fsync() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid descriptor.
        */
        ERROR_SHALL(POSIX_FSYNC, EBADF, "fsync.06.01", TODO_ERR(EBADF))

        /*
        * The fsync() function shall fail if:
        *
        * [EINTR]
        *
        * The fsync() function was interrupted by a signal.
        */
        ERROR_SHALL(POSIX_FSYNC, EINTR, "fsync.06.02", TODO_ERR(EINTR))

        /*
        * The fsync() function shall fail if:
        *
        * [EINVAL]
        *
        * The fildes argument does not refer to a file on which this operation is
        * possible.
        */
        ERROR_SHALL(POSIX_FSYNC, EINVAL, "fsync.06.03", TODO_ERR(EINVAL))

        /*
        * The fsync() function shall fail if:
        *
        * [EIO]
        *
        * An I/O error occurred while reading from or writing to the file system.
        */
        ERROR_SHALL(POSIX_FSYNC, EIO, "fsync.06.04", TODO_ERR(EIO))

        ERROR_END()

        /*
        * Upon successful completion, fsync() shall return 0.
        */
        REQ("fsync.05.01",
            "Upon successful completion, fsync() shall return 0",
            fsync_spec==0);

        /*
        * The fsync() function shall request that all data for the open file descriptor
        * named by fildes is to be transferredto the storage device associated with the
        * file described by fildes.
        */
        REQ("fsync.01", "", TODO_REQ());

        /*
        * The fsync() function shall not return until the system has completed that
        * action or until an error is detected.
        */
        REQ("fsync.02", "", TODO_REQ());

        /*
        * If _POSIX_SYNCHRONIZED_IO is defined, the fsync() function shall force all
        * currently queued I/O operations associated withthe file indicated by file
        * descriptor fildes to the synchronized I/O completion state.
        */
        REQ("fsync.03", "", TODO_REQ());

        /*
        * All I/O operations shall be completedas defined for synchronized I/O file
        * integrity completion.
        */
        REQ("fsync.04", "", TODO_REQ());

        /*
        * If the fsync() function fails, outstanding I/O operations are not guaranteed to
        * have been completed.
        */
        REQ("fsync.05.03", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    ftruncate - truncate a file to a specified length

SYNOPSIS

    #include <unistd.h>
    int ftruncate(int fildes, off_t length);

DESCRIPTION

    If fildes is not a valid file descriptor open for writing, the ftruncate()
    function shall fail.

    If fildes refers to a regular file, the ftruncate() function shall cause
    the size of the file to be truncated to length. If the size of the file
    previously exceeded length, the extra data shall no longer be available to
    reads on the file. If the file previously was smaller than this size,
    ftruncate() shall either increase the size of the file or fail.

    XSI-conformant systems shall increase the size of the file.
    If the file size is increased, the extended area shall appear as if it
    were zero-filled. The value of the seek pointer shall not be modified by
    a call to ftruncate().

    Upon successful completion, if fildes refers to a regular file, the
    ftruncate() function shall mark for update the st_ctime and st_mtime fields
    of the file and the S_ISUID and S_ISGID bits of the file mode may be
    cleared. If the ftruncate() function is unsuccessful, the file is
    unaffected.

    If the request would cause the file size to exceed the soft file size limit
    for the process, the request shall fail and the implementation shall
    generate the SIGXFSZ signal for the thread.

    If fildes refers to a directory, ftruncate() shall fail.

    If fildes refers to any other file type, except a shared memory object,
    the result is unspecified.

    If fildes refers to a shared memory object, ftruncate() shall set the size
    of the shared memory object to length.

    If the effect of ftruncate() is to decrease the size of a shared memory
    object or memory mapped file and whole pages beyond the new end were
    previously mapped, then the whole pages beyond the new end shall be
    discarded.

    If the Memory Protection option is supported, references to discarded pages
    shall result in the generation of a SIGBUS signal; otherwise, the result of
    such references is undefined.

    If the effect of ftruncate() is to increase the size of a shared memory
    object, it is unspecified whether the contents of any mapped pages between
    the old end-of-file and the new are flushed to the underlying object.

RETURN VALUE

    Upon successful completion, ftruncate() shall return 0; otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS

The ftruncate() function shall fail if:

    [EINTR]
    A signal was caught during execution.

    [EINVAL]
    The length argument was less than 0.

    [EFBIG] or [EINVAL]
    The length argument was greater than the maximum file size.

    [EFBIG]
    The file is a regular file and length is greater than the offset maximum
    established in the open file description associated with fildes.

    [EIO]
    An I/O error occurred while reading from or writing to a file system.

    [EBADF] or [EINVAL]
    The fildes argument is not a file descriptor open for writing.

    [EINVAL]
    The fildes argument references a file that was opened without write
    permission.

    [EROFS]
    The named file resides on a read-only file system.
*/

/** ftruncate_spec **/
//This specification refers to: ftruncate, ftruncate64
specification
IntT ftruncate_spec(CallContext context, FileDescId  fildes,
                          OffT length, ErrorCode* errno, bool is64bits)
{
    File* file=getFile_FileDescId(fildes);
    File* oldFile;
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    OffT oldOffset;

    if (is64bits)
        FILTER("ftruncate64");
    else
        FILTER("ftruncate");

    pre
    {
        if (getFileDescriptor(fildes)!=NULL)
        {
            /*
            *  [Corresponding function shall be used for file: 64 bit function for 64 bit file]
            */
            REQ("", "Corresponding function shall be used for file",
                is64bits==getIs64bits_FileDescId(fildes));
        }

        if (file!=NULL)
        {
            /*
            * If fildes refers to any other file type, except a shared memory object, the
            * result is unspecified.
            */
            /*
            *[Shared memory not supported]
            */
            REQ("app.ftruncate.09;ftruncate64.ftruncate.09", "File kind shall be valid", file->kind==RegularFile || file->kind==DirectoryFile);

            oldFile=clone(file);
        }

        if (fdesc!=NULL)
        {
            oldOffset=fdesc->offset;
        }

        return true;
    }
    post
    {


        if (file!=NULL && file->kind==DirectoryFile)
        {
            /*
            * If fildes refers to a directory, ftruncate() shall fail.
            */
            REQ("ftruncate.08;ftruncate64.ftruncate.08", "ftruncate() shall fail", ftruncate_spec==-1);
        }

        if (ftruncate_spec==-1 && file!=NULL)
        {
            /*
            * If the ftruncate() function is unsuccessful, the file is unaffected.
            */
            REQ("?ftruncate.07;ftruncate64.ftruncate.07", "File shall be unaffected", equals(getFile_FileDescId(fildes), oldFile));
        }

        /*
        * otherwise, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_FTRUNCATE, "ftruncate.13.02;ftruncate64.ftruncate.13.02", ftruncate_spec==-1, *errno)

        /*
        * The ftruncate() function shall fail if:
        *
        * [EINTR]
        *
        * A signal was caught during execution.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EINTR, "ftruncate.14.01;ftruncate64.ftruncate.14.01", TODO_ERR(EINTR))

        /*
        * The ftruncate() function shall fail if:
        *
        * [EINVAL]
        *
        * The length argument was less than 0.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EINVAL, "ftruncate.14.02;ftruncate64.ftruncate.14.02", length<0)

        /*
        * The ftruncate() function shall fail if:
        *
        * [EFBIG] or [EINVAL]
        *
        * The length argument was greater than the maximum file size.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EFBIG, "ftruncate.14.03;ftruncate64.ftruncate.14.03", TODO_ERR(EFBIG))

        /*
        * The ftruncate() function shall fail if:
        *
        * [EFBIG]
        *
        * [XSI] The file is a regular file and length is greater than the offset maximum
        * established in the open file description associated with fildes.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EFBIG, "ftruncate.14.04;ftruncate64.ftruncate.14.04", file!=NULL && !is64bits &&
            file->kind==RegularFile && length > max_LongT)

        /*
        * The ftruncate() function shall fail if:
        *
        * [EIO]
        *
        * An I/O error occurred while reading from or writing to a file system.
        */
        ERROR_UNCHECKABLE(POSIX_FTRUNCATE, EIO, "ftruncate.14.05;ftruncate64.ftruncate.14.05", "Can not check IO errors")

        /*
        * The ftruncate() function shall fail if:
        *
        * [EBADF] or [EINVAL]
        *
        * The fildes argument is not a file descriptor open for writing.
        */
        /*
        * If fildes is not a valid file descriptor open for writing, the ftruncate()
        * function shall fail.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EBADF, "ftruncate.14.06;ftruncate.01;ftruncate64.ftruncate.01",
            file==NULL || getAccessMode_FileDescId(fildes)==ReadOnly)
        ERROR_SHALL(POSIX_FTRUNCATE, EINVAL, "ftruncate.14.06;ftruncate.01;ftruncate64.ftruncate.01",
            file==NULL || getAccessMode_FileDescId(fildes)==ReadOnly)

        /*
        * The ftruncate() function shall fail if:
        *
        * [EINVAL]
        *
        * The fildes argument references a file that was opened without write permission.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EINVAL, "ftruncate.14.07;ftruncate64.ftruncate.14.07",
            file!=NULL && getAccessMode_FileDescId(fildes)==ReadOnly)

        /*
        * The ftruncate() function shall fail if:
        *
        * [EROFS]
        *
        * The named file resides on a read-only file system.
        */
        ERROR_SHALL(POSIX_FTRUNCATE, EROFS, "ftruncate.14.08;ftruncate64.ftruncate.14.08", TODO_ERR(EROFS))

        ERROR_END()

        /*
        * Upon successful completion, ftruncate() shall return 0;
        */
        REQ("ftruncate.13.01;ftruncate64.ftruncate.13.01",
            "Upon successful completion, ftruncate() shall return 0",
            ftruncate_spec==0);

        if (fdesc!=NULL)
        {
            /*
            * The value of the seek pointer shall not be modified by a call to ftruncate().
            */
            REQ("?ftruncate.05.02;ftruncate64.ftruncate.05.02", "File pointer shall be unchanged", fdesc->offset==oldOffset);
        }

        /*
        * If the request would cause the file size to exceed the soft file size limit for
        * the process, the request shall fail and the implementation shall generate the
        * SIGXFSZ signal for the thread.
        */
        REQ("ftruncate.15;ftruncate64.ftruncate.15", "", TODO_REQ());

        /*
        * If the effect of ftruncate() is to increase the size of a shared memory object,
        * it is unspecified whether the contents of any mapped pages between the old end-
        * of-file and the new are flushed to the underlying object.
        */
        REQ("ftruncate.16;ftruncate64.ftruncate.16", "", TODO_REQ());

        return true;
    }
    FILTER_CLEAN;
}


void onFtruncate(CallContext context, FileDescId  fildes,
                    OffT length, IntT ftruncate_spec)
{

    if (ftruncate_spec!=-1)
    {
        File* file=getFile_FileDescId(fildes);
        RegularFileDescriptor* fdesc=getDescriptor_FileDescId(fildes);

        if (file!=NULL && file->kind==RegularFile)
        {
            /*
            * If fildes refers to a regular file, the ftruncate() function shall cause the
            * size of the file to be truncated to length.
            */
            IMPLEMENT_REQ("ftruncate.02;truncate.01;truncate64.truncate.01");
            /*
            * If the file previously was smaller than this size, ftruncate() shall either
            * increase the size of the file or fail.
            */
            IMPLEMENT_REQ("ftruncate.04");

            /*
            * XSI-conformant systems shall increase the size of the file.
            */
            IMPLEMENT_REQ("ftruncate.17");

            file->size=create_OffTObj(length);

            if (fdesc!=NULL)
            {
                /*
                * If the size of the file previously exceeded length, the extra data shall no
                * longer be available to reads on the file.
                */
                IMPLEMENT_REQ("ftruncate.03;truncate.02;truncate64.truncate.02");

                /*
                * If the file size is increased, the extended area shall appear as if it were
                * zero-filled.
                */
                IMPLEMENT_REQ("ftruncate.05.01;truncate.03;truncate64.truncate.03");

                fdesc->dataChunks=truncateChunksList(fdesc->dataChunks, length, context);
            }

            /*
            * Upon successful completion, if fildes refers to a regular file, the ftruncate()
            * function shall mark for update the st_ctime and st_mtime fields of the file
            */
            IMPLEMENT_REQ("ftruncate.06.01;truncate.06;truncate64.truncate.06");
            file->ctime_updated=false;
            file->mtime_updated=false;

            if (file->permissions != NULL)
            {
                /*
                * and the S_ISUID and S_ISGID bits of the file mode may be cleared.
                */
                IMPLEMENT_REQ("ftruncate.06.02;truncate.06;truncate64.truncate.06");

                file->permissions->set_uid = Unknown_Bool3;
                file->permissions->set_gid = Unknown_Bool3;
            }

        }
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    lockf - record locking on files

SYNOPSIS

    #include <unistd.h>
    int lockf(int fildes, int function, off_t size);

DESCRIPTION

    The lockf() function shall lock sections of a file with advisory-mode
    locks. Calls to lockf() from other threads which attempt to lock the
    locked file section shall either return an error value or block until
    the section becomes unlocked. All the locks for a process are removed when
    the process terminates. Record locking with lockf() shall be supported for
    regular files and may be supported for other files.

    The fildes argument is an open file descriptor. To establish a lock with
    this function, the file descriptor shall be opened with write-only
    permission (O_WRONLY) or with read/write permission (O_RDWR).

    The function argument is a control value which specifies the action to be
    taken. The permissible values for function are defined in <unistd.h>
    as follows:

    Function    Description

    F_ULOCK     Unlock locked sections.

    F_LOCK      Lock a section for exclusive use.

    F_TLOCK     Test and lock a section for exclusive use.

    F_TEST      Test a section for locks by other processes.


    F_TEST shall detect if a lock by another process is present on the
    specified section.

    F_LOCK and F_TLOCK shall both lock a section of a file if the section is
    available.

    F_ULOCK shall remove locks from a section of the file.

    The size argument is the number of contiguous bytes to be locked or
    unlocked. The section to be locked or unlocked starts at the current offset
    in the file and extends forward for a positive size or backward for a
    negative size (the preceding bytes up to but not including the current
    offset). If size is 0, the section from the current offset through the
    largest possible file offset shall be locked (that is, from the current
    offset through the present or any future end-of-file). An area need not be
    allocated to the file to be locked because locks may exist past the
    end-of-file.

    The sections locked with F_LOCK or F_TLOCK may, in whole or in part,
    contain or be contained by a previously locked section for the same
    process. When this occurs, or if adjacent locked sections would occur,
    the sections shall be combined into a single locked section. If the request
    would cause the number of locks to exceed a system-imposed limit, the
    request shall fail.

    F_LOCK and F_TLOCK requests differ only by the action taken if the section
    is not available. F_LOCK shall block the calling thread until the section
    is available. F_TLOCK shall cause the function to fail if the section is
    already locked by another process.

    File locks shall be released on first close by the locking process of any
    file descriptor for the file.

    F_ULOCK requests may release (wholly or in part) one or more locked
    sections controlled by the process. Locked sections shall be unlocked
    starting at the current file offset through size bytes or to the
    end-of-file if size is (off_t)0. When all of a locked section is not
    released (that is, when the beginning or end of the area to be unlocked
    falls within a locked section), the remaining portions of that section
    shall remain locked by the process. Releasing the center portion of a
    locked section shall cause the remaining locked beginning and end portions
    to become two separate locked sections. If the request would cause the
    number of locks in the system to exceed a system-imposed limit, the request
    shall fail.

    A potential for deadlock occurs if the threads of a process controlling a
    locked section are blocked by accessing another process' locked section.
    If the system detects that deadlock would occur, lockf() shall fail with
    an [EDEADLK] error.

    The interaction between fcntl() and lockf() locks is unspecified.

    Blocking on a section shall be interrupted by any signal.

    An F_ULOCK request in which size is non-zero and the offset of the last
    byte of the requested section is the maximum value for an object of type
    off_t, when the process has an existing lock in which size is 0 and which
    includes the last byte of the requested section, shall be treated as a
    request to unlock from the start of the requested section with a size
    equal to 0. Otherwise, an F_ULOCK request shall attempt to unlock only the
    requested section.

    Attempting to lock a section of a file that is associated with a buffered
    stream produces unspecified results.

RETURN VALUE

    Upon successful completion, lockf() shall return 0. Otherwise, it shall
    return -1, set errno to indicate an error, and existing locks shall not be
    changed.

ERRORS

    The lockf() function shall fail if:

    [EBADF]
        The fildes argument is not a valid open file descriptor; or function is
        F_LOCK or F_TLOCK and fildes is not a valid file descriptor open for
        writing.

    [EACCES] or [EAGAIN]
        The function argument is F_TLOCK or F_TEST and the section is already
        locked by another process.

    [EDEADLK]
        The function argument is F_LOCK and a deadlock is detected.

    [EINTR]
        A signal was caught during execution of the function.

    [EINVAL]
        The function argument is not one of F_LOCK, F_TLOCK, F_TEST, or
        F_ULOCK; or size plus the current file offset is less than 0.

    [EOVERFLOW]
        The offset of the first, or if size is not 0 then the last, byte in the
        requested section cannot be represented correctly in an object of type
        off_t.

    The lockf() function may fail if:

    [EAGAIN]
        The function argument is F_LOCK or F_TLOCK and the file is mapped with
        mmap().

    [EDEADLK] or [ENOLCK]
        The function argument is F_LOCK, F_TLOCK, or F_ULOCK, and the request
        would cause the number of locks to exceed a system-imposed limit.

    [EOPNOTSUPP] or [EINVAL]
        The implementation does not support the locking of files of the type
        indicated by the fildes argument.
*/


//This specification refers to: lockf64, lockf
specification
IntT lockf_F_TLOCK_spec(CallContext context, FileDescId  fildes, OffT size,
                         ErrorCode* errno, bool is64bits)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    List* oldLocks;

    if (is64bits)
        FILTER("lockf64");
    else
        FILTER("lockf");

    pre
    {

        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (regdesc!=NULL)
            {
                /*
                 * The interaction between fcntl() and lockf() locks is unspecified.
                 */
                REQ("app.lockf.25;app.lockf64.lockf.25", "Only one type of locks shall be used", size_List(regdesc->locks)==0);
            }
        }

        if (file!=NULL)
        {
            /*
            * Record locking with lockf() shall be supported for regular files and may be
            * supported for other files.
            */
            /*
             * [Function works with regular files only]
             *
             */
            REQ("app.lockf.21;app.lockf64.lockf.21", "Function works with regular files only", file->kind==RegularFile);
        }

        if (regdesc!=NULL)
        {
            oldLocks=clone(regdesc->lockfLocks);
        }

        return true;
    }
    post
    {
        if (lockf_F_TLOCK_spec==-1 && regdesc!=NULL)
        {

            /*
             * and existing locks shall not be changed.
             */
            REQ("?lockf.18.03;lockf64.lockf.18.03", "Existing locks shall not be changed", equals(regdesc->lockfLocks, oldLocks));
        }


        /*
         * Otherwise, it shall return -1, set errno to indicate an error,
         */
        ERROR_BEGIN(POSIX_LOCKF, "lockf.18.02;lockf64.lockf.18.02", lockf_F_TLOCK_spec==-1,  *errno)

        /*
        * The lockf() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid open file descriptor; or function is F_LOCK
        * or F_TLOCK and fildes is not a valid file descriptor open for writing.
        */
        /*
         * The fildes argument is an open file descriptor. To establish a lock with this
         * function, the file descriptor shall be opened with write-only permission (
         * O_WRONLY) or with read/write permission (O_RDWR).
         */
        ERROR_SHALL(POSIX_LOCKF, EBADF, "lockf.19.01;lockf.04;lockf64.lockf.04", file==NULL || getAccessMode_FileDescId(fildes)==ReadOnly)

        /*
        * The lockf() function shall fail if:
        *
        * [EACCES] or [EAGAIN]
        *
        * The function argument is F_TLOCK or F_TEST and the section is already locked by
        * another process.
        */
        /*
         * F_TLOCK shall cause the function to fail if the section is already locked by
         * another process.
         */
        /*
         * Calls to lockf() from other threads which attempt to lock the locked file
         * section shall either return an error value or block until the section becomes
         * unlocked.
         */
        ERROR_SHALL(POSIX_LOCKF, EACCES, "lockf.19.02;lockf.12.02;lockf.02;lockf64.lockf.02",
            fdesc!=NULL && regdesc!=NULL && isSectionLocked(context, fildes, regdesc->lockfLocks, fdesc->offset, size, is64bits))
        ERROR_SHALL(POSIX_LOCKF, EAGAIN, "lockf.19.02;lockf.12.02;lockf.02;lockf64.lockf.02",
            fdesc!=NULL && regdesc!=NULL && isSectionLocked(context, fildes, regdesc->lockfLocks, fdesc->offset, size, is64bits))

        /*
        * The lockf() function shall fail if:
        *
        * [EINTR]
        *
        * A signal was caught during execution of the function.
        */
        ERROR_SHALL(POSIX_LOCKF, EINTR, "lockf.19.04;lockf64.lockf.19.04", TODO_ERR(EINTR))

        /*
        * The lockf() function shall fail if:
        *
        * [EINVAL]
        *
        * The function argument is not one of F_LOCK, F_TLOCK, F_TEST, or F_ULOCK; or
        * size plus the current file offset is less than 0.
        */
        ERROR_SHALL(POSIX_LOCKF, EINVAL, "lockf.19.05;lockf64.lockf.19.05", fdesc!=NULL && fdesc->offset+size < 0)

        /*
        * The lockf() function shall fail if:
        *
        * [EOVERFLOW]
        *
        * The offset of the first, or if size is not 0 then the last, byte in the
        * requested section cannot be represented correctly in an object of type off_t.
        */
        ERROR_SHALL(POSIX_LOCKF, EOVERFLOW, "lockf.19.06;lockf64.lockf.19.06", !is64bits && fdesc!=NULL
            && fdesc->offset+size > max_LongT)

        /*
        * The lockf() function may fail if:
        *
        * [EAGAIN]
        *
        * The function argument is F_LOCK or F_TLOCK and the file is mapped with mmap().
        */
        ERROR_MAY(POSIX_LOCKF, EAGAIN, "lockf.20.01;lockf64.lockf.20.01", TODO_ERR(EAGAIN))

        /*
        * The lockf() function may fail if:
        *
        * [EDEADLK] or [ENOLCK]
        *
        * The function argument is F_LOCK, F_TLOCK, or F_ULOCK, and the request would
        * cause the number of locks to exceed a system-imposed limit.
        */
        ERROR_UNCHECKABLE(POSIX_LOCKF, EDEADLK, "lockf.20.02;lockf64.lockf.20.02", "Do not know system-imposed limit")
        ERROR_UNCHECKABLE(POSIX_LOCKF, ENOLCK, "lockf.20.02;lockf64.lockf.20.02", "Do not know system-imposed limit")

        /*
        * The lockf() function may fail if:
        *
        * [EOPNOTSUPP] or [EINVAL]
        *
        * The implementation does not support the locking of files of the type indicated
        * by the fildes argument.
        */
        ERROR_MAY(POSIX_LOCKF, EOPNOTSUPP, "lockf.20.03;lockf64.lockf.20.03", file!=NULL && file->kind!=RegularFile)
        ERROR_MAY(POSIX_LOCKF, EINVAL, "lockf.20.03;lockf64.lockf.20.03", file!=NULL && file->kind!=RegularFile)

        ERROR_END()

        /*
         * Upon successful completion, lockf() shall return 0.
         */
        REQ("lockf.18.01;lockf64.lockf.18.01",
            "Upon successful completion, lockf() shall return 0",
            lockf_F_TLOCK_spec==0);

        /*
         * Attempting to lock a section of a file that is associated with a buffered
         * stream produces unspecified results.
         */
        REQ("lockf.26;lockf64.lockf.26", "Function works with regular files only", true);

        /*
         * If the request would cause the number of locks to exceed a system-imposed limit,
         * the request shall fail.
         */
        REQ_UNCHECKABLE("lockf.11;lockf64.lockf.11", "Do not know system imposed limit");

        /*
         * If the request would cause the number of locks in the system to exceed a system-
         * imposed limit, the request shall fail.
         */
        REQ_UNCHECKABLE("lockf.23;lockf64.lockf.23", "Do not know system imposed limit");

        /*
         * All the locks for a process are removed when the process terminates.
         */
        REQ("lockf.03;lockf64.lockf.03", "", TODO_REQ());

        /*
         * File locks shall be released on first close by the locking process of any file
         * descriptor for the file.
         */
        REQ("lockf.12.03;lockf64.lockf.12.03", "", TODO_REQ());

        return true;
    }
    FILTER_CLEAN;
}


void onLockf_F_TLOCK(CallContext context, FileDescId  fildes, OffT size, bool is64bits,
                        IntT lockf_F_TLOCK_spec)
{

    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    Flock* lock;

    if (is64bits)
        FILTER("lockf64");
    else
        FILTER("lockf");

    if(lockf_F_TLOCK_spec!=-1 && fdesc!=NULL && regdesc!=NULL)
    {

        /*
         * The lockf() function shall lock sections of a file with advisory-mode locks.
         */
        IMPLEMENT_REQ("lockf.01;lockf64.lockf.01");

        /*
         * F_LOCK and F_TLOCK shall both lock a section of a file if the section is
         * available.
         */
        IMPLEMENT_REQ("lockf.06;lockf64.lockf.06");

        /*
         * An area need not be allocated to the file to be locked because locks may exist
         * past the end-of-file.
         */
        IMPLEMENT_REQ("lockf.22;lockf64.lockf.22");

        lock=createNormalizedLockfLock(context, fdesc, size, is64bits);

        /*
         * The sections locked with F_LOCK or F_TLOCK may, in whole or in part,contain or
         * be contained by a previously locked section for the same process. When this
         * occurs, or if adjacent locked sections would occur, the sections shall be
         * combined into a single locked section.
         */
        IMPLEMENT_REQ("lockf.10;lockf64.lockf.10");

        append_List(regdesc->lockfLocks, lock);
   }
    FILTER_CLEAN;
}


//This specification refers to: lockf64, lockf
specification
IntT lockf_F_UNLOCK_spec(CallContext context, FileDescId  fildes, OffT size,
                         ErrorCode* errno, bool is64bits)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    List* oldLocks;

    if (is64bits)
        FILTER("lockf64");
    else
        FILTER("lockf");

    pre
    {

        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (regdesc!=NULL)
            {
                /*
                 * The interaction between fcntl() and lockf() locks is unspecified.
                 */
                REQ("app.lockf.25;app.lockf64.lockf.25", "Only one type of locks shall be used", size_List(regdesc->locks)==0);
            }
        }

        if (file!=NULL)
        {
            /*
            * Record locking with lockf() shall be supported for regular files and may be
            * supported for other files.
            */
            /*
             * [Function works with regular files only]
             *
             */
            REQ("app.lockf.21;app.lockf64.lockf.21", "Function works with regular files only", file->kind==RegularFile);
        }

        if (regdesc!=NULL)
        {
            oldLocks=clone(regdesc->lockfLocks);
        }
        return true;
    }
    post
    {
        if (lockf_F_UNLOCK_spec==-1 && regdesc!=NULL)
        {

            /*
             * and existing locks shall not be changed.
             */
            REQ("?lockf.18.03;lockf64.lockf.18.03", "Existing locks shall not be changed", equals(regdesc->lockfLocks, oldLocks));
        }


        /*
         * Otherwise, it shall return -1, set errno to indicate an error,
         */
        ERROR_BEGIN(POSIX_LOCKF, "lockf.18.02;lockf64.lockf.18.02", lockf_F_UNLOCK_spec==-1,  *errno)

        /*
        * The lockf() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid open file descriptor; or function is F_LOCK
        * or F_TLOCK and fildes is not a valid file descriptor open for writing.
        */
        ERROR_SHALL(POSIX_LOCKF, EBADF, "lockf.19.01;lockf64.lockf.19.01", file==NULL)

        /*
        * The lockf() function shall fail if:
        *
        * [EINTR]
        *
        * A signal was caught during execution of the function.
        */
        ERROR_SHALL(POSIX_LOCKF, EINTR, "lockf.19.04;lockf64.lockf.19.04", TODO_ERR(EINTR))

        /*
        * The lockf() function shall fail if:
        *
        * [EINVAL]
        *
        * The function argument is not one of F_LOCK, F_TLOCK, F_TEST, or F_ULOCK; or
        * size plus the current file offset is less than 0.
        */
        ERROR_SHALL(POSIX_LOCKF, EINVAL, "lockf.19.05;lockf64.lockf.19.05", fdesc!=NULL && fdesc->offset+size < 0)

        /*
        * The lockf() function shall fail if:
        *
        * [EOVERFLOW]
        *
        * The offset of the first, or if size is not 0 then the last, byte in the
        * requested section cannot be represented correctly in an object of type off_t.
        */
        ERROR_SHALL(POSIX_LOCKF, EOVERFLOW, "lockf.19.06;lockf64.lockf.19.06", !is64bits && fdesc!=NULL
            && fdesc->offset+size > max_LongT)

        /*
        * The lockf() function may fail if:
        *
        * [EDEADLK] or [ENOLCK]
        *
        * The function argument is F_LOCK, F_TLOCK, or F_ULOCK, and the request would
        * cause the number of locks to exceed a system-imposed limit.
        */
        ERROR_UNCHECKABLE(POSIX_LOCKF, EDEADLK, "lockf.20.02;lockf64.lockf.20.02", "Do not know system imposed limit")

        /*
        * The lockf() function may fail if:
        *
        * [EOPNOTSUPP] or [EINVAL]
        *
        * The implementation does not support the locking of files of the type indicated
        * by the fildes argument.
        */
        ERROR_MAY(POSIX_LOCKF, EOPNOTSUPP, "lockf.20.03;lockf64.lockf.20.03", file!=NULL && file->kind!=RegularFile)
        ERROR_MAY(POSIX_LOCKF, EINVAL, "lockf.20.03;lockf64.lockf.20.03", file!=NULL && file->kind!=RegularFile)

        ERROR_END()

        /*
         * Upon successful completion, lockf() shall return 0.
         */
        REQ("lockf.18.01;lockf64.lockf.18.01",
            "Upon successful completion, lockf() shall return 0",
            lockf_F_UNLOCK_spec==0);

        /*
         * If the request would cause the number of locks to exceed a system-imposed limit,
         * the request shall fail.
         */
        REQ_UNCHECKABLE("lockf.11;lockf64.lockf.11", "Do not know system imposed limit");

        /*
         * File locks shall be released on first close by the locking process of any file
         * descriptor for the file.
         */
        REQ("lockf.12.03;lockf64.lockf.12.03", "", TODO_REQ());

        /*
         * All the locks for a process are removed when the process terminates.
         */
        REQ("lockf.03;lockf64.lockf.03", "", TODO_REQ());


        return true;
    }
    FILTER_CLEAN;
}



void onLockf_F_UNLOCK(CallContext context, FileDescId  fildes, OffT size, bool is64bits,
                     IntT lockf_F_UNLOCK_spec)
{

    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    Flock* lock;

    if (is64bits)
        FILTER("lockf64");
    else
        FILTER("lockf");

    if(lockf_F_UNLOCK_spec!=-1 && fdesc!=NULL && regdesc!=NULL)
    {

        lock=createNormalizedLockfLock(context, fdesc, size, is64bits);
        lock->l_type=SUT_F_ULOCK;

        /*
         * F_ULOCK shall remove locks from a section of the file.
         */
        IMPLEMENT_REQ("lockf.07;lockf64.lockf.07");

        /*
         * When all of a locked section is not released (that is, when the beginning or end
         * of the area to be unlocked falls within a locked section), the remaining
         * portions of that section shall remain locked by the process.
         */
        IMPLEMENT_REQ("lockf.14;lockf64.lockf.14");

        /*
         * Releasing the center portion of a locked section shall cause the remaining
         * locked beginning and end portions to become two separate locked sections.
         */
        IMPLEMENT_REQ("lockf.15;lockf64.lockf.15");

         /*
         * An F_ULOCK request in which size is non-zero and the offset of the last byte of
         * the requested section is the maximum value for an object of type off_t, when the
         * process has an existing lock in which size is 0 and which includes the last byte
         * of the requested section, shall be treated as a request to unlock from the
         * start of the requested section with a size equal to 0.
         */
        IMPLEMENT_REQ("lockf.17.01;lockf64.lockf.17.01");

        /*
         * Otherwise, an F_ULOCK request shall attempt to unlock only the requested
         * section.
         */
        IMPLEMENT_REQ("lockf.17.02;lockf64.lockf.17.02");

        unlockRegions(regdesc->lockfLocks, lock);
    }
    FILTER_CLEAN;
}


//This specification refers to: lockf64, lockf
specification
IntT lockf_F_TEST_spec(CallContext context, FileDescId  fildes, OffT size,
                         ErrorCode* errno, bool is64bits)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);

    if (is64bits)
        FILTER("lockf64");
    else
        FILTER("lockf");

    pre
    {

        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (regdesc!=NULL)
            {
                /*
                * The interaction between fcntl() and lockf() locks is unspecified.
                */
                REQ("app.lockf.25;app.lockf64.lockf.25", "Only one type of locks shall be used", size_List(regdesc->locks)==0);
            }
        }

        if (file!=NULL)
        {
            /*
            * Record locking with lockf() shall be supported for regular files and may be
            * supported for other files.
            */
            /*
             * [Function works with regular files only]
             *
             */
            REQ("app.lockf.21;app.lockf64.lockf.21", "Function works with regular files only", file->kind==RegularFile);
        }

        return true;
    }
    post
    {
        /*
         * Otherwise, it shall return -1, set errno to indicate an error,
         */
        ERROR_BEGIN(POSIX_LOCKF, "lockf.18.02;lockf64.lockf.18.02", lockf_F_TEST_spec==-1,  *errno)

        /*
        * The lockf() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid open file descriptor; or function is F_LOCK
        * or F_TLOCK and fildes is not a valid file descriptor open for writing.
        */
        ERROR_SHALL(POSIX_LOCKF, EBADF, "lockf.19.01;lockf64.lockf.19.01", file==NULL)

        /*
        * The lockf() function shall fail if:
        *
        * [EACCES] or [EAGAIN]
        *
        * The function argument is F_TLOCK or F_TEST and the section is already locked by
        * another process.
        */
        /*
         * F_TEST shall detect if a lock by another process is present on the specified
         * section.
         */
        ERROR_SHALL(POSIX_LOCKF, EACCES, "lockf.19.02;lockf.05;lockf64.lockf.05",
            fdesc!=NULL && regdesc!=NULL && isSectionLocked(context, fildes, regdesc->lockfLocks, fdesc->offset, size, is64bits))
        ERROR_SHALL(POSIX_LOCKF, EAGAIN, "lockf.19.02;lockf.05;lockf64.lockf.05",
            fdesc!=NULL && regdesc!=NULL && isSectionLocked(context, fildes, regdesc->lockfLocks, fdesc->offset, size, is64bits))

        /*
        * The lockf() function shall fail if:
        *
        * [EINTR]
        *
        * A signal was caught during execution of the function.
        */
        ERROR_SHALL(POSIX_LOCKF, EINTR, "lockf.19.04;lockf64.lockf.19.04", TODO_ERR(EINTR))

        /*
        * The lockf() function shall fail if:
        *
        * [EINVAL]
        *
        * The function argument is not one of F_LOCK, F_TLOCK, F_TEST, or F_ULOCK; or
        * size plus the current file offset is less than 0.
        */
        ERROR_SHALL(POSIX_LOCKF, EINVAL, "lockf.19.05;lockf64.lockf.19.05", fdesc!=NULL && fdesc->offset+size < 0)

        /*
        * The lockf() function shall fail if:
        *
        * [EOVERFLOW]
        *
        * The offset of the first, or if size is not 0 then the last, byte in the
        * requested section cannot be represented correctly in an object of type off_t.
        */
        ERROR_SHALL(POSIX_LOCKF, EOVERFLOW, "lockf.19.06;lockf64.lockf.19.06", !is64bits && fdesc!=NULL
            && fdesc->offset+size > max_LongT)

        ERROR_END()

        /*
         * Upon successful completion, lockf() shall return 0.
         */
        REQ("lockf.18.01;lockf64.lockf.18.01",
            "Upon successful completion, lockf() shall return 0",
            lockf_F_TEST_spec==0);

        return true;
    }
    FILTER_CLEAN;
}

//This specification refers to: lockf64, lockf
specification
void lockf_F_LOCK_spec(CallContext context, FileDescId  fildes, OffT size,
                         ErrorCode* errno, bool is64bits)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);

    if (is64bits)
        FILTER("lockf64");
    else
        FILTER("lockf");

    pre
    {

        if(!LOCKF_EQUIVALENT_TO_FCNTL)
        {
            if (regdesc!=NULL)
            {
                /*
                 * The interaction between fcntl() and lockf() locks is unspecified.
                 */
                REQ("app.lockf.25;app.lockf64.lockf.25", "Only one type of locks shall be used", size_List(regdesc->locks)==0);
            }
        }

        if (file!=NULL)
        {
            /*
            * Record locking with lockf() shall be supported for regular files and may be
            * supported for other files.
            */
            /*
             * [Function works with regular files only]
             *
             */
            REQ("app.lockf.21;app.lockf64.lockf.21", "Function works with regular files only", file->kind==RegularFile);
        }

        return true;
    }
    post
    {
        return true;
    }
    FILTER_CLEAN;
}



specification typedef struct Lockf_F_LOCKCall Lockf_F_LOCKCall = {};


void onLockf_F_LOCK(CallContext context, FileDescId  fildes, OffT size, bool is64bits)
{
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    List* oldLocks=NULL;

    if (regdesc!=NULL)
    {
        oldLocks=clone(regdesc->locks);
    }

    startBlockedCall(context, create_Lockf_F_LOCKCall( fildes, size, is64bits, oldLocks));
}


void onLockf_F_LOCKReturn(CallContext context, IntT lockf_F_LOCK_return_value)
{
    Lockf_F_LOCKCall* blocked_call=finishBlockedCall(context);
    onLockf_F_TLOCK(context, blocked_call->fildes, blocked_call->size, blocked_call->is64bits,
        lockf_F_LOCK_return_value);
}



specification typedef struct Lockf_F_LOCKReturnType Lockf_F_LOCKReturnType= {};


reaction Lockf_F_LOCKReturnType* lockf_F_LOCK_return(void)
{
  post
  {
        CallContext    context=lockf_F_LOCK_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        Lockf_F_LOCKCall* lockfCall= findBlockedCall(@getBlockedCalls(), context);

        File* file=getFile_FileDescId(lockfCall->fildes);
        FileDescriptor* fdesc=getFileDescriptor(lockfCall->fildes);
        RegularFileDescriptor* regdesc=getDescriptor_FileDescId(lockfCall->fildes);

        if (lockf_F_LOCK_return->functionResult==-1 && regdesc!=NULL)
        {

            /*
             * and existing locks shall not be changed.
             */
            REQ("?lockf.18.03;lockf64.lockf.18.03", "Existing locks shall not be changed", equals(regdesc->lockfLocks, lockfCall->oldLocks));
        }


        /*
         * Otherwise, it shall return -1, set errno to indicate an error,
         */
        ERROR_BEGIN(POSIX_LOCKF, "lockf.18.02;lockf64.lockf.18.02", lockf_F_LOCK_return->functionResult==-1,  *lockf_F_LOCK_return->errno)

        /*
        * The lockf() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not a valid open file descriptor; or function is F_LOCK
        * or F_TLOCK and fildes is not a valid file descriptor open for writing.
        */
        /*
         * The fildes argument is an open file descriptor. To establish a lock with this
         * function, the file descriptor shall be opened with write-only permission (
         * O_WRONLY) or with read/write permission (O_RDWR).
         */
        ERROR_SHALL(POSIX_LOCKF, EBADF, "lockf.19.01;lockf.04;lockf64.lockf.04", file==NULL ||
            getAccessMode_FileDescId(lockfCall->fildes)==ReadOnly)

        /*
        * The lockf() function shall fail if:
        *
        * [EDEADLK]
        *
        * The function argument is F_LOCK and a deadlock is detected.
        */
        ERROR_SHALL(POSIX_LOCKF, EDEADLK, "lockf.19.03;lockf64.lockf.19.03", fdesc!=NULL && regdesc!=NULL &&
            isLockfDeadLock(context, regdesc, fdesc, lockfCall->size, lockfCall->is64bits))

        /*
        * The lockf() function shall fail if:
        *
        * [EINTR]
        *
        * A signal was caught during execution of the function.
        */
        ERROR_SHALL(POSIX_LOCKF, EINTR, "lockf.19.04;lockf64.lockf.19.04", TODO_ERR(EINTR))

        /*
        * The lockf() function shall fail if:
        *
        * [EINVAL]
        *
        * The function argument is not one of F_LOCK, F_TLOCK, F_TEST, or F_ULOCK; or
        * size plus the current file offset is less than 0.
        */
        ERROR_SHALL(POSIX_LOCKF, EINVAL, "lockf.19.05;lockf64.lockf.19.05", fdesc!=NULL && fdesc->offset+lockfCall->size < 0)

        /*
        * The lockf() function shall fail if:
        *
        * [EOVERFLOW]
        *
        * The offset of the first, or if size is not 0 then the last, byte in the
        * requested section cannot be representedcorrectly in an object of type off_t.
        */
        ERROR_SHALL(POSIX_LOCKF, EOVERFLOW, "lockf.19.06;lockf64.lockf.19.06", !lockfCall->is64bits && fdesc!=NULL
            && fdesc->offset+lockfCall->size > max_LongT)

        /*
        * The lockf() function may fail if:
        *
        * [EAGAIN]
        *
        * The function argument is F_LOCK or F_TLOCK and the file is mapped with mmap().
        */
        ERROR_MAY(POSIX_LOCKF, EAGAIN, "lockf.20.01;lockf64.lockf.20.01", TODO_ERR(EAGAIN))

        /*
        * The lockf() function may fail if:
        *
        * [EDEADLK] or [ENOLCK]
        *
        * The function argument is F_LOCK, F_TLOCK, or F_ULOCK, and the request would
        * cause the number of locks to exceed a system-imposed limit.
        */
        /*
         * A potential for deadlock occurs if the threads of a process controlling a
         * locked section are blocked by accessing another process' locked section. If the
         * system detects that deadlock would occur, lockf() shall fail with an [EDEADLK]
         * error.
         */
        ERROR_UNCHECKABLE(POSIX_LOCKF, EDEADLK, "lockf.20.02;lockf.24;lockf64.lockf.24", "Do not know system imposed limit")

        /*
        * The lockf() function may fail if:
        *
        * [EOPNOTSUPP] or [EINVAL]
        *
        * The implementation does not support the locking of files of the type indicated
        * by the fildes argument.
        */
        ERROR_MAY(POSIX_LOCKF, EOPNOTSUPP, "lockf.20.03;lockf64.lockf.20.03", file!=NULL && file->kind!=RegularFile)
        ERROR_MAY(POSIX_LOCKF, EINVAL, "lockf.20.03;lockf64.lockf.20.03", file!=NULL && file->kind!=RegularFile)

        ERROR_END()

        /*
         * Upon successful completion, lockf() shall return 0.
         */
        REQ("lockf.18.01;lockf64.lockf.18.01",
            "Upon successful completion, lockf() shall return 0",
            lockf_F_LOCK_return->functionResult==0);


        if (fdesc!=NULL && regdesc!=NULL)
        {
            /*
             * Calls to lockf() from other threads which attempt to lock the locked file
             * section shall either return an error value or block until the section becomes
             * unlocked.
             */
            /*
             * F_LOCK shall block the calling thread until the section is available.
             */
            REQ("?lockf.02;lockf64.lockf.02;lockf.12.01;lockf64.lockf.12.01", "Section shall be locked",
                isSectionLocked(create_CallContext( -1, -1, 0), lockfCall->fildes, regdesc->lockfLocks, fdesc->offset, lockfCall->size, lockfCall->is64bits));
        }

        /*
         * All the locks for a process are removed when the process terminates.
         */
        REQ("lockf.03;lockf64.lockf.03", "", TODO_REQ());

        /*
         * File locks shall be released on first close by the locking process of any file
         * descriptor for the file.
         */
        REQ("lockf.12.03;lockf64.lockf.12.03", "", TODO_REQ());


        /*
         * Blocking on a section shall be interrupted by any signal.
         */
        REQ("lockf.16;lockf64.lockf.16", "", TODO_REQ());

        /*
         * Attempting to lock a section of a file that is associated with a buffered
         * stream produces unspecified results.
         */
        REQ("lockf.26;lockf64.lockf.26", "Function works with regular files only", true);


        return true;

  }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    lseek - move the read/write file offset

SYNOPSIS

    #include <unistd.h>
    off_t lseek(int fildes, off_t offset, int whence);

DESCRIPTION

    The lseek() function shall set the file offset for the open file
    description associated with the file descriptor fildes, as follows:

        * If whence is SEEK_SET, the file offset shall be set to offset bytes.
        * If whence is SEEK_CUR, the file offset shall be set to its current
          location plus offset.
        * If whence is SEEK_END, the file offset shall be set to the size of
          the file plus offset.

    The symbolic constants SEEK_SET, SEEK_CUR, and SEEK_END are defined in
    <unistd.h>.

    The behavior of lseek() on devices which are incapable of seeking is
    implementation-defined. The value of the file offset associated with such
    a device is undefined.

    The lseek() function shall allow the file offset to be set beyond the end
    of the existing data in the file. If data is later written at this point,
    subsequent reads of data in the gap shall return bytes with the value 0
    until data is actually written into the gap.

    The lseek() function shall not, by itself, extend the size of a file.

    If fildes refers to a shared memory object, the result of the lseek()
    function is unspecified.

    If fildes refers to a typed memory object, the result of the lseek()
    function is unspecified.

RETURN VALUE

    Upon successful completion, the resulting offset, as measured in bytes
    from the beginning of the file, shall be returned. Otherwise, (off_t)-1
    shall be returned, errno shall be set to indicate the error, and
    the file offset shall remain unchanged.

ERRORS

    The lseek() function shall fail if:

        [EBADF]
        The fildes argument is not an open file descriptor.

        [EINVAL]
        The whence argument is not a proper value, or the resulting file offset
        would be negative for a regular file, block special file, or directory.

        [EOVERFLOW]
        The resulting file offset would be a value which cannot be represented
        correctly in an object of type off_t.

        [ESPIPE]
        The fildes argument is associated with a pipe, FIFO, or socket.
*/

//This specification refers to: lseek64, lseek
specification
OffT lseek_spec(CallContext context, FileDescId  fildes, OffT offset,
                IntT whence, ErrorCode* errno, bool is64bits)
{

    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    OffT oldFileSize, oldOffset;

    if (is64bits)
        FILTER("lseek64");
    else
        FILTER("lseek");

    pre
    {
        if (file!=NULL && file->size!=NULL)
        {
            oldFileSize=*(file->size);
        }
        if (fdesc!=NULL)
        {
            oldOffset=fdesc->offset;
        }

        if (getFileDescriptor(fildes)!=NULL)
        {
            /*
            *  [Corresponding function shall be used for file: 64 bit function for 64 bit file]
            */
            REQ("", "Corresponding function shall be used for file",
                is64bits==getIs64bits_FileDescId(fildes));
        }

        if (file!=NULL)
        {
            /*
            * If fildes refers to a shared memory object, the result of the lseek() function
            * is unspecified.
            */
            REQ("app.lseek.07.01;app.lseek64.lseek.07.01", "Function argument shall not be shared memory object", file->kind!=SharedMemoryObject);

            /*
            * If fildes refers to a typed memory object, the result of the lseek() function
            * is unspecified.
            */
            REQ("app.lseek.07.02;app.lseek64.lseek.07.02", "Function argument shall not be typed memory object", file->kind!=TypedMemoryObject);
        }

        return true;
    }
    post
    {

        if (fdesc!=NULL && lseek_spec==-1)
        {
            /*
            * and the file offset shall remain unchanged.
            */
            REQ("?lseek.08.03;lseek64.lseek.08.03", "The file offset shall remain unchanged", fdesc->offset==oldOffset);
        }


        /*
        * Otherwise, (off_t)-1 shall be returned, errno shall be set to indicate the
        * error,
        */
        ERROR_BEGIN(POSIX_LSEEK, "lseek.08.02;lseek64.lseek.08.02", lseek_spec==-1, *errno )
        /*
        * The lseek() function shall fail if:
        *
        * [EBADF]
        *
        * The fildes argument is not an open file descriptor.
        */
        ERROR_SHALL(POSIX_LSEEK, EBADF, "lseek.09.01;lseek64.lseek.09.01", file==NULL)

        /*
        * The lseek() function shall fail if:
        *
        * [EINVAL]
        *
        * The whence argument is not a proper value, or the resulting file offset would
        * be negative for a regular file, block special file, or directory.
        */
        ERROR_SHALL(POSIX_LSEEK, EINVAL, "lseek.09.02;lseek64.lseek.09.02",
            (whence!=SEEK_SET && whence!=SEEK_CUR && whence!=SEEK_END) ||
            (fdesc!=NULL && file!=NULL &&
                (file->kind==RegularFile || file->kind==BlockFile || file->kind==DirectoryFile) &&
                calculateOffset(fdesc, whence, oldOffset, file->size)<0))

        /*
        * The lseek() function shall fail if:
        *
        * [EOVERFLOW]
        *
        * The resulting file offset would be a value which cannot be represented
        * correctly in an object of type off_t.
        */
        ERROR_SHALL(POSIX_LSEEK, EOVERFLOW, "lseek.09.03;lseek64.lseek.09.03",
            !is64bits && fdesc!=NULL && file!=NULL && calculateOffset(fdesc, whence, oldOffset, file->size)>max_LongT)

        /*
        * The lseek() function shall fail if:
        *
        * [ESPIPE]
        *
        * The fildes argument is associated with a pipe, FIFO, or socket.
        */
        ERROR_SHALL(POSIX_LSEEK, ESPIPE, "lseek.09.04;lseek64.lseek.09.04", file!=NULL && (file->kind==FIFOFile || file->kind==Socket))

        ERROR_END()

        if (file->size!=NULL)
        {
            /*
            * The lseek() function shall not, by itself, extend the size of a file.
            */
            REQ("?lseek.06;lseek64.lseek.06", "The lseek() function shall not, by itself, extend the size of a file.",
                *(file->size)==oldFileSize);
        }

        if (fdesc!=NULL)
        {
            /*
            * Upon successful completion, the resulting offset, as measured in bytes from the
            * beginning of the file, shall be returned.
            */
            REQ("lseek.08.01;lseek64.lseek.08.01", "Returned offset shall be valid", lseek_spec==fdesc->offset);
        }


        /*
        * If data is later written at this point, subsequent reads of data in the gap
        * shall return bytes with the value 0 until data is actually written into the gap.
        */
        REQ("lseek.05;lseek64.lseek.05", "This is caused by model", true);


        return true;
    }
    FILTER_CLEAN;
}



void onLseek(CallContext context, FileDescId  fildes, OffT offset,
                IntT whence, OffT lseek_spec)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);

    if (lseek_spec!=-1 && fdesc!=NULL && file!=NULL)
    {
        fdesc->offset=calculateOffset(fdesc, whence, offset, file->size);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------
NAME

    open - open a file

SYNOPSIS

    #include <sys/stat.h>
    #include <fcntl.h>
    int open(const char *path, int oflag, ... );

DESCRIPTION

    The open() function shall establish the connection between a file and a
    file descriptor. It shall create an open file description that refers to a
    file and a file descriptor that refers to that open file description. The
    file descriptor is used by other I/O functions to refer to that file. The
    path argument points to a pathname naming the file.

    The open() function shall return a file descriptor for the named file that
    is the lowest file descriptor not currently open for that process. The open
    file description is new, and therefore the file descriptor shall not share
    it with any other process in the system. The FD_CLOEXEC file descriptor
    flag associated with the new file descriptor shall be cleared.

    The file offset used to mark the current position within the file shall be
    set to the beginning of the file.

    The file status flags and file access modes of the open file description
    shall be set according to the value of oflag.

    Values for oflag are constructed by a bitwise-inclusive OR of flags from
    the following list, defined in <fcntl.h>. Applications shall specify
    exactly one of the first three values (file access modes) below in the
    value of oflag:

    O_RDONLY
        Open for reading only.
    O_WRONLY
        Open for writing only.
    O_RDWR
        Open for reading and writing. The result is undefined if this flag is
        applied to a FIFO.

    Any combination of the following may be used:

    O_APPEND
        If set, the file offset shall be set to the end of the file prior to
        each write.
    O_CREAT
        If the file exists, this flag has no effect except as noted under
        O_EXCL below. Otherwise, the file shall be created; the user ID of the
        file shall be set to the effective user ID of the process; the group
        ID of the file shall be set to the group ID of the file's parent
        directory or to the effective group ID of the process; and the access
        permission bits (see <sys/stat.h>) of the file mode shall be set to the
        value of the third argument taken as type mode_t modified as follows: a
        bitwise AND is performed on the file-mode bits and the corresponding
        bits in the complement of the process' file mode creation mask. Thus,
        all bits in the file mode whose corresponding bit in the file mode
        creation mask is set are cleared. When bits other than the file
        permission bits are set, the effect is unspecified. The third argument
        does not affect whether the file is open for reading, writing, or for
        both. Implementations shall provide a way to initialize the file's
        group ID to the group ID of the parent directory. Implementations may,
        but need not, provide an implementation-defined way to initialize the
        file's group ID to the effective group ID of the calling process.
    O_DSYNC
        [SIO] [Option Start] Write I/O operations on the file descriptor shall
        complete as defined by synchronized I/O data integrity completion.
    O_EXCL
        If O_CREAT and O_EXCL are set, open() shall fail if the file exists.
        The check for the existence of the file and the creation of the file
        if it does not exist shall be atomic with respect to other threads
        executing open() naming the same filename in the same directory with
        O_EXCL and O_CREAT set. If O_EXCL and O_CREAT are set, and path names
        a symbolic link, open() shall fail and set errno to [EEXIST],
        regardless of the contents of the symbolic link. If O_EXCL is set and
        O_CREAT is not set, the result is undefined.
    O_NOCTTY
        If set and path identifies a terminal device, open() shall not cause
        the terminal device to become the controlling terminal for the process.
    O_NONBLOCK

        When opening a FIFO with O_RDONLY or O_WRONLY set:

            * If O_NONBLOCK is set, an open() for reading-only shall return
              without delay. An open() for writing-only shall return an error
              if no process currently has the file open for reading.
            * If O_NONBLOCK is clear, an open() for reading-only shall block
              the calling thread until a thread opens the file for writing. An
              open() for writing-only shall block the calling thread until a
              thread opens the file for reading.

        When opening a block special or character special file that supports
        non-blocking opens:

            * If O_NONBLOCK is set, the open() function shall return without
              blocking for the device to be ready or available. Subsequent
              behavior of the device is device-specific.
            * If O_NONBLOCK is clear, the open() function shall block the
              calling thread until the device is ready or available before
              returning.

        Otherwise, the behavior of O_NONBLOCK is unspecified.
    O_RSYNC
        Read I/O operations on the file descriptor shall complete at the same
        level of integrity as specified by the O_DSYNC and O_SYNC flags. If
        both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the
        file descriptor shall complete as defined by synchronized I/O data
        integrity completion. If both O_SYNC and O_RSYNC are set in flags, all
        I/O operations on the file descriptor shall complete as defined by
        synchronized I/O file integrity completion.
    O_SYNC
        Write I/O operations on the file descriptor shall complete as defined
        by synchronized I/O file integrity completion.
    O_TRUNC
        If the file exists and is a regular file, and the file is successfully
        opened O_RDWR or O_WRONLY, its length shall be truncated to 0, and the
        mode and owner shall be unchanged. It shall have no effect on FIFO
        special files or terminal device files. Its effect on other file types
        is implementation-defined. The result of using O_TRUNC with O_RDONLY is
        undefined.

    If O_CREAT is set and the file did not previously exist, upon successful
    completion, open() shall mark for update the st_atime, st_ctime, and
    st_mtime fields of the file and the st_ctime and st_mtime fields of the
    parent directory.

    If O_TRUNC is set and the file did previously exist, upon successful
    completion, open() shall mark for update the st_ctime and st_mtime fields
    of the file.

    If both the O_SYNC and O_DSYNC flags are set, the effect is as if only
    the O_SYNC flag was set. [Option End]

    If path refers to a STREAMS file, oflag may be constructed from O_NONBLOCK
    OR'ed with either O_RDONLY, O_WRONLY, or O_RDWR. Other flag values are not
    applicable to STREAMS devices and shall have no effect on them. The value
    O_NONBLOCK affects the operation of STREAMS drivers and certain functions
    applied to file descriptors associated with STREAMS files. For STREAMS
    drivers, the implementation of O_NONBLOCK is device-specific.

    If path names the master side of a pseudo-terminal device, then it is
    unspecified whether open() locks the slave side so that it cannot be
    opened. Conforming applications shall call unlockpt() before opening
    the slave side.

    The largest value that can be represented correctly in an object of type
    off_t shall be established as the offset maximum in the open file
    description.

RETURN VALUE

    Upon successful completion, the function shall open the file and return a
    non-negative integer representing the lowest numbered unused file
    descriptor. Otherwise, -1 shall be returned and errno set to indicate the
    error. No files shall be created or modified if the function returns -1.

ERRORS

    The open() function shall fail if:

    [EACCES]
        Search permission is denied on a component of the path prefix, or the
        file exists and the permissions specified by oflag are denied, or the
        file does not exist and write permission is denied for the parent
        directory of the file to be created, or O_TRUNC is specified and write
        permission is denied.
    [EEXIST]
        O_CREAT and O_EXCL are set, and the named file exists.
    [EINTR]
        A signal was caught during open().
    [EINVAL]
        [SIO] [Option Start] The implementation does not support synchronized
        I/O for this file. [Option End]
    [EIO]
        [XSR] [Option Start] The path argument names a STREAMS file and a
        hangup or error occurred during the open().
    [EISDIR]
        The named file is a directory and oflag includes O_WRONLY or O_RDWR.
    [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path argument.
    [EMFILE]
        {OPEN_MAX} file descriptors are currently open in the calling process.
    [ENAMETOOLONG]
        The length of the path argument exceeds {PATH_MAX} or a pathname
        component is longer than {NAME_MAX}.
    [ENFILE]
        The maximum allowable number of files is currently open in the system.
    [ENOENT]
        O_CREAT is not set and the named file does not exist; or O_CREAT is set
        and either the path prefix does not exist or the path argument points
        to an empty string.
    [ENOSR]
        The path argument names a STREAMS-based file and
        the system is unable to allocate a STREAM.
    [ENOSPC]
        The directory or file system that would contain the new file cannot be
        expanded, the file does not exist, and O_CREAT is specified.
    [ENOTDIR]
        A component of the path prefix is not a directory.
    [ENXIO]
        O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no
        process has the file open for reading.
    [ENXIO]
        The named file is a character special or block special file, and the
        device associated with this special file does not exist.
    [EOVERFLOW]
        The named file is a regular file and the size of the file cannot be
        represented correctly in an object of type off_t.
    [EROFS]
        The named file resides on a read-only file system and either O_WRONLY,
        O_RDWR, O_CREAT (if the file does not exist), or O_TRUNC is set in the
        oflag argument.

    The open() function may fail if:

    [EAGAIN]
        The path argument names the slave side of a
        pseudo-terminal device that is locked.
    [EINVAL]
        The value of the oflag argument is not valid.
    [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path argument.
    [ENAMETOOLONG]
        As a result of encountering a symbolic link in resolution of the path
        argument, the length of the substituted pathname string exceeded
        {PATH_MAX}.
    [ENOMEM]
        The path argument names a STREAMS file and the
        system is unable to allocate resources.
    [ETXTBSY]
        The file is a pure procedure (shared text) file that is being executed
        and oflag is O_WRONLY or O_RDWR.
*/

//This specification refers to: open64, open
specification
FileDescId open_spec(CallContext context, CString* path, OpenFlags oflag,
                     FilePermissions* mode, ErrorCode* errno, bool is64bits )
{
    File* openedFile;
    FileDescriptor* openedFileDesc;
    ProcessState* ps=getProcessState_CallContext(context);
    RegularFileDescriptor *desc;
    Bool3 isELOOP;
    FileSystem *pre_fs = clone(getFileSystem(context));
    CString *absPath = resolvePath_Ext(context, pre_fs, path, &isELOOP);
    Bool3 fileExists=doesFileExist_FileSystem( pre_fs, absPath);
    File* oldFile=NULL;

    if (is64bits)
        FILTER("open64");
    else
        FILTER("open");

    pre
    {
        /*
        * Values for oflag are constructed by a bitwise-inclusive OR of flags from the
        * following list, defined in <fcntl.h>.>Applications shall specify exactly one
        * of the first three values (file access modes) below in the value of oflag:
        *
        * O_RDONLY
        *
        * Open for reading only.
        *
        * O_WRONLY
        *
        * Open for writing only.
        *
        * O_RDWR
        *
        * Open for reading and writing. The result is undefined if this flag is applied
        * to a FIFO.
        *
        */
        REQ("?app.open.104;app.open64.open.104", "Open flag shall be valid", oflag.access_mode==ReadOnly || oflag.access_mode==WriteOnly
            || oflag.access_mode==ReadWrite);

        if (fileExists==True_Bool3)
        {
            oldFile=clone(getFile_FileSystem(getFileSystem(context), absPath));
        }

        /*
        * If O_EXCL is set and O_CREAT is not set, the result is undefined.
        */
        if(oflag.excl)
        {
            REQ("app.open.08.04;app.open64.open.08.04", "O_CREAT shall be set", oflag.creat==true);
        }

        if (oflag.creat)
        {
            /*
            * When bits other than the file permission bits are set, the effect is
            * unspecified.
            *
            */
            REQ("app.open.06.06;app.open64.open.06.06", "Model inhibits invalid flag values", true);
        }
        if (oflag.trunc)
        {
            /*
            * The result of using O_TRUNC with O_RDONLY is undefined.
            */
            REQ("app.open.13.04;app.open64.open.13.04", "O_RDONLY shall not be set",
                oflag.access_mode!=ReadOnly);

            if (fileExists==True_Bool3)
            {
                /*
                * Its effect on other file types is implementation-defined.
                */
                REQ("app.open.13.03;app.open64.open.13.03", "File type shall be valid",
                    oldFile->kind==RegularFile ||
                    oldFile->kind==FIFOFile);
            }
        }


        if (oflag.block_mode==Nonblocking && fileExists==True_Bool3)
        {
            /*
            * Otherwise, the behavior of O_NONBLOCK is unspecified.
            *
            */
            REQ("app.open.10.05;app.open64.open.10.05", "File type shall be valid for O_NONBLOCK",
                (oldFile->kind==FIFOFile &&
                (oflag.access_mode==ReadOnly || oflag.access_mode==WriteOnly))
                || oldFile->kind == BlockFile || oldFile->kind == CharacterFile);
        }
        return true;
    }
    post
    {

        if (oflag.excl && oflag.creat && fileExists)
        {
            File* exFile=getFile_FileSystem(getFileSystem(context), absPath);
            /*
            * If the file exists, this flag has no effect except as noted under O_EXCL below.
            *
            */
            /*
            * If O_CREAT and O_EXCL are set, open() shall fail if the file exists.
            *
            */
            REQ("open.06.01;open.08.01;open64.open.08.01", "Function shall fail", open_spec.filedesc==-1);


            if (exFile->kind==SymbolicLinkFile)
            {
                /*
                * If O_EXCL and O_CREAT are set, and path names a symbolic link, open() shall
                * fail and set errno to [EEXIST], regardless of the contents of the symbolic link.
                *
                */
                REQ("open.08.03;open64.open.08.03", "Function shall fail with EEXIST", open_spec.filedesc==-1 && *errno==SUT_EEXIST);
            }
        }

        if (open_spec.filedesc==-1)
        {
            if (fileExists==False_Bool3)
            {
                /*
                * No files shall be created or modified if the function returns -1.
                *
                */
                REQ("?open.30.03;open64.open.30.03", "File shall not be created",
                    doesFileExist_FileSystem(getFileSystem(context), absPath)==False_Bool3);
            }
        }

        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         */
        ERROR_BEGIN(POSIX_OPEN, "open.30.02;open64.open.30.02", open_spec.filedesc==-1, *errno )
        /*
         * The open() function shall fail if:
         *
         * [EACCES]
         *
         * Search permission is denied on a component of the path prefix, or the file
         * exists and the permissions specified by oflag are denied, or the file does not
         * exist and write permission is denied for the parent directory of the file to be
         * created, or O_TRUNC is specified and write permission is denied.
         */
         ERROR_SHALL3(POSIX_OPEN, EACCES, "open.31.01;open64.open.31.01", isEACCES_io_file_open(context, pre_fs, absPath, fileExists, oflag))

        /*
         * The open() function shall fail if:
         *
         * [EEXIST]
         *
         * O_CREAT and O_EXCL are set, and the named file exists.
         */
        ERROR_SHALL(POSIX_OPEN, EEXIST, "open.31.02;open64.open.31.02", oflag.creat && oflag.excl && fileExists==True_Bool3)

        /*
         * The open() function shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during open().
         */
        ERROR_SHALL(POSIX_OPEN, EINTR, "open.31.03;open64.open.31.03", TODO_ERR(EINTR))

        /*
         * The open() function shall fail if:
         *
         * [EINVAL]
         *
         * [SIO] The implementation does not support synchronized I/O for this file.
         */
        ERROR_SHALL(POSIX_OPEN, EINVAL, "open.31.04;open64.open.31.04", TODO_ERR(EINVAL))

        /*
         * The open() function shall fail if:
         *
         * [EIO]
         *
         * [XSR] The path argument names a STREAMS file and a hangup or error occurred
         * during the open().
         */
        ERROR_SHALL(POSIX_OPEN, EIO, "open.31.05;open64.open.31.05", TODO_ERR(EIO))

        /*
         * The open() function shall fail if:
         *
         * [EISDIR]
         *
         * The named file is a directory and oflag includes O_WRONLY or O_RDWR.
         */
        ERROR_SHALL(POSIX_OPEN, EISDIR, "open.31.06;open64.open.31.06",
            (fileExists == Unknown_Bool3
              &&
             errNo == SUT_EISDIR
            )
            ||
            (fileExists == True_Bool3
              &&
             oldFile->kind==DirectoryFile
              &&
             (oflag.access_mode == ReadWrite || oflag.access_mode == WriteOnly)
            ));

        /*
         * The open() function shall fail if:
         *
         * [ELOOP]
         *
         * A loop exists in symbolic links encountered during resolution of the path
         * argument.
         */
        ERROR_SHALL3(POSIX_OPEN, ELOOP, "open.31.07;open64.open.31.07", isELOOP)

        /*
         * The open() function shall fail if:
         *
         * [EMFILE]
         *
         * {OPEN_MAX} file descriptors are currently open in the calling process.
         */
        ERROR_SHALL3(POSIX_OPEN, EMFILE, "open.31.08;open64.open.31.08", @isOpenFileDescNumberExceedMax(context))

        /*
         * The open() function shall fail if:
         *
         * [ENAMETOOLONG]
         *
         * The length of the path argument exceeds {PATH_MAX} or a pathname component is
         * longer than {NAME_MAX}.
         */
        ERROR_SHALL3(POSIX_OPEN, ENAMETOOLONG, "open.31.09;open64.open.31.09",  isENAMETOOLONG(context, path))

        /*
         * The open() function shall fail if:
         *
         * [ENFILE]
         *
         * The maximum allowable number of files is currently open in the system.
         */
        ERROR_UNCHECKABLE(POSIX_OPEN, ENFILE, "open.31.10;open64.open.31.10", "ENFILE could not be checked")

        /*
         * The open() function shall fail if:
         *
         * [ENOENT]
         *
         * O_CREAT is not set and the named file does not exist; or O_CREAT is set and
         * either the path prefix does not exist or the path argument points to an empty
         * string.
         */
        /*
        ERROR_SHALL(POSIX_OPEN, ENOENT, "open.31.11;open64.open.31.11", (oflag.creat==false && fileExists==False_Bool3)||
            (oflag.creat && (isENOENT_dir(context, pre_fs, getParentDir_Path(absPath ))==True_Bool3)))
        */
        ERROR_SHALL(POSIX_OPEN, ENOENT, "open.31.11;open64.open.31.11", TODO_ERR(ENOENT));

        /*
         * The open() function shall fail if:
         *
         * [ENOSR]
         *
         * [XSR] The path argument names a STREAMS-based file and the system is unable to
         * allocate a STREAM.
         */
        ERROR_SHALL(POSIX_OPEN, ENOSR, "open.31.12;open64.open.31.12", TODO_ERR(ENOSR))

        /*
         * The open() function shall fail if:
         *
         * [ENOSPC]
         *
         * The directory or file system that would contain the new file cannot be expanded,
         * the file does not exist, and O_CREAT is specified.
         */
        ERROR_SHALL(POSIX_OPEN, ENOSPC, "open.31.13;open64.open.31.13", TODO_ERR(ENOSPC))

        /*
         * The open() function shall fail if:
         *
         * [ENOTDIR]
         *
         * A component of the path prefix is not a directory.
         */
        ERROR_SHALL3(POSIX_OPEN, ENOTDIR, "open.31.14;open64.open.31.14", isENOTDIR_dir(context, pre_fs, getParentDir_Path(absPath)))


        /*
         * The open() function shall fail if:
         *
         * [ENXIO]
         *
         * The named file is a character special or block special file, and the device
         * associated with this special file does not exist.
         */
        ERROR_SHALL(POSIX_OPEN, ENXIO, "open.31.16;open64.open.31.16", TODO_ERR(ENXIO))

        /*
         * The open() function shall fail if:
         *
         * [EOVERFLOW]
         *
         * The named file is a regular file and the size of the file cannot be represented
         * correctly in an object of type off_t.
         *
         * The open() function shall fail if:
         *
         * [EOVERFLOW]
         * The named file is a regular file and either O_LARGEFILE is not set and
         * the size of the file cannot be represented correctly in an object of
         * type off_t or O_LARGEFILE is set and the size of the file cannot be
         * represented correctly in an object of type off64_t.
         */
        ERROR_SHALL(POSIX_OPEN, EOVERFLOW, "open.31.17;open64.open.31.17", TODO_ERR(EOVERFLOW))

        /*
         * The open() function shall fail if:
         *
         * [EROFS]
         *
         * The named file resides on a read-only file system and either O_WRONLY, O_RDWR,
         * O_CREAT (if the file does not exist), or O_TRUNCis set in the oflag argument.
         */
        ERROR_SHALL(POSIX_OPEN, EROFS, "open.31.18;open64.open.31.18", TODO_ERR(EROFS))

        /*
         * The open() function may fail if:
         *
         * [EINVAL]
         *
         * The value of the oflag argument is not valid.
         */
        ERROR_UNCHECKABLE(POSIX_OPEN, EINVAL, "open.32.02;open64.open.32.02", "Model inhibits the invalid oflag values")

        /*
         * The open() function may fail if:
         *
         * [ELOOP]
         *
         * More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
         * the path argument.
         */
        ERROR_MAY3(POSIX_OPEN, ELOOP, "open.32.03;open64.open.32.03", isELOOP)

        /*
         * The open() function may fail if:
         *
         * [ENAMETOOLONG]
         *
         * As a result of encountering a symbolic link in resolution of the path argument,
         * the length of the substituted pathname string exceeded {PATH_MAX}.
         */
        ERROR_MAY3(POSIX_OPEN, ENAMETOOLONG, "open.32.04;open64.open.32.04", isENAMETOOLONG(context, absPath))

        /*
         * The open() function may fail if:
         *
         * [ENOMEM]
         *
         * [XSR] The path argument names a STREAMS file and the system is unable to
         * allocate resources.
         */
        ERROR_MAY(POSIX_OPEN, ENOMEM, "open.32.05;open64.open.32.05", TODO_ERR(ENOMEM))

        /*
         * The open() function may fail if:
         *
         * [ETXTBSY]
         *
         * The file is a pure procedure (shared text) file that is being executed and
         * oflag is O_WRONLY or O_RDWR.
         */
        ERROR_MAY(POSIX_OPEN, ETXTBSY, "open.32.06;open64.open.32.06", TODO_ERR(ETXTBSY))

        ERROR_END()


        openedFile=getFile_FileDescId(open_spec);
        openedFileDesc=getFileDescriptor(open_spec);
        if (openedFile!=NULL && openedFile->kind==RegularFile)
        {
            desc=getDescriptor_FileDescId(open_spec);
        }

        /*
         * The open() function shall establish the connection between a file and a file
         * descriptor. It shall create an open file description that refers to a file and
         * a file descriptor that refers to that open file description.
         *
         */
        REQ("open.01;open64.open.01", "File descriptor shall not be NULL", openedFileDesc!=NULL);

        /*
         * The open() function shall return a file descriptor for the named file that is
         * the lowest file descriptor not currently open for that process.
         *
         */
        /*
         * Upon successful completion, the function shall open the file and return a non-
         * negative integer representing the lowest numbered unused file descriptor.
         *
         */
        REQ("open.02.01;open.30.01;open64.open.30.01", "Descriptor shall be lowest",
            isLowestUnused_FileDescId(ps->file_descriptors, open_spec));

        /*
         * The open file description is new, and therefore the file descriptor shall not
         * share it with any other process in the system.
         */
        REQ_UNCHECKABLE("open.02.02;open64.open.02.02", "Can not detect file sharing");

        if (openedFile->kind==RegularFile)
        {
            /*
             * The FD_CLOEXEC file descriptor flag associated with the new file descriptor
             * shall be cleared.
             *
             */
            REQ("?open.02.03;open64.open.02.03", "FD_CLOEXEC flag shall be cleared",
                desc!=NULL && getFD_CLOEXEC_FileDescId(open_spec)==false);

            /*
             * The file offset used to mark the current position within the file shall be set
             * to the beginning of the file.
             */
            REQ("?open.03;open64.open.03", "The file offset shall be set to the beginning of the file",
                openedFileDesc->offset==0);

        }

        /*
         * The file status flags and file access modes of the open file description shall
         * be set according to the value of oflag.
         *
         */
        REQ("?open.04;open64.open.04", "Access mode shall be valid", getAccessMode_FileDescId(open_spec)
            ==oflag.access_mode);

        if (fileExists==False_Bool3 && oflag.creat)
        {
            /*
            * Otherwise, the file shall be created;
            *
            */
            REQ("?open.06.02;open64.open.06.02","File shall be created", openedFile!=NULL);

            /*
             * the user ID of the file shall be set to the effective user ID of the process;
             *
             */
            REQ("?open.06.03;open64.open.06.03", "User ID of the file shall be valid",
                equals(openedFile->uid, create_UidTObj(ps->meta.effective_userid)));
            {
                /*
                 * the group ID of the file shall be set to the group ID of the file's parent
                 * directory or to the effective group ID of the process;
                 *
                 */
                CString* parPath=getParentDir_Path(absPath);
                File* parentDir=getFile_FileSystem(getFileSystem(context), parPath);

                REQ("?open.06.04;open64.open.06.04", "Group ID shall be valid",
                    equals(openedFile->gid, create_GidTObj(ps->meta.effective_groupid)) ||
                    equals(openedFile->gid, parentDir->gid));
            }

            /*
             * and the access permission bits (see <sys/stat.h>) of the file mode shall be
             * set to the value of the third argument taken as type mode_t modified as follows:
             * a bitwise AND is performed on the file-mode bits and the corresponding bits in
             * the complement of the process' file mode creation mask. Thus, all bits in the
             * file mode whose corresponding bit in the file mode creation mask is set are
             * cleared.
             *
             */
            REQ("?open.06.05;open64.open.06.05", "Permissions shall be valid",
                equals(openedFile->permissions, ANDPermissions(ps->meta.umask, mode)));

            /*
            * If O_CREAT is set and the file did not previously exist, upon successful
            * completion, open() shall mark for update the st_atime, st_ctime, and st_mtime
            * fields of the file and the st_ctime and st_mtime fields of the parent directory.
            *
            */
            REQ("?open.14;open64.open.14", "Time shall be marked for update", openedFile->atime_updated==false &&
                openedFile->ctime_updated==false && openedFile->mtime_updated==false);

        }

        /*
         * The check for the existence of the file and the creation of the file if it does
         * not exist shall be atomic with respect to other threads executing open() naming
         * the same filename in the same directory with O_EXCL and O_CREAT set.
         *
         */
        IMPLEMENT_REQ("open.08.02;open64.open.08.02");

        if (oflag.trunc)
        {
            if (fileExists==True_Bool3 && oflag.access_mode!=ReadOnly)
            {
                /*
                 * If the file exists and is a regular file, and the file is successfully opened
                 * O_RDWR or O_WRONLY, its length shall be truncated to 0, and the mode and owner
                 * shall be unchanged.
                 *
                 */
                if (!SKIP_OPEN_CHECK)
                {
                    REQ("?open.13.01;open64.open.13.01", "File parameters shall be unchanged and size shall be zero",
                        openedFile->size==0 && equals(openedFile->permissions, oldFile->permissions)
                        && equals(openedFile->uid, oldFile->uid));
                }
            }


            /*
            * If O_TRUNC is set and the file did previously exist, upon successful completion,
            * open() shall mark for update the st_ctime and st_mtime fields of the file.
            *
            */
            REQ("?open.15;open64.open.15", "File time shall be updated", openedFile->ctime_updated==false &&
                openedFile->mtime_updated==false);

        }

        /*
         * O_DSYNC
         *
         * [SIO] Write I/O operations on the file descriptor shall complete as defined by
         * synchronized I/O data integrity completion.
         *
         */
        REQ("open.07;open64.open.07", "", TODO_REQ());


        /*
         * If both the O_SYNC and O_DSYNC flags are set, the effect is as if only the
         * O_SYNC flag was set.
         *
         */
        REQ("open.16;open64.open.16", "", TODO_REQ());

        /*
         * If path refers to a STREAMS file, oflag may be constructed from O_NONBLOCK OR'
         * ed with either O_RDONLY, O_WRONLY, or O_RDWR. Other flag values are not
         * applicable to STREAMS devices and shall have no effect on them.
         *
         */
        REQ("open.17;open64.open.17", "", TODO_REQ());

        /*
         * If O_NONBLOCK is set, the open() function shall return without blocking for the
         * device to be ready or available.
         *
         */
        REQ("open.10.03;open64.open.10.03", "", TODO_REQ());

        /*
         * If O_NONBLOCK is clear, the open() function shall block the calling thread
         * until the device is ready or available before returning.
         *
         */
        REQ("open.10.04;open64.open.10.04", "", TODO_REQ());

        /*
         * Read I/O operations on the file descriptor shall complete at the same level of
         * integrity as specified by the O_DSYNC and O_SYNC flags.
         *
         */
        REQ("open.11.01;open64.open.11.01", "", TODO_REQ());

        /*
         * If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file
         * descriptor shall complete as defined by synchronized I/O data integrity
         * completion.
         *
         */
        REQ("open.11.02;open64.open.11.02", "", TODO_REQ());

        /*
         * If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file
         * descriptor shall complete as defined by synchronized I/O file integrity
         * completion.
         *
         */
        REQ("open.11.03;open64.open.11.03", "", TODO_REQ());

        /*
         * O_SYNC
         *
         * [SIO] Write I/O operations on the file descriptor shall complete as defined by
         * synchronized I/O file integrity completion.
         *
         */
        REQ("open.12;open64.open.12", "", TODO_REQ());


        /*
         * The largest value that can be represented correctly in an object of type off_t
         * shall be established as the offset maximum in the open file description.
         *
         */
        REQ("open.19;open64.open.19", "", TODO_REQ());


        return true;
    }
    FILTER_CLEAN;
}

void onOpen( CallContext context, CString* path, OpenFlags oflag, FilePermissions* mode, FileDescId open_spec, bool is64bits )
{
    ProcessState* ps=getProcessState_CallContext(context);
    FileSystem*   file_system = getFileSystem(context);
    Bool3         eloop;
    CString*      resolved=resolvePath_Ext(context, file_system, path, &eloop);
    CString*      parPath=getParentDir_Path(resolved);
    Bool3         fileExists=doesFileExist_FileSystem(file_system, resolved);
    File*         file = getFile_FileSystem( file_system, resolved );
    File*         parentDir=getFile_FileSystem(getFileSystem(context), parPath);

    if (open_spec.filedesc >= 0)
    {
        if (oflag.trunc && fileExists==True_Bool3)
        {
            updateCtimePath(context, file_system, resolved);
            updateMtimePath(context, file_system, resolved);
        }
        if (oflag.creat && fileExists==False_Bool3)
        {
            updateAtimePath(context, file_system, resolved);
            updateCtimePath(context, file_system, resolved);
            updateMtimePath(context, file_system, resolved);

            updateCtimePath(context, file_system, parPath);
            updateMtimePath(context, file_system, parPath);
        }

        if (file == NULL)
        {
            file = registerFile( file_system, path );
            file->kind=RegularFile;
        }
        if (file != NULL)
        {
            RegularFileDescriptor* descr=create_DefaultRegularFileDescriptor();
            descr->append=oflag.append;

            if (fileExists==False_Bool3)
            {
                registerFileDescriptor( open_spec, file->fileid, path, oflag.access_mode,
                    oflag.block_mode, RegularFile, false, (OffT)0, true, is64bits, descr);
                file->permissions=ANDPermissions(ps->meta.umask, mode);
                file->uid=create_UidTObj(ps->meta.effective_userid);

                if(FILE_IO_OPEN_SETS_GID_TO_PROCESS_GID)
                {
                    file->gid=create_GidTObj(ps->meta.effective_groupid);
                }else{
                    if (parentDir!=NULL && parentDir->gid!=NULL)
                    {
                        file->gid=clone(parentDir->gid);
                    }
                }
                file->descriptor=descr;

                file->kind=RegularFile;
                file->size=create_OffTObj(0);

            }
            else
            {
                if (file->descriptor==NULL)
                {
                    if (file->kind==RegularFile)
                    {
                        registerFileDescriptor( open_spec, file->fileid, path, oflag.access_mode,
                            oflag.block_mode, file->kind, false, (OffT)0, true, is64bits, descr);
                        file->descriptor=descr;
                        descr->notExternallyModified=false;
                    }
                    else
                    {
                        registerFileDescriptor( open_spec, file->fileid, path, oflag.access_mode,
                            oflag.block_mode, file->kind, false, (OffT)0, true, is64bits, NULL);
                    }
                }
                else
                {
                    registerFileDescriptor( open_spec, file->fileid, path, oflag.access_mode,
                        oflag.block_mode, file->kind, false, (OffT)0, true, is64bits, file->descriptor);
                }

                if (file->kind==RegularFile && oflag.access_mode!=ReadOnly && oflag.trunc)
                {
                    file->size=create_OffTObj(0);
                }
            }
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

    The Open Group Base Specifications Issue 6
    IEEE Std 1003.1, 2004 Edition
    Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
    -------------------------------------------------------------------------------

      NAME

        pread, read - read from a file

          SYNOPSIS

            #include <unistd.h>
            ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
            ssize_t read(int fildes, void *buf, size_t nbyte);

              DESCRIPTION

                The read() function shall attempt to read nbyte bytes from the file
                associated with the open file descriptor, fildes, into the buffer pointed
                to by buf. The behavior of multiple concurrent reads on the same pipe,
                FIFO, or terminal device is unspecified.

                  Before any action described below is taken, and if nbyte is zero, the
                  read() function may detect and return errors as described below. In the
    absence of errors, or if error detection is not performed, the read() f
    unction shall return zero and have no other results.

    On files that support seeking (for example, a regular file), the read()
    shall start at a position in the file given by the file offset associated
    with fildes. The file offset shall be incremented by the number of bytes
    actually read.

    Files that do not support seeking-for example, terminals-always read from
    the current position. The value of a file offset associated with such a
    file is undefined.

    No data transfer shall occur past the current end-of-file. If the starting
    position is at or after the end-of-file, 0 shall be returned. If the file
    refers to a device special file, the result of subsequent read() requests
    is implementation-defined.

    If the value of nbyte is greater than {SSIZE_MAX}, the result is
    implementation-defined.

    When attempting to read from an empty pipe or FIFO:

        * If no process has the pipe open for writing, read() shall return 0
          to indicate end-of-file.
        * If some process has the pipe open for writing and O_NONBLOCK is set,
          read() shall return -1 and set errno to [EAGAIN].
        * If some process has the pipe open for writing and O_NONBLOCK is
          clear, read() shall block the calling thread until some data is
          written or the pipe is closed by all processes that had the pipe open
          for writing.

    When attempting to read a file (other than a pipe or FIFO) that supports
    non-blocking reads and has no data currently available:

        * If O_NONBLOCK is set, read() shall return -1 and set errno to
          [EAGAIN].
        * If O_NONBLOCK is clear, read() shall block the calling thread until
          some data becomes available.
        * The use of the O_NONBLOCK flag has no effect if there is some data
           available.

    The read() function reads data previously written to a file . If any
    portion of a regular file prior to the end-of-file has not been written,
    read() shall return bytes with value 0. For example, lseek() allows the
    file offset to be set beyond the end of existing data in the file. If data
    is later written at this point, subsequent reads in the gap between the
    previous end of data and the newly written data shall return bytes with
    value 0 until data is written into the gap.

    Upon successful completion, where nbyte is greater than 0, read() shall
    mark for update the st_atime field of the file, and shall return the number
    of bytes read. This number shall never be greater than nbyte. The value
    returned may be less than nbyte if the number of bytes left in the file is
    less than nbyte, if the read() request was interrupted by a signal, or if
    the file is a pipe or FIFO or special file and has fewer than nbyte bytes
    immediately available for reading. For example, a read() from a file
    associated with a terminal may return one typed line of data.

    If a read() is interrupted by a signal before it reads any data, it shall
    return -1 with errno set to [EINTR].

    If a read() is interrupted by a signal after it has successfully read some
    data, it shall return the number of bytes read.

    For regular files, no data transfer shall occur past the offset maximum
    established in the open file description associated with fildes.

    If fildes refers to a socket, read() shall be equivalent to recv() with
    no flags set.

    If the O_DSYNC and O_RSYNC bits have been set, read
    I/O operations on the file descriptor shall complete as defined by
    synchronized I/O data integrity completion. If the O_SYNC and O_RSYNC bits
    have been set, read I/O operations on the file descriptor shall complete as
    defined by synchronized I/O file integrity completion.

    If fildes refers to a shared memory object, the result
    of the read() function is unspecified.

    If fildes refers to a typed memory object, the result of the read()
    function is unspecified.

    A read() from a STREAMS file can read data in three different modes:
    byte-stream mode, message-nondiscard mode, and message-discard mode. The
    default shall be byte-stream mode. This can be changed using the I_SRDOPT
    ioctl() request, and can be tested with I_GRDOPT ioctl(). In byte-stream
    mode, read() shall retrieve data from the STREAM until as many bytes as
    were requested are transferred, or until there is no more data to be
    retrieved. Byte-stream mode ignores message boundaries.

    In STREAMS message-nondiscard mode, read() shall retrieve data until as
    many bytes as were requested are transferred, or until a message boundary
    is reached. If read() does not retrieve all the data in a message, the
    remaining data shall be left on the STREAM, and can be retrieved by the
    next read() call. Message-discard mode also retrieves data until as many
    bytes as were requested are transferred, or a message boundary is reached.
    However, unread data remaining in a message after the read() returns shall
    be discarded, and shall not be available for a subsequent read(), getmsg(),
    or getpmsg() call.

    How read() handles zero-byte STREAMS messages is determined by the current
    read mode setting. In byte-stream mode, read() shall accept data until it
    has read nbyte bytes, or until there is no more data to read, or until a
    zero-byte message block is encountered. The read() function shall then
    return the number of bytes read, and place the zero-byte message back on
    the STREAM to be retrieved by the next read(), getmsg(), or getpmsg(). In
    message-nondiscard mode or message-discard mode, a zero-byte message shall
    return 0 and the message shall be removed from the STREAM. When a zero-byte
    message is read as the first message on a STREAM, the message shall be
    removed from the STREAM and 0 shall be returned, regardless of the read
    mode.

    A read() from a STREAMS file shall return the data in the message at the
    front of the STREAM head read queue, regardless of the priority band of
    the message.

    By default, STREAMs are in control-normal mode, in which a read() from a
    STREAMS file can only process messages that contain a data part but do not
    contain a control part. The read() shall fail if a message containing a
    control part is encountered at the STREAM head. This default action can be
    changed by placing the STREAM in either control-data mode or
    control-discard mode with the I_SRDOPT ioctl() command. In control-data
    mode, read() shall convert any control part to data and pass it to the
    application before passing any data part originally present in the same
    message. In control-discard mode, read() shall discard message control
    parts but return to the process any data part in the message.

    In addition, read() shall fail if the STREAM head had processed an
    asynchronous error before the call. In this case, the value of errno shall
    not reflect the result of read(), but reflect the prior error. If a hangup
    occurs on the STREAM being read, read() shall continue to operate normally
    until the STREAM head read queue is empty. Thereafter, it shall return 0.

    The pread() function shall be equivalent to read(), except that it shall
    read from a given position in the file without changing the file pointer.
    The first three arguments to pread() are the same as read() with the
    addition of a fourth argument offset for the desired position inside the
    file. An attempt to perform a pread() on a file that is incapable of
    seeking shall result in an error.

RETURN VALUE

    Upon successful completion, read() and pread() shall return a non-negative
    integer indicating the number of bytes actually read. Otherwise,
    the functions shall return -1 and set errno to indicate the error.

ERRORS

    The read() and pread()functions shall fail if:

    [EAGAIN]
        The O_NONBLOCK flag is set for the file descriptor and the thread would
        be delayed.

    [EBADF]
        The fildes argument is not a valid file descriptor open for reading.

    [EBADMSG]
        The file is a STREAM file that is set to
        control-normal mode and the message waiting to be read includes a
        control part.

    [EINTR]
        The read operation was terminated due to the receipt of a signal, and
        no data was transferred.

    [EINVAL]
        The STREAM or multiplexer referenced by fildes is linked (directly or
        indirectly) downstream from a multiplexer.

    [EIO]
        The process is a member of a background process attempting to read from
        its controlling terminal, the process is ignoring or blocking the
        SIGTTIN signal, or the process group is orphaned. This error may also
        be generated for implementation-defined reasons.

    [EISDIR]
        The fildes argument refers to a directory and the implementation does
        not allow the directory to be read using read() or pread(). The
        readdir() function should be used instead.

    [EOVERFLOW]
        The file is a regular file, nbyte is greater than 0, the starting
        position is before the end-of-file, and the starting position is
        greater than or equal to the offset maximum established in the open
        file description associated with fildes.

    The read() function shall fail if:

    [EAGAIN] or [EWOULDBLOCK]
        The file descriptor is for a socket, is marked O_NONBLOCK, and no data
        is waiting to be received.

    [ECONNRESET]
        A read was attempted on a socket and the connection was forcibly
        closed by its peer.

    [ENOTCONN]
        A read was attempted on a socket that is not connected.

    [ETIMEDOUT]
        A read was attempted on a socket and a transmission timeout occurred.

    The read() and pread() functions may fail if:

    [EIO]
        A physical I/O error has occurred.

    [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.

    [ENOMEM]
        Insufficient memory was available to fulfill the request.

    [ENXIO]
        A request was made of a nonexistent device, or the request was outside
        the capabilities of the device.

    The pread() function shall fail, and the file pointer shall remain
    unchanged, if:

    [EINVAL]
        The offset argument is invalid. The value is negative.

    [EOVERFLOW]
        The file is a regular file and an attempt was made to read at or beyond
        the offset maximum associated with the file.

    [ENXIO]
        A request was outside the capabilities of the device.

    [ESPIPE]
        A fildes is associated with a pipe or FIFO.
*/

//This specification refers to: pread64, pread
specification
SSizeT pread_spec(CallContext context, FileDescId fildes, VoidTPtr buf,
                  SizeT nbyte, OffT offset, ErrorCode* errno, bool is64bits)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* desc=getDescriptor_FileDescId(fildes);

    if (is64bits)
        FILTER("pread64");
    else
        FILTER("pread");

    pre
    {
        if (getFileDescriptor(fildes)!=NULL)
        {
            /*
            *  [Corresponding function shall be used for file: 64 bit function for 64 bit file]
            */
            REQ("", "Corresponding function shall be used for file",
                is64bits==getIs64bits_FileDescId(fildes));
        }

        if (file!=NULL)
        {
            /*
             * [Function works with regular files and directory files only]
             *
             */
            REQ("", "Function works with regular files and directory files only",
                file->kind==DirectoryFile || file->kind==RegularFile);
        }


        /*
        * If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.
        *
        */
        REQ("app.pread.51;app.pread64.pread.51", "The value of nbyte shall be less than {SSIZE_MAX}",
            (nbyte <= (SizeT)max_SSizeT));

        return true;
    }
    post
    {

        /*
         * Before any action described below is taken, and if nbyte is zero, the read()
         * function may detect and return errors as described below.
         *
         */
        REQ("pread.03;pread64.pread.03", "This is checked below", true);


        if (!POSIX_READ_PERFORMS_ERRORS_DETECTION && nbyte==0)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the read()
             * function shall return zero and have no other results.
             *
             */
            REQ("pread.04;pread64.pread.04", "Function shall return zero", pread_spec==0);

            return true;
        }


        /*
         * Otherwise, the functions shall return -1 and set errno to indicate the error.
         *
         */
        ERROR_BEGIN(POSIX_PREAD, "pread.41.02;pread64.pread.41.02", pread_spec==-1, *errno)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EAGAIN]
         *
         * The O_NONBLOCK flag is set for the file descriptor and the thread would be
         * delayed.
         *
         */
        ERROR_SHALL3(POSIX_PREAD, EAGAIN, "pread.42.01;pread64.pread.42.01", isO_NONBLOCKset(fildes))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid file descriptor open for reading.
         *
         */
        ERROR_SHALL(POSIX_PREAD, EBADF, "pread.42.02;pread64.pread.42.02", file==NULL || getAccessMode_FileDescId(fildes)==WriteOnly)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EINTR]
         *
         * The read operation was terminated due to the receipt of a signal, and no data
         * was transferred.
         *
         */
        ERROR_SHALL(POSIX_PREAD, EINTR, "pread.42.04;pread64.pread.42.04", TODO_ERR(EINTR))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EISDIR]
         *
         * [XSI] The fildes argument refers to a directory and the implementation does
         * not allow the directory to be read using read() or pread(). The readdir()
         * function should be used instead.
         *
         */
        ERROR_SHALL(POSIX_PREAD, EISDIR, "pread.42.07;pread64.pread.42.07", file!=NULL && file->kind==DirectoryFile &&
            POSIX_DIRECTORY_READ_NOT_ALLOWED)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * The file is a regular file, nbyte is greater than 0, the starting position is
         * before the end-of-file, and the starting position is greater than or equal to
         * the offset maximum established in the open file description associated with
         * fildes.
         *
         */
        ERROR_SHALL(POSIX_PREAD, EOVERFLOW, "pread.42.08;pread64.pread.42.08", file!=NULL && file->kind==RegularFile
            && file->size!=NULL && offset<*(file->size) && !is64bits && offset >= max_LongT)

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [EIO]
         *
         * A physical I/O error has occurred.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PREAD, EIO, "pread.44.01;pread64.pread.44.01", "Can not check IO errors")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOBUFS]
         *
         * Insufficient resources were available in the system to perform the operation.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PREAD, ENOBUFS, "pread.44.02;pread64.pread.44.02", "Can not check insufficient resources case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOMEM]
         *
         * Insufficient memory was available to fulfill the request.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PREAD, ENOMEM, "pread.44.03;pread64.pread.44.03", "Can not check insufficient memory case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENXIO]
         *
         * A request was made of a nonexistent device, or the request was outside the
         * capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PREAD, ENXIO, "pread.44.04;pread64.pread.44.04", "Can not check details about devices")

        /*
         * The pread() function shall fail, and the file pointer shall remain unchanged,
         * if:
         *
         * [EINVAL]
         *
         * [XSI] The offset argument is invalid. The value is negative.
         *
         */
        ERROR_SHALL(POSIX_PREAD, EINVAL, "pread.45.01;pread64.pread.45.01", offset<0)

        /*
         * The pread() function shall fail, and the file pointer shall remain unchanged,
         * if:
         *
         * [EOVERFLOW]
         *
         * [XSI] The file is a regular file and an attempt was made to read at or beyond
         * the offset maximum associated with the file.
         *
         */
         ERROR_SHALL(POSIX_PREAD, EOVERFLOW, "pread.45.02;pread64.pread.45.02", !is64bits && offset>=max_LongT)

        /*
         * The pread() function shall fail, and the file pointer shall remain unchanged,
         * if:
         *
         * [ENXIO]
         *
         * [XSI] A request was outside the capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PREAD, ENXIO, "pread.45.03;pread64.pread.45.03", "Can not check details about devices")


        ERROR_END()


        /*
         * Upon successful completion, read() [XSI]  and pread() shall return a non-
         * negative integer indicating the number of bytes actually read.
         *
         */
        REQ("pread.41.01;pread64.pread.41.01", "Return value shall be non negative", pread_spec>=0);

        if (nbyte==0)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the read()
             * function shall return zero and have no other results.
             *
             */
            REQ("pread.04;pread64.pread.04", "Function shall return zero", pread_spec==0);
        }


        /*
         * The read() function shall attempt to read nbyte bytes from the file associated
         * with the open file descriptor, fildes, into the buffer pointed to by buf.
         *
         */
        REQ("pread.01;pread64.pread.01", "This is done in agent", true);


        if (file->size!=NULL)
        {
            if (offset>=*(file->size))
            {
                /*
                 * If the starting position is at or after the end-of-file, 0 shall be returned.
                 *
                 */
                REQ("pread.08;pread64.pread.08", "Function shall return zero", pread_spec==0);
            }

            if (offset+nbyte>*(file->size))
            {
                /*
                 * The value returned may be less than nbyte
                 *
                 * if the number of bytes left in the file is less than nbyte,
                 */
                REQ("pread.14.01;pread64.pread.14.01", "The value returned shall be less than nbyte", pread_spec<nbyte);
            }

        }

        /*
         * and shall return the number of bytes read. This number shall never be greater
         * than nbyte.
         *
         */
        REQ("pread.13.02;pread64.pread.13.02", "Number of bytes read shall never be greater than nbyte", pread_spec<=nbyte);


        if (!is64bits)
        {
            /*
             * For regular files, no data transfer shall occur past the offset maximum
             * established in the open file description associated with fildes.
             *
             */
            REQ("pread.17;pread64.pread.17", "No data transfer shall occur past the offset maximum", offset+pread_spec<=(LongT)max_LongT);
        }



        if (desc!=NULL && desc->notExternallyModified)
        {

            /*
             * The read() function reads data previously written to a file.
             *
             */

            /*
             * The pread() function shall be equivalent to read(), except that it shall read
             * from a given position in the file without changing the file pointer.
             *
             */
            /*
             * The first three arguments to pread() are the same as read() with the addition
             * of a fourth argument offset for the desired position inside the file.
             *
             */
            /*
             * On files that support seeking (for example, a regular file), the read() shall
             * start at a position in the file given by the file offset associated with fildes.
             *
             */
            REQ("pread.52;pread64.pread.52;pread.38;pread64.pread.38;pread.39;pread64.pread.39;pread.05;pread64.pread.05", "Read data shall be valid", checkDataRead(context, fildes, buf, pread_spec, offset));
        }

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
         *
         */
        REQ_UNCHECKABLE("pread.10.01;pread64.pread.10.01", "Can not check thread blocking");

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is clear, read() shall block the calling thread until some data
         * becomes available.
         *
         */
        REQ_UNCHECKABLE("pread.10.02;pread64.pread.10.02", "Can not check thread blocking");

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * The use of the O_NONBLOCK flag has no effect if there is some data available.
         *
         */
        REQ_UNCHECKABLE("pread.10.03;pread64.pread.10.03", "Can not check thread blocking");


        /*
        * The value returned may be less than nbyte
        *
        * if the read() request was interrupted by a signal,
        */
        REQ("pread.14.02;pread64.pread.14.02", "", TODO_REQ());


        /*
         * If a read() is interrupted by a signal before it reads any data, it shall
         * return -1 with errno set to [EINTR].
         *
         */
        REQ("pread.15;pread64.pread.15", "", TODO_REQ());

        /*
         * If a read() is interrupted by a signal after it has successfully read some data,
         * it shall return the number of bytes read.
         *
         */
        REQ("pread.16;pread64.pread.16", "", TODO_REQ());

        return true;
    }
    FILTER_CLEAN;
}

void onPread(CallContext context, FileDescId fildes, VoidTPtr buf,
                  SizeT nbyte, OffT offset, SSizeT pread_spec)
{
    File* file=getFile_FileDescId(fildes);


    if (nbyte>0 && pread_spec!=-1 && file!=NULL)
    {
        /*
         * Upon successful completion, where nbyte is greater than 0, read() shall mark
         * for update the st_atime field of the file
         *
         */
        IMPLEMENT_REQ("pread.13.01;pread64.pread.13.01");
        file->atime_updated=false;
    }
}


specification
SSizeT read_spec(CallContext context, FileDescId fildes, VoidTPtr buf,
                 SizeT nbyte, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* desc=getDescriptor_FileDescId(fildes);
    bool is64bits=false;
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    OffT offset=-1;

    pre
    {
        if (getFileDescriptor(fildes)!=NULL)
        {
                is64bits=getIs64bits_FileDescId(fildes);
        }

        if (fdesc!=NULL)
        {
            offset=fdesc->offset;
        }
        if (file!=NULL)
        {
            /*
             * [Function works with regular files and directory files only]
             *
             */
            REQ("", "Function works with regular files and directory files only",
                file->kind==DirectoryFile || file->kind==RegularFile);
        }


        /*
        * If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.
        *
        */
        REQ("app.read.51", "The value of nbyte shall be less than {SSIZE_MAX}",
            (nbyte <= (SizeT)max_SSizeT));

        return true;
    }
    post
    {

        /*
         * Before any action described below is taken, and if nbyte is zero, the read()
         * function may detect and return errors as described below.
         *
         */
        REQ("read.03", "This is checked below", true);


        if (!POSIX_READ_PERFORMS_ERRORS_DETECTION && nbyte==0)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the read()
             * function shall return zero and have no other results.
             *
             */
            REQ("read.04", "Function shall return zero", read_spec==0);

            return true;
        }

        /*
         * Otherwise, the functions shall return -1 and set errno to indicate the error.
         *
         */
        ERROR_BEGIN(POSIX_READ, "read.41.02", read_spec==-1, *errno)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EAGAIN]
         *
         * The O_NONBLOCK flag is set for the file descriptor and the thread would be
         * delayed.
         *
         */
        ERROR_SHALL3(POSIX_READ, EAGAIN, "read.42.01", isO_NONBLOCKset(fildes))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid file descriptor open for reading.
         *
         */
        ERROR_SHALL(POSIX_READ, EBADF, "read.42.02", file==NULL || getAccessMode_FileDescId(fildes)==WriteOnly)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EINTR]
         *
         * The read operation was terminated due to the receipt of a signal, and no data
         * was transferred.
         *
         */
        ERROR_SHALL(POSIX_READ, EINTR, "read.42.04", TODO_ERR(EINTR))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EISDIR]
         *
         * [XSI] The fildes argument refers to a directory and the implementation does
         * not allow the directory to be read using read() or pread(). The readdir()
         * function should be used instead.
         *
         */
        ERROR_SHALL(POSIX_READ, EISDIR, "read.42.07", file!=NULL && file->kind==DirectoryFile &&
            POSIX_DIRECTORY_READ_NOT_ALLOWED)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * The file is a regular file, nbyte is greater than 0, the starting position is
         * before the end-of-file, and the starting position is greater than or equal to
         * the offset maximum established in the open file description associated with
         * fildes.
         *
         */
        ERROR_SHALL(POSIX_READ, EOVERFLOW, "read.42.08", file!=NULL && file->kind==RegularFile
            && file->size!=NULL && offset<*(file->size) && !is64bits && offset >= max_LongT)

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [EIO]
         *
         * A physical I/O error has occurred.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, EIO, "read.44.01", "Can not check IO errors")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOBUFS]
         *
         * Insufficient resources were available in the system to perform the operation.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENOBUFS, "read.44.02", "Can not check insufficient resources case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOMEM]
         *
         * Insufficient memory was available to fulfill the request.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENOMEM, "read.44.03", "Can not check insufficient memory case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENXIO]
         *
         * A request was made of a nonexistent device, or the request was outside the
         * capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENXIO, "read.44.04", "Can not check details about devices")

        ERROR_END()

        /*
         * Upon successful completion, read() [XSI]  and pread() shall return a non-
         * negative integer indicating the number of bytes actually read.
         *
         */
        REQ("read.41.01", "Return value shall be non negative", read_spec>=0);

        if (nbyte==0)
        {
            /*
             * In the absence of errors, or if error detection is not performed, the read()
             * function shall return zero and have no other results.
             *
             */
            REQ("read.04", "Function shall return zero", read_spec==0);
        }

        /*
         * The read() function shall attempt to read nbyte bytes from the file associated
         * with the open file descriptor, fildes, into the buffer pointed to by buf.
         *
         */
        REQ("read.01", "This is done in agent", true);

        if (file->size!=NULL)
        {
            if (offset>=*(file->size))
            {
                /*
                 * If the starting position is at or after the end-of-file, 0 shall be returned.
                 *
                 */
                REQ("read.08", "Function shall return zero", read_spec==0);
            }

            if (offset+nbyte>*(file->size))
            {
                /*
                 * The value returned may be less than nbyte
                 *
                 * if the number of bytes left in the file is less than nbyte,
                 */
                REQ("read.14.01", "The value returned shall be less than nbyte", read_spec<nbyte);
            }

        }

        /*
         * and shall return the number of bytes read. This number shall never be greater
         * than nbyte.
         *
         */
        REQ("read.13.02", "Number of bytes read shall never be greater than nbyte", read_spec<=nbyte);


        if (!is64bits)
        {
            /*
             * For regular files, no data transfer shall occur past the offset maximum
             * established in the open file description associated with fildes.
             *
             */
            REQ("read.17", "No data transfer shall occur past the offset maximum", offset+read_spec<=(LongT)max_LongT);
        }



        if (desc!=NULL && desc->notExternallyModified)
        {

            /*
             * The read() function reads data previously written to a file.
             *
             */
            /*
             * On files that support seeking (for example, a regular file), the read() shall
             * start at a position in the file given by the file offset associated with fildes.
             *
             */
            REQ("read.52;read.05", "Read data shall be valid", checkDataRead(context, fildes, buf, read_spec, offset));
        }

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
         *
         */
        REQ_UNCHECKABLE("read.10.01", "Can not check thread blocking");

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is clear, read() shall block the calling thread until some data
         * becomes available.
         *
         */
        REQ_UNCHECKABLE("read.10.02", "Can not check thread blocking");

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * The use of the O_NONBLOCK flag has no effect if there is some data available.
         *
         */
        REQ_UNCHECKABLE("read.10.03", "Can not check thread blocking");


        /*
        * The value returned may be less than nbyte
        *
        * if the read() request was interrupted by a signal,
        */
        REQ("read.14.02", "", TODO_REQ());


        /*
         * If a read() is interrupted by a signal before it reads any data, it shall
         * return -1 with errno set to [EINTR].
         *
         */
        REQ("read.15", "", TODO_REQ());

        /*
         * If a read() is interrupted by a signal after it has successfully read some data,
         * it shall return the number of bytes read.
         *
         */
        REQ("read.16", "", TODO_REQ());

        return true;
    }
}


void onRead(CallContext context, FileDescId fildes, VoidTPtr buf,
                  SizeT nbyte, SSizeT read_spec)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);


    if (nbyte>0 && read_spec!=-1 && file!=NULL)
    {
        /*
         * Upon successful completion, where nbyte is greater than 0, read() shall mark
         * for update the st_atime field of the file
         *
         */
        IMPLEMENT_REQ("read.13.01");
        file->atime_updated=false;
    }

    if (read_spec!=-1 && fdesc!=NULL)
    {
        /*
         * The file offset shall be incremented by the number of bytes actually read.
         *
         */
        IMPLEMENT_REQ("read.06");

        fdesc->offset=fdesc->offset+read_spec;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    pwrite, write - write on a file

SYNOPSIS

    #include <unistd.h>

    [XSI] [Option Start] ssize_t pwrite(int fildes, const void *buf, size_t nbyte,
           off_t offset); [Option End]

    ssize_t write(int fildes, const void *buf, size_t nbyte);

DESCRIPTION

    The write() function shall attempt to write nbyte bytes from the buffer
    pointed to by buf to the file associated with the open file descriptor,
    fildes.

    Before any action described below is taken, and if nbyte is zero and the
    file is a regular file, the write() function may detect and return errors
    as described below. In the absence of errors, or if error detection is not
    performed, the write() function shall return zero and have no other
    results. If nbyte is zero and the file is not a regular file, the results
    are unspecified.

    On a regular file or other file capable of seeking, the actual writing of
    data shall proceed from the position in the file indicated by the file
    offset associated with fildes. Before successful return from write(), the
    file offset shall be incremented by the number of bytes actually written.
    On a regular file, if this incremented file offset is greater than the
    length of the file, the length of the file shall be set to this file
    offset.

    On a file not capable of seeking, writing shall always take place starting
    at the current position. The value of a file offset associated with such a
    device is undefined.

    If the O_APPEND flag of the file status flags is set, the file offset
    shall be set to the end of the file prior to each write and no intervening
    file modification operation shall occur between changing the file offset
    and the write operation.

    If a write() requests that more bytes be written than there is room for
    (for example, [XSI] [Option Start]  the process' file size limit or
    [Option End] the physical end of a medium), only as many bytes as there
    is room for shall be written. For example, suppose there is space for 20
    bytes more in a file before reaching a limit. A write of 512 bytes will
    return 20. The next write of a non-zero number of bytes would give a
    failure return (except as noted below).

    [XSI] [Option Start] If the request would cause the file size to exceed
    the soft file size limit for the process and there is no room for any
    bytes to be written, the request shall fail and the implementation shall
    generate the SIGXFSZ signal for the thread. [Option End]

    If write() is interrupted by a signal before it writes any data, it shall
    return -1 with errno set to [EINTR].

    If write() is interrupted by a signal after it successfully writes some
    data, it shall return the number of bytes written.

    If the value of nbyte is greater than {SSIZE_MAX}, the result is
    implementation-defined.

    After a write() to a regular file has successfully returned:

        * Any successful read() from each byte position in the file that was
          modified by that write shall return the data specified by the write()
          for that position until such byte positions are again modified.
        * Any subsequent successful write() to the same byte position in the
          file shall overwrite that file data.

    Write requests to a pipe or FIFO shall be handled in the same way as a
    regular file with the following exceptions:

        * There is no file offset associated with a pipe, hence each write
          request shall append to the end of the pipe.
        * Write requests of {PIPE_BUF} bytes or less shall not be interleaved
          with data from other processes doing writes on the same pipe. Writes
          of greater than {PIPE_BUF} bytes may have data interleaved, on
          arbitrary boundaries, with writes by other processes, whether or not
          the O_NONBLOCK flag of the file status flags is set.
        * If the O_NONBLOCK flag is clear, a write request may cause the thread
          to block, but on normal completion it shall return nbyte.
        * If the O_NONBLOCK flag is set, write() requests shall be handled
          differently, in the following ways:
              o The write() function shall not block the thread.
              o A write request for {PIPE_BUF} or fewer bytes shall have the
                following effect: if there is sufficient space available in the
                pipe, write() shall transfer all the data and return the number
                of bytes requested. Otherwise, write() shall transfer no data
                and return -1 with errno set to [EAGAIN].
              o A write request for more than {PIPE_BUF} bytes shall cause one
                of the following:
                    + When at least one byte can be written, transfer what it
                      can and return the number of bytes written. When all data
                      previously written to the pipe is read, it shall transfer
                      at least {PIPE_BUF} bytes.
                    + When no data can be written, transfer no data, and
                      return -1 with errno set to [EAGAIN].

    When attempting to write to a file descriptor (other than a pipe or FIFO)
    that supports non-blocking writes and cannot accept the data immediately:

        * If the O_NONBLOCK flag is clear, write() shall block the calling
          thread until the data can be accepted.
        * If the O_NONBLOCK flag is set, write() shall not block the thread.
          If some data can be written without blocking the thread, write()
          shall write what it can and return the number of bytes written.
          Otherwise, it shall return -1 and set errno to [EAGAIN].

    Upon successful completion, where nbyte is greater than 0, write() shall
    mark for update the st_ctime and st_mtime fields of the file, and if the
    file is a regular file, the S_ISUID and S_ISGID bits of the file mode may
    be cleared.

    For regular files, no data transfer shall occur past the offset maximum
    established in the open file description associated with fildes.

    If fildes refers to a socket, write() shall be equivalent to send() with
    no flags set.

    [SIO] [Option Start] If the O_DSYNC bit has been set, write I/O operations
    on the file descriptor shall complete as defined by synchronized I/O data
    integrity completion.

    If the O_SYNC bit has been set, write I/O operations on the file descriptor
    shall complete as defined by synchronized I/O file integrity completion.
    [Option End]

    [SHM] [Option Start] If fildes refers to a shared memory object, the result
    of the write() function is unspecified. [Option End]

    [TYM] [Option Start] If fildes refers to a typed memory object, the result
    of the write() function is unspecified. [Option End]

    [XSR] [Option Start] If fildes refers to a STREAM, the operation of write()
    shall be determined by the values of the minimum and maximum nbyte range
    (packet size) accepted by the STREAM. These values are determined by the
    topmost STREAM module. If nbyte falls within the packet size range, nbyte
    bytes shall be written. If nbyte does not fall within the range and the
    minimum packet size value is 0, write() shall break the buffer into maximum
    packet size segments prior to sending the data downstream (the last segment
    may contain less than the maximum packet size). If nbyte does not fall
    within the range and the minimum value is non-zero, write() shall fail
    with errno set to [ERANGE]. Writing a zero-length buffer ( nbyte is 0) to
    a STREAMS device sends 0 bytes with 0 returned. However, writing a
    zero-length buffer to a STREAMS-based pipe or FIFO sends no message and 0
    is returned. The process may issue I_SWROPT ioctl() to enable zero-length
    messages to be sent across the pipe or FIFO.

    When writing to a STREAM, data messages are created with a priority band
    of 0. When writing to a STREAM that is not a pipe or FIFO:

        * If O_NONBLOCK is clear, and the STREAM cannot accept data (the STREAM
          write queue is full due to internal flow control conditions), write()
          shall block until data can be accepted.
        * If O_NONBLOCK is set and the STREAM cannot accept data, write()
          shall return -1 and set errno to [EAGAIN].
        * If O_NONBLOCK is set and part of the buffer has been written while a
          condition in which the STREAM cannot accept additional data occurs,
          write() shall terminate and return the number of bytes written.

    In addition, write() shall fail if the STREAM head has processed an
    asynchronous error before the call. In this case, the value of errno does
    not reflect the result of write(), but reflects the prior error.
    [Option End]

    [XSI] [Option Start] The pwrite() function shall be equivalent to write(),
    except that it writes into a given position without changing the file
    pointer. The first three arguments to pwrite() are the same as write()
    with the addition of a fourth argument offset for the desired position
    inside the file. [Option End]

RETURN VALUE

    Upon successful completion, write() [XSI] [Option Start]  and pwrite()
    [Option End] shall return the number of bytes actually written to the file
    associated with fildes. This number shall never be greater than nbyte.
    Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

    The write() and [XSI] [Option Start] pwrite() [Option End] functions shall
    fail if:

    [EAGAIN]
        The O_NONBLOCK flag is set for the file descriptor and the thread would
        be delayed in the write() operation.
    [EBADF]
        The fildes argument is not a valid file descriptor open for writing.
    [EFBIG]
        An attempt was made to write a file that exceeds the
        implementation-defined maximum file size [XSI] [Option Start]  or the
        process' file size limit, [Option End]  and there was no room for any
        bytes to be written.
    [EFBIG]
        The file is a regular file, nbyte is greater than 0, and the starting
        position is greater than or equal to the offset maximum established in
        the open file description associated with fildes.
    [EINTR]
        The write operation was terminated due to the receipt of a signal, and
        no data was transferred.
    [EIO]
        The process is a member of a background process group attempting to
        write to its controlling terminal, TOSTOP is set, the process is
        neither ignoring nor blocking SIGTTOU, and the process group of the
        process is orphaned. This error may also be returned under
        implementation-defined conditions.
    [ENOSPC]
        There was no free space remaining on the device containing the file.
    [EPIPE]
        An attempt is made to write to a pipe or FIFO that is not open for
        reading by any process, or that only has one end open. A SIGPIPE signal
        shall also be sent to the thread.
    [ERANGE]
        [XSR] [Option Start] The transfer request size was outside the range
        supported by the STREAMS file associated with fildes. [Option End]

    The write() function shall fail if:

    [EAGAIN] or [EWOULDBLOCK]
        The file descriptor is for a socket, is marked O_NONBLOCK, and write
        would block.
    [ECONNRESET]
        A write was attempted on a socket that is not connected.
    [EPIPE]
        A write was attempted on a socket that is shut down for writing, or is
        no longer connected. In the latter case, if the socket is of type
        SOCK_STREAM, a SIGPIPE signal shall also be sent to the thread.

    The write() and [XSI] [Option Start] pwrite() [Option End] functions may
    fail if:

    [EINVAL]
        [XSR] [Option Start] The STREAM or multiplexer referenced by fildes
        is linked (directly or indirectly) downstream from a multiplexer.
        [Option End]
    [EIO]
        A physical I/O error has occurred.
    [ENOBUFS]
        Insufficient resources were available in the system to perform the
        operation.
    [ENXIO]
        A request was made of a nonexistent device, or the request was outside
        the capabilities of the device.
    [ENXIO]
        [XSR] [Option Start] A hangup occurred on the STREAM being written to.
        [Option End]

    [XSR] [Option Start] A write to a STREAMS file may fail if an error message
    has been received at the STREAM head. In this case, errno is set to the
    value included in the error message. [Option End]

    The write() function may fail if:

    [EACCES]
        A write was attempted on a socket and the calling process does not have
        appropriate privileges.
    [ENETDOWN]
        A write was attempted on a socket and the local network interface used
        to reach the destination is down.
    [ENETUNREACH]
        A write was attempted on a socket and no route to the network is
        present.

    [XSI] [Option Start] The pwrite() function shall fail and the file pointer
    remain unchanged if: [Option End]

    [EINVAL]
        [XSI] [Option Start] The offset argument is invalid. The value is
        negative. [Option End]
    [ESPIPE]
        [XSI] [Option Start] fildes is associated with a pipe or FIFO.
        [Option End]
*/

//This specification refers to: pwrite64, pwrite
specification
SSizeT pwrite_spec(CallContext context, FileDescId fildes,
                   VoidTPtr buf, SizeT nbyte, OffT offset, ErrorCode* errno,
                   bool is64bits)
{
    File* file=getFile_FileDescId(fildes);

    if (is64bits)
        FILTER("pwrite64");
    else
        FILTER("pwrite");

    pre
    {
        if (getFileDescriptor(fildes)!=NULL)
        {
            /*
            *  [Corresponding function shall be used for file: 64 bit function for 64 bit file]
            */
            REQ("", "Corresponding function shall be used for file",
                is64bits==getIs64bits_FileDescId(fildes));
        }

        if (file!=NULL && file->kind != UnknownFileKind)
        {

            /*
            * [Function works with regular files only]
            */
            REQ("", "File shall be regular", file->kind == RegularFile);

            if (nbyte==0)
            {
                /*
                * If nbyte is zero and the file is not a regular file, the results are
                * unspecified.
                */
                REQ("app.pwrite.03;app.pwrite64.pwrite.03", "File shall be regular", file->kind == RegularFile);
            }
        }

        /*
        * If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-
        * defined.
        */
        REQ("app.pwrite.13;app.pwrite64.pwrite.13", "The value of nbyte shall be less than {SSIZE_MAX}",
            (nbyte <= (SizeT)max_SSizeT));

        return true;
    }
    post
    {
        /*
         * Before any action described below is taken, and if nbyte is zero and the file
         * is a regular file, the write() function may detect and return errors as
         * described below.
         *
         */
        REQ("pwrite.02.01;pwrite64.pwrite.02.01", "This is checked below", true);

        if (!POSIX_WRITE_PERFORMS_ERRORS_DETECTION && nbyte==0 && file!=NULL && file->kind==RegularFile)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the write()
             * function shall return zero and have no other results.
             *
             */
            REQ("pwrite.02.02;pwrite64.pwrite.02.02", "Function shall return zero", pwrite_spec==0);

            return true;
        }

        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         *
         */
        ERROR_BEGIN(POSIX_PWRITE, "pwrite.40.03;pwrite64.pwrite.40.03", pwrite_spec==-1, *errno)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EAGAIN]
         *
         * The O_NONBLOCK flag is set for the file descriptor and the thread would be
         * delayed in the write() operation.
         *
         */
        ERROR_SHALL3(POSIX_PWRITE, EAGAIN, "pwrite.41.01;pwrite64.pwrite.41.01", isO_NONBLOCKset(fildes))

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid file descriptor open for writing.
         *
         */
        ERROR_SHALL(POSIX_PWRITE, EBADF, "pwrite.41.02;pwrite64.pwrite.41.02", file==NULL ||
            getAccessMode_FileDescId(fildes)==ReadOnly)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EFBIG]
         *
         * An attempt was made to write a file that exceeds the implementation-defined
         * maximum file size [XSI]  or the process' file size limit,  and there was no
         * room for any bytes to be written.
         *
         */
         ERROR_UNCHECKABLE(POSIX_PWRITE, EFBIG, "pwrite.41.03;pwrite64.pwrite.41.03",
            "Implementation-defined maximum file size can not be checked")

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EFBIG]
         *
         * The file is a regular file, nbyte is greater than 0, and the starting position
         * is greater than or equal to the offset maximum established in the open file
         * description associated with fildes.
         *
         */
        ERROR_SHALL(POSIX_PWRITE, EFBIG, "pwrite.41.04;pwrite64.pwrite.41.04", file!=NULL && file->kind==RegularFile
            && !is64bits && offset>max_LongT)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EINTR]
         *
         * The write operation was terminated due to the receipt of a signal, and no data
         * was transferred.
         *
         */
        ERROR_SHALL(POSIX_PWRITE, EINTR, "pwrite.41.05;pwrite64.pwrite.41.05", TODO_ERR(EINTR))


        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [ENOSPC]
         *
         * There was no free space remaining on the device containing the file.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PWRITE, ENOSPC, "pwrite.41.07;pwrite64.pwrite.41.07", "Can not determine free space")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [EIO]
         *
         * A physical I/O error has occurred.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PWRITE, EIO, "pwrite.43.02;pwrite64.pwrite.43.02", "Can not check physical I/O errors")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENOBUFS]
         *
         * Insufficient resources were available in the system to perform the operation.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PWRITE, ENOBUFS, "pwrite.43.03;pwrite64.pwrite.43.03", "Can not check insufficient resources case")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENXIO]
         *
         * A request was made of a nonexistent device, or the request was outside the
         * capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_PWRITE, ENXIO, "pwrite.43.04;pwrite64.pwrite.43.04", "Impossible to check details bout devices")

        /*
         * The pwrite() function shall fail and the file pointer remain unchanged if:
         *
         * [EINVAL]
         *
         * [XSI] The offset argument is invalid. The value is negative.
         *
         */
        ERROR_SHALL(POSIX_PWRITE, EINVAL, "pwrite.45.01;pwrite64.pwrite.45.01", offset<0)

        ERROR_END()

        if (nbyte==0 && file!=NULL && file->kind==RegularFile)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the write()
             * function shall return zero and have no other results.
             *
             */
            REQ("pwrite.02.02;pwrite64.pwrite.02.02", "Function shall return zero", pwrite_spec==0);
        }

        /*
         * This number shall never be greater than nbyte.
         *
         */
        REQ("pwrite.40.02;pwrite64.pwrite.40.02", "Function shall return number not greater than nbyte",
            pwrite_spec<=nbyte);

        if (!is64bits)
        {
            /*
             * For regular files, no data transfer shall occur past the offset maximum
             * established in the open file description associated with fildes.
             *
             */
            REQ("pwrite.23;pwrite64.pwrite.23", "No data transfer shall occur past the offset maximum",
                offset+pwrite_spec <= max_LongT);
        }


        /*
         * When attempting to write to a file descriptor (other than a pipe or FIFO) that
         * supports non-blocking writes and cannot accept the data immediately:
         *
         * If the O_NONBLOCK flag is clear, write() shall block the calling thread until
         * the data can be accepted.
         *
         */
        REQ_UNCHECKABLE("pwrite.20.01;pwrite64.pwrite.20.01", "Can not check if the thread blocks");

        /*
         * If the O_NONBLOCK flag is set, write() shall not block the thread.
         *
         */
        REQ_UNCHECKABLE("pwrite.20.02.01;pwrite64.pwrite.20.02.01", "Can not check if the thread blocks");

        /*
         * If some data can be written without blocking the thread, write() shall write
         * what it can and return the number of bytes written.
         *
         */
        REQ_UNCHECKABLE("pwrite.20.02.02;pwrite64.pwrite.20.02.02", "Can not check if the thread blocks");

        /*
         * Otherwise, it shall return -1 and set errno to [EAGAIN].
         *
         */
        REQ_UNCHECKABLE("pwrite.20.02.03;pwrite64.pwrite.20.02.03", "Can not check if the thread blocks");

        /*
         * On a file not capable of seeking, writing shall always take place starting at
         * the current position.
         *
         */
        REQ("pwrite.07;pwrite64.pwrite.07;", "", TODO_REQ());

        /*
         * no intervening file modification operation shall occur between changing the
         * file offset and the write operation.
         *
         */
        REQ("pwrite.08.02;pwrite64.pwrite.08.02", "", TODO_REQ());

        /*
         * If a write() requests that more bytes be written than there is room for (for
         * example, [XSI]  the process' file size limit or the physical end of a medium),
         * only as many bytes as there is room for shall be written.
         *
         */
        REQ("pwrite.09;pwrite64.pwrite.09", "", TODO_REQ());

        /*
         * If the request would cause the file size to exceed the soft file size limit for
         * the process and there is no room for any bytes to be written, the request shall
         * fail and the implementation shall generate the SIGXFSZ signal for the thread.
         *
         */
        REQ("pwrite.10;pwrite64.pwrite.10", "", TODO_REQ());

        /*
         * If write() is interrupted by a signal before it writes any data, it shall
         * return -1 with errno set to [EINTR].
         *
         */
        REQ("pwrite.11;pwrite64.pwrite.11;pwrite64.pwrite.11", "", TODO_REQ());

        /*
         * If write() is interrupted by a signal after it successfully writes some data,
         * it shall return the number of bytes written.
         *
         */
        REQ("pwrite.12;pwrite64.pwrite.12", "", TODO_REQ());


        /*
         * If the O_DSYNC bit has been set, write I/O operations on the file descriptor
         * shall complete as defined by synchronized I/O data integrity completion
         *
         */
        REQ("pwrite.24;pwrite64.pwrite.24", "", TODO_REQ());

        /*
         * If the O_SYNC bit has been set, write I/O operations on the file descriptor
         * shall complete as defined by synchronized I/O file integrity completion.
         *
         */
        REQ("pwrite.25;pwrite64.pwrite.25", "", TODO_REQ());

        return true;
    }
    FILTER_CLEAN;
}


void onPwrite(CallContext context, FileDescId fildes,
                   VoidTPtr buf, SizeT nbyte, OffT offset,
                   SSizeT pwrite_spec)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* desc=getDescriptor_FileDescId(fildes);
    CByteArray* data;
    List* chunks;

    if (pwrite_spec!=-1)
    {
        data=readCByteArray_VoidTPtr(buf, pwrite_spec);
        if (desc!=NULL)
        {
            if (desc->append && file!=NULL && file->size!=NULL)
            {
                /*
                 * If the O_APPEND flag of the file status flags is set, the file offset shall be
                 * set to the end of the file prior to each write
                 *
                 */
                IMPLEMENT_REQ("pwrite.08.01;pwrite64.pwrite.08.01");

                offset=*(file->size);
            }

            /*
             * The pwrite() function shall be equivalent to write(), except that it writes
             * into a given position without changing the file pointer.
             */
            IMPLEMENT_REQ("pwrite.37;pwrite64.pwrite.37");

            /*
             * The first three arguments to pwrite() are the same as write() with the addition
             * of a fourth argument offset for the desired position inside the file.
             *
             */
            IMPLEMENT_REQ("pwrite.38;pwrite64.pwrite.38");

            /*
             * Any subsequent successful write() to the same byte position in the file shall
             * overwrite that file data.
             */
            IMPLEMENT_REQ("pwrite.15;pwrite64.pwrite.15;write.15");

            /*
             * Any successful read() from each byte position in the file that was modified by
             * that write shall return the data specified by the write() for that position
             * until such byte positions are again modified.
             */
            IMPLEMENT_REQ("pwrite.14;pwrite64.pwrite.14;write.14");

            chunks = desc->dataChunks;
            append_List(chunks, create_DataChunk(context, offset, data));
            chunks = reorderChunksList(chunks, context);
        }

        if (file->kind==RegularFile && file->permissions != NULL)
        {
            /*
             * if the file is a regular file, the S_ISUID and S_ISGID bits of the file mode
             * may be cleared.
             *
             */
            IMPLEMENT_REQ("pwrite.22.02;pwrite64.pwrite.22.02;write.22.02");
            file->permissions->set_uid = Unknown_Bool3;
            file->permissions->set_gid = Unknown_Bool3;
        }


        if (file->size!=NULL && offset+pwrite_spec >= *(file->size))
        {

            /*
             * Upon successful completion, write() [XSI]  and pwrite() shall return the
             * number of bytes actually written to the file associated with fildes.
             *
             */
            IMPLEMENT_REQ("pwrite.40.01;pwrite64.pwrite.40.01;write.40.01");

            /*
            * On a regular file, if this incremented file offset is greater than the length
            * of the file, the length of the file shall be set to this file offset.
            */
            IMPLEMENT_REQ("pwrite.06;pwrite64.pwrite.06;write.06");

            file->size=create_OffTObj(offset+pwrite_spec);
        }

        if (nbyte>0)
        {
            /*
             * Upon successful completion, where nbyte is greater than 0, write() shall mark
             * for update the st_ctime and st_mtime fields of the file,
             *
             */
            IMPLEMENT_REQ("pwrite.22.01;pwrite64.pwrite.22.01;write.22.01");
            file->ctime_updated=false;
            file->mtime_updated=false;
        }
    }
}


specification
SSizeT write_spec(CallContext context, FileDescId fildes, VoidTPtr buf,
                      SizeT nbyte, ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    OffT offset=-1;
    bool is64bits=false;

    pre
    {
        if (getFileDescriptor(fildes)!=NULL)
        {
            is64bits=getIs64bits_FileDescId(fildes);
        }

        if (file!=NULL && file->kind != UnknownFileKind)
        {

            if (nbyte==0)
            {
                /*
                * If nbyte is zero and the file is not a regular file, the results are
                * unspecified.
                */
                REQ("app.write.03", "File shall be regular", file->kind == RegularFile);
            }

            /*
            * [Function works with regular files only]
            */
            REQ("", "File shall be regular", file->kind == RegularFile);

        }

        /*
        * If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-
        * defined.
        */
        REQ("app.write.13", "The value of nbyte shall be less than {SSIZE_MAX}",
            (nbyte <= (SizeT)max_SSizeT));

        return true;
    }
    post
    {
        /*
         * Before any action described below is taken, and if nbyte is zero and the file
         * is a regular file, the write() function may detect and return errors as
         * described below.
         *
         */
        REQ("write.02.01", "This is checked below", true);

        if (!POSIX_WRITE_PERFORMS_ERRORS_DETECTION && nbyte==0 && file!=NULL && file->kind==RegularFile)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the write()
             * function shall return zero and have no other results.
             *
             */
            REQ("write.02.02", "Function shall return zero", write_spec==0);

            return true;
        }

        /*
         * Otherwise, -1 shall be returned and errno set to indicate the error.
         *
         */
        ERROR_BEGIN(POSIX_WRITE, "write.40.03", write_spec==-1, *errno)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EAGAIN]
         *
         * The O_NONBLOCK flag is set for the file descriptor and the thread would be
         * delayed in the write() operation.
         *
         */
        ERROR_SHALL3(POSIX_WRITE, EAGAIN, "write.41.01", isO_NONBLOCKset(fildes))

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid file descriptor open for writing.
         *
         */
        ERROR_SHALL(POSIX_WRITE, EBADF, "write.41.02", file==NULL ||
            getAccessMode_FileDescId(fildes)==ReadOnly)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EFBIG]
         *
         * An attempt was made to write a file that exceeds the implementation-defined
         * maximum file size [XSI]  or the process' file size limit,  and there was no
         * room for any bytes to be written.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, EFBIG, "write.41.03", "Implementation-defined maximum file size can not be checked")

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EINTR]
         *
         * The write operation was terminated due to the receipt of a signal, and no data
         * was transferred.
         *
         */
        ERROR_SHALL(POSIX_WRITE, EINTR, "write.41.05", TODO_ERR(EINTR))


        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [ENOSPC]
         *
         * There was no free space remaining on the device containing the file.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENOSPC, "write.41.07", "Can not determine free space")

        /*
         * The write() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK]
         *
         * The file descriptor is for a socket, is marked O_NONBLOCK, and write would
         * block.
         *
         */
        ERROR_SHALL3(POSIX_WRITE, EAGAIN, "write.42.01", isO_NONBLOCKset(fildes))
        ERROR_SHALL3(POSIX_WRITE, EWOULDBLOCK, "write.42.01", isO_NONBLOCKset(fildes))


        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [EIO]
         *
         * A physical I/O error has occurred.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, EIO, "write.43.02", "Can not check physical I/O errors")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENOBUFS]
         *
         * Insufficient resources were available in the system to perform the operation.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENOBUFS, "write.43.03", "Can not check insufficient resources case")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENXIO]
         *
         * A request was made of a nonexistent device, or the request was outside the
         * capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENXIO, "write.43.04", "Impossible to check details about devices")

        ERROR_END()

        /*
         * The write() function shall attempt to write nbyte bytes from the buffer pointed
         * to by buf to the file associated with the open file descriptor, fildes.
         *
         */
        REQ("write.01", "This is checked below", true);

        if (nbyte==0 && file!=NULL && file->kind==RegularFile)
        {

            /*
             * In the absence of errors, or if error detection is not performed, the write()
             * function shall return zero and have no other results.
             *
             */
            REQ("write.02.02", "Function shall return zero", write_spec==0);
        }

        /*
         * This number shall never be greater than nbyte.
         *
         */
        REQ("write.40.02", "Function shall return number not greater than nbyte",
            write_spec<=nbyte);

        if (!is64bits)
        {
            /*
             * For regular files, no data transfer shall occur past the offset maximum
             * established in the open file description associated with fildes.
             *
             */
            REQ("write.23", "No data transfer shall occur past the offset maximum",
                offset+write_spec <= max_LongT);
        }

        /*
         * When attempting to write to a file descriptor (other than a pipe or FIFO) that
         * supports non-blocking writes and cannot accept the data immediately:
         *
         * If the O_NONBLOCK flag is clear, write() shall block the calling thread until
         * the data can be accepted.
         *
         */
        REQ_UNCHECKABLE("write.20.01", "Can not check if the thread blocks");

        /*
         * If the O_NONBLOCK flag is set, write() shall not block the thread.
         *
         */
        REQ_UNCHECKABLE("write.20.02.01", "Can not check if the thread blocks");


        /*
         * If some data can be written without blocking the thread, write() shall write
         * what it can and return the number of bytes written.
         *
         */
        REQ_UNCHECKABLE("write.20.02.02", "Can not check if the thread blocks");

        /*
         * Otherwise, it shall return -1 and set errno to [EAGAIN].
         *
         */
        REQ_UNCHECKABLE("write.20.02.03", "Can not check if the thread blocks");

        /*
         * On a file not capable of seeking, writing shall always take place starting at
         * the current position.
         *
         */
        REQ("write.07", "", TODO_REQ());

        /*
         * no intervening file modification operation shall occur between changing the
         * file offset and the write operation.
         *
         */
        REQ("write.08.02", "", TODO_REQ());

        /*
         * If a write() requests that more bytes be written than there is room for (for
         * example, [XSI]  the process' file size limit or the physical end of a medium),
         * only as many bytes as there is room for shall be written.
         *
         */
        REQ("write.09", "", TODO_REQ());

        /*
         * If the request would cause the file size to exceed the soft file size limit for
         * the process and there is no room for any bytes to be written, the request shall
         * fail and the implementation shall generate the SIGXFSZ signal for the thread.
         *
         */
        REQ("write.10", "", TODO_REQ());

        /*
         * If write() is interrupted by a signal before it writes any data, it shall
         * return -1 with errno set to [EINTR].
         *
         */
        REQ("write.11", "", TODO_REQ());

        /*
         * If write() is interrupted by a signal after it successfully writes some data,
         * it shall return the number of bytes written.
         *
         */
        REQ("write.12", "", TODO_REQ());


        /*
         * If the O_DSYNC bit has been set, write I/O operations on the file descriptor
         * shall complete as defined by synchronized I/O data integrity completion
         *
         */
        REQ("write.24", "", TODO_REQ());

        /*
         * If the O_SYNC bit has been set, write I/O operations on the file descriptor
         * shall complete as defined by synchronized I/O file integrity completion.
         *
         */
        REQ("write.25", "", TODO_REQ());

        return true;
    }
}



void onWrite(CallContext context, FileDescId fildes,
                   VoidTPtr buf, SizeT nbyte,
                   SSizeT write_spec)
{
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    File* file=getFile_FileDescId(fildes);
    OffT offset;

    if (write_spec!=-1)
    {
        if (fdesc!=NULL)
        {

            /*
             * On a regular file or other file capable of seeking, the actual writing of data
             * shall proceed from the position in the file indicated by the file offset
             * associated with fildes.
             *
             */
            IMPLEMENT_REQ("write.04");

            offset=fdesc->offset;


            if (regdesc!=NULL && regdesc->append && file!=NULL && file->size!=NULL)
            {
                /*
                 * If the O_APPEND flag of the file status flags is set, the file offset shall be
                 * set to the end of the file prior to each write
                 *
                 */
                IMPLEMENT_REQ("write.08.01;open.05");

                offset=*(file->size);
            }

            onPwrite(context, fildes, buf, nbyte, offset, write_spec);

            /*
             * Before successful return from write(), the file offset shall be incremented by
             * the number of bytes actually written.
             *
             */
            IMPLEMENT_REQ("write.05");

            fdesc->offset=fdesc->offset+write_spec;
        }
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    readv - read a vector

SYNOPSIS

    #include <sys/uio.h>
    ssize_t readv(int fildes, const struct iovec *iov, int iovcnt);

DESCRIPTION

    The readv() function shall be equivalent to read(), except as described
    below. The readv() function shall place the input data into the iovcnt
    buffers specified by the members of the iov array: iov[0], iov[1], ...,
    iov[ iovcnt-1]. The iovcnt argument is valid if greater than 0 and less
    than or equal to {IOV_MAX}.

    Each iovec entry specifies the base address and length of an area in
    memory where data should be placed. The readv() function shall always
    fill an area completely before proceeding to the next.

    Upon successful completion, readv() shall mark for update the st_atime
    field of the file.

RETURN VALUE

    Refer to read().

ERRORS

    Refer to read().

    In addition, the readv() function shall fail if:

        [EINVAL]
        The sum of the iov_len values in the iov array overflowed an ssize_t.

    The readv() function may fail if:

        [EINVAL]
        The iovcnt argument was less than or equal to 0, or greater than {IOV_MAX}.
*/
specification typedef struct IOvec IOvec = {};

specification
SSizeT readv_spec(CallContext context, FileDescId fildes, List* iov,
                  ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    RegularFileDescriptor* desc=getDescriptor_FileDescId(fildes);
    bool is64bits=false;
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    OffT offset=-1;

    pre
    {

        if (fdesc!=NULL)
        {
            is64bits=getIs64bits_FileDescId(fildes);
            offset=fdesc->offset;
        }
        if (file!=NULL)
        {
            /*
             * [Function works with regular files and directory files only]
             *
             */
            REQ("", "Function works with regular files and directory files only",
                file->kind==DirectoryFile || file->kind==RegularFile);
        }

        return true;
    }
    post
    {
        /*
         * Otherwise, the functions shall return -1 and set errno to indicate the error.
         *
         */
        ERROR_BEGIN(POSIX_READV, "readv.pread.41.02", readv_spec==-1, *errno)
        /*
        * In addition, the readv() function shall fail if:
        *
        * [EINVAL]
        *
        * The sum of the iov_len values in the iov array overflowed an ssize_t.
        *
        */
        ERROR_SHALL(POSIX_READV, EINVAL, "readv.06.01", sumIOVecMembers(iov)>(SizeT)max_SSizeT)

        /*
        * The readv() function may fail if:
        *
        * [EINVAL]
        *
        * The iovcnt argument was less than or equal to 0, or greater than {IOV_MAX}.
        *
        */
        /*
        * The iovcnt argument is valid if greater than 0 and less than or equal to {
        * IOV_MAX}.
        */
        ERROR_MAY(POSIX_READV, EINVAL, "readv.07.01;app.readv.02", size_List(iov)==0 ||
        (getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_UNKNOWN
        &&
        getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_NO_LIMIT
        &&
            size_List(iov) > getSystemConfigurationValue(context, SUT_SC_IOV_MAX)))


        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EAGAIN]
         *
         * The O_NONBLOCK flag is set for the file descriptor and the thread would be
         * delayed.
         *
         */
        ERROR_SHALL3(POSIX_READ, EAGAIN, "readv.pread.42.01", isO_NONBLOCKset(fildes))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid file descriptor open for reading.
         *
         */
        ERROR_SHALL(POSIX_READ, EBADF, "readv.pread.42.02", file==NULL || getAccessMode_FileDescId(fildes)==WriteOnly)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EINTR]
         *
         * The read operation was terminated due to the receipt of a signal, and no data
         * was transferred.
         *
         */
        ERROR_SHALL(POSIX_READ, EINTR, "readv.pread.42.04", TODO_ERR(EINTR))

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EISDIR]
         *
         * [XSI] The fildes argument refers to a directory and the implementation does
         * not allow the directory to be read using read() or pread(). The readdir()
         * function should be used instead.
         *
         */
        ERROR_SHALL(POSIX_READ, EISDIR, "readv.pread.42.07", file!=NULL && file->kind==DirectoryFile &&
            POSIX_DIRECTORY_READ_NOT_ALLOWED)

        /*
         * The read() and [XSI] pread() functions shall fail if:
         *
         * [EOVERFLOW]
         *
         * The file is a regular file, nbyte is greater than 0, the starting position is
         * before the end-of-file, and the starting position is greater than or equal to
         * the offset maximum established in the open file description associated with
         * fildes.
         *
         */
        ERROR_SHALL(POSIX_READ, EOVERFLOW, "readv.pread.42.08", file!=NULL && file->kind==RegularFile
            && file->size!=NULL && offset<*(file->size) && !is64bits && offset >= (LongT)max_LongT)

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [EIO]
         *
         * A physical I/O error has occurred.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, EIO, "readv.pread.44.01", "Can not check IO errors")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOBUFS]
         *
         * Insufficient resources were available in the system to perform the operation.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENOBUFS, "readv.pread.44.02", "Can not check insufficient resources case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENOMEM]
         *
         * Insufficient memory was available to fulfill the request.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENOMEM, "readv.pread.44.03", "Can not check insufficient memory case")

        /*
         * The read() and [XSI] pread() functions may fail if:
         *
         * [ENXIO]
         *
         * A request was made of a nonexistent device, or the request was outside the
         * capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_READ, ENXIO, "readv.pread.44.04", "Can not check details about devices")

        ERROR_END()

        /*
         * Upon successful completion, read() [XSI]  and pread() shall return a non-
         * negative integer indicating the number of bytes actually read.
         *
         */
        REQ("readv.pread.41.01", "Return value shall be non-negative", readv_spec>=0);


        {
            IntT i;
            SizeT sumLen=0;
            OffT curOffset=offset;
            for (i=0;i<size_List(iov);i++)
            {
                IOvec* curVec=get_List(iov, i);
                SizeT  curLen;

                if (sumLen>=readv_spec)
                {
                    break;
                }

                if (sumLen+curVec->iov_len<=readv_spec)
                {
                    curLen=curVec->iov_len;
                }
                else
                {
                    curLen=readv_spec-sumLen;
                }

                sumLen+=curVec->iov_len;


                /*
                * The readv() function shall place the input data into the iovcnt buffers
                * specified by the members of the iov array: iov[0], iov[1], ..., iov[ iovcnt-1].
                *
                */
                /*
                * Each iovec entry specifies the base address and length of an area in memory
                * where data should be placed.
                *
                */
                /*
                * The readv() function shall always fill an area completely before proceeding
                * to the next.
                *
                */
                /*
                 * On files that support seeking (for example, a regular file), the read() shall
                 * start at a position in the file given by the file offset associated with fildes.
                 *
                 */
                /*
                 * The read() function reads data previously written to a file.
                 *
                 */
                REQ("readv.01;readv.03;readv.04;readv.pread.05;readv.pread.52", "Read data shall be valid", checkDataRead(context, fildes,
                    curVec->iov_base, curLen, curOffset));
                curOffset+=curLen;
            }
        }


        if (file->size!=NULL)
        {
            if (offset>=*(file->size))
            {
                /*
                 * If the starting position is at or after the end-of-file, 0 shall be returned.
                 *
                 */
                REQ("readv.pread.08", "Function shall return zero", readv_spec==0);
            }

            if (offset+sumIOVecMembers(iov)>*(file->size))
            {
                /*
                 * The value returned may be less than nbyte
                 *
                 * if the number of bytes left in the file is less than nbyte,
                 */
                REQ("readv.pread.14.01", "The value returned shall be less than number of bytes requested", readv_spec<sumIOVecMembers(iov));
            }

        }

        /*
         * and shall return the number of bytes read. This number shall never be greater
         * than nbyte.
         *
         */
        REQ("readv.pread.13.02", "Return value shall be valid", readv_spec <= sumIOVecMembers(iov));

        if (!is64bits)
        {
            /*
             * For regular files, no data transfer shall occur past the offset maximum
             * established in the open file description associated with fildes.
             *
             */
            REQ("readv.pread.17", "No data transfer shall occur past the offset maximum", offset+readv_spec<=(LongT)max_LongT);
        }

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
         *
         */
        REQ_UNCHECKABLE("readv.pread.10.01", "Can not check thread blocking");

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * If O_NONBLOCK is clear, read() shall block the calling thread until some data
         * becomes available.
         *
         */
        REQ_UNCHECKABLE("readv.pread.10.02", "Can not check thread blocking");

        /*
         * When attempting to read a file (other than a pipe or FIFO) that supports non-
         * blocking reads and has no data currently available:
         *
         * The use of the O_NONBLOCK flag has no effect if there is some data available.
         *
         */
        REQ_UNCHECKABLE("readv.pread.10.03", "Can not check thread blocking");


        /*
        * The value returned may be less than nbyte
        *
        * if the read() request was interrupted by a signal,
        */
        REQ("readv.pread.14.02", "", TODO_REQ());


        /*
         * If a read() is interrupted by a signal before it reads any data, it shall
         * return -1 with errno set to [EINTR].
         *
         */
        REQ("readv.pread.15", "", TODO_REQ());

        /*
         * If a read() is interrupted by a signal after it has successfully read some data,
         * it shall return the number of bytes read.
         *
         */
        REQ("readv.pread.16", "", TODO_REQ());


        return true;
    }
}

void onReadv(CallContext context, FileDescId fildes, List* iov,
                  SSizeT readv_spec)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);


    if (readv_spec!=-1 && file!=NULL)
    {

        /*
        * Upon successful completion, readv() shall mark for update the st_atime field of
        * the file.
        *
        */
        /*
         * Upon successful completion, where nbyte is greater than 0, read() shall mark
         * for update the st_atime field of the file
         *
         */
        IMPLEMENT_REQ("readv.05;readv.pread.13.01");
        file->atime_updated=false;

        if (fdesc!=NULL)
        {
            /*
             * The file offset shall be incremented by the number of bytes actually read.
             *
             */
            IMPLEMENT_REQ("readv.pread.06");
            fdesc->offset=fdesc->offset+readv_spec;
        }
    }

}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    sync - schedule file system updates

SYNOPSIS

    [XSI] [Option Start] #include <unistd.h>
    void sync(void); [Option End]

DESCRIPTION

    The sync() function shall cause all information in memory that updates
    file systems to be scheduled for writing out to all file systems.

    The writing, although scheduled, is not necessarily complete upon return
    from sync().

RETURN VALUE

    The sync() function shall not return a value.

ERRORS

    No errors are defined.
*/
specification
void sync_spec(CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { ScheduleFileSystemUpdates, "Schedule file system updates" };
    }
    post
    {
        /*
        * The sync() function shall cause all information in memory that updates file
        * systems to be scheduled for writing out to all file systems.
        *
        */
        REQ("sync.01", "", TODO_REQ());

        /*
        * The writing, although scheduled, is not necessarily complete upon return from
        * sync().
        *
        */
        REQ("sync.02", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    truncate - truncate a file to a specified length

SYNOPSIS

    [XSI] [Option Start] #include <unistd.h>
    int truncate(const char *path, off_t length); [Option End]

DESCRIPTION

    The truncate() function shall cause the regular file named by path to have
    a size which shall be equal to length bytes.

    If the file previously was larger than length, the extra data is discarded.
    If the file was previously shorter than length, its size is increased, and
    the extended area appears as if it were zero-filled.

    The application shall ensure that the process has write permission for the
    file.

    If the request would cause the file size to exceed the soft file size limit
    for the process, the request shall fail and the implementation shall
    generate the SIGXFSZ signal for the process.

    This function shall not modify the file offset for any open file
    descriptions associated with the file. Upon successful completion, if the
    file size is changed, this function shall mark for update the st_ctime and
    st_mtime fields of the file, and the S_ISUID and S_ISGID bits of the file
    mode may be cleared.

RETURN VALUE

    Upon successful completion, truncate() shall return 0. Otherwise, -1 shall
    be returned, and errno set to indicate the error.

ERRORS

    The truncate() function shall fail if:

        [EINTR]
        A signal was caught during execution.
        [EINVAL]
        The length argument was less than 0.
        [EFBIG] or [EINVAL]
        The length argument was greater than the maximum file size.
        [EIO]
        An I/O error occurred while reading from or writing to a file system.
        [EACCES]
        A component of the path prefix denies search permission, or write
        permission is denied on the file.
        [EISDIR]
        The named file is a directory.
        [ELOOP]
        A loop exists in symbolic links encountered during resolution of the
        path argument.
        [ENAMETOOLONG]
        The length of the path argument exceeds {PATH_MAX} or a pathname
        component is longer than {NAME_MAX}.
        [ENOENT]
        A component of path does not name an existing file or path is an empty
        string.
        [ENOTDIR]
        A component of the path prefix of path is not a directory.
        [EROFS]
        The named file resides on a read-only file system.

    The truncate() function may fail if:

        [ELOOP]
        More than {SYMLOOP_MAX} symbolic links were encountered during
        resolution of the path argument.

        [ENAMETOOLONG]
        Pathname resolution of a symbolic link produced an intermediate result
        whose length exceeds {PATH_MAX}.
*/

/** truncate_spec **/
//This specification refers to: truncate, truncate64
specification
IntT truncate_spec(CallContext context, CString* path, OffT length,
                   ErrorCode* errno, bool is64bits)
{
    Bool3 isELOOP;
    FileSystem* file_system=getFileSystem(context);
    CString* absPath = resolvePath_Ext(context, file_system, path, &isELOOP);
    File* file = getFile_FileSystem(file_system, absPath);
    FileDescriptor* fdesc=getFileDescriptor_File(context, file);
    OffT oldOffset;

    pre
    {
        if (file!=NULL)
        {
            /*
             * [Function works with regular files only]
             *
             */
            REQ("", "Function works with regular files only", file->kind==RegularFile);
        }

        if (fdesc!=NULL)
        {
            oldOffset=fdesc->offset;
        }

        return true;
    }
    post
    {
        /*
        * Otherwise, -1 shall be returned, and errno set to indicate the error.
        *
        */
        ERROR_BEGIN(POSIX_TRUNCATE, "truncate.07.02;truncate64.truncate.07.02", truncate_spec==-1, *errno )

        /*
         * The truncate() function shall fail if:
         *
         * [EINTR]
         *
         * A signal was caught during execution.
         *
         */
        ERROR_SHALL(POSIX_TRUNCATE, EINTR, "truncate.08.01;truncate64.truncate.08.01", TODO_ERR(EINTR))

        /*
         * The truncate() function shall fail if:
         *
         * [EINVAL]
         *
         * The length argument was less than 0.
         *
         */
        ERROR_SHALL(POSIX_TRUNCATE, EINVAL, "truncate.08.02;truncate64.truncate.08.02", length<0)

        /*
         * The truncate() function shall fail if:
         *
         * [EFBIG] or [EINVAL]
         *
         * The length argument was greater than the maximum file size.
         *
         */
        ERROR_SHALL(POSIX_TRUNCATE, EFBIG, "truncate.08.03;truncate64.truncate.08.03",
            file!=NULL && !is64bits && length>max_LongT)

        /*
         * The truncate() function shall fail if:
         *
         * [EIO]
         *
         * An I/O error occurred while reading from or writing to a file system.
         *
         */
        ERROR_UNCHECKABLE(POSIX_TRUNCATE, EIO, "truncate.08.04;truncate64.truncate.08.04", "Can not check IO errors")

        /*
         * The truncate() function shall fail if:
         *
         *
         * [EACCES]
         *
         * A component of the path prefix denies search permission, or write permission is
         * denied on the file.
         *
         */
         /*
         * The application shall ensure that the process has write permission for the file.
         */
        ERROR_SHALL3(POSIX_TRUNCATE, EACCES, "truncate.08.05;truncate.10;truncate64.truncate.10",
            or_Bool3(isEACCES_dir_open(context, file_system, getParentDir_Path(absPath)),
                     isNoPermOnPath(context, file_system, absPath, false, true, false)))

        /*
         * The truncate() function shall fail if:
         *
         * [EISDIR]
         *
         * The named file is a directory.
         *
         */
        ERROR_SHALL(POSIX_TRUNCATE, EISDIR, "truncate.08.06;truncate64.truncate.08.06", file!=NULL && file->kind==DirectoryFile)

        /*
         * The truncate() function shall fail if:
         *
         * [ELOOP]
         *
         * A loop exists in symbolic links encountered during resolution of the path
         * argument.
         *
         */
        ERROR_SHALL3(POSIX_TRUNCATE, ELOOP, "truncate.08.07;truncate64.truncate.08.07", isELOOP)

        /*
         * The truncate() function shall fail if:
         *
         * [ENAMETOOLONG]
         *
         * The length of the path argument exceeds {PATH_MAX} or a pathname component is
         * longer than {NAME_MAX}.
         *
         */
        ERROR_SHALL3(POSIX_TRUNCATE, ENAMETOOLONG, "truncate.08.08;truncate64.truncate.08.08", isENAMETOOLONG(context, path))

        /*
         * The truncate() function shall fail if:
         *
         * [ENOENT]
         *
         * A component of path does not name an existing file or path is an empty string.
         *
         */
         ERROR_SHALL3(POSIX_TRUNCATE, ENOENT, "truncate.08.09;truncate64.truncate.08.09",
            isENOENT_dir(context, file_system, getParentDir_Path(absPath)))

        /*
         * The truncate() function shall fail if:
         *
         * [ENOTDIR]
         *
         * A component of the path prefix of path is not a directory.
         *
         */
        ERROR_SHALL3(POSIX_TRUNCATE, ENOTDIR, "truncate.08.10;truncate64.truncate.08.10",
             isENOTDIR_dir(context, file_system, getParentDir_Path(absPath)))

        /*
         * The truncate() function shall fail if:
         *
         * [EROFS]
         *
         * The named file resides on a read-only file system.
         *
         */
        ERROR_SHALL(POSIX_TRUNCATE, EROFS, "truncate.08.11;truncate64.truncate.08.11", TODO_ERR(EROFS))

        /*
         * The truncate() function may fail if:
         *
         * [ELOOP]
         *
         * More than {SYMLOOP_MAX} symbolic links were encountered during resolution of
         * the path argument.
         *
         */
        ERROR_MAY3(POSIX_TRUNCATE, ELOOP, "truncate.09.01;truncate64.truncate.09.01", isELOOP)

        /*
         * The truncate() function may fail if:
         *
         * [ENAMETOOLONG]
         *
         * Pathname resolution of a symbolic link produced an intermediate result whose
         * length exceeds {PATH_MAX}.
         *
         */
        ERROR_MAY3(POSIX_TRUNCATE, ENAMETOOLONG, "truncate.09.02;truncate64.truncate.09.02",
            isENAMETOOLONG(context, absPath))

        ERROR_END()

        /*
        * Upon successful completion, truncate() shall return 0.
        *
        */
        REQ("truncate.07.01;truncate64.truncate.07.01", "Function shall return zero", truncate_spec==0);

        if (fdesc!=NULL)
        {
            /*
            * This function shall not modify the file offset for any open file descriptions
            * associated with the file.
            *
            */
            REQ("?truncate.05;truncate64.truncate.05", "This function shall not modify the file offset", fdesc->offset==oldOffset);
        }


        /*
        * If the request would cause the file size to exceed the soft file size limit for
        * the process, the request shall fail and the implementation shall generate the
        * SIGXFSZ signal for the process.
        *
        */
        REQ("truncate.04;truncate64.truncate.04", "", TODO_REQ());

        return true;
    }
}


void onTruncate(CallContext context, CString* path, OffT length, IntT truncate_spec)
{
    Bool3 isELOOP;
    FileSystem* file_system=getFileSystem(context);
    CString* absPath = resolvePath_Ext(context, file_system, path, &isELOOP);
    File* file = getFile_FileSystem(file_system, absPath);
    FileDescriptor* fdesc=getFileDescriptor_File(context, file);

    if (fdesc!=NULL)
    {
        onFtruncate(context, fdesc->file_desc_id, length, truncate_spec);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers


The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    writev - write a vector

SYNOPSIS

    [XSI] [Option Start] #include <sys/uio.h>
    ssize_t writev(int fildes, const struct iovec *iov, int iovcnt); [Option End]

DESCRIPTION

    The writev() function shall be equivalent to write(), except as described
    below. The writev() function shall gather output data from the iovcnt
    buffers specified by the members of the iov array: iov[0], iov[1], ...,
    iov[iovcnt-1]. The iovcnt argument is valid if greater than 0 and less
    than or equal to {IOV_MAX}, as defined in <limits.h>.

    Each iovec entry specifies the base address and length of an area in
    memory from which data should be written. The writev() function shall
    always write a complete area before proceeding to the next.

    If fildes refers to a regular file and all of the iov_len members in the
    array pointed to by iov are 0, writev() shall return 0 and have no other
    effect. For other file types, the behavior is unspecified.

    If the sum of the iov_len values is greater than {SSIZE_MAX}, the
    operation shall fail and no data shall be transferred.

RETURN VALUE

    Upon successful completion, writev() shall return the number of bytes
    actually written. Otherwise, it shall return a value of -1, the
    file-pointer shall remain unchanged, and errno shall be set to indicate an
    error.

ERRORS

    Refer to write().

    In addition, the writev() function shall fail if:

        [EINVAL]
        The sum of the iov_len values in the iov array would overflow an
        ssize_t.

    The writev() function may fail and set errno to:

        [EINVAL]
        The iovcnt argument was less than or equal to 0, or greater than
        {IOV_MAX}.
*/
specification
SSizeT writev_spec(CallContext context, FileDescId fildes, List* iov,
                       ErrorCode* errno)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    OffT oldOffset;
    bool is64bits=false;

    pre
    {
        if (getFileDescriptor(fildes)!=NULL)
        {
            is64bits=getIs64bits_FileDescId(fildes);
        }

        if (file!=NULL)
        {
            /*
            * [Function works with regular files only]
            */
            REQ("", "File shall be regular", file->kind == RegularFile);
        }
        if (fdesc!=NULL)
        {
            oldOffset=fdesc->offset;
        }


        return true;
    }
    post
    {

        if (writev_spec==-1 && fdesc!=NULL)
        {
            /*
            * the file-pointer shall remain unchanged,
            *
            */
            REQ("?writev.07.03", "The file-pointer shall remain unchanged on error",
                fdesc->offset==oldOffset);
        }

        if (sumIOVecMembers(iov)==0)
        {
            /*
            * If fildes refers to a regular file and all of the iov_len members in the array
            * pointed to by iov are 0, writev() shall return 0 and have no other effect.
            *
            */
            REQ("writev.04", "writev() shall return 0", writev_spec==0);

            return true;
        }


        /*
        * Otherwise, it shall return a value of -1,
        *
        */
        /*
        * and errno shall be set to indicate an error.
        *
        */
        ERROR_BEGIN(POSIX_WRITEV, "writev.07.02;writev.07.04", writev_spec==-1, *errno)
        /*
        * In addition, the writev() function shall fail if:
        *
        * [EINVAL]
        *
        * The sum of the iov_len values in the iov array would overflow an ssize_t.
        *
        */
        /*
        * If the sum of the iov_len values is greater than {SSIZE_MAX}, the operation
        * shall fail and no data shall be transferred.
        *
        */
        ERROR_SHALL(POSIX_WRITEV, EINVAL, "writev.08.01;writev.06", sumIOVecMembers(iov)>(SSizeT)max_SSizeT)

        /*
        * The writev() function may fail and set errno to:
        *
        * [EINVAL]
        *
        * The iovcnt argument was less than or equal to 0, or greater than {IOV_MAX}.
        *
        */
        /*
        * The iovcnt argument is valid if greater than 0 and less than or equal to {
        * IOV_MAX}, as defined in <limits.h>.
        *
        */
        ERROR_MAY(POSIX_WRITEV, EINVAL, "writev.09.01;writev.02", size_List(iov)==0 ||
            (getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_UNKNOWN
            &&
            getSystemConfigurationValue(context, SUT_SC_IOV_MAX)!= SC_VALUE_NO_LIMIT
            &&
            size_List(iov) > getSystemConfigurationValue(context, SUT_SC_IOV_MAX)))

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EAGAIN]
         *
         * The O_NONBLOCK flag is set for the file descriptor and the thread would be
         * delayed in the write() operation.
         *
         */
        ERROR_SHALL3(POSIX_WRITE, EAGAIN, "writev.pwrite.41.01", isO_NONBLOCKset(fildes))

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EBADF]
         *
         * The fildes argument is not a valid file descriptor open for writing.
         *
         */
        ERROR_SHALL(POSIX_WRITE, EBADF, "writev.pwrite.41.02", file==NULL ||
            getAccessMode_FileDescId(fildes)==ReadOnly)

        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EFBIG]
         *
         * An attempt was made to write a file that exceeds the implementation-defined
         * maximum file size [XSI]  or the process' file size limit,  and there was no
         * room for any bytes to be written.
         *
         */
         ERROR_UNCHECKABLE(POSIX_WRITE, EFBIG, "writev.pwrite.41.03",
            "Implementation-defined maximum file size can not be checked")


        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [EINTR]
         *
         * The write operation was terminated due to the receipt of a signal, and no data
         * was transferred.
         *
         */
        ERROR_SHALL(POSIX_WRITE, EINTR, "writev.pwrite.41.05", TODO_ERR(EINTR))


        /*
         * The write() and [XSI] pwrite() functions shall fail if:
         *
         * [ENOSPC]
         *
         * There was no free space remaining on the device containing the file.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENOSPC, "writev.pwrite.41.07", "Can not determine free space")

        /*
         * The write() function shall fail if:
         *
         * [EAGAIN] or [EWOULDBLOCK]
         *
         * The file descriptor is for a socket, is marked O_NONBLOCK, and write would
         * block.
         *
         */
        ERROR_SHALL3(POSIX_WRITE, EAGAIN, "writev.42.01", isO_NONBLOCKset(fildes))
        ERROR_SHALL3(POSIX_WRITE, EWOULDBLOCK, "writev.42.01", isO_NONBLOCKset(fildes))


        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [EIO]
         *
         * A physical I/O error has occurred.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, EIO, "writev.pwrite.43.02", "Can not check physical I/O errors")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENOBUFS]
         *
         * Insufficient resources were available in the system to perform the operation.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENOBUFS, "writev.pwrite.43.03", "Can not check insufficient resources case")

        /*
         * The write() and [XSI] pwrite() functions may fail if:
         *
         * [ENXIO]
         *
         * A request was made of a nonexistent device, or the request was outside the
         * capabilities of the device.
         *
         */
        ERROR_UNCHECKABLE(POSIX_WRITE, ENXIO, "writev.pwrite.43.04", "Impossible to check details about devices")

        ERROR_END()

        if (!is64bits)
        {
            /*
             * For regular files, no data transfer shall occur past the offset maximum
             * established in the open file description associated with fildes.
             *
             */
            REQ("writev.pwrite.23", "No data transfer shall occur past the offset maximum",
                oldOffset+writev_spec<max_LongT);
        }

        /*
         * no intervening file modification operation shall occur between changing the
         * file offset and the write operation.
         *
         */
        REQ("writev.pwrite.08.02", "", TODO_REQ());

        /*
         * If a write() requests that more bytes be written than there is room for (for
         * example, [XSI]  the process' file size limit or the physical end of a medium),
         * only as many bytes as there is room for shall be written.
         *
         */
        REQ("writev.pwrite.09", "", TODO_REQ());


        /*
         * If the request would cause the file size to exceed the soft file size limit for
         * the process and there is no room for any bytes to be written, the request shall
         * fail and the implementation shall generate the SIGXFSZ signal for the thread.
         *
         */
        REQ("writev.pwrite.10", "", TODO_REQ());

        /*
         * If write() is interrupted by a signal before it writes any data, it shall
         * return -1 with errno set to [EINTR].
         *
         */
        REQ("writev.pwrite.11", "", TODO_REQ());

        /*
         * If write() is interrupted by a signal after it successfully writes some data,
         * it shall return the number of bytes written.
         *
         */
        REQ("writev.pwrite.12", "", TODO_REQ());

        /*
         * When attempting to write to a file descriptor (other than a pipe or FIFO) that
         * supports non-blocking writes and cannot accept the data immediately:
         *
         * If the O_NONBLOCK flag is clear, write() shall block the calling thread until
         * the data can be accepted.
         *
         */
        REQ_UNCHECKABLE("writev.pwrite.20.01", "Can not check if the thread blocks");

        /*
         * If the O_NONBLOCK flag is set, write() shall not block the thread.
         *
         */
        REQ_UNCHECKABLE("writev.pwrite.20.02.01", "Can not check if the thread blocks");

        /*
         * If some data can be written without blocking the thread, write() shall write
         * what it can and return the number of bytes written.
         *
         */
        REQ_UNCHECKABLE("writev.pwrite.20.02.02", "Can not check if the thread blocks");

        /*
         * Otherwise, it shall return -1 and set errno to [EAGAIN].
         *
         */
        REQ_UNCHECKABLE("writev.pwrite.20.02.03", "Can not check if the thread blocks");


        /*
         * If the O_DSYNC bit has been set, write I/O operations on the file descriptor
         * shall complete as defined by synchronized I/O data integrity completion
         *
         */
        REQ("writev.pwrite.24", "", TODO_REQ());

        /*
         * If the O_SYNC bit has been set, write I/O operations on the file descriptor
         * shall complete as defined by synchronized I/O file integrity completion.
         *
         */
        REQ("writev.pwrite.25", "", TODO_REQ());

        return true;
    }
}


void onWritev(CallContext context, FileDescId fildes, List* iov,
                   SSizeT writev_spec)
{
    FileDescriptor* fdesc=getFileDescriptor(fildes);
    RegularFileDescriptor* regdesc=getDescriptor_FileDescId(fildes);
    File* file=getFile_FileDescId(fildes);
    OffT offset, curOffset;
    IntT i;
    CByteArray* data;
    SizeT sumLen=0;
    List* chunks;

    if (writev_spec!=-1)
    {
        if (fdesc!=NULL)
        {
            /*
             * On a regular file or other file capable of seeking, the actual writing of data
             * shall proceed from the position in the file indicated by the file offset
             * associated with fildes.
             *
             */
            IMPLEMENT_REQ("writev.pwrite.04");

            offset=fdesc->offset;

            if (regdesc!=NULL)
            {
                chunks = regdesc->dataChunks;
            }

            if (regdesc!=NULL && regdesc->append && file!=NULL && file->size!=NULL)
            {
                /*
                 * If the O_APPEND flag of the file status flags is set, the file offset shall be
                 * set to the end of the file prior to each write
                 *
                 */
                IMPLEMENT_REQ("writev.pwrite.08.01;open.05");

                offset=*(file->size);
            }



            sumLen=0;
            curOffset=offset;
            for (i=0;i<size_List(iov);i++)
            {
                IOvec* curVec=get_List(iov, i);
                SizeT  curLen;

                if (sumLen>=writev_spec)
                {
                    break;
                }

                if (sumLen+curVec->iov_len<=writev_spec)
                {
                    curLen=curVec->iov_len;
                }
                else
                {
                    curLen=writev_spec-sumLen;
                }

                sumLen+=curVec->iov_len;

                /*
                * The writev() function shall gather output data from the iovcnt buffers
                * specified by the members of the iov array: iov[0], iov[1], ..., iov[iovcnt-1].
                *
                */
                IMPLEMENT_REQ("writev.01");

                data=readCByteArray_VoidTPtr(curVec->iov_base, curLen);

                if (regdesc!=NULL)
                {

                    /*
                    * Each iovec entry specifies the base address and length of an area in memory
                    * from which data should be written. The writev() function shall always write a
                    * complete area before proceeding to the next.
                    *
                    */
                    IMPLEMENT_REQ("writev.03");

                    append_List(chunks, create_DataChunk( context, curOffset, data));
                    curOffset+=curLen;
                }
            }
            /*
             * Any successful read() from each byte position in the file that was modified by
             * that write shall return the data specified by the write() for that position
             * until such byte positions are again modified.
             *
             */
            IMPLEMENT_REQ("writev.pwrite.14");

            /*
             * Any subsequent successful write() to the same byte position in the file shall
             * overwrite that file data.
             *
             */
            IMPLEMENT_REQ("writev.pwrite.15");

            chunks = reorderChunksList(chunks, context);



            if (file->kind==RegularFile && file->permissions != NULL)
            {
                /*
                 * if the file is a regular file, the S_ISUID and S_ISGID bits of the file mode
                 * may be cleared.
                 *
                 */
                IMPLEMENT_REQ("writev.pwrite.22.02");
                file->permissions->set_uid = Unknown_Bool3;
                file->permissions->set_gid = Unknown_Bool3;
            }


            if (file->size!=NULL && offset+writev_spec >= *(file->size))
            {

                /*
                * Upon successful completion, writev() shall return the number of bytes actually
                * written.
                *
                */
                IMPLEMENT_REQ("writev.07.01");

                /*
                 * On a regular file, if this incremented file offset is greater than the length
                 * of the file, the length of the file shall be set to this file offset.
                 *
                 */
                IMPLEMENT_REQ("writev.12");

                file->size=create_OffTObj(offset+writev_spec);
            }


            if (sumIOVecMembers(iov)>0)
            {
                /*
                 * Upon successful completion, where nbyte is greater than 0, write() shall mark
                 * for update the st_ctime and st_mtime fields of the file,
                 *
                 */
                IMPLEMENT_REQ("writev.pwrite.22.01");
                file->ctime_updated=false;
                file->mtime_updated=false;
            }

            /*
             * Before successful return from write(), the file offset shall be incremented by
             * the number of bytes actually written.
             *
             */
            IMPLEMENT_REQ("writev.11");
            fdesc->offset=fdesc->offset+writev_spec;

        }
    }
}

/********************************************************************/
/**                         Specification Types                    **/
/********************************************************************/

int SKIP_OPEN_CHECK = 0;

specification typedef struct DataChunk DataChunk = {};


specification typedef struct FIFOFileDescriptor FIFOFileDescriptor = {};

FIFOFileDescriptor * create_FIFOFileDescriptor(
    CByteArray* data
    )
{
    return create(&type_FIFOFileDescriptor,
        data);
}

Fcntl_F_GETFL_ReturnType * create_Fcntl_F_GETFL_ReturnType(
    AccessMode access_mode,
    BlockMode  block_mode,
    bool       append_flag,
    IntT       retVal
    )
{
    return create(&type_Fcntl_F_GETFL_ReturnType,
        access_mode,
        block_mode,
        append_flag,
        retVal
        );
}

RegularFileDescriptor * create_RegularFileDescriptor(
    bool  append,
    List* locks,
    List* lockfLocks,
    List* dataChunks,
    List* waitLocks,
    List* waitLockfLocks,
    bool  notExternallyModified
    )
{
    return create(&type_RegularFileDescriptor,
        append,
        locks,
        lockfLocks,
        dataChunks,
        waitLocks,
        waitLockfLocks,
        notExternallyModified
        );
}

RegularFileDescriptor* create_DefaultRegularFileDescriptor()
{
    RegularFileDescriptor* res;
    if(IO_FILE_LOCKF_EQUIVALENT_TO_FCNTL)
    {
        res=create_RegularFileDescriptor( false, create_List(&type_Flock), (void*)NULL, create_List(&type_DataChunk), create_List(&type_Flock), NULL, true);
        res->lockfLocks=res->locks;
        res->waitLockfLocks=res->waitLocks;
    }else{
        res=create_RegularFileDescriptor( false, create_List(&type_Flock), create_List(&type_Flock), create_List(&type_DataChunk), create_List(&type_Flock), create_List(&type_Flock), true);
    }
    return res;
}



Flock* createNormalizedLockfLock(CallContext context, FileDescriptor* fdesc, OffT size, bool is64bits)
{
    Flock* lock=create_Flock(SUT_F_WRLCK, SEEK_SET, (OffT)0, (OffT)0, context.process);


    /*
     * The size argument is the number of contiguous bytes to be locked or unlocked.
     * The section to be locked or unlocked starts at the current offset in the file
     * and extends forward for a positive size or backward for a negative size (the
     * preceding bytes up to but not including the current offset).
     */
     /*
     * F_ULOCK requests may release (wholly or in part) one or more locked sections
     * controlled by the process. Locked sections shall be unlocked starting at the
     * current file offset through size bytes or to the end-of-file if size is (off_t)
     * 0.
     */
    IMPLEMENT_REQ("lockf.08;lockf.13;lockf64.lockf.08;lockf64.lockf.13");

    if (size>0)
    {
        lock->l_start=fdesc->offset;
        lock->l_len=size;
    }
    else if (size<0)
    {
        lock->l_start=fdesc->offset+size;
        lock->l_len=-size;
    }
    else
    {
        lock->l_start=fdesc->offset;

        /*
         * If size is 0, the section from the current offset through the largest
         * possible file offset shall be locked (that is, from the current offset through
         * the present or any future end-of-file).
         */
         /*
         * F_ULOCK requests may release (wholly or in part) one or more locked sections
         * controlled by the process. Locked sections shall be unlocked starting at the
         * current file offset through size bytes or to the end-of-file if size is (off_t)
         * 0.
         */
         IMPLEMENT_REQ("lockf.09;lockf.13;lockf64.lockf.09;lockf64.lockf.13");
        if (!is64bits)
        {
            lock->l_len=max_LongT;
        }
        else
        {
            lock->l_len=max_LLongT;
        }
    }
    return lock;
}

Flock* normalizeLock(CallContext context, FileDescId  fildes, Flock* lock)
{
    File* file=getFile_FileDescId(fildes);
    FileDescriptor* openedFileDesc=getFileDescriptor(fildes);
    RegularFileDescriptor* desc=getDescriptor_FileDescId(fildes);
    Flock* toAddLock=clone(lock);

    if (desc!=NULL && file!=NULL)
    {
        /*
         * The value of l_whence is SEEK_SET, SEEK_CUR, or SEEK_END, to indicate that the
         * relative offset l_start bytes shall be measured from the start of the file,
         * current position, or end of the file, respectively.
         */
        IMPLEMENT_REQ("fcntl.08");

        if (toAddLock->l_whence==SEEK_CUR)
        {
            toAddLock->l_whence=SEEK_SET;
            toAddLock->l_start=openedFileDesc->offset+toAddLock->l_start;
        }
        else if (toAddLock->l_whence==SEEK_END)
        {
            assertion( file->size != NULL, "onFcntl_F_SETLCK_spec: file->size is zero" );

            toAddLock->l_whence=SEEK_SET;
            toAddLock->l_start=*(file->size)+toAddLock->l_start;
        }

        toAddLock->l_pid=context.process;

        /*
         * The value of l_len is the number of consecutive bytes to be locked. The value
         * of l_len may be negative (where the definition of off_t permits negative values
         * of l_len).
         */
        IMPLEMENT_REQ("fcntl.09");

        /*
         * If l_len is positive, the area affected shall start at l_start and end at
         * l_start+ l_len-1.
         */
        IMPLEMENT_REQ("fcntl.14");

        /*
         * If l_len is negative, the area affected shall start at l_start+ l_len and end
         * at l_start-1.
         */
        IMPLEMENT_REQ("fcntl.15");


        /*
         * A lock shall be set to extend to the largest possible value of the file offset
         * for that file by setting l_len to 0.
         */
        IMPLEMENT_REQ("fcntl.17");


        /*
         * If such a lock also has l_start set to 0 and l_whence is set to SEEK_SET, the
         * whole file shall be locked.
         */
        IMPLEMENT_REQ("fcntl.18");

        /*
        * Locks may start and extend beyond the current end of a file,
        */
        IMPLEMENT_REQ("fcntl.16.01");


        if (toAddLock->l_len<0)
        {
            toAddLock->l_start=toAddLock->l_start+toAddLock->l_len;
            toAddLock->l_len=-toAddLock->l_len;
        }
        else if (toAddLock->l_len==0)
        {
            assertion( file->size != NULL, "onFcntl_F_SETLCK_spec: file->size is zero" );

            toAddLock->l_len=*(file->size)-toAddLock->l_start;
        }

    }

    return toAddLock;
}


bool intersectLocks(List* locks, Flock* curLock, Flock* lock, bool adjust)
{
    OffT left2=lock->l_start;
    OffT left1=curLock->l_start;
    OffT right2=lock->l_start+lock->l_len-1;
    OffT right1=curLock->l_start+curLock->l_len-1;
    OffT len2=lock->l_len;
    OffT len1=curLock->l_len;

    if (left2<=left1 && right2<right1 && right2>left1)
    {
        if (adjust)
        {
            curLock->l_start=right2+1;
        }
        return true;
    }
    else if (left2>left1 && right2<right1)
    {
        if (adjust)
        {
            curLock->l_len=left2-left1;
            append_List(locks, create_Flock(curLock->l_type, SEEK_SET, right2+1, right1-right2, curLock->l_pid));
        }
        return true;
    }
    else if (left2<=left1 && right2>=right1)
    {
        if (adjust)
        {
            remove_List(locks, indexOf_List(locks, curLock));
        }
        return true;
    }
    else if (left2>left1 && left2<right1 && right2 >= right1)
    {
        if (adjust)
        {
            curLock->l_len=left2-left1;
        }
        return true;
    }

    return false;
}


bool isOneTypeOfLock(List* locks)
{
    int i=0, j=0;

    for (i=0;i<size_List(locks);i++)
    {
        for (j=0;j<size_List(locks);j++)
        {
            if (i!=j)
            {
                Flock* l1=get_List(locks, i);
                Flock* l2=get_List(locks, j);
                if (intersectLocks(locks, l1, l2, false)
                    && l1->l_type!=l2->l_type && l1->l_pid!=l2->l_pid)
                {
                    return false;
                }
            }
        }
    }

    return true;
}




bool doLocksConflict(Flock* locked, Flock* toLock)
{
    /* The cmd argument is F_SETLK; the type of lock ( l_type) is a shared (F_RDLCK)
     * or exclusive (F_WRLCK) lock and the segment of a file to be locked is already
     * exclusive-locked by another process, or the type is an exclusive lock and some
     * portion of the segment of a file to be locked is already shared-locked or
     * exclusive-locked by another process.
     */

    if (intersectLocks(NULL, locked, toLock, false) &&
        (locked->l_type == SUT_F_WRLCK || toLock->l_type == SUT_F_WRLCK) && (locked->l_pid!=toLock->l_pid))
    {
        return true;
    }

    return false;
}

bool isSectionLocked(CallContext context, FileDescId fildes, List* lockfLocks, OffT offset, SizeT size, bool is64bits)
{
    IntT i=0;
    Flock* normLock=createNormalizedLockfLock(context, getFileDescriptor(fildes), size, is64bits);

    for (i=0;i<size_List(lockfLocks);i++)
    {
        Flock* curLock=get_List(lockfLocks, i);
        if(doLocksConflict(normLock, curLock))
            return true;
    }

    return false;
}

void unlockRegions(List* locks, Flock* toAddLock)
{
    int i=0;
    for (i=0;i<size_List(locks);i++)
    {
        Flock* curLock=get_List(locks, i);
        if (curLock->l_pid == toAddLock->l_pid)
        {
            intersectLocks(locks, curLock, toAddLock, true);
        }
    }

}

void processFileLocking(List* locks, Flock* toAddLock)
{
    if (toAddLock->l_type==SUT_F_UNLCK)
    {
        unlockRegions(locks, toAddLock);
    }
    else
    {
        append_List(locks, toAddLock);
    }
}


Flock* getBlockingLock(Flock* lock, FileDescId fildes)
{

    RegularFileDescriptor* fdesc=getDescriptor_FileDescId(fildes);
    int i=0;

    if (fdesc==NULL)
    {
        return NULL;
    }

    for (i=0;i<size_List(fdesc->locks);i++)
    {
        Flock* curLock=get_List(fdesc->locks, i);
        if (doLocksConflict(curLock, lock))
        {
            return curLock;
        }
    }
    return NULL;
}


List* getBlockingLocks(Flock* lock, List* locks)
{
    List* res=create_List(&type_Flock);

    int i=0;

    for (i=0;i<size_List(locks);i++)
    {
        Flock* curLock=get_List(locks, i);
        if (doLocksConflict(curLock, lock))
        {
            append_List(res, curLock);
        }
    }
    return res;
}


bool isLockInvalid(Flock*  lock)
{
    if (lock->l_type!=SUT_F_RDLCK && lock->l_type!=SUT_F_WRLCK &&
        lock->l_type!=SUT_F_UNLCK)
    {
        return true;
    }
    if (lock->l_whence!=SEEK_SET && lock->l_whence!=SEEK_END &&
        lock->l_whence!=SEEK_CUR)
    {
        return true;
    }

    return false;
}

bool isFlockDeadLock(List* waitList, List* locks, Flock* lock)
{
    List* blockingLocks=getBlockingLocks(lock, locks);
    IntT i=0, j=0, k=0;

    for (j=0;j<size_List(blockingLocks);j++)
    {
        Flock* blockingLock=get_List(blockingLocks, j);
        for (i=0;i<size_List(waitList);i++)
        {
            Flock* curLock=get_List(waitList, i);
            List*  curBlockingLocks=getBlockingLocks(curLock, locks);
            for (k=0;k<size_List(curBlockingLocks);k++)
            {
                Flock* curBlockingLock=get_List(curBlockingLocks, k);
                if (curLock->l_pid         == blockingLock->l_pid &&
                    curBlockingLock->l_pid == lock->l_pid)
                {
                    return true;
                }
            }
        }
    }

    return false;
}

bool isLockfDeadLock(CallContext context, RegularFileDescriptor* fdesc, FileDescriptor* fildes, OffT size, bool is64bits)
{
    isFlockDeadLock(fdesc->waitLockfLocks, fdesc->lockfLocks, createNormalizedLockfLock(context, fildes, size, is64bits));

    return false;
}

bool isLowestUnused_FileDescId_Greater(Map *file_descriptors, FileDescId desc, FileDescId greaterThan)
{

    return true;
}



OffT findMaxOffset(List* chunks)
{
    int i=0;
    DataChunk* curChunk;
    OffT maxOffset=-1;

    for (i=0;i<size_List(chunks);i++)
    {
        curChunk=get_List(chunks, i);
        if (curChunk->offset+ size_CByteArray(curChunk->data)-1 > maxOffset)
        {
            maxOffset=curChunk->offset+ size_CByteArray(curChunk->data)-1;
        }
    }

    return maxOffset;
}


ByteT getByteAtPos(List* chunks, OffT curPos, IntTObj* found)
{
    int i;
    ByteT res;

    *found=false;

    for (i=0;i<size_List(chunks);i++)
    {
        DataChunk* curChunk=get_List(chunks, i);
        if (curPos >= curChunk->offset &&
            curPos < curChunk->offset+size_CByteArray(curChunk->data))
        {
            *found=true;
            res=byteAt_CByteArray(curChunk->data, curPos-curChunk->offset);
        }
    }

    return res;
}


OffT getLengthArray(List* chunks, OffT curPos, OffT maxOffset)
{
    OffT res=0;
    IntTObj* found=create_IntTObj(0);
    getByteAtPos(chunks, curPos, found);
    while (equals(found, create_IntTObj(true)) && curPos<=maxOffset)
    {
        curPos++;
        res++;
        getByteAtPos(chunks, curPos, found);
    }

    return res;
}


OffT findStartArray(List* chunks, OffT curPos, OffT maxOffset)
{
    OffT res=curPos;
    IntTObj* found=create_IntTObj(0);
    getByteAtPos(chunks, res, found);
    while (equals(found, create_IntTObj(false)) && res<=maxOffset)
    {
        res++;
        getByteAtPos(chunks, res, found);
    }

    return res;
}


CByteArray*  getNextCByteArray(List* chunks, OffTObj* curPos,  OffTObj* start, OffT maxOffset)
{
    CByteArray* res = NULL;
    OffT length;
    OffT i;
    IntTObj* found=create_IntTObj(0);

    *start=findStartArray(chunks, *curPos, maxOffset);
    if (*start>maxOffset)
    {
        return res;
    }
    length=getLengthArray(chunks, *start, maxOffset);

    res=create_CByteArray(NULL, length);

    for (i=*start;i<*start+length;i++)
    {
        setByteAt_CByteArray(res, i-*start, getByteAtPos(chunks, i, found));
    }

    *curPos=*start+length;

    return res;
}


List* reorderChunksList(List* chunks, CallContext context)
{
    OffT maxOffset;
    OffTObj* i=create_OffTObj(0);
    OffTObj* start=create_OffTObj(0);
    List* res=create_List(&type_DataChunk);
    DataChunk* curChunk;
    bool found;
    CByteArray* nextArray;

    maxOffset=findMaxOffset(chunks);

    if (maxOffset==-1)
    {
        return chunks;
    }

    nextArray=getNextCByteArray(chunks, i, start, maxOffset);

    while (nextArray!=NULL)
    {
        append_List(res, create_DataChunk(context, *start, nextArray));

        nextArray=getNextCByteArray(chunks, i, start, maxOffset);
    }

    return res;

}


List* truncateChunksList(List* chunks, OffT size, CallContext context)
{
    OffT maxOffset;
    OffTObj* i=create_OffTObj(0);
    OffTObj* start=create_OffTObj(0);
    List* res=create_List(&type_DataChunk);
    DataChunk* curChunk;
    bool found;
    CByteArray* nextArray;

    maxOffset=findMaxOffset(chunks);

    if (maxOffset==-1)
    {
        return chunks;
    }

    if (maxOffset<=size-1)
    {
        return chunks;
    }
    else
    {
        maxOffset=size-1;
    }

    nextArray=getNextCByteArray(chunks, i, start, maxOffset);

    while (nextArray!=NULL)
    {
        append_List(res, create_DataChunk( context, *start, nextArray));

        nextArray=getNextCByteArray(chunks, i, start, maxOffset);
    }

    return res;

}


Bool3 isO_NONBLOCKset(FileDescId fildes)
{
    if (getBlockMode_FileDescId(fildes)!=Nonblocking)
    {
        return False_Bool3;
    }
    return Unknown_Bool3;
}



bool checkDataRead(CallContext context, FileDescId fildes, VoidTPtr buf, SizeT nbyte, OffT offset)
{
    RegularFileDescriptor* descr = getDescriptor_FileDescId(fildes);
    CByteArray* data=readCByteArray_VoidTPtr(buf, nbyte);
    IntT i;
    IntTObj* found=create_IntTObj(0);
    ByteT curByte;

    if (descr==NULL)
    {
        return false;
    }

    /*
     * If data is later written at this point, subsequent reads in the gap between the
     * previous end of data and the newly written data shall return bytes with value 0
     * until data is written into the gap.
     *
     */
    IMPLEMENT_REQ("pread.12;read.12;readv.pread.12");

    for (i=0;i<size_CByteArray(data);i++)
    {
        ByteT cbyte=byteAt_CByteArray(data, i);
        curByte=getByteAtPos(descr->dataChunks, offset+i, found);
        if (equals(found, create_IntTObj(true)))
        {
            if (curByte!=cbyte)
            {
                return false;
            }
        }
        else
        {
            /*
             * If any portion of a regular file prior to the end-of-file has not been
             * written, read() shall return bytes with value 0.
             *
             */
            IMPLEMENT_REQ("pread.11;read.11;readv.pread.11");

            if (0!=cbyte)
            {
                return false;
            }
        }
    }
    return true;
}


SSizeT sumIOVecMembers(List* iov)
{
    IntT i=0;
    SSizeT res=0;
    for (i=0;i<size_List(iov);i++)
    {
        IOvec* curVec=get_List(iov, i);
        res+=curVec->iov_len;
    }
    return res;
}


FileDescriptor* getFileDescriptor_File(CallContext context, File* file)
{
    ProcessState* ps=getProcessState_CallContext(context);
    Map* descriptors=ps->file_descriptors;
    IntT i=0;

    if (file==NULL)
    {
        return NULL;
    }

    for (i=0;i<size_Map(descriptors);i++)
    {
        FileDescIdObj* descID=key_Map(descriptors, i);
        FileDescriptor* fdesc=get_Map(descriptors, descID);
        if (fdesc->file.file==file->fileid.file
            && fdesc->file.system==file->fileid.system)
        {
            return fdesc;
        }
    }
    return NULL;
}

OffT calculateOffset(FileDescriptor* fdesc, IntT whence, OffT offset, OffTObj* file_size)
{
        if (whence==SEEK_SET)
        {
            /*
            * If whence is SEEK_SET, the file offset shall be set to offset bytes.
            */
            IMPLEMENT_REQ("lseek.01");
            return offset;
        }
        else if (whence==SEEK_CUR)
        {
            /*
            * If whence is SEEK_CUR, the file offset shall be set to its current location
            * plus offset.
            */
            IMPLEMENT_REQ("lseek.02");
            return fdesc->offset+offset;
        }
        else
        {

            assertion((file_size != NULL), "calculateOffset: file_size is NULL");

            /*
            * If whence is SEEK_END, the file offset shall be set to the size of the file
            * plus offset.
            */
            IMPLEMENT_REQ("lseek.03");

            /*
            * The lseek() function shall allow the file offset to be set beyond the end of
            * the existing data in the file.
            */
            IMPLEMENT_REQ("lseek.04");


             return *(file_size)+offset;
        }

        return -1;
}


specification typedef struct Flock Flock = {};

Flock * create_Flock(
    LockType  l_type,
    IntT  l_whence,
    OffT   l_start,
    OffT   l_len,
    PidT  l_pid
    )
{
    return create(&type_Flock,
        l_type,
        l_whence,
        l_start,
        l_len,
        l_pid);
}

FcntlArgument * create_FcntlArgument(
    IntT   intArg,
    Flock* ptrArg,
    bool   isIntArg
    )
{
    return create(&type_FcntlArgument,
        intArg,
        ptrArg,
        isIntArg
        );
}

IOvec * create_IOvec(
    VoidTPtr   iov_base,
    SizeT      iov_len
    )
{
    return create(&type_IOvec,
        iov_base,
        iov_len
        );
}

FcntlSETLKWCall * create_FcntlSETLKWCall(
    Flock* lock,
    FileDescId  fildes,
    Flock*  blockingLock
    )
{
    return create(&type_FcntlSETLKWCall,
        lock,
        fildes,
        blockingLock);
}

fcntlSETLKWReturnType * create_fcntlSETLKWReturnType(
    CallContext context,
    IntT functionResult,
    ErrorCode* errno
    )
{
    return create(&type_fcntlSETLKWReturnType,
        context,
        functionResult,
        errno);
}

Fcntl_F_GETLCKReturnType * create_Fcntl_F_GETLCKReturnType(
    IntT res,
    Flock* lock
)
{
    return create(&type_Fcntl_F_GETLCKReturnType,
        res,
        lock
        );
}

Lockf_F_LOCKCall * create_Lockf_F_LOCKCall(
    FileDescId  fildes,
    OffT size,
    bool is64bits,
    List* oldLocks
)
{
    return create(&type_Lockf_F_LOCKCall,
        fildes,
        size,
        is64bits,
        oldLocks
        );
}

Lockf_F_LOCKReturnType * create_Lockf_F_LOCKReturnType(
    CallContext context,
    IntT functionResult,
    ErrorCode* errno
)
{
    return create(&type_Lockf_F_LOCKReturnType,
        context,
        functionResult,
        errno
        );
}

FlockCall * create_FlockCall(
    FileDescId  fildes,
    IntT        operation,
    IntT        block,
    Flock*      blockingLock
)
{
    return create(&type_FlockCall,
        fildes,
        operation,
        block,
        blockingLock
        );
}

FlockReturnType * create_FlockReturnType(
    CallContext context,
    IntT        functionResult,
    ErrorCode*  errno
)
{
    return create(&type_FlockReturnType,
        context,
        functionResult,
        errno);
}

specification typedef struct RegularFileDescriptor RegularFileDescriptor = {};

DataChunk * create_DataChunk(
    CallContext process,
    OffT        offset,
    CByteArray* data
)
{
    return create(&type_DataChunk,
            process,
            offset,
            data
            );
}

/********************************************************************/
/**                        File Desciptors                         **/
/********************************************************************/
specification typedef struct FileDescription FileDescription = {};

FileDescription * create_FileDescription(
    AccessMode  access_mode,
    BlockMode   block_mode,
    FileKind    kind,
    bool        fdatasync,
    bool        is64bits,
    Object*     descriptor
    )
{
    return create(&type_FileDescription,
        access_mode,
        block_mode,
        kind,
        fdatasync,
        is64bits,
        descriptor
        );
}

specification typedef struct FileDescriptor FileDescriptor = {};


FileDescriptor* create_FileDescriptor(
                                      FileDescId file_desc_id,
                                      FileId     file,
                                      CString*   path,
                                      AccessMode access_mode,
                                      BlockMode  block_mode,
                                      FileKind   kind,
                                      bool       fd_cloexec,
                                      OffT       offset,
                                      bool       fdatasync,
                                      bool       is64bits,
                                      Object*    descriptor
                                      )
{
    FileDescription* description=create_FileDescription(access_mode, block_mode, kind, fdatasync, is64bits, (void*)NULL);
    FileDescriptor* res;

    description->descriptor=descriptor;

    res = create( &type_FileDescriptor,
        file_desc_id,
        file,
        path,
        fd_cloexec,
        offset,
        (void*)NULL
        );

    res->description=description;

    return res;
}

FileDescriptor* registerFileDescriptor(
                                       FileDescId file_desc_id,
                                       FileId     file,
                                       CString*   path,
                                       AccessMode access_mode,
                                       BlockMode  block_mode,
                                       FileKind   kind,
                                       bool       fd_cloexec,
                                       OffT       offset,
                                       bool       fdatasync,
                                       bool       is64bits,
                                       Object*    descriptor
                                      )
{
    ProcessState* process;
    FileDescriptor* res;

    process = getProcessState_FileDescId( file_desc_id );
    if (process == NULL)
        return NULL;
    res = create_FileDescriptor( file_desc_id, file, path, access_mode, block_mode, kind,
        fd_cloexec, offset, fdatasync, is64bits, descriptor);
    put_Map( process->file_descriptors, create_FileDescIdObj(file_desc_id), res );
    return res;
}



void unregisterFileDescriptor( FileDescId file_desc_id )
{
    ProcessState* process;

    process = getProcessState_FileDescId( file_desc_id );
    if (process == NULL)
        return;
    remove_Map( process->file_descriptors, create_FileDescIdObj(file_desc_id) );
}


/********************************************************************/
/**                     File Descriptors Storage                   **/
/********************************************************************/
FileDescriptor* getFileDescriptor( FileDescId file_desc_id )
{
    ProcessState* process;

    process = getProcessState_FileDescId( file_desc_id );
    if (process == NULL)
        return NULL;
    return get_Map( process->file_descriptors, create_FileDescIdObj(file_desc_id) );
}

FileDescriptor* findFileDescriptor( Map* file_descriptors, FileDescId file_desc_id )
{
    return get_Map( file_descriptors, create_FileDescIdObj(file_desc_id) );
}

int getFileDescriptorsCount(Map *file_descriptors, FileId fileid)
{
    int i, size, res;

    assertion((file_descriptors != NULL),
        "getFileDescriptorsCount: file_descriptors is NULL");

    size = size_Map(file_descriptors);
    for(i = res = 0; i < size; i++)
    {
        FileDescriptor* file_descriptor = get_Map(file_descriptors, key_Map(file_descriptors, i));
        if(equals_FileId(file_descriptor->file, fileid)) res++;
    }

    return res;
}

Bool3 isOpenFileDescNumberExceedMax(CallContext context)
{
    LongT open_max;
    ProcessState* process;

    process = getProcessState_CallContext(context);
    assertion(process != NULL, "process is NULL");

    open_max = getSystemConfigurationValue(context, SUT_SC_OPEN_MAX);

    if(open_max == SC_VALUE_NO_LIMIT)
        return False_Bool3;

    if(open_max == SC_VALUE_UNKNOWN)
        return Unknown_Bool3;

    return ( size_Map(process->file_descriptors) + 3

        + (POSIX_DIR_IMPLEMENTED_VIA_FILEDESC ? size_Set(process->dir_descriptors) : 0 )

        >= (SizeT)open_max ) ? True_Bool3 : False_Bool3;
}

/********************************************************************/
/**                 File Descriptor Helper Functions               **/
/********************************************************************/

/*
 * Returns true iff fildes is a valid open file descriptor in the
 * filedes.process process.
 */
bool isValid_FileDescId(FileDescId file_desc_id)
{
    ProcessState* process;

    process = getProcessState_FileDescId( file_desc_id );
    if (process == NULL)
        return false;
    return containsKey_Map( process->file_descriptors, create_FileDescIdObj(file_desc_id) );
}

/*
 * Returns true iff file_desc_id is a lowest unused file descriptor in the
 * file_descriptors.
 */
bool isLowestUnused_FileDescId(Map *file_descriptors, FileDescId file_desc_id)
{
    return true;
}

/*
 * Returns/sets path of a valid open file descriptor filedes.
 */
CString* getPath_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    // assertion( file_desc != NULL, "getPath_FileDescId: invalid file descriptor" );

    if(file_desc==NULL)
        return NULL;

    return file_desc->path;
}

void setPath_FileDescId(FileDescId file_desc_id, CString *path)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setPath_FileDescId: invalid file descriptor" );

    file_desc->path = path;
}


/*
 * Returns/sets description of a valid open file descriptor filedes.
 */
FileDescription* getDescription_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

//    assertion( file_desc != NULL, "getPath_FileDescId: invalid file descriptor" );
    if(file_desc==NULL)
        return NULL;

    return file_desc->description;
}

void setDescription_FileDescId(FileDescId file_desc_id, FileDescription *description)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setPath_FileDescId: invalid file descriptor" );

    file_desc->description = description;
}


/*
 * Returns/sets FD_CLOEXEC flag of a valid open file descriptor filedes.
 */
bool getFD_CLOEXEC_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "getPath_FileDescId: invalid file descriptor" );


    return file_desc->fd_cloexec;
}

void setFD_CLOEXEC_FileDescId(FileDescId file_desc_id, bool fd_cloexec)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setPath_FileDescId: invalid file descriptor" );

    file_desc->fd_cloexec = fd_cloexec;
}


/*
 * Returns/sets is64bits flag of a valid open file descriptor filedes.
 */
bool getIs64bits_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "getIs64bits_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getIs64bits_FileDescId: invalid file description" );


    return file_desc->description->is64bits;
}

void setIs64bits_FileDescId(FileDescId file_desc_id, bool value)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setIs64bits_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "setIs64bits_FileDescId: invalid file description" );


    file_desc->description->is64bits = value;
}


/*
 * Returns/sets access mode of a valid open file descriptor filedes.
 */
AccessMode getAccessMode_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "getAccessMode_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    return file_desc->description->access_mode;
}

void setAccessMode_FileDescId(FileDescId file_desc_id, AccessMode access_mode)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setAccessMode_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    file_desc->description->access_mode = access_mode;
}


/*
 * Returns/sets fdatasync flag of a valid open file descriptor filedes.
 */
bool getFdataSync_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "getAccessMode_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    return file_desc->description->fdatasync;
}

void setFdataSync_FileDescId(FileDescId file_desc_id, bool fdatasync)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setAccessMode_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    file_desc->description->fdatasync = fdatasync;
}


/*
 * Returns/sets block mode of a valid open file descriptor filedes.
 */
BlockMode getBlockMode_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "getBlockMode_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    return file_desc->description->block_mode;
}

void setBlockMode_FileDescId(FileDescId file_desc_id, BlockMode block_mode)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setBlockMode_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    file_desc->description->block_mode = block_mode;
}

/*
 * Returns/sets file kind of a valid open file descriptor filedes.
 */
FileKind getFileKind_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "getFileKind_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    return file_desc->description->kind;
}

void setFileKind_FileDescId(FileDescId file_desc_id, FileKind kind)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setFileKind_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    file_desc->description->kind = kind;
}

/*
 * Returns/sets descriptor of a valid open file descriptor filedes.
 */
Object* getDescriptor_FileDescId(FileDescId file_desc_id)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

//    assertion( file_desc != NULL, "getDescriptor_FileDescId: invalid file descriptor" );
//    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );
    if(file_desc==NULL || file_desc->description==NULL)
        return NULL;

    return file_desc->description->descriptor;
}

void setDescriptor_FileDescId(FileDescId file_desc_id, Object *descriptor)
{
    FileDescriptor* file_desc = getFileDescriptor(file_desc_id);

    assertion( file_desc != NULL, "setDescriptor_FileDescId: invalid file descriptor" );
    assertion( file_desc->description != NULL, "getAccessMode_FileDescId: invalid file description" );

    file_desc->description->descriptor = descriptor;
}

/*
 * Returns file of a valid open file descriptor id file_desc_id.
 */
File* getFile_FileDescId(FileDescId fdi)
{
    FileDescriptor* fd = getFileDescriptor(fdi);

    if(fd == NULL) return NULL;

    return getFile_FileId(fd->file);
}

/********************************************************************/
/**                          Open Flags                            **/
/********************************************************************/
specification typedef OpenFlags OpenFlagsObj = {};

OpenFlagsObj* create_OpenFlagsObj( OpenFlags oflag )
{
    return create( &type_OpenFlagsObj,
        oflag.access_mode,
        oflag.block_mode,
        oflag.append,
        oflag.creat,
        oflag.excl,
        oflag.trunc,
        oflag.noctty,
        oflag.large_file
        );
}


/********************************************************************/
/**                         Helper Functions                       **/
/********************************************************************/

FilePermissions* ANDPermissions(FilePermissions* umask, FilePermissions* mode)
{
    FilePermissions* perms=create_FilePermissions(create_FilePermission(false, false, false),
        create_FilePermission(false, false, false), create_FilePermission(false, false, false),
        Unknown_Bool3, Unknown_Bool3, Unknown_Bool3);

    perms->owner->read=mode->owner->read && ((umask->owner==NULL) || (!umask->owner->read));
    perms->owner->write=mode->owner->write && ((umask->owner==NULL) || (!umask->owner->write));
    perms->owner->execute=mode->owner->execute && ((umask->owner==NULL) || (!umask->owner->execute));

    perms->group->read=mode->owner->read && ((umask->group==NULL) || (!umask->group->read));
    perms->group->write=mode->owner->write && ((umask->group==NULL) || (!umask->group->write));
    perms->group->execute=mode->owner->execute && ((umask->group==NULL) || (!umask->group->execute));

    perms->other->read=mode->owner->read && ((umask->other==NULL) || (!umask->other->read));
    perms->other->write=mode->owner->write && ((umask->other==NULL) || (!umask->other->write));
    perms->other->execute=mode->owner->execute && ((umask->other==NULL) || (!umask->other->execute));

    return perms;
}

Bool3 isEACCES_io_file_open(CallContext context, FileSystem *fs, CString *path, bool fileExists, OpenFlags oflags)
{
    /*
    * [EACCES]
    *
    * Search permission is denied on a component of the path prefix, or the file
    * exists and the permissions specified by oflag are denied, or the file does not
    * exist and write permission is denied for the parent directory of the file to be
    * created, or O_TRUNC is specified and write permission is denied.
    */

    Bool3 res = False_Bool3;
    CString* parPath;

    if(!isAbsolute_Path(path))
        return Unknown_Bool3;

    parPath = getParentDir_Path(path);

    if(NULL==parPath)  // is child of root
        return Unknown_Bool3;

    res = or_Bool3(res, isNoPermOnPathComponents(context, fs, parPath, false, false, true)); // check search

    if (fileExists)
    {
        if (oflags.trunc)
        {
            res = or_Bool3(res, isNoPermOnPath(context, fs, path, false, true, false));
        }

        if (oflags.access_mode==ReadOnly)
        {
            res = or_Bool3(res, isNoPermOnPath(context, fs, path, true, false, false));
        }
        else if (oflags.access_mode==WriteOnly)
        {
            res = or_Bool3(res, isNoPermOnPath(context, fs, path, false, true, false));
        }
        else
        {
            res = or_Bool3(res, isNoPermOnPath(context, fs, path, true, true, false));
        }
    }
    else
    {
        res = or_Bool3(res, isNoPermOnPath(context, fs, parPath, false, true, false));
    }

    return res;
}


Bool3 isEACCES_io_file_creat(CallContext context, FileSystem *fs, CString *path, bool fileExists)
{
    /*
    * [EACCES]
    *
    * Search permission is denied on a component of the path prefix, or the file
    * exists and the permissions specified by oflag are denied, or the file does not
    * exist and write permission is denied for the parent directory of the file to be
    * created, or O_TRUNC is specified and write permission is denied.
    */

    Bool3 res = False_Bool3;
    CString* parPath;

    if(!isAbsolute_Path(path))
        return Unknown_Bool3;

    parPath = getParentDir_Path(path);

    if(NULL==parPath)  // is child of root
        return Unknown_Bool3;

    res = or_Bool3(res, isNoPermOnPathComponents(context, fs, parPath, false, false, true)); // check search

    if (fileExists)
    {
        res = or_Bool3(res, isNoPermOnPath(context, fs, path, false, true, false));
        res = or_Bool3(res, isNoPermOnPath(context, fs, path, false, true, false));
    }
    else
    {
        res = or_Bool3(res, isNoPermOnPath(context, fs, parPath, false, true, false));
    }

    return res;
}
