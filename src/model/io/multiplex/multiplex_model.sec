/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */

#include "io/multiplex/multiplex_model.seh"
#include "io/multiplex/multiplex_config.h"
#include "io/file/file_model.seh"
#include "fs/fs/fs_model.seh"
#include "config/system_config.seh"

#pragma SEC subsystem multiplex "io.multiplex"

/* 
   The group of functions 'io.multiplex' consists of: 
       poll [2]
       select [2]
 */

/********************************************************************/
/**                      Specification Types                       **/
/********************************************************************/

specification typedef struct PollFd PollFd = {};

PollFd* create_PollFd(FileDescId fd, ShortT events, ShortT revents)
{
    return create(&type_PollFd, fd, events, revents);
}

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright � 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    poll - input/output multiplexing

SYNOPSIS

    [XSI]  #include <poll.h>
    int poll(struct pollfd fds[], nfds_t nfds, int timeout); 

DESCRIPTION

    The poll() function provides applications with a mechanism for multiplexing
    input/output over a set of file descriptors.For each member of the array 
    pointed to by fds, poll() shall examine the given file descriptor for the 
    event(s) specified in events. The number of pollfd structures in the fds
    array is specified by nfds. The poll() function shall identify those file 
    descriptors on which an application can read or write data, or on which 
    certain events have occurred.

    The fds argument specifies the file descriptors to be examined and the 
    events of interest for each file descriptor. It is a pointer to an array 
    with one member for each open file descriptor of interest. The array's 
    members are pollfd structures within which fd specifies an open file 
    descriptor and events and revents are bitmasks constructed by OR'ing a 
    combination of the following event flags:

        POLLIN 
        Data other than high-priority data may be read without blocking.
        [XSR]  For STREAMS, this flag is set in revents even if the message is 
        of zero length. This flag shall be equivalent to 
        POLLRDNORM | POLLRDBAND. 

        POLLRDNORM 
        Normal data may be read without blocking.
        [XSR]  For STREAMS, data on priority band 0 may be read without 
        blocking. This flag is set in revents even if the message is of zero 
        length. 

        POLLRDBAND 
        Priority data may be read without blocking. 
        [XSR]  For STREAMS, data on priority bands greater than 0 may be read 
        without blocking. This flag is set in revents even if the message is 
        of zero length. 

        POLLPRI 
        High-priority data may be read without blocking. 
        [XSR]  For STREAMS, this flag is set in revents even if the message is 
        of zero length. 

        POLLOUT 
        Normal data may be written without blocking. 
        [XSR]  For STREAMS, data on priority band 0 may be written without 
        blocking. 

        POLLWRNORM 
        Equivalent to POLLOUT. 

        POLLWRBAND 
        Priority data may be written. 
        [XSR]  For STREAMS, data on priority bands greater than 0 may be 
        written without blocking. If any priority band has been written to on 
        this STREAM, this event only examines bands that have been written to 
        at least once. 

        POLLERR 
        An error has occurred on the device or stream. This flag is only valid
        in the revents bitmask; it shall be ignored in the events member. 

        POLLHUP 
        The device has been disconnected. This event and POLLOUT are 
        mutually-exclusive; a stream can never be writable if a hangup has 
        occurred. However, this event and POLLIN, POLLRDNORM, POLLRDBAND, or 
        POLLPRI are not mutually-exclusive. This flag is only valid in the 
        revents bitmask; it shall be ignored in the events member. 

        POLLNVAL 
        The specified fd value is invalid. This flag is only valid in the 
        revents member; it shall ignored in the events member. 

    The significance and semantics of normal, priority, and high-priority data 
    are file and device-specific.

    If the value of fd is less than 0, events shall be ignored, and revents 
    shall be set to 0 in that entry on return from poll().

    In each pollfd structure, poll() shall clear the revents member, except 
    that where the application requested a report on a condition by setting one
    of the bits of events listed above, poll() shall set the corresponding bit
    in revents if the requested condition is true. In addition, poll() shall 
    set the POLLHUP, POLLERR, and POLLNVAL flag in revents if the condition is 
    true, even if the application did not set the corresponding bit in events.

    If none of the defined events have occurred on any selected file 
    descriptor, poll() shall wait at least timeout milliseconds for an event to
    occur on any of the selected file descriptors. If the value of timeout is 
    0, poll() shall return immediately. If the value of timeout is -1, poll()
    shall block until a requested event occurs or until the call is 
    interrupted.

    Implementations may place limitations on the granularity of timeout 
    intervals. If the requested timeout interval requires a finer granularity 
    than the implementation supports, the actual timeout interval shall be 
    rounded up to the next supported value.

    The poll() function shall not be affected by the O_NONBLOCK flag.

    The poll() function shall support regular files, terminal and 
    pseudo-terminal devices, FIFOs, pipes, sockets and [XSR]   STREAMS-based 
    files.  The behavior of poll() on elements of fds that refer to other types
    of file is unspecified.

    Regular files shall always poll TRUE for reading and writing.

    A file descriptor for a socket that is listening for connections shall 
    indicate that it is ready for reading, once connections are available. A 
    file descriptor for a socket that is connecting asynchronously shall 
    indicate that it is ready for writing, once a connection has been 
    established.

RETURN VALUE

    Upon successful completion, poll() shall return a non-negative value. A 
    positive value indicates the total number of file descriptors that have 
    been selected (that is, file descriptors for which the revents member is 
    non-zero). A value of 0 indicates that the call timed out and no file 
    descriptors have been selected. Upon failure, poll() shall return -1 and 
    set errno to indicate the error.

ERRORS

    The poll() function shall fail if:

        [EAGAIN] 
        The allocation of internal data structures failed but a subsequent 
        request may succeed. 

        [EINTR] 
        A signal was caught during poll(). 

        [EINVAL] 
        The nfds argument is greater than {OPEN_MAX}, [XSR]   or one of the fd 
        members refers to a STREAM or multiplexer that is linked (directly or
        indirectly) downstream from a multiplexer.  
*/

specification
IntT poll_spec(CallContext context, List/*<PollFd>*/ *fds, NfdsT nfds, IntT timeout, ErrorCode *errno)
{
    LongT _OPEN_MAX = getSystemConfigurationValue(context, SUT_SC_OPEN_MAX);

    // TODO: assertion(_OPEN_MAX != SC_VALUE_UNKNOWN, "OPEN_MAX constant is unknown");

    pre
    {
        /*
         * It is a pointer to an array with one member for each open file descriptor of 
         * interest.
         */
        REQ("app.poll.05", "fds is pointer to an array", size_List(fds) <= nfds && nfds);

        /*
         * The poll() function shall support regular files, terminal and pseudo-terminal 
         * devices, FIFOs, pipes, sockets and [XSR] STREAMS-based files. The behavior of 
         * poll() on elements of fds that refer to other types of file is unspecified.
         */
        REQ("app.poll.16", "shall support regular files, FIFOs, pipes, ...",
            isValidFileTypes_Multiplex(fds));

        return true;
    }

    coverage C /* TODO: */
    {
        return { TheOnlyBranch, "The only branch" };
    }

    post
    {
        int i, FlagsNum = 0;
        bool bNONBLOCK = false;

        ERROR_BEGIN(POSIX_POLL, "poll.21", *errno && poll_spec == -1, *errno)

            /*
             * The poll() function shall fail if:
             *
             * [EINTR] A signal was caught during poll().
             */
            ERROR_SHALL(POSIX_POLL, EINTR, "poll.21.02", TODO_ERR(EINTR))

            /*
             * The poll() function shall fail if:
             *
             * [EINVAL] The nfds argument is greater than {OPEN_MAX} , [XSR] or one of the fd 
             * members refers to a STREAM or multiplexer that is linked (directly or 
             * indirectly) downstream from a multiplexer.
             */
            ERROR_SHALL(POSIX_POLL, EINVAL, "poll.21.03", TODO_ERR(EINVAL))
                // TODO: _OPEN_MAX == SC_VALUE_UNKNOWN ? true : nfds > _OPEN_MAX)

        ERROR_END()

        if(*errno)
            /*
             * Upon failure, poll() shall return -1 and set errno to indicate the error.
             */
            REQ("poll.20.02", "poll() shall return -1", poll_spec == -1);

        for(i = 0; i < size_List(fds); i++)
        {
            PollFd* plf = get_List(fds, i);
            File* file = getFile_FileDescId(plf->fd);
            FileDescriptor* fd = getFileDescriptor(plf->fd);
            FileDescription* dscshn = fd->description;

            if(plf->revents != 0) ++FlagsNum;
            if(dscshn && dscshn->block_mode == Nonblocking) bNONBLOCK = true;

            if(plf->fd.filedesc < 0)
            {
                /*
                 * If the value of fd is less than 0, events shall be ignored, and revents shall 
                 * be set to 0 in that entry on return from poll().
                 */
                REQ("poll.09", "if fd < 0 revents = 0", plf->revents == 0);

                continue;
            }

            if(!file)
            {
                /*
                 * POLLNVAL
                 *
                 * The specified fd value is invalid.
                 */
                REQ("poll.07.09.01", "fd value is invalid", plf->revents & POLLNVAL);

                continue;
            }

            /*
             * POLLHUP
             *
             * This event and POLLOUT are mutually-exclusive; a stream can never be writable 
             * if a hangup has occurred.
             */
            REQ("poll.07.08.02", "POLLHUP and POLLOUT are mutually-exclusive",
                !((plf->revents & POLLHUP) && (plf->revents & POLLOUT)));

            if(plf->events & POLLNVAL)
                /*
                 * POLLNVAL
                 *
                 * This flag is only valid in the revents member; it shall ignored in the events 
                 * member.
                 */
                REQ("poll.07.09.02", "POLLNVAL only valid in the revents member",
                    !(plf->revents & POLLNVAL));

            switch(file->kind)
            {
            case RegularFile:
                if(plf->events & POLLALL)
                    /*
                     * Regular files shall always poll TRUE for reading and writing.
                     */
                    REQ("poll.17", "Regular files shall always poll TRUE",
                        plf->revents & plf->events);

                /*
                 * POLLERR
                 *
                 * This flag is only valid in the revents bitmask; it shall be ignored in the 
                 * events member.
                 */
                /*
                 * POLLERR
                 *
                 * An error has occurred on the device or stream.
                 */
                REQ("poll.07.07.01;poll.07.07.02", "POLLERR there isn't in revents",
                    (plf->revents & POLLERR) == 0);

                /*
                 * POLLHUP
                 *
                 * This flag is only valid in the revents bitmask; it shall be ignored in the 
                 * events member.
                 */
                /*
                 * POLLHUP
                 *
                 * The device has been disconnected.
                 */
                REQ("poll.07.08.01;poll.07.08.04", "POLLHUP isn't in revents",
                    (plf->revents & POLLHUP) == 0);

                break;

            case FIFOFile:
                if(fd->description->access_mode == ReadOnly)
                {
                    FIFOFileDescriptor* fffd = fd->description->descriptor;
                    bool bR = size_CByteArray(fffd->data) > 0;

                    if(plf->events & POLLIN)
                        /*
                         * POLLIN
                         *
                         * Data other than high-priority data may be read without blocking.
                         */
                        REQ("poll.07.01.01", "data may be read (r)",
                            bR ? plf->revents & POLLIN : !(plf->revents & POLLIN));

                    if(plf->events & POLLRDNORM)
                        /*
                         * POLLRDNORM
                         *
                         * Normal data may be read without blocking.
                         */
                        REQ("poll.07.02.01", "data may be read (r)",
                            bR ? plf->revents & POLLRDNORM : !(plf->revents & POLLRDNORM));

                    if(plf->events & POLLRDBAND)
                        /*
                         * POLLRDBAND
                         *
                         * Priority data may be read without blocking.
                         */
                        REQ("poll.07.03.01", "data may be read (r)",
                            bR ? plf->revents & POLLRDBAND : !(plf->revents & POLLRDBAND));

                    if(plf->events & POLLPRI)
                        /*
                         * POLLPRI
                         *
                         * High-priority data may be read without blocking.
                         */
                        REQ("poll.07.04.01", "data may be read (r)",
                            bR ? plf->revents & POLLPRI : !(plf->revents & POLLPRI));

                    if(plf->events & POLLOUT)
                        /*
                         * POLLOUT
                         *
                         * Normal data may be written without blocking.
                         */
                        /*
                         * POLLWRNORM Equivalent to POLLOUT.
                         */
                        REQ("poll.07.05.01", "normal data may be written (r)",
                            (plf->revents & POLLOUT) == 0);

                    if(plf->events & POLLWRBAND)
                        /*
                         * POLLWRBAND
                         *
                         * Priority data may be written.
                         */
                        REQ("poll.07.06.01", "priority data may be written (r)",
                            (plf->revents & POLLWRBAND) == 0);
                }
                else // if(fd->description->access_mode == WriteOnly)
                {
                    if(plf->events & POLLOUT)
                        /*
                         * POLLOUT
                         *
                         * Normal data may be written without blocking.
                         */
                        /*
                         * POLLWRNORM Equivalent to POLLOUT.
                         */
                        REQ("poll.07.05.01", "normal data may be written (w)",
                            plf->revents & POLLOUT);

                    if(plf->events & POLLWRBAND)
                        /*
                         * POLLWRBAND
                         *
                         * Priority data may be written.
                         */
                        REQ("poll.07.06.01", "priority data may be written (w)",
                            plf->revents & POLLWRBAND);

                    if(plf->events & POLLIN)
                        /*
                         * POLLIN
                         *
                         * Data other than high-priority data may be read without blocking.
                         */
                        REQ("poll.07.01.01", "data may be read (w)",
                            (plf->revents & POLLIN) == 0);

                    if(plf->events & POLLPRI)
                        /*
                         * POLLPRI
                         *
                         * High-priority data may be read without blocking.
                         */
                        REQ("poll.07.04.01", "data may be read (w)",
                            (plf->revents & POLLPRI) == 0);
                }

                /*
                 * POLLERR
                 *
                 * This flag is only valid in the revents bitmask; it shall be ignored in the 
                 * events member.
                 */
                /*
                 * POLLERR
                 *
                 * An error has occurred on the device or stream.
                 */
                REQ("poll.07.07.01;poll.07.07.02", "POLLERR there isn't in revents",
                    (plf->revents & POLLERR) == 0);

                /*
                 * POLLHUP
                 *
                 * This flag is only valid in the revents bitmask; it shall be ignored in the 
                 * events member.
                 */
                /*
                 * POLLHUP
                 *
                 * The device has been disconnected.
                 */
                REQ("poll.07.08.01;poll.07.08.04", "POLLHUP isn't in revents",
                    (plf->revents & POLLHUP) == 0);

                break;
            }

            if(plf->events & POLLALL != POLLALL)
            {
                /*
                 * In each pollfd structure, poll() shall clear the revents member, except that 
                 * where the application requested a report on a condition by setting one of the 
                 * bits of events listed above, poll() shall set the corresponding bit in revents 
                 * if the requested condition is true.
                 */
                REQ("poll.10", "poll() shall clear the revents member",
                    ((~((plf->events & POLLALL) | ~POLLALL)) & plf->revents) == 0);
            }
        } // for(i = 0; i < size_List(fds); i++)

        /*
         * For each member of the array pointed to by fds, poll() shall examine the given 
         * file descriptor for the event(s) specified in events.
         */
        /*
         * The poll() function shall identify those file descriptors on which an 
         * application can read or write data, or on which certain events have occurred.
         */
        REQ("poll.02", "poll() function shall find events", true);

        /*
         * In addition, poll() shall set the POLLHUP, POLLERR, and POLLNVAL flag in 
         * revents if the condition is true, even if the application did not set the 
         * corresponding bit in events.
         */
        REQ("poll.11", "poll() shall set the POLLHUP, POLLERR, and POLLNVAL flag", true);

        if(FlagsNum > 0)
            /*
             * Upon successful completion, poll() shall return a non-negative value.
             *
             * A positive value indicates the total number of file descriptors that have been 
             * selected (that is, file descriptors for which the revents member is non-zero).
             */
            REQ("poll.20.01.01", "the total num of file descs", poll_spec == FlagsNum);

        if(FlagsNum == 0)
            /*
             * Upon successful completion, poll() shall return a non-negative value.
             *
             * A value of 0 indicates that the call timed out and no file descriptors have 
             * been selected.
             */
            REQ("poll.20.01.02", "no file descs have been selected", poll_spec == FlagsNum);

        /*
         * If the value of timeout is 0, poll() shall return immediately.
         */
        REQ("poll.13.01", "if timeout = 0, poll() shall return immediately", true);

        if(bNONBLOCK)
            /*
             * The poll() function shall not be affected by the O_NONBLOCK flag.
             */
            REQ("poll.15", "poll() shall not be affected by the O_NONBLOCK", true);

        /*
         * If the value of timeout is -1, poll() shall block until a requested event 
         * occurs or until the call is interrupted.
         */
        REQ("poll.13.02", "", TODO_REQ());

        /*
         * If none of the defined events have occurred on any selected file descriptor, 
         * poll() shall wait at least timeout milliseconds for an event to occur on any of 
         * the selected file descriptors.
         */
        REQ("poll.12", "", TODO_REQ());

        /*
         * A file descriptor for a socket that is listening for connections shall indicate 
         * that it is ready for reading, once connections are available.
         */
        REQ("poll.18", "", TODO_REQ());

        /*
         * A file descriptor for a socket that is connecting asynchronously shall indicate 
         * that it is ready for writing, once a connection has been established.
         */
        REQ("poll.19", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright � 2001-2004 The IEEE and The Open Group, All Rights reserved.

-------------------------------------------------------------------------------

NAME

    pselect, select - synchronous I/O multiplexing

SYNOPSIS

    #include <sys/select.h>

    int pselect(int nfds, fd_set *restrict readfds,
           fd_set *restrict writefds, fd_set *restrict errorfds,
           const struct timespec *restrict timeout,
           const sigset_t *restrict sigmask);
    int select(int nfds, fd_set *restrict readfds,
           fd_set *restrict writefds, fd_set *restrict errorfds,
           struct timeval *restrict timeout);
    void FD_CLR(int fd, fd_set *fdset);
    int FD_ISSET(int fd, fd_set *fdset);
    void FD_SET(int fd, fd_set *fdset);
    void FD_ZERO(fd_set *fdset);


DESCRIPTION
    The pselect() function shall examine the file descriptor sets whose 
    addresses are passed in the readfds, writefds, and errorfds parameters to 
    see whether some of their descriptors are ready for reading, are ready for
    writing, or have an exceptional condition pending, respectively.

    The select() function shall be equivalent to the pselect() function, except
    as follows:

        For the select() function, the timeout period is given in seconds and 
        microseconds in an argument of type struct timeval, whereas for the 
        pselect() function the timeout period is given in seconds and 
        nanoseconds in an argument of type struct timespec.

        The select() function has no sigmask argument; it shall behave as 
        pselect() does when sigmask is a null pointer.

        Upon successful completion, the select() function may modify the object
        pointed to by the timeout argument.

    The pselect() and select() functions shall support regular files, terminal
    and pseudo-terminal devices, [XSR]   STREAMS-based files,  FIFOs, pipes, 
    and sockets. The behavior of pselect() and select() on file descriptors 
    that refer to other types of file is unspecified.

    The nfds argument specifies the range of descriptors to be tested. The 
    first nfds descriptors shall be checked in each set; that is, the 
    descriptors from zero through nfds-1 in the descriptor sets shall be 
    examined.

    If the readfds argument is not a null pointer, it points to an object of 
    type fd_set that on input specifies the file descriptors to be checked for 
    being ready to read, and on output indicates which file descriptors are 
    ready to read.

    If the writefds argument is not a null pointer, it points to an object of 
    type fd_set that on input specifies the file descriptors to be checked for
    being ready to write, and on output indicates which file descriptors are 
    ready to write.

    If the errorfds argument is not a null pointer, it points to an object of 
    type fd_set that on input specifies the file descriptors to be checked for 
    error conditions pending, and on output indicates which file descriptors 
    have error conditions pending.

    Upon successful completion, the pselect() or select() function shall modify
    the objects pointed to by the readfds, writefds, and errorfds arguments to 
    indicate which file descriptors are ready for reading, ready for writing, 
    or have an error condition pending, respectively, and shall return the 
    total number of ready descriptors in all the output sets. For each file
    descriptor less than nfds, the corresponding bit shall be set on successful
    completion if it was set on input and the associated condition is true for 
    that file descriptor.

    If none of the selected descriptors are ready for the requested operation, 
    the pselect() or select() function shall block until at least one of the 
    requested operations becomes ready, until the timeout occurs, or until 
    interrupted by a signal. The timeout parameter controls how long the 
    pselect() or select() function shall take before timing out. If the timeout
    parameter is not a null pointer, it specifies a maximum interval to wait 
    for the selection to complete.If the specified time interval expires 
    without any requested operation becoming ready, the function shall return.
    If the timeout parameter is a null pointer, then the call to pselect() or 
    select() shall block indefinitely until at least one descriptor meets the 
    specified criteria. To effect a poll, the timeout parameter should not be a
    null pointer, and should point to a zero-valued timespec structure.

    The use of a timeout does not affect any pending timers set up by alarm(),
    ualarm(), or setitimer().

    Implementations may place limitations on the maximum timeout interval 
    supported. All implementations shall support a maximum timeout interval of 
    at least 31 days. If the timeout argument specifies a timeout interval 
    greater than the implementation-defined maximum value, the maximum value 
    shall be used as the actual timeout value. Implementations may also place 
    limitations on the granularity of timeout intervals. If the requested 
    timeout interval requires a finer granularity than the implementation 
    supports, the actual timeout interval shall be rounded up to the next 
    supported value.

    If sigmask is not a null pointer, then the pselect() function shall replace
    the signal mask of the caller by the set of signals pointed to by sigmask 
    before examining the descriptors, and shall restore the signal mask of the
    calling thread before returning.

    A descriptor shall be considered ready for reading when a call to an input 
    function with O_NONBLOCK clear would not block, whether or not the function
    would transfer data successfully. (The function might return data, an
    end-of-file indication, or an error other than one indicating that it is 
    blocked, and in each of these cases the descriptor shall be considered 
    ready for reading.)

    A descriptor shall be considered ready for writing when a call to an output
    function with O_NONBLOCK clear would not block, whether or not the function
    would transfer data successfully.

    If a socket has a pending error, it shall be considered to have an 
    exceptional condition pending. Otherwise, what constitutes an exceptional
    condition is file type-specific. For a file descriptor for use with a 
    socket, it is protocol-specific except as noted below. For other file types
    it is implementation-defined. If the operation is meaningless for a 
    particular file type, pselect() or select() shall indicate that the 
    descriptor is ready for read or write operations, and shall indicate that 
    the descriptor has no exceptional condition pending.

    If a descriptor refers to a socket, the implied input function is the 
    recvmsg() function with parameters requesting normal and ancillary data, 
    such that the presence of either type shall cause the socket to be marked 
    as readable. The presence of out-of-band data shall be checked if the 
    socket option SO_OOBINLINE has been enabled, as out-of-band data is 
    enqueued with normal data. If the socket is currently listening, then it 
    shall be marked as readable if an incoming connection request has been 
    received, and a call to the accept() function shall complete without 
    blocking.

    If a descriptor refers to a socket, the implied output function is the 
    sendmsg() function supplying an amount of normal data equal to the current 
    value of the SO_SNDLOWAT option for the socket. If a non-blocking call to
    the connect() function has been made for a socket, and the connection 
    attempt has either succeeded or failed leaving a pending error, the socket
    shall be marked as writable.

    A socket shall be considered to have an exceptional condition pending if a
    receive operation with O_NONBLOCK clear for the open file description and
    with the MSG_OOB flag set would return out-of-band data without blocking.
    (It is protocol-specific whether the MSG_OOB flag would be used to read 
    out-of-band data.) A socket shall also be considered to have an exceptional
    condition pending if an out-of-band data mark is present in the receive 
    queue. Other circumstances under which a socket may be considered to have 
    an exceptional condition pending are protocol-specific and 
    implementation-defined.

    If the readfds, writefds, and errorfds arguments are all null pointers and 
    the timeout argument is not a null pointer, the pselect() or select() 
    function shall block for the time specified, or until interrupted by a 
    signal. If the readfds, writefds, and errorfds arguments are all null 
    pointers and the timeout argument is a null pointer, the pselect() or 
    select() function shall block until interrupted by a signal.

    File descriptors associated with regular files shall always select true for
    ready to read, ready to write, and error conditions.

    On failure, the objects pointed to by the readfds, writefds, and errorfds 
    arguments shall not be modified.If the timeout interval expires without the
    specified condition being true for any of the specified file descriptors, 
    the objects pointed to by the readfds, writefds, and errorfds arguments 
    shall have all bits set to 0.

    File descriptor masks of type fd_set can be initialized and tested with 
    FD_CLR(), FD_ISSET(), FD_SET(), and FD_ZERO(). It is unspecified whether 
    each of these is a macro or a function. If a macro definition is suppressed
    in order to access an actual function, or a program defines an external 
    identifier with any of these names, the behavior is undefined.

    FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed
    to by fdsetp. If fd is not a member of this set, there shall be no effect 
    on the set, nor will an error be returned.

    FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd 
    is a member of the set pointed to by fdsetp, and shall evaluate to zero 
    otherwise.

    FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to 
    by fdsetp. If the file descriptor fd is already in this set, there shall be
    no effect on the set, nor will an error be returned.

    FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to
    the null set. No error is returned if the set is not empty at the time 
    FD_ZERO() is invoked.

    The behavior of these macros is undefined if the fd argument is less than 0
    or greater than or equal to FD_SETSIZE, or if fd is not a valid file 
    descriptor, or if any of the arguments are expressions with side effects.

RETURN VALUE

    Upon successful completion, the pselect() and select() functions shall 
    return the total number of bits set in the bit masks. Otherwise, -1 shall 
    be returned, and errno shall be set to indicate the error.

    FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall 
    return a non-zero value if the bit for the file descriptor fd is set in the
    file descriptor set pointed to by fdset, and 0 otherwise.

ERRORS

    Under the following conditions, pselect() and select() shall fail and set 
    errno to:

        [EBADF] 
        One or more of the file descriptor sets specified a file descriptor 
        that is not a valid open file descriptor. 
        [EINTR] 
        The function was interrupted before any of the selected events occurred
        and before the timeout interval expired. 
        [XSI]  If SA_RESTART has been set for the interrupting signal, it is 
        implementation-defined whether the function restarts or returns with
        [EINTR]. 

        [EINVAL] 
        An invalid timeout interval was specified. 

        [EINVAL] 
        The nfds argument is less than 0 or greater than FD_SETSIZE. 

        [EINVAL] 
        [XSR]  One of the specified file descriptors refers to a STREAM or 
        multiplexer that is linked (directly or indirectly) downstream from a 
        multiplexer.  
*/

specification
IntT select_spec (  CallContext context,
                    IntT nfds,
                    Set* /*IntT*/ readfds,
                    Set* /*IntT*/ writefds,
                    Set* /*IntT*/ errorfds,
                    TimeValTObj* timeout,
                    ErrorCode* errno
                 )
{
    pre
    {
        REQ("", "errno shall be a pointer to ErrorCode", errno != NULL);
        
        /*
         * The pselect() and select() functions shall support regular files, terminal and
         * pseudo-terminal devices, [XSR] [Option Start] STREAMS-based files, [Option End]
         * FIFOs, pipes, and sockets. The behavior of pselect() and select() on file
         * descriptors that refer to other types of file is unspecified.
         */
        REQ("app.select.02", "", TODO_REQ());
    
        return true;
    }

    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }

    post
    {
        int i, FlagsNum = 0;
        
        if(select_spec == -1)
        {
            /*
             * On failure, the objects pointed to by the readfds, writefds, and errorfds
             * arguments shall not be modified.
             */
            REQ("select.42", "", ((@readfds != NULL) => equals(@readfds, readfds)) &&
                                 ((@writefds != NULL) => equals(@writefds, writefds)) &&
                                 ((@errorfds != NULL) => equals(@errorfds, errorfds)));
        }
    
//        ERROR_BEGIN(POSIX_SELECT, "select.45", *errno != 0, *errno)
//
//            /*
//             * Under the following conditions, pselect() and select() shall fail and set errno
//             * to:
//             *
//             * [EBADF] One or more of the file descriptor sets specified a file descriptor
//             * that is not a valid open file descriptor.
//             */
//            ERROR_SHALL(POSIX_SELECT, EBADF, "select.45.01",
//                !(isValidFileDescs_Multiplex(readfds) &&
//                isValidFileDescs_Multiplex(writefds) &&
//                isValidFileDescs_Multiplex(errorfds)))
//
//            /*
//             * Under the following conditions, pselect() and select() shall fail and set errno
//             * to:
//             *
//             * [EINTR] The function was interrupted before any of the selected events occurred
//             * and before the timeout interval expired. [XSI] [Option Start] If SA_RESTART has
//             * been set for the interrupting signal, it is implementation-defined whether the
//             * function restarts or returns with [EINTR]. [Option End]
//             */
//            ERROR_SHALL(POSIX_SELECT, EINTR, "select.45.02", TODO_ERR(EINTR) )
//
//            /*
//             * Under the following conditions, pselect() and select() shall fail and set errno
//             * to:
//             *
//             * [EINVAL] An invalid timeout interval was specified.
//             */
//            /*
//             * Under the following conditions, pselect() and select() shall fail and set errno
//             * to:
//             *
//             * [EINVAL] The nfds argument is less than 0 or greater than FD_SETSIZE.
//             */
//            /*
//             * Under the following conditions, pselect() and select() shall fail and set errno
//             * to:
//             *
//             * [EINVAL] [XSR] [Option Start] One of the specified file descriptors refers to a
//             * STREAM or multiplexer that is linked (directly or indirectly) downstream from a
//             * multiplexer. [Option End]
//             */
//            ERROR_SHALL(POSIX_SELECT, EINVAL, "select.45.03;select.45.04;select.45.05",
//                           /* TODO: */TODO_ERR(EINVAL) /*select.45.03*/
//                        || nfds < 0 /* TODO: || nfds > FD_SETSIZE */ /*select.45.04*/
//                        || TODO_ERR(EINVAL) /*select.45.05 TODO: b1*/
//                        )
//        ERROR_END()
        
        if(select_spec == -1)
            /*
             * Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
             */
            REQ("select.44.02", "-1 returned and errno != 0", *errno != 0);

		if(readfds)
		{
	        for(i = 0; i < size_Set(@readfds); i++)
	        {
	            IntT fileId = *((IntTObj*)get_Set(@readfds, i));
	            bool bSet = contains_Set(readfds, create_IntTObj(fileId));
	            FileDescId fdi = { context.system, context.process, fileId };
	            File* file = getFile_FileDescId(fdi);
	            FileDescriptor* fd = getFileDescriptor(fdi);
	            FileDescription* dscshn = fd->description;
	            
	            switch(file->kind)
	            {
	            case RegularFile:
	                FlagsNum++;
	            
	                /*
	                 * If the readfds argument is not a null pointer, it points to an object of type
	                 * fd_set that on input specifies the file descriptors to be checked for being
	                 * ready to read, and on output indicates which file descriptors are ready to read.
	                 */
	                /*
	                 * File descriptors associated with regular files shall always select true for
	                 * ready to read, ready to write, and error conditions.
	                 */
	                REQ("select.41;select.05", "", bSet == true);
	            
	                break;
	
	            case FIFOFile:
	                if(fd->description->access_mode == ReadOnly)
	                {
	                    FIFOFileDescriptor* fffd = fd->description->descriptor;
	                    bool bR = size_CByteArray(fffd->data) > 0;
	                    
	                    if(bR) FlagsNum++;
	                    
	                    /*
	                     * If the readfds argument is not a null pointer, it points to an object of type
	                     * fd_set that on input specifies the file descriptors to be checked for being
	                     * ready to read, and on output indicates which file descriptors are ready to read.
	                     */
	                    REQ("select.05", "", bR == bSet);
	                }
	                else // if(fd->description->access_mode == WriteOnly)
	                {
	                    /*
	                     * If the readfds argument is not a null pointer, it points to an object of type
	                     * fd_set that on input specifies the file descriptors to be checked for being
	                     * ready to read, and on output indicates which file descriptors are ready to read.
	                     */
	                    REQ("select.05", "", bSet == false);
	                }
	                break;
	
	            default:
	                REQ("", "illigal file type", false);
	            }
	        }
		} // if(readfds)

		if(writefds)
		{
	        for(i = 0; i < size_Set(@writefds); i++)
	        {
	            IntT fileId = *((IntTObj*)get_Set(@writefds, i));
	            bool bSet = contains_Set(writefds, create_IntTObj(fileId));
	            FileDescId fdi = { context.system, context.process, fileId };
	            File* file = getFile_FileDescId(fdi);
	            FileDescriptor* fd = getFileDescriptor(fdi);
	            FileDescription* dscshn = fd->description;
	            
	            switch(file->kind)
	            {
	            case RegularFile:
	                FlagsNum++;

	                /*
			         * If the writefds argument is not a null pointer, it points to an object of type
			         * fd_set that on input specifies the file descriptors to be checked for being
			         * ready to write, and on output indicates which file descriptors are ready to
			         * write.
			         */
	                /*
	                 * File descriptors associated with regular files shall always select true for
	                 * ready to read, ready to write, and error conditions.
	                 */
	                REQ("select.41;select.06", "", bSet == true);
	            
	                break;
	
	            case FIFOFile:
	                if(fd->description->access_mode == ReadOnly)
	                {
	                    /*
	                     * If the readfds argument is not a null pointer, it points to an object of type
	                     * fd_set that on input specifies the file descriptors to be checked for being
	                     * ready to read, and on output indicates which file descriptors are ready to read.
	                     */
	                    REQ("select.05", "", bSet == false);
	                }
	                else // if(fd->description->access_mode == WriteOnly)
	                {
	                	FlagsNum++;

	                    /*
	                     * If the readfds argument is not a null pointer, it points to an object of type
	                     * fd_set that on input specifies the file descriptors to be checked for being
	                     * ready to read, and on output indicates which file descriptors are ready to read.
	                     */
	                    REQ("select.05", "", bSet == true);
	                }
	                break;
	
	            default:
	                REQ("", "illigal file type", false);
	            }
	        }
		} // if(writefds)

		/*
         * The first nfds descriptors shall be checked in each set; that is, the
         * descriptors from zero through nfds-1 in the descriptor sets shall be examined.
         */
        REQ("select.04", "", true);
        
        /*
         * Upon successful completion, the pselect() or select() function shall modify the
         * objects pointed to by the readfds, writefds, and errorfds arguments to indicate
         * which file descriptors are ready for reading, ready for writing, or have an
         * error condition pending, respectively, and shall return the total number of
         * ready descriptors in all the output sets.
         */
        REQ("select.08", "", true);
        
        /*
         * For each file descriptor less than nfds, the corresponding bit shall be set on
         * successful completion if it was set on input and the associated condition is
         * true for that file descriptor.
         */
        REQ("select.09", "", true);

        /*
         * If the errorfds argument is not a null pointer, it points to an object of type
         * fd_set that on input specifies the file descriptors to be checked for error
         * conditions pending, and on output indicates which file descriptors have error
         * conditions pending.
         */
        REQ("select.07", "", TODO_REQ());
        
        if(timeout != NULL)
        {
            /*
             * If the timeout parameter is not a null pointer, it specifies a maximum interval
             * to wait for the selection to complete.
             */
            REQ("select.12", "", TODO_REQ());

            /*
             * If the specified time interval expires without any requested operation becoming
             * ready, the function shall return.
             */
            REQ("select.13", "", TODO_REQ());
        }
        else
        {
            /*
             * If the timeout parameter is a null pointer, then the call to pselect() or
             * select() shall block indefinitely until at least one descriptor meets the
             * specified criteria.
             */
            REQ("select.14", "", TODO_REQ());
        }

        /*
         * If the timeout interval expires without the specified condition being true for
         * any of the specified file descriptors, the objects pointed to by the readfds,
         * writefds, and errorfds arguments shall have all bits set to 0.
         */
        REQ("select.43", "", true);

        /*
         * Upon successful completion, the pselect() and select() functions shall return
         * the total number of bits set in the bit masks.
         */
        REQ("select.44.01", "", select_spec == FlagsNum);

        // ------------------- BASE1 (19) -------------------------
        /*
         * The select() function shall be equivalent to the pselect() function, except as
         * follows:
         *
         * For the select() function, the timeout period is given in seconds and
         * microseconds in an argument of type struct timeval, whereas for the pselect()
         * function the timeout period is given in seconds and nanoseconds in an argument
         * of type struct timespec.
         */
        REQ("select.01.01", "", TODO_REQ());

        /*
         * If none of the selected descriptors are ready for the requested operation, the
         * pselect() or select() function shall block until at least one of the requested
         * operations becomes ready, until the timeout occurs, or until interrupted by a
         * signal.
         */
        REQ("select.10", "", TODO_REQ());
        
        /*
         * The timeout parameter controls how long the pselect() or select() function
         * shall take before timing out.
         */
        REQ("select.11", "", TODO_REQ());
        
        /*
         * The use of a timeout does not affect any pending timers set up by alarm(),
         * ualarm(), or setitimer().
         */
        REQ("select.16", "", TODO_REQ());

        /*
         * If a socket has a pending error, it shall be considered to have an exceptional
         * condition pending.
         */
        REQ("select.26", "", TODO_REQ());

        /*
         * Otherwise, what constitutes an exceptional condition is file type-specific.
         */
        REQ("select.27", "", TODO_REQ());

        /*
         * For a file descriptor for use with a socket, it is protocol-specific except as
         * noted below. For other file types it is implementation-defined.
         */
        REQ("select.28", "", TODO_REQ());
        
        /*
         * If the operation is meaningless for a particular file type, pselect() or
         * select() shall indicate that the descriptor is ready for read or write
         * operations, and shall indicate that the descriptor has no exceptional condition
         * pending.
         */
        REQ("select.29", "", TODO_REQ());

        /*
         * If a descriptor refers to a socket, the implied input function is the recvmsg()
         * function with parameters requesting normal and ancillary data, such that the
         * presence of either type shall cause the socket to be marked as readable.
         */
        REQ("select.30", "", TODO_REQ());

        /*
         * The presence of out-of-band data shall be checked if the socket option
         * SO_OOBINLINE has been enabled, as out-of-band data is enqueued with normal data.
         */
        REQ("select.31", "", TODO_REQ());

        /*
         * If the socket is currently listening, then it shall be marked as readable if an
         * incoming connection request has been received, and a call to the accept()
         * function shall complete without blocking.
         */
        REQ("select.32", "", TODO_REQ());

        /*
         * If a descriptor refers to a socket, the implied output function is the sendmsg()
         * function supplying an amount of normal data equal to the current value of the
         * SO_SNDLOWAT option for the socket.
         */
        REQ("select.33", "", TODO_REQ());

        /*
         * If a non-blocking call to the connect() function has been made for a socket,
         * and the connection attempt has either succeeded or failed leaving a pending
         * error, the socket shall be marked as writable.
         */
        REQ("select.34", "", TODO_REQ());

        /*
         * A socket shall be considered to have an exceptional condition pending if a
         * receive operation with O_NONBLOCK clear for the open file description and with
         * the MSG_OOB flag set would return out-of-band data without blocking.
         */
        REQ("select.35", "", TODO_REQ());

        /*
         * It is protocol-specific whether the MSG_OOB flag would be used to read out-of-
         * band data.
         */
        REQ("select.36", "", TODO_REQ());

        /*
         * A socket shall also be considered to have an exceptional condition pending if
         * an out-of-band data mark is present in the receive queue.
         */
        REQ("select.37", "", TODO_REQ());

        /*
         * Other circumstances under which a socket may be considered to have an
         * exceptional condition pending are protocol-specific and implementation-defined.
         */
        REQ("select.38", "", TODO_REQ());
        
        /*
         * If the readfds, writefds, and errorfds arguments are all null pointers and the
         * timeout argument is not a null pointer, the pselect() or select() function
         * shall block for the time specified, or until interrupted by a signal.
         */
        REQ("select.39", "", TODO_REQ());

        /*
         * If the readfds, writefds, and errorfds arguments are all null pointers and the
         * timeout argument is a null pointer, the pselect() or select() function shall
         * block until interrupted by a signal.
         */
        REQ("select.40", "", TODO_REQ());

        return true;
    }
}

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/

bool isValidFileTypes_Multiplex(List*/*<PollFd>*/ fds)
{
    int i;

    assertion(fds != NULL, "isValidFileTypes_PollFdList: PollFd list is NULL");

    for(i = 0; i < size_List(fds); i++)
    {
        PollFd* pf = get_List(fds, i);
        FileDescId fd = pf->fd;
        File* file = getFile_FileDescId(fd);

        assertion(file != NULL, "isValidFileTypes_PollFdList: "
                                "can't find the file in model state");

        switch(file->kind)
        {
        case RegularFile:
        case FIFOFile:
        /*case Socket: */break;
        default: return false;
        }
    }

    return true;
}

bool isValidFileDescs_Multiplex(Set*/*<IntT>*/ fds)
{
    /* TODO: */

    return true;
}
