/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "signal/sigctrl/tests/sigctrl_scenario.seh"
#include "signal/sigstr/sigstr_media.seh"

#include <stdio.h>

static CallContext context;
static CallContext context2;

static bool init_signal_sigctrl_basic_scenario(int argc, char** argv)
{
    bool result=true;

    context = createProcess();
    context2 = createProcess();
    if(isWrong_ThreadId(context)) result = false;

    setTSTimeModel(NotUseTSTime);
    setWTimeMSec(SERIALIZATION_TIME*10);

    initSignalToString( context );

    return result;
}

static void finish_signal_sigctrl_basic_scenario(void)
{
    ;//TO DO delete process
}

bool isStationarySignalState_Ctrl(void)
{
    return true;
}

Map* saveSignalModelState_Ctrl(void)
{
    return clone(systems);
}

void restoreSignalModelState_Ctrl(Map* st)
{
    systems = st;
}


scenario bool signal_sighold_scen(void)
{
    sighold_spec(context, SUT_SIGUSR1, requestErrorCode());
    return true;
}

scenario bool signal_sigignore_scen(void)
{
    sigignore_spec(context, SUT_SIGUSR1, requestErrorCode());
    return true;
}

scenario bool signal_sigpause_scen(void)
{
    verbose("sdffe\n");
    verbose( "signal_sigpause_scen : SUT_SIGUSR1 is %d\n", SUT_SIGUSR1 );
    kill_spec(context2, getProcessId_CallContext(context), create_Signal(SUT_SIGUSR1), false);
    ts_sleep_msec(500);
    sigpause_spec(context, SUT_SIGUSR1, requestErrorCode());
    ts_sleep_msec(500);
    return true;
}

scenario bool signal_sigrelse_scen(void)
{
    sigrelse_spec(context, SUT_SIGUSR1, requestErrorCode());
    return true;
}

scenario bool signal_sigset_scen(void)
{
    sigset_spec(context, SUT_SIGUSR1, SIG_USER_CATCHER, requestErrorCode());
    return true;
}

scenario dfsm signal_sigctrl_basic_scenario =
{
    .init   = init_signal_sigctrl_basic_scenario,
    .finish = finish_signal_sigctrl_basic_scenario,

    .saveModelState = (PtrSaveModelState)saveSignalModelState_Ctrl,
    .restoreModelState = (PtrRestoreModelState)restoreSignalModelState_Ctrl,
    .isStationaryState = (PtrIsStationaryState)isStationarySignalState_Ctrl,

    .actions = {
         signal_sigset_scen,
         signal_sighold_scen,
         signal_sigpause_scen,
         signal_sigignore_scen,
         signal_sigrelse_scen,
         NULL
    }
};

