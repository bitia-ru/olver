/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Portions of this text are reprinted and reproduced in electronic form
 * from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology
 * -- Portable Operating System Interface (POSIX), The Open Group Base
 * Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
 * Electrical and Electronics Engineers, Inc and The Open Group. In the
 * event of any discrepancy between this version and the original IEEE and
 * The Open Group Standard, the original IEEE and The Open Group Standard
 * is the referee document. The original Standard can be obtained online at
 * http://www.opengroup.org/unix/online.html.
 */


#include "signal/sigaction/sigaction_config.h"
#include "signal/sigaction/sigaction_model.seh"

#pragma SEC subsystem sigaction "signal.sigaction"

/*
   The group of functions 'signal.sigaction' consists of:
       __libc_current_sigrtmax [1]          b0
       __libc_current_sigrtmin [1]          b0
       __sysv_signal [1]                    b0
       bsd_signal [2]                       b0
       pause [2]                            b0
       pthread_sigmask [2]                  b0
       sigaction [2]                        b0
       sigaltstack [2]                      b0
       siginterrupt [2]                     b0
       signal [2]                           b0
       sigpending [2]                       b0
       sigprocmask [2]                      b0
       sigreturn [1]                        b0
       sigsuspend [2]                       b0
 */

/********************************************************************/
/**                      Interface Functions                       **/
/********************************************************************/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __libc_current_sigrtmax - return number of available real-time signal
    with lowest priority

SYNOPSIS

    int __libc_current_sigrtmax(void);

DESCRIPTION

    __libc_current_sigrtmax() returns the number of an available real-time
    signal with the lowest priority.

    __libc_current_sigrtmax() is not in the source standard; it is only
    in the binary standard.

RETURN VALUE

    __libc_current_sigrtmax shall return number of an available real-time
    signal with the lowest priority.

ERRORS

    No errors are defined.

*/

specification
IntT __libc_current_sigrtmax_spec( CallContext context)
{
    SystemState* system_state_pre;
    SystemState* system_state_post;
    pre
    {
        system_state_pre  = getSystemState_CallContext(context);
        /* [System state should be defined] */
        REQ("","System state should be defined", system_state_pre != NULL);
        return true;
    }
    coverage C
    {
        return { ReturnNumberOfAvailableRealTimeSignalWithLowestPriority,
                 "Return number of available real-time signal with lowest priority"
               };
    }
    post
    {
        system_state_post = getSystemState_CallContext(context);
        REQ("","System state should be defined", system_state_post != NULL);

        /*
         * __libc_current_sigrtmax() returns the number of
         * an available real-time signal with the lowest priority.
         */
        REQ("__libc_current_sigrtmax.01",
            "SIGRTMAX should return variable from system configuration",
            system_state_post->configuration->sigrtmax == __libc_current_sigrtmax_spec);

        /*
         * [If it is a first function call, return value should be > 0 and
         * realtime signal numbers shouldn't intersect with usual signal
         * numbers, and if SIGRTMIN was initialized, SIGRTMIN < SIGRTMAX]
         */

        if (system_state_pre->configuration->sigrtmax == -1)
        {
            //first function call
            if (system_state_post->configuration->sigrtmin != -1)
            {
                /*
                 * [SIGRTMIN was already initialized, and we check that
                 *  SIGRTMIN < then SIGRTMAX]
                 */
                REQ("","SIGRTMAX should be > SIGRTMIN",
                    (system_state_post->configuration->sigrtmax >
                     system_state_post->configuration->sigrtmin));
            };
            // [Realtime signals don't intersect with usual signals]
            return (system_state_post->configuration->sigrtmax > SIGDEFF);
        }
        else
        {
            //function already was called
            return (system_state_post->configuration->sigrtmax ==
                    system_state_pre->configuration->sigrtmax);
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __libc_current_sigrtmin - return number of available real-time signal
    with highest priority

SYNOPSIS

    int __libc_current_sigrtmin(void);

DESCRIPTION

    __libc_current_sigrtmin() returns the number of an available real-time
    signal with the highest priority.

    __libc_current_sigrtmin() is not in the source standard; it is only
    in the binary standard.

RETURN VALUE

    __libc_current_sigrtmin shall return number of an available real-time
    signal with the highest priority.

ERRORS

    No errors are defined.
*/
/*
 * [At first call mediator should initialize SIGRTMIN variable. Value
 *  of this variable before initialization is -1]
 */
specification
IntT __libc_current_sigrtmin_spec( CallContext context)
{
    SystemState* system_state_pre;
    SystemState* system_state_post;
    pre
    {
        system_state_pre  = getSystemState_CallContext(context);
        /* [System state should be defined] */
        REQ("","System state should be defined", system_state_pre != NULL);
        return true;
    }
    coverage C
    {
        return { ReturnNumberOfAvailableRealTimeSignalWithHighestPriority,
                 "Return number of available real-time signal with highest priority"
               };
    }
    post
    {
        system_state_post = getSystemState_CallContext(context);
        REQ("","System state should be defined", system_state_post != NULL);

        /*
         * __libc_current_sigrtmin() returns the number of
         * an available real-time signal with the highest priority.
         */
         REQ("__libc_current_sigrtmin.01",
             "SIGRTMIN should return variable from system configuration",
             system_state_post->configuration->sigrtmin == __libc_current_sigrtmin_spec);

        /*
         * [If it is a first function call, return value should be > 0 and
         * realtime signal numbers shouldn't intersect with usual signal
         * numbers, and if SIGRTMAX already initialized, SIGRTMIN < SIGRTMAX]
         */
        if (system_state_pre->configuration->sigrtmin == -1)
        {
            //first function call
            if (system_state_post->configuration->sigrtmax != -1)
            {
                /*
                 * [SIGRTMAX was already initialized, and we check that
                 *  SIGRTMIN < then SIGRTMAX]
                 */
                REQ("","SIGRTMAX should be > SIGRTMIN",
                    (system_state_post->configuration->sigrtmax >
                     system_state_post->configuration->sigrtmin));
            };
            return (system_state_post->configuration->sigrtmin > SIGDEFF);
        }
        else
        {
            //function already was called
            return (system_state_pre->configuration->sigrtmin ==
                    system_state_post->configuration->sigrtmin);
        }
    }
}

/*
specification
SignalHandler __sysv_signal_spec( CallContext context, IntT signo, SignalHandler handler)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { TheOnlyBranch, "The only branch" };
    }
    post
    {
        return true;
    }
}
*/

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    bsd_signal - simplified signal facilities

SYNOPSIS

    [OB XSI] #include <signal.h>void (*bsd_signal(int sig,
                                        void (*func)(int)))(int);

DESCRIPTION

    The bsd_signal() function provides a partially compatible interface for
    programs written to historical system interfaces (see APPLICATION USAGE).

    The function call bsd_signal(sig, func) shall be equivalent to the
    following:

    void (*bsd_signal(int sig, void (*func)(int)))(int)
    {
        struct sigaction act, oact;

        act.sa_handler = func;
        act.sa_flags = SA_RESTART;

        sigemptyset(&act.sa_mask);
        sigaddset(&act.sa_mask, sig);
        if (sigaction(sig, &act, &oact) == -1)
            return(SIG_ERR);

        return(oact.sa_handler);
    }


    The handler function should be declared:

        void handler(int sig);


    where sig is the signal number. The behavior is undefined if func is a
    function that takes more than one argument, or an argument of a different
    type.

RETURN VALUE

    Upon successful completion, bsd_signal() shall return the previous action
    for sig. Otherwise, SIG_ERR shall be returned and errno shall be set to
    indicate the error.

ERRORS

    Refer to sigaction().
*/
specification
SignalHandler bsd_signal_spec( CallContext context, Signal* sig, SignalHandler handler, ErrorCode* errno)
{
    ProcessState* ps = getProcessState_CallContext(context);
    SigAction*    preAct = get_Map(ps->signal_actions, create_SignalObj(*sig));

    pre
    {
        if (preAct!=NULL)
        {
            preAct = clone(preAct);
        }

        return true;
    }
    post
    {
        /*
        * Otherwise, SIG_ERR shall be returned and errno shall be set to indicate the
        * error.
        */
        ERROR_BEGIN(POSIX_BSD_SIGNAL, "bsd_signal.05", bsd_signal_spec==SUT_SIG_ERR, *errno)

        /*
        * The sigaction() function shall fail if:
        *
        * [EINVAL] The sig argument is not a valid signal number or an attempt is made to
        * catch a signal that cannot be caught or ignore a signal that cannot be ignored.
        */
        ERROR_SHALL(POSIX_BSD_SIGNAL, EINVAL, "bsd_signal.39.01",
            isNotValidSignal(sig, context) ||
            (isCannotCatch(sig) && isUseUserCatcher(handler)) ||
             (isCannotIgnore(sig) && (handler == SUT_SIG_IGN)))


        /*
        * The sigaction() function may fail if:
        *
        * [EINVAL] An attempt was made to set the action to SIG_DFL for a signal that
        * cannot be caught or ignored (or both).
        */
        ERROR_MAY(POSIX_BSD_SIGNAL, EINVAL, "bsd_signal.40.01",
            (handler == SUT_SIG_DFL) &&
            (isCannotCatch(sig) || isCannotIgnore(sig)))

        ERROR_END()

        if (preAct!=NULL && preAct->m_sa_handler!=SUT_SIG_DFL)
        {
            /*
            * Upon successful completion, bsd_signal() shall return the previous action for
            * sig
            */
            REQ("bsd_signal.04", "Old value shall be returned", preAct->m_sa_handler == bsd_signal_spec);
        }


        return true;
    }
}

void bsd_signal_model(CallContext context, Signal* sig, SignalHandler handler)
{
    ProcessState* ps  = getProcessState_CallContext(context);
    SigAction*    act = create_SigAction();

    /*
    * The function call bsd_signal(sig, func) shall be equivalent to the following:
    * void (*bsd_signal(int sig, void (*func)(int)))(int) {
    *        struct sigaction act, oact;
    *
    *        act.sa_handler = func;
    *        act.sa_flags = SA_RESTART;
    *
    *        sigemptyset(&act.sa_mask);
    *        sigaddset(&act.sa_mask, sig);
    *        if (sigaction(sig, &act, &oact) == -1)
    *            return(SIG_ERR);
    *        return(oact.sa_handler);
    *  }
    */
    IMPLEMENT_REQ("bsd_signal.01");

    act->m_sa_handler = handler;
    act->m_sa_flag.SA_RESTART_Flag = true;
    add_Set(act->m_sa_mask, create_SignalObj(*sig));

    put_Map(ps->signal_actions, create_SignalObj(*sig), act);

}

void onBsdSignal( CallContext context, Signal* sig, SignalHandler handler, SignalHandler bsd_signal_spec)
{
    if (bsd_signal_spec!=SUT_SIG_ERR)
    {
        bsd_signal_model(context, sig, handler);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    pause - suspend the thread until a signal is received

SYNOPSIS

    #include <unistd.h>

    int pause(void);


DESCRIPTION

    The pause() function shall suspend the calling thread until delivery of a
    signal whose action is either to execute a signal-catching function or to
    terminate the process.

    If the action is to terminate the process, pause() shall not return.

    If the action is to execute a signal-catching function, pause() shall
    return after the signal-catching function returns.

RETURN VALUE

    Since pause() suspends thread execution indefinitely unless interrupted by
    a signal, there is no successful completion return value. A value of -1
    shall be returned and errno set to indicate the error.

ERRORS

    The pause() function shall fail if:

    [EINTR]
    A signal is caught by the calling process and control is returned from the
    signal-catching function.

*/
specification
void pause_spec( CallContext context)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { SuspendThreadUntilSignalIsReceived, "Suspend the thread until a signal is received" };
    }
    post
    {
        return true;
    }
}

void onPause(CallContext context)
{
    ProcessState* ps =getProcessState_CallContext(context);

    Map* processed = clone(ps->processed_signals);

    startBlockedCall(context, create_PauseCall(context, processed));

}

void onPauseReturn(CallContext context, PauseReturnType* pause_ret_val)
{
    PauseCall* blocked_call=finishBlockedCall(context);

}

reaction PauseReturnType* pause_return(void)
{
    post
    {
        CallContext    context=pause_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        PauseCall*     pCall= findBlockedCall(@getBlockedCalls(), context);

        VERBOSE("Pause reaction start\n");

        /*
        * Since pause() suspends thread execution indefinitely unless interrupted by a
        * signal, there is no successful completion return value
        */
        REQ("pause.04", "Function shall always return -1", pause_return->funcRes == -1);

        /*
        * If the action is to execute a signal-catching function, pause() shall return
        * after the signal-catching function returns
        */
        REQ("pause.03", "Signal shall be processed before return",
            size_Map(ps->processed_signals) > size_Map(pCall->oldProcessedSignals));

        /*
        * A value of -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_PAUSE, "pause.05", pause_return->funcRes == -1, *(pause_return->errno))

        /*
        * The pause() function shall fail if:
        *
        * [EINTR] A signal is caught by the calling process and control is returned from
        * the signal-catching function.
        */
        ERROR_SHALL(POSIX_PAUSE, EINTR, "pause.06.01", true)

        ERROR_END()

      
        return true;
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    pthread_sigmask, sigprocmask - examine and change blocked signals

SYNOPSIS

    #include <signal.h>
    int pthread_sigmask(int how, const sigset_t *restrict set,
                        sigset_t *restrict oset);
    int sigprocmask(int how, const sigset_t *restrict set,
                    sigset_t *restrict oset);


DESCRIPTION

    The pthread_sigmask() function shall examine or change (or both)
    the calling thread's signal mask, regardless of the number of threads in
    the process.The function shall be equivalent to sigprocmask(), without the
    restriction that the call be made in a single-threaded process.

    In a single-threaded process, the sigprocmask() function shall examine or
    change (or both) the signal mask of the calling thread.

    If the argument set is not a null pointer, it points to a set of signals
    to be used to change the currently blocked set.

    The argument how indicates the way in which the set is changed, and the
    application shall ensure it consists of one of the following values:

    SIG_BLOCK

        The resulting set shall be the union of the current set and the signal
        set pointed to by set.

    SIG_SETMASK

        The resulting set shall be the signal set pointed to by set.

    SIG_UNBLOCK
        The resulting set shall be the intersection of the current set and the
        complement of the signal set pointed to by set.

    If the argument oset is not a null pointer, the previous mask shall be
    stored in the location pointed to by oset.If set is a null pointer, the
    value of the argument how is not significant and the thread's signal mask
    shall be unchanged; thus the call can be used to enquire about currently
    blocked signals.

    If there are any pending unblocked signals after the call to sigprocmask
    (), at least one of those signals shall be delivered before the call to
    sigprocmask() returns.

    It is not possible to block those signals which cannot be ignored. This
    shall be enforced by the system without causing an error to be indicated.

    If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated
    while they are blocked, the result is undefined, unless the signal was
    generated by the kill() function, the sigqueue() function, or the raise()
    function.

    If sigprocmask() fails, the thread's signal mask shall not be changed.

    The use of the sigprocmask() function is unspecified in a multi-threaded
    process.

RETURN VALUE

    [THR]  Upon successful completion pthread_sigmask() shall return 0;
    otherwise, it shall return the corresponding error number.

    Upon successful completion, sigprocmask() shall return 0; otherwise, -1
    shall be returned, errno shall be set to indicate the error, and the
    process' signal mask shall be unchanged.

ERRORS

    The pthread_sigmask()  and sigprocmask() functions shall fail if:

    [EINVAL]
    The value of the how argument is not equal to one of the defined values.

    The pthread_sigmask() function shall not return an error code of [EINTR].
*/

//This specification refers to: sigprocmask, pthread_sigmask
specification
void pthread_sigmask_spec( CallContext context, SigMaskAction how, SigSetTPtr set, SigSetTPtr oset, bool singleThreaded)
{
    SigSet* s = getSigSet(set);
    SigSet* os = getSigSet(oset);
    pre
    {
        if (singleThreaded)
        {
            FILTER("sigprocmask");
        }
        else
        {
            FILTER("pthread_sigmask");
        }
        /*
         * If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated while
         * they are blocked, the result is undefined, unless the signal was generated by
         * the kill() function, the sigqueue() function, or the raise() function
         */
        REQ("app.pthread_sigmask.09;app.sigprocmask.09", "", TODO_REQ());

        if (singleThreaded)
        {
            /*
            * The use of the sigprocmask() function is unspecified in a multi-threaded
            * process
            */
            REQ("app.sigprocmask.11", "", TODO_REQ());
        }
        return true;
    }
    post
    {
        /*
         * It is not possible to block those signals which cannot be ignored. This shall
         * be enforced by the system without causing an error to be indicated.
         */
        REQ("pthread_sigmask.08;sigprocmask.02", "", TODO_REQ());

     
        FILTER_CLEAN;
        return true;
    }
}


void pthread_sigmask_model(CallContext context, SigMaskAction how, SigSetTPtr set, SigSetTPtr oset, bool singleThreaded)
{
    Set* temp_mask;
    Set* old_mask;
    SigSet* s = getSigSet(set);
    SigSet* os = getSigSet(oset);
    ThreadState* thSt = getThreadState_CallContext(context);
    CalledFunctionDescription* fdesc;
    Pthread_Sigmask_BlockedCallParams* params;
    bool need_handler;

    temp_mask = get_List(thSt->signal_masks_stack, 0);
    old_mask = clone(temp_mask);

    if ((os != NULL) &&
        (!isNULL_VoidTPtr(os->address)))
    {
        /*
         * If the argument oset is not a null pointer, the previous mask shall be stored
         * in the location pointed to by oset
         */
        IMPLEMENT_REQ("pthread_sigmask.05;sigprocmask.05");

        os->is_init = true;
        copy(temp_mask, os->data);
    }

    need_handler = false;

    if ((s != NULL) &&
        (!isNULL_VoidTPtr(s->address)))
    {
        switch(how){
            case SUT_SIG_BLOCK:
                 /*
                 * The argument how indicates the way in which the set is changed, and the
                 * application shall ensure it consists of one of the following values:
                 *
                 * SIG_BLOCK The resulting set shall be the union of the current set and the
                 * signal set pointed to by set.
                 */
                IMPLEMENT_REQ("pthread_sigmask.04.01;sigprocmask.04.01");

                need_handler = false; //becouse set of blocked signals is union of sets
                addAll_Set(temp_mask, s->data);
                break;
            case SUT_SIG_SETMASK:
                /*
                 * The argument how indicates the way in which the set is changed, and the
                 * application shall ensure it consists of one of the following values:
                 *
                 * SIG_SETMASK The resulting set shall be the signal set pointed to by set.
                 */
                IMPLEMENT_REQ("pthread_sigmask.04.02;sigprocmask.04.02");

                copy(s->data, temp_mask);
                if (size_Set(CanBeDelivered(context, temp_mask)) > 0)
                {
                    need_handler = true;
                }
                break;
            case SUT_SIG_UNBLOCK:
                /*
                 * The argument how indicates the way in which the set is changed, and the
                 * application shall ensure it consists of one of the following values:
                 *
                 * SIG_UNBLOCK The resulting set shall be the intersection of the current set
                 * and the complement of the signal set pointed to by set.
                 */
                IMPLEMENT_REQ("pthread_sigmask.04.03;sigprocmask.04.03");

                retainAll_Set(temp_mask, s->data);
                if (size_Set(CanBeDelivered(context, temp_mask)) > 0)
                {
                    need_handler = true;
                }
                break;
            default:
                break;
        }
    }

    fdesc = create_CalledFunctionDescription(MakeFunctionCallUID(thSt), CALLED_PTHREAD_SIGMASK, CALLED_NONE);
    add_List(thSt->stack_of_calls, 0, clone(fdesc));

    params = create_Pthread_Sigmask_BlockedCallParams(fdesc->uid, how, set, old_mask, need_handler, singleThreaded);
    startBlockedCall(context, params);
}

void onPthread_sigmask(CallContext context, SigMaskAction how, SigSetTPtr set, SigSetTPtr oset, bool singleThreaded)
{
    pthread_sigmask_model(context, how, set,  oset, singleThreaded);
}

reaction
Pthread_SigmaskReactionType* pthread_sigmask_react(void)
{
    pre
    {
        return true;
    }
    post
    {
        CallContext context = pthread_sigmask_react->context;
        SigSet* s = getSigSet(pthread_sigmask_react->params->set);
        ThreadState* thSt = getThreadState_CallContext(context);
        Set*          cur_mask;
        cur_mask = get_List(thSt->signal_masks_stack, 0);

        if (pthread_sigmask_react->params->singleThreaded)
        {
            FILTER("sigprocmask");
        }
        else
        {
            FILTER("pthread_sigmask");
        }

        REQ("", "Serialization false, wrong stack of calls, wrong function name", pthread_sigmask_react->called_func->function_called == CALLED_PTHREAD_SIGMASK);
        REQ("", "Serialization false, wrong stack of calls, wrong function id", pthread_sigmask_react->called_func->uid == pthread_sigmask_react->params->uid);



        if (pthread_sigmask_react->res != 0)
        {
            /*
             * If sigprocmask() fails, the thread's signal mask shall not be changed
             */
            REQ("?pthread_sigmask.10;sigprocmask.10", "The thread's signal mask shall not be changed",
                equals(pthread_sigmask_react->params->old_mask, cur_mask));
        }


        /*
         * otherwise, it shall return the corresponding error number
         */
        /*
        * otherwise, -1 shall be returned, errno shall be set to indicate the error, and
        * the process' signal mask shall be unchanged.
        */
        ERROR_BEGIN(POSIX_PTHREAD_SIGMASK, "pthread_sigmask.12;sigprocmask.13", pthread_sigmask_react->res != 0, pthread_sigmask_react->res)

            /*
             * The pthread_sigmask() function shall not return an error code of [EINTR]
             */
            REQ("pthread_sigmask.14;sigprocmask.14", "Error code should not be EINTR", pthread_sigmask_react->res != SUT_EINTR);

            /*
             * If set is a null pointer, the value of the argument how is not significant and
             * the thread's signal mask shall be unchanged
             */
            /*
             * The pthread_sigmask() and sigprocmask() functions shall fail if:
             *
             * [EINVAL] The value of the how argument is not equal to one of the defined
             * values.
             */
            ERROR_SHALL(POSIX_PTHREAD_SIGMASK, EINVAL, "pthread_sigmask.14.01;pthread_sigmask.06;sigprocmask.14.01;sigprocmask.06",
                        ((s != NULL) && (!isNULL_VoidTPtr(s->address)) &&
                         (pthread_sigmask_react->params->how != SUT_SIG_BLOCK) &&
                         (pthread_sigmask_react->params->how != SUT_SIG_SETMASK) &&
                         (pthread_sigmask_react->params->how != SUT_SIG_UNBLOCK)))
        ERROR_END()

        if (pthread_sigmask_react->params->need_handler)
        {
            /*
             * If there are any pending unblocked signals after the call to sigprocmask(), at
             * least one of those signals shall be delivered before the call to sigprocmask()
             * returns.
             */
            REQ("pthread_sigmask.07;sigprocmask.07", "Catcher wasn't called before pthread_sigmask returns",
                pthread_sigmask_react->called_func->function_nested == CALLED_HANDLER);
        }

        /*
         * Upon successful completion pthread_sigmask() shall return 0
         */
        /*
        * Upon successful completion, sigprocmask() shall return 0
        */
        REQ("pthread_sigmask.11;sigprocmask.12", "Return value should be 0", pthread_sigmask_react->res == 0);

        FILTER_CLEAN;
        return true;
    }
}

void onPthread_sigmask_react(Pthread_SigmaskReactionType* react)
{
    ThreadState* thSt;
    Pthread_Sigmask_BlockedCallParams* params;
    CalledFunctionDescription* func_desc;
    Set* mask;

    thSt = getThreadState_CallContext(react->context);

    react->params = finishBlockedCall(react->context);

    //remove function call from stack
    react->called_func = get_List(thSt->stack_of_calls, 0);
    remove_List(thSt->stack_of_calls, 0);

    if (react->res != 0)
    {
        /*
         * Set previouse mask, becouse it should not been set before and
         * set, that none signal was delivered.
         */
         mask = get_List(thSt->signal_masks_stack, 0);
         copy(react->params->old_mask, mask);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

    refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.
-------------------------------------------------------------------------------

NAME

    sigaction - examine and change a signal action

SYNOPSIS

    #include <signal.h>

    int sigaction(int sig, const struct sigaction *restrict act,
                  struct sigaction *restrict oact);

DESCRIPTION

    The sigaction() function allows the calling process to examine and/or
    specify the action to be associated with a specific signal. The argument
    sig specifies the signal; acceptable values are defined in <signal.h>.

    The structure sigaction, used to describe an action to be taken, is
    defined in the <signal.h> header to include at least the following members:

        void(*) (int) - sa_handler
        Pointer to a signal-catching function or one of
        the macros SIG_IGN or SIG_DFL.

        sigset_t - sa_mask
        Additional set of signals to be blocked during execution
        of signal-catching function.

        int - sa_flags
        Special flags to affect behavior of signal.

        void(*) (int, siginfo_t *, void *) - sa_sigaction
        Pointer to a signal-catching function.


    The storage occupied by sa_handler and sa_sigaction may overlap, and a
    conforming application shall not use both simultaneously.

    If the argument act is not a null pointer, it points to a structure
    specifying the action to be associated with the specified signal.
    If the argument oact is not a null pointer, the action previously
    associated with the signal is stored in the location pointed to by the
    argument oact. If the argument act is a null pointer, signal handling is
    unchanged; thus, the call can be used to enquire about the current
    handling of a given signal. The SIGKILL and SIGSTOP signals shall not be
    added to the signal mask using this mechanism; this restriction shall be
    enforced by the system without causing an error to be indicated.

    If the SA_SIGINFO flag (see below) is cleared in the sa_flags field of the
    sigaction structure, the sa_handler field identifies the action to be
    associated with the specified signal. If the SA_SIGINFO flag
    is set in the sa_flags field, and the implementation supports the
    Realtime Signals Extension option or the XSI Extension option,
    the sa_sigaction field specifies a signal-catching function.

    The sa_flags field can be used to modify the behavior of the
    specified signal.

    The following flags, defined in the <signal.h> header, can be set
    in sa_flags:

    SA_NOCLDSTOP

        Do not generate SIGCHLD when children stop or stopped
        children continue If sig is SIGCHLD and the SA_NOCLDSTOP flag is not
        set in sa_flags, and the implementation supports the SIGCHLD signal,
        then a SIGCHLD signal shall be generated for the calling process
        whenever any of its child processes stop and a SIGCHLD signal may be
        generated for the calling process whenever any of its stopped child
        processes are continued. If sig is SIGCHLD and the SA_NOCLDSTOP flag
        is set in sa_flags, then the implementation shall not generate
        a SIGCHLD signal in this way.

    SA_ONSTACK

        If set and an alternate signal stack has been declared with
        sigaltstack(), the signal shall be delivered to the calling process on
        that stack. Otherwise, the signal shall be delivered on
        the current stack.

    SA_RESETHAND

        If set, the disposition of the signal shall be reset to SIG_DFL and
        the SA_SIGINFO flag shall be cleared on entry to the signal handler.
        Note:
        SIGILL and SIGTRAP cannot be automatically reset when delivered;
        the system silently enforces this restriction.
        Otherwise, the disposition of the signal shall not be modified
        on entry to the signal handler.
        In addition, if this flag is set, sigaction() behaves as if
        the SA_NODEFER flag were also set.

    SA_RESTART

        This flag affects the behavior of interruptible functions; that is,
        those specified to fail with errno set to [EINTR]. If set, and a
        function specified as interruptible is interrupted by this signal,
        the function shall restart and shall not fail with [EINTR] unless
        otherwise specified. If the flag is not set, interruptible functions
        interrupted by this signal shall fail with errno set to [EINTR].

    SA_SIGINFO

        If cleared and the signal is caught, the signal-catching function
        shall be entered as:
            void func(int signo);
        where signo is the only argument to the signal-catching function.
        In this case, the application shall use the sa_handler member to
        describe the signal-catching function and the application shall not
        modify the sa_sigaction member.

        If SA_SIGINFO is set and the signal is caught, the signal-catching
        function shall be entered as:

        void func(int signo, siginfo_t *info, void *context);


        where two additional arguments are passed to the signal-catching
        function. The second argument shall point to an object of type
        siginfo_t explaining the reason why the signal was generated; the
        third argument can be cast to a pointer to an object of type
        ucontext_t to refer to the receivingthread's context that was
        interrupted when the signal was delivered. In this case, the
        application shall use the sa_sigaction member to describe the
        signal-catching function and the application shall not modify
        the sa_handler member.

        The si_signo member contains the system-generated signal number.

        The si_errno member may contain implementation-defined additional error
        information; if non-zero, it contains an error number identifying the
        condition that caused the signal to be generated.

        The si_code member contains a code identifying the cause of the signal.

        If the value of si_code is less than or equal to 0, then the signal
        was generated by a process and si_pid and si_uid, respectively, indicate
        the process ID and the real user ID of the sender.  The <signal.h> header
        description contains information about the signal-specific contents of the
        elements of the siginfo_t type.

    SA_NOCLDWAIT

        If set, and sig equals SIGCHLD, child processes of the calling
        processes shall not be transformed into zombie processes when they
        terminate. If the calling process subsequently waits for its children,
        and the process has no unwaited-for children that were transformed into
        zombie processes, it shall block until all of its children terminate, and
        wait(), waitid(), and waitpid() shall fail and set errno to [ECHILD].
        Otherwise, terminating child processes shall be transformed into zombie
        processes, unless SIGCHLD is set to SIG_IGN.

    SA_NODEFER

        [XSI]  If set and sig is caught, sig shall not be added to the thread's
        signal mask on entry to the signal handler unless it is included in
        sa_mask. Otherwise, sig shall always be added to the thread's signal mask
        on entry to the signal handler.

    When a signal is caught by a signal-catching function installed by
    sigaction(), a new signal mask is calculated and installed for the
    duration of the signal-catching function (or until a call to either
    sigprocmask() or sigsuspend() is made). This mask is formed by taking the
    union of the current signal mask and the value of the sa_mask for the
    signal being delivered [XSI]   unless SA_NODEFER or SA_RESETHAND is set,
    and then including the signal being delivered. If and when the user's
    signal handler returns normally, the original signal mask is restored.

    Once an action is installed for a specific signal, it shall remain
    installed until another action is explicitly requested (by another call
    to sigaction()), [XSI]   until the SA_RESETHAND flag causes resetting of
    the handler,   or until one of the exec functions is called.

    If the previous action for sig had been established by signal(),
    the values of the fields returned in the structure pointed to by oact
    are unspecified, and in particular oact-> sa_handler is not necessarily
    the same value passed to signal(). However, if a pointer to the same
    structure or a copy thereof is passed to a subsequent call to sigaction()
    via the act argument, handling of the signal shall be as if the original
    call to signal() were repeated.

    If sigaction() fails, no new signal handler is installed.

    It is unspecified whether an attempt to set the action for a signal that
    cannot be caught or ignored to SIG_DFL is ignored or causes an error to
    be returned with errno set to [EINVAL].

    If SA_SIGINFO is not set in sa_flags, then the disposition of subsequent
    occurrences of sig when it is already pending is implementation-defined;
    the signal-catching function shall be invoked with a single argument.
    If the implementation supports the Realtime Signals Extension option, and
    if SA_SIGINFO is set in sa_flags, then subsequent occurrences of sig
    generated by sigqueue() or as a result of any signal-generating function
    that supports the specification of an application-defined value (when sig
    is already pending) shall be queued in FIFO order until delivered or
    accepted; the signal-catching function shall be invoked with three
    arguments. The application specified value is passed to the
    signal-catching function as the si_value member of the siginfo_t structure.

    The result of the use of sigaction() and a sigwait() function concurrently
    within a process on the same signal is unspecified.

RETURN VALUE

    Upon successful completion, sigaction() shall return 0; otherwise, -1
    shall be returned, errno shall be set to indicate the error, and no new
    signal-catching function shall be installed.

ERRORS

    The sigaction() function shall fail if:

        [EINVAL] The sig argument is not a valid signal number or an attempt
        is made to catch a signal that cannot be caught or ignore a signal
        that cannot be ignored.

        [ENOTSUP] The SA_SIGINFO bit flag is set in the sa_flags field of the
        sigaction structure, and the implementation does not support either
        the Realtime Signals Extension option, or the XSI Extension option.

    The sigaction() function may fail if:

        [EINVAL]
        An attempt was made to set the action to SIG_DFL for a signal that
        cannot be caught or ignored (or both).

*/

specification
IntT sigaction_spec(CallContext context, Signal* sig, SigAction* s_act,
                    SigAction* s_oact, ErrorCode* errno)
{
    /*
     * Value from process_state->signal_actions with key sig.
     * Signal action for signal with number sig
     */
    SigAction* process_s_act_post; // after function call
    SigAction* process_s_act_pre;  // before function call
    Map* sig_actions;

    ThreadState* thr_st;
    ProcessState* process_state_pre;
    ProcessState* process_state_post;

    pre
    {
        thr_st = getThreadState_CallContext(context);
        process_state_pre = clone(getProcessState_CallContext(context));
        process_s_act_pre = get_Map(process_state_pre->signal_actions, create_SignalObj(*sig));

        if (process_s_act_pre!=NULL)
        {
            process_s_act_pre = clone(process_s_act_pre);
        }

        /*
         * The storage occupied by sa_handler and sa_sigaction may overlap,
         * and a conforming application shall not use both simultaneously.
         */
        REQ("app.sigaction.02", "", TODO_REQ());

        /*
         * If SA_SIGINFO is not set in sa_flags, then the disposition of
         * subsequent occurrences of sig when it is already pending is
         * implementation-defined
         */
        REQ("app.sigaction.33", "", TODO_REQ());

        /*
         * The result of the use of sigaction() and a sigwait() function
         * concurrently within a process on the same signal is unspecified.
         */
        REQ("app.sigaction.36",
            "Behaviour of this function is implementation defined, when sigwait() is called in the process",
            !isWaitingForSignal(sig, context));


        traceFormattedUserInfo("Sigaction called for process $(obj) and signal $(obj)", create_IntTObj(context.process), create_IntTObj(*sig));


        return true;
    }
    coverage C
    {
        if (s_act == NULL)
        {
            if (s_oact == NULL)
            {
                return { NothingToDo,
                         "No actions are happened"};
            }
            else
            {
                return { OnlyView,
                         "No changes are happened, only view current value"};
            }
        }
        else if (s_oact == NULL)
        {
            return { OnlySet, "Set new handler, but don't get old "};
        }
        else
        {
            if (( !isValidNotReaitimeSignal(sig) &&
                  !isRealtimeSignal(sig, context))    ||
                isCannotCatch(sig)                    ||
                isCannotIgnore(sig))
            {
                /*
                 * The sig argument is not a valid signal number or an
                 * attempt is made to catch a signal that cannot be caught or
                 * ignore a signal that cannot be ignored.
                 * [Function shall set errno to EINVAL and return -1]
                 */
                return {WrongSigForThisCatcher,
                    "Sig is not a valid signal number or catcher for this function is unsuitable"};
            }
            else if((s_act->m_sa_flag.SA_SIGINFO_Flag == true) && (REALTIME_OPTION == 0))
            {
                /*
                 * The SA_SIGINFO bit flag is set in the sa_flags field of
                 * the sigaction structure, and the implementation does not
                 * support either the Realtime Signals Extension option, or the
                 * XSI Extension option.
                 * [Function shall set errno to ENOTSUP and return -1]
                 */
                return {SAFlagAndSystemConfigurationMismatch,
                    "SA_SIGINFO is set, but implementation doesn't support a work in this case"};
            }
            else if(isCannotCatch(sig) ||
                isCannotIgnore(sig))
            {
                /*
                 * An attempt was made to set the action to SIG_DFL for
                 * a signal that cannot be caught or ignored.
                 * [Function may set errno to EINVAL]
                 */
                return {WrongSigForSIG_DEFCatcher,
                    "Sig is not a valid signal number or catcher for this function is unsuitable"};
            }
            else
            {
                /*
                 * [Usual work with, when no errors are expected.
                 *  Function shall change catcher and return 0]
                 */
                return { ChangeBranch,
                     "Function changes signal processing function"};
            }
        }

    }
    post
    {
        /*
         * otherwise, -1 shall be returned, errno shall be set to
         * indicate the error, and no new signal-catching function shall be
         * installed
         * [sigaction.38 requirement if function fails]
         */
        /*
         * If sigaction() fails, no new signal handler is installed.
         * [sigaction.31 requirement in this case only model state was checked]
         */

        ERROR_BEGIN(POSIX_SIGACTION, "sigaction.38;sigaction.31",
                    (sigaction_spec == -1) &&
                    equals(process_state_pre->signal_actions,
                           process_state_post->signal_actions),
                    *errno)


            /*
             * The sigaction() function may fail if:
             *
             * [EINVAL]
             * An attempt was made to set the action to SIG_DFL for a signal that
             * cannot be caught or ignored (or both).
             */
            /*
             * It is unspecified whether an attempt to set the action for a
             * signal that cannot be caught or ignored to SIG_DFL is ignored
             * or causes an error to be returned with errno set to [EINVAL].
             */
            ERROR_MAY(POSIX_SIGACTION, EINVAL,"sigaction.40.01;sigaction.32",
                (s_act != NULL) && (s_act->m_sa_handler == SUT_SIG_DFL) &&
                (isCannotCatch(sig) || isCannotIgnore(sig)))

            /*
             * The sigaction() function shall fail if:
             *
             * [EINVAL]
             * The sig argument is not a valid signal number or an attempt is made
             * to catch a signal that cannot be caught or ignore a signal that
             * cannot be ignored.
             */
            ERROR_SHALL(POSIX_SIGACTION, EINVAL, "sigaction.39.01",
                (isNotValidSignal(sig, context)) ||
                ((s_act != NULL) &&
                 ((isCannotCatch(sig) && isUseUserCatcher(s_act->m_sa_handler)) ||
                  (isCannotIgnore(sig) && (s_act->m_sa_handler == SUT_SIG_IGN)))))

            /*
             * The sigaction() function shall fail if:
             *
             * [ENOTSUP]
             * The SA_SIGINFO bit flag is set in the sa_flags field of the
             * sigaction structure, and the implementation does not support either
             * the Realtime Signals Extension option, or the XSI Extension option.
             */
            ERROR_SHALL(POSIX_SIGACTION, ENOTSUP,"sigaction.39.02", TODO_ERR(ENOTSUP))
        ERROR_END()

        process_state_post = getProcessState_CallContext(context);
        process_s_act_post = get_Map(process_state_post->signal_actions, create_SignalObj(*sig));

        if (s_oact != NULL)
        {

            /*
             * If the argument oact is not a null pointer, the action
             * previously associated with the signal is stored in the location
             * pointed to by the argument oact
             */
            if (process_s_act_pre != NULL)
            {
                /*
                 * Handler was define for this signal in the model
                 */
                REQ("sigaction.04",
                    "Function shall set previously associated catcher to oact argument",
                    equals(s_oact, process_s_act_pre));
            }

        }

        if (s_act != NULL)
        {
            /*
             * If the argument act is not a null pointer, it points to a
             * structure specifying the action to be associated with the
             * specified signal
             */
            REQ("sigaction.03", "New signal handler should be set",
                equals(s_act, process_s_act_post));

            /*
             * The SIGKILL and SIGSTOP
             *
             * signals shall not be added to the signal mask using this mechanism
             * [it means that SIGKILL and SIGSTOP cant'n be blocked during
             * this signal handling]
             */
            REQ("sigaction.06.01",
                "The SIGKILL and SIGSTOP signals shall not be added to the signal mask",
                (!contains_Set(process_s_act_post->m_sa_mask, create_IntTObj(SUT_SIGKILL))) &&
                (!contains_Set(process_s_act_post->m_sa_mask, create_IntTObj(SUT_SIGSTOP))));

            if ((SUT_SIGCHLD == *sig) &&
                (!process_s_act_post->m_sa_flag.SA_NOCLDSTOP_Flag))
            {
                /*
                 * SA_NOCLDSTOP
                 *
                 * If sig is SIGCHLD and the SA_NOCLDSTOP flag is not set in
                 * sa_flags, and the implementation supports the SIGCHLD
                 * signal, then a SIGCHLD signal shall be generated for the
                 * calling process whenever any of its child processes stop
                 */

                REQ("sigaction.10.01",
                    "",
                    TODO_REQ());

                /*
                 * SA_NOCLDSTOP
                 *
                 * and a SIGCHLD signal may be generated for the calling
                 * process whenever any of its stopped child processes are
                 * continued.
                 */

                 REQ("sigaction.10.02",
                    "",
                    TODO_REQ());
            }

            if ((SUT_SIGCHLD == *sig) &&
                (process_s_act_post->m_sa_flag.SA_NOCLDSTOP_Flag))
            {
                /*
                 * If sig is SIGCHLD and the SA_NOCLDSTOP flag is set in
                 * sa_flags, then the implementation shall not generate a
                 * SIGCHLD signal in this way
                 */
                REQ("sigaction.11",
                    "",
                    TODO_REQ());
            }

            if(process_s_act_post->m_sa_flag.SA_ONSTACK_Flag)
            {
                /*
                 * SA_ONSTACK
                 *
                 * If set and an alternate signal stack has been declared with
                 * sigaltstack(), the signal shall be delivered to the calling
                 * process on that stack
                 */
                REQ("sigaction.12.01",
                    "",
                    TODO_REQ());
            }
            else
            {
                /*
                 * SA_ONSTACK
                 *
                 * Otherwise, the signal shall be delivered on the current stack
                 */
                REQ("sigaction.12.02",
                    "",
                    TODO_REQ());
            }

            /*
             * The si_signo member contains the system-generated signal number.
             *
             * The si_errno member may contain implementation-defined
             * additional error information; if non-zero, it contains an error
             * number identifying the condition that caused the signal to be
             * generated.
             *
             * The si_code member contains a code identifying the cause of
             * the signal.
             *
             * If the value of si_code is less than or equal to 0, then the
             * signal was generated by a process and si_pid and si_uid,
             * respectively, indicate the process ID and the real user
             * ID of the sender. The <signal.h> header description contains
             * information about the signal-specific contents of the elements
             * of the siginfo_t type.
             */
            REQ("sigaction.22", "", TODO_REQ());

            /*
             * SA_NOCLDWAIT
             *
             * If set, and sig equals SIGCHLD, child processes of the calling
             * processes shall not be transformed into zombie processes when
             * they terminate. If the calling process subsequently waits for
             * its children, and the process has no unwaited-for children that
             * were transformed into zombie processes, it shall block until
             * all of its children terminate, and wait(), waitid(), and
             * waitpid() shall fail and set errno to [ECHILD]
             */
            REQ("sigaction.23.01", "", TODO_REQ());

            /*
             * SA_NOCLDWAIT
             *
             * Otherwise, terminating child processes shall be transformed
             * into zombie processes, unless SIGCHLD is set to SIG_IGN.
             */
            REQ("sigaction.23.02",
                "This requirement should be checked in other place",
                TODO_REQ());

        }
        else
        {
            /*
             * If the argument act is a null pointer, signal handling is
             * unchanged
             */
            REQ("sigaction.05", "Signal handling should not change",
                equals(get_Map(process_state_pre->signal_actions, create_SignalObj(*sig)),
                       get_Map(process_state_post->signal_actions, create_SignalObj(*sig))));
        }

        /*
         * Upon successful completion, sigaction() shall return 0
         */
        REQ("sigaction.37", "Function shall return 0 in this case",
            sigaction_spec == 0);

       

        traceFormattedUserInfo("Sigaction sucessful for process $(obj) and signal $(obj)", create_IntTObj(context.process), create_IntTObj(*sig));


        return true;
    }
}

void onSigaction(CallContext context, Signal* sig, SigAction* s_oact, SigAction* s_act,
                 IntT sigaction_res)
{
    ProcessState* pr_state = getProcessState_CallContext(context);

    if (sigaction_res == 0)
    {
        if (s_act != NULL)
        {
            if (s_act->m_sa_flag.SA_SIGINFO_Flag)
            {
                s_act->m_sa_handler=SIG_UNDEFINED;
            }
            else
            {
                s_act->m_sa_sigaction=SIGACT_UNDEFINED;
            }

            put_Map(pr_state->signal_actions, create_SignalObj(*sig), clone(s_act)); //sigaction.29
        }
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

  refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    sigaltstack - set and get signal alternate stack context

SYNOPSIS

    [XSI]  #include <signal.h>

    int sigaltstack(const stack_t *restrict ss, stack_t *restrict oss);

DESCRIPTION

    The sigaltstack() function allows a process to define and examine the
    state of an alternate stack for signal handlers for the current thread.
    Signals that have been explicitly declared to execute on the alternate
    stack shall be delivered on the alternate stack.

    If ss is not a null pointer, it points to a stack_t structure that
    specifies the alternate signal stack that shall take effect upon return
    from sigaltstack(). The ss_flags member specifies the new stack state. If
    it is set to SS_DISABLE, the stack is disabled and ss_sp and ss_size are
    ignored. Otherwise, the stack shall be enabled, and the ss_sp and ss_size
    members specify the new address and size of the stack.

    The range of addresses starting at ss_sp up to but not including ss_sp+
    ss_size is available to the implementation for use as the stack. This
    function makes no assumptions regarding which end is the stack base and in
    which direction the stack grows as items are pushed.

    If oss is not a null pointer, on successful completion it shall point to a
    stack_t structure that specifies the alternate signal stack that was in
    effect prior to the call to sigaltstack(). The ss_sp and ss_size members
    specify the address and size of that stack. The ss_flags member specifies
    the stack's state, and may contain one of the following values:

    SS_ONSTACK
    The process is currently executing on the alternate signal stack. Attempts
    to modify the alternate signal stack while the process is executing on it
    fail. This flag shall not be modified by processes.
    SS_DISABLE
    The alternate signal stack is currently disabled.
    The value SIGSTKSZ is a system default specifying the number of bytes that
    would be used to cover the usual case when manually allocating an
    alternate stack area. The value MINSIGSTKSZ is defined to be the minimum
    stack size for a signal handler. In computing an alternate stack size, a
    program should add that amount to its stack requirements to allow for the
    system implementation overhead. The constants SS_ONSTACK, SS_DISABLE,
    SIGSTKSZ, and MINSIGSTKSZ are defined in <signal.h>.

    After a successful call to one of the exec functions, there are no
    alternate signal stacks in the new process image.

    In some implementations, a signal (whether or not indicated to execute on
    the alternate stack) shall always execute on the alternate stack if it is
    delivered while another signal is being caught using the alternate stack.

    Use of this function by library threads that are not bound to kernel-
    scheduled entities results in undefined behavior.

RETURN VALUE

    Upon successful completion, sigaltstack() shall return 0; otherwise, it
    shall return -1 and set errno to indicate the error.

ERRORS

    The sigaltstack() function shall fail if:

    [EINVAL]
    The ss argument is not a null pointer, and the ss_flags member pointed to
    by ss contains flags other than SS_DISABLE.
    [ENOMEM]
    The size of the alternate stack area is less than MINSIGSTKSZ.
    [EPERM]
    An attempt was made to modify an active stack.

*/

specification
SigaltstackReturnType* sigaltstack_spec( CallContext context, StackT* ss, ErrorCode* errno)
{
    pre
    {
        /*
        * Use of this function by library threads that are not bound to kernel-scheduled
        * entities results in undefined behavior.
        */
        REQ("app.sigaltstack.16", "", TODO_REQ());

        return true;
    }
    post
    {

        /*
         * otherwise, it shall return -1 and set errno to indicate the error
         */
        ERROR_BEGIN(POSIX_SIGALTSTACK, "sigaltstack.18", sigaltstack_spec->funcRes, *errno)

        /*
        * The sigaltstack() function shall fail if
        *
        * [EINVAL] The ss argument is not a null pointer, and the ss_flags member pointed
        * to by ss contains flags other than SS_DISABLE.
        */
        ERROR_SHALL(POSIX_SIGALTSTACK, EINVAL, "sigaltstack.19.01", ss!=NULL && ss->ss_flags!=0 && ss->ss_flags!=SUT_SS_DISABLE)

        /*
        * The sigaltstack() function shall fail if
        *
        * [ENOMEM] The size of the alternate stack area is less than MINSIGSTKSZ.
        */
        /*
         * The value MINSIGSTKSZ is defined to be the minimum stack size for a signal
         * handler
         */
        /*
         * In computing an alternate stack size, a program should add that amount to its
         * stack requirements to allow for the system implementation overhead
         */
        ERROR_SHALL(POSIX_SIGALTSTACK, ENOMEM, "sigaltstack.19.02;sigaltstack.11;sigaltstack.12", ss!=NULL && ss->ss_size < sigaltstack_spec->minsigstcksz)

        /*
        * The sigaltstack() function shall fail if
        *
        * [EPERM] An attempt was made to modify an active stack.
        */
        ERROR_SHALL(POSIX_SIGALTSTACK, EPERM, "sigaltstack.19.03", TODO_ERR(EPERM) )

        ERROR_END()

        /*
         * Upon successful completion, sigaltstack() shall return 0
         */
        REQ("sigaltstack.17", "Upon successful completion, sigaltstack() shall return 0", sigaltstack_spec->funcRes==0);


        /*
         * Signals that have been explicitly declared to execute on the alternate stack
         * shall be delivered on the alternate stack
         */
        REQ("sigaltstack.02", "", TODO_REQ());
        /*
         * The ss_flags member specifies the stack's state, and may contain one of the
         * following values
         *
         * SS_ONSTACK The process is currently executing on the alternate signal stack.
         * Attempts to modify the alternate signal stack while the process is executing on
         * it fail. This flag shall not be modified by processes.
         */
        REQ("sigaltstack.09.01", "", TODO_REQ());

        /*
         * The value SIGSTKSZ is a system default specifying the number of bytes that
         * would be used to cover the usual case when manually allocating an alternate
         * stack area
         */
        REQ("sigaltstack.10", "", TODO_REQ());

        /*
         * After a successful call to one of the exec functions, there are no alternate
         * signal stacks in the new process image
         */
        REQ("sigaltstack.14", "", TODO_REQ());

        /*
         * In some implementations, a signal (whether or not indicated to execute on the
         * alternate stack) shall always execute on the alternate stack if it is delivered
         * while another signal is being caught using the alternate stack.
         */
        REQ("sigaltstack.15", "", TODO_REQ());


       
        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    siginterrupt - allow signals to interrupt functions

SYNOPSIS

    [XSI]  #include <signal.h>

    int siginterrupt(int sig, int flag);

DESCRIPTION

    The siginterrupt() function shall change the restart behavior when a
    function is interrupted by the specified signal. The function siginterrupt(
    sig, flag) has an effect as if implemented as:

    int siginterrupt(int sig, int flag) {
        int ret;
        struct sigaction act;

        (void) sigaction(sig, NULL, &act);
        if (flag)
            act.sa_flags &= ~SA_RESTART;
        else
            act.sa_flags |= SA_RESTART;
        ret = sigaction(sig, &act, NULL);
        return ret;
    }


RETURN VALUE

    Upon successful completion, siginterrupt() shall return 0; otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS

    The siginterrupt() function shall fail if:

    [EINVAL]
    The sig argument is not a valid signal number.
*/
specification
IntT siginterrupt_spec( CallContext context, Signal* sig, IntT flag, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    post
    {
        /*
        * otherwise, -1 shall be returned and errno set to indicate the error
        */
        ERROR_BEGIN(POSIX_SIGINTERRUPT, "siginterrupt.03", siginterrupt_spec==-1, *errno)

        /*
        * The siginterrupt() function shall fail if
        *
        * [EINVAL] The sig argument is not a valid signal number.
        */
        ERROR_SHALL(POSIX_SIGINTERRUPT, EINVAL, "siginterrupt.04.01", isNotValidSignal(sig, context))

        ERROR_END()

        /*
        * Upon successful completion, siginterrupt() shall return 0
        */
        REQ("siginterrupt.02", "Function shall return zero", siginterrupt_spec==0);


        return true;
    }
}

void siginterrupt_model(CallContext context, Signal* sig, IntT flag)
{
    ProcessState* pr_state = getProcessState_CallContext(context);
    SigAction* s_act;

    /*
    * The siginterrupt() function shall change the restart behavior when a function
    * is interrupted by the specified signal. The function siginterrupt(sig, flag)
    * has an effect as if implemented as:
    * int siginterrupt(int sig, int flag) {
    *      int ret; struct sigaction act;
    *      (void) sigaction(sig, NULL, &act);
    *      if (flag)
    *           act.sa_flags &= ~ SA_RESTART;
    *      else
    *           act.sa_flags |= SA_RESTART;
    *       ret = sigaction(sig, &act, NULL);
    *       return ret;
    * }
    */
    IMPLEMENT_REQ("siginterrupt.01");

    s_act = (SigAction*)get_Map(pr_state->signal_actions, create_SignalObj(*sig));
    if (s_act!=NULL)
    {
        if (flag)
        {
            s_act->m_sa_flag.SA_RESTART_Flag = false;
        }
        else
        {
            s_act->m_sa_flag.SA_RESTART_Flag = true;
        }
        put_Map(pr_state->signal_actions, create_SignalObj(*sig), s_act);
    }
    else
    {
        setBadVerdict("Action shall be set up for signal. Call sigaction() first");
    }
}


void onSiginterrupt(CallContext context, Signal* sig, IntT flag, IntT siginterrupt_spec)
{
    if (siginterrupt_spec!=-1)
    {
        siginterrupt_model(context, sig, flag);
    }
}

/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    signal - signal management

SYNOPSIS

    #include <signal.h>

    void (*signal(int sig, void (*func)(int)))(int);

DESCRIPTION

    The functionality described on this reference page is aligned with the
    ISO C standard. Any conflict between the requirements described here
    and the ISO C standard is unintentional. This volume of IEEE Std
    1003.1-2001 defers to the ISO C standard.

    Use of this function is unspecified in a multi-threaded process.

    The signal() function chooses one of three ways in which receipt of
    the signal number sig is to be subsequently handled. If the value of
    func is SIG_DFL, default handling for that signal shall occur.
    If the value of func is SIG_IGN, the signal shall be ignored.
    Otherwise, the application shall ensure that func points to a function
    to be called when that signal occurs. An invocation of such a function
    because of a signal, or (recursively) of any further functions called
    by that invocation (other than functions in the standard library),
    is called a "signal handler".

    When a signal occurs, and func points to a function, it is
    implementation-defined whether the equivalent of a:

    signal(sig, SIG_DFL);

    is executed or the implementation prevents some implementation-defined
    set of signals (at least including sig) from occurring until the current
    signal handling has completed. (If the value of sig is SIGILL,
    the implementation may alternatively define that no action is taken.)
    Next the equivalent of:

    (*func)(sig);

    is executed. If and when the function returns, if the value of sig was
    SIGFPE, SIGILL, or SIGSEGV or any other implementation-defined value
    corresponding to a computational exception, the behavior is undefined.
    Otherwise, the program shall resume execution at the point it was
    interrupted. If the signal occurs as the result of calling the abort(),
    raise(), [CX]  kill(), pthread_kill(), or sigqueue()  function, the signal
    handler shall not call the raise() function.

    If the signal occurs other than as the result of calling abort(),
    raise(), kill(), pthread_kill(), or sigqueue(), the behavior is
    undefined if the signal handler refers to any object with static
    storage duration other than by assigning a value to an object declared
    as volatile sig_atomic_t, or if the signal handler calls any function in
    the standard library other than one of the functions listed in Signal
    Concepts. Furthermore, if such a call fails, the value of errno is
    unspecified.

    At program start-up, the equivalent of:

    signal(sig, SIG_IGN);

    is executed for some signals, and the equivalent of:

    signal(sig, SIG_DFL);

    is executed for all other signals (see exec).

RETURN VALUE

    If the request can be honored, signal() shall return the value of func
    for the most recent call to signal() for the specified signal sig.
    Otherwise, SIG_ERR shall be returned and a positive value shall be
    stored in errno.

ERRORS

    The signal() function shall fail if:

    [EINVAL]
        The sig argument is not a valid signal number or an attempt is made to
        catch a signal that cannot be caught or ignore a signal that
        cannot be ignored. The signal() function may fail if:

    [EINVAL]
        An attempt was made to set the action to SIG_DFL for a signal that
        cannot be caught or ignored (or both).
*/
/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    __sysv_signal -- signal handling

SYNOPSIS

    __sighandler_t __sysv_signal(int sig, __sighandler_t handler);

DESCRIPTION

    __sysv_signal() has the same behavior as signal() as specified by ISO
    POSIX (2003).
    __sysv_signal() is not in the source standard; it is only in the binary
    standard.
*/

//This specification refers to: __sysv_signal, signal
specification
SignalHandler signal_spec(CallContext context, Signal* sig, SignalHandler handler,
                     ErrorCode* errno, bool lsbFunc)
{
    ProcessState* ps = getProcessState_CallContext(context);
    SigAction* preAct = get_Map(ps->signal_actions, create_SignalObj(*sig));

    pre
    {
        if (lsbFunc)
        {
            FILTER("__sysv_signal");
        }
        else
        {
            FILTER("signal");
        }

        /*
        * Use of this function is unspecified in a multi-threaded process
        */
        REQ("app.signal.01;app.__sysv_signal.01", "", TODO_REQ());

        if (preAct!=NULL)
        {
            preAct = clone(preAct);
        }

        return true;
    }
    post
    {
        /*
         * Otherwise, SIG_ERR shall be returned and a positive value shall be stored in
         * errno
         */
        ERROR_BEGIN(POSIX_SIGNAL, "signal.08;__sysv_signal.08", signal_spec==SUT_SIG_ERR && *errno > 0, *errno)

        /*
        * The signal() function shall fail if
        *
        * [EINVAL] [CX] The sig argument is not a valid signal number or an attempt is
        * made to catch a signal that cannot be caught or ignore a signal that cannot be
        * ignored.
        */
        ERROR_SHALL(POSIX_SIGNAL, EINVAL, "signal.09.01;__sysv_signal.09.01",
            isNotValidSignal(sig, context) ||
            (isCannotCatch(sig) && isUseUserCatcher(handler)) ||
             (isCannotIgnore(sig) && (handler == SUT_SIG_IGN)))

        /*
        * The signal() function may fail if
        *
        * [EINVAL] [CX] An attempt was made to set the action to SIG_DFL for a signal
        * that cannot be caught or ignored (or both).
        */
        ERROR_MAY(POSIX_SIGNAL, EINVAL, "signal.10.01;__sysv_signal.10.01",
            (handler == SUT_SIG_DFL) &&
            (isCannotCatch(sig) || isCannotIgnore(sig)))

        ERROR_END()

        /*
         * When a signal occurs, and func points to a function
         *
         * it is implementation-defined whether the equivalent of a:
         * signal(sig, SIG_DFL);
         * is executed or the implementation prevents some implementation-defined set of
         * signals (at least including sig) from occurring until the current signal
         * handling has completed.
         */
        REQ_UNCHECKABLE("signal.03.01;__sysv_signal.03.01", "Can not check this implementation defined statement");

        /*
         * When a signal occurs, and func points to a function
         *
         * (If the value of sig is SIGILL, the implementation may alternatively define
         * that no action is taken.)
         */
        REQ("signal.03.02;__sysv_signal.03.02", "", TODO_REQ());

        /*
         * If and when the function returns
         *
         * if the value of sig was SIGFPE, SIGILL, or SIGSEGV or any other implementation-
         * defined value corresponding to a computational exception, the behavior is
         * undefined
         */
        REQ_UNCHECKABLE("signal.04.01;__sysv_signal.04.01", "Can not check implementation defined information");

        /*
         * If and when the function returns
         *
         * Otherwise, the program shall resume execution at the point it was interrupted.
         */
        REQ("signal.04.02;__sysv_signal.04.02", "", TODO_REQ());

        /*
         * If the signal occurs as the result of calling the abort(), raise(), [CX]
         * kill(), pthread_kill(), or sigqueue() function, the signal handler shall not
         * call the raise() function
         */
        REQ("signal.05;__sysv_signal.05", "", TODO_REQ());

        /*
         * If the signal occurs other than as the result of calling abort(), raise(), [CX]
         * kill(), pthread_kill(), or sigqueue(),
         *
         * the behavior is undefined if the signal handler refers to any object with
         * static storage duration other than by assigning a value to an object declared
         * as volatile sig_atomic_t, or if the signal handler calls any function in the
         * standard library other than one of the functions listed in Signal Concepts
         */
        REQ("signal.06.01;__sysv_signal.06.01", "", TODO_REQ());

        /*
         * If the signal occurs other than as the result of calling abort(), raise(), [CX]
         * kill(), pthread_kill(), or sigqueue(),
         *
         * Furthermore, if such a call fails, the value of errno is unspecified
         */
        REQ("signal.06.02;__sysv_signal.06.02", "", TODO_REQ());

        if (preAct!=NULL && preAct->m_sa_handler!=SUT_SIG_DFL)
        {
            /*
             * If the request can be honored, signal() shall return the value of func for the
             * most recent call to signal() for the specified signal sig
             */
            REQ("signal.07;__sysv_signal.07", "Old value shall be returned", preAct->m_sa_handler == signal_spec);
        }

       

        FILTER_CLEAN;
        return true;
    }
}


void onSignal(CallContext context, Signal* sig, SignalHandler handler, SignalHandler ret_val)
{
    if (ret_val!=SUT_SIG_ERR)
    {
        ProcessState* ps  = getProcessState_CallContext(context);
        SigAction*    act = create_SigAction();

        act->m_sa_handler = handler;

        put_Map(ps->signal_actions, create_SignalObj(*sig), act);
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

refers

The Open Group Base Specifications Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright (c) 2001-2004 The IEEE and The Open Group, All Rights reserved.

NAME

    sigpending - examine pending signals

SYNOPSIS

    #include <signal.h>

    int sigpending(sigset_t *set);

DESCRIPTION

    The sigpending() function shall store, in the location referenced by the
    set argument, the set of signals that are blocked from delivery to the
    calling thread and that are pending on the process or the calling thread.

RETURN VALUE

    Upon successful completion, sigpending() shall return 0; otherwise, -1
    shall be returned and errno set to indicate the error.

ERRORS

    No errors are defined.
*/
specification
IntT sigpending_spec(CallContext context, SigSetTPtr set, ErrorCode* errno)
{
    pre
    {
        return true;
    }
    coverage C
    {
        return { ExaminePendingSignals, "Examine pending signals" };
    }
    post
    {
        /*
         * Upon successful completion, sigpending() shall return 0
         */
        /*
         * otherwise, -1 shall be returned and errno set to indicate the error
         */
        REQ("sigpending.02;sigpending.03", "Return value should be 0",
            sigpending_spec == 0 ||
            (sigpending_spec == -1 && errno!=0));

        return true;
    }
}

void onSigpending(CallContext context, SigSetTPtr set, IntT res)
{
    int size, counter;
    ThreadState* thSt = getThreadState_CallContext(context);
    ProcessState* prSt = getProcessState_CallContext(context);
    SigSet* s = getSigSet(set);
    Set* mask = get_List(thSt->signal_masks_stack, 0);
    Signal* temp_sig;
    List* temp_list;

    if (res == 0)
    {
        size = size_Set(mask);
        s->data = create_Set(&type_SignalObj);
        for (counter = 0; counter < size; counter++)
        {
            temp_sig = get_Set(mask, counter);

            temp_list = get_Map(prSt->signal_queue, create_SignalObj(*temp_sig));
            if(temp_list != NULL) //checking process signal queue
            {
                if (size_List(temp_list) > 0)
                {
                    add_Set(s->data, create_SignalObj(*temp_sig));
                }
            }

            temp_list = get_Map(thSt->signal_queue, create_SignalObj(*temp_sig));
            if(temp_list != NULL) //checking thread signal queue
            {
                if (size_List(temp_list) > 0)
                {
                    add_Set(s->data, create_SignalObj(*temp_sig));
                }
            }
        }
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    sigreturn -- return from signal handler and cleanup stack frame

SYNOPSIS

    int sigreturn(struct sigcontext * scp);

DESCRIPTION

    The sigreturn() function is used by the system to cleanup after a signal
    handler has returned. This function is not in the source standard; it is
    only in the binary standard.

RETURN VALUE

    sigreturn() never returns.


*/
specification
IntT sigreturn_spec(CallContext context)
{
    pre
    {
        /*[This function shall never be called directly]*/
        REQ("", "This function is called from kernel only and NEVER shall be called directly", false);

        return true;
    }
    coverage C
    {
        return { ReturnFromSignalHandlerAndCleanupStackFrame, "Return from signal handler and cleanup stack frame" };
    }
    post
    {
        /*
        * The sigreturn() function is used by the system to cleanup after a signal
        * handler has returned.
        */
        REQ("sigreturn.01", "", TODO_REQ());

        /*
        * This function is not in the source standard; it is only in the binary standard.
        */
        REQ("sigreturn.02", "", TODO_REQ());

        return true;
    }
}


/*
Linux Standard Base Core Specification 3.1
Copyright (c) 2004, 2005 Free Standards Group

NAME

    sigsuspend - wait for a signal

SYNOPSIS

    #include <signal.h>
    int sigsuspend(const sigset_t *sigmask);

DESCRIPTION

    The sigsuspend() function shall replace the current signal mask of the
    calling thread with the set of signals pointed to by sigmask and then
    suspend the thread until delivery of a signal whose action is either to
    execute a signal-catching function or to terminate the process. This shall
    not cause any other signals that may have been pending on the process to
    become pending on the thread.
    If the action is to terminate the process then sigsuspend() shall never
    return. If the action is to execute a signal-catching function, then
    sigsuspend() shall return after the signal-catching function returns, with
    the signal mask restored to the set that existed prior to the sigsuspend()
    call.
    It is not possible to block signals that cannot be ignored. This is
    enforced by the system without causing an error to be indicated.

RETURN VALUE

    Since sigsuspend() suspends thread execution indefinitely, there is no
    successful completion return value. If a return occurs, -1 shall be
    returned and errno set to indicate the error.

ERRORS

    The sigsuspend() function shall fail if:

    [EINTR]
        A signal is caught by the calling process and control is returned from the
        signal-catching function.
*/
specification
void sigsuspend_spec( CallContext context, SigSetTPtr sigmask)
{
    pre
    {
        return true;
    }
    post
    {
        return true;
    }
}


void onSigsuspend(CallContext context, SigSetTPtr sigmask)
{
    ProcessState* ps =getProcessState_CallContext(context);
    Set*          temp_mask, *old_mask;
    ThreadState*  thSt = getThreadState_CallContext(context);
    SigSet*       st = getSigSet(sigmask);

    temp_mask = get_List(thSt->signal_masks_stack, 0);

    if (temp_mask!=NULL)
    {
        old_mask = clone(temp_mask);
        copy(temp_mask, st->data);
    }
    else
    {
        append_List(thSt->signal_masks_stack, st->data);
    }

    startBlockedCall(context, create_SigsuspendCall(context, st, clone(ps->processed_signals), old_mask));
}


void onSigsuspendReturn(CallContext context, SigsuspendReturnType* sigsuspend_ret_val)
{
    SigsuspendCall* blocked_call=finishBlockedCall(context);
    ThreadState*  thSt = getThreadState_CallContext(context);
    Set*          temp_mask;
    temp_mask = get_List(thSt->signal_masks_stack, 0);

    if (blocked_call->oldMask!=NULL && temp_mask!=NULL)
    {
        copy(temp_mask, blocked_call->oldMask);
    }
}

reaction SigsuspendReturnType* sigsuspend_return(void)
{
    post
    {
        CallContext    context=sigsuspend_return->context;
        ProcessState*  ps=getProcessState_CallContext(context);
        SigsuspendCall*     pCall= findBlockedCall(@getBlockedCalls(), context);
        ThreadState* thSt = getThreadState_CallContext(context);


        VERBOSE("Sigsuspend reaction start\n");

        /*
        * Since sigsuspend() suspends thread execution indefinitely, there is no
        * successful completion return value
        */
        REQ("sigsuspend.06", "Function shall always return -1", sigsuspend_return->funcRes == -1);

        /*
        * If the action is to execute a signal-catching function
        *
        * then sigsuspend() shall return after the signal-catching function returns
        */
        REQ("sigsuspend.04.01", "Signal shall be processed", size_Map(ps->processed_signals) > size_Map(pCall->oldProcessedSignals));

        /*
        * This shall not cause any other signals that may have been pending on the
        * process to become pending on the thread.
        */
        REQ("sigsuspend.02", "", TODO_REQ());

        if (pCall->oldMask!=NULL)
        {
            Set* temp_mask = get_List(thSt->signal_masks_stack, 0);

            /*
            * If the action is to execute a signal-catching function
            *
            * with the signal mask restored to the set that existed prior to the sigsuspend()
            * call
            */
            REQ("?sigsuspend.04.02", "Thread signal mask shall be restored", equals(pCall->oldMask, temp_mask));
        }

        /*
        * It is not possible to block signals that cannot be ignored. This is enforced by
        * the system without causing an error to be indicated
        */
        REQ("sigsuspend.05", "", TODO_REQ());

        /*
        * If a return occurs, -1 shall be returned and errno set to indicate the error.
        */
        ERROR_BEGIN(POSIX_SIGSUSPEND, "sigsuspend.07", sigsuspend_return->funcRes == -1, *(sigsuspend_return->errno))

        /*
        * The sigsuspend() function shall fail if
        *
        * [EINTR] A signal is caught by the calling process and control is returned from
        * the signal-catching function.
        */
        ERROR_SHALL(POSIX_SIGSUSPEND, EINTR, "sigsuspend.08.01", true)

        ERROR_END()


       

        VERBOSE("Sigsuspend reaction end\n");

        return true;
    }
}

/********************************************************************/
/**       Catcher void f(int signo) returns right away as start    **/
/********************************************************************/
reaction UserCatcherHandlerStartReactionType* user_catcher_handler_reaction_start(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {

        return true;
    }
    post
    {


        prSt = getProcessState_ThreadId(user_catcher_handler_reaction_start->thr_st->id);



        traceFormattedUserInfo("Signal $(obj) was recieved in process $(obj) and thread $(obj)", create_IntTObj(*(user_catcher_handler_reaction_start->signo)), create_IntTObj(user_catcher_handler_reaction_start->thr_st->id.process),

            create_ULongTObj(user_catcher_handler_reaction_start->thr_st->id.thread));



        sa = get_Map(prSt->signal_actions, create_SignalObj(*user_catcher_handler_reaction_start->signo));
        /*
         * Can't react when process is zombie
         */
        REQ("", "Process should not be zombie to do this call", !isProcessZombie(prSt));

        REQ("", "Signal action should be set", sa != NULL);

        REQ("", "Signal should not be stopped", !prSt->is_stopped);

        REQ("",
            "Signals SIGSTOP and SIGKILL couldn't be catched",
            ((*user_catcher_handler_reaction_start->signo != SUT_SIGKILL) &&
             (*user_catcher_handler_reaction_start->signo != SUT_SIGSTOP)));

        /*
         * If the SA_SIGINFO flag (see below) is cleared in the sa_flags field of the
         * sigaction structure, the sa_handler field identifies the action to be
         * associated with the specified signal
         */
        REQ("sigaction.08", "Handler shall be valid", sa->m_sa_handler == SIG_USER_CATCHER);

        return user_catcher_handler_reaction_start->was_set;
    }
}

void sigaction_catcher_start_model(UserCatcherHandlerStartReactionType* react)
{
    ProcessState*  prSt;
    List* temp_list;
    SigAction* sa;
    Set* temp_set;
    CalledFunctionDescription* temp_func_desc;
    CalledFunctionDescription* temp_func_desc2;

    verbose("start handler \n");
    prSt = getProcessState_ThreadId(react->thr_st->id);
    sa = get_Map(prSt->signal_actions, create_SignalObj(*react->signo));

    if (sa == NULL)
    {
        verbose("signal action need default sigaction for Signal %d\n", *(react->signo));
        PrintfProcessSignalActions(prSt);
        return;
    }

    if (sa->m_sa_flag.SA_RESETHAND_Flag)
    {
        /*
         * SA_RESETHAND
         *
         * SIGILL and SIGTRAP cannot be automatically reset when delivered; the system
         * silently enforces this restriction
         */
        IMPLEMENT_REQ("sigaction.14.02");

        if (((*react->signo) != SUT_SIGILL) && ((*react->signo) != SUT_SIGTRAP))
        {
            /*
             * SA_RESETHAND
             * If set, the disposition of the signal shall be reset to
             * SIG_DFL and the SA_SIGINFO flag shall be cleared on entry
             * to the signal handler
             */
            IMPLEMENT_REQ("sigaction.14.01");

            /*
             * Once an action is installed for a specific signal, it shall
             * remain installed until another action is explicitly requested
             * (by another call to sigaction()), [XSI]  until the SA_RESETHAND
             * flag causes resetting of the handler,  or until one of the exec
             * functions is called
             */
            IMPLEMENT_REQ("sigaction.29");

            sa->m_sa_handler = SUT_SIG_DFL;
            sa->m_sa_flag.SA_SIGINFO_Flag = false;
        }
    }
    else
    {
        /*
        * SA_RESETHAND
        *
        * Otherwise, the disposition of the signal shall not be modified on entry to the
        * signal handler
        */
        IMPLEMENT_REQ("sigaction.14.03");
    }

    //list for every threadState is already exists
    if (size_List(react->thr_st->signal_masks_stack) > 0)
    {
        /*
         * When a signal is caught by a signal-catching function installed
         * by sigaction(), a new signal mask is calculated and
         * installed for the duration of the signal-catching function
         * (or until a call to either sigprocmask() or sigsuspend() is
         * made). This mask is formed by taking the union of the current
         * signal mask and the value of the sa_mask for the signal being
         * delivered unless SA_NODEFER or SA_RESETHAND is set, and
         * then including the signal being delivered.
         */
        IMPLEMENT_REQ("sigaction.27");

        temp_set = get_List(react->thr_st->signal_masks_stack, 0);
    }
    else
    {
        temp_set = create_Set(&type_SignalObj);
    }

    addAll_Set(temp_set, sa->m_sa_mask);

    if (sa->m_sa_flag.SA_RESETHAND_Flag || sa->m_sa_flag.SA_NODEFER_Flag)
    {
        /*
         * SA_RESETHAND
         *
         * In addition, if this flag is set, sigaction() behaves as if the
         * SA_NODEFER flag were also set
         */
        IMPLEMENT_REQ("sigaction.14.04");

        /*
         * SA_NODEFER
         *
         * If set and sig is caught, sig shall not be added to the
         * thread's signal mask on entry to the signal handler unless
         * it is included in sa_mask
         */
        IMPLEMENT_REQ("sigaction.25.01");

        add_Set(temp_set, create_SignalObj(*(react->signo)));
    }
    else
    {
        /*
         * SA_NODEFER
         *
         * Otherwise, sig shall always be added to the thread's signal
         * mask on entry to the signal handler
         */
        IMPLEMENT_REQ("sigaction.25.02");
    }
    /*
     * When a signal is caught by a signal-catching function installed
     * by sigaction(), a new signal mask is calculated and
     * installed for the duration of the signal-catching function
     * (or until a call to either sigprocmask() or sigsuspend() is
     * made). This mask is formed by taking the union of the current
     * signal mask and the value of the sa_mask for the signal being
     * delivered unless SA_NODEFER or SA_RESETHAND is set, and
     * then including the signal being delivered.
     */
    IMPLEMENT_REQ("sigaction.27");

    add_List(react->thr_st->signal_masks_stack, 0, temp_set);

    temp_list = get_Map(prSt->signal_queue, create_SignalObj(*react->signo));
    if (temp_list == NULL)
    {
        temp_list = create_List(&type_SignalObj);
    }

    if(size_List(temp_list) > 0)
    {
        traceUserInfo("Good sequence");
        remove_All_Signals_from_Model(prSt, react->signo);
        react->was_set = true;
    }
    else
    {
        traceUserInfo("Wrong sequence, no signal with this number was generated before catcher was called");
        react->was_set = false;
    }

    //make the previous stack of calls to know, that handler was called after it
    temp_func_desc = get_List(react->thr_st->stack_of_calls, 0);
    temp_func_desc->function_nested = CALLED_HANDLER;

    temp_func_desc2 = create_CalledFunctionDescription(MakeFunctionCallUID(react->thr_st), CALLED_HANDLER, CALLED_NONE);
    add_List(react->thr_st->stack_of_calls, 0, temp_func_desc2);

    if ((*react->signo == SUT_SIGSTOP) || (*react->signo == SUT_SIGTSTP) ||
        (*react->signo == SUT_SIGTTIN) || (*react->signo == SUT_SIGTTOU))
    {
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGCONT));
    }

}


void on_user_catcher_handler_reaction_start(UserCatcherHandlerStartReactionType* react)
{
    sigaction_catcher_start_model(react);
}

reaction UserCatcherHandlerFinishReactionType* user_catcher_handler_reaction_finish(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        prSt = getProcessState_CallContext(user_catcher_handler_reaction_finish->thr_st->id);
        /*
         * Can't react when process is zombie
         */
        REQ("", "Process should not be zombie to do this call", !isProcessZombie(prSt));


        return true;
    }
}

void sigaction_catcher_finish_model(UserCatcherHandlerFinishReactionType* react)
{
    ProcessState* prSt;
    prSt = getProcessState_ThreadId (react->thr_st->id);

    /*
     * If and when the user's signal handler returns normally, the original signal
     * mask is restored
     */
    IMPLEMENT_REQ("sigaction.28");

    remove_List(react->thr_st->signal_masks_stack, 0);
    remove_List(react->thr_st->stack_of_calls, 0);
}

void on_user_catcher_handler_reaction_finish(UserCatcherHandlerFinishReactionType* react)
{
    sigaction_catcher_finish_model(react);
}

/********************************************************************/
/**           Catcher void f(int signo) listen for commands        **/
/********************************************************************/
reaction UserAgentHandlerStartReactionType* user_agent_handler_reaction_start(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        prSt = getProcessState_ThreadId(user_agent_handler_reaction_start->thr_st->id);
        sa = get_Map(prSt->signal_actions, create_SignalObj(*user_agent_handler_reaction_start->signo));

        REQ("", "Signal should not be stopped", !prSt->is_stopped);
        return user_agent_handler_reaction_start->was_set;
    }
}

void sigaction_user_agent_handler_start_model(UserAgentHandlerStartReactionType* react)
{
    ProcessState*  prSt;
    List* temp_list;
    SigAction* sa;

    prSt = getProcessState_ThreadId(react->thr_st->id);
    sa = get_Map(prSt->signal_actions, create_SignalObj(*react->signo));

    if (sa->m_sa_flag.SA_RESETHAND_Flag)
    {
        /*
         * SA_RESETHAND
         *
         * SIGILL and SIGTRAP cannot be automatically reset when delivered; the system
         * silently enforces this restriction
         */
        IMPLEMENT_REQ("sigaction.14.02");

        if (((*react->signo) != SUT_SIGILL) && ((*react->signo) != SUT_SIGTRAP))
        {
            /*
             * SA_RESETHAND
             * If set, the disposition of the signal shall be reset to
             * SIG_DFL and the SA_SIGINFO flag shall be cleared on entry
             * to the signal handler
             */
            IMPLEMENT_REQ("sigaction.14.01");

            sa->m_sa_handler = SUT_SIG_DFL;
            sa->m_sa_flag.SA_SIGINFO_Flag = false;
        }
    }
    else
    {
        /*
         * SA_RESETHAND
         *
         * Otherwise, the disposition of the signal shall not be modified on entry to the
         * signal handler
         */
        IMPLEMENT_REQ("sigaction.14.03");
    }

    temp_list = get_Map(prSt->signal_queue, create_SignalObj(*react->signo));

    if(size_List(temp_list) > 0)
    {
        traceUserInfo("Good sequence");
        remove_All_Signals_from_Model(prSt, react->signo);
        react->was_set = true;
    }
    else
    {
        traceUserInfo("Wrong sequence, no signal with this number was generated before catcher was called");
        react->was_set = false;
    }

    if (*react->signo == SUT_SIGCONT)
    {
        prSt->is_stopped = false;
    }

    if (*react->signo == SUT_SIGCONT)
    {
        prSt->is_stopped = false;
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGSTOP));
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGTSTP));
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGTTIN));
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGTTOU));
    }

    if ((*react->signo == SUT_SIGSTOP) || (*react->signo == SUT_SIGTSTP) ||
        (*react->signo == SUT_SIGTTIN) || (*react->signo == SUT_SIGTTOU))
    {
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGCONT));
    }

}

void on_user_agent_handler_reaction_start(UserAgentHandlerStartReactionType* react)
{
    sigaction_user_agent_handler_start_model(react);
}

reaction UserAgentHandlerFinishReactionType* user_agent_handler_reaction_finish(void)
{
    ProcessState* prSt;
    ThreadState* thrSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        VERBOSE("Handler end\n");
        return true;
    }
}

void on_user_agent_handler_reaction_finish(UserAgentHandlerFinishReactionType* react)
{
    remove_List(react->thr_st->signal_masks_stack, 0);
}
/********************************************************************/
/**      Catcher void f(int signo, siginfo_t *info, void *context) **/
/**                returns right away as start                     **/
/********************************************************************/
reaction UserCatcherSigactionStartReactionType* user_catcher_sigaction_reaction_start(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        prSt = getProcessState_ThreadId(user_catcher_sigaction_reaction_start->thr_st->id);
        sa = get_Map(prSt->signal_actions, create_SignalObj(*user_catcher_sigaction_reaction_start->signo));

        /*
         * Can't react when process is zombie
         */
        REQ("", "Process should not be zombie to do this call", !isProcessZombie(prSt));
        REQ("", "Process should not be stopped in this place", prSt->is_stopped == false);
        REQ("",
            "Signals SIGSTOP and SIGKILL couldn't be catched",
            ((*user_catcher_sigaction_reaction_start->signo != SUT_SIGKILL) &&
             (*user_catcher_sigaction_reaction_start->signo != SUT_SIGSTOP)));

        if (sa->m_sa_flag.SA_SIGINFO_Flag)
        {
            /*
             * [XSI|RTS] If SA_SIGINFO is set and the signal is caught, the
             * signal-catching function shall be entered as:
             * void func(int signo, siginfo_t *info, void *context);
             * where two additional arguments are passed to the signal-catching
             * function. The second argument shall point to an object of type
             * siginfo_t explaining the reason why the signal was generated;
             * the third argument can be cast to a pointer to an object of
             * type ucontext_t to refer to the receiving thread's context that
             * was interrupted when the signal was delivered. In this case,
             * the application shall use the sa_sigaction member to describe
             * the signal-catching function and the application shall not modify
             * the sa_handler member.
             */
            REQ("sigaction.21",
                "If SA_SIGINFO is set, catcher call shall be void catcher(int, siginfo_t, void*)",
                (sa->m_sa_flag.SA_SIGINFO_Flag == true));
        }
        else
        {
            /*
             * SA_SIGINFO
             *
             * If cleared and the signal is caught, the signal-catching
             * function shall be entered as: void func(int signo);
             * where signo is the only argument to the signal-catching
             * function. In this case, the application shall use the
             * sa_handler member to describe the signal-catching function and
             * the application shall not modify the sa_sigaction member.
             */
            REQ("sigaction.20.01", "If SA_SIGINFO is not set, catcher shall be void catcher(int)", false);

        }
        return user_catcher_sigaction_reaction_start->was_set;
    }
}

void on_user_catcher_sigaction_reaction_start(UserCatcherSigactionStartReactionType* react)
{
    ProcessState*  prSt;
    List* temp_list;
    SigAction* sa;
    Set* temp_set;
    CalledFunctionDescription* temp_func_desc;
    CalledFunctionDescription* temp_func_desc2;

    verbose("start catcher \n");
    prSt = getProcessState_ThreadId(react->thr_st->id);
    sa = get_Map(prSt->signal_actions, create_SignalObj(*react->signo));


    if (sa->m_sa_flag.SA_RESETHAND_Flag)
    {
        if (((*react->signo) != SUT_SIGILL) && ((*react->signo) != SUT_SIGTRAP))
        {
            sa->m_sa_handler = SUT_SIG_DFL;
            sa->m_sa_flag.SA_SIGINFO_Flag = false;
        }
    }

    //list for every threadState is already exists
    if (size_List(react->thr_st->signal_masks_stack) > 0)
    {
        temp_set = get_List(react->thr_st->signal_masks_stack, 0);
    }
    else
    {
        temp_set = create_Set(&type_SignalObj);
    }

    addAll_Set(temp_set, sa->m_sa_mask);

    if (sa->m_sa_flag.SA_RESETHAND_Flag || sa->m_sa_flag.SA_NODEFER_Flag)
    {
        add_Set(temp_set, create_SignalObj(*(react->signo)));
    }
    add_List(react->thr_st->signal_masks_stack, 0, temp_set);

    temp_list = get_Map(prSt->signal_queue, create_SignalObj(*react->signo));
    if (temp_list == NULL)
    {
        temp_list = create_List(&type_SignalObj);
    }

    if(size_List(temp_list) > 0)
    {
        traceUserInfo("Good sequence");
        remove_All_Signals_from_Model(prSt, react->signo);
        react->was_set = true;
    }
    else
    {
        traceUserInfo("Wrong sequence, no signal with this number was generated before catcher was called");
        react->was_set = false;
    }

    //make the previous stack of calls to know, that handler was called after it
    temp_func_desc = get_List(react->thr_st->stack_of_calls, 0);
    temp_func_desc->function_nested = CALLED_HANDLER;

    temp_func_desc2 = create_CalledFunctionDescription(MakeFunctionCallUID(react->thr_st), CALLED_HANDLER, CALLED_NONE);
    add_List(react->thr_st->stack_of_calls, 0, temp_func_desc2);

    if (*react->signo == SUT_SIGCONT)
    {
        prSt->is_stopped = false;
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGSTOP));
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGTSTP));
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGTTIN));
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGTTOU));
    }

    if ((*react->signo == SUT_SIGSTOP) || (*react->signo == SUT_SIGTSTP) ||
        (*react->signo == SUT_SIGTTIN) || (*react->signo == SUT_SIGTTOU))
    {
        remove_Map(prSt->signal_queue, create_SignalObj(SUT_SIGCONT));
    }
}

reaction UserCatcherSigactionFinishReactionType* user_catcher_sigaction_reaction_finish(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        prSt = getProcessState_CallContext(user_catcher_sigaction_reaction_finish->thr_st->id);
        /*
         * Can't react when process is zombie
         */
        REQ("", "Process should not be zombie to do this call", !isProcessZombie(prSt));
        VERBOSE("Handler end\n");

        return true;
    }
}

void on_user_catcher_sigaction_reaction_finish(UserCatcherSigactionFinishReactionType* react)
{
    remove_List(react->thr_st->signal_masks_stack, 0);
    remove_List(react->thr_st->stack_of_calls, 0);
}
/********************************************************************/
/**      Catcher void f(int signo, siginfo_t *info, void *context) **/
/**                      listen for commands                       **/
/********************************************************************/
reaction UserAgentSigactionStartReactionType* user_agent_sigaction_reaction_start(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        prSt = getProcessState_ThreadId(user_agent_sigaction_reaction_start->thr_st->id);
        sa = get_Map(prSt->signal_actions, create_SignalObj(*user_agent_sigaction_reaction_start->signo));


        return user_agent_sigaction_reaction_start->was_set;
    }
}

void on_user_agent_sigaction_reaction_start(UserAgentSigactionStartReactionType* react)
{
    //if this thread was waiting for the signal, continue execution
}

reaction UserAgentSigactionFinishReactionType* user_agent_sigaction_reaction_finish(void)
{
    ProcessState* prSt;
    SigAction* sa;
    pre
    {
        return true;
    }
    post
    {
        VERBOSE("Handler end\n");
        return true;
   }
}

void on_user_agent_sigaction_reaction_finish(UserAgentSigactionFinishReactionType* react)
{
    remove_List(react->thr_st->signal_masks_stack, 0);
}

/********************************************************************/
/**                      Data Types Definitions                    **/
/********************************************************************/

specification typedef struct Pthread_SigmaskReactionType Pthread_SigmaskReactionType = {};
specification typedef struct Pthread_Sigmask_BlockedCallParams Pthread_Sigmask_BlockedCallParams = {};

specification typedef struct SigprocmaskReactionType SigprocmaskReactionType = {};
specification typedef struct Sigprocmask_BlockedCallParams Sigprocmask_BlockedCallParams = {};

specification typedef struct UserCatcherHandlerStartReactionType UserCatcherHandlerStartReactionType = {};
specification typedef struct UserCatcherHandlerFinishReactionType UserCatcherHandlerFinishReactionType = {};

specification typedef struct UserAgentHandlerStartReactionType UserAgentHandlerStartReactionType = {};
specification typedef struct UserAgentHandlerFinishReactionType UserAgentHandlerFinishReactionType = {};

specification typedef struct UserCatcherSigactionStartReactionType UserCatcherSigactionStartReactionType = {};
specification typedef struct UserCatcherSigactionFinishReactionType UserCatcherSigactionFinishReactionType = {};

specification typedef struct UserAgentSigactionStartReactionType UserAgentSigactionStartReactionType = {};
specification typedef struct UserAgentSigactionFinishReactionType UserAgentSigactionFinishReactionType = {};

specification typedef struct PauseCall PauseCall = {};
specification typedef struct PauseReturnType PauseReturnType = {};

specification typedef struct StackT  StackT = {};
specification typedef struct SigaltstackReturnType SigaltstackReturnType = {};

specification typedef struct SigsuspendCall SigsuspendCall = {};
specification typedef struct SigsuspendReturnType SigsuspendReturnType = {};

/********************************************************************/
/**                       Helper Functions                         **/
/********************************************************************/
/*
 * return number of deleted signals in the queue and add this signals to
 * processed signals
 */
int remove_All_Signals_from_Model(ProcessState* pr_st_get, Signal* sig)
{
    List* temp_list;
    List* new_list;
    int size_list, counter;
    SignalParams* params;


    temp_list = get_Map(pr_st_get->processed_signals, create_SignalObj(*sig));
    if (temp_list == NULL)
    {
        temp_list = create_List(&type_List);
        //add empty list if there wasn't any (needs to provide deterministic serialization)
        put_Map(pr_st_get->processed_signals, create_SignalObj(*sig), temp_list);
    }

    temp_list = remove_Map(pr_st_get->signal_queue, create_SignalObj(*sig));
    if (temp_list == NULL)
    {
        return 0;
    }

    size_list = size_List(temp_list);
    new_list = create_List(&type_IntTObj);
    for (counter = 0; counter < size_list; counter++)
    {
        params = get_List(temp_list, counter);
        if (params->returned_kill == true)
        {
            return size_list;//if one of the kill has already successfully returned
        }
        append_List(new_list, create_IntTObj(params->unique_id));
    }

    temp_list = get_Map(pr_st_get->processed_signals, create_SignalObj(*sig));
    append_List(temp_list, new_list);
    put_Map(pr_st_get->processed_signals, create_SignalObj(*sig), temp_list);
    return size_list;
}

Pthread_Sigmask_BlockedCallParams* create_Pthread_Sigmask_BlockedCallParams(int uid, int how, SigSetTPtr set,
                                                                            Set* old_mask, bool need_handler, bool singleThreaded)
{
    return create(&type_Pthread_Sigmask_BlockedCallParams, uid, how, set, old_mask, need_handler, singleThreaded);
}

Pthread_SigmaskReactionType* create_Pthread_SigmaskReactionType(CallContext context, IntT res, CalledFunctionDescription* called_func,
                                                                Pthread_Sigmask_BlockedCallParams* params)
{
    return create(&type_Pthread_SigmaskReactionType, context, res, called_func, params);
}

Sigprocmask_BlockedCallParams* create_Sigprocmask_BlockedCallParams(int uid, int how, SigSetTPtr set,
                                                                            Set* old_mask, bool need_handler)
{
    return create(&type_Sigprocmask_BlockedCallParams, uid, how, set, old_mask, need_handler);
}

SigprocmaskReactionType* create_SigprocmaskReactionType(CallContext context, IntT res, ErrorCode* errno, CalledFunctionDescription* called_func,
                                                        Pthread_Sigmask_BlockedCallParams* params)
{
    return create(&type_SigprocmaskReactionType, context, res, errno, called_func, params);
}

UserCatcherHandlerStartReactionType* create_UserCatcherHandlerStartReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserCatcherHandlerStartReactionType, thr_st, sig, true);
}
UserCatcherHandlerFinishReactionType* create_UserCatcherHandlerFinishReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserCatcherHandlerFinishReactionType, thr_st, sig, true);
}

UserAgentHandlerStartReactionType* create_UserAgentHandlerStartReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserAgentHandlerStartReactionType, thr_st, sig, true);
}
UserAgentHandlerFinishReactionType* create_UserAgentHandlerFinishReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserAgentHandlerFinishReactionType, thr_st, sig, true);
}


UserCatcherSigactionStartReactionType* create_UserCatcherSigactionStartReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserCatcherSigactionStartReactionType, thr_st, sig, true);
}
UserCatcherSigactionFinishReactionType* create_UserCatcherSigactionFinishReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserCatcherSigactionFinishReactionType, thr_st, sig, true);
}

UserAgentSigactionStartReactionType* create_UserAgentSigactionStartReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserAgentSigactionStartReactionType, thr_st, sig, true);
}
UserAgentSigactionFinishReactionType* create_UserAgentSigactionFinishReactionType(ThreadState*  thr_st, Signal* sig)
{
    return create(&type_UserAgentSigactionFinishReactionType, thr_st, sig, true);
}

PauseCall * create_PauseCall(CallContext context, Map* oldProcessedSignals)
{
    return create(&type_PauseCall, context, oldProcessedSignals);
}

PauseReturnType* create_PauseReturnType(CallContext context, IntT funcRes, ErrorCode* errno)
{
    return create(&type_PauseReturnType, context, funcRes, errno);
}

StackT* create_StackT(VoidTPtr ss_sp, IntT ss_flags, SizeT ss_size)
{
    return create(&type_StackT, ss_sp, ss_flags, ss_size);
}

SigaltstackReturnType* create_SigaltstackReturnType(IntT funcRes, StackT* oldSs, SizeT minsigstcksz)
{
    return create(&type_SigaltstackReturnType, funcRes, oldSs, minsigstcksz);
}

SigsuspendCall * create_SigsuspendCall(CallContext context, SigSet* sigmask, Map* oldProcessedSignals, Set* oldMask)
{
    return create(&type_SigsuspendCall, context, sigmask, oldProcessedSignals, oldMask);
}

SigsuspendReturnType* create_SigsuspendReturnType(CallContext context, IntT funcRes, ErrorCode* errno)
{
    return create(&type_SigsuspendReturnType, context, funcRes, errno);
}

/********************************************************************/
/**                Helper Informative Functions                    **/
/********************************************************************/
/*
 * Returns set of signals which can be delivered to the thread with CallContext
 * context, when signal mask is equals to sigmask, return type Set* of SignalObj
 */
Set* CanBeDelivered(CallContext context, Set* sigmask)
{
    ThreadState* thSt  =  getThreadState_CallContext(context);
    ProcessState* prSt = getProcessState_CallContext(context);
    int i, size;
    List* temp_list;
    SignalObj* sigobj;
    Set* res;

    res = create_Set(&type_SignalObj);

    size = size_Map(prSt->signal_queue); //processes signals
    for (i = 0; i < size; i++)
    {
        sigobj = create_SignalObj(i);
        if (!contains_Set(sigmask, sigobj))
        {
            temp_list = get_Map(prSt->signal_queue, sigobj);
            if ((temp_list != NULL) && (size_List(temp_list) > 0))
            {
                add_Set(res, sigobj);
            }
        }
    }

    size = size_Map(thSt->signal_queue); //threads signals
    for(i = 0; i < size; i++)
    {
        sigobj = create_SignalObj(i);
        if (!contains_Set(sigmask, sigobj))
        {
            temp_list = get_Map(thSt->signal_queue, sigobj);
            if (size_List(temp_list) > 0)
            {
                add_Set(res, sigobj);
            }
        }
    }
    return res;
}

bool isValidNotReaitimeSignal(Signal* sig)
{
    return (*sig >= 1) && (*sig <= SIGDEFF);
}

bool isCannotCatch(Signal* sig)
{
    return (*sig == SUT_SIGKILL) || (*sig == SUT_SIGSTOP);
}

bool isCannotIgnore(Signal* sig)
{
    return (*sig == SUT_SIGKILL) || (*sig == SUT_SIGSTOP);
}

bool isRealtimeSignal(Signal* sig, CallContext context)
{
    /*
     * Constants SIGRTMIN and SIGRTMAX should be initialized by calling
     * __libc_current_sigrtmax_spec and __libc_current_sigrtmin_spec functions
     */
    SystemState*  systemState  = getSystemState_CallContext(context);
    return ((*sig >= systemState->configuration->sigrtmin) &&
            (*sig <= systemState->configuration->sigrtmax));
}

bool isNotValidSignal(Signal* sig, CallContext context)
{
    /*
     * __libc_current_sigrtmax_spec and __libc_current_sigrtmin_spec functions
     * should be called before this function call
     */
    return (!isValidNotReaitimeSignal(sig)) &&
           (!REALTIME_OPTION || !isRealtimeSignal(sig, context));
}

bool isUseUserCatcher(SignalHandler h)
{
    if ((h == SIG_USER_CATCHER) || (h == SIG_USER_AGENT))
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool isWaitingForSignal(Signal* sig, CallContext context)
{
    return false;
}

IntT convertSignalFlagsToIntT(SigActionFlag* sigflags)
{
    IntT res = 0;
    if (sigflags->SA_NOCLDSTOP_Flag)
    {
        res = res | SUT_SA_NOCLDSTOP;
    }
    if (sigflags->SA_ONSTACK_Flag)
    {
        res = res | SUT_SA_ONSTACK;
    }
    if (sigflags->SA_RESETHAND_Flag)
    {
        res = res | SUT_SA_RESETHAND;
    }
    if (sigflags->SA_RESTART_Flag)
    {
        res = res | SUT_SA_RESTART;
    }
    if (sigflags->SA_INTERRUPT_Flag)
    {
        res = res | SUT_SA_INTERRUPT;
    }
    if (sigflags->SA_SIGINFO_Flag)
    {
        res = res | SUT_SA_SIGINFO;
    }
    if (sigflags->SA_NOCLDWAIT_Flag)
    {
        res = res | SUT_SA_NOCLDWAIT;
    }
    if (sigflags->SA_NODEFER_Flag)
    {
        res = res | SUT_SA_NODEFER;
    }
    return res;
}


int  getNumberUnblockedRealtimeSignals(CallContext context, Signal* rt_min_sig, Signal* rt_max_sig)
{
    int res = 0;
    int i;
    ProcessState* pr_st = getProcessState_CallContext(context);
    ThreadState* thr_st = getThreadState_CallContext(context);
    Set* sigmask = get_List(thr_st->signal_masks_stack, 0);
    List* pr_sig_list;
    List* thr_sig_list;

    for (i = *rt_min_sig; i <= *rt_max_sig; i++)
    {
        if (!contains_Set(sigmask, create_SignalObj(i)))
        {
            pr_sig_list = get_Map(pr_st->signal_queue, create_SignalObj(i));
            thr_sig_list = get_Map(thr_st->signal_queue, create_SignalObj(i));

            if ((pr_sig_list != NULL) && (size_List(pr_sig_list) > 0))
            {
                res++;
            }
            else if ((thr_sig_list != NULL) && (size_List(thr_sig_list) > 0))
            {
                res++;
            }
        }
    }
    return res;
}

bool isMinimalUnblockedRealtimeSignal(CallContext context, Signal* rt_min_sig, Signal* sig)
{
    ProcessState* pr_st = getProcessState_CallContext(context);
    ThreadState* thr_st = getThreadState_CallContext(context);
    Set* sigmask = get_List(thr_st->signal_masks_stack, 0);
    List* pr_sig_list;
    List* thr_sig_list;
    int i;

    for (i = *rt_min_sig; i < *sig; i++)
    {
        if (!contains_Set(sigmask, create_SignalObj(i)))
        {
            pr_sig_list = get_Map(pr_st->signal_queue, create_SignalObj(i));
            thr_sig_list = get_Map(thr_st->signal_queue, create_SignalObj(i));

            if ((pr_sig_list != NULL) && (size_List(pr_sig_list) > 0))
            {
                return false;
            }

            if ((thr_sig_list != NULL) && (size_List(thr_sig_list) > 0))
            {
                return false;
            }
        }
    }
    return true;
}
/********************************************************************/
/**                  Flag Convertion Functions                     **/
/********************************************************************/

SigActionFlag SignalConvertIntTToFlags(IntT value)
{
    SigActionFlag res;
    if (value & SUT_SA_NOCLDSTOP)
    {
        res.SA_NOCLDSTOP_Flag = true;
    }
    else
    {
        res.SA_NOCLDSTOP_Flag = false;
    }

    if (value & SUT_SA_ONSTACK)
    {
        res.SA_ONSTACK_Flag = true;
    }
    else
    {
        res.SA_ONSTACK_Flag = false;
    }

    if (value & SUT_SA_RESETHAND)
    {
        res.SA_RESETHAND_Flag = true;
    }
    else
    {
        res.SA_RESETHAND_Flag = false;
    }

    if (value & SUT_SA_RESTART)
    {
        res.SA_RESTART_Flag = true;
    }
    else
    {
        res.SA_RESTART_Flag = false;
    }

    if (value & SUT_SA_INTERRUPT)
    {
        res.SA_INTERRUPT_Flag = true;
    }
    else
    {
        res.SA_INTERRUPT_Flag = false;
    }

    if (value & SUT_SA_SIGINFO)
    {
        res.SA_SIGINFO_Flag = true;
    }
    else
    {
        res.SA_SIGINFO_Flag = false;
    }

    if (value & SUT_SA_NOCLDWAIT)
    {
        res.SA_NOCLDWAIT_Flag = true;
    }
    else
    {
        res.SA_NOCLDWAIT_Flag = false;
    }

    if (value & SUT_SA_NODEFER)
    {
        res.SA_NODEFER_Flag = true;
    }
    else
    {
        res.SA_NODEFER_Flag = false;
    }

    return res;
}




