/*
 * Copyright (c) 2005-2006 Institute for System Programming
 * Russian Academy of Sciences
 * All rights reserved. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "signal/sigset/tests/sigset_scenario.seh"
#include "signal/sigset/sigset_model.seh"
#include "config/system_config.seh"
#include "common/common_media.seh"
#include "common/common_scenario.seh"

/*
 * variables for sigset_automatic_scenario
 */
static CallContext context;
static SigSetTPtr set1a;
static SigSet *mset1a;

/********************************************************************/
/**   Test Scenario for automatic enumeration of possibilities     **/ 
/**                    Initialization                              **/
/********************************************************************/

static bool init_sigset_auto_scenario(int argc, char** argv)
{
    /* Init test scenario data*/
    context = getContext();
  //  getSigRTConsts(context, &SIGRTMIN, &SIGRTMAX);
    init_SigRTConsts(context, &sigrtmin, &sigrtmax);

    set1a = allocateMemoryBlock(context, sizeof_SUTType("sigset_t"));
    if(isNULL_VoidTPtr(set1a)) return false;
    mset1a = create_SigSet(set1a);    
    registerObjectInMemory(set1a, 0, (Object*)mset1a);

    return true;
}

static void finish_sigset_auto_scenario(void)
{
    unregisterObjectInMemory(set1a);
    deallocateMemoryBlock(context, set1a);
}

/********************************************************************/
/**                Test Scenarios Generalized States               **/
/**                for automatic enumeration of possibilities      **/
/********************************************************************/

/*
 * Definition of system state for automatic scenario
 */
#if SIGNAL_SIGSET_INT_PAIR_GENSTATE
    specification typedef struct StateForAutoScen
    {
        int num_deff;       // Number of defined(usual) signals in the set
        int num_realtime;   // Number of realtime signals in the set       
    } StateForAutoScen = {};

    Object* getStateForAutoScen(void)
    {
        SignalObj* sig;
        int sigdeff, sigreal, i;

        sigdeff = 0;
        sigreal = 0;
        for (i = 1; i <= SIGDEFF; i++)
        {
            sig = create_SignalObj(i);
            if (contains_Set(mset1a->data, sig))
            {
                sigdeff++;
            }
        }

        for (i = sigrtmin; i <= sigrtmax; i++)
        {
            sig = create_SignalObj(i);
            if (contains_Set(mset1a->data, sig))
            {
                sigreal++;
            }
        }

        return create(&type_StateForAutoScen, sigdeff, sigreal);
    }

#else
    /*
     * State value is number of defined and realtime signals,
     * which are always supported
     */
    specification typedef struct StateForAutoScen
    {
        int signum;            
    } StateForAutoScen = {};

    StateForAutoScen * create_StateForAutoScen(int signum)
    {
        return create(&type_StateForAutoScen, signum);
    }

    Object* getStateForAutoScen(void)
    {
        SignalObj* sig;
        int sigs, i;

        sigs = 0;    
        for (i = 1; i <= sigrtmax; i++)
        {        
            if (isAlwaysSupported(i)) 
            {
                sig = create_SignalObj(i);
                if (contains_Set(mset1a->data, sig))
                {
                    sigs++;
                }
            }
        }
        return create_StateForAutoScen(sigs);
    }
#endif

/********************************************************************/
/**   Test Actions for automatic enumeration of possibilities      **/
/********************************************************************/
scenario
bool sigaddset_scen()
{
    iterate coverage sigaddset_spec.C
    {
        int j;        
        for (j = SIGDEFF - 5; j < sigrtmin + 5; j++)
        {

            if((sigaddset_spec.C == sigaddset_spec.C(context, set1a, j, requestErrorCode())) &&
                isAlwaysSupported(j))
            {
                sigaddset_spec(context, set1a, j, requestErrorCode());    
                return true;                
            }
        }
    }
    return true;
}

scenario
bool sigdelset_scen()
{
    iterate coverage sigdelset_spec.C
    {
        int j;    
        for (j = SIGDEFF - 5; j < sigrtmin + 5; j++)
        {
            if((sigdelset_spec.C == sigdelset_spec.C(context, set1a, j, requestErrorCode())) &&
                isAlwaysSupported(j))
            {
                sigdelset_spec(context, set1a, j, requestErrorCode());
                return true;
            }
        }
    }
    return true;
}

scenario
bool sigemptyset_scen()
{
    sigemptyset_spec(context, set1a, requestErrorCode());
    return true;
}

scenario
bool sigfillset_scen()
{
    sigfillset_spec(context, set1a, requestErrorCode());
    return true;
}
scenario
bool sigisemptyset_scen()
{
    sigisemptyset_spec(context, set1a, requestErrorCode());
    return true;
}

scenario
bool sigismember_scen()
{
    iterate(int i = 1; i <= sigrtmax; i++; (i % 6 == 1) && isAlwaysSupported(i))
    {
        sigismember_spec(context, set1a, i, requestErrorCode());
    }
    return true;
}
/********************************************************************/
/**         Test Scenario Definition for automatic                 **/
/**            enumeration of possibilities                        **/
/********************************************************************/

scenario dfsm sigset_automatic_scenario =
{
    .init = init_sigset_auto_scenario,
    .finish = finish_sigset_auto_scenario,
    .getState = getStateForAutoScen,
    .actions = {
        sigemptyset_scen, // Executes at first, then set1a is initialized
        sigaddset_scen,
        sigdelset_scen,
        sigfillset_scen,
        sigisemptyset_scen,
        sigismember_scen,
        NULL
    }
};
